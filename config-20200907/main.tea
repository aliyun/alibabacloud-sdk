/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  @endpointMap = {
    cn-shanghai = 'config.cn-shanghai.aliyuncs.com',
    ap-southeast-1 = 'config.ap-southeast-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('config', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ResourceDirectoryFolderNode {
  accountId?: string(name='AccountId', description='accountId'),
  children?: [
    ResourceDirectoryFolderNode
  ](name='Children', description='children'),
  displayName?: string(name='DisplayName', description='displayName'),
  folderId?: string(name='FolderId', description='folderId'),
  folderName?: string(name='FolderName', description='folderName'),
  parentFolderId?: string(name='ParentFolderId', description='parentFolderId'),
}

model ActiveAggregateConfigRulesRequest {
  aggregatorId?: string(name='AggregatorId'),
  configRuleIds?: string(name='ConfigRuleIds'),
}

model ActiveAggregateConfigRulesResponseBody = {
  operateRuleResult?: {
    operateRuleItemList?: [ 
      {
        configRuleId?: string(name='ConfigRuleId'),
        errorCode?: string(name='ErrorCode'),
        success?: boolean(name='Success'),
      }
    ](name='OperateRuleItemList'),
  }(name='OperateRuleResult'),
  requestId?: string(name='RequestId'),
}

model ActiveAggregateConfigRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ActiveAggregateConfigRulesResponseBody(name='body'),
}

async function activeAggregateConfigRulesWithOptions(request: ActiveAggregateConfigRulesRequest, runtime: Util.RuntimeOptions): ActiveAggregateConfigRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.configRuleIds)) {
    query['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ActiveAggregateConfigRules',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function activeAggregateConfigRules(request: ActiveAggregateConfigRulesRequest): ActiveAggregateConfigRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return activeAggregateConfigRulesWithOptions(request, runtime);
}

model AttachAggregateConfigRuleToCompliancePackRequest {
  aggregatorId?: string(name='AggregatorId'),
  compliancePackId?: string(name='CompliancePackId'),
  configRuleIds?: string(name='ConfigRuleIds'),
}

model AttachAggregateConfigRuleToCompliancePackResponseBody = {
  operateRuleResult?: {
    operateRuleItemList?: [ 
      {
        configRuleId?: string(name='ConfigRuleId'),
        errorCode?: string(name='ErrorCode'),
        success?: boolean(name='Success'),
      }
    ](name='OperateRuleItemList'),
  }(name='OperateRuleResult'),
  requestId?: string(name='RequestId'),
}

model AttachAggregateConfigRuleToCompliancePackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachAggregateConfigRuleToCompliancePackResponseBody(name='body'),
}

async function attachAggregateConfigRuleToCompliancePackWithOptions(request: AttachAggregateConfigRuleToCompliancePackRequest, runtime: Util.RuntimeOptions): AttachAggregateConfigRuleToCompliancePackResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.compliancePackId)) {
    query['CompliancePackId'] = request.compliancePackId;
  }
  if (!Util.isUnset(request.configRuleIds)) {
    query['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachAggregateConfigRuleToCompliancePack',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachAggregateConfigRuleToCompliancePack(request: AttachAggregateConfigRuleToCompliancePackRequest): AttachAggregateConfigRuleToCompliancePackResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachAggregateConfigRuleToCompliancePackWithOptions(request, runtime);
}

model AttachConfigRuleToCompliancePackRequest {
  compliancePackId?: string(name='CompliancePackId'),
  configRuleIds?: string(name='ConfigRuleIds'),
}

model AttachConfigRuleToCompliancePackResponseBody = {
  operateRuleResult?: {
    operateRuleItemList?: [ 
      {
        configRuleId?: string(name='ConfigRuleId'),
        errorCode?: string(name='ErrorCode'),
        success?: boolean(name='Success'),
      }
    ](name='OperateRuleItemList'),
  }(name='OperateRuleResult'),
  requestId?: string(name='RequestId'),
}

model AttachConfigRuleToCompliancePackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachConfigRuleToCompliancePackResponseBody(name='body'),
}

async function attachConfigRuleToCompliancePackWithOptions(request: AttachConfigRuleToCompliancePackRequest, runtime: Util.RuntimeOptions): AttachConfigRuleToCompliancePackResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.compliancePackId)) {
    query['CompliancePackId'] = request.compliancePackId;
  }
  if (!Util.isUnset(request.configRuleIds)) {
    query['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachConfigRuleToCompliancePack',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachConfigRuleToCompliancePack(request: AttachConfigRuleToCompliancePackRequest): AttachConfigRuleToCompliancePackResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachConfigRuleToCompliancePackWithOptions(request, runtime);
}

model CreateAggregateCompliancePackRequest {
  aggregatorId?: string(name='AggregatorId'),
  clientToken?: string(name='ClientToken'),
  compliancePackName?: string(name='CompliancePackName'),
  compliancePackTemplateId?: string(name='CompliancePackTemplateId'),
  configRules?: [ 
    {
      configRuleId?: string(name='ConfigRuleId'),
      configRuleName?: string(name='ConfigRuleName'),
      configRuleParameters?: [ 
        {
          parameterName?: string(name='ParameterName'),
          parameterValue?: string(name='ParameterValue'),
        }
      ](name='ConfigRuleParameters'),
      description?: string(name='Description'),
      managedRuleIdentifier?: string(name='ManagedRuleIdentifier'),
      riskLevel?: int32(name='RiskLevel'),
    }
  ](name='ConfigRules'),
  description?: string(name='Description'),
  riskLevel?: int32(name='RiskLevel'),
}

model CreateAggregateCompliancePackShrinkRequest {
  aggregatorId?: string(name='AggregatorId'),
  clientToken?: string(name='ClientToken'),
  compliancePackName?: string(name='CompliancePackName'),
  compliancePackTemplateId?: string(name='CompliancePackTemplateId'),
  configRulesShrink?: string(name='ConfigRules'),
  description?: string(name='Description'),
  riskLevel?: int32(name='RiskLevel'),
}

model CreateAggregateCompliancePackResponseBody = {
  compliancePackId?: string(name='CompliancePackId'),
  requestId?: string(name='RequestId'),
}

model CreateAggregateCompliancePackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAggregateCompliancePackResponseBody(name='body'),
}

async function createAggregateCompliancePackWithOptions(tmpReq: CreateAggregateCompliancePackRequest, runtime: Util.RuntimeOptions): CreateAggregateCompliancePackResponse {
  Util.validateModel(tmpReq);
  var request = new CreateAggregateCompliancePackShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.configRules)) {
    request.configRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.configRules, 'ConfigRules', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.aggregatorId)) {
    body['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.compliancePackName)) {
    body['CompliancePackName'] = request.compliancePackName;
  }
  if (!Util.isUnset(request.compliancePackTemplateId)) {
    body['CompliancePackTemplateId'] = request.compliancePackTemplateId;
  }
  if (!Util.isUnset(request.configRulesShrink)) {
    body['ConfigRules'] = request.configRulesShrink;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.riskLevel)) {
    body['RiskLevel'] = request.riskLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAggregateCompliancePack',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAggregateCompliancePack(request: CreateAggregateCompliancePackRequest): CreateAggregateCompliancePackResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAggregateCompliancePackWithOptions(request, runtime);
}

model CreateAggregateConfigDeliveryChannelRequest {
  aggregatorId?: string(name='AggregatorId'),
  clientToken?: string(name='ClientToken'),
  configurationItemChangeNotification?: boolean(name='ConfigurationItemChangeNotification'),
  configurationSnapshot?: boolean(name='ConfigurationSnapshot'),
  deliveryChannelCondition?: string(name='DeliveryChannelCondition'),
  deliveryChannelName?: string(name='DeliveryChannelName'),
  deliveryChannelTargetArn?: string(name='DeliveryChannelTargetArn'),
  deliveryChannelType?: string(name='DeliveryChannelType'),
  description?: string(name='Description'),
  nonCompliantNotification?: boolean(name='NonCompliantNotification'),
  oversizedDataOSSTargetArn?: string(name='OversizedDataOSSTargetArn'),
}

model CreateAggregateConfigDeliveryChannelResponseBody = {
  deliveryChannelId?: string(name='DeliveryChannelId'),
  requestId?: string(name='RequestId'),
}

model CreateAggregateConfigDeliveryChannelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAggregateConfigDeliveryChannelResponseBody(name='body'),
}

async function createAggregateConfigDeliveryChannelWithOptions(request: CreateAggregateConfigDeliveryChannelRequest, runtime: Util.RuntimeOptions): CreateAggregateConfigDeliveryChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configurationItemChangeNotification)) {
    query['ConfigurationItemChangeNotification'] = request.configurationItemChangeNotification;
  }
  if (!Util.isUnset(request.configurationSnapshot)) {
    query['ConfigurationSnapshot'] = request.configurationSnapshot;
  }
  if (!Util.isUnset(request.deliveryChannelCondition)) {
    query['DeliveryChannelCondition'] = request.deliveryChannelCondition;
  }
  if (!Util.isUnset(request.deliveryChannelName)) {
    query['DeliveryChannelName'] = request.deliveryChannelName;
  }
  if (!Util.isUnset(request.deliveryChannelTargetArn)) {
    query['DeliveryChannelTargetArn'] = request.deliveryChannelTargetArn;
  }
  if (!Util.isUnset(request.deliveryChannelType)) {
    query['DeliveryChannelType'] = request.deliveryChannelType;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.nonCompliantNotification)) {
    query['NonCompliantNotification'] = request.nonCompliantNotification;
  }
  if (!Util.isUnset(request.oversizedDataOSSTargetArn)) {
    query['OversizedDataOSSTargetArn'] = request.oversizedDataOSSTargetArn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAggregateConfigDeliveryChannel',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAggregateConfigDeliveryChannel(request: CreateAggregateConfigDeliveryChannelRequest): CreateAggregateConfigDeliveryChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAggregateConfigDeliveryChannelWithOptions(request, runtime);
}

model CreateAggregateConfigRuleRequest {
  aggregatorId?: string(name='AggregatorId'),
  clientToken?: string(name='ClientToken'),
  configRuleName?: string(name='ConfigRuleName'),
  configRuleTriggerTypes?: string(name='ConfigRuleTriggerTypes'),
  description?: string(name='Description'),
  excludeAccountIdsScope?: string(name='ExcludeAccountIdsScope'),
  excludeFolderIdsScope?: string(name='ExcludeFolderIdsScope'),
  excludeResourceIdsScope?: string(name='ExcludeResourceIdsScope'),
  folderIdsScope?: string(name='FolderIdsScope'),
  inputParameters?: map[string]any(name='InputParameters'),
  maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
  regionIdsScope?: string(name='RegionIdsScope'),
  resourceGroupIdsScope?: string(name='ResourceGroupIdsScope'),
  resourceTypesScope?: [ string ](name='ResourceTypesScope'),
  riskLevel?: int32(name='RiskLevel'),
  sourceIdentifier?: string(name='SourceIdentifier'),
  sourceOwner?: string(name='SourceOwner'),
  tagKeyLogicScope?: string(name='TagKeyLogicScope'),
  tagKeyScope?: string(name='TagKeyScope'),
  tagValueScope?: string(name='TagValueScope'),
}

model CreateAggregateConfigRuleShrinkRequest {
  aggregatorId?: string(name='AggregatorId'),
  clientToken?: string(name='ClientToken'),
  configRuleName?: string(name='ConfigRuleName'),
  configRuleTriggerTypes?: string(name='ConfigRuleTriggerTypes'),
  description?: string(name='Description'),
  excludeAccountIdsScope?: string(name='ExcludeAccountIdsScope'),
  excludeFolderIdsScope?: string(name='ExcludeFolderIdsScope'),
  excludeResourceIdsScope?: string(name='ExcludeResourceIdsScope'),
  folderIdsScope?: string(name='FolderIdsScope'),
  inputParametersShrink?: string(name='InputParameters'),
  maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
  regionIdsScope?: string(name='RegionIdsScope'),
  resourceGroupIdsScope?: string(name='ResourceGroupIdsScope'),
  resourceTypesScopeShrink?: string(name='ResourceTypesScope'),
  riskLevel?: int32(name='RiskLevel'),
  sourceIdentifier?: string(name='SourceIdentifier'),
  sourceOwner?: string(name='SourceOwner'),
  tagKeyLogicScope?: string(name='TagKeyLogicScope'),
  tagKeyScope?: string(name='TagKeyScope'),
  tagValueScope?: string(name='TagValueScope'),
}

model CreateAggregateConfigRuleResponseBody = {
  configRuleId?: string(name='ConfigRuleId'),
  requestId?: string(name='RequestId'),
}

model CreateAggregateConfigRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAggregateConfigRuleResponseBody(name='body'),
}

async function createAggregateConfigRuleWithOptions(tmpReq: CreateAggregateConfigRuleRequest, runtime: Util.RuntimeOptions): CreateAggregateConfigRuleResponse {
  Util.validateModel(tmpReq);
  var request = new CreateAggregateConfigRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.inputParameters)) {
    request.inputParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.inputParameters, 'InputParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.resourceTypesScope)) {
    request.resourceTypesScopeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceTypesScope, 'ResourceTypesScope', 'simple');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.aggregatorId)) {
    body['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configRuleName)) {
    body['ConfigRuleName'] = request.configRuleName;
  }
  if (!Util.isUnset(request.configRuleTriggerTypes)) {
    body['ConfigRuleTriggerTypes'] = request.configRuleTriggerTypes;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.excludeAccountIdsScope)) {
    body['ExcludeAccountIdsScope'] = request.excludeAccountIdsScope;
  }
  if (!Util.isUnset(request.excludeFolderIdsScope)) {
    body['ExcludeFolderIdsScope'] = request.excludeFolderIdsScope;
  }
  if (!Util.isUnset(request.excludeResourceIdsScope)) {
    body['ExcludeResourceIdsScope'] = request.excludeResourceIdsScope;
  }
  if (!Util.isUnset(request.folderIdsScope)) {
    body['FolderIdsScope'] = request.folderIdsScope;
  }
  if (!Util.isUnset(request.inputParametersShrink)) {
    body['InputParameters'] = request.inputParametersShrink;
  }
  if (!Util.isUnset(request.maximumExecutionFrequency)) {
    body['MaximumExecutionFrequency'] = request.maximumExecutionFrequency;
  }
  if (!Util.isUnset(request.regionIdsScope)) {
    body['RegionIdsScope'] = request.regionIdsScope;
  }
  if (!Util.isUnset(request.resourceGroupIdsScope)) {
    body['ResourceGroupIdsScope'] = request.resourceGroupIdsScope;
  }
  if (!Util.isUnset(request.resourceTypesScopeShrink)) {
    body['ResourceTypesScope'] = request.resourceTypesScopeShrink;
  }
  if (!Util.isUnset(request.riskLevel)) {
    body['RiskLevel'] = request.riskLevel;
  }
  if (!Util.isUnset(request.sourceIdentifier)) {
    body['SourceIdentifier'] = request.sourceIdentifier;
  }
  if (!Util.isUnset(request.sourceOwner)) {
    body['SourceOwner'] = request.sourceOwner;
  }
  if (!Util.isUnset(request.tagKeyLogicScope)) {
    body['TagKeyLogicScope'] = request.tagKeyLogicScope;
  }
  if (!Util.isUnset(request.tagKeyScope)) {
    body['TagKeyScope'] = request.tagKeyScope;
  }
  if (!Util.isUnset(request.tagValueScope)) {
    body['TagValueScope'] = request.tagValueScope;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAggregateConfigRule',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAggregateConfigRule(request: CreateAggregateConfigRuleRequest): CreateAggregateConfigRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAggregateConfigRuleWithOptions(request, runtime);
}

model CreateAggregateRemediationRequest {
  aggregatorId?: string(name='AggregatorId'),
  clientToken?: string(name='ClientToken'),
  configRuleId?: string(name='ConfigRuleId'),
  invokeType?: string(name='InvokeType'),
  params?: string(name='Params'),
  remediationTemplateId?: string(name='RemediationTemplateId'),
  remediationType?: string(name='RemediationType'),
  sourceType?: string(name='SourceType'),
}

model CreateAggregateRemediationResponseBody = {
  remediationId?: string(name='RemediationId'),
  requestId?: string(name='RequestId'),
}

model CreateAggregateRemediationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAggregateRemediationResponseBody(name='body'),
}

async function createAggregateRemediationWithOptions(request: CreateAggregateRemediationRequest, runtime: Util.RuntimeOptions): CreateAggregateRemediationResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.aggregatorId)) {
    body['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configRuleId)) {
    body['ConfigRuleId'] = request.configRuleId;
  }
  if (!Util.isUnset(request.invokeType)) {
    body['InvokeType'] = request.invokeType;
  }
  if (!Util.isUnset(request.params)) {
    body['Params'] = request.params;
  }
  if (!Util.isUnset(request.remediationTemplateId)) {
    body['RemediationTemplateId'] = request.remediationTemplateId;
  }
  if (!Util.isUnset(request.remediationType)) {
    body['RemediationType'] = request.remediationType;
  }
  if (!Util.isUnset(request.sourceType)) {
    body['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAggregateRemediation',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAggregateRemediation(request: CreateAggregateRemediationRequest): CreateAggregateRemediationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAggregateRemediationWithOptions(request, runtime);
}

model CreateAggregatorRequest {
  aggregatorAccounts?: [ 
    {
      accountId?: long(name='AccountId'),
      accountName?: string(name='AccountName'),
      accountType?: string(name='AccountType'),
    }
  ](name='AggregatorAccounts'),
  aggregatorName?: string(name='AggregatorName'),
  aggregatorType?: string(name='AggregatorType'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
}

model CreateAggregatorShrinkRequest {
  aggregatorAccountsShrink?: string(name='AggregatorAccounts'),
  aggregatorName?: string(name='AggregatorName'),
  aggregatorType?: string(name='AggregatorType'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
}

model CreateAggregatorResponseBody = {
  aggregatorId?: string(name='AggregatorId'),
  requestId?: string(name='RequestId'),
}

model CreateAggregatorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAggregatorResponseBody(name='body'),
}

async function createAggregatorWithOptions(tmpReq: CreateAggregatorRequest, runtime: Util.RuntimeOptions): CreateAggregatorResponse {
  Util.validateModel(tmpReq);
  var request = new CreateAggregatorShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.aggregatorAccounts)) {
    request.aggregatorAccountsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.aggregatorAccounts, 'AggregatorAccounts', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.aggregatorAccountsShrink)) {
    body['AggregatorAccounts'] = request.aggregatorAccountsShrink;
  }
  if (!Util.isUnset(request.aggregatorName)) {
    body['AggregatorName'] = request.aggregatorName;
  }
  if (!Util.isUnset(request.aggregatorType)) {
    body['AggregatorType'] = request.aggregatorType;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAggregator',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAggregator(request: CreateAggregatorRequest): CreateAggregatorResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAggregatorWithOptions(request, runtime);
}

model CreateCompliancePackRequest {
  clientToken?: string(name='ClientToken'),
  compliancePackName?: string(name='CompliancePackName'),
  compliancePackTemplateId?: string(name='CompliancePackTemplateId'),
  configRules?: [ 
    {
      configRuleId?: string(name='ConfigRuleId'),
      configRuleName?: string(name='ConfigRuleName'),
      configRuleParameters?: [ 
        {
          parameterName?: string(name='ParameterName'),
          parameterValue?: string(name='ParameterValue'),
        }
      ](name='ConfigRuleParameters'),
      description?: string(name='Description'),
      managedRuleIdentifier?: string(name='ManagedRuleIdentifier'),
      riskLevel?: int32(name='RiskLevel'),
    }
  ](name='ConfigRules'),
  description?: string(name='Description'),
  riskLevel?: int32(name='RiskLevel'),
}

model CreateCompliancePackShrinkRequest {
  clientToken?: string(name='ClientToken'),
  compliancePackName?: string(name='CompliancePackName'),
  compliancePackTemplateId?: string(name='CompliancePackTemplateId'),
  configRulesShrink?: string(name='ConfigRules'),
  description?: string(name='Description'),
  riskLevel?: int32(name='RiskLevel'),
}

model CreateCompliancePackResponseBody = {
  compliancePackId?: string(name='CompliancePackId'),
  requestId?: string(name='RequestId'),
}

model CreateCompliancePackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCompliancePackResponseBody(name='body'),
}

async function createCompliancePackWithOptions(tmpReq: CreateCompliancePackRequest, runtime: Util.RuntimeOptions): CreateCompliancePackResponse {
  Util.validateModel(tmpReq);
  var request = new CreateCompliancePackShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.configRules)) {
    request.configRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.configRules, 'ConfigRules', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.compliancePackName)) {
    body['CompliancePackName'] = request.compliancePackName;
  }
  if (!Util.isUnset(request.compliancePackTemplateId)) {
    body['CompliancePackTemplateId'] = request.compliancePackTemplateId;
  }
  if (!Util.isUnset(request.configRulesShrink)) {
    body['ConfigRules'] = request.configRulesShrink;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.riskLevel)) {
    body['RiskLevel'] = request.riskLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCompliancePack',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCompliancePack(request: CreateCompliancePackRequest): CreateCompliancePackResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCompliancePackWithOptions(request, runtime);
}

model CreateConfigDeliveryChannelRequest {
  clientToken?: string(name='ClientToken'),
  configurationItemChangeNotification?: boolean(name='ConfigurationItemChangeNotification'),
  configurationSnapshot?: boolean(name='ConfigurationSnapshot'),
  deliveryChannelCondition?: string(name='DeliveryChannelCondition'),
  deliveryChannelName?: string(name='DeliveryChannelName'),
  deliveryChannelTargetArn?: string(name='DeliveryChannelTargetArn'),
  deliveryChannelType?: string(name='DeliveryChannelType'),
  description?: string(name='Description'),
  nonCompliantNotification?: boolean(name='NonCompliantNotification'),
  oversizedDataOSSTargetArn?: string(name='OversizedDataOSSTargetArn'),
}

model CreateConfigDeliveryChannelResponseBody = {
  deliveryChannelId?: string(name='DeliveryChannelId'),
  requestId?: string(name='RequestId'),
}

model CreateConfigDeliveryChannelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateConfigDeliveryChannelResponseBody(name='body'),
}

async function createConfigDeliveryChannelWithOptions(request: CreateConfigDeliveryChannelRequest, runtime: Util.RuntimeOptions): CreateConfigDeliveryChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configurationItemChangeNotification)) {
    query['ConfigurationItemChangeNotification'] = request.configurationItemChangeNotification;
  }
  if (!Util.isUnset(request.configurationSnapshot)) {
    query['ConfigurationSnapshot'] = request.configurationSnapshot;
  }
  if (!Util.isUnset(request.deliveryChannelCondition)) {
    query['DeliveryChannelCondition'] = request.deliveryChannelCondition;
  }
  if (!Util.isUnset(request.deliveryChannelName)) {
    query['DeliveryChannelName'] = request.deliveryChannelName;
  }
  if (!Util.isUnset(request.deliveryChannelTargetArn)) {
    query['DeliveryChannelTargetArn'] = request.deliveryChannelTargetArn;
  }
  if (!Util.isUnset(request.deliveryChannelType)) {
    query['DeliveryChannelType'] = request.deliveryChannelType;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.nonCompliantNotification)) {
    query['NonCompliantNotification'] = request.nonCompliantNotification;
  }
  if (!Util.isUnset(request.oversizedDataOSSTargetArn)) {
    query['OversizedDataOSSTargetArn'] = request.oversizedDataOSSTargetArn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateConfigDeliveryChannel',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createConfigDeliveryChannel(request: CreateConfigDeliveryChannelRequest): CreateConfigDeliveryChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConfigDeliveryChannelWithOptions(request, runtime);
}

model CreateConfigRuleRequest {
  clientToken?: string(name='ClientToken'),
  configRuleName?: string(name='ConfigRuleName'),
  configRuleTriggerTypes?: string(name='ConfigRuleTriggerTypes'),
  description?: string(name='Description'),
  excludeResourceIdsScope?: string(name='ExcludeResourceIdsScope'),
  inputParameters?: map[string]any(name='InputParameters'),
  maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
  regionIdsScope?: string(name='RegionIdsScope'),
  resourceGroupIdsScope?: string(name='ResourceGroupIdsScope'),
  resourceTypesScope?: [ string ](name='ResourceTypesScope'),
  riskLevel?: int32(name='RiskLevel'),
  sourceIdentifier?: string(name='SourceIdentifier'),
  sourceOwner?: string(name='SourceOwner'),
  tagKeyLogicScope?: string(name='TagKeyLogicScope'),
  tagKeyScope?: string(name='TagKeyScope'),
  tagValueScope?: string(name='TagValueScope'),
}

model CreateConfigRuleShrinkRequest {
  clientToken?: string(name='ClientToken'),
  configRuleName?: string(name='ConfigRuleName'),
  configRuleTriggerTypes?: string(name='ConfigRuleTriggerTypes'),
  description?: string(name='Description'),
  excludeResourceIdsScope?: string(name='ExcludeResourceIdsScope'),
  inputParametersShrink?: string(name='InputParameters'),
  maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
  regionIdsScope?: string(name='RegionIdsScope'),
  resourceGroupIdsScope?: string(name='ResourceGroupIdsScope'),
  resourceTypesScopeShrink?: string(name='ResourceTypesScope'),
  riskLevel?: int32(name='RiskLevel'),
  sourceIdentifier?: string(name='SourceIdentifier'),
  sourceOwner?: string(name='SourceOwner'),
  tagKeyLogicScope?: string(name='TagKeyLogicScope'),
  tagKeyScope?: string(name='TagKeyScope'),
  tagValueScope?: string(name='TagValueScope'),
}

model CreateConfigRuleResponseBody = {
  configRuleId?: string(name='ConfigRuleId'),
  requestId?: string(name='RequestId'),
}

model CreateConfigRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateConfigRuleResponseBody(name='body'),
}

async function createConfigRuleWithOptions(tmpReq: CreateConfigRuleRequest, runtime: Util.RuntimeOptions): CreateConfigRuleResponse {
  Util.validateModel(tmpReq);
  var request = new CreateConfigRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.inputParameters)) {
    request.inputParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.inputParameters, 'InputParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.resourceTypesScope)) {
    request.resourceTypesScopeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceTypesScope, 'ResourceTypesScope', 'simple');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configRuleName)) {
    body['ConfigRuleName'] = request.configRuleName;
  }
  if (!Util.isUnset(request.configRuleTriggerTypes)) {
    body['ConfigRuleTriggerTypes'] = request.configRuleTriggerTypes;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.excludeResourceIdsScope)) {
    body['ExcludeResourceIdsScope'] = request.excludeResourceIdsScope;
  }
  if (!Util.isUnset(request.inputParametersShrink)) {
    body['InputParameters'] = request.inputParametersShrink;
  }
  if (!Util.isUnset(request.maximumExecutionFrequency)) {
    body['MaximumExecutionFrequency'] = request.maximumExecutionFrequency;
  }
  if (!Util.isUnset(request.regionIdsScope)) {
    body['RegionIdsScope'] = request.regionIdsScope;
  }
  if (!Util.isUnset(request.resourceGroupIdsScope)) {
    body['ResourceGroupIdsScope'] = request.resourceGroupIdsScope;
  }
  if (!Util.isUnset(request.resourceTypesScopeShrink)) {
    body['ResourceTypesScope'] = request.resourceTypesScopeShrink;
  }
  if (!Util.isUnset(request.riskLevel)) {
    body['RiskLevel'] = request.riskLevel;
  }
  if (!Util.isUnset(request.sourceIdentifier)) {
    body['SourceIdentifier'] = request.sourceIdentifier;
  }
  if (!Util.isUnset(request.sourceOwner)) {
    body['SourceOwner'] = request.sourceOwner;
  }
  if (!Util.isUnset(request.tagKeyLogicScope)) {
    body['TagKeyLogicScope'] = request.tagKeyLogicScope;
  }
  if (!Util.isUnset(request.tagKeyScope)) {
    body['TagKeyScope'] = request.tagKeyScope;
  }
  if (!Util.isUnset(request.tagValueScope)) {
    body['TagValueScope'] = request.tagValueScope;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConfigRule',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createConfigRule(request: CreateConfigRuleRequest): CreateConfigRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConfigRuleWithOptions(request, runtime);
}

model CreateRemediationRequest {
  clientToken?: string(name='ClientToken'),
  configRuleId?: string(name='ConfigRuleId'),
  invokeType?: string(name='InvokeType'),
  params?: string(name='Params'),
  remediationTemplateId?: string(name='RemediationTemplateId'),
  remediationType?: string(name='RemediationType'),
  sourceType?: string(name='SourceType'),
}

model CreateRemediationResponseBody = {
  remediationId?: string(name='RemediationId'),
  requestId?: string(name='RequestId'),
}

model CreateRemediationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRemediationResponseBody(name='body'),
}

async function createRemediationWithOptions(request: CreateRemediationRequest, runtime: Util.RuntimeOptions): CreateRemediationResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configRuleId)) {
    body['ConfigRuleId'] = request.configRuleId;
  }
  if (!Util.isUnset(request.invokeType)) {
    body['InvokeType'] = request.invokeType;
  }
  if (!Util.isUnset(request.params)) {
    body['Params'] = request.params;
  }
  if (!Util.isUnset(request.remediationTemplateId)) {
    body['RemediationTemplateId'] = request.remediationTemplateId;
  }
  if (!Util.isUnset(request.remediationType)) {
    body['RemediationType'] = request.remediationType;
  }
  if (!Util.isUnset(request.sourceType)) {
    body['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRemediation',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRemediation(request: CreateRemediationRequest): CreateRemediationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRemediationWithOptions(request, runtime);
}

model DeactiveAggregateConfigRulesRequest {
  aggregatorId?: string(name='AggregatorId'),
  configRuleIds?: string(name='ConfigRuleIds'),
}

model DeactiveAggregateConfigRulesResponseBody = {
  operateRuleResult?: {
    operateRuleItemList?: [ 
      {
        configRuleId?: string(name='ConfigRuleId'),
        errorCode?: string(name='ErrorCode'),
        success?: boolean(name='Success'),
      }
    ](name='OperateRuleItemList'),
  }(name='OperateRuleResult'),
  requestId?: string(name='RequestId'),
}

model DeactiveAggregateConfigRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeactiveAggregateConfigRulesResponseBody(name='body'),
}

async function deactiveAggregateConfigRulesWithOptions(request: DeactiveAggregateConfigRulesRequest, runtime: Util.RuntimeOptions): DeactiveAggregateConfigRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.configRuleIds)) {
    query['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeactiveAggregateConfigRules',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deactiveAggregateConfigRules(request: DeactiveAggregateConfigRulesRequest): DeactiveAggregateConfigRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deactiveAggregateConfigRulesWithOptions(request, runtime);
}

model DeactiveConfigRulesRequest {
  configRuleIds?: string(name='ConfigRuleIds'),
}

model DeactiveConfigRulesResponseBody = {
  operateRuleResult?: {
    operateRuleItemList?: [ 
      {
        configRuleId?: string(name='ConfigRuleId'),
        errorCode?: string(name='ErrorCode'),
        success?: boolean(name='Success'),
      }
    ](name='OperateRuleItemList'),
  }(name='OperateRuleResult'),
  requestId?: string(name='RequestId'),
}

model DeactiveConfigRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeactiveConfigRulesResponseBody(name='body'),
}

async function deactiveConfigRulesWithOptions(request: DeactiveConfigRulesRequest, runtime: Util.RuntimeOptions): DeactiveConfigRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configRuleIds)) {
    query['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeactiveConfigRules',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deactiveConfigRules(request: DeactiveConfigRulesRequest): DeactiveConfigRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deactiveConfigRulesWithOptions(request, runtime);
}

model DeleteAggregateCompliancePacksRequest {
  aggregatorId?: string(name='AggregatorId'),
  clientToken?: string(name='ClientToken'),
  compliancePackIds?: string(name='CompliancePackIds'),
  deleteRule?: boolean(name='DeleteRule'),
}

model DeleteAggregateCompliancePacksResponseBody = {
  operateCompliancePacksResult?: {
    operateCompliancePacks?: [ 
      {
        compliancePackId?: string(name='CompliancePackId'),
        errorCode?: string(name='ErrorCode'),
        success?: boolean(name='Success'),
      }
    ](name='OperateCompliancePacks'),
  }(name='OperateCompliancePacksResult'),
  requestId?: string(name='RequestId'),
}

model DeleteAggregateCompliancePacksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAggregateCompliancePacksResponseBody(name='body'),
}

async function deleteAggregateCompliancePacksWithOptions(request: DeleteAggregateCompliancePacksRequest, runtime: Util.RuntimeOptions): DeleteAggregateCompliancePacksResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.aggregatorId)) {
    body['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.compliancePackIds)) {
    body['CompliancePackIds'] = request.compliancePackIds;
  }
  if (!Util.isUnset(request.deleteRule)) {
    body['DeleteRule'] = request.deleteRule;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAggregateCompliancePacks',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAggregateCompliancePacks(request: DeleteAggregateCompliancePacksRequest): DeleteAggregateCompliancePacksResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAggregateCompliancePacksWithOptions(request, runtime);
}

model DeleteAggregateConfigRulesRequest {
  aggregatorId?: string(name='AggregatorId'),
  configRuleIds?: string(name='ConfigRuleIds'),
}

model DeleteAggregateConfigRulesResponseBody = {
  operateRuleResult?: {
    operateRuleItemList?: [ 
      {
        configRuleId?: string(name='ConfigRuleId'),
        errorCode?: string(name='ErrorCode'),
        success?: boolean(name='Success'),
      }
    ](name='OperateRuleItemList'),
  }(name='OperateRuleResult'),
  requestId?: string(name='RequestId'),
}

model DeleteAggregateConfigRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAggregateConfigRulesResponseBody(name='body'),
}

async function deleteAggregateConfigRulesWithOptions(request: DeleteAggregateConfigRulesRequest, runtime: Util.RuntimeOptions): DeleteAggregateConfigRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.configRuleIds)) {
    query['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAggregateConfigRules',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAggregateConfigRules(request: DeleteAggregateConfigRulesRequest): DeleteAggregateConfigRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAggregateConfigRulesWithOptions(request, runtime);
}

model DeleteAggregateRemediationsRequest {
  aggregatorId?: string(name='AggregatorId'),
  remediationIds?: string(name='RemediationIds'),
}

model DeleteAggregateRemediationsResponseBody = {
  remediationDeleteResults?: [ 
    {
      errorMessage?: string(name='ErrorMessage'),
      remediationId?: string(name='RemediationId'),
      success?: boolean(name='Success'),
    }
  ](name='RemediationDeleteResults'),
  requestId?: string(name='RequestId'),
}

model DeleteAggregateRemediationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAggregateRemediationsResponseBody(name='body'),
}

async function deleteAggregateRemediationsWithOptions(request: DeleteAggregateRemediationsRequest, runtime: Util.RuntimeOptions): DeleteAggregateRemediationsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.aggregatorId)) {
    body['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.remediationIds)) {
    body['RemediationIds'] = request.remediationIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAggregateRemediations',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAggregateRemediations(request: DeleteAggregateRemediationsRequest): DeleteAggregateRemediationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAggregateRemediationsWithOptions(request, runtime);
}

model DeleteAggregatorsRequest {
  aggregatorIds?: string(name='AggregatorIds'),
  clientToken?: string(name='ClientToken'),
}

model DeleteAggregatorsResponseBody = {
  operateAggregatorsResult?: {
    operateAggregators?: [ 
      {
        aggregatorId?: string(name='AggregatorId'),
        errorCode?: string(name='ErrorCode'),
        success?: boolean(name='Success'),
      }
    ](name='OperateAggregators'),
  }(name='OperateAggregatorsResult'),
  requestId?: string(name='RequestId'),
}

model DeleteAggregatorsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAggregatorsResponseBody(name='body'),
}

async function deleteAggregatorsWithOptions(request: DeleteAggregatorsRequest, runtime: Util.RuntimeOptions): DeleteAggregatorsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.aggregatorIds)) {
    body['AggregatorIds'] = request.aggregatorIds;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAggregators',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAggregators(request: DeleteAggregatorsRequest): DeleteAggregatorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAggregatorsWithOptions(request, runtime);
}

model DeleteCompliancePacksRequest {
  clientToken?: string(name='ClientToken'),
  compliancePackIds?: string(name='CompliancePackIds'),
  deleteRule?: boolean(name='DeleteRule'),
}

model DeleteCompliancePacksResponseBody = {
  operateCompliancePacksResult?: {
    operateCompliancePacks?: [ 
      {
        compliancePackId?: string(name='CompliancePackId'),
        errorCode?: string(name='ErrorCode'),
        success?: boolean(name='Success'),
      }
    ](name='OperateCompliancePacks'),
  }(name='OperateCompliancePacksResult'),
  requestId?: string(name='RequestId'),
}

model DeleteCompliancePacksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCompliancePacksResponseBody(name='body'),
}

async function deleteCompliancePacksWithOptions(request: DeleteCompliancePacksRequest, runtime: Util.RuntimeOptions): DeleteCompliancePacksResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.compliancePackIds)) {
    body['CompliancePackIds'] = request.compliancePackIds;
  }
  if (!Util.isUnset(request.deleteRule)) {
    body['DeleteRule'] = request.deleteRule;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCompliancePacks',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCompliancePacks(request: DeleteCompliancePacksRequest): DeleteCompliancePacksResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCompliancePacksWithOptions(request, runtime);
}

model DeleteRemediationsRequest {
  remediationIds?: string(name='RemediationIds'),
}

model DeleteRemediationsResponseBody = {
  remediationDeleteResults?: [ 
    {
      errorMessage?: string(name='ErrorMessage'),
      remediationId?: string(name='RemediationId'),
      success?: boolean(name='Success'),
    }
  ](name='RemediationDeleteResults'),
  requestId?: string(name='RequestId'),
}

model DeleteRemediationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRemediationsResponseBody(name='body'),
}

async function deleteRemediationsWithOptions(request: DeleteRemediationsRequest, runtime: Util.RuntimeOptions): DeleteRemediationsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.remediationIds)) {
    body['RemediationIds'] = request.remediationIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRemediations',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRemediations(request: DeleteRemediationsRequest): DeleteRemediationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRemediationsWithOptions(request, runtime);
}

model DetachAggregateConfigRuleToCompliancePackRequest {
  aggregatorId?: string(name='AggregatorId'),
  compliancePackId?: string(name='CompliancePackId'),
  configRuleIds?: string(name='ConfigRuleIds'),
}

model DetachAggregateConfigRuleToCompliancePackResponseBody = {
  operateRuleResult?: {
    operateRuleItemList?: [ 
      {
        configRuleId?: string(name='ConfigRuleId'),
        errorCode?: string(name='ErrorCode'),
        success?: boolean(name='Success'),
      }
    ](name='OperateRuleItemList'),
  }(name='OperateRuleResult'),
  requestId?: string(name='RequestId'),
}

model DetachAggregateConfigRuleToCompliancePackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachAggregateConfigRuleToCompliancePackResponseBody(name='body'),
}

async function detachAggregateConfigRuleToCompliancePackWithOptions(request: DetachAggregateConfigRuleToCompliancePackRequest, runtime: Util.RuntimeOptions): DetachAggregateConfigRuleToCompliancePackResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.compliancePackId)) {
    query['CompliancePackId'] = request.compliancePackId;
  }
  if (!Util.isUnset(request.configRuleIds)) {
    query['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachAggregateConfigRuleToCompliancePack',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachAggregateConfigRuleToCompliancePack(request: DetachAggregateConfigRuleToCompliancePackRequest): DetachAggregateConfigRuleToCompliancePackResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachAggregateConfigRuleToCompliancePackWithOptions(request, runtime);
}

model DetachConfigRuleToCompliancePackRequest {
  compliancePackId?: string(name='CompliancePackId'),
  configRuleIds?: string(name='ConfigRuleIds'),
}

model DetachConfigRuleToCompliancePackResponseBody = {
  operateRuleResult?: {
    operateRuleItemList?: [ 
      {
        configRuleId?: string(name='ConfigRuleId'),
        errorCode?: string(name='ErrorCode'),
        success?: boolean(name='Success'),
      }
    ](name='OperateRuleItemList'),
  }(name='OperateRuleResult'),
  requestId?: string(name='RequestId'),
}

model DetachConfigRuleToCompliancePackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachConfigRuleToCompliancePackResponseBody(name='body'),
}

async function detachConfigRuleToCompliancePackWithOptions(request: DetachConfigRuleToCompliancePackRequest, runtime: Util.RuntimeOptions): DetachConfigRuleToCompliancePackResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.compliancePackId)) {
    query['CompliancePackId'] = request.compliancePackId;
  }
  if (!Util.isUnset(request.configRuleIds)) {
    query['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachConfigRuleToCompliancePack',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachConfigRuleToCompliancePack(request: DetachConfigRuleToCompliancePackRequest): DetachConfigRuleToCompliancePackResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachConfigRuleToCompliancePackWithOptions(request, runtime);
}

model GenerateAggregateCompliancePackReportRequest {
  aggregatorId?: string(name='AggregatorId'),
  clientToken?: string(name='ClientToken'),
  compliancePackId?: string(name='CompliancePackId'),
}

model GenerateAggregateCompliancePackReportResponseBody = {
  compliancePackId?: string(name='CompliancePackId'),
  requestId?: string(name='RequestId'),
}

model GenerateAggregateCompliancePackReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateAggregateCompliancePackReportResponseBody(name='body'),
}

async function generateAggregateCompliancePackReportWithOptions(request: GenerateAggregateCompliancePackReportRequest, runtime: Util.RuntimeOptions): GenerateAggregateCompliancePackReportResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.aggregatorId)) {
    body['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.compliancePackId)) {
    body['CompliancePackId'] = request.compliancePackId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GenerateAggregateCompliancePackReport',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateAggregateCompliancePackReport(request: GenerateAggregateCompliancePackReportRequest): GenerateAggregateCompliancePackReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateAggregateCompliancePackReportWithOptions(request, runtime);
}

model GenerateAggregateConfigRulesReportRequest {
  aggregatorId?: string(name='AggregatorId'),
  clientToken?: string(name='ClientToken'),
  configRuleIds?: string(name='ConfigRuleIds'),
}

model GenerateAggregateConfigRulesReportResponseBody = {
  aggregatorId?: string(name='AggregatorId'),
  reportId?: string(name='ReportId'),
  requestId?: string(name='RequestId'),
}

model GenerateAggregateConfigRulesReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateAggregateConfigRulesReportResponseBody(name='body'),
}

async function generateAggregateConfigRulesReportWithOptions(request: GenerateAggregateConfigRulesReportRequest, runtime: Util.RuntimeOptions): GenerateAggregateConfigRulesReportResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.aggregatorId)) {
    body['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configRuleIds)) {
    body['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GenerateAggregateConfigRulesReport',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateAggregateConfigRulesReport(request: GenerateAggregateConfigRulesReportRequest): GenerateAggregateConfigRulesReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateAggregateConfigRulesReportWithOptions(request, runtime);
}

model GenerateCompliancePackReportRequest {
  clientToken?: string(name='ClientToken'),
  compliancePackId?: string(name='CompliancePackId'),
}

model GenerateCompliancePackReportResponseBody = {
  compliancePackId?: string(name='CompliancePackId'),
  requestId?: string(name='RequestId'),
}

model GenerateCompliancePackReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateCompliancePackReportResponseBody(name='body'),
}

async function generateCompliancePackReportWithOptions(request: GenerateCompliancePackReportRequest, runtime: Util.RuntimeOptions): GenerateCompliancePackReportResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.compliancePackId)) {
    body['CompliancePackId'] = request.compliancePackId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GenerateCompliancePackReport',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateCompliancePackReport(request: GenerateCompliancePackReportRequest): GenerateCompliancePackReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateCompliancePackReportWithOptions(request, runtime);
}

model GenerateConfigRulesReportRequest {
  clientToken?: string(name='ClientToken'),
  configRuleIds?: string(name='ConfigRuleIds'),
}

model GenerateConfigRulesReportResponseBody = {
  reportId?: string(name='ReportId'),
  requestId?: string(name='RequestId'),
}

model GenerateConfigRulesReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateConfigRulesReportResponseBody(name='body'),
}

async function generateConfigRulesReportWithOptions(request: GenerateConfigRulesReportRequest, runtime: Util.RuntimeOptions): GenerateConfigRulesReportResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configRuleIds)) {
    body['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GenerateConfigRulesReport',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateConfigRulesReport(request: GenerateConfigRulesReportRequest): GenerateConfigRulesReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateConfigRulesReportWithOptions(request, runtime);
}

model GetAggregateAccountComplianceByPackRequest {
  aggregatorId?: string(name='AggregatorId'),
  compliancePackId?: string(name='CompliancePackId'),
}

model GetAggregateAccountComplianceByPackResponseBody = {
  accountComplianceResult?: {
    accountCompliances?: [ 
      {
        accountId?: long(name='AccountId'),
        accountName?: string(name='AccountName'),
        complianceType?: string(name='ComplianceType'),
      }
    ](name='AccountCompliances'),
    compliancePackId?: string(name='CompliancePackId'),
    nonCompliantCount?: int32(name='NonCompliantCount'),
    totalCount?: int32(name='TotalCount'),
  }(name='AccountComplianceResult'),
  requestId?: string(name='RequestId'),
}

model GetAggregateAccountComplianceByPackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateAccountComplianceByPackResponseBody(name='body'),
}

async function getAggregateAccountComplianceByPackWithOptions(request: GetAggregateAccountComplianceByPackRequest, runtime: Util.RuntimeOptions): GetAggregateAccountComplianceByPackResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateAccountComplianceByPack',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateAccountComplianceByPack(request: GetAggregateAccountComplianceByPackRequest): GetAggregateAccountComplianceByPackResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateAccountComplianceByPackWithOptions(request, runtime);
}

model GetAggregateCompliancePackRequest {
  aggregatorId?: string(name='AggregatorId'),
  compliancePackId?: string(name='CompliancePackId'),
}

model GetAggregateCompliancePackResponseBody = {
  compliancePack?: {
    accountId?: long(name='AccountId'),
    aggregatorId?: string(name='AggregatorId'),
    compliancePackId?: string(name='CompliancePackId'),
    compliancePackName?: string(name='CompliancePackName'),
    compliancePackTemplateId?: string(name='CompliancePackTemplateId'),
    configRules?: [ 
      {
        configRuleId?: string(name='ConfigRuleId'),
        configRuleName?: string(name='ConfigRuleName'),
        configRuleParameters?: [ 
          {
            parameterName?: string(name='ParameterName'),
            parameterValue?: string(name='ParameterValue'),
            required?: boolean(name='Required'),
          }
        ](name='ConfigRuleParameters'),
        description?: string(name='Description'),
        managedRuleIdentifier?: string(name='ManagedRuleIdentifier'),
        riskLevel?: int32(name='RiskLevel'),
      }
    ](name='ConfigRules'),
    createTimestamp?: long(name='CreateTimestamp'),
    description?: string(name='Description'),
    riskLevel?: int32(name='RiskLevel'),
    status?: string(name='Status'),
  }(name='CompliancePack'),
  requestId?: string(name='RequestId'),
}

model GetAggregateCompliancePackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateCompliancePackResponseBody(name='body'),
}

async function getAggregateCompliancePackWithOptions(request: GetAggregateCompliancePackRequest, runtime: Util.RuntimeOptions): GetAggregateCompliancePackResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateCompliancePack',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateCompliancePack(request: GetAggregateCompliancePackRequest): GetAggregateCompliancePackResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateCompliancePackWithOptions(request, runtime);
}

model GetAggregateCompliancePackReportRequest {
  aggregatorId?: string(name='AggregatorId'),
  compliancePackId?: string(name='CompliancePackId'),
}

model GetAggregateCompliancePackReportResponseBody = {
  compliancePackReport?: {
    accountId?: long(name='AccountId'),
    compliancePackId?: string(name='CompliancePackId'),
    reportCreateTimestamp?: long(name='ReportCreateTimestamp'),
    reportStatus?: string(name='ReportStatus'),
    reportUrl?: string(name='ReportUrl'),
  }(name='CompliancePackReport'),
  requestId?: string(name='RequestId'),
}

model GetAggregateCompliancePackReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateCompliancePackReportResponseBody(name='body'),
}

async function getAggregateCompliancePackReportWithOptions(request: GetAggregateCompliancePackReportRequest, runtime: Util.RuntimeOptions): GetAggregateCompliancePackReportResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateCompliancePackReport',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateCompliancePackReport(request: GetAggregateCompliancePackReportRequest): GetAggregateCompliancePackReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateCompliancePackReportWithOptions(request, runtime);
}

model GetAggregateConfigDeliveryChannelRequest {
  aggregatorId?: string(name='AggregatorId'),
  deliveryChannelId?: string(name='DeliveryChannelId'),
}

model GetAggregateConfigDeliveryChannelResponseBody = {
  deliveryChannel?: {
    accountId?: string(name='AccountId'),
    aggregatorId?: string(name='AggregatorId'),
    configurationItemChangeNotification?: boolean(name='ConfigurationItemChangeNotification'),
    configurationSnapshot?: boolean(name='ConfigurationSnapshot'),
    deliveryChannelAssumeRoleArn?: string(name='DeliveryChannelAssumeRoleArn'),
    deliveryChannelCondition?: string(name='DeliveryChannelCondition'),
    deliveryChannelId?: string(name='DeliveryChannelId'),
    deliveryChannelName?: string(name='DeliveryChannelName'),
    deliveryChannelTargetArn?: string(name='DeliveryChannelTargetArn'),
    deliveryChannelType?: string(name='DeliveryChannelType'),
    description?: string(name='Description'),
    nonCompliantNotification?: boolean(name='NonCompliantNotification'),
    oversizedDataOSSTargetArn?: string(name='OversizedDataOSSTargetArn'),
    status?: int32(name='Status'),
  }(name='DeliveryChannel'),
  requestId?: string(name='RequestId'),
}

model GetAggregateConfigDeliveryChannelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateConfigDeliveryChannelResponseBody(name='body'),
}

async function getAggregateConfigDeliveryChannelWithOptions(request: GetAggregateConfigDeliveryChannelRequest, runtime: Util.RuntimeOptions): GetAggregateConfigDeliveryChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.deliveryChannelId)) {
    query['DeliveryChannelId'] = request.deliveryChannelId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateConfigDeliveryChannel',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateConfigDeliveryChannel(request: GetAggregateConfigDeliveryChannelRequest): GetAggregateConfigDeliveryChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateConfigDeliveryChannelWithOptions(request, runtime);
}

model GetAggregateConfigRuleRequest {
  aggregatorId?: string(name='AggregatorId'),
  configRuleId?: string(name='ConfigRuleId'),
}

model GetAggregateConfigRuleResponseBody = {
  configRule?: {
    accountId?: long(name='AccountId'),
    compliance?: {
      complianceType?: string(name='ComplianceType'),
      count?: int32(name='Count'),
    }(name='Compliance'),
    configRuleArn?: string(name='ConfigRuleArn'),
    configRuleEvaluationStatus?: {
      firstActivatedTimestamp?: long(name='FirstActivatedTimestamp'),
      firstEvaluationStarted?: boolean(name='FirstEvaluationStarted'),
      lastErrorCode?: string(name='LastErrorCode'),
      lastErrorMessage?: string(name='LastErrorMessage'),
      lastFailedEvaluationTimestamp?: long(name='LastFailedEvaluationTimestamp'),
      lastFailedInvocationTimestamp?: long(name='LastFailedInvocationTimestamp'),
      lastSuccessfulEvaluationTimestamp?: long(name='LastSuccessfulEvaluationTimestamp'),
      lastSuccessfulInvocationTimestamp?: long(name='LastSuccessfulInvocationTimestamp'),
    }(name='ConfigRuleEvaluationStatus'),
    configRuleId?: string(name='ConfigRuleId'),
    configRuleName?: string(name='ConfigRuleName'),
    configRuleState?: string(name='ConfigRuleState'),
    configRuleTriggerTypes?: string(name='ConfigRuleTriggerTypes'),
    createBy?: {
      aggregatorId?: string(name='AggregatorId'),
      aggregatorName?: string(name='AggregatorName'),
      compliancePackId?: string(name='CompliancePackId'),
      compliancePackName?: string(name='CompliancePackName'),
      creatorId?: string(name='CreatorId'),
      creatorName?: string(name='CreatorName'),
      creatorType?: string(name='CreatorType'),
    }(name='CreateBy'),
    createTimestamp?: long(name='CreateTimestamp'),
    description?: string(name='Description'),
    excludeAccountIdsScope?: string(name='ExcludeAccountIdsScope'),
    excludeFolderIdsScope?: string(name='ExcludeFolderIdsScope'),
    excludeResourceIdsScope?: string(name='ExcludeResourceIdsScope'),
    folderIdsScope?: string(name='FolderIdsScope'),
    inputParameters?: map[string]any(name='InputParameters'),
    managedRule?: {
      compulsoryInputParameterDetails?: map[string]any(name='CompulsoryInputParameterDetails'),
      description?: string(name='Description'),
      identifier?: string(name='Identifier'),
      labels?: [ string ](name='Labels'),
      managedRuleName?: string(name='ManagedRuleName'),
      optionalInputParameterDetails?: map[string]any(name='OptionalInputParameterDetails'),
      sourceDetails?: [ 
        {
          eventSource?: string(name='EventSource'),
          maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
          messageType?: string(name='MessageType'),
        }
      ](name='SourceDetails'),
    }(name='ManagedRule'),
    maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
    modifiedTimestamp?: long(name='ModifiedTimestamp'),
    regionIdsScope?: string(name='RegionIdsScope'),
    resourceGroupIdsScope?: string(name='ResourceGroupIdsScope'),
    resourceTypesScope?: string(name='ResourceTypesScope'),
    riskLevel?: int32(name='RiskLevel'),
    source?: {
      identifier?: string(name='Identifier'),
      owner?: string(name='Owner'),
      sourceDetails?: [ 
        {
          eventSource?: string(name='EventSource'),
          maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
          messageType?: string(name='MessageType'),
        }
      ](name='SourceDetails'),
    }(name='Source'),
    tagKeyLogicScope?: string(name='TagKeyLogicScope'),
    tagKeyScope?: string(name='TagKeyScope'),
    tagValueScope?: string(name='TagValueScope'),
  }(name='ConfigRule'),
  requestId?: string(name='RequestId'),
}

model GetAggregateConfigRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateConfigRuleResponseBody(name='body'),
}

async function getAggregateConfigRuleWithOptions(request: GetAggregateConfigRuleRequest, runtime: Util.RuntimeOptions): GetAggregateConfigRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.configRuleId)) {
    query['ConfigRuleId'] = request.configRuleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateConfigRule',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateConfigRule(request: GetAggregateConfigRuleRequest): GetAggregateConfigRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateConfigRuleWithOptions(request, runtime);
}

model GetAggregateConfigRuleComplianceByPackRequest {
  aggregatorId?: string(name='AggregatorId'),
  compliancePackId?: string(name='CompliancePackId'),
}

model GetAggregateConfigRuleComplianceByPackResponseBody = {
  configRuleComplianceResult?: {
    compliancePackId?: string(name='CompliancePackId'),
    configRuleCompliances?: [ 
      {
        complianceType?: string(name='ComplianceType'),
        configRuleId?: string(name='ConfigRuleId'),
        configRuleName?: string(name='ConfigRuleName'),
      }
    ](name='ConfigRuleCompliances'),
    nonCompliantCount?: int32(name='NonCompliantCount'),
    totalCount?: int32(name='TotalCount'),
  }(name='ConfigRuleComplianceResult'),
  requestId?: string(name='RequestId'),
}

model GetAggregateConfigRuleComplianceByPackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateConfigRuleComplianceByPackResponseBody(name='body'),
}

async function getAggregateConfigRuleComplianceByPackWithOptions(request: GetAggregateConfigRuleComplianceByPackRequest, runtime: Util.RuntimeOptions): GetAggregateConfigRuleComplianceByPackResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateConfigRuleComplianceByPack',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateConfigRuleComplianceByPack(request: GetAggregateConfigRuleComplianceByPackRequest): GetAggregateConfigRuleComplianceByPackResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateConfigRuleComplianceByPackWithOptions(request, runtime);
}

model GetAggregateConfigRuleSummaryByRiskLevelRequest {
  aggregatorId?: string(name='AggregatorId'),
}

model GetAggregateConfigRuleSummaryByRiskLevelResponseBody = {
  configRuleSummaries?: [ 
    {
      compliantCount?: int32(name='CompliantCount'),
      nonCompliantCount?: int32(name='NonCompliantCount'),
      riskLevel?: int32(name='RiskLevel'),
    }
  ](name='ConfigRuleSummaries'),
  requestId?: string(name='RequestId'),
}

model GetAggregateConfigRuleSummaryByRiskLevelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateConfigRuleSummaryByRiskLevelResponseBody(name='body'),
}

async function getAggregateConfigRuleSummaryByRiskLevelWithOptions(request: GetAggregateConfigRuleSummaryByRiskLevelRequest, runtime: Util.RuntimeOptions): GetAggregateConfigRuleSummaryByRiskLevelResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateConfigRuleSummaryByRiskLevel',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateConfigRuleSummaryByRiskLevel(request: GetAggregateConfigRuleSummaryByRiskLevelRequest): GetAggregateConfigRuleSummaryByRiskLevelResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateConfigRuleSummaryByRiskLevelWithOptions(request, runtime);
}

model GetAggregateConfigRulesReportRequest {
  aggregatorId?: string(name='AggregatorId'),
  reportId?: string(name='ReportId'),
}

model GetAggregateConfigRulesReportResponseBody = {
  configRulesReport?: {
    accountId?: long(name='AccountId'),
    aggregatorId?: string(name='AggregatorId'),
    reportCreateTimestamp?: long(name='ReportCreateTimestamp'),
    reportId?: string(name='ReportId'),
    reportStatus?: string(name='ReportStatus'),
    reportUrl?: string(name='ReportUrl'),
  }(name='ConfigRulesReport'),
  requestId?: string(name='RequestId'),
}

model GetAggregateConfigRulesReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateConfigRulesReportResponseBody(name='body'),
}

async function getAggregateConfigRulesReportWithOptions(request: GetAggregateConfigRulesReportRequest, runtime: Util.RuntimeOptions): GetAggregateConfigRulesReportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateConfigRulesReport',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateConfigRulesReport(request: GetAggregateConfigRulesReportRequest): GetAggregateConfigRulesReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateConfigRulesReportWithOptions(request, runtime);
}

model GetAggregateDiscoveredResourceRequest {
  aggregatorId?: string(name='AggregatorId'),
  region?: string(name='Region'),
  resourceId?: string(name='ResourceId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
}

model GetAggregateDiscoveredResourceResponseBody = {
  discoveredResourceDetail?: {
    accountId?: long(name='AccountId'),
    availabilityZone?: string(name='AvailabilityZone'),
    configuration?: string(name='Configuration'),
    region?: string(name='Region'),
    resourceCreationTime?: long(name='ResourceCreationTime'),
    resourceDeleted?: int32(name='ResourceDeleted'),
    resourceId?: string(name='ResourceId'),
    resourceName?: string(name='ResourceName'),
    resourceStatus?: string(name='ResourceStatus'),
    resourceType?: string(name='ResourceType'),
    tags?: string(name='Tags'),
  }(name='DiscoveredResourceDetail'),
  requestId?: string(name='RequestId'),
}

model GetAggregateDiscoveredResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateDiscoveredResourceResponseBody(name='body'),
}

async function getAggregateDiscoveredResourceWithOptions(request: GetAggregateDiscoveredResourceRequest, runtime: Util.RuntimeOptions): GetAggregateDiscoveredResourceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateDiscoveredResource',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateDiscoveredResource(request: GetAggregateDiscoveredResourceRequest): GetAggregateDiscoveredResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateDiscoveredResourceWithOptions(request, runtime);
}

model GetAggregateResourceComplianceByConfigRuleRequest {
  aggregatorId?: string(name='AggregatorId'),
  complianceType?: string(name='ComplianceType'),
  configRuleId?: string(name='ConfigRuleId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetAggregateResourceComplianceByConfigRuleResponseBody = {
  complianceResult?: {
    compliances?: [ 
      {
        complianceType?: string(name='ComplianceType'),
        count?: int32(name='Count'),
      }
    ](name='Compliances'),
    totalCount?: long(name='TotalCount'),
  }(name='ComplianceResult'),
  requestId?: string(name='RequestId'),
}

model GetAggregateResourceComplianceByConfigRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateResourceComplianceByConfigRuleResponseBody(name='body'),
}

async function getAggregateResourceComplianceByConfigRuleWithOptions(request: GetAggregateResourceComplianceByConfigRuleRequest, runtime: Util.RuntimeOptions): GetAggregateResourceComplianceByConfigRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.complianceType)) {
    query['ComplianceType'] = request.complianceType;
  }
  if (!Util.isUnset(request.configRuleId)) {
    query['ConfigRuleId'] = request.configRuleId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateResourceComplianceByConfigRule',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateResourceComplianceByConfigRule(request: GetAggregateResourceComplianceByConfigRuleRequest): GetAggregateResourceComplianceByConfigRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateResourceComplianceByConfigRuleWithOptions(request, runtime);
}

model GetAggregateResourceComplianceByPackRequest {
  aggregatorId?: string(name='AggregatorId'),
  compliancePackId?: string(name='CompliancePackId'),
}

model GetAggregateResourceComplianceByPackResponseBody = {
  requestId?: string(name='RequestId'),
  resourceComplianceResult?: {
    compliancePackId?: string(name='CompliancePackId'),
    nonCompliantCount?: int32(name='NonCompliantCount'),
    totalCount?: int32(name='TotalCount'),
  }(name='ResourceComplianceResult'),
}

model GetAggregateResourceComplianceByPackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateResourceComplianceByPackResponseBody(name='body'),
}

async function getAggregateResourceComplianceByPackWithOptions(request: GetAggregateResourceComplianceByPackRequest, runtime: Util.RuntimeOptions): GetAggregateResourceComplianceByPackResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateResourceComplianceByPack',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateResourceComplianceByPack(request: GetAggregateResourceComplianceByPackRequest): GetAggregateResourceComplianceByPackResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateResourceComplianceByPackWithOptions(request, runtime);
}

model GetAggregateResourceComplianceGroupByRegionRequest {
  aggregatorId?: string(name='AggregatorId'),
  configRuleIds?: string(name='ConfigRuleIds'),
}

model GetAggregateResourceComplianceGroupByRegionResponseBody = {
  complianceResult?: {
    complianceResultList?: [ 
      {
        compliances?: [ 
          {
            complianceType?: string(name='ComplianceType'),
            count?: long(name='Count'),
          }
        ](name='Compliances'),
        regionId?: string(name='RegionId'),
      }
    ](name='ComplianceResultList'),
  }(name='ComplianceResult'),
  requestId?: string(name='RequestId'),
}

model GetAggregateResourceComplianceGroupByRegionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateResourceComplianceGroupByRegionResponseBody(name='body'),
}

async function getAggregateResourceComplianceGroupByRegionWithOptions(request: GetAggregateResourceComplianceGroupByRegionRequest, runtime: Util.RuntimeOptions): GetAggregateResourceComplianceGroupByRegionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.configRuleIds)) {
    query['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateResourceComplianceGroupByRegion',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateResourceComplianceGroupByRegion(request: GetAggregateResourceComplianceGroupByRegionRequest): GetAggregateResourceComplianceGroupByRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateResourceComplianceGroupByRegionWithOptions(request, runtime);
}

model GetAggregateResourceComplianceGroupByResourceTypeRequest {
  aggregatorId?: string(name='AggregatorId'),
  configRuleIds?: string(name='ConfigRuleIds'),
}

model GetAggregateResourceComplianceGroupByResourceTypeResponseBody = {
  complianceResult?: {
    complianceResultList?: [ 
      {
        compliances?: [ 
          {
            complianceType?: string(name='ComplianceType'),
            count?: long(name='Count'),
          }
        ](name='Compliances'),
        resourceType?: string(name='ResourceType'),
      }
    ](name='ComplianceResultList'),
  }(name='ComplianceResult'),
  requestId?: string(name='RequestId'),
}

model GetAggregateResourceComplianceGroupByResourceTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateResourceComplianceGroupByResourceTypeResponseBody(name='body'),
}

async function getAggregateResourceComplianceGroupByResourceTypeWithOptions(request: GetAggregateResourceComplianceGroupByResourceTypeRequest, runtime: Util.RuntimeOptions): GetAggregateResourceComplianceGroupByResourceTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.configRuleIds)) {
    query['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateResourceComplianceGroupByResourceType',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateResourceComplianceGroupByResourceType(request: GetAggregateResourceComplianceGroupByResourceTypeRequest): GetAggregateResourceComplianceGroupByResourceTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateResourceComplianceGroupByResourceTypeWithOptions(request, runtime);
}

model GetAggregateResourceComplianceTimelineRequest {
  aggregatorId?: string(name='AggregatorId'),
  endTime?: long(name='EndTime'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  region?: string(name='Region'),
  resourceId?: string(name='ResourceId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  startTime?: long(name='StartTime'),
}

model GetAggregateResourceComplianceTimelineResponseBody = {
  requestId?: string(name='RequestId'),
  resourceComplianceTimeline?: {
    complianceList?: [ 
      {
        accountId?: string(name='AccountId'),
        availabilityZone?: string(name='AvailabilityZone'),
        captureTime?: long(name='CaptureTime'),
        configuration?: string(name='Configuration'),
        configurationDiff?: string(name='ConfigurationDiff'),
        region?: string(name='Region'),
        resourceCreateTime?: long(name='ResourceCreateTime'),
        resourceId?: string(name='ResourceId'),
        resourceName?: string(name='ResourceName'),
        resourceStatus?: string(name='ResourceStatus'),
        resourceType?: string(name='ResourceType'),
        tags?: string(name='Tags'),
      }
    ](name='ComplianceList'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='ResourceComplianceTimeline'),
}

model GetAggregateResourceComplianceTimelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateResourceComplianceTimelineResponseBody(name='body'),
}

async function getAggregateResourceComplianceTimelineWithOptions(request: GetAggregateResourceComplianceTimelineRequest, runtime: Util.RuntimeOptions): GetAggregateResourceComplianceTimelineResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateResourceComplianceTimeline',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateResourceComplianceTimeline(request: GetAggregateResourceComplianceTimelineRequest): GetAggregateResourceComplianceTimelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateResourceComplianceTimelineWithOptions(request, runtime);
}

model GetAggregateResourceConfigurationTimelineRequest {
  aggregatorId?: string(name='AggregatorId'),
  endTime?: long(name='EndTime'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  region?: string(name='Region'),
  resourceId?: string(name='ResourceId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  startTime?: long(name='StartTime'),
}

model GetAggregateResourceConfigurationTimelineResponseBody = {
  requestId?: string(name='RequestId'),
  resourceConfigurationTimeline?: {
    configurationList?: [ 
      {
        accountId?: long(name='AccountId'),
        availabilityZone?: string(name='AvailabilityZone'),
        captureTime?: string(name='CaptureTime'),
        configurationDiff?: string(name='ConfigurationDiff'),
        region?: string(name='Region'),
        resourceCreateTime?: string(name='ResourceCreateTime'),
        resourceEventType?: string(name='ResourceEventType'),
        resourceId?: string(name='ResourceId'),
        resourceName?: string(name='ResourceName'),
        resourceType?: string(name='ResourceType'),
        tags?: string(name='Tags'),
      }
    ](name='ConfigurationList'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='ResourceConfigurationTimeline'),
}

model GetAggregateResourceConfigurationTimelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateResourceConfigurationTimelineResponseBody(name='body'),
}

async function getAggregateResourceConfigurationTimelineWithOptions(request: GetAggregateResourceConfigurationTimelineRequest, runtime: Util.RuntimeOptions): GetAggregateResourceConfigurationTimelineResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateResourceConfigurationTimeline',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateResourceConfigurationTimeline(request: GetAggregateResourceConfigurationTimelineRequest): GetAggregateResourceConfigurationTimelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateResourceConfigurationTimelineWithOptions(request, runtime);
}

model GetAggregateResourceCountsGroupByRegionRequest {
  aggregatorId?: string(name='AggregatorId'),
  folderId?: string(name='FolderId', description='Id'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='owner'),
  resourceType?: string(name='ResourceType'),
}

model GetAggregateResourceCountsGroupByRegionResponseBody = {
  discoveredResourceCountsSummary?: [ 
    {
      region?: string(name='Region'),
      resourceCount?: long(name='ResourceCount'),
    }
  ](name='DiscoveredResourceCountsSummary'),
  requestId?: string(name='RequestId'),
}

model GetAggregateResourceCountsGroupByRegionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateResourceCountsGroupByRegionResponseBody(name='body'),
}

async function getAggregateResourceCountsGroupByRegionWithOptions(request: GetAggregateResourceCountsGroupByRegionRequest, runtime: Util.RuntimeOptions): GetAggregateResourceCountsGroupByRegionResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateResourceCountsGroupByRegion',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateResourceCountsGroupByRegion(request: GetAggregateResourceCountsGroupByRegionRequest): GetAggregateResourceCountsGroupByRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateResourceCountsGroupByRegionWithOptions(request, runtime);
}

model GetAggregateResourceCountsGroupByResourceTypeRequest {
  aggregatorId?: string(name='AggregatorId'),
  folderId?: string(name='FolderId', description='Id'),
  region?: string(name='Region'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='Owner'),
}

model GetAggregateResourceCountsGroupByResourceTypeResponseBody = {
  discoveredResourceCountsSummary?: [ 
    {
      resourceCount?: long(name='ResourceCount'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='DiscoveredResourceCountsSummary'),
  requestId?: string(name='RequestId'),
}

model GetAggregateResourceCountsGroupByResourceTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateResourceCountsGroupByResourceTypeResponseBody(name='body'),
}

async function getAggregateResourceCountsGroupByResourceTypeWithOptions(request: GetAggregateResourceCountsGroupByResourceTypeRequest, runtime: Util.RuntimeOptions): GetAggregateResourceCountsGroupByResourceTypeResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateResourceCountsGroupByResourceType',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateResourceCountsGroupByResourceType(request: GetAggregateResourceCountsGroupByResourceTypeRequest): GetAggregateResourceCountsGroupByResourceTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateResourceCountsGroupByResourceTypeWithOptions(request, runtime);
}

model GetAggregatorRequest {
  aggregatorId?: string(name='AggregatorId'),
}

model GetAggregatorResponseBody = {
  aggregator?: {
    accountId?: long(name='AccountId'),
    aggregatorAccountCount?: long(name='AggregatorAccountCount'),
    aggregatorAccounts?: [ 
      {
        accountId?: long(name='AccountId'),
        accountName?: string(name='AccountName'),
        accountType?: string(name='AccountType'),
        recorderStatus?: string(name='RecorderStatus'),
      }
    ](name='AggregatorAccounts'),
    aggregatorCreateTimestamp?: string(name='AggregatorCreateTimestamp'),
    aggregatorId?: string(name='AggregatorId'),
    aggregatorName?: string(name='AggregatorName'),
    aggregatorStatus?: int32(name='AggregatorStatus'),
    aggregatorType?: string(name='AggregatorType'),
    description?: string(name='Description'),
  }(name='Aggregator'),
  requestId?: string(name='RequestId'),
}

model GetAggregatorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregatorResponseBody(name='body'),
}

async function getAggregatorWithOptions(request: GetAggregatorRequest, runtime: Util.RuntimeOptions): GetAggregatorResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregator',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregator(request: GetAggregatorRequest): GetAggregatorResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregatorWithOptions(request, runtime);
}

model GetCompliancePackRequest {
  compliancePackId?: string(name='CompliancePackId'),
}

model GetCompliancePackResponseBody = {
  compliancePack?: {
    accountId?: long(name='AccountId'),
    compliancePackId?: string(name='CompliancePackId'),
    compliancePackName?: string(name='CompliancePackName'),
    compliancePackTemplateId?: string(name='CompliancePackTemplateId'),
    configRules?: [ 
      {
        configRuleId?: string(name='ConfigRuleId'),
        configRuleName?: string(name='ConfigRuleName'),
        configRuleParameters?: [ 
          {
            parameterName?: string(name='ParameterName'),
            parameterValue?: string(name='ParameterValue'),
            required?: boolean(name='Required'),
          }
        ](name='ConfigRuleParameters'),
        description?: string(name='Description'),
        managedRuleIdentifier?: string(name='ManagedRuleIdentifier'),
        riskLevel?: int32(name='RiskLevel'),
      }
    ](name='ConfigRules'),
    createTimestamp?: long(name='CreateTimestamp'),
    description?: string(name='Description'),
    riskLevel?: int32(name='RiskLevel'),
    status?: string(name='Status'),
  }(name='CompliancePack'),
  requestId?: string(name='RequestId'),
}

model GetCompliancePackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCompliancePackResponseBody(name='body'),
}

async function getCompliancePackWithOptions(request: GetCompliancePackRequest, runtime: Util.RuntimeOptions): GetCompliancePackResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCompliancePack',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCompliancePack(request: GetCompliancePackRequest): GetCompliancePackResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCompliancePackWithOptions(request, runtime);
}

model GetCompliancePackReportRequest {
  compliancePackId?: string(name='CompliancePackId'),
}

model GetCompliancePackReportResponseBody = {
  compliancePackReport?: {
    accountId?: long(name='AccountId'),
    compliancePackId?: string(name='CompliancePackId'),
    reportCreateTimestamp?: long(name='ReportCreateTimestamp'),
    reportStatus?: string(name='ReportStatus'),
    reportUrl?: string(name='ReportUrl'),
  }(name='CompliancePackReport'),
  requestId?: string(name='RequestId'),
}

model GetCompliancePackReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCompliancePackReportResponseBody(name='body'),
}

async function getCompliancePackReportWithOptions(request: GetCompliancePackReportRequest, runtime: Util.RuntimeOptions): GetCompliancePackReportResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCompliancePackReport',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCompliancePackReport(request: GetCompliancePackReportRequest): GetCompliancePackReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCompliancePackReportWithOptions(request, runtime);
}

model GetConfigDeliveryChannelRequest {
  deliveryChannelId?: string(name='DeliveryChannelId'),
}

model GetConfigDeliveryChannelResponseBody = {
  deliveryChannel?: {
    accountId?: long(name='AccountId'),
    configurationItemChangeNotification?: boolean(name='ConfigurationItemChangeNotification'),
    configurationSnapshot?: boolean(name='ConfigurationSnapshot'),
    deliveryChannelAssumeRoleArn?: string(name='DeliveryChannelAssumeRoleArn'),
    deliveryChannelCondition?: string(name='DeliveryChannelCondition'),
    deliveryChannelId?: string(name='DeliveryChannelId'),
    deliveryChannelName?: string(name='DeliveryChannelName'),
    deliveryChannelTargetArn?: string(name='DeliveryChannelTargetArn'),
    deliveryChannelType?: string(name='DeliveryChannelType'),
    description?: string(name='Description'),
    nonCompliantNotification?: boolean(name='NonCompliantNotification'),
    oversizedDataOSSTargetArn?: string(name='OversizedDataOSSTargetArn'),
    status?: int32(name='Status'),
  }(name='DeliveryChannel'),
  requestId?: string(name='RequestId'),
}

model GetConfigDeliveryChannelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConfigDeliveryChannelResponseBody(name='body'),
}

async function getConfigDeliveryChannelWithOptions(request: GetConfigDeliveryChannelRequest, runtime: Util.RuntimeOptions): GetConfigDeliveryChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deliveryChannelId)) {
    query['DeliveryChannelId'] = request.deliveryChannelId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetConfigDeliveryChannel',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConfigDeliveryChannel(request: GetConfigDeliveryChannelRequest): GetConfigDeliveryChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConfigDeliveryChannelWithOptions(request, runtime);
}

model GetConfigRuleRequest {
  configRuleId?: string(name='ConfigRuleId'),
}

model GetConfigRuleResponseBody = {
  configRule?: {
    accountId?: long(name='AccountId'),
    compliance?: {
      complianceType?: string(name='ComplianceType'),
      count?: int32(name='Count'),
    }(name='Compliance'),
    configRuleArn?: string(name='ConfigRuleArn'),
    configRuleEvaluationStatus?: {
      firstActivatedTimestamp?: long(name='FirstActivatedTimestamp'),
      firstEvaluationStarted?: boolean(name='FirstEvaluationStarted'),
      lastErrorCode?: string(name='LastErrorCode'),
      lastErrorMessage?: string(name='LastErrorMessage'),
      lastFailedEvaluationTimestamp?: long(name='LastFailedEvaluationTimestamp'),
      lastFailedInvocationTimestamp?: long(name='LastFailedInvocationTimestamp'),
      lastSuccessfulEvaluationTimestamp?: long(name='LastSuccessfulEvaluationTimestamp'),
      lastSuccessfulInvocationTimestamp?: long(name='LastSuccessfulInvocationTimestamp'),
    }(name='ConfigRuleEvaluationStatus'),
    configRuleId?: string(name='ConfigRuleId'),
    configRuleName?: string(name='ConfigRuleName'),
    configRuleState?: string(name='ConfigRuleState'),
    configRuleTriggerTypes?: string(name='ConfigRuleTriggerTypes'),
    createBy?: {
      compliancePackId?: string(name='CompliancePackId'),
      compliancePackName?: string(name='CompliancePackName'),
      creatorId?: string(name='CreatorId'),
      creatorName?: string(name='CreatorName'),
    }(name='CreateBy'),
    createTimestamp?: long(name='CreateTimestamp'),
    description?: string(name='Description'),
    excludeResourceIdsScope?: string(name='ExcludeResourceIdsScope'),
    inputParameters?: map[string]any(name='InputParameters'),
    managedRule?: {
      compulsoryInputParameterDetails?: map[string]any(name='CompulsoryInputParameterDetails'),
      description?: string(name='Description'),
      identifier?: string(name='Identifier'),
      labels?: [ string ](name='Labels'),
      managedRuleName?: string(name='ManagedRuleName'),
      optionalInputParameterDetails?: map[string]any(name='OptionalInputParameterDetails'),
      sourceDetails?: [ 
        {
          eventSource?: string(name='EventSource'),
          maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
          messageType?: string(name='MessageType'),
        }
      ](name='SourceDetails'),
    }(name='ManagedRule'),
    maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
    modifiedTimestamp?: long(name='ModifiedTimestamp'),
    regionIdsScope?: string(name='RegionIdsScope'),
    resourceGroupIdsScope?: string(name='ResourceGroupIdsScope'),
    resourceTypesScope?: string(name='ResourceTypesScope'),
    riskLevel?: int32(name='RiskLevel'),
    source?: {
      identifier?: string(name='Identifier'),
      owner?: string(name='Owner'),
      sourceDetails?: [ 
        {
          eventSource?: string(name='EventSource'),
          maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
          messageType?: string(name='MessageType'),
        }
      ](name='SourceDetails'),
    }(name='Source'),
    tagKeyLogicScope?: string(name='TagKeyLogicScope'),
    tagKeyScope?: string(name='TagKeyScope'),
    tagValueScope?: string(name='TagValueScope'),
  }(name='ConfigRule'),
  requestId?: string(name='RequestId'),
}

model GetConfigRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConfigRuleResponseBody(name='body'),
}

async function getConfigRuleWithOptions(request: GetConfigRuleRequest, runtime: Util.RuntimeOptions): GetConfigRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configRuleId)) {
    query['ConfigRuleId'] = request.configRuleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetConfigRule',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConfigRule(request: GetConfigRuleRequest): GetConfigRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConfigRuleWithOptions(request, runtime);
}

model GetConfigRuleComplianceByPackRequest {
  compliancePackId?: string(name='CompliancePackId'),
}

model GetConfigRuleComplianceByPackResponseBody = {
  configRuleComplianceResult?: {
    compliancePackId?: string(name='CompliancePackId'),
    configRuleCompliances?: [ 
      {
        complianceType?: string(name='ComplianceType'),
        configRuleId?: string(name='ConfigRuleId'),
        configRuleName?: string(name='ConfigRuleName'),
      }
    ](name='ConfigRuleCompliances'),
    nonCompliantCount?: int32(name='NonCompliantCount'),
    totalCount?: int32(name='TotalCount'),
  }(name='ConfigRuleComplianceResult'),
  requestId?: string(name='RequestId'),
}

model GetConfigRuleComplianceByPackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConfigRuleComplianceByPackResponseBody(name='body'),
}

async function getConfigRuleComplianceByPackWithOptions(request: GetConfigRuleComplianceByPackRequest, runtime: Util.RuntimeOptions): GetConfigRuleComplianceByPackResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetConfigRuleComplianceByPack',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConfigRuleComplianceByPack(request: GetConfigRuleComplianceByPackRequest): GetConfigRuleComplianceByPackResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConfigRuleComplianceByPackWithOptions(request, runtime);
}

model GetConfigRuleSummaryByRiskLevelResponseBody = {
  configRuleSummaries?: [ 
    {
      compliantCount?: int32(name='CompliantCount'),
      nonCompliantCount?: int32(name='NonCompliantCount'),
      riskLevel?: int32(name='RiskLevel'),
    }
  ](name='ConfigRuleSummaries'),
  requestId?: string(name='RequestId'),
}

model GetConfigRuleSummaryByRiskLevelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConfigRuleSummaryByRiskLevelResponseBody(name='body'),
}

async function getConfigRuleSummaryByRiskLevelWithOptions(runtime: Util.RuntimeOptions): GetConfigRuleSummaryByRiskLevelResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetConfigRuleSummaryByRiskLevel',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConfigRuleSummaryByRiskLevel(): GetConfigRuleSummaryByRiskLevelResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConfigRuleSummaryByRiskLevelWithOptions(runtime);
}

model GetConfigRulesReportRequest {
  reportId?: string(name='ReportId'),
}

model GetConfigRulesReportResponseBody = {
  configRulesReport?: {
    accountId?: long(name='AccountId'),
    reportCreateTimestamp?: long(name='ReportCreateTimestamp'),
    reportId?: string(name='ReportId'),
    reportStatus?: string(name='ReportStatus'),
    reportUrl?: string(name='ReportUrl'),
  }(name='ConfigRulesReport'),
  requestId?: string(name='RequestId'),
}

model GetConfigRulesReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConfigRulesReportResponseBody(name='body'),
}

async function getConfigRulesReportWithOptions(request: GetConfigRulesReportRequest, runtime: Util.RuntimeOptions): GetConfigRulesReportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetConfigRulesReport',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConfigRulesReport(request: GetConfigRulesReportRequest): GetConfigRulesReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConfigRulesReportWithOptions(request, runtime);
}

model GetDiscoveredResourceRequest {
  region?: string(name='Region'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
}

model GetDiscoveredResourceResponseBody = {
  discoveredResourceDetail?: {
    accountId?: long(name='AccountId'),
    availabilityZone?: string(name='AvailabilityZone'),
    configuration?: string(name='Configuration'),
    region?: string(name='Region'),
    resourceCreationTime?: long(name='ResourceCreationTime'),
    resourceDeleted?: int32(name='ResourceDeleted'),
    resourceId?: string(name='ResourceId'),
    resourceName?: string(name='ResourceName'),
    resourceStatus?: string(name='ResourceStatus'),
    resourceType?: string(name='ResourceType'),
    tags?: string(name='Tags'),
  }(name='DiscoveredResourceDetail'),
  requestId?: string(name='RequestId'),
}

model GetDiscoveredResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDiscoveredResourceResponseBody(name='body'),
}

async function getDiscoveredResourceWithOptions(request: GetDiscoveredResourceRequest, runtime: Util.RuntimeOptions): GetDiscoveredResourceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDiscoveredResource',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDiscoveredResource(request: GetDiscoveredResourceRequest): GetDiscoveredResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDiscoveredResourceWithOptions(request, runtime);
}

model GetDiscoveredResourceCountsGroupByRegionRequest {
  resourceType?: string(name='ResourceType'),
}

model GetDiscoveredResourceCountsGroupByRegionResponseBody = {
  discoveredResourceCountsSummary?: [ 
    {
      region?: string(name='Region'),
      resourceCount?: long(name='ResourceCount'),
    }
  ](name='DiscoveredResourceCountsSummary'),
  requestId?: string(name='RequestId'),
}

model GetDiscoveredResourceCountsGroupByRegionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDiscoveredResourceCountsGroupByRegionResponseBody(name='body'),
}

async function getDiscoveredResourceCountsGroupByRegionWithOptions(request: GetDiscoveredResourceCountsGroupByRegionRequest, runtime: Util.RuntimeOptions): GetDiscoveredResourceCountsGroupByRegionResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDiscoveredResourceCountsGroupByRegion',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDiscoveredResourceCountsGroupByRegion(request: GetDiscoveredResourceCountsGroupByRegionRequest): GetDiscoveredResourceCountsGroupByRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDiscoveredResourceCountsGroupByRegionWithOptions(request, runtime);
}

model GetDiscoveredResourceCountsGroupByResourceTypeRequest {
  region?: string(name='Region'),
}

model GetDiscoveredResourceCountsGroupByResourceTypeResponseBody = {
  discoveredResourceCountsSummary?: [ 
    {
      resourceCount?: long(name='ResourceCount'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='DiscoveredResourceCountsSummary'),
  requestId?: string(name='RequestId'),
}

model GetDiscoveredResourceCountsGroupByResourceTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDiscoveredResourceCountsGroupByResourceTypeResponseBody(name='body'),
}

async function getDiscoveredResourceCountsGroupByResourceTypeWithOptions(request: GetDiscoveredResourceCountsGroupByResourceTypeRequest, runtime: Util.RuntimeOptions): GetDiscoveredResourceCountsGroupByResourceTypeResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDiscoveredResourceCountsGroupByResourceType',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDiscoveredResourceCountsGroupByResourceType(request: GetDiscoveredResourceCountsGroupByResourceTypeRequest): GetDiscoveredResourceCountsGroupByResourceTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDiscoveredResourceCountsGroupByResourceTypeWithOptions(request, runtime);
}

model GetManagedRuleRequest {
  identifier?: string(name='Identifier'),
}

model GetManagedRuleResponseBody = {
  managedRule?: {
    compulsoryInputParameterDetails?: map[string]any(name='CompulsoryInputParameterDetails'),
    configRuleName?: string(name='ConfigRuleName'),
    description?: string(name='Description'),
    helpUrls?: string(name='HelpUrls'),
    identifier?: string(name='Identifier'),
    labels?: [ string ](name='Labels'),
    optionalInputParameterDetails?: map[string]any(name='OptionalInputParameterDetails'),
    riskLevel?: int32(name='RiskLevel'),
    scope?: {
      complianceResourceTypes?: [ string ](name='ComplianceResourceTypes'),
    }(name='Scope'),
    sourceDetails?: [ 
      {
        maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
        messageType?: string(name='MessageType'),
      }
    ](name='SourceDetails'),
  }(name='ManagedRule'),
  requestId?: string(name='RequestId'),
}

model GetManagedRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetManagedRuleResponseBody(name='body'),
}

async function getManagedRuleWithOptions(request: GetManagedRuleRequest, runtime: Util.RuntimeOptions): GetManagedRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetManagedRule',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getManagedRule(request: GetManagedRuleRequest): GetManagedRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getManagedRuleWithOptions(request, runtime);
}

model GetResourceComplianceByConfigRuleRequest {
  complianceType?: string(name='ComplianceType'),
  configRuleId?: string(name='ConfigRuleId'),
}

model GetResourceComplianceByConfigRuleResponseBody = {
  complianceResult?: {
    compliances?: [ 
      {
        complianceType?: string(name='ComplianceType'),
        count?: int32(name='Count'),
      }
    ](name='Compliances'),
    totalCount?: long(name='TotalCount'),
  }(name='ComplianceResult'),
  requestId?: string(name='RequestId'),
}

model GetResourceComplianceByConfigRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceComplianceByConfigRuleResponseBody(name='body'),
}

async function getResourceComplianceByConfigRuleWithOptions(request: GetResourceComplianceByConfigRuleRequest, runtime: Util.RuntimeOptions): GetResourceComplianceByConfigRuleResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceComplianceByConfigRule',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResourceComplianceByConfigRule(request: GetResourceComplianceByConfigRuleRequest): GetResourceComplianceByConfigRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResourceComplianceByConfigRuleWithOptions(request, runtime);
}

model GetResourceComplianceByPackRequest {
  compliancePackId?: string(name='CompliancePackId'),
}

model GetResourceComplianceByPackResponseBody = {
  requestId?: string(name='RequestId'),
  resourceComplianceResult?: {
    compliancePackId?: string(name='CompliancePackId'),
    nonCompliantCount?: int32(name='NonCompliantCount'),
    totalCount?: int32(name='TotalCount'),
  }(name='ResourceComplianceResult'),
}

model GetResourceComplianceByPackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceComplianceByPackResponseBody(name='body'),
}

async function getResourceComplianceByPackWithOptions(request: GetResourceComplianceByPackRequest, runtime: Util.RuntimeOptions): GetResourceComplianceByPackResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceComplianceByPack',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResourceComplianceByPack(request: GetResourceComplianceByPackRequest): GetResourceComplianceByPackResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResourceComplianceByPackWithOptions(request, runtime);
}

model GetResourceComplianceGroupByRegionRequest {
  configRuleIds?: string(name='ConfigRuleIds'),
}

model GetResourceComplianceGroupByRegionResponseBody = {
  complianceResult?: {
    complianceResultList?: [ 
      {
        compliances?: [ 
          {
            complianceType?: string(name='ComplianceType'),
            count?: long(name='Count'),
          }
        ](name='Compliances'),
        regionId?: string(name='RegionId'),
      }
    ](name='ComplianceResultList'),
  }(name='ComplianceResult'),
  requestId?: string(name='RequestId'),
}

model GetResourceComplianceGroupByRegionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceComplianceGroupByRegionResponseBody(name='body'),
}

async function getResourceComplianceGroupByRegionWithOptions(request: GetResourceComplianceGroupByRegionRequest, runtime: Util.RuntimeOptions): GetResourceComplianceGroupByRegionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configRuleIds)) {
    query['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceComplianceGroupByRegion',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResourceComplianceGroupByRegion(request: GetResourceComplianceGroupByRegionRequest): GetResourceComplianceGroupByRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResourceComplianceGroupByRegionWithOptions(request, runtime);
}

model GetResourceComplianceGroupByResourceTypeRequest {
  configRuleIds?: string(name='ConfigRuleIds'),
}

model GetResourceComplianceGroupByResourceTypeResponseBody = {
  complianceResult?: {
    complianceResultList?: [ 
      {
        compliances?: [ 
          {
            complianceType?: string(name='ComplianceType'),
            count?: long(name='Count'),
          }
        ](name='Compliances'),
        resourceType?: string(name='ResourceType'),
      }
    ](name='ComplianceResultList'),
  }(name='ComplianceResult'),
  requestId?: string(name='RequestId'),
}

model GetResourceComplianceGroupByResourceTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceComplianceGroupByResourceTypeResponseBody(name='body'),
}

async function getResourceComplianceGroupByResourceTypeWithOptions(request: GetResourceComplianceGroupByResourceTypeRequest, runtime: Util.RuntimeOptions): GetResourceComplianceGroupByResourceTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configRuleIds)) {
    query['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceComplianceGroupByResourceType',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResourceComplianceGroupByResourceType(request: GetResourceComplianceGroupByResourceTypeRequest): GetResourceComplianceGroupByResourceTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResourceComplianceGroupByResourceTypeWithOptions(request, runtime);
}

model GetResourceComplianceTimelineRequest {
  endTime?: long(name='EndTime'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  region?: string(name='Region'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  startTime?: long(name='StartTime'),
}

model GetResourceComplianceTimelineResponseBody = {
  requestId?: string(name='RequestId'),
  resourceComplianceTimeline?: {
    complianceList?: [ 
      {
        accountId?: string(name='AccountId'),
        availabilityZone?: string(name='AvailabilityZone'),
        captureTime?: long(name='CaptureTime'),
        configuration?: string(name='Configuration'),
        configurationDiff?: string(name='ConfigurationDiff'),
        region?: string(name='Region'),
        resourceCreateTime?: long(name='ResourceCreateTime'),
        resourceId?: string(name='ResourceId'),
        resourceName?: string(name='ResourceName'),
        resourceStatus?: string(name='ResourceStatus'),
        resourceType?: string(name='ResourceType'),
        tags?: string(name='Tags'),
      }
    ](name='ComplianceList'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='ResourceComplianceTimeline'),
}

model GetResourceComplianceTimelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceComplianceTimelineResponseBody(name='body'),
}

async function getResourceComplianceTimelineWithOptions(request: GetResourceComplianceTimelineRequest, runtime: Util.RuntimeOptions): GetResourceComplianceTimelineResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceComplianceTimeline',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResourceComplianceTimeline(request: GetResourceComplianceTimelineRequest): GetResourceComplianceTimelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResourceComplianceTimelineWithOptions(request, runtime);
}

model GetResourceConfigurationTimelineRequest {
  endTime?: long(name='EndTime'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  region?: string(name='Region'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  startTime?: long(name='StartTime'),
}

model GetResourceConfigurationTimelineResponseBody = {
  requestId?: string(name='RequestId'),
  resourceConfigurationTimeline?: {
    configurationList?: [ 
      {
        accountId?: long(name='AccountId'),
        availabilityZone?: string(name='AvailabilityZone'),
        captureTime?: string(name='CaptureTime'),
        configurationDiff?: string(name='ConfigurationDiff'),
        region?: string(name='Region'),
        relationship?: string(name='Relationship'),
        relationshipDiff?: string(name='RelationshipDiff'),
        resourceCreateTime?: string(name='ResourceCreateTime'),
        resourceEventType?: string(name='ResourceEventType'),
        resourceId?: string(name='ResourceId'),
        resourceName?: string(name='ResourceName'),
        resourceType?: string(name='ResourceType'),
        tags?: string(name='Tags'),
      }
    ](name='ConfigurationList'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='ResourceConfigurationTimeline'),
}

model GetResourceConfigurationTimelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceConfigurationTimelineResponseBody(name='body'),
}

async function getResourceConfigurationTimelineWithOptions(request: GetResourceConfigurationTimelineRequest, runtime: Util.RuntimeOptions): GetResourceConfigurationTimelineResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceConfigurationTimeline',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResourceConfigurationTimeline(request: GetResourceConfigurationTimelineRequest): GetResourceConfigurationTimelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResourceConfigurationTimelineWithOptions(request, runtime);
}

model IgnoreAggregateEvaluationResultsRequest {
  aggregatorId?: string(name='AggregatorId'),
  configRuleId?: string(name='ConfigRuleId'),
  ignoreDate?: string(name='IgnoreDate'),
  reason?: string(name='Reason'),
  resources?: [ 
    {
      region?: string(name='Region'),
      resourceAccountId?: long(name='ResourceAccountId'),
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resources'),
}

model IgnoreAggregateEvaluationResultsShrinkRequest {
  aggregatorId?: string(name='AggregatorId'),
  configRuleId?: string(name='ConfigRuleId'),
  ignoreDate?: string(name='IgnoreDate'),
  reason?: string(name='Reason'),
  resourcesShrink?: string(name='Resources'),
}

model IgnoreAggregateEvaluationResultsResponseBody = {
  requestId?: string(name='RequestId'),
}

model IgnoreAggregateEvaluationResultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: IgnoreAggregateEvaluationResultsResponseBody(name='body'),
}

async function ignoreAggregateEvaluationResultsWithOptions(tmpReq: IgnoreAggregateEvaluationResultsRequest, runtime: Util.RuntimeOptions): IgnoreAggregateEvaluationResultsResponse {
  Util.validateModel(tmpReq);
  var request = new IgnoreAggregateEvaluationResultsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resources)) {
    request.resourcesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resources, 'Resources', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.aggregatorId)) {
    body['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.configRuleId)) {
    body['ConfigRuleId'] = request.configRuleId;
  }
  if (!Util.isUnset(request.ignoreDate)) {
    body['IgnoreDate'] = request.ignoreDate;
  }
  if (!Util.isUnset(request.reason)) {
    body['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.resourcesShrink)) {
    body['Resources'] = request.resourcesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'IgnoreAggregateEvaluationResults',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function ignoreAggregateEvaluationResults(request: IgnoreAggregateEvaluationResultsRequest): IgnoreAggregateEvaluationResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return ignoreAggregateEvaluationResultsWithOptions(request, runtime);
}

model IgnoreEvaluationResultsRequest {
  configRuleId?: string(name='ConfigRuleId'),
  ignoreDate?: string(name='IgnoreDate'),
  reason?: string(name='Reason'),
  resources?: [ 
    {
      region?: string(name='Region'),
      resourceAccountId?: long(name='ResourceAccountId'),
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resources'),
}

model IgnoreEvaluationResultsShrinkRequest {
  configRuleId?: string(name='ConfigRuleId'),
  ignoreDate?: string(name='IgnoreDate'),
  reason?: string(name='Reason'),
  resourcesShrink?: string(name='Resources'),
}

model IgnoreEvaluationResultsResponseBody = {
  requestId?: string(name='RequestId'),
}

model IgnoreEvaluationResultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: IgnoreEvaluationResultsResponseBody(name='body'),
}

async function ignoreEvaluationResultsWithOptions(tmpReq: IgnoreEvaluationResultsRequest, runtime: Util.RuntimeOptions): IgnoreEvaluationResultsResponse {
  Util.validateModel(tmpReq);
  var request = new IgnoreEvaluationResultsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resources)) {
    request.resourcesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resources, 'Resources', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.configRuleId)) {
    body['ConfigRuleId'] = request.configRuleId;
  }
  if (!Util.isUnset(request.ignoreDate)) {
    body['IgnoreDate'] = request.ignoreDate;
  }
  if (!Util.isUnset(request.reason)) {
    body['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.resourcesShrink)) {
    body['Resources'] = request.resourcesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'IgnoreEvaluationResults',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function ignoreEvaluationResults(request: IgnoreEvaluationResultsRequest): IgnoreEvaluationResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return ignoreEvaluationResultsWithOptions(request, runtime);
}

model ListAggregateCompliancePacksRequest {
  aggregatorId?: string(name='AggregatorId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model ListAggregateCompliancePacksResponseBody = {
  compliancePacksResult?: {
    compliancePacks?: [ 
      {
        accountId?: long(name='AccountId'),
        aggregatorId?: string(name='AggregatorId'),
        compliancePackId?: string(name='CompliancePackId'),
        compliancePackName?: string(name='CompliancePackName'),
        compliancePackTemplateId?: string(name='CompliancePackTemplateId'),
        createTimestamp?: long(name='CreateTimestamp'),
        description?: string(name='Description'),
        riskLevel?: int32(name='RiskLevel'),
        status?: string(name='Status'),
      }
    ](name='CompliancePacks'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='CompliancePacksResult'),
  requestId?: string(name='RequestId'),
}

model ListAggregateCompliancePacksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAggregateCompliancePacksResponseBody(name='body'),
}

async function listAggregateCompliancePacksWithOptions(request: ListAggregateCompliancePacksRequest, runtime: Util.RuntimeOptions): ListAggregateCompliancePacksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAggregateCompliancePacks',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAggregateCompliancePacks(request: ListAggregateCompliancePacksRequest): ListAggregateCompliancePacksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAggregateCompliancePacksWithOptions(request, runtime);
}

model ListAggregateConfigDeliveryChannelsRequest {
  aggregatorId?: string(name='AggregatorId'),
  deliveryChannelIds?: string(name='DeliveryChannelIds'),
}

model ListAggregateConfigDeliveryChannelsResponseBody = {
  deliveryChannels?: [ 
    {
      accountId?: long(name='AccountId'),
      aggregatorId?: string(name='AggregatorId'),
      configurationItemChangeNotification?: boolean(name='ConfigurationItemChangeNotification'),
      configurationSnapshot?: boolean(name='ConfigurationSnapshot'),
      deliveryChannelAssumeRoleArn?: string(name='DeliveryChannelAssumeRoleArn'),
      deliveryChannelCondition?: string(name='DeliveryChannelCondition'),
      deliveryChannelId?: string(name='DeliveryChannelId'),
      deliveryChannelName?: string(name='DeliveryChannelName'),
      deliveryChannelTargetArn?: string(name='DeliveryChannelTargetArn'),
      deliveryChannelType?: string(name='DeliveryChannelType'),
      description?: string(name='Description'),
      nonCompliantNotification?: boolean(name='NonCompliantNotification'),
      oversizedDataOSSTargetArn?: string(name='OversizedDataOSSTargetArn'),
      status?: int32(name='Status'),
    }
  ](name='DeliveryChannels'),
  requestId?: string(name='RequestId'),
}

model ListAggregateConfigDeliveryChannelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAggregateConfigDeliveryChannelsResponseBody(name='body'),
}

async function listAggregateConfigDeliveryChannelsWithOptions(request: ListAggregateConfigDeliveryChannelsRequest, runtime: Util.RuntimeOptions): ListAggregateConfigDeliveryChannelsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.deliveryChannelIds)) {
    query['DeliveryChannelIds'] = request.deliveryChannelIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAggregateConfigDeliveryChannels',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAggregateConfigDeliveryChannels(request: ListAggregateConfigDeliveryChannelsRequest): ListAggregateConfigDeliveryChannelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAggregateConfigDeliveryChannelsWithOptions(request, runtime);
}

model ListAggregateConfigRuleEvaluationResultsRequest {
  aggregatorId?: string(name='AggregatorId'),
  compliancePackId?: string(name='CompliancePackId'),
  complianceType?: string(name='ComplianceType'),
  configRuleId?: string(name='ConfigRuleId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListAggregateConfigRuleEvaluationResultsResponseBody = {
  evaluationResults?: {
    evaluationResultList?: [ 
      {
        annotation?: string(name='Annotation'),
        complianceType?: string(name='ComplianceType'),
        configRuleInvokedTimestamp?: long(name='ConfigRuleInvokedTimestamp'),
        evaluationResultIdentifier?: {
          evaluationResultQualifier?: {
            compliancePackId?: string(name='CompliancePackId'),
            configRuleArn?: string(name='ConfigRuleArn'),
            configRuleId?: string(name='ConfigRuleId'),
            configRuleName?: string(name='ConfigRuleName'),
            ignoreDate?: string(name='IgnoreDate'),
            regionId?: string(name='RegionId'),
            resourceId?: string(name='ResourceId'),
            resourceName?: string(name='ResourceName'),
            resourceOwnerId?: long(name='ResourceOwnerId'),
            resourceType?: string(name='ResourceType'),
          }(name='EvaluationResultQualifier'),
          orderingTimestamp?: long(name='OrderingTimestamp'),
        }(name='EvaluationResultIdentifier'),
        invokingEventMessageType?: string(name='InvokingEventMessageType'),
        remediationEnabled?: boolean(name='RemediationEnabled'),
        resultRecordedTimestamp?: long(name='ResultRecordedTimestamp'),
        riskLevel?: int32(name='RiskLevel'),
      }
    ](name='EvaluationResultList'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='EvaluationResults'),
  requestId?: string(name='RequestId'),
}

model ListAggregateConfigRuleEvaluationResultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAggregateConfigRuleEvaluationResultsResponseBody(name='body'),
}

async function listAggregateConfigRuleEvaluationResultsWithOptions(request: ListAggregateConfigRuleEvaluationResultsRequest, runtime: Util.RuntimeOptions): ListAggregateConfigRuleEvaluationResultsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAggregateConfigRuleEvaluationResults',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAggregateConfigRuleEvaluationResults(request: ListAggregateConfigRuleEvaluationResultsRequest): ListAggregateConfigRuleEvaluationResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAggregateConfigRuleEvaluationResultsWithOptions(request, runtime);
}

model ListAggregateConfigRulesRequest {
  aggregatorId?: string(name='AggregatorId'),
  complianceType?: string(name='ComplianceType'),
  configRuleName?: string(name='ConfigRuleName'),
  configRuleState?: string(name='ConfigRuleState'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  riskLevel?: int32(name='RiskLevel'),
}

model ListAggregateConfigRulesResponseBody = {
  configRules?: {
    configRuleList?: [ 
      {
        accountId?: long(name='AccountId'),
        automationType?: string(name='AutomationType'),
        compliance?: {
          complianceType?: string(name='ComplianceType'),
          count?: int32(name='Count'),
        }(name='Compliance'),
        configRuleArn?: string(name='ConfigRuleArn'),
        configRuleId?: string(name='ConfigRuleId'),
        configRuleName?: string(name='ConfigRuleName'),
        configRuleState?: string(name='ConfigRuleState'),
        createBy?: {
          aggregatorId?: string(name='AggregatorId'),
          aggregatorName?: string(name='AggregatorName'),
          compliancePackId?: string(name='CompliancePackId'),
          compliancePackName?: string(name='CompliancePackName'),
          creatorId?: string(name='CreatorId'),
          creatorName?: string(name='CreatorName'),
          creatorType?: string(name='CreatorType'),
        }(name='CreateBy'),
        description?: string(name='Description'),
        riskLevel?: int32(name='RiskLevel'),
        sourceIdentifier?: string(name='SourceIdentifier'),
        sourceOwner?: string(name='SourceOwner'),
        tags?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Tags'),
      }
    ](name='ConfigRuleList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='ConfigRules'),
  requestId?: string(name='RequestId'),
}

model ListAggregateConfigRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAggregateConfigRulesResponseBody(name='body'),
}

async function listAggregateConfigRulesWithOptions(request: ListAggregateConfigRulesRequest, runtime: Util.RuntimeOptions): ListAggregateConfigRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.complianceType)) {
    query['ComplianceType'] = request.complianceType;
  }
  if (!Util.isUnset(request.configRuleName)) {
    query['ConfigRuleName'] = request.configRuleName;
  }
  if (!Util.isUnset(request.configRuleState)) {
    query['ConfigRuleState'] = request.configRuleState;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskLevel)) {
    query['RiskLevel'] = request.riskLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAggregateConfigRules',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAggregateConfigRules(request: ListAggregateConfigRulesRequest): ListAggregateConfigRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAggregateConfigRulesWithOptions(request, runtime);
}

model ListAggregateDiscoveredResourcesRequest {
  aggregatorId?: string(name='AggregatorId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regions?: string(name='Regions'),
  resourceDeleted?: int32(name='ResourceDeleted'),
  resourceId?: string(name='ResourceId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceTypes?: string(name='ResourceTypes'),
}

model ListAggregateDiscoveredResourcesResponseBody = {
  discoveredResourceProfiles?: {
    discoveredResourceProfileList?: [ 
      {
        accountId?: long(name='AccountId'),
        region?: string(name='Region'),
        resourceCreationTime?: long(name='ResourceCreationTime'),
        resourceDeleted?: int32(name='ResourceDeleted'),
        resourceId?: string(name='ResourceId'),
        resourceName?: string(name='ResourceName'),
        resourceOwnerId?: long(name='ResourceOwnerId'),
        resourceStatus?: string(name='ResourceStatus'),
        resourceType?: string(name='ResourceType'),
        tags?: string(name='Tags'),
      }
    ](name='DiscoveredResourceProfileList'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
    totalCount?: int32(name='TotalCount'),
  }(name='DiscoveredResourceProfiles'),
  requestId?: string(name='RequestId'),
}

model ListAggregateDiscoveredResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAggregateDiscoveredResourcesResponseBody(name='body'),
}

async function listAggregateDiscoveredResourcesWithOptions(request: ListAggregateDiscoveredResourcesRequest, runtime: Util.RuntimeOptions): ListAggregateDiscoveredResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regions)) {
    query['Regions'] = request.regions;
  }
  if (!Util.isUnset(request.resourceDeleted)) {
    query['ResourceDeleted'] = request.resourceDeleted;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceTypes)) {
    query['ResourceTypes'] = request.resourceTypes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAggregateDiscoveredResources',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAggregateDiscoveredResources(request: ListAggregateDiscoveredResourcesRequest): ListAggregateDiscoveredResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAggregateDiscoveredResourcesWithOptions(request, runtime);
}

model ListAggregateRemediationsRequest {
  aggregatorId?: string(name='AggregatorId'),
  configRuleIds?: string(name='ConfigRuleIds'),
}

model ListAggregateRemediationsResponseBody = {
  remediations?: [ 
    {
      accountId?: long(name='AccountId'),
      aggregatorId?: string(name='AggregatorId'),
      configRuleId?: string(name='ConfigRuleId'),
      invokeType?: string(name='InvokeType'),
      lastSuccessfulInvocationId?: string(name='LastSuccessfulInvocationId'),
      lastSuccessfulInvocationTime?: long(name='LastSuccessfulInvocationTime'),
      lastSuccessfulInvocationType?: string(name='LastSuccessfulInvocationType'),
      remediaitonOriginParams?: string(name='RemediaitonOriginParams'),
      remediationId?: string(name='RemediationId'),
      remediationSourceType?: string(name='RemediationSourceType'),
      remediationTemplateId?: string(name='RemediationTemplateId'),
      remediationType?: string(name='RemediationType'),
    }
  ](name='Remediations'),
  requestId?: string(name='RequestId'),
}

model ListAggregateRemediationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAggregateRemediationsResponseBody(name='body'),
}

async function listAggregateRemediationsWithOptions(request: ListAggregateRemediationsRequest, runtime: Util.RuntimeOptions): ListAggregateRemediationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.configRuleIds)) {
    query['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAggregateRemediations',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAggregateRemediations(request: ListAggregateRemediationsRequest): ListAggregateRemediationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAggregateRemediationsWithOptions(request, runtime);
}

model ListAggregateResourceEvaluationResultsRequest {
  aggregatorId?: string(name='AggregatorId'),
  complianceType?: string(name='ComplianceType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  region?: string(name='Region'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
}

model ListAggregateResourceEvaluationResultsResponseBody = {
  evaluationResults?: {
    evaluationResultList?: [ 
      {
        annotation?: string(name='Annotation'),
        complianceType?: string(name='ComplianceType'),
        configRuleInvokedTimestamp?: long(name='ConfigRuleInvokedTimestamp'),
        evaluationResultIdentifier?: {
          evaluationResultQualifier?: {
            configRuleArn?: string(name='ConfigRuleArn'),
            configRuleId?: string(name='ConfigRuleId'),
            configRuleName?: string(name='ConfigRuleName'),
            ignoreDate?: string(name='IgnoreDate'),
            regionId?: string(name='RegionId'),
            resourceId?: string(name='ResourceId'),
            resourceName?: string(name='ResourceName'),
            resourceType?: string(name='ResourceType'),
          }(name='EvaluationResultQualifier'),
          orderingTimestamp?: long(name='OrderingTimestamp'),
        }(name='EvaluationResultIdentifier'),
        invokingEventMessageType?: string(name='InvokingEventMessageType'),
        remediationEnabled?: boolean(name='RemediationEnabled'),
        resultRecordedTimestamp?: long(name='ResultRecordedTimestamp'),
        riskLevel?: int32(name='RiskLevel'),
      }
    ](name='EvaluationResultList'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='EvaluationResults'),
  requestId?: string(name='RequestId'),
}

model ListAggregateResourceEvaluationResultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAggregateResourceEvaluationResultsResponseBody(name='body'),
}

async function listAggregateResourceEvaluationResultsWithOptions(request: ListAggregateResourceEvaluationResultsRequest, runtime: Util.RuntimeOptions): ListAggregateResourceEvaluationResultsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.complianceType)) {
    query['ComplianceType'] = request.complianceType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAggregateResourceEvaluationResults',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAggregateResourceEvaluationResults(request: ListAggregateResourceEvaluationResultsRequest): ListAggregateResourceEvaluationResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAggregateResourceEvaluationResultsWithOptions(request, runtime);
}

model ListAggregatorsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListAggregatorsResponseBody = {
  aggregatorsResult?: {
    aggregators?: [ 
      {
        accountId?: long(name='AccountId'),
        aggregatorAccountCount?: long(name='AggregatorAccountCount'),
        aggregatorCreateTimestamp?: long(name='AggregatorCreateTimestamp'),
        aggregatorId?: string(name='AggregatorId'),
        aggregatorName?: string(name='AggregatorName'),
        aggregatorStatus?: int32(name='AggregatorStatus'),
        aggregatorType?: string(name='AggregatorType'),
        description?: string(name='Description'),
      }
    ](name='Aggregators'),
    nextToken?: string(name='NextToken'),
  }(name='AggregatorsResult'),
  requestId?: string(name='RequestId'),
}

model ListAggregatorsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAggregatorsResponseBody(name='body'),
}

async function listAggregatorsWithOptions(request: ListAggregatorsRequest, runtime: Util.RuntimeOptions): ListAggregatorsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAggregators',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAggregators(request: ListAggregatorsRequest): ListAggregatorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAggregatorsWithOptions(request, runtime);
}

model ListCompliancePackTemplatesRequest {
  compliancePackTemplateId?: string(name='CompliancePackTemplateId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListCompliancePackTemplatesResponseBody = {
  compliancePackTemplatesResult?: {
    compliancePackTemplates?: [ 
      {
        compliancePackTemplateId?: string(name='CompliancePackTemplateId'),
        compliancePackTemplateName?: string(name='CompliancePackTemplateName'),
        configRules?: [ 
          {
            configRuleParameters?: [ 
              {
                parameterName?: string(name='ParameterName'),
                parameterValue?: string(name='ParameterValue'),
                required?: boolean(name='Required'),
              }
            ](name='ConfigRuleParameters'),
            description?: string(name='Description'),
            managedRuleIdentifier?: string(name='ManagedRuleIdentifier'),
            managedRuleName?: string(name='ManagedRuleName'),
            riskLevel?: int32(name='RiskLevel'),
          }
        ](name='ConfigRules'),
        description?: string(name='Description'),
        riskLevel?: int32(name='RiskLevel'),
      }
    ](name='CompliancePackTemplates'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='CompliancePackTemplatesResult'),
  requestId?: string(name='RequestId'),
}

model ListCompliancePackTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCompliancePackTemplatesResponseBody(name='body'),
}

async function listCompliancePackTemplatesWithOptions(request: ListCompliancePackTemplatesRequest, runtime: Util.RuntimeOptions): ListCompliancePackTemplatesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCompliancePackTemplates',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCompliancePackTemplates(request: ListCompliancePackTemplatesRequest): ListCompliancePackTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCompliancePackTemplatesWithOptions(request, runtime);
}

model ListCompliancePacksRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model ListCompliancePacksResponseBody = {
  compliancePacksResult?: {
    compliancePacks?: [ 
      {
        accountId?: long(name='AccountId'),
        compliancePackId?: string(name='CompliancePackId'),
        compliancePackName?: string(name='CompliancePackName'),
        compliancePackTemplateId?: string(name='CompliancePackTemplateId'),
        createTimestamp?: long(name='CreateTimestamp'),
        description?: string(name='Description'),
        riskLevel?: int32(name='RiskLevel'),
        status?: string(name='Status'),
      }
    ](name='CompliancePacks'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='CompliancePacksResult'),
  requestId?: string(name='RequestId'),
}

model ListCompliancePacksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCompliancePacksResponseBody(name='body'),
}

async function listCompliancePacksWithOptions(request: ListCompliancePacksRequest, runtime: Util.RuntimeOptions): ListCompliancePacksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCompliancePacks',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCompliancePacks(request: ListCompliancePacksRequest): ListCompliancePacksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCompliancePacksWithOptions(request, runtime);
}

model ListConfigDeliveryChannelsRequest {
  deliveryChannelIds?: string(name='DeliveryChannelIds'),
}

model ListConfigDeliveryChannelsResponseBody = {
  deliveryChannels?: [ 
    {
      accountId?: long(name='AccountId'),
      configurationItemChangeNotification?: boolean(name='ConfigurationItemChangeNotification'),
      configurationSnapshot?: boolean(name='ConfigurationSnapshot'),
      deliveryChannelAssumeRoleArn?: string(name='DeliveryChannelAssumeRoleArn'),
      deliveryChannelCondition?: string(name='DeliveryChannelCondition'),
      deliveryChannelId?: string(name='DeliveryChannelId'),
      deliveryChannelName?: string(name='DeliveryChannelName'),
      deliveryChannelTargetArn?: string(name='DeliveryChannelTargetArn'),
      deliveryChannelType?: string(name='DeliveryChannelType'),
      description?: string(name='Description'),
      nonCompliantNotification?: boolean(name='NonCompliantNotification'),
      oversizedDataOSSTargetArn?: string(name='OversizedDataOSSTargetArn'),
      status?: int32(name='Status'),
    }
  ](name='DeliveryChannels'),
  requestId?: string(name='RequestId'),
}

model ListConfigDeliveryChannelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConfigDeliveryChannelsResponseBody(name='body'),
}

async function listConfigDeliveryChannelsWithOptions(request: ListConfigDeliveryChannelsRequest, runtime: Util.RuntimeOptions): ListConfigDeliveryChannelsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deliveryChannelIds)) {
    query['DeliveryChannelIds'] = request.deliveryChannelIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConfigDeliveryChannels',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listConfigDeliveryChannels(request: ListConfigDeliveryChannelsRequest): ListConfigDeliveryChannelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConfigDeliveryChannelsWithOptions(request, runtime);
}

model ListConfigRuleEvaluationResultsRequest {
  compliancePackId?: string(name='CompliancePackId'),
  complianceType?: string(name='ComplianceType'),
  configRuleId?: string(name='ConfigRuleId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListConfigRuleEvaluationResultsResponseBody = {
  evaluationResults?: {
    evaluationResultList?: [ 
      {
        annotation?: string(name='Annotation'),
        complianceType?: string(name='ComplianceType'),
        configRuleInvokedTimestamp?: long(name='ConfigRuleInvokedTimestamp'),
        evaluationResultIdentifier?: {
          evaluationResultQualifier?: {
            compliancePackId?: string(name='CompliancePackId'),
            configRuleArn?: string(name='ConfigRuleArn'),
            configRuleId?: string(name='ConfigRuleId'),
            configRuleName?: string(name='ConfigRuleName'),
            ignoreDate?: string(name='IgnoreDate'),
            regionId?: string(name='RegionId'),
            resourceId?: string(name='ResourceId'),
            resourceName?: string(name='ResourceName'),
            resourceOwnerId?: long(name='ResourceOwnerId'),
            resourceType?: string(name='ResourceType'),
          }(name='EvaluationResultQualifier'),
          orderingTimestamp?: long(name='OrderingTimestamp'),
        }(name='EvaluationResultIdentifier'),
        invokingEventMessageType?: string(name='InvokingEventMessageType'),
        remediationEnabled?: boolean(name='RemediationEnabled'),
        resultRecordedTimestamp?: long(name='ResultRecordedTimestamp'),
        riskLevel?: int32(name='RiskLevel'),
      }
    ](name='EvaluationResultList'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='EvaluationResults'),
  requestId?: string(name='RequestId'),
}

model ListConfigRuleEvaluationResultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConfigRuleEvaluationResultsResponseBody(name='body'),
}

async function listConfigRuleEvaluationResultsWithOptions(request: ListConfigRuleEvaluationResultsRequest, runtime: Util.RuntimeOptions): ListConfigRuleEvaluationResultsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConfigRuleEvaluationResults',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listConfigRuleEvaluationResults(request: ListConfigRuleEvaluationResultsRequest): ListConfigRuleEvaluationResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConfigRuleEvaluationResultsWithOptions(request, runtime);
}

model ListDiscoveredResourcesRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regions?: string(name='Regions'),
  resourceDeleted?: int32(name='ResourceDeleted'),
  resourceId?: string(name='ResourceId'),
  resourceTypes?: string(name='ResourceTypes'),
}

model ListDiscoveredResourcesResponseBody = {
  discoveredResourceProfiles?: {
    discoveredResourceProfileList?: [ 
      {
        accountId?: long(name='AccountId'),
        region?: string(name='Region'),
        resourceCreationTime?: long(name='ResourceCreationTime'),
        resourceDeleted?: int32(name='ResourceDeleted'),
        resourceId?: string(name='ResourceId'),
        resourceName?: string(name='ResourceName'),
        resourceStatus?: string(name='ResourceStatus'),
        resourceType?: string(name='ResourceType'),
        tags?: string(name='Tags'),
      }
    ](name='DiscoveredResourceProfileList'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
    totalCount?: int32(name='TotalCount'),
  }(name='DiscoveredResourceProfiles'),
  requestId?: string(name='RequestId'),
}

model ListDiscoveredResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDiscoveredResourcesResponseBody(name='body'),
}

async function listDiscoveredResourcesWithOptions(request: ListDiscoveredResourcesRequest, runtime: Util.RuntimeOptions): ListDiscoveredResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regions)) {
    query['Regions'] = request.regions;
  }
  if (!Util.isUnset(request.resourceDeleted)) {
    query['ResourceDeleted'] = request.resourceDeleted;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceTypes)) {
    query['ResourceTypes'] = request.resourceTypes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDiscoveredResources',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDiscoveredResources(request: ListDiscoveredResourcesRequest): ListDiscoveredResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDiscoveredResourcesWithOptions(request, runtime);
}

model ListManagedRulesRequest {
  keyword?: string(name='Keyword'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  riskLevel?: int32(name='RiskLevel'),
}

model ListManagedRulesResponseBody = {
  managedRules?: [ 
    {
      managedRuleList?: [ 
        {
          configRuleName?: string(name='ConfigRuleName'),
          description?: string(name='Description'),
          helpUrls?: string(name='HelpUrls'),
          identifier?: string(name='Identifier'),
          labels?: [ string ](name='Labels'),
          riskLevel?: int32(name='RiskLevel'),
        }
      ](name='ManagedRuleList'),
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize'),
      totalCount?: long(name='TotalCount'),
    }
  ](name='ManagedRules'),
  requestId?: string(name='RequestId'),
}

model ListManagedRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListManagedRulesResponseBody(name='body'),
}

async function listManagedRulesWithOptions(request: ListManagedRulesRequest, runtime: Util.RuntimeOptions): ListManagedRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskLevel)) {
    query['RiskLevel'] = request.riskLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListManagedRules',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listManagedRules(request: ListManagedRulesRequest): ListManagedRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listManagedRulesWithOptions(request, runtime);
}

model ListRemediationTemplatesRequest {
  managedRuleIdentifier?: string(name='ManagedRuleIdentifier'),
  remediationType?: string(name='RemediationType'),
}

model ListRemediationTemplatesResponseBody = {
  remediationTemplates?: [ 
    {
      remediationType?: string(name='RemediationType'),
      templateDefinition?: string(name='TemplateDefinition'),
      templateIdentifier?: string(name='TemplateIdentifier'),
      templateName?: string(name='TemplateName'),
    }
  ](name='RemediationTemplates'),
  requestId?: string(name='RequestId'),
}

model ListRemediationTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRemediationTemplatesResponseBody(name='body'),
}

async function listRemediationTemplatesWithOptions(request: ListRemediationTemplatesRequest, runtime: Util.RuntimeOptions): ListRemediationTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.managedRuleIdentifier)) {
    query['ManagedRuleIdentifier'] = request.managedRuleIdentifier;
  }
  if (!Util.isUnset(request.remediationType)) {
    query['RemediationType'] = request.remediationType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRemediationTemplates',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRemediationTemplates(request: ListRemediationTemplatesRequest): ListRemediationTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRemediationTemplatesWithOptions(request, runtime);
}

model ListRemediationsRequest {
  configRuleIds?: string(name='ConfigRuleIds'),
}

model ListRemediationsResponseBody = {
  remediations?: [ 
    {
      accountId?: long(name='AccountId'),
      configRuleId?: string(name='ConfigRuleId'),
      invokeType?: string(name='InvokeType'),
      lastSuccessfulInvocationId?: string(name='LastSuccessfulInvocationId'),
      lastSuccessfulInvocationTime?: long(name='LastSuccessfulInvocationTime'),
      lastSuccessfulInvocationType?: string(name='LastSuccessfulInvocationType'),
      remediationId?: string(name='RemediationId'),
      remediationOriginParams?: string(name='RemediationOriginParams'),
      remediationSourceType?: string(name='RemediationSourceType'),
      remediationTemplateId?: string(name='RemediationTemplateId'),
      remediationType?: string(name='RemediationType'),
    }
  ](name='Remediations'),
  requestId?: string(name='RequestId'),
}

model ListRemediationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRemediationsResponseBody(name='body'),
}

async function listRemediationsWithOptions(request: ListRemediationsRequest, runtime: Util.RuntimeOptions): ListRemediationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configRuleIds)) {
    query['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRemediations',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRemediations(request: ListRemediationsRequest): ListRemediationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRemediationsWithOptions(request, runtime);
}

model ListResourceEvaluationResultsRequest {
  complianceType?: string(name='ComplianceType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  region?: string(name='Region'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
}

model ListResourceEvaluationResultsResponseBody = {
  evaluationResults?: {
    evaluationResultList?: [ 
      {
        annotation?: string(name='Annotation'),
        complianceType?: string(name='ComplianceType'),
        configRuleInvokedTimestamp?: long(name='ConfigRuleInvokedTimestamp'),
        evaluationResultIdentifier?: {
          evaluationResultQualifier?: {
            configRuleArn?: string(name='ConfigRuleArn'),
            configRuleId?: string(name='ConfigRuleId'),
            configRuleName?: string(name='ConfigRuleName'),
            ignoreDate?: string(name='IgnoreDate'),
            regionId?: string(name='RegionId'),
            resourceId?: string(name='ResourceId'),
            resourceName?: string(name='ResourceName'),
            resourceType?: string(name='ResourceType'),
          }(name='EvaluationResultQualifier'),
          orderingTimestamp?: long(name='OrderingTimestamp'),
        }(name='EvaluationResultIdentifier'),
        invokingEventMessageType?: string(name='InvokingEventMessageType'),
        remediationEnabled?: boolean(name='RemediationEnabled'),
        resultRecordedTimestamp?: long(name='ResultRecordedTimestamp'),
        riskLevel?: int32(name='RiskLevel'),
      }
    ](name='EvaluationResultList'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='EvaluationResults'),
  requestId?: string(name='RequestId'),
}

model ListResourceEvaluationResultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceEvaluationResultsResponseBody(name='body'),
}

async function listResourceEvaluationResultsWithOptions(request: ListResourceEvaluationResultsRequest, runtime: Util.RuntimeOptions): ListResourceEvaluationResultsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.complianceType)) {
    query['ComplianceType'] = request.complianceType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceEvaluationResults',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceEvaluationResults(request: ListResourceEvaluationResultsRequest): ListResourceEvaluationResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceEvaluationResultsWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', description='Token'),
  regionId?: string(name='RegionId', description=''),
  resourceId?: [ string ](name='ResourceId', description='ID, 50'),
  resourceType?: string(name='ResourceType', description=''),
  tag?: [ 
    {
      key?: string(name='Key', description=''),
      value?: string(name='Value', description=''),
    }
  ](name='Tag', description='20'),
}

model ListTagResourcesShrinkRequest {
  nextToken?: string(name='NextToken', description='Token'),
  regionId?: string(name='RegionId', description=''),
  resourceId?: [ string ](name='ResourceId', description='ID, 50'),
  resourceType?: string(name='ResourceType', description=''),
  tagShrink?: string(name='Tag', description='20'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='TokenNextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(tmpReq: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tag)) {
    request.tagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tag, 'Tag', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    body['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagShrink)) {
    body['Tag'] = request.tagShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model RevertAggregateEvaluationResultsRequest {
  aggregatorId?: string(name='AggregatorId'),
  configRuleId?: string(name='ConfigRuleId'),
  resources?: [ 
    {
      region?: string(name='Region'),
      resourceAccountId?: long(name='ResourceAccountId'),
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resources'),
}

model RevertAggregateEvaluationResultsShrinkRequest {
  aggregatorId?: string(name='AggregatorId'),
  configRuleId?: string(name='ConfigRuleId'),
  resourcesShrink?: string(name='Resources'),
}

model RevertAggregateEvaluationResultsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevertAggregateEvaluationResultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevertAggregateEvaluationResultsResponseBody(name='body'),
}

async function revertAggregateEvaluationResultsWithOptions(tmpReq: RevertAggregateEvaluationResultsRequest, runtime: Util.RuntimeOptions): RevertAggregateEvaluationResultsResponse {
  Util.validateModel(tmpReq);
  var request = new RevertAggregateEvaluationResultsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resources)) {
    request.resourcesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resources, 'Resources', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.aggregatorId)) {
    body['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.configRuleId)) {
    body['ConfigRuleId'] = request.configRuleId;
  }
  if (!Util.isUnset(request.resourcesShrink)) {
    body['Resources'] = request.resourcesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RevertAggregateEvaluationResults',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revertAggregateEvaluationResults(request: RevertAggregateEvaluationResultsRequest): RevertAggregateEvaluationResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return revertAggregateEvaluationResultsWithOptions(request, runtime);
}

model RevertEvaluationResultsRequest {
  configRuleId?: string(name='ConfigRuleId'),
  resources?: [ 
    {
      region?: string(name='Region'),
      resourceAccountId?: long(name='ResourceAccountId'),
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resources'),
}

model RevertEvaluationResultsShrinkRequest {
  configRuleId?: string(name='ConfigRuleId'),
  resourcesShrink?: string(name='Resources'),
}

model RevertEvaluationResultsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevertEvaluationResultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevertEvaluationResultsResponseBody(name='body'),
}

async function revertEvaluationResultsWithOptions(tmpReq: RevertEvaluationResultsRequest, runtime: Util.RuntimeOptions): RevertEvaluationResultsResponse {
  Util.validateModel(tmpReq);
  var request = new RevertEvaluationResultsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resources)) {
    request.resourcesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resources, 'Resources', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.configRuleId)) {
    body['ConfigRuleId'] = request.configRuleId;
  }
  if (!Util.isUnset(request.resourcesShrink)) {
    body['Resources'] = request.resourcesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RevertEvaluationResults',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revertEvaluationResults(request: RevertEvaluationResultsRequest): RevertEvaluationResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return revertEvaluationResultsWithOptions(request, runtime);
}

model StartAggregateConfigRuleEvaluationRequest {
  aggregatorId?: string(name='AggregatorId'),
  compliancePackId?: string(name='CompliancePackId'),
  configRuleId?: string(name='ConfigRuleId'),
  revertEvaluation?: boolean(name='RevertEvaluation'),
}

model StartAggregateConfigRuleEvaluationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model StartAggregateConfigRuleEvaluationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartAggregateConfigRuleEvaluationResponseBody(name='body'),
}

async function startAggregateConfigRuleEvaluationWithOptions(request: StartAggregateConfigRuleEvaluationRequest, runtime: Util.RuntimeOptions): StartAggregateConfigRuleEvaluationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.compliancePackId)) {
    query['CompliancePackId'] = request.compliancePackId;
  }
  if (!Util.isUnset(request.configRuleId)) {
    query['ConfigRuleId'] = request.configRuleId;
  }
  if (!Util.isUnset(request.revertEvaluation)) {
    query['RevertEvaluation'] = request.revertEvaluation;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartAggregateConfigRuleEvaluation',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startAggregateConfigRuleEvaluation(request: StartAggregateConfigRuleEvaluationRequest): StartAggregateConfigRuleEvaluationResponse {
  var runtime = new Util.RuntimeOptions{};
  return startAggregateConfigRuleEvaluationWithOptions(request, runtime);
}

model StartAggregateRemediationRequest {
  aggregatorId?: string(name='AggregatorId'),
  configRuleId?: string(name='ConfigRuleId'),
}

model StartAggregateRemediationResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model StartAggregateRemediationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartAggregateRemediationResponseBody(name='body'),
}

async function startAggregateRemediationWithOptions(request: StartAggregateRemediationRequest, runtime: Util.RuntimeOptions): StartAggregateRemediationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.configRuleId)) {
    query['ConfigRuleId'] = request.configRuleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartAggregateRemediation',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startAggregateRemediation(request: StartAggregateRemediationRequest): StartAggregateRemediationResponse {
  var runtime = new Util.RuntimeOptions{};
  return startAggregateRemediationWithOptions(request, runtime);
}

model StartRemediationRequest {
  configRuleId?: string(name='ConfigRuleId'),
}

model StartRemediationResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model StartRemediationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartRemediationResponseBody(name='body'),
}

async function startRemediationWithOptions(request: StartRemediationRequest, runtime: Util.RuntimeOptions): StartRemediationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configRuleId)) {
    query['ConfigRuleId'] = request.configRuleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartRemediation',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startRemediation(request: StartRemediationRequest): StartRemediationResponse {
  var runtime = new Util.RuntimeOptions{};
  return startRemediationWithOptions(request, runtime);
}

model TagResourcesRequest {
  regionId?: string(name='RegionId', description=''),
  resourceId?: [ string ](name='ResourceId', description='ID, 50'),
  resourceType?: string(name='ResourceType', description=''),
  tag?: [ 
    {
      key?: string(name='Key', description=''),
      value?: string(name='Value', description=''),
    }
  ](name='Tag', description='20'),
}

model TagResourcesShrinkRequest {
  regionId?: string(name='RegionId', description=''),
  resourceId?: [ string ](name='ResourceId', description='ID, 50'),
  resourceType?: string(name='ResourceType', description=''),
  tagShrink?: string(name='Tag', description='20'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(tmpReq: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new TagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tag)) {
    request.tagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tag, 'Tag', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    body['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagShrink)) {
    body['Tag'] = request.tagShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  regionId?: string(name='RegionId', description=''),
  resourceId?: [ string ](name='ResourceId', description='ID, 50'),
  resourceType?: string(name='ResourceType', description=''),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.all)) {
    body['All'] = request.all;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    body['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    body['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateAggregateCompliancePackRequest {
  aggregatorId?: string(name='AggregatorId'),
  clientToken?: string(name='ClientToken'),
  compliancePackId?: string(name='CompliancePackId'),
  compliancePackName?: string(name='CompliancePackName'),
  configRules?: [ 
    {
      configRuleId?: string(name='ConfigRuleId'),
      configRuleName?: string(name='ConfigRuleName'),
      configRuleParameters?: [ 
        {
          parameterName?: string(name='ParameterName'),
          parameterValue?: string(name='ParameterValue'),
        }
      ](name='ConfigRuleParameters'),
      description?: string(name='Description'),
      managedRuleIdentifier?: string(name='ManagedRuleIdentifier'),
      riskLevel?: int32(name='RiskLevel'),
    }
  ](name='ConfigRules'),
  description?: string(name='Description'),
  riskLevel?: int32(name='RiskLevel'),
}

model UpdateAggregateCompliancePackShrinkRequest {
  aggregatorId?: string(name='AggregatorId'),
  clientToken?: string(name='ClientToken'),
  compliancePackId?: string(name='CompliancePackId'),
  compliancePackName?: string(name='CompliancePackName'),
  configRulesShrink?: string(name='ConfigRules'),
  description?: string(name='Description'),
  riskLevel?: int32(name='RiskLevel'),
}

model UpdateAggregateCompliancePackResponseBody = {
  compliancePackId?: string(name='CompliancePackId'),
  requestId?: string(name='RequestId'),
}

model UpdateAggregateCompliancePackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAggregateCompliancePackResponseBody(name='body'),
}

async function updateAggregateCompliancePackWithOptions(tmpReq: UpdateAggregateCompliancePackRequest, runtime: Util.RuntimeOptions): UpdateAggregateCompliancePackResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateAggregateCompliancePackShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.configRules)) {
    request.configRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.configRules, 'ConfigRules', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.aggregatorId)) {
    body['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.compliancePackId)) {
    body['CompliancePackId'] = request.compliancePackId;
  }
  if (!Util.isUnset(request.compliancePackName)) {
    body['CompliancePackName'] = request.compliancePackName;
  }
  if (!Util.isUnset(request.configRulesShrink)) {
    body['ConfigRules'] = request.configRulesShrink;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.riskLevel)) {
    body['RiskLevel'] = request.riskLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAggregateCompliancePack',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAggregateCompliancePack(request: UpdateAggregateCompliancePackRequest): UpdateAggregateCompliancePackResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAggregateCompliancePackWithOptions(request, runtime);
}

model UpdateAggregateConfigDeliveryChannelRequest {
  aggregatorId?: string(name='AggregatorId'),
  clientToken?: string(name='ClientToken'),
  configurationItemChangeNotification?: boolean(name='ConfigurationItemChangeNotification'),
  configurationSnapshot?: boolean(name='ConfigurationSnapshot'),
  deliveryChannelCondition?: string(name='DeliveryChannelCondition'),
  deliveryChannelId?: string(name='DeliveryChannelId'),
  deliveryChannelName?: string(name='DeliveryChannelName'),
  deliveryChannelTargetArn?: string(name='DeliveryChannelTargetArn'),
  description?: string(name='Description'),
  nonCompliantNotification?: boolean(name='NonCompliantNotification'),
  oversizedDataOSSTargetArn?: string(name='OversizedDataOSSTargetArn'),
  status?: long(name='Status'),
}

model UpdateAggregateConfigDeliveryChannelResponseBody = {
  deliveryChannelId?: string(name='DeliveryChannelId'),
  requestId?: string(name='RequestId'),
}

model UpdateAggregateConfigDeliveryChannelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAggregateConfigDeliveryChannelResponseBody(name='body'),
}

async function updateAggregateConfigDeliveryChannelWithOptions(request: UpdateAggregateConfigDeliveryChannelRequest, runtime: Util.RuntimeOptions): UpdateAggregateConfigDeliveryChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configurationItemChangeNotification)) {
    query['ConfigurationItemChangeNotification'] = request.configurationItemChangeNotification;
  }
  if (!Util.isUnset(request.configurationSnapshot)) {
    query['ConfigurationSnapshot'] = request.configurationSnapshot;
  }
  if (!Util.isUnset(request.deliveryChannelCondition)) {
    query['DeliveryChannelCondition'] = request.deliveryChannelCondition;
  }
  if (!Util.isUnset(request.deliveryChannelId)) {
    query['DeliveryChannelId'] = request.deliveryChannelId;
  }
  if (!Util.isUnset(request.deliveryChannelName)) {
    query['DeliveryChannelName'] = request.deliveryChannelName;
  }
  if (!Util.isUnset(request.deliveryChannelTargetArn)) {
    query['DeliveryChannelTargetArn'] = request.deliveryChannelTargetArn;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.nonCompliantNotification)) {
    query['NonCompliantNotification'] = request.nonCompliantNotification;
  }
  if (!Util.isUnset(request.oversizedDataOSSTargetArn)) {
    query['OversizedDataOSSTargetArn'] = request.oversizedDataOSSTargetArn;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAggregateConfigDeliveryChannel',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAggregateConfigDeliveryChannel(request: UpdateAggregateConfigDeliveryChannelRequest): UpdateAggregateConfigDeliveryChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAggregateConfigDeliveryChannelWithOptions(request, runtime);
}

model UpdateAggregateConfigRuleRequest {
  aggregatorId?: string(name='AggregatorId'),
  clientToken?: string(name='ClientToken'),
  configRuleId?: string(name='ConfigRuleId'),
  configRuleName?: string(name='ConfigRuleName'),
  configRuleTriggerTypes?: string(name='ConfigRuleTriggerTypes'),
  description?: string(name='Description'),
  excludeAccountIdsScope?: string(name='ExcludeAccountIdsScope'),
  excludeFolderIdsScope?: string(name='ExcludeFolderIdsScope'),
  excludeResourceIdsScope?: string(name='ExcludeResourceIdsScope'),
  folderIdsScope?: string(name='FolderIdsScope'),
  inputParameters?: map[string]any(name='InputParameters'),
  maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
  regionIdsScope?: string(name='RegionIdsScope'),
  resourceGroupIdsScope?: string(name='ResourceGroupIdsScope'),
  resourceTypesScope?: [ string ](name='ResourceTypesScope'),
  riskLevel?: int32(name='RiskLevel'),
  tagKeyLogicScope?: string(name='TagKeyLogicScope'),
  tagKeyScope?: string(name='TagKeyScope'),
  tagValueScope?: string(name='TagValueScope'),
}

model UpdateAggregateConfigRuleShrinkRequest {
  aggregatorId?: string(name='AggregatorId'),
  clientToken?: string(name='ClientToken'),
  configRuleId?: string(name='ConfigRuleId'),
  configRuleName?: string(name='ConfigRuleName'),
  configRuleTriggerTypes?: string(name='ConfigRuleTriggerTypes'),
  description?: string(name='Description'),
  excludeAccountIdsScope?: string(name='ExcludeAccountIdsScope'),
  excludeFolderIdsScope?: string(name='ExcludeFolderIdsScope'),
  excludeResourceIdsScope?: string(name='ExcludeResourceIdsScope'),
  folderIdsScope?: string(name='FolderIdsScope'),
  inputParametersShrink?: string(name='InputParameters'),
  maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
  regionIdsScope?: string(name='RegionIdsScope'),
  resourceGroupIdsScope?: string(name='ResourceGroupIdsScope'),
  resourceTypesScopeShrink?: string(name='ResourceTypesScope'),
  riskLevel?: int32(name='RiskLevel'),
  tagKeyLogicScope?: string(name='TagKeyLogicScope'),
  tagKeyScope?: string(name='TagKeyScope'),
  tagValueScope?: string(name='TagValueScope'),
}

model UpdateAggregateConfigRuleResponseBody = {
  configRuleId?: string(name='ConfigRuleId'),
  requestId?: string(name='RequestId'),
}

model UpdateAggregateConfigRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAggregateConfigRuleResponseBody(name='body'),
}

async function updateAggregateConfigRuleWithOptions(tmpReq: UpdateAggregateConfigRuleRequest, runtime: Util.RuntimeOptions): UpdateAggregateConfigRuleResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateAggregateConfigRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.inputParameters)) {
    request.inputParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.inputParameters, 'InputParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.resourceTypesScope)) {
    request.resourceTypesScopeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceTypesScope, 'ResourceTypesScope', 'simple');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.aggregatorId)) {
    body['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configRuleId)) {
    body['ConfigRuleId'] = request.configRuleId;
  }
  if (!Util.isUnset(request.configRuleName)) {
    body['ConfigRuleName'] = request.configRuleName;
  }
  if (!Util.isUnset(request.configRuleTriggerTypes)) {
    body['ConfigRuleTriggerTypes'] = request.configRuleTriggerTypes;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.excludeAccountIdsScope)) {
    body['ExcludeAccountIdsScope'] = request.excludeAccountIdsScope;
  }
  if (!Util.isUnset(request.excludeFolderIdsScope)) {
    body['ExcludeFolderIdsScope'] = request.excludeFolderIdsScope;
  }
  if (!Util.isUnset(request.excludeResourceIdsScope)) {
    body['ExcludeResourceIdsScope'] = request.excludeResourceIdsScope;
  }
  if (!Util.isUnset(request.folderIdsScope)) {
    body['FolderIdsScope'] = request.folderIdsScope;
  }
  if (!Util.isUnset(request.inputParametersShrink)) {
    body['InputParameters'] = request.inputParametersShrink;
  }
  if (!Util.isUnset(request.maximumExecutionFrequency)) {
    body['MaximumExecutionFrequency'] = request.maximumExecutionFrequency;
  }
  if (!Util.isUnset(request.regionIdsScope)) {
    body['RegionIdsScope'] = request.regionIdsScope;
  }
  if (!Util.isUnset(request.resourceGroupIdsScope)) {
    body['ResourceGroupIdsScope'] = request.resourceGroupIdsScope;
  }
  if (!Util.isUnset(request.resourceTypesScopeShrink)) {
    body['ResourceTypesScope'] = request.resourceTypesScopeShrink;
  }
  if (!Util.isUnset(request.riskLevel)) {
    body['RiskLevel'] = request.riskLevel;
  }
  if (!Util.isUnset(request.tagKeyLogicScope)) {
    body['TagKeyLogicScope'] = request.tagKeyLogicScope;
  }
  if (!Util.isUnset(request.tagKeyScope)) {
    body['TagKeyScope'] = request.tagKeyScope;
  }
  if (!Util.isUnset(request.tagValueScope)) {
    body['TagValueScope'] = request.tagValueScope;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAggregateConfigRule',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAggregateConfigRule(request: UpdateAggregateConfigRuleRequest): UpdateAggregateConfigRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAggregateConfigRuleWithOptions(request, runtime);
}

model UpdateAggregateRemediationRequest {
  aggregatorId?: string(name='AggregatorId'),
  invokeType?: string(name='InvokeType'),
  params?: string(name='Params'),
  remediationId?: string(name='RemediationId'),
  remediationTemplateId?: string(name='RemediationTemplateId'),
  remediationType?: string(name='RemediationType'),
  sourceType?: string(name='SourceType'),
}

model UpdateAggregateRemediationResponseBody = {
  remediationId?: string(name='RemediationId'),
  requestId?: string(name='RequestId'),
}

model UpdateAggregateRemediationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAggregateRemediationResponseBody(name='body'),
}

async function updateAggregateRemediationWithOptions(request: UpdateAggregateRemediationRequest, runtime: Util.RuntimeOptions): UpdateAggregateRemediationResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.aggregatorId)) {
    body['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.invokeType)) {
    body['InvokeType'] = request.invokeType;
  }
  if (!Util.isUnset(request.params)) {
    body['Params'] = request.params;
  }
  if (!Util.isUnset(request.remediationId)) {
    body['RemediationId'] = request.remediationId;
  }
  if (!Util.isUnset(request.remediationTemplateId)) {
    body['RemediationTemplateId'] = request.remediationTemplateId;
  }
  if (!Util.isUnset(request.remediationType)) {
    body['RemediationType'] = request.remediationType;
  }
  if (!Util.isUnset(request.sourceType)) {
    body['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAggregateRemediation',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAggregateRemediation(request: UpdateAggregateRemediationRequest): UpdateAggregateRemediationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAggregateRemediationWithOptions(request, runtime);
}

model UpdateAggregatorRequest {
  aggregatorAccounts?: [ 
    {
      accountId?: long(name='AccountId'),
      accountName?: string(name='AccountName'),
      accountType?: string(name='AccountType'),
    }
  ](name='AggregatorAccounts'),
  aggregatorId?: string(name='AggregatorId'),
  aggregatorName?: string(name='AggregatorName'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
}

model UpdateAggregatorShrinkRequest {
  aggregatorAccountsShrink?: string(name='AggregatorAccounts'),
  aggregatorId?: string(name='AggregatorId'),
  aggregatorName?: string(name='AggregatorName'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
}

model UpdateAggregatorResponseBody = {
  aggregatorId?: string(name='AggregatorId'),
  requestId?: string(name='RequestId'),
}

model UpdateAggregatorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAggregatorResponseBody(name='body'),
}

async function updateAggregatorWithOptions(tmpReq: UpdateAggregatorRequest, runtime: Util.RuntimeOptions): UpdateAggregatorResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateAggregatorShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.aggregatorAccounts)) {
    request.aggregatorAccountsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.aggregatorAccounts, 'AggregatorAccounts', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.aggregatorAccountsShrink)) {
    body['AggregatorAccounts'] = request.aggregatorAccountsShrink;
  }
  if (!Util.isUnset(request.aggregatorId)) {
    body['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.aggregatorName)) {
    body['AggregatorName'] = request.aggregatorName;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAggregator',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAggregator(request: UpdateAggregatorRequest): UpdateAggregatorResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAggregatorWithOptions(request, runtime);
}

model UpdateCompliancePackRequest {
  clientToken?: string(name='ClientToken'),
  compliancePackId?: string(name='CompliancePackId'),
  compliancePackName?: string(name='CompliancePackName'),
  configRules?: [ 
    {
      configRuleId?: string(name='ConfigRuleId'),
      configRuleName?: string(name='ConfigRuleName'),
      configRuleParameters?: [ 
        {
          parameterName?: string(name='ParameterName'),
          parameterValue?: string(name='ParameterValue'),
        }
      ](name='ConfigRuleParameters'),
      description?: string(name='Description'),
      managedRuleIdentifier?: string(name='ManagedRuleIdentifier'),
      riskLevel?: int32(name='RiskLevel'),
    }
  ](name='ConfigRules'),
  description?: string(name='Description'),
  riskLevel?: int32(name='RiskLevel'),
}

model UpdateCompliancePackShrinkRequest {
  clientToken?: string(name='ClientToken'),
  compliancePackId?: string(name='CompliancePackId'),
  compliancePackName?: string(name='CompliancePackName'),
  configRulesShrink?: string(name='ConfigRules'),
  description?: string(name='Description'),
  riskLevel?: int32(name='RiskLevel'),
}

model UpdateCompliancePackResponseBody = {
  compliancePackId?: string(name='CompliancePackId'),
  requestId?: string(name='RequestId'),
}

model UpdateCompliancePackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCompliancePackResponseBody(name='body'),
}

async function updateCompliancePackWithOptions(tmpReq: UpdateCompliancePackRequest, runtime: Util.RuntimeOptions): UpdateCompliancePackResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateCompliancePackShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.configRules)) {
    request.configRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.configRules, 'ConfigRules', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.compliancePackId)) {
    body['CompliancePackId'] = request.compliancePackId;
  }
  if (!Util.isUnset(request.compliancePackName)) {
    body['CompliancePackName'] = request.compliancePackName;
  }
  if (!Util.isUnset(request.configRulesShrink)) {
    body['ConfigRules'] = request.configRulesShrink;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.riskLevel)) {
    body['RiskLevel'] = request.riskLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCompliancePack',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCompliancePack(request: UpdateCompliancePackRequest): UpdateCompliancePackResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCompliancePackWithOptions(request, runtime);
}

model UpdateConfigDeliveryChannelRequest {
  clientToken?: string(name='ClientToken'),
  configurationItemChangeNotification?: boolean(name='ConfigurationItemChangeNotification'),
  configurationSnapshot?: boolean(name='ConfigurationSnapshot'),
  deliveryChannelCondition?: string(name='DeliveryChannelCondition'),
  deliveryChannelId?: string(name='DeliveryChannelId'),
  deliveryChannelName?: string(name='DeliveryChannelName'),
  deliveryChannelTargetArn?: string(name='DeliveryChannelTargetArn'),
  description?: string(name='Description'),
  nonCompliantNotification?: boolean(name='NonCompliantNotification'),
  oversizedDataOSSTargetArn?: string(name='OversizedDataOSSTargetArn'),
  status?: long(name='Status'),
}

model UpdateConfigDeliveryChannelResponseBody = {
  deliveryChannelId?: string(name='DeliveryChannelId'),
  requestId?: string(name='RequestId'),
}

model UpdateConfigDeliveryChannelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateConfigDeliveryChannelResponseBody(name='body'),
}

async function updateConfigDeliveryChannelWithOptions(request: UpdateConfigDeliveryChannelRequest, runtime: Util.RuntimeOptions): UpdateConfigDeliveryChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configurationItemChangeNotification)) {
    query['ConfigurationItemChangeNotification'] = request.configurationItemChangeNotification;
  }
  if (!Util.isUnset(request.configurationSnapshot)) {
    query['ConfigurationSnapshot'] = request.configurationSnapshot;
  }
  if (!Util.isUnset(request.deliveryChannelCondition)) {
    query['DeliveryChannelCondition'] = request.deliveryChannelCondition;
  }
  if (!Util.isUnset(request.deliveryChannelId)) {
    query['DeliveryChannelId'] = request.deliveryChannelId;
  }
  if (!Util.isUnset(request.deliveryChannelName)) {
    query['DeliveryChannelName'] = request.deliveryChannelName;
  }
  if (!Util.isUnset(request.deliveryChannelTargetArn)) {
    query['DeliveryChannelTargetArn'] = request.deliveryChannelTargetArn;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.nonCompliantNotification)) {
    query['NonCompliantNotification'] = request.nonCompliantNotification;
  }
  if (!Util.isUnset(request.oversizedDataOSSTargetArn)) {
    query['OversizedDataOSSTargetArn'] = request.oversizedDataOSSTargetArn;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConfigDeliveryChannel',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateConfigDeliveryChannel(request: UpdateConfigDeliveryChannelRequest): UpdateConfigDeliveryChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConfigDeliveryChannelWithOptions(request, runtime);
}

model UpdateConfigRuleRequest {
  clientToken?: string(name='ClientToken'),
  configRuleId?: string(name='ConfigRuleId'),
  configRuleName?: string(name='ConfigRuleName'),
  configRuleTriggerTypes?: string(name='ConfigRuleTriggerTypes'),
  description?: string(name='Description'),
  excludeResourceIdsScope?: string(name='ExcludeResourceIdsScope'),
  inputParameters?: map[string]any(name='InputParameters'),
  maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
  regionIdsScope?: string(name='RegionIdsScope'),
  resourceGroupIdsScope?: string(name='ResourceGroupIdsScope'),
  resourceTypesScope?: [ string ](name='ResourceTypesScope'),
  riskLevel?: int32(name='RiskLevel'),
  tagKeyLogicScope?: string(name='TagKeyLogicScope'),
  tagKeyScope?: string(name='TagKeyScope'),
  tagValueScope?: string(name='TagValueScope'),
}

model UpdateConfigRuleShrinkRequest {
  clientToken?: string(name='ClientToken'),
  configRuleId?: string(name='ConfigRuleId'),
  configRuleName?: string(name='ConfigRuleName'),
  configRuleTriggerTypes?: string(name='ConfigRuleTriggerTypes'),
  description?: string(name='Description'),
  excludeResourceIdsScope?: string(name='ExcludeResourceIdsScope'),
  inputParametersShrink?: string(name='InputParameters'),
  maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
  regionIdsScope?: string(name='RegionIdsScope'),
  resourceGroupIdsScope?: string(name='ResourceGroupIdsScope'),
  resourceTypesScopeShrink?: string(name='ResourceTypesScope'),
  riskLevel?: int32(name='RiskLevel'),
  tagKeyLogicScope?: string(name='TagKeyLogicScope'),
  tagKeyScope?: string(name='TagKeyScope'),
  tagValueScope?: string(name='TagValueScope'),
}

model UpdateConfigRuleResponseBody = {
  configRuleId?: string(name='ConfigRuleId'),
  requestId?: string(name='RequestId'),
}

model UpdateConfigRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateConfigRuleResponseBody(name='body'),
}

async function updateConfigRuleWithOptions(tmpReq: UpdateConfigRuleRequest, runtime: Util.RuntimeOptions): UpdateConfigRuleResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateConfigRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.inputParameters)) {
    request.inputParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.inputParameters, 'InputParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.resourceTypesScope)) {
    request.resourceTypesScopeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceTypesScope, 'ResourceTypesScope', 'simple');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configRuleId)) {
    body['ConfigRuleId'] = request.configRuleId;
  }
  if (!Util.isUnset(request.configRuleName)) {
    body['ConfigRuleName'] = request.configRuleName;
  }
  if (!Util.isUnset(request.configRuleTriggerTypes)) {
    body['ConfigRuleTriggerTypes'] = request.configRuleTriggerTypes;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.excludeResourceIdsScope)) {
    body['ExcludeResourceIdsScope'] = request.excludeResourceIdsScope;
  }
  if (!Util.isUnset(request.inputParametersShrink)) {
    body['InputParameters'] = request.inputParametersShrink;
  }
  if (!Util.isUnset(request.maximumExecutionFrequency)) {
    body['MaximumExecutionFrequency'] = request.maximumExecutionFrequency;
  }
  if (!Util.isUnset(request.regionIdsScope)) {
    body['RegionIdsScope'] = request.regionIdsScope;
  }
  if (!Util.isUnset(request.resourceGroupIdsScope)) {
    body['ResourceGroupIdsScope'] = request.resourceGroupIdsScope;
  }
  if (!Util.isUnset(request.resourceTypesScopeShrink)) {
    body['ResourceTypesScope'] = request.resourceTypesScopeShrink;
  }
  if (!Util.isUnset(request.riskLevel)) {
    body['RiskLevel'] = request.riskLevel;
  }
  if (!Util.isUnset(request.tagKeyLogicScope)) {
    body['TagKeyLogicScope'] = request.tagKeyLogicScope;
  }
  if (!Util.isUnset(request.tagKeyScope)) {
    body['TagKeyScope'] = request.tagKeyScope;
  }
  if (!Util.isUnset(request.tagValueScope)) {
    body['TagValueScope'] = request.tagValueScope;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConfigRule',
    version = '2020-09-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateConfigRule(request: UpdateConfigRuleRequest): UpdateConfigRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConfigRuleWithOptions(request, runtime);
}

