/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  @endpointMap = {
    ap-northeast-1 = 'workorder.ap-northeast-1.aliyuncs.com',
    ap-southeast-1 = 'workorder.ap-southeast-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('workorder', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CloseTicketRequest {
  ticketId?: string(name='TicketId'),
}

model CloseTicketResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CloseTicketResponse = {
  headers: map[string]string(name='headers'),
  body: CloseTicketResponseBody(name='body'),
}

async function closeTicketWithOptions(request: CloseTicketRequest, runtime: Util.RuntimeOptions): CloseTicketResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.ticketId)) {
    body['TicketId'] = request.ticketId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CloseTicket',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function closeTicket(request: CloseTicketRequest): CloseTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return closeTicketWithOptions(request, runtime);
}

model CreateTicketRequest {
  categoryId?: string(name='CategoryId'),
  description?: string(name='Description'),
  severity?: int32(name='Severity'),
}

model CreateTicketResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateTicketResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTicketResponseBody(name='body'),
}

async function createTicketWithOptions(request: CreateTicketRequest, runtime: Util.RuntimeOptions): CreateTicketResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.categoryId)) {
    body['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.severity)) {
    body['Severity'] = request.severity;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTicket',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTicket(request: CreateTicketRequest): CreateTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTicketWithOptions(request, runtime);
}

model EvaluateTicketRequest {
  content?: string(name='Content'),
  score?: string(name='Score'),
  solved?: boolean(name='Solved'),
  ticketId?: string(name='TicketId'),
}

model EvaluateTicketResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EvaluateTicketResponse = {
  headers: map[string]string(name='headers'),
  body: EvaluateTicketResponseBody(name='body'),
}

async function evaluateTicketWithOptions(request: EvaluateTicketRequest, runtime: Util.RuntimeOptions): EvaluateTicketResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.score)) {
    body['Score'] = request.score;
  }
  if (!Util.isUnset(request.solved)) {
    body['Solved'] = request.solved;
  }
  if (!Util.isUnset(request.ticketId)) {
    body['TicketId'] = request.ticketId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EvaluateTicket',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function evaluateTicket(request: EvaluateTicketRequest): EvaluateTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return evaluateTicketWithOptions(request, runtime);
}

model GetMqConsumerTagResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMqConsumerTagResponse = {
  headers: map[string]string(name='headers'),
  body: GetMqConsumerTagResponseBody(name='body'),
}

async function getMqConsumerTagWithOptions(runtime: Util.RuntimeOptions): GetMqConsumerTagResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetMqConsumerTag',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMqConsumerTag(): GetMqConsumerTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMqConsumerTagWithOptions(runtime);
}

model ListCategoriesRequest {
  name?: string(name='Name'),
  productId?: long(name='ProductId'),
}

model ListCategoriesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      categoryId?: long(name='CategoryId'),
      categoryName?: string(name='CategoryName'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListCategoriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListCategoriesResponseBody(name='body'),
}

async function listCategoriesWithOptions(request: ListCategoriesRequest, runtime: Util.RuntimeOptions): ListCategoriesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.productId)) {
    body['ProductId'] = request.productId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListCategories',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCategories(request: ListCategoriesRequest): ListCategoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCategoriesWithOptions(request, runtime);
}

model ListProductsRequest {
  name?: string(name='Name'),
}

model ListProductsResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      directoryId?: long(name='DirectoryId'),
      directoryName?: string(name='DirectoryName'),
      productList?: [ 
        {
          productId?: long(name='ProductId'),
          productName?: string(name='ProductName'),
        }
      ](name='ProductList'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListProductsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProductsResponseBody(name='body'),
}

async function listProductsWithOptions(request: ListProductsRequest, runtime: Util.RuntimeOptions): ListProductsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProducts',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProducts(request: ListProductsRequest): ListProductsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProductsWithOptions(request, runtime);
}

model ListTicketNotesRequest {
  ticketId?: string(name='TicketId'),
}

model ListTicketNotesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      createTime?: long(name='CreateTime'),
      dialog?: {
        content?: string(name='Content'),
        schema?: string(name='Schema'),
      }(name='Dialog'),
      dialogId?: long(name='DialogId'),
      status?: int32(name='Status'),
      tip?: string(name='Tip'),
      type?: int32(name='Type'),
      user?: {
        name?: string(name='Name'),
        role?: int32(name='Role'),
      }(name='User'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListTicketNotesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTicketNotesResponseBody(name='body'),
}

async function listTicketNotesWithOptions(request: ListTicketNotesRequest, runtime: Util.RuntimeOptions): ListTicketNotesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ticketId)) {
    query['TicketId'] = request.ticketId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTicketNotes',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTicketNotes(request: ListTicketNotesRequest): ListTicketNotesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTicketNotesWithOptions(request, runtime);
}

model ListTicketsRequest {
  endDate?: long(name='EndDate'),
  keyword?: string(name='Keyword'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startDate?: long(name='StartDate'),
  statusList?: [ string ](name='StatusList'),
  ticketId?: string(name='TicketId'),
}

model ListTicketsResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      status?: {
        label?: string(name='Label'),
        value?: string(name='Value'),
      }(name='Status'),
      ticketId?: string(name='TicketId'),
      title?: string(name='Title'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListTicketsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTicketsResponseBody(name='body'),
}

async function listTicketsWithOptions(request: ListTicketsRequest, runtime: Util.RuntimeOptions): ListTicketsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.endDate)) {
    body['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    body['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.startDate)) {
    body['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.statusList)) {
    body['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.ticketId)) {
    body['TicketId'] = request.ticketId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListTickets',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTickets(request: ListTicketsRequest): ListTicketsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTicketsWithOptions(request, runtime);
}

model ReplyTicketRequest {
  content?: string(name='Content'),
  encrypt?: boolean(name='Encrypt'),
  ticketId?: string(name='TicketId'),
}

model ReplyTicketResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReplyTicketResponse = {
  headers: map[string]string(name='headers'),
  body: ReplyTicketResponseBody(name='body'),
}

async function replyTicketWithOptions(request: ReplyTicketRequest, runtime: Util.RuntimeOptions): ReplyTicketResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.encrypt)) {
    body['Encrypt'] = request.encrypt;
  }
  if (!Util.isUnset(request.ticketId)) {
    body['TicketId'] = request.ticketId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReplyTicket',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function replyTicket(request: ReplyTicketRequest): ReplyTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return replyTicketWithOptions(request, runtime);
}

