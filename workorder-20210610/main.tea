/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  @endpointMap = {
    ap-northeast-1 = 'workorder.ap-northeast-1.aliyuncs.com',
    ap-southeast-1 = 'workorder.ap-southeast-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('workorder', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CloseTicketRequest {
  ticketId?: string(name='TicketId'),
}

model CloseTicketResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CloseTicketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloseTicketResponseBody(name='body'),
}

async function closeTicketWithOptions(request: CloseTicketRequest, runtime: Util.RuntimeOptions): CloseTicketResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ticketId)) {
    body['TicketId'] = request.ticketId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CloseTicket',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function closeTicket(request: CloseTicketRequest): CloseTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return closeTicketWithOptions(request, runtime);
}

model CreateTicketRequest {
  categoryId?: string(name='CategoryId'),
  creatorId?: string(name='CreatorId'),
  description?: string(name='Description'),
  email?: string(name='Email'),
  fileNameList?: [ string ](name='FileNameList'),
  secretInfo?: {
    content?: string(name='Content'),
    fileNameList?: [ string ](name='FileNameList'),
  }(name='SecretInfo'),
  severity?: int32(name='Severity'),
  title?: string(name='Title'),
}

model CreateTicketShrinkRequest {
  categoryId?: string(name='CategoryId'),
  creatorId?: string(name='CreatorId'),
  description?: string(name='Description'),
  email?: string(name='Email'),
  fileNameListShrink?: string(name='FileNameList'),
  secretInfoShrink?: string(name='SecretInfo'),
  severity?: int32(name='Severity'),
  title?: string(name='Title'),
}

model CreateTicketResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateTicketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTicketResponseBody(name='body'),
}

async function createTicketWithOptions(tmpReq: CreateTicketRequest, runtime: Util.RuntimeOptions): CreateTicketResponse {
  Util.validateModel(tmpReq);
  var request = new CreateTicketShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.fileNameList)) {
    request.fileNameListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fileNameList, 'FileNameList', 'simple');
  }
  if (!Util.isUnset(tmpReq.secretInfo)) {
    request.secretInfoShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.secretInfo, 'SecretInfo', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.secretInfoShrink)) {
    query['SecretInfo'] = request.secretInfoShrink;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.categoryId)) {
    body['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.creatorId)) {
    body['CreatorId'] = request.creatorId;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.email)) {
    body['Email'] = request.email;
  }
  if (!Util.isUnset(request.fileNameListShrink)) {
    body['FileNameList'] = request.fileNameListShrink;
  }
  if (!Util.isUnset(request.severity)) {
    body['Severity'] = request.severity;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTicket',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTicket(request: CreateTicketRequest): CreateTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTicketWithOptions(request, runtime);
}

model EvaluateTicketRequest {
  content?: string(name='Content'),
  score?: string(name='Score'),
  solved?: boolean(name='Solved'),
  ticketId?: string(name='TicketId'),
}

model EvaluateTicketResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EvaluateTicketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EvaluateTicketResponseBody(name='body'),
}

async function evaluateTicketWithOptions(request: EvaluateTicketRequest, runtime: Util.RuntimeOptions): EvaluateTicketResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.score)) {
    body['Score'] = request.score;
  }
  if (!Util.isUnset(request.solved)) {
    body['Solved'] = request.solved;
  }
  if (!Util.isUnset(request.ticketId)) {
    body['TicketId'] = request.ticketId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EvaluateTicket',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function evaluateTicket(request: EvaluateTicketRequest): EvaluateTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return evaluateTicketWithOptions(request, runtime);
}

model GetAttachmentUploadUrlRequest {
  fileName?: string(name='FileName'),
}

model GetAttachmentUploadUrlResponseBody = {
  code?: int32(name='Code'),
  data?: {
    getSignedUrl?: string(name='GetSignedUrl'),
    objectKey?: string(name='ObjectKey'),
    putSignedUrl?: string(name='PutSignedUrl'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAttachmentUploadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAttachmentUploadUrlResponseBody(name='body'),
}

async function getAttachmentUploadUrlWithOptions(request: GetAttachmentUploadUrlRequest, runtime: Util.RuntimeOptions): GetAttachmentUploadUrlResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetAttachmentUploadUrl',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAttachmentUploadUrl(request: GetAttachmentUploadUrlRequest): GetAttachmentUploadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAttachmentUploadUrlWithOptions(request, runtime);
}

model GetMqConsumerTagResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMqConsumerTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMqConsumerTagResponseBody(name='body'),
}

async function getMqConsumerTagWithOptions(runtime: Util.RuntimeOptions): GetMqConsumerTagResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetMqConsumerTag',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMqConsumerTag(): GetMqConsumerTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMqConsumerTagWithOptions(runtime);
}

model GetTicketRequest {
  ticketId?: string(name='TicketId'),
}

model GetTicketResponseBody = {
  code?: int32(name='Code'),
  data?: {
    categoryId?: string(name='CategoryId'),
    createTime?: long(name='CreateTime'),
    creatorId?: string(name='CreatorId'),
    description?: string(name='Description'),
    severity?: {
      label?: string(name='Label'),
      value?: string(name='Value'),
    }(name='Severity'),
    status?: {
      label?: string(name='Label'),
      value?: string(name='Value'),
    }(name='Status'),
    ticketId?: string(name='TicketId'),
    title?: string(name='Title'),
  }(name='Data'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model GetTicketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTicketResponseBody(name='body'),
}

async function getTicketWithOptions(request: GetTicketRequest, runtime: Util.RuntimeOptions): GetTicketResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ticketId)) {
    body['TicketId'] = request.ticketId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTicket',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTicket(request: GetTicketRequest): GetTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTicketWithOptions(request, runtime);
}

model ListCategoriesRequest {
  language?: string(name='Language'),
  name?: string(name='Name'),
  productId?: long(name='ProductId'),
}

model ListCategoriesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      categoryId?: long(name='CategoryId'),
      categoryName?: string(name='CategoryName'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListCategoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCategoriesResponseBody(name='body'),
}

async function listCategoriesWithOptions(request: ListCategoriesRequest, runtime: Util.RuntimeOptions): ListCategoriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.language)) {
    query['Language'] = request.language;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.productId)) {
    body['ProductId'] = request.productId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListCategories',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCategories(request: ListCategoriesRequest): ListCategoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCategoriesWithOptions(request, runtime);
}

model ListProductsRequest {
  language?: string(name='Language'),
  name?: string(name='Name'),
}

model ListProductsResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      directoryId?: long(name='DirectoryId'),
      directoryName?: string(name='DirectoryName'),
      productList?: [ 
        {
          productId?: long(name='ProductId'),
          productName?: string(name='ProductName'),
        }
      ](name='ProductList'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListProductsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProductsResponseBody(name='body'),
}

async function listProductsWithOptions(request: ListProductsRequest, runtime: Util.RuntimeOptions): ListProductsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.language)) {
    query['Language'] = request.language;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProducts',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProducts(request: ListProductsRequest): ListProductsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProductsWithOptions(request, runtime);
}

model ListTicketNotesRequest {
  ticketId?: string(name='TicketId'),
}

model ListTicketNotesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      attachments?: [ 
        {
          name?: string(name='Name'),
          url?: string(name='Url'),
        }
      ](name='Attachments'),
      createTime?: long(name='CreateTime'),
      dialog?: {
        content?: string(name='Content'),
        schema?: string(name='Schema'),
      }(name='Dialog'),
      dialogId?: long(name='DialogId'),
      status?: int32(name='Status'),
      tip?: string(name='Tip'),
      type?: int32(name='Type'),
      user?: {
        name?: string(name='Name'),
        role?: int32(name='Role'),
      }(name='User'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListTicketNotesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTicketNotesResponseBody(name='body'),
}

async function listTicketNotesWithOptions(request: ListTicketNotesRequest, runtime: Util.RuntimeOptions): ListTicketNotesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ticketId)) {
    query['TicketId'] = request.ticketId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTicketNotes',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTicketNotes(request: ListTicketNotesRequest): ListTicketNotesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTicketNotesWithOptions(request, runtime);
}

model ListTicketsRequest {
  endDate?: long(name='EndDate'),
  keyword?: string(name='Keyword'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startDate?: long(name='StartDate'),
  statusList?: [ string ](name='StatusList'),
  ticketId?: string(name='TicketId'),
  ticketIdList?: [ string ](name='TicketIdList'),
}

model ListTicketsShrinkRequest {
  endDate?: long(name='EndDate'),
  keyword?: string(name='Keyword'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startDate?: long(name='StartDate'),
  statusList?: [ string ](name='StatusList'),
  ticketId?: string(name='TicketId'),
  ticketIdListShrink?: string(name='TicketIdList'),
}

model ListTicketsResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      status?: {
        label?: string(name='Label'),
        value?: string(name='Value'),
      }(name='Status'),
      ticketId?: string(name='TicketId'),
      title?: string(name='Title'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListTicketsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTicketsResponseBody(name='body'),
}

async function listTicketsWithOptions(tmpReq: ListTicketsRequest, runtime: Util.RuntimeOptions): ListTicketsResponse {
  Util.validateModel(tmpReq);
  var request = new ListTicketsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ticketIdList)) {
    request.ticketIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ticketIdList, 'TicketIdList', 'simple');
  }
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.endDate)) {
    body['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.keyword)) {
    body['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.startDate)) {
    body['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.statusList)) {
    body['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.ticketId)) {
    body['TicketId'] = request.ticketId;
  }
  if (!Util.isUnset(request.ticketIdListShrink)) {
    body['TicketIdList'] = request.ticketIdListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListTickets',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTickets(request: ListTicketsRequest): ListTicketsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTicketsWithOptions(request, runtime);
}

model ReopenTicketRequest {
  content?: string(name='Content'),
  ticketId?: string(name='TicketId'),
}

model ReopenTicketResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReopenTicketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReopenTicketResponseBody(name='body'),
}

async function reopenTicketWithOptions(request: ReopenTicketRequest, runtime: Util.RuntimeOptions): ReopenTicketResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.ticketId)) {
    body['TicketId'] = request.ticketId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReopenTicket',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reopenTicket(request: ReopenTicketRequest): ReopenTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return reopenTicketWithOptions(request, runtime);
}

model ReplyTicketRequest {
  content?: string(name='Content'),
  encrypt?: boolean(name='Encrypt'),
  fileNameList?: [ string ](name='FileNameList'),
  ticketId?: string(name='TicketId'),
}

model ReplyTicketShrinkRequest {
  content?: string(name='Content'),
  encrypt?: boolean(name='Encrypt'),
  fileNameListShrink?: string(name='FileNameList'),
  ticketId?: string(name='TicketId'),
}

model ReplyTicketResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReplyTicketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReplyTicketResponseBody(name='body'),
}

async function replyTicketWithOptions(tmpReq: ReplyTicketRequest, runtime: Util.RuntimeOptions): ReplyTicketResponse {
  Util.validateModel(tmpReq);
  var request = new ReplyTicketShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.fileNameList)) {
    request.fileNameListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fileNameList, 'FileNameList', 'simple');
  }
  var query = {};
  if (!Util.isUnset(request.fileNameListShrink)) {
    query['FileNameList'] = request.fileNameListShrink;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.encrypt)) {
    body['Encrypt'] = request.encrypt;
  }
  if (!Util.isUnset(request.ticketId)) {
    body['TicketId'] = request.ticketId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReplyTicket',
    version = '2021-06-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function replyTicket(request: ReplyTicketRequest): ReplyTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return replyTicketWithOptions(request, runtime);
}

