/**
 *
 */
import OpenApi;
import OpenApi.OpenApiUtil;

extends OpenApi;


init(config: OpenApiUtil.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('aiworkspace', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!$isNull(endpoint)) {
    return endpoint;
  }
  
  if (!$isNull(endpointMap) && !$isNull(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CodeSourceItem {
  accessibility?: string(name='Accessibility', example='PUBLIC'),
  codeBranch?: string(name='CodeBranch', example='master'),
  codeCommit?: string(name='CodeCommit', example='44da109b59f8596152987eaa8f3b2487bb72ea63'),
  codeRepo?: string(name='CodeRepo', example='https://code.aliyun.com/pai-dlc/examples.git'),
  codeRepoAccessToken?: string(name='CodeRepoAccessToken'),
  codeRepoUserName?: string(name='CodeRepoUserName', example='user'),
  codeSourceId?: string(name='CodeSourceId', example='code-20210111103721-85qz78ia96lu'),
  description?: string(name='Description', example='code source of dlc examples'),
  displayName?: string(name='DisplayName', example='MyCodeSourceName1'),
  gmtCreateTime?: string(name='GmtCreateTime', example='2021-01-18T12:52:15Z'),
  gmtModifyTime?: string(name='GmtModifyTime', example='2021-01-18T12:52:15Z'),
  mountPath?: string(name='MountPath', example='/root/code/'),
  userId?: string(name='UserId', example='1157290171663117'),
  workspaceId?: string(name='WorkspaceId', example='1234'),
}

model Collection {
  collectionName?: string(name='CollectionName', example='AI4D'),
  gmtCreateTime?: string(name='GmtCreateTime', example='2021-01-21T17:12:35Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', example='2021-01-21T17:12:35Z'),
  ownerId?: string(name='OwnerId', example='155770209******'),
  userId?: string(name='UserId', example='155770209******'),
}

model Connection {
  accessibility?: string(name='Accessibility'),
  configs?: map[string]string(name='Configs'),
  connectionId?: string(name='ConnectionId'),
  connectionName?: string(name='ConnectionName'),
  connectionType?: string(name='ConnectionType'),
  creator?: string(name='Creator'),
  description?: string(name='Description'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  models?: [ 
    {
      displayName?: string(name='DisplayName'),
      model?: string(name='Model'),
      modelType?: string(name='ModelType'),
      toolCall?: boolean(name='ToolCall'),
    }
  ](name='Models'),
  resourceMeta?: {
    extra?: string(name='Extra'),
    instanceId?: string(name='InstanceId'),
    instanceName?: string(name='InstanceName'),
  }(name='ResourceMeta'),
  secrets?: map[string]string(name='Secrets'),
  workspaceId?: string(name='WorkspaceId'),
}

model Dataset {
  accessibility?: string(name='Accessibility', example='PRIVATE PUBLIC'),
  dataSourceType?: string(name='DataSourceType', example='OSS URL'),
  dataType?: string(name='DataType', example='COMMON PIC TEXT VIDEO AUDIO'),
  datasetId?: string(name='DatasetId', example='d-c0h44g3wlwkj8o4348'),
  description?: string(name='Description', example='Animal images.'),
  edition?: string(name='Edition', example='BASIC'),
  gmtCreateTime?: string(name='GmtCreateTime', example='2021-01-30T12:51:33.028Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', example='2021-01-30T12:51:33.028Z'),
  importInfo?: string(name='ImportInfo'),
  isShared?: boolean(name='IsShared'),
  labels?: [
    Label
  ](name='Labels'),
  latestVersion?: DatasetVersion(name='LatestVersion'),
  mountAccess?: string(name='MountAccess', example='RO RW'),
  mountAccessReadWriteRoleIdList?: [ string ](name='MountAccessReadWriteRoleIdList'),
  name?: string(name='Name', example='AnimalDataset'),
  options?: string(name='Options', example='jsonstring'),
  ownerId?: string(name='OwnerId', example='1004110000006048'),
  property?: string(name='Property', example='FILE DIRECTORY TABULAR'),
  providerType?: string(name='ProviderType', example='Ecs'),
  sharedFrom?: DatasetShareRelationship(name='SharedFrom'),
  sharingConfig?: {
    sharedTo?: [
      DatasetShareRelationship
    ](name='SharedTo'),
  }(name='SharingConfig'),
  sourceDatasetId?: string(name='SourceDatasetId', example='d-bvfasdf4wxxj8o411'),
  sourceDatasetVersion?: string(name='SourceDatasetVersion', example='v2'),
  sourceId?: string(name='SourceId', example='Source Id'),
  sourceType?: string(name='SourceType', example='USER ITAG  PAI_PUBLIC_DATASET'),
  tagTemplateType?: string(name='TagTemplateType', example='text-classification'),
  uri?: string(name='Uri', example='oss://xxx'),
  userId?: string(name='UserId', example='2004110000006048'),
  workspaceId?: string(name='WorkspaceId', example='Workspace Id'),
}

model DatasetFileMeta {
  contentType?: string(name='ContentType', example='image/jpeg'),
  dataSize?: long(name='DataSize', example='12'),
  datasetFileMetaId?: string(name='DatasetFileMetaId'),
  downloadUrl?: string(name='DownloadUrl'),
  fileCreateTime?: string(name='FileCreateTime', description='Use the UTC time format: yyyy-MM-ddTHH:mmZ', example='2021-01-12T14:36:01.000Z'),
  fileFingerPrint?: string(name='FileFingerPrint'),
  fileName?: string(name='FileName', example='car.png'),
  fileType?: string(name='FileType', example='image'),
  fileUpdateTime?: string(name='FileUpdateTime', description='Use the UTC time format: yyyy-MM-ddTHH:mmZ', example='2021-01-12T14:36:01.000Z'),
  metaAttributes?: string(name='MetaAttributes', example='{     "ImageHeight": 400,     "ImageWidth": 800 }'),
  score?: float(name='Score', example='0.6'),
  semanticIndexJobId?: string(name='SemanticIndexJobId'),
  semanticIndexUpdateTime?: string(name='SemanticIndexUpdateTime', description='Use the UTC time format: yyyy-MM-ddTHH:mmZ', example='2021-01-12T14:36:01.000Z'),
  tags?: string(name='Tags'),
  thumbnailUrl?: string(name='ThumbnailUrl'),
  uri?: string(name='Uri', example='oss://test-bucket/dataset/car.png'),
}

model DatasetFileMetaConentUpdate {
  comment?: string(name='Comment'),
  contentType?: string(name='ContentType'),
  dataSize?: long(name='DataSize'),
  datasetFileMetaId?: string(name='DatasetFileMetaId', description='This parameter is required.'),
  fileCreateTime?: string(name='FileCreateTime', description='Use the UTC time format: yyyy-MM-ddTHH:mmZ', example='2021-01-12T14:36:01.000Z'),
  fileFingerPrint?: string(name='FileFingerPrint'),
  fileName?: string(name='FileName'),
  fileType?: string(name='FileType'),
  fileUpdateTime?: string(name='FileUpdateTime', description='Use the UTC time format: yyyy-MM-ddTHH:mmZ', example='2021-01-12T14:36:01.000Z'),
  metaAttributes?: string(name='MetaAttributes'),
  semanticIndexJobId?: string(name='SemanticIndexJobId'),
  semanticIndexUpdateTime?: string(name='SemanticIndexUpdateTime', description='Use the UTC time format: yyyy-MM-ddTHH:mmZ', example='2021-01-12T14:36:01.000Z'),
  tags?: string(name='Tags', example='● 执行算法打标更新（必须设置有效的TagJobId）： {    "ai":["车道线", "水马", "晴天"] } ● 用户手动打标：(add/remove表示对标签组内的标签进行增加/删除操作) 用户可操作的标签组为：   ○ user: 对单个元数据，用户自行添加的标签名列表。   ○ user-delete-ai-tags: 对单个元数据，算法标签组中用户需要删除的标签名列表。 {     "user":{         "add":["车道线","晴天"],         "remove":["水马"]     },     "user-delete-ai-tags":{         "add": ["地面阴影"],         "remove": []     } }'),
}

model DatasetFileMetaContentCreate {
  comment?: string(name='Comment'),
  contentType?: string(name='ContentType', description='This parameter is required.'),
  dataSize?: long(name='DataSize'),
  fileCreateTime?: string(name='FileCreateTime', description='Use the UTC time format: yyyy-MM-ddTHH:mmZ', example='2021-01-12T14:36:01.000Z'),
  fileFingerPrint?: string(name='FileFingerPrint', description='This parameter is required.'),
  fileName?: string(name='FileName'),
  fileType?: string(name='FileType', description='This parameter is required.'),
  fileUpdateTime?: string(name='FileUpdateTime', description='This parameter is required.

Use the UTC time format: yyyy-MM-ddTHH:mmZ', example='2021-01-12T14:36:01.000Z'),
  metaAttributes?: string(name='MetaAttributes'),
  tags?: string(name='Tags', example='{"user":{"add":["cat"]}}'),
  uri?: string(name='Uri', description='This parameter is required.'),
}

model DatasetFileMetaContentGet {
  comment?: string(name='Comment'),
  contentType?: string(name='ContentType'),
  dataSize?: long(name='DataSize'),
  datasetFileMetaId?: string(name='DatasetFileMetaId'),
  fileCreateTime?: string(name='FileCreateTime', description='Use the UTC time format: yyyy-MM-ddTHH:mmZ', example='2021-01-12T14:36:01.000Z'),
  fileDir?: string(name='FileDir'),
  fileFingerPrint?: string(name='FileFingerPrint'),
  fileName?: string(name='FileName'),
  fileType?: string(name='FileType'),
  fileUpdateTime?: string(name='FileUpdateTime', description='Use the UTC time format: yyyy-MM-ddTHH:mmZ', example='2021-01-12T14:36:01.000Z'),
  metaAttributes?: string(name='MetaAttributes'),
  semanticIndexJobId?: string(name='SemanticIndexJobId'),
  semanticIndexUpdateTime?: string(name='SemanticIndexUpdateTime', description='Use the UTC time format: yyyy-MM-ddTHH:mmZ', example='2021-01-12T14:36:01.000Z'),
  tagUpdateTime?: string(name='TagUpdateTime', description='Use the UTC time format: yyyy-MM-ddTHH:mmZ', example='2021-01-12T14:36:01.000Z'),
  tags?: string(name='Tags'),
  uri?: string(name='Uri'),
}

model DatasetFileMetaResponse {
  datasetFileMetaId?: string(name='DatasetFileMetaId', description='This parameter is required.'),
  result?: string(name='Result', description='This parameter is required.'),
  uri?: string(name='Uri'),
}

model DatasetFileMetasStat {
  count?: int32(name='Count', example='10'),
  key?: string(name='Key', example='cat'),
}

model DatasetJob {
  completedFileCount?: long(name='CompletedFileCount'),
  createTime?: string(name='CreateTime'),
  datasetJobId?: string(name='DatasetJobId'),
  datasetVersion?: string(name='DatasetVersion'),
  description?: string(name='Description'),
  failedFileCount?: long(name='FailedFileCount'),
  finishTime?: string(name='FinishTime'),
  jobAction?: string(name='JobAction'),
  jobMode?: string(name='JobMode'),
  jobSpec?: string(name='JobSpec'),
  logs?: [ string ](name='Logs'),
  status?: string(name='Status'),
  totalFileCount?: long(name='TotalFileCount'),
  workspaceId?: string(name='WorkspaceId'),
}

model DatasetJobConfig {
  config?: string(name='Config'),
  configType?: string(name='ConfigType'),
  createTime?: string(name='CreateTime'),
  datasetJobConfigId?: string(name='DatasetJobConfigId'),
  datasetVersion?: string(name='DatasetVersion'),
  modifyTime?: string(name='ModifyTime'),
  workspaceId?: string(name='WorkspaceId'),
}

model DatasetLabel {
  key?: string(name='Key'),
  value?: string(name='Value'),
}

model DatasetShareRelationship {
  allowedMountAccessLevels?: [ string ](name='AllowedMountAccessLevels'),
  expiresAt?: string(name='ExpiresAt'),
  isSecureMode?: boolean(name='IsSecureMode'),
  sharedAt?: string(name='SharedAt'),
  sourceTenantId?: string(name='SourceTenantId'),
  sourceWorkspaceId?: string(name='SourceWorkspaceId'),
  status?: string(name='Status'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DatasetVersion {
  dataCount?: long(name='DataCount'),
  dataSize?: long(name='DataSize'),
  dataSourceType?: string(name='DataSourceType', example='OSS'),
  description?: string(name='Description'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  importInfo?: string(name='ImportInfo'),
  labels?: [
    Label
  ](name='Labels'),
  mountAccess?: string(name='MountAccess', example='RO RW'),
  options?: string(name='Options'),
  property?: string(name='Property', example='FILE'),
  sourceId?: string(name='SourceId'),
  sourceType?: string(name='SourceType'),
  uri?: string(name='Uri', example='OSS://xxx'),
  versionName?: string(name='VersionName', example='v1'),
}

model Experiment {
  accessibility?: string(name='Accessibility'),
  artifactUri?: string(name='ArtifactUri'),
  experimentId?: string(name='ExperimentId'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  labels?: [
    ExperimentLabel
  ](name='Labels'),
  latestRun?: Run(name='LatestRun'),
  name?: string(name='Name'),
  ownerId?: string(name='OwnerId'),
  requestId?: string(name='RequestId'),
  tensorboardLogUri?: string(name='TensorboardLogUri'),
  userId?: string(name='UserId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ExperimentLabel {
  experimentId?: string(name='ExperimentId', example='exp-890waerw09a0f'),
  gmtCreateTime?: string(name='GmtCreateTime', example='2023-12-27T03:30:04Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', example='2023-12-27T03:30:04Z'),
  key?: string(name='Key', example='key'),
  value?: string(name='Value', example='value'),
}

model Label {
  key?: string(name='Key'),
  value?: string(name='Value'),
}

model LabelInfo {
  key?: string(name='Key', example='key'),
  value?: string(name='Value', example='value'),
}

model LineageEntity {
  attributes?: map[string]any(name='Attributes'),
  entityType?: string(name='EntityType'),
  name?: string(name='Name'),
  qualifiedName?: string(name='QualifiedName'),
}

model LineageRelation {
  destEntityQualifiedName?: string(name='DestEntityQualifiedName'),
  relationshipGuid?: string(name='RelationshipGuid'),
  srcEntityQualifiedName?: string(name='SrcEntityQualifiedName'),
}

model Model {
  accessibility?: string(name='Accessibility', example='PUBLIC'),
  domain?: string(name='Domain', example='cv'),
  extraInfo?: map[string]any(name='ExtraInfo'),
  gmtCreateTime?: string(name='GmtCreateTime', example='2021-01-21T17:12:35Z'),
  gmtLatestVersionModifiedTime?: string(name='GmtLatestVersionModifiedTime', example='2021-01-21T17:12:35Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', example='2021-01-21T17:12:35Z'),
  labels?: [
    Label
  ](name='Labels'),
  latestVersion?: ModelVersion(name='LatestVersion'),
  modelDescription?: string(name='ModelDescription'),
  modelDoc?: string(name='ModelDoc', example='https://***.md'),
  modelId?: string(name='ModelId', example='model-1123*****'),
  modelName?: string(name='ModelName'),
  modelType?: string(name='ModelType', example='Checkpoint'),
  orderNumber?: long(name='OrderNumber', example='101'),
  origin?: string(name='Origin', example='ModelScope'),
  ownerId?: string(name='OwnerId', example='1557702098******'),
  parameterSize?: long(name='ParameterSize', example='1024'),
  provider?: string(name='Provider', example='pai'),
  tags?: [
    Label
  ](name='Tags'),
  task?: string(name='Task', example='text-classifiaction'),
  userId?: string(name='UserId', example='1557702098******'),
  workspaceId?: string(name='WorkspaceId', example='234**'),
}

model ModelVersion {
  approvalStatus?: string(name='ApprovalStatus'),
  compressionSpec?: map[string]any(name='CompressionSpec'),
  distillationSpec?: map[string]any(name='DistillationSpec'),
  evaluationSpec?: map[string]any(name='EvaluationSpec'),
  extraInfo?: map[string]any(name='ExtraInfo'),
  formatType?: string(name='FormatType', example='SavedModel'),
  frameworkType?: string(name='FrameworkType', example='TensorFlow'),
  gmtCreateTime?: string(name='GmtCreateTime', example='2021-01-21T17:12:35Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', example='2021-01-21T17:12:35Z'),
  inferenceSpec?: map[string]any(name='InferenceSpec'),
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
  metrics?: map[string]any(name='Metrics'),
  options?: string(name='Options'),
  ownerId?: string(name='OwnerId', example='155770209******'),
  sourceId?: string(name='SourceId'),
  sourceType?: string(name='SourceType'),
  trainingSpec?: map[string]any(name='TrainingSpec'),
  uri?: string(name='Uri', example='oss://bucket/path-to-model'),
  userId?: string(name='UserId', example='155770209******'),
  versionDescription?: string(name='VersionDescription'),
  versionName?: string(name='VersionName', example='1.0.0'),
}

model Prompt {
  accessibility?: string(name='Accessibility'),
  createTime?: string(name='CreateTime'),
  description?: string(name='Description'),
  frameworkContent?: string(name='FrameworkContent'),
  frameworkType?: string(name='FrameworkType'),
  modifyTime?: string(name='ModifyTime'),
  promptId?: string(name='PromptId'),
  promptName?: string(name='PromptName'),
}

model Relation {
  errMsg?: string(name='ErrMsg'),
  lineageRelation?: LineageRelation(name='LineageRelation'),
  result?: boolean(name='Result'),
}

model Relationship {
  attributes?: map[string]any(name='Attributes'),
  dataChannel?: string(name='DataChannel'),
  relationshipGuid?: string(name='RelationshipGuid'),
  relationshipType?: string(name='RelationshipType'),
}

model Run {
  accessibility?: string(name='Accessibility'),
  experimentId?: string(name='ExperimentId'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  labels?: [
    RunLabel
  ](name='Labels'),
  metrics?: [
    RunMetric
  ](name='Metrics'),
  name?: string(name='Name'),
  ownerId?: string(name='OwnerId'),
  params?: [
    RunParam
  ](name='Params'),
  requestId?: string(name='RequestId'),
  runId?: string(name='RunId'),
  sourceId?: string(name='SourceId'),
  sourceType?: string(name='SourceType'),
  userId?: string(name='UserId'),
  workspaceId?: string(name='WorkspaceId'),
}

model RunLabel {
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  key?: string(name='Key', description='This parameter is required.'),
  runId?: string(name='RunId'),
  value?: string(name='Value', description='This parameter is required.'),
}

model RunMetric {
  key?: string(name='Key', description='This parameter is required.'),
  step?: long(name='Step'),
  timestamp?: long(name='Timestamp'),
  value?: float(name='Value', description='This parameter is required.'),
}

model RunParam {
  key?: string(name='Key', description='This parameter is required.'),
  value?: string(name='Value', description='This parameter is required.'),
}

model Trial {
  accessibility?: string(name='Accessibility'),
  experimentId?: string(name='ExperimentId'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  labels?: [  map[string]any ](name='Labels'),
  name?: string(name='Name'),
  ownerId?: string(name='OwnerId'),
  sourceId?: string(name='SourceId'),
  sourceType?: string(name='SourceType'),
  trialId?: string(name='TrialId'),
  userId?: string(name='UserId'),
  workspaceId?: string(name='WorkspaceId'),
}

model TrialLabel {
  gmtCreateTime?: string(name='GmtCreateTime', example='2023-12-27T03:30:04Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', example='2023-12-27T03:30:04Z'),
  key?: string(name='Key', example='key'),
  trialId?: string(name='TrialId'),
  value?: string(name='Value', example='value'),
}

model AcceptDataworksEventRequest {
  data?: map[string]any(name='Data', description='The event content in the message.', example='{"eventCode":"d****ct","projectId":"8***6","tenantId":4*******8,"operator":"115*****901"}'),
  messageId?: string(name='MessageId', description='The message ID. You can obtain the ID from the message received when an extension point event is triggered. For more information about the message format, see [Message formats](https://help.aliyun.com/document_detail/436911.html).', example='539306ba-*****-41a0-****-6dc81060985c'),
}

model AcceptDataworksEventResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ADF6D849-*****-7E7030F0CE53'),
}

model AcceptDataworksEventResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AcceptDataworksEventResponseBody(name='body'),
}

/**
 * @summary Receives and processes system event messages sent by DataWorks.
 *
 * @description This operation can be called only by the internal system and cannot be called by external users.
 *
 * @param request AcceptDataworksEventRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AcceptDataworksEventResponse
 */
@context("acceptDataworksEventWithContext")
async function acceptDataworksEventWithOptions(request: AcceptDataworksEventRequest, headers: map[string]string, runtime: $RuntimeOptions): AcceptDataworksEventResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.data)) {
    body['Data'] = request.data;
  }
  if (!$isNull(request.messageId)) {
    body['MessageId'] = request.messageId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'AcceptDataworksEvent',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/action/acceptdataworksevent`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Receives and processes system event messages sent by DataWorks.
 *
 * @description This operation can be called only by the internal system and cannot be called by external users.
 *
 * @param request AcceptDataworksEventRequest
 * @return AcceptDataworksEventResponse
 */
async function acceptDataworksEvent(request: AcceptDataworksEventRequest): AcceptDataworksEventResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return acceptDataworksEventWithOptions(request, headers, runtime);
}

model AddImageRequest {
  accessibility?: string(name='Accessibility', description='The accessibility of the image. Valid values:

*   PUBLIC: The image is accessible to all members in the workspace.
*   PRIVATE: The image is accessible only to the image creator.', example='PUBLIC'),
  description?: string(name='Description', description='The image description.'),
  imageId?: string(name='ImageId', description='The image ID. If you do not specify this parameter, the system automatically generates an image ID. The image ID must start with image- followed by 18 characters in letters or digits.', example='image-k83*****cv'),
  imageUri?: string(name='ImageUri', description='The URL of the image, which can be repeated. You can call [ListImage](https://help.aliyun.com/document_detail/449118.html) to view the image URL.

This parameter is required.', example='registry.cn-hangzhou.aliyuncs.com/pai-compression/nlp:gpu'),
  labels?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='system.chipType'),
      value?: string(name='Value', description='The tag value.', example='GPU'),
    }
  ](name='Labels', description='The image tag, which is an array. Each element in the array contains a key-value pair. Alibaba Cloud images have the system.official=true tag. You can add the following keys to an image:

*   system.chipType
*   system.dsw.cudaVersion
*   system.dsw.fromImageId
*   system.dsw.fromInstanceId
*   system.dsw.id
*   system.dsw.os
*   system.dsw.osVersion
*   system.dsw.resourceType
*   system.dsw.rootImageId
*   system.dsw.stage
*   system.dsw.tag
*   system.dsw.type
*   system.framework
*   system.origin
*   system.pythonVersion
*   system.source
*   system.supported.dlc
*   system.supported.dsw'),
  name?: string(name='Name', description='The image name. The name must meet the following requirements:

*   The name must be 1 to 50 characters in length.
*   The name can contain lowercase letters, digits, and hyphens (-). The name must start with a lowercase letter.
*   The name must be unique in a workspace.

This parameter is required.', example='nlp-compression'),
  size?: int32(name='Size', description='The size of the image. Unit: GB.', example='2'),
  sourceId?: string(name='SourceId'),
  sourceType?: string(name='SourceType'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='15******45'),
}

model AddImageResponseBody = {
  imageId?: string(name='ImageId', description='The image ID.', example='image-4c62******53uor'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model AddImageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddImageResponseBody(name='body'),
}

/**
 * @summary Adds a custom image to a workspace.
 *
 * @param request AddImageRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddImageResponse
 */
@context("addImageWithContext")
async function addImageWithOptions(request: AddImageRequest, headers: map[string]string, runtime: $RuntimeOptions): AddImageResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.accessibility)) {
    body['Accessibility'] = request.accessibility;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.imageId)) {
    body['ImageId'] = request.imageId;
  }
  if (!$isNull(request.imageUri)) {
    body['ImageUri'] = request.imageUri;
  }
  if (!$isNull(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!$isNull(request.name)) {
    body['Name'] = request.name;
  }
  if (!$isNull(request.size)) {
    body['Size'] = request.size;
  }
  if (!$isNull(request.sourceId)) {
    body['SourceId'] = request.sourceId;
  }
  if (!$isNull(request.sourceType)) {
    body['SourceType'] = request.sourceType;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'AddImage',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/images`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds a custom image to a workspace.
 *
 * @param request AddImageRequest
 * @return AddImageResponse
 */
async function addImage(request: AddImageRequest): AddImageResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return addImageWithOptions(request, headers, runtime);
}

model AddImageLabelsRequest {
  labels?: [ 
    {
      key?: string(name='Key', description='The tag key. The following keys can be added:

*   system.chipType
*   system.dsw.cudaVersion
*   system.dsw.fromImageId
*   system.dsw.fromInstanceId
*   system.dsw.id
*   system.dsw.os
*   system.dsw.osVersion
*   system.dsw.resourceType
*   system.dsw.rootImageId
*   system.dsw.stage
*   system.dsw.tag
*   system.dsw.type
*   system.framework
*   system.origin
*   system.pythonVersion
*   system.source
*   system.supported.dlc
*   system.supported.dsw', example='system.chipType'),
      value?: string(name='Value', description='The tag value.', example='GPU'),
    }
  ](name='Labels', description='The list of image tags.

This parameter is required.'),
}

model AddImageLabelsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model AddImageLabelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddImageLabelsResponseBody(name='body'),
}

/**
 * @summary Adds tags to an image.
 *
 * @param request AddImageLabelsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddImageLabelsResponse
 */
@context("addImageLabelsWithContext")
async function addImageLabelsWithOptions(ImageId: string, request: AddImageLabelsRequest, headers: map[string]string, runtime: $RuntimeOptions): AddImageLabelsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.labels)) {
    body['Labels'] = request.labels;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'AddImageLabels',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/images/${$URL.percentEncode(ImageId)}/labels`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds tags to an image.
 *
 * @param request AddImageLabelsRequest
 * @return AddImageLabelsResponse
 */
async function addImageLabels(ImageId: string, request: AddImageLabelsRequest): AddImageLabelsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return addImageLabelsWithOptions(ImageId, request, headers, runtime);
}

model AddMemberRoleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model AddMemberRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddMemberRoleResponseBody(name='body'),
}

/**
 * @summary Adds a role to a member in a workspace. After you add a role to a member, the member is granted the permissions of the role.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddMemberRoleResponse
 */
@context("addMemberRoleWithContext")
async function addMemberRoleWithOptions(WorkspaceId: string, MemberId: string, RoleName: string, headers: map[string]string, runtime: $RuntimeOptions): AddMemberRoleResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'AddMemberRole',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}/members/${$URL.percentEncode(MemberId)}/roles/${$URL.percentEncode(RoleName)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds a role to a member in a workspace. After you add a role to a member, the member is granted the permissions of the role.
 *
 * @return AddMemberRoleResponse
 */
async function addMemberRole(WorkspaceId: string, MemberId: string, RoleName: string): AddMemberRoleResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return addMemberRoleWithOptions(WorkspaceId, MemberId, RoleName, headers, runtime);
}

model ChangeResourceGroupRequest {
  newResourceGroupId?: string(name='NewResourceGroupId', description='The ID of the target resource group. For information about how to obtain the ID of a resource group, see [View basic information of a resource group](https://help.aliyun.com/document_detail/151181.html).', example='rg-df********534dy'),
  resourceId?: string(name='ResourceId', description='The resource ID, which is the workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='12**56'),
  resourceType?: string(name='ResourceType', description='The resource group type, which must be set to workspace.', example='workspace'),
}

model ChangeResourceGroupResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='6****27E-****-5144-A002-89C****8660F'),
}

model ChangeResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeResourceGroupResponseBody(name='body'),
}

/**
 * @summary Changes the resource group to which a resource belongs based on the ID.
 *
 * @param request ChangeResourceGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeResourceGroupResponse
 */
@context("changeResourceGroupWithContext")
async function changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, headers: map[string]string, runtime: $RuntimeOptions): ChangeResourceGroupResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.newResourceGroupId)) {
    body['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!$isNull(request.resourceId)) {
    body['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ChangeResourceGroup',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/resourcegroups/action/changeresourcegroup`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the resource group to which a resource belongs based on the ID.
 *
 * @param request ChangeResourceGroupRequest
 * @return ChangeResourceGroupResponse
 */
async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return changeResourceGroupWithOptions(request, headers, runtime);
}

model CreateCodeSourceRequest {
  accessibility?: string(name='Accessibility', description='The visibility of the code build. Valid values:

*   PUBLIC: The code build is visible to all members in the workspace.
*   PRIVATE: The code build is visible only to you and the administrator of the workspace.', example='PRIVATE'),
  codeBranch?: string(name='CodeBranch', description='The code branch.', example='master'),
  codeCommit?: string(name='CodeCommit'),
  codeRepo?: string(name='CodeRepo', description='The URL of the code repository.', example='https://code.aliyun.com/******'),
  codeRepoAccessToken?: string(name='CodeRepoAccessToken', description='The token used to access the code repository.', example='***'),
  codeRepoUserName?: string(name='CodeRepoUserName', description='The username of the code repository.', example='use***'),
  description?: string(name='Description', description='The description of the code build, which helps you distinguish between code builds.', example='code source of dlc examples'),
  displayName?: string(name='DisplayName', description='The name of the code build.

This parameter is required.', example='MyCodeSource1'),
  mountPath?: string(name='MountPath', description='The local mount path of the code. By default, the code is mounted to the /root/code/ path.', example='/root/code/code-source-1'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.

This parameter is required.', example='1234'),
}

model CreateCodeSourceResponseBody = {
  codeSourceId?: string(name='CodeSourceId', description='The ID of the created code build.', example='code-20********'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3**********'),
}

model CreateCodeSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCodeSourceResponseBody(name='body'),
}

/**
 * @summary Creates a code build in Platform for AI (PAI). You can configure Git branches and commit IDs. After the code build is created, you can reference the code build in a Deep Learning Containers (DLC) job.
 *
 * @param request CreateCodeSourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCodeSourceResponse
 */
@context("createCodeSourceWithContext")
async function createCodeSourceWithOptions(request: CreateCodeSourceRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateCodeSourceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.accessibility)) {
    body['Accessibility'] = request.accessibility;
  }
  if (!$isNull(request.codeBranch)) {
    body['CodeBranch'] = request.codeBranch;
  }
  if (!$isNull(request.codeCommit)) {
    body['CodeCommit'] = request.codeCommit;
  }
  if (!$isNull(request.codeRepo)) {
    body['CodeRepo'] = request.codeRepo;
  }
  if (!$isNull(request.codeRepoAccessToken)) {
    body['CodeRepoAccessToken'] = request.codeRepoAccessToken;
  }
  if (!$isNull(request.codeRepoUserName)) {
    body['CodeRepoUserName'] = request.codeRepoUserName;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.displayName)) {
    body['DisplayName'] = request.displayName;
  }
  if (!$isNull(request.mountPath)) {
    body['MountPath'] = request.mountPath;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateCodeSource',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/codesources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a code build in Platform for AI (PAI). You can configure Git branches and commit IDs. After the code build is created, you can reference the code build in a Deep Learning Containers (DLC) job.
 *
 * @param request CreateCodeSourceRequest
 * @return CreateCodeSourceResponse
 */
async function createCodeSource(request: CreateCodeSourceRequest): CreateCodeSourceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createCodeSourceWithOptions(request, headers, runtime);
}

model CreateConnectionRequest {
  accessibility?: string(name='Accessibility', description='The accessibility of the workspace. Valid values:

*   PRIVATE: The workspace is accessible only to you and the administrator of the workspace. This is the default value.
*   PUBLIC: The workspace is accessible to all users in the workspace.', example='PRIVATE'),
  configs?: map[string]string(name='Configs', description='The connection configurations, in key-value pairs. The key varies based on the connection type. For more information, see the supplementary notes below the request parameters.

This parameter is required.'),
  connectionName?: string(name='ConnectionName', description='The connection name.

This parameter is required.', example='llm-connection'),
  connectionType?: string(name='ConnectionType', description='The connection type. Valid values:

*   DashScopeConnection: Alibaba Cloud Model Studio connection
*   OpenLLMConnection: open source model connection
*   MilvusConnection: Milvus connection
*   OpenSearchConnection: OpenSearch connection
*   LindormConnection: Lindorm connection
*   ElasticsearchConnection: Elasticsearch connection
*   HologresConnection: Hologres connection
*   RDSConnection: RDS connection
*   CustomConnection: custom connection', example='DashScopeConnection'),
  description?: string(name='Description', description='The connection description.'),
  models?: [ 
    {
      displayName?: string(name='DisplayName', description='The display name of the model.'),
      model?: string(name='Model', description='The model identifier.', example='model_001'),
      modelType?: string(name='ModelType', description='The model type. Valid values:

*   LLM
*   Embedding
*   ReRank', example='LLM'),
      toolCall?: boolean(name='ToolCall', description='Specifies whether a tool can be called by using ToolCall. Valid values:

*   true
*   false', example='true'),
    }
  ](name='Models', description='The models, which apply to model service connections.'),
  resourceMeta?: {
    extra?: string(name='Extra'),
    instanceId?: string(name='InstanceId', description='The instance ID.', example='ld-uf69****9nqjjes'),
    instanceName?: string(name='InstanceName', description='The instance name.'),
  }(name='ResourceMeta', description='The instance resource information of the connection, which applies to database connections.'),
  secrets?: map[string]string(name='Secrets', description='The configuration to be encrypted. Examples: the database logon account and password and the key of the model service.'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='123**45'),
}

model CreateConnectionResponseBody = {
  connectionId?: string(name='ConnectionId', description='The connection ID.', example='conn-pai9m***mi47'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model CreateConnectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateConnectionResponseBody(name='body'),
}

/**
 * @summary Creates a connection. This API is used to connect Platform for AI (PAI) to customer models and databases in LangStudio and multimodal dataset search scenarios.
 *
 * @param request CreateConnectionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConnectionResponse
 */
@context("createConnectionWithContext")
async function createConnectionWithOptions(request: CreateConnectionRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateConnectionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.accessibility)) {
    body['Accessibility'] = request.accessibility;
  }
  if (!$isNull(request.configs)) {
    body['Configs'] = request.configs;
  }
  if (!$isNull(request.connectionName)) {
    body['ConnectionName'] = request.connectionName;
  }
  if (!$isNull(request.connectionType)) {
    body['ConnectionType'] = request.connectionType;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.models)) {
    body['Models'] = request.models;
  }
  if (!$isNull(request.resourceMeta)) {
    body['ResourceMeta'] = request.resourceMeta;
  }
  if (!$isNull(request.secrets)) {
    body['Secrets'] = request.secrets;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateConnection',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/connections`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a connection. This API is used to connect Platform for AI (PAI) to customer models and databases in LangStudio and multimodal dataset search scenarios.
 *
 * @param request CreateConnectionRequest
 * @return CreateConnectionResponse
 */
async function createConnection(request: CreateConnectionRequest): CreateConnectionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createConnectionWithOptions(request, headers, runtime);
}

model CreateDatasetRequest {
  accessibility?: string(name='Accessibility', description='The workspace accessibility. Valid values:

*   PRIVATE: The workspace is accessible only to you and the administrator of the workspace. This is the default value.
*   PUBLIC: The workspace is accessible to all users.', example='PRIVATE'),
  dataCount?: long(name='DataCount', description='The number of dataset files.', example='500'),
  dataSize?: long(name='DataSize', description='The size of the dataset file. Unit: bytes.', example='10000'),
  dataSourceType?: string(name='DataSourceType', description='The data source type. Valid values:

*   OSS: Object Storage Service (OSS).
*   NAS: File Storage NAS (NAS).

This parameter is required.', example='NAS'),
  dataType?: string(name='DataType', description='The type of the dataset. Default value: COMMON. Valid values:

*   COMMON: common
*   PIC: picture
*   TEXT: text
*   Video: video
*   AUDIO: audio', example='COMMON'),
  description?: string(name='Description', description='The description of the dataset. Descriptions are used to differentiate datasets.'),
  edition?: string(name='Edition'),
  importInfo?: string(name='ImportInfo', description='The dataset configurations to be imported to a storage, such as OSS, NAS, or Cloud Parallel File Storage (CPFS).

**OSS**

{\\\\
"region": "${region}",// The region ID.\\\\
"bucket": "${bucket}",//The bucket name.\\\\
"path": "${path}" // The file path.\\\\
}\\\\


**NAS**

{\\\\
"region": "${region}",// The region ID.\\\\
"fileSystemId": "${file_system_id}", // The file system ID.\\\\
"path": "${path}", // The file system path.\\\\
"mountTarget": "${mount_target}" // The mount point of the file system.\\\\
}\\\\


**CPFS**

{\\\\
"region": "${region}",// The region ID.\\\\
"fileSystemId": "${file_system_id}", // The file system ID.\\\\
"protocolServiceId":"${protocol_service_id}", // The file system protocol service.\\\\
"exportId": "${export_id}", // The file system export directory.\\\\
"path": "${path}", // The file system path.\\\\
}\\\\


**CPFS for Lingjun**

{\\\\
"region": "${region}",// The region ID.\\\\
"fileSystemId": "${file_system_id}", // The file system ID.\\\\
"path": "${path}", // The file system path.\\\\
"mountTarget": "${mount_target}" // The mount point of the file system, CPFS for Lingjun only.\\\\
"isVpcMount": boolean, // Whether the mount point is a virtual private cloud (VPC) mount point, CPFS for Lingjun only.\\\\
}\\\\', example='{
    "region": "cn-wulanchabu",
    "fileSystemId": "bmcpfs-xxxxxxxxxxx",
    "path": "/mnt",
    "mountTarget": "cpfs-xxxxxxxxxxxx-vpc-gacs9f.cn-wulanchabu.cpfs.aliyuncs.com",
    "isVpcMount": true
}'),
  labels?: [
    Label
  ](name='Labels', description='The tags.'),
  mountAccessReadWriteRoleIdList?: [ string ](name='MountAccessReadWriteRoleIdList', description='The list of role names in the workspace that have read and write permissions on the mounted database. The names start with PAI are basic role names and the names start with role- are custom role names. If the list contains asterisks (\\\\*), all roles have read and write permissions.

*   If you set the value to ["PAI.AlgoOperator", "role-hiuwpd01ncrokkgp21"], the account of the specified role is granted the read and write permissions.
*   If you set the value to ["\\\\*"], all accounts are granted the read and write permissions.
*   If you set the value to [], only the creator of the dataset has the read and write permissions.'),
  name?: string(name='Name', description='The dataset name. The name must meet the following requirements:

*   The name must start with a letter, digit, or Chinese character.
*   The name can contain underscores (_) and hyphens (-).
*   The name must be 1 to 127 characters in length.

This parameter is required.', example='myName'),
  options?: string(name='Options', description='The extended field, which is a JSON string. When you use the dataset in Deep Learning Containers (DLC), you can configure the mountPath field to specify the default mount path of the dataset.', example='{
  "mountPath": "/mnt/data/"
}'),
  property?: string(name='Property', description='The property of the dataset. Valid values:

*   FILE
*   DIRECTORY

This parameter is required.', example='DIRECTORY'),
  provider?: string(name='Provider', description='The dataset provider. The value cannot be set to pai.', example='Github'),
  providerType?: string(name='ProviderType', description='The source type of the dataset. Valid values:

*   Ecs (default)
*   Lingjun', example='Ecs'),
  sourceDatasetId?: string(name='SourceDatasetId', description='The ID of the source dataset for the labeled dataset.', example='d-bvfasdfxxxxj8o411'),
  sourceDatasetVersion?: string(name='SourceDatasetVersion', description='The version of the source dataset for the labeled dataset.', example='v2'),
  sourceId?: string(name='SourceId', description='The data source ID.

*   If SourceType is set to USER, the value of SourceId is a custom string.
*   If SourceType is set to ITAG, the value of SourceId is the ID of the labeling job of iTAG.
*   If SourceType is set to PAI_PUBLIC_DATASET, SourceId is empty by default.', example='jdnhf***fnrimv'),
  sourceType?: string(name='SourceType', description='The type of the data source. Default value: USER.

Valid values:

*   PAI_PUBLIC_DATASET: a public dataset of PAI.
*   ITAG: a dataset generated from a labeling job of iTAG.
*   USER: a dataset registered by a user.', example='USER'),
  uri?: string(name='Uri', description='The URI of the data source.

*   Value format if DataSourceType is set to OSS: `oss://bucket.endpoint/object`.
*   Value formats if DataSourceType is set to NAS: General-purpose NAS: `nas://<nasfisid>.region/subpath/to/dir/`. CPFS 1.0: `nas://<cpfs-fsid>.region/subpath/to/dir/`. CPFS 2.0: `nas://<cpfs-fsid>.region/<protocolserviceid>/`. You can distinguish CPFS 1.0 and CPFS 2.0 file systems based on the format of the file system ID: The ID for CPFS 1.0 is in the cpfs-<8-bit ASCII characters> format. The ID for CPFS 2.0 is in the cpfs-<16-bit ASCII characters> format.

This parameter is required.', example='nas://09f****f2.cn-hangzhou/'),
  userId?: string(name='UserId', description='The ID of the Alibaba Cloud account to which the dataset belongs. The workspace owner and administrator have permissions to create datasets for specified members in the workspace.', example='2485765****023475'),
  versionDescription?: string(name='VersionDescription', description='The description of the dataset of the initial version.', example='The initial version'),
  versionLabels?: [
    Label
  ](name='VersionLabels', description='The list of tags to be added to the dataset of the initial version.'),
  workspaceId?: string(name='WorkspaceId', description='The ID of the workspace to which the dataset belongs. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID. If you do not specify this parameter, the default workspace is used. If the default workspace does not exist, an error is reported.', example='478**'),
}

model CreateDatasetResponseBody = {
  datasetId?: string(name='DatasetId', description='The dataset ID.', example='d-rbvg5*****jhc9ks92'),
  requestId?: string(name='RequestId', description='The request ID.', example='B2C51F93-1C07-5477-9705-5FDB****F19F'),
}

model CreateDatasetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDatasetResponseBody(name='body'),
}

/**
 * @summary Creates a dataset.
 *
 * @param request CreateDatasetRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDatasetResponse
 */
@context("createDatasetWithContext")
async function createDatasetWithOptions(request: CreateDatasetRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateDatasetResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.accessibility)) {
    body['Accessibility'] = request.accessibility;
  }
  if (!$isNull(request.dataCount)) {
    body['DataCount'] = request.dataCount;
  }
  if (!$isNull(request.dataSize)) {
    body['DataSize'] = request.dataSize;
  }
  if (!$isNull(request.dataSourceType)) {
    body['DataSourceType'] = request.dataSourceType;
  }
  if (!$isNull(request.dataType)) {
    body['DataType'] = request.dataType;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.edition)) {
    body['Edition'] = request.edition;
  }
  if (!$isNull(request.importInfo)) {
    body['ImportInfo'] = request.importInfo;
  }
  if (!$isNull(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!$isNull(request.mountAccessReadWriteRoleIdList)) {
    body['MountAccessReadWriteRoleIdList'] = request.mountAccessReadWriteRoleIdList;
  }
  if (!$isNull(request.name)) {
    body['Name'] = request.name;
  }
  if (!$isNull(request.options)) {
    body['Options'] = request.options;
  }
  if (!$isNull(request.property)) {
    body['Property'] = request.property;
  }
  if (!$isNull(request.provider)) {
    body['Provider'] = request.provider;
  }
  if (!$isNull(request.providerType)) {
    body['ProviderType'] = request.providerType;
  }
  if (!$isNull(request.sourceDatasetId)) {
    body['SourceDatasetId'] = request.sourceDatasetId;
  }
  if (!$isNull(request.sourceDatasetVersion)) {
    body['SourceDatasetVersion'] = request.sourceDatasetVersion;
  }
  if (!$isNull(request.sourceId)) {
    body['SourceId'] = request.sourceId;
  }
  if (!$isNull(request.sourceType)) {
    body['SourceType'] = request.sourceType;
  }
  if (!$isNull(request.uri)) {
    body['Uri'] = request.uri;
  }
  if (!$isNull(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!$isNull(request.versionDescription)) {
    body['VersionDescription'] = request.versionDescription;
  }
  if (!$isNull(request.versionLabels)) {
    body['VersionLabels'] = request.versionLabels;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateDataset',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a dataset.
 *
 * @param request CreateDatasetRequest
 * @return CreateDatasetResponse
 */
async function createDataset(request: CreateDatasetRequest): CreateDatasetResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createDatasetWithOptions(request, headers, runtime);
}

model CreateDatasetFileMetasRequest {
  datasetFileMetas?: [
    DatasetFileMetaContentCreate
  ](name='DatasetFileMetas', description='The metadata of the file.

This parameter is required.'),
  datasetVersion?: string(name='DatasetVersion', description='The dataset version name.

This parameter is required.', example='v1'),
  workspaceId?: string(name='WorkspaceId', description='The ID of the workspace to which the dataset belongs. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.

This parameter is required.', example='478**'),
}

model CreateDatasetFileMetasResponseBody = {
  failedDetails?: [
    DatasetFileMetaResponse
  ](name='FailedDetails', description='The metadata that failed to be created.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  status?: boolean(name='Status', description='Indicates whether the metadata records of all dataset files were created. The value true indicates that the metadata records of all dataset files are created. If the value is false, view the failure details specified by FailedDetails.

Valid values:

*   true
*   false', example='true'),
  succeedDetails?: [
    DatasetFileMetaResponse
  ](name='SucceedDetails', description='The metadata that is created.'),
}

model CreateDatasetFileMetasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDatasetFileMetasResponseBody(name='body'),
}

/**
 * @summary Creates the metadata records of multiple files in a dataset at a time.
 *
 * @param request CreateDatasetFileMetasRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDatasetFileMetasResponse
 */
@context("createDatasetFileMetasWithContext")
async function createDatasetFileMetasWithOptions(DatasetId: string, request: CreateDatasetFileMetasRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateDatasetFileMetasResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.datasetFileMetas)) {
    body['DatasetFileMetas'] = request.datasetFileMetas;
  }
  if (!$isNull(request.datasetVersion)) {
    body['DatasetVersion'] = request.datasetVersion;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateDatasetFileMetas',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/datasetfilemetas`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates the metadata records of multiple files in a dataset at a time.
 *
 * @param request CreateDatasetFileMetasRequest
 * @return CreateDatasetFileMetasResponse
 */
async function createDatasetFileMetas(DatasetId: string, request: CreateDatasetFileMetasRequest): CreateDatasetFileMetasResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createDatasetFileMetasWithOptions(DatasetId, request, headers, runtime);
}

model CreateDatasetJobRequest {
  datasetVersion?: string(name='DatasetVersion', description='The dataset version.', example='v1'),
  description?: string(name='Description', description='The job description.'),
  jobAction?: string(name='JobAction', description='The job action.

Valid values:

*   SemanticIndex
*   IntelligentTag
*   FileMetaExport

This parameter is required.', example='SemanticIndex'),
  jobMode?: string(name='JobMode', description='The job mode.

Valid values:

*   Full: full mode.', example='Full'),
  jobSpec?: string(name='JobSpec', description='The job configuration.

This parameter is required.', example='{\\\\"modelId\\\\":\\\\"xxx\\\\"}'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.

This parameter is required.', example='478**'),
}

model CreateDatasetJobResponseBody = {
  datasetJobId?: string(name='DatasetJobId', description='The ID of the dataset job.', example='dsjob-9jx1******uj9e'),
  requestId?: string(name='RequestId', description='The request ID.', example='99341606-****-0757724D97EE'),
}

model CreateDatasetJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDatasetJobResponseBody(name='body'),
}

/**
 * @summary Creates a dataset job.
 *
 * @param request CreateDatasetJobRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDatasetJobResponse
 */
@context("createDatasetJobWithContext")
async function createDatasetJobWithOptions(DatasetId: string, request: CreateDatasetJobRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateDatasetJobResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.datasetVersion)) {
    body['DatasetVersion'] = request.datasetVersion;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.jobAction)) {
    body['JobAction'] = request.jobAction;
  }
  if (!$isNull(request.jobMode)) {
    body['JobMode'] = request.jobMode;
  }
  if (!$isNull(request.jobSpec)) {
    body['JobSpec'] = request.jobSpec;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateDatasetJob',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/datasetjobs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a dataset job.
 *
 * @param request CreateDatasetJobRequest
 * @return CreateDatasetJobResponse
 */
async function createDatasetJob(DatasetId: string, request: CreateDatasetJobRequest): CreateDatasetJobResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createDatasetJobWithOptions(DatasetId, request, headers, runtime);
}

model CreateDatasetJobConfigRequest {
  config?: string(name='Config', description='The configuration content. Format:

*   MultimodalIntelligentTag

{ "apiKey":"sk-xxxxxxxxxxxxxxxxxxxxx" }

*   MultimodalSemanticIndex

{ "defaultModelId": "xxx" "defaultModelVersion":"1.0.0" }

This parameter is required.', example='{ "apiKey":"sk-xxxxxxxxxxxxxxxxxxxxx" }'),
  configType?: string(name='ConfigType', description='The configuration type.

Valid values:

*   MultimodalIntelligentTag
*   MultimodalSemanticIndex

This parameter is required.', example='MultimodalIntelligentTag'),
  datasetVersion?: string(name='DatasetVersion'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.

This parameter is required.', example='454716'),
}

model CreateDatasetJobConfigResponseBody = {
  datasetJobConfigId?: string(name='DatasetJobConfigId', description='The configuration ID.', example='dscfg-xxxxxxxxxxxxxx'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model CreateDatasetJobConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDatasetJobConfigResponseBody(name='body'),
}

/**
 * @summary Creates a job configuration for a dataset.
 *
 * @param request CreateDatasetJobConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDatasetJobConfigResponse
 */
@context("createDatasetJobConfigWithContext")
async function createDatasetJobConfigWithOptions(DatasetId: string, request: CreateDatasetJobConfigRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateDatasetJobConfigResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.config)) {
    body['Config'] = request.config;
  }
  if (!$isNull(request.configType)) {
    body['ConfigType'] = request.configType;
  }
  if (!$isNull(request.datasetVersion)) {
    body['DatasetVersion'] = request.datasetVersion;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateDatasetJobConfig',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/datasetjobconfigs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a job configuration for a dataset.
 *
 * @param request CreateDatasetJobConfigRequest
 * @return CreateDatasetJobConfigResponse
 */
async function createDatasetJobConfig(DatasetId: string, request: CreateDatasetJobConfigRequest): CreateDatasetJobConfigResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createDatasetJobConfigWithOptions(DatasetId, request, headers, runtime);
}

model CreateDatasetLabelsRequest {
  labels?: [
    Label
  ](name='Labels', description='The tags.'),
}

model CreateDatasetLabelsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A083731B-4973-54D1-B324-E53****4DD44'),
}

model CreateDatasetLabelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDatasetLabelsResponseBody(name='body'),
}

/**
 * @summary Creates tags for a dataset.
 *
 * @description Before you call this operation, take note of the following items:
 * *   The tag key and value are not empty strings and cannot exceed 128 characters in length.
 * *   The tag key cannot start with any of the following strings: "aliyun", "acs", "http://", and "https://".
 *
 * @param request CreateDatasetLabelsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDatasetLabelsResponse
 */
@context("createDatasetLabelsWithContext")
async function createDatasetLabelsWithOptions(DatasetId: string, request: CreateDatasetLabelsRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateDatasetLabelsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.labels)) {
    body['Labels'] = request.labels;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateDatasetLabels',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/labels`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates tags for a dataset.
 *
 * @description Before you call this operation, take note of the following items:
 * *   The tag key and value are not empty strings and cannot exceed 128 characters in length.
 * *   The tag key cannot start with any of the following strings: "aliyun", "acs", "http://", and "https://".
 *
 * @param request CreateDatasetLabelsRequest
 * @return CreateDatasetLabelsResponse
 */
async function createDatasetLabels(DatasetId: string, request: CreateDatasetLabelsRequest): CreateDatasetLabelsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createDatasetLabelsWithOptions(DatasetId, request, headers, runtime);
}

model CreateDatasetVersionRequest {
  dataCount?: long(name='DataCount', description='The number of dataset files.', example='300'),
  dataSize?: long(name='DataSize', description='The size of the dataset file. Unit: bytes.', example='19000'),
  dataSourceType?: string(name='DataSourceType', description='The type of the data source. Separate multiple types with commas (,). Valid values:

*   NAS: File Storage NAS (NAS).
*   OSS: Object Storage Service (OSS).
*   CPFS

Note: The DataSourceType value of a dataset version must be the same as that of the dataset. When you create a dataset version, the system checks whether the values are the same.

This parameter is required.', example='OSS'),
  description?: string(name='Description', description='The description of the dataset. Descriptions are used to differentiate datasets.'),
  importInfo?: string(name='ImportInfo', description='The dataset storage import configurations, such as OSS, NAS, and CPFS.

**OSS**

{\\\\
"region": "${region}",// The region ID\\\\
"bucket": "${bucket}",//The bucket name\\\\
"path": "${path}" // The file path\\\\
}\\\\


**NAS**

{\\\\
"region": "${region}",// The region ID\\\\
"fileSystemId": "${file_system_id}", // The file system ID\\\\
"path": "${path}", // The file system path\\\\
"mountTarget": "${mount_target}" // The mount point of the file system\\\\
}\\\\


**CPFS**

{\\\\
"region": "${region}",// The region ID\\\\
"fileSystemId": "${file_system_id}", // The file system ID\\\\
"protocolServiceId":"${protocol_service_id}", // The file system protocol service\\\\
"exportId": "${export_id}", // The file system export directory\\\\
"path": "${path}", // The file system path\\\\
}\\\\


**CPFS for Lingjun**

{\\\\
"region": "${region}",// The region ID\\\\
"fileSystemId": "${file_system_id}", // The file system ID\\\\
"path": "${path}", // The ile system path\\\\
"mountTarget": "${mount_target}" // The mount point of the file system, CPFS for Lingjun only\\\\
"isVpcMount": boolean, // Whether the mount point is a VPC mount point, CPFS for Lingjun only\\\\
}\\\\', example='{
    "region": "cn-wulanchabu",
    "fileSystemId": "bmcpfs-xxxxxxxxxxx",
    "path": "/mnt",
    "mountTarget": "cpfs-xxxxxxxxxxxx-vpc-gacs9f.cn-wulanchabu.cpfs.aliyuncs.com",
    "isVpcMount": true
}'),
  labels?: [
    Label
  ](name='Labels', description='The tags of the dataset version.'),
  options?: string(name='Options', description='The extended field, which is of the JsonString type. When you use the dataset in Deep Learning Containers (DLC), you can use the mountPath field to specify the default mount path of the dataset.', example='{
  "mountPath": "/mnt/data/"
}'),
  property?: string(name='Property', description='The property of the dataset. Valid values:

*   FILE
*   DIRECTORY

This parameter is required.', example='DIRECTORY'),
  sourceId?: string(name='SourceId', description='The ID of the data source.

*   If SourceType is set to USER, the value of SourceId can be a custom string.
*   If SourceType is set to ITAG, the value of SourceId is the ID of the labeling job of iTAG.
*   If SourceType is set to PAI_PUBLIC_DATASET, SourceId is empty by default.', example='d-a0xbe5n03bhqof46ce'),
  sourceType?: string(name='SourceType', description='The type of the data source. Default value: USER. Valid values:

*   PAI-PUBLIC-DATASET: a public dataset of Platform for AI (PAI).
*   ITAG: a dataset generated from a labeling job of iTAG.
*   USER: a dataset registered by a user.

For each job type:

*   PAI_PUBLIC_DATASET: PAI_PUBLIC_DATASET.
*   ITAG: ITAG.
*   USER: USER.', example='USER'),
  uri?: string(name='Uri', description='Example format:

*   Value format when DataSourceType is set to OSS: `oss://bucket.endpoint/object`.
*   Value formats when DataSourceType is set to NAS: General-purpose NAS: `nas://<nasfisid>.region/subpath/to/dir/`. CPFS 1.0: `nas://<cpfs-fsid>.region/subpath/to/dir/`. CPFS 2.0: `nas://<cpfs-fsid>.region/<protocolserviceid>/`. You can distinguish CPFS 1.0 and CPFS 2.0 file systems based on the format of the file system ID: The ID for CPFS 1.0 is in the cpfs-<8-bit ASCII characters> format. The ID for CPFS 2.0 is in the cpfs-<16-bit ASCII characters> format.

This parameter is required.', example='oss://mybucket.oss-cn-beijing.aliyuncs.com/mypath/'),
}

model CreateDatasetVersionResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  versionName?: string(name='VersionName', description='The dataset version name.', example='v1'),
}

model CreateDatasetVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDatasetVersionResponseBody(name='body'),
}

/**
 * @summary Creates a dataset version.
 *
 * @param request CreateDatasetVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDatasetVersionResponse
 */
@context("createDatasetVersionWithContext")
async function createDatasetVersionWithOptions(DatasetId: string, request: CreateDatasetVersionRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateDatasetVersionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.dataCount)) {
    body['DataCount'] = request.dataCount;
  }
  if (!$isNull(request.dataSize)) {
    body['DataSize'] = request.dataSize;
  }
  if (!$isNull(request.dataSourceType)) {
    body['DataSourceType'] = request.dataSourceType;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.importInfo)) {
    body['ImportInfo'] = request.importInfo;
  }
  if (!$isNull(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!$isNull(request.options)) {
    body['Options'] = request.options;
  }
  if (!$isNull(request.property)) {
    body['Property'] = request.property;
  }
  if (!$isNull(request.sourceId)) {
    body['SourceId'] = request.sourceId;
  }
  if (!$isNull(request.sourceType)) {
    body['SourceType'] = request.sourceType;
  }
  if (!$isNull(request.uri)) {
    body['Uri'] = request.uri;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateDatasetVersion',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a dataset version.
 *
 * @param request CreateDatasetVersionRequest
 * @return CreateDatasetVersionResponse
 */
async function createDatasetVersion(DatasetId: string, request: CreateDatasetVersionRequest): CreateDatasetVersionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createDatasetVersionWithOptions(DatasetId, request, headers, runtime);
}

model CreateDatasetVersionLabelsRequest {
  labels?: [
    Label
  ](name='Labels', description='The tags.

This parameter is required.'),
}

model CreateDatasetVersionLabelsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='8D7B2E70-F770-505B-A672-09F1D8F2EC1E'),
}

model CreateDatasetVersionLabelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDatasetVersionLabelsResponseBody(name='body'),
}

/**
 * @summary Creates tags for a dataset version.
 *
 * @param request CreateDatasetVersionLabelsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDatasetVersionLabelsResponse
 */
@context("createDatasetVersionLabelsWithContext")
async function createDatasetVersionLabelsWithOptions(DatasetId: string, VersionName: string, request: CreateDatasetVersionLabelsRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateDatasetVersionLabelsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.labels)) {
    body['Labels'] = request.labels;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateDatasetVersionLabels',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/versions/${$URL.percentEncode(VersionName)}/labels`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates tags for a dataset version.
 *
 * @param request CreateDatasetVersionLabelsRequest
 * @return CreateDatasetVersionLabelsResponse
 */
async function createDatasetVersionLabels(DatasetId: string, VersionName: string, request: CreateDatasetVersionLabelsRequest): CreateDatasetVersionLabelsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createDatasetVersionLabelsWithOptions(DatasetId, VersionName, request, headers, runtime);
}

model CreateExperimentRequest {
  accessibility?: string(name='Accessibility', description='The visibility of the experiment. Valid values: PRIVATE (the experiment is visible only to the creator and the Alibaba Cloud account) and PUBLIC (the experiment is visible to all users). This parameter is optional and the default value is PRIVATE.', example='PRIVATE'),
  artifactUri?: string(name='ArtifactUri', description='The default artifact output path of all jobs that are associated with the experiment. Only Object Storage Service (OSS) paths are supported.', example='oss://test-bucket.oss-cn-hangzhou.aliyuncs.com/test'),
  labels?: [
    LabelInfo
  ](name='Labels', description='The tags.'),
  name?: string(name='Name', description='The experiment name. The name must meet the following requirements:

*   The name must start with a letter.
*   The name can contain letters, digits, underscores (_), and hyphens (-).
*   The name must be 1 to 63 characters in length.

This parameter is required.', example='exp-test'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.

This parameter is required.', example='478**'),
}

model CreateExperimentResponseBody = {
  experimentId?: string(name='ExperimentId', description='The returned data. If the operation is asynchronously implemented, the job ID is returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.'),
}

model CreateExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateExperimentResponseBody(name='body'),
}

/**
 * @summary Creates an experiment.
 *
 * @param request CreateExperimentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateExperimentResponse
 */
@context("createExperimentWithContext")
async function createExperimentWithOptions(request: CreateExperimentRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateExperimentResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.accessibility)) {
    body['Accessibility'] = request.accessibility;
  }
  if (!$isNull(request.artifactUri)) {
    body['ArtifactUri'] = request.artifactUri;
  }
  if (!$isNull(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!$isNull(request.name)) {
    body['Name'] = request.name;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateExperiment',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an experiment.
 *
 * @param request CreateExperimentRequest
 * @return CreateExperimentResponse
 */
async function createExperiment(request: CreateExperimentRequest): CreateExperimentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createExperimentWithOptions(request, headers, runtime);
}

model CreateMemberRequest {
  members?: [ 
    {
      roles?: [ string ](name='Roles', description='The list of roles.

This parameter is required.'),
      userId?: string(name='UserId', description='The member IDs. Multiple member IDs are separated by commas (,). You can call [ListMembers](https://help.aliyun.com/document_detail/449135.html) to obtain the member IDs.

This parameter is required.', example='21513926******88039'),
    }
  ](name='Members', description='The members.

This parameter is required.'),
}

model CreateMemberResponseBody = {
  members?: [ 
    {
      displayName?: string(name='DisplayName', description='The display name.', example='myDisplayName'),
      memberId?: string(name='MemberId', description='The member ID.', example='145883-21513926******88039'),
      roles?: [ string ](name='Roles', description='The list of roles.'),
      userId?: string(name='UserId', description='The user ID.', example='21513926******88039'),
    }
  ](name='Members', description='The returned members.'),
  requestId?: string(name='RequestId', description='The request ID.', example='DA869D1B-035A-43B2-ACC1-C56681BD9FAA'),
}

model CreateMemberResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMemberResponseBody(name='body'),
}

/**
 * @summary Adds a user to a workspace as a member. You can add multiple users as members.
 *
 * @param request CreateMemberRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMemberResponse
 */
@context("createMemberWithContext")
async function createMemberWithOptions(WorkspaceId: string, request: CreateMemberRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateMemberResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.members)) {
    body['Members'] = request.members;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMember',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}/members`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds a user to a workspace as a member. You can add multiple users as members.
 *
 * @param request CreateMemberRequest
 * @return CreateMemberResponse
 */
async function createMember(WorkspaceId: string, request: CreateMemberRequest): CreateMemberResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createMemberWithOptions(WorkspaceId, request, headers, runtime);
}

model CreateModelRequest {
  accessibility?: string(name='Accessibility', description='The visibility of the model in the workspace. Valid values:

*   PRIVATE (default): Visible only to you and the administrator of the workspace.
*   PUBLIC: Vvisible to all users in the workspace.', example='PRIVATE'),
  domain?: string(name='Domain', description='The domain of the model. Describes the domain in which the model is for. Example: nlp (natural language processing), cv (computer vision), and others.', example='nlp'),
  extraInfo?: map[string]any(name='ExtraInfo', description='Other information about the model.', example='{
	"RatingCount": 2866,
	"Rating": 4.94,
	"FavoriteCount": 34992,
	"CommentCount": 754,
	"CoverUris": ["https://e***u.oss-cn-hangzhou.aliyuncs.com/drea***w.png"],
	"TippedAmountCount": 32,
	"DownloadCount": 606056
}', nullable=true),
  labels?: [
    Label
  ](name='Labels', description='The tags. This parameter will be deprecated and replaced by Tag.'),
  modelDescription?: string(name='ModelDescription', description='The model description, used to distinguish different models.'),
  modelDoc?: string(name='ModelDoc', description='The documentation of the model.', example='https://*.md'),
  modelName?: string(name='ModelName', description='The name of the model. The name must be 1 to 127 characters in length.

This parameter is required.'),
  modelType?: string(name='ModelType', description='The model type. Example: Checkpoint or LoRA.', example='Checkpoint'),
  orderNumber?: long(name='OrderNumber', description='The sequence number of the model. Can be used for custom sorting.', example='0'),
  origin?: string(name='Origin', description='The source of the model. The community or organization to which the source model belongs, such as ModelScope or HuggingFace.', example='ModelScope'),
  parameterSize?: long(name='ParameterSize'),
  tag?: [
    Label
  ](name='Tag', description='The tags.'),
  task?: string(name='Task', description='The task of the model. Describes the specific problem that the model solves. Example: text-classification.', example='text-classification'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. Call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='796**'),
}

model CreateModelResponseBody = {
  modelId?: string(name='ModelId', description='The model ID.', example='model-rbvg5wzljz****ks92'),
  requestId?: string(name='RequestId', description='The request ID.', example='9DAD3112-AE22-5563-9A02-5C7E8****E35'),
}

model CreateModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateModelResponseBody(name='body'),
}

/**
 * @summary Creates a model. A model is a collection of model versions. When you create a model, you must specify the model name and description.
 *
 * @param request CreateModelRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateModelResponse
 */
@context("createModelWithContext")
async function createModelWithOptions(request: CreateModelRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateModelResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.accessibility)) {
    body['Accessibility'] = request.accessibility;
  }
  if (!$isNull(request.domain)) {
    body['Domain'] = request.domain;
  }
  if (!$isNull(request.extraInfo)) {
    body['ExtraInfo'] = request.extraInfo;
  }
  if (!$isNull(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!$isNull(request.modelDescription)) {
    body['ModelDescription'] = request.modelDescription;
  }
  if (!$isNull(request.modelDoc)) {
    body['ModelDoc'] = request.modelDoc;
  }
  if (!$isNull(request.modelName)) {
    body['ModelName'] = request.modelName;
  }
  if (!$isNull(request.modelType)) {
    body['ModelType'] = request.modelType;
  }
  if (!$isNull(request.orderNumber)) {
    body['OrderNumber'] = request.orderNumber;
  }
  if (!$isNull(request.origin)) {
    body['Origin'] = request.origin;
  }
  if (!$isNull(request.parameterSize)) {
    body['ParameterSize'] = request.parameterSize;
  }
  if (!$isNull(request.tag)) {
    body['Tag'] = request.tag;
  }
  if (!$isNull(request.task)) {
    body['Task'] = request.task;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateModel',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/models`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a model. A model is a collection of model versions. When you create a model, you must specify the model name and description.
 *
 * @param request CreateModelRequest
 * @return CreateModelResponse
 */
async function createModel(request: CreateModelRequest): CreateModelResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createModelWithOptions(request, headers, runtime);
}

model CreateModelLabelsRequest {
  labels?: [
    Label
  ](name='Labels', description='The tags.'),
}

model CreateModelLabelsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F81D9EC0-1872-50F5-A96C-A0647D****1D'),
}

model CreateModelLabelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateModelLabelsResponseBody(name='body'),
}

/**
 * @summary Creates a tag for a model.
 *
 * @param request CreateModelLabelsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateModelLabelsResponse
 */
@context("createModelLabelsWithContext")
async function createModelLabelsWithOptions(ModelId: string, request: CreateModelLabelsRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateModelLabelsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.labels)) {
    body['Labels'] = request.labels;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateModelLabels',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/models/${$URL.percentEncode(ModelId)}/labels`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a tag for a model.
 *
 * @param request CreateModelLabelsRequest
 * @return CreateModelLabelsResponse
 */
async function createModelLabels(ModelId: string, request: CreateModelLabelsRequest): CreateModelLabelsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createModelLabelsWithOptions(ModelId, request, headers, runtime);
}

model CreateModelVersionRequest {
  approvalStatus?: string(name='ApprovalStatus', description='The approval status. Valid values:

*   Pending
*   Approved
*   Rejected', example='Approved'),
  compressionSpec?: map[string]any(name='CompressionSpec', description='The compression configuration.', example='{}'),
  distillationSpec?: map[string]any(name='DistillationSpec'),
  evaluationSpec?: map[string]any(name='EvaluationSpec', description='The evaluation configuration.', example='{}'),
  extraInfo?: map[string]any(name='ExtraInfo', description='The additional information.', example='{
	"CoverUris": ["https://e***u.oss-cn-hangzhou.aliyuncs.com/st****017.preview.png"],
	"TrainedWords": ["albedo_overlord"]
}'),
  formatType?: string(name='FormatType', description='The model format. Valid values:

*   OfflineModel
*   SavedModel
*   Keras H5
*   Frozen Pb
*   Caffe Prototxt
*   TorchScript
*   XGBoost
*   PMML
*   AlinkModel
*   ONNX', example='SavedModel'),
  frameworkType?: string(name='FrameworkType', description='The model framework. Valid values:

*   Pytorch
*   XGBoost
*   Keras
*   Caffe
*   Alink
*   Xflow
*   TensorFlow', example='TensorFlow'),
  inferenceSpec?: map[string]any(name='InferenceSpec', description='Describes how to apply to downstream inference services. For example, describe the processor and container of EAS. Example: `{ "processor": "tensorflow_gpu_1.12" }`', example='{
    "processor": "tensorflow_gpu_1.12"
}'),
  labels?: [
    Label
  ](name='Labels', description='The labels.'),
  metrics?: map[string]any(name='Metrics', description='The metrics for the model. The length after serialization is limited to 8,192.', example='{
  "Results": [{
    "Dataset": {
      "DatasetId": "d-sdkjanksaklerhfd"
    },
    "Metrics": {
      "cer": 0.175
    }
  }, {
    "Dataset": {
      "Uri": "oss://xxxx/"
    },
    "Metrics": {
      "cer": 0.172
    }
  }]
}'),
  options?: string(name='Options', description='The extended field. This is a JSON string.', example='{}'),
  sourceId?: string(name='SourceId', description='The ID of the model source.

*   If SourceType is set to Custom, this parameter is not limited.
*   If SourceType is set to PAIFlow or TrainingService, the ID of the model source is in the following format:

<!---->

    region=<region_id>,workspaceId=<workspace_id>,kind=<kind>,id=<id>

Take note of the following parameters:

*   region indicates the region ID.
*   workspaceId indicates the workspace ID.
*   kind indicates the type. Valid values: PipelineRun (PAIFlow) and ServiceJob (training service).
*   id indicates the unique identifier.', example='region=cn-shanghai,workspaceId=13**,kind=PipelineRun,id=run-sakdb****jdf'),
  sourceType?: string(name='SourceType', description='The type of the model source. Valid values:

*   Custom (default)
*   PAIFlow
*   TrainingService: the Platform for AI (PAI) training service.', example='PAIFlow'),
  trainingSpec?: map[string]any(name='TrainingSpec', description='The training configurations, which is used for fine-tuning and incremental training.', example='{}'),
  uri?: string(name='Uri', description='The URI of the model version, which is the location where the model is stored. Valid values:

*   The HTTP(S) address of the model. Example: `https://myweb.com/mymodel.tar.gz`.
*   The OSS path of the model, in the format of `oss://<bucket>.<endpoint>/object`. For information about endpoints, see [OSS regions and endpoints](https://help.aliyun.com/document_detail/31837.html). Example: `oss://mybucket.oss-cn-beijing.aliyuncs.com/mypath/`.

This parameter is required.', example='oss://mybucket.oss-cn-beijing.aliyuncs.com/mypath/'),
  versionDescription?: string(name='VersionDescription', description='The version description.'),
  versionName?: string(name='VersionName', description='The model version, which is unique for each model. If you leave this parameter empty, the first version is **0.1.0** by default. After that, the minor version number is increased by 1 in sequence. For example, the second version number is **0.2.0**. A version number consists of a major version number, a minor version number, and a stage version number, separated by periods (.). The major version number and minor version number are numeric. The stage version number begins with a digit and can include numbers, underscores, and letters. For example, the version number is 1.1.0 or 2.3.4_beta.', example='0.1.0'),
}

model CreateModelVersionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='21645FCD-BAB9-5742-89AE-AEB27****B2E'),
  versionName?: string(name='VersionName', description='The version of the model.', example='0.1.0'),
}

model CreateModelVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateModelVersionResponseBody(name='body'),
}

/**
 * @summary Creates a new version for the specified model.
 *
 * @param request CreateModelVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateModelVersionResponse
 */
@context("createModelVersionWithContext")
async function createModelVersionWithOptions(ModelId: string, request: CreateModelVersionRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateModelVersionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.approvalStatus)) {
    body['ApprovalStatus'] = request.approvalStatus;
  }
  if (!$isNull(request.compressionSpec)) {
    body['CompressionSpec'] = request.compressionSpec;
  }
  if (!$isNull(request.distillationSpec)) {
    body['DistillationSpec'] = request.distillationSpec;
  }
  if (!$isNull(request.evaluationSpec)) {
    body['EvaluationSpec'] = request.evaluationSpec;
  }
  if (!$isNull(request.extraInfo)) {
    body['ExtraInfo'] = request.extraInfo;
  }
  if (!$isNull(request.formatType)) {
    body['FormatType'] = request.formatType;
  }
  if (!$isNull(request.frameworkType)) {
    body['FrameworkType'] = request.frameworkType;
  }
  if (!$isNull(request.inferenceSpec)) {
    body['InferenceSpec'] = request.inferenceSpec;
  }
  if (!$isNull(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!$isNull(request.metrics)) {
    body['Metrics'] = request.metrics;
  }
  if (!$isNull(request.options)) {
    body['Options'] = request.options;
  }
  if (!$isNull(request.sourceId)) {
    body['SourceId'] = request.sourceId;
  }
  if (!$isNull(request.sourceType)) {
    body['SourceType'] = request.sourceType;
  }
  if (!$isNull(request.trainingSpec)) {
    body['TrainingSpec'] = request.trainingSpec;
  }
  if (!$isNull(request.uri)) {
    body['Uri'] = request.uri;
  }
  if (!$isNull(request.versionDescription)) {
    body['VersionDescription'] = request.versionDescription;
  }
  if (!$isNull(request.versionName)) {
    body['VersionName'] = request.versionName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateModelVersion',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/models/${$URL.percentEncode(ModelId)}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a new version for the specified model.
 *
 * @param request CreateModelVersionRequest
 * @return CreateModelVersionResponse
 */
async function createModelVersion(ModelId: string, request: CreateModelVersionRequest): CreateModelVersionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createModelVersionWithOptions(ModelId, request, headers, runtime);
}

model CreateModelVersionLabelsRequest {
  labels?: [
    Label
  ](name='Labels', description='The tags.'),
}

model CreateModelVersionLabelsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model CreateModelVersionLabelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateModelVersionLabelsResponseBody(name='body'),
}

/**
 * @summary Creates a tag for a model version.
 *
 * @param request CreateModelVersionLabelsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateModelVersionLabelsResponse
 */
@context("createModelVersionLabelsWithContext")
async function createModelVersionLabelsWithOptions(ModelId: string, VersionName: string, request: CreateModelVersionLabelsRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateModelVersionLabelsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.labels)) {
    body['Labels'] = request.labels;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateModelVersionLabels',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/models/${$URL.percentEncode(ModelId)}/versions/${$URL.percentEncode(VersionName)}/labels`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a tag for a model version.
 *
 * @param request CreateModelVersionLabelsRequest
 * @return CreateModelVersionLabelsResponse
 */
async function createModelVersionLabels(ModelId: string, VersionName: string, request: CreateModelVersionLabelsRequest): CreateModelVersionLabelsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createModelVersionLabelsWithOptions(ModelId, VersionName, request, headers, runtime);
}

model CreateProductOrdersRequest {
  autoPay?: boolean(name='AutoPay', description='Specifies whether to automatically pay for the provided products.

*   true
*   false', example='true'),
  products?: [ 
    {
      autoRenew?: boolean(name='AutoRenew', description='Specifies whether to automatically renew the product.

*   true
*   false', example='true'),
      chargeType?: string(name='ChargeType', description='The billing method. Only POSTPAY is supported.', example='POSTPAY'),
      duration?: long(name='Duration', description='The purchase duration. You can use this parameter together with pricingCycle. Only 1 is supported.', example='1'),
      instanceProperties?: [ 
        {
          code?: string(name='Code', description='The property code.', example='commodity_type'),
          name?: string(name='Name', description='The property name.'),
          value?: string(name='Value', description='The property value.', example='oss'),
        }
      ](name='InstanceProperties', description='The properties of the instance.

*   DataWorks_share: [ { "Code": "region", "Value": "cn-shanghai" } ]
*   OSS_share: [ { "Code": "commodity_type", "Value": "oss", "Name": "Object Storage Service" }, { "Code": "ord_time", "Value": "1:Hour", "Name": "1 Hour" } ]
*   PAI_share: None
*   China bid MaxCompute_share: [ { "Code": "region", "Value": "cn-hangzhou" }, { "Code": "odps_specification_type", "Value": "OdpsStandard" }, { "Code": "ord_time", "Value": "1:Hour" } ]
*   International bid MaxCompute_share: [ { "Code": "region", "Value": "cn-hangzhou" }, { "Code": "ord_time", "Value": "1:Hour" } ]'),
      orderType?: string(name='OrderType', description='The type of the order. Only BUY is supported.', example='BUY'),
      pricingCycle?: string(name='PricingCycle', description='The billing cycle. Valid values:

*   Month: The price is calculated every month. DataWorks_share only supports Month.
*   Hour: The price is calculated every hour. OSS_share and MaxCompute_share only support Hour.', example='Month'),
      productCode?: string(name='ProductCode', description='The product code. Valid values:

*   DataWorks_share: pay-as-you-go DataWorks
*   MaxCompute_share: pay-as-you-go MaxCompute
*   PAI_share: pay-as-you-go PAI.
*   OSS_share: pay-as-you-go OSS', example='DataWorks_share'),
    }
  ](name='Products', description='The list of products to be purchased. Separate them with commas (,).'),
}

model CreateProductOrdersResponseBody = {
  buyProductRequestId?: string(name='BuyProductRequestId', description='The ID of the product purchase request.', example='3ed6a882-0d85-4dd8-ad36-cd8d74ab9fdb'),
  message?: string(name='Message', description='The returned message.'),
  orderId?: string(name='OrderId', description='The purchase order ID.', example='210292536260646'),
  productIds?: [ string ](name='ProductIds'),
  requestId?: string(name='RequestId', description='The request ID.', example='ksdjf-jksd-*****slkdjf'),
}

model CreateProductOrdersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateProductOrdersResponseBody(name='body'),
}

/**
 * @summary Creates a pay-as-you-go order for DataWorks, OSS, PAI, or MaxCompute.
 *
 * @param request CreateProductOrdersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProductOrdersResponse
 */
@context("createProductOrdersWithContext")
async function createProductOrdersWithOptions(request: CreateProductOrdersRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateProductOrdersResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.autoPay)) {
    body['AutoPay'] = request.autoPay;
  }
  if (!$isNull(request.products)) {
    body['Products'] = request.products;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateProductOrders',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/productorders`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a pay-as-you-go order for DataWorks, OSS, PAI, or MaxCompute.
 *
 * @param request CreateProductOrdersRequest
 * @return CreateProductOrdersResponse
 */
async function createProductOrders(request: CreateProductOrdersRequest): CreateProductOrdersResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createProductOrdersWithOptions(request, headers, runtime);
}

model CreateRunRequest {
  experimentId?: string(name='ExperimentId', description='The ID of the experiment that corresponds to the run.

This parameter is required.', example='exp-6thbb5xrbmp*****'),
  labels?: [
    Label
  ](name='Labels', description='The list of tags added to the run.'),
  name?: string(name='Name', description='The name of the run. The name must meet the following requirements:

*   The name must start with a letter.
*   The name can contain letters, digits, underscores (_), and hyphens (-).
*   The name must be 1 to 63 characters in length.

If the name is left empty when you create a run, a random run ID generated by the server is used as the name.', example='myName'),
  params?: [
    RunParam
  ](name='Params', description='The parameters of the run.'),
  sourceId?: string(name='SourceId', description='The ID of the workload associated with the run.', example='job-jdnhf***fnrimv'),
  sourceType?: string(name='SourceType', description='The type of the workload source that is associated with the run. Valid values: TrainingService and DLC. You can also leave this parameter empty. This parameter is optional and left empty by default.', example='DLC'),
}

model CreateRunResponseBody = {
  runId?: string(name='RunId', description='The run ID.', example='run-1meoz7VJd2C6f****'),
  requestId?: string(name='requestId', description='Id of the request', example='ADF6D849-*****-7E7030F0CE53'),
}

model CreateRunResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRunResponseBody(name='body'),
}

/**
 * @summary Creates a run. A run is an experiment that can be associated with a specific workload or simply a code execution.
 *
 * @param request CreateRunRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRunResponse
 */
@context("createRunWithContext")
async function createRunWithOptions(request: CreateRunRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateRunResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.experimentId)) {
    body['ExperimentId'] = request.experimentId;
  }
  if (!$isNull(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!$isNull(request.name)) {
    body['Name'] = request.name;
  }
  if (!$isNull(request.params)) {
    body['Params'] = request.params;
  }
  if (!$isNull(request.sourceId)) {
    body['SourceId'] = request.sourceId;
  }
  if (!$isNull(request.sourceType)) {
    body['SourceType'] = request.sourceType;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateRun',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/runs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a run. A run is an experiment that can be associated with a specific workload or simply a code execution.
 *
 * @param request CreateRunRequest
 * @return CreateRunResponse
 */
async function createRun(request: CreateRunRequest): CreateRunResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createRunWithOptions(request, headers, runtime);
}

model CreateWorkspaceRequest {
  description?: string(name='Description', description='The description of the workspace. The description can be up to 80 characters in length.

This parameter is required.', example='description'),
  displayName?: string(name='DisplayName', description='The display name of the workspace. You can set it based on the purpose of the workspace. If left empty, the name of the workspace is used.', example='display name'),
  envTypes?: [ string ](name='EnvTypes', description='The environment of the workspace.

*   Workspaces in basic mode can run only in the production environment (prod).
*   Workspaces in standard mode can run in both the development and production environments (dev and prod).

This parameter is required.'),
  resourceGroupId?: string(name='ResourceGroupId'),
  workspaceName?: string(name='WorkspaceName', description='The name of the workspace. Format:

*   The name must be 3 to 23 characters in length, and can contain letters, underscores (_), and digits.
*   The name must start with a letter.
*   It must be unique in the current region.

This parameter is required.', example='workspace_example'),
}

model CreateWorkspaceResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='1e195c5116124202371861018d5bde'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='1234'),
}

model CreateWorkspaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateWorkspaceResponseBody(name='body'),
}

/**
 * @summary Creates a workspace.
 *
 * @param request CreateWorkspaceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateWorkspaceResponse
 */
@context("createWorkspaceWithContext")
async function createWorkspaceWithOptions(request: CreateWorkspaceRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateWorkspaceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.displayName)) {
    body['DisplayName'] = request.displayName;
  }
  if (!$isNull(request.envTypes)) {
    body['EnvTypes'] = request.envTypes;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.workspaceName)) {
    body['WorkspaceName'] = request.workspaceName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateWorkspace',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a workspace.
 *
 * @param request CreateWorkspaceRequest
 * @return CreateWorkspaceResponse
 */
async function createWorkspace(request: CreateWorkspaceRequest): CreateWorkspaceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createWorkspaceWithOptions(request, headers, runtime);
}

model CreateWorkspaceResourceRequest {
  option?: string(name='Option', description='The operation to perform. Valid values:

*   CreateAndAttach: creates resources and associates the resources with a workspace.
*   Attach: associates resources with a workspace.

>  MaxCompute supports only the Attach operation.', example='CreateAndAttach'),
  resources?: [ 
    {
      envType?: string(name='EnvType', description='The environment type. Valid values:

*   dev: development environment
*   prod: production environment

This parameter is required.', example='prod'),
      groupName?: string(name='GroupName', description='The name of the resource group, which is unique within your Alibaba Cloud account. This parameter is required for MaxCompute, Elastic Compute Service (ECS), Lingjun, Alibaba Cloud Container Compute Service (ACS), and Realtime Compute for Apache Flink resources.', example='groupName'),
      isDefault?: boolean(name='IsDefault', description='Specifies whether the resource is the default resource. Each type of resources has a default resource. Valid values:

*   false (default)
*   true', example='false'),
      labels?: [ 
        {
          key?: string(name='Key', description='The label key.', example='system.support.eas'),
          value?: string(name='Value', description='The label value.', example='true'),
        }
      ](name='Labels', description='The labels added to the resource.'),
      name?: string(name='Name', description='The resource name. The name must meet the following requirements:

*   The name must be 3 to 28 characters in length, and can contain only letters, digits, and underscores (_). The name must start with a letter.
*   The name must be unique in the region.

This parameter is required.', example='ResourceName'),
      productType?: string(name='ProductType', description='**This parameter is no longer used and will be removed. Use the ResourceType parameter instead.', example='MaxCompute'),
      quotas?: [ 
        {
          id?: string(name='Id', description='The quota ID. You can call [ListQuotas](https://help.aliyun.com/document_detail/449144.html) to obtain the quota ID.

This parameter is required.', example='232892******92912'),
        }
      ](name='Quotas', description='The quotas. Only MaxCompute quotas are available.'),
      resourceType?: string(name='ResourceType', description='The resource types. Valid values:

*   MaxCompute
*   ECS
*   Lingjun
*   ACS
*   FLINK', example='MaxCompute'),
      spec?: map[string]any(name='Spec', description='The resource specifications in the JSON format.'),
      workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.

This parameter is required.', example='123'),
    }
  ](name='Resources', description='The resources.

This parameter is required.'),
}

model CreateWorkspaceResourceResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='1e195c5116124202371861018d5bde'),
  resources?: [ 
    {
      id?: string(name='Id', description='The resource ID.', example='1234'),
    }
  ](name='Resources', description='The resources.'),
  totalCount?: long(name='TotalCount', description='The total number of resources.', example='1'),
}

model CreateWorkspaceResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateWorkspaceResourceResponseBody(name='body'),
}

/**
 * @summary Associates resources with a workspace.
 *
 * @param request CreateWorkspaceResourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateWorkspaceResourceResponse
 */
@context("createWorkspaceResourceWithContext")
async function createWorkspaceResourceWithOptions(WorkspaceId: string, request: CreateWorkspaceResourceRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateWorkspaceResourceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.option)) {
    body['Option'] = request.option;
  }
  if (!$isNull(request.resources)) {
    body['Resources'] = request.resources;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateWorkspaceResource',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}/resources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Associates resources with a workspace.
 *
 * @param request CreateWorkspaceResourceRequest
 * @return CreateWorkspaceResourceResponse
 */
async function createWorkspaceResource(WorkspaceId: string, request: CreateWorkspaceResourceRequest): CreateWorkspaceResourceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createWorkspaceResourceWithOptions(WorkspaceId, request, headers, runtime);
}

model DeleteCodeSourceResponseBody = {
  codeSourceId?: string(name='CodeSourceId', description='The ID of the deleted code source.', example='code-20210111103721-85qz78ia96lu'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model DeleteCodeSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCodeSourceResponseBody(name='body'),
}

/**
 * @summary Deletes a code source based on the provided ID.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCodeSourceResponse
 */
@context("deleteCodeSourceWithContext")
async function deleteCodeSourceWithOptions(CodeSourceId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteCodeSourceResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteCodeSource',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/codesources/${$URL.percentEncode(CodeSourceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a code source based on the provided ID.
 *
 * @return DeleteCodeSourceResponse
 */
async function deleteCodeSource(CodeSourceId: string): DeleteCodeSourceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteCodeSourceWithOptions(CodeSourceId, headers, runtime);
}

model DeleteConfigRequest {
  categoryName?: string(name='CategoryName', description='The category of the configuration item. Valid values:

*   CommonResourceConfig
*   DLCAutoRecycle - DLCPriorityConfig
*   DSWPriorityConfig
*   QuotaMaximumDuration
*   CommonTagConfig', example='CommonResourceConfig'),
  labels?: string(name='Labels', description='The filter conditions. Separate multiple conditions with commas (,). The conditions have an AND relationship.', example='key1=value;key2=value2'),
}

model DeleteConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A******C83E'),
}

model DeleteConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteConfigResponseBody(name='body'),
}

/**
 * @summary Deletes workspace configurations.
 *
 * @param request DeleteConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConfigResponse
 */
@context("deleteConfigWithContext")
async function deleteConfigWithOptions(WorkspaceId: string, ConfigKey: string, request: DeleteConfigRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteConfigResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.categoryName)) {
    query['CategoryName'] = request.categoryName;
  }
  if (!$isNull(request.labels)) {
    query['Labels'] = request.labels;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteConfig',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}/configs/${$URL.percentEncode(ConfigKey)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes workspace configurations.
 *
 * @param request DeleteConfigRequest
 * @return DeleteConfigResponse
 */
async function deleteConfig(WorkspaceId: string, ConfigKey: string, request: DeleteConfigRequest): DeleteConfigResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConfigWithOptions(WorkspaceId, ConfigKey, request, headers, runtime);
}

model DeleteConnectionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model DeleteConnectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteConnectionResponseBody(name='body'),
}

/**
 * @summary Deletes a connection.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConnectionResponse
 */
@context("deleteConnectionWithContext")
async function deleteConnectionWithOptions(ConnectionId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteConnectionResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteConnection',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/connections/${$URL.percentEncode(ConnectionId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a connection.
 *
 * @return DeleteConnectionResponse
 */
async function deleteConnection(ConnectionId: string): DeleteConnectionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConnectionWithOptions(ConnectionId, headers, runtime);
}

model DeleteDatasetResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A0F049F0-8D69-5BAC-8F10-B******A34C'),
}

model DeleteDatasetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDatasetResponseBody(name='body'),
}

/**
 * @summary Deletes a dataset.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDatasetResponse
 */
@context("deleteDatasetWithContext")
async function deleteDatasetWithOptions(DatasetId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteDatasetResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteDataset',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a dataset.
 *
 * @return DeleteDatasetResponse
 */
async function deleteDataset(DatasetId: string): DeleteDatasetResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDatasetWithOptions(DatasetId, headers, runtime);
}

model DeleteDatasetFileMetasRequest {
  datasetFileMetaIds?: string(name='DatasetFileMetaIds', description='The metadata ID of the dataset file.

This parameter is required.', example='07914c9534586e4e7aa6e9dbca5009082df******fd8a0d857b33296c59bf6'),
  datasetVersion?: string(name='DatasetVersion', description='The dataset version.', example='v1'),
  workspaceId?: string(name='WorkspaceId', description='The ID of the workspace to which the dataset belongs. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='132602'),
}

model DeleteDatasetFileMetasResponseBody = {
  failedDetails?: [
    DatasetFileMetaResponse
  ](name='FailedDetails', description='The metadata records that fail to be deleted for the dataset files.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  status?: boolean(name='Status', description='Indicates whether the metadata records of all dataset files were deleted. The value true indicates that the metadata records of all dataset files are deleted. If the value is false, view the failure details specified by FailedDetails.', example='true'),
}

model DeleteDatasetFileMetasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDatasetFileMetasResponseBody(name='body'),
}

/**
 * @summary Deletes the metadata records of multiple files in a dataset at a time.
 *
 * @param request DeleteDatasetFileMetasRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDatasetFileMetasResponse
 */
@context("deleteDatasetFileMetasWithContext")
async function deleteDatasetFileMetasWithOptions(DatasetId: string, request: DeleteDatasetFileMetasRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteDatasetFileMetasResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.datasetFileMetaIds)) {
    query['DatasetFileMetaIds'] = request.datasetFileMetaIds;
  }
  if (!$isNull(request.datasetVersion)) {
    query['DatasetVersion'] = request.datasetVersion;
  }
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteDatasetFileMetas',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/datasetfilemetas`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes the metadata records of multiple files in a dataset at a time.
 *
 * @param request DeleteDatasetFileMetasRequest
 * @return DeleteDatasetFileMetasResponse
 */
async function deleteDatasetFileMetas(DatasetId: string, request: DeleteDatasetFileMetasRequest): DeleteDatasetFileMetasResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDatasetFileMetasWithOptions(DatasetId, request, headers, runtime);
}

model DeleteDatasetJobResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model DeleteDatasetJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDatasetJobResponseBody(name='body'),
}

/**
 * @summary Deletes a dataset job.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDatasetJobResponse
 */
@context("deleteDatasetJobWithContext")
async function deleteDatasetJobWithOptions(DatasetId: string, DatasetJobId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteDatasetJobResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteDatasetJob',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/datasetjobs/${$URL.percentEncode(DatasetJobId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a dataset job.
 *
 * @return DeleteDatasetJobResponse
 */
async function deleteDatasetJob(DatasetId: string, DatasetJobId: string): DeleteDatasetJobResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDatasetJobWithOptions(DatasetId, DatasetJobId, headers, runtime);
}

model DeleteDatasetJobConfigRequest {
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='513663'),
}

model DeleteDatasetJobConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='DA869D1B-035A-43B2-ACC1-C56681BD9FAA'),
}

model DeleteDatasetJobConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDatasetJobConfigResponseBody(name='body'),
}

/**
 * @summary Deletes a job configuration for a dataset.
 *
 * @param request DeleteDatasetJobConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDatasetJobConfigResponse
 */
@context("deleteDatasetJobConfigWithContext")
async function deleteDatasetJobConfigWithOptions(DatasetId: string, DatasetJobConfigId: string, request: DeleteDatasetJobConfigRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteDatasetJobConfigResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteDatasetJobConfig',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/datasetjobconfigs/${$URL.percentEncode(DatasetJobConfigId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a job configuration for a dataset.
 *
 * @param request DeleteDatasetJobConfigRequest
 * @return DeleteDatasetJobConfigResponse
 */
async function deleteDatasetJobConfig(DatasetId: string, DatasetJobConfigId: string, request: DeleteDatasetJobConfigRequest): DeleteDatasetJobConfigResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDatasetJobConfigWithOptions(DatasetId, DatasetJobConfigId, request, headers, runtime);
}

model DeleteDatasetLabelsRequest {
  labelKeys?: string(name='LabelKeys', description='The tag key. You can call [GetDataset](https://help.aliyun.com/document_detail/457218.html) to obtain the tag key. Multiple tag keys are separated by commas (,).', example='key1,key2'),
}

model DeleteDatasetLabelsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='64B50C1D-D4C2-560C-86A3-A6ED****16D'),
}

model DeleteDatasetLabelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDatasetLabelsResponseBody(name='body'),
}

/**
 * @summary Deletes a dataset tag.
 *
 * @param request DeleteDatasetLabelsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDatasetLabelsResponse
 */
@context("deleteDatasetLabelsWithContext")
async function deleteDatasetLabelsWithOptions(DatasetId: string, request: DeleteDatasetLabelsRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteDatasetLabelsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.labelKeys)) {
    query['LabelKeys'] = request.labelKeys;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteDatasetLabels',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/labels`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a dataset tag.
 *
 * @param request DeleteDatasetLabelsRequest
 * @return DeleteDatasetLabelsResponse
 */
async function deleteDatasetLabels(DatasetId: string, request: DeleteDatasetLabelsRequest): DeleteDatasetLabelsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDatasetLabelsWithOptions(DatasetId, request, headers, runtime);
}

model DeleteDatasetVersionResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteDatasetVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDatasetVersionResponseBody(name='body'),
}

/**
 * @summary Deletes the information about a specified version of a dataset. Version v1 cannot be deleted by using this operation. When you call the DeleteDataset operation to delete a dataset, it can be deleted at the same time.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDatasetVersionResponse
 */
@context("deleteDatasetVersionWithContext")
async function deleteDatasetVersionWithOptions(DatasetId: string, VersionName: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteDatasetVersionResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteDatasetVersion',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/versions/${$URL.percentEncode(VersionName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes the information about a specified version of a dataset. Version v1 cannot be deleted by using this operation. When you call the DeleteDataset operation to delete a dataset, it can be deleted at the same time.
 *
 * @return DeleteDatasetVersionResponse
 */
async function deleteDatasetVersion(DatasetId: string, VersionName: string): DeleteDatasetVersionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDatasetVersionWithOptions(DatasetId, VersionName, headers, runtime);
}

model DeleteDatasetVersionLabelsRequest {
  keys?: string(name='Keys', description='The tag keys. Multiple tags are separated by commas (,).

This parameter is required.', example='key1,key2'),
}

model DeleteDatasetVersionLabelsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteDatasetVersionLabelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDatasetVersionLabelsResponseBody(name='body'),
}

/**
 * @summary Deletes tags for a dataset version.
 *
 * @param request DeleteDatasetVersionLabelsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDatasetVersionLabelsResponse
 */
@context("deleteDatasetVersionLabelsWithContext")
async function deleteDatasetVersionLabelsWithOptions(DatasetId: string, VersionName: string, request: DeleteDatasetVersionLabelsRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteDatasetVersionLabelsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.keys)) {
    query['Keys'] = request.keys;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteDatasetVersionLabels',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/versions/${$URL.percentEncode(VersionName)}/labels`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes tags for a dataset version.
 *
 * @param request DeleteDatasetVersionLabelsRequest
 * @return DeleteDatasetVersionLabelsResponse
 */
async function deleteDatasetVersionLabels(DatasetId: string, VersionName: string, request: DeleteDatasetVersionLabelsRequest): DeleteDatasetVersionLabelsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDatasetVersionLabelsWithOptions(DatasetId, VersionName, request, headers, runtime);
}

model DeleteExperimentResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='8D7B2E70-F770-505B-A672-09F1D8F2EC1E'),
}

model DeleteExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteExperimentResponseBody(name='body'),
}

/**
 * @summary Deletes an experiment.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteExperimentResponse
 */
@context("deleteExperimentWithContext")
async function deleteExperimentWithOptions(ExperimentId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteExperimentResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteExperiment',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${$URL.percentEncode(ExperimentId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an experiment.
 *
 * @return DeleteExperimentResponse
 */
async function deleteExperiment(ExperimentId: string): DeleteExperimentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteExperimentWithOptions(ExperimentId, headers, runtime);
}

model DeleteExperimentLabelResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model DeleteExperimentLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteExperimentLabelResponseBody(name='body'),
}

/**
 * @summary Deletes an experiment tag.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteExperimentLabelResponse
 */
@context("deleteExperimentLabelWithContext")
async function deleteExperimentLabelWithOptions(ExperimentId: string, Key: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteExperimentLabelResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteExperimentLabel',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${$URL.percentEncode(ExperimentId)}/labels/${$URL.percentEncode(Key)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an experiment tag.
 *
 * @return DeleteExperimentLabelResponse
 */
async function deleteExperimentLabel(ExperimentId: string, Key: string): DeleteExperimentLabelResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteExperimentLabelWithOptions(ExperimentId, Key, headers, runtime);
}

model DeleteMembersRequest {
  memberIds?: string(name='MemberIds', description='The list of member IDs. Separate multiple member IDs with commas (,). You can call [ListMembers](https://help.aliyun.com/document_detail/449135.html) to obtain the member ID.

This parameter is required.', example='145883-21513926******88039,145883-2769726******87513'),
}

model DeleteMembersResponseBody = {
  code?: string(name='Code', description='The error code returned if the call failed.', example='100600017'),
  message?: string(name='Message', description='The error message returned if the call failed.', example='Owner not allowed to delete'),
  requestId?: string(name='RequestId', description='The request ID.', example='D5BFFEE3-6025-443F-8A03-02D619B5C4B9'),
}

model DeleteMembersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMembersResponseBody(name='body'),
}

/**
 * @summary Deletes a member from a workspace.
 *
 * @param request DeleteMembersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMembersResponse
 */
@context("deleteMembersWithContext")
async function deleteMembersWithOptions(WorkspaceId: string, request: DeleteMembersRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteMembersResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.memberIds)) {
    query['MemberIds'] = request.memberIds;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteMembers',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}/members`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a member from a workspace.
 *
 * @param request DeleteMembersRequest
 * @return DeleteMembersResponse
 */
async function deleteMembers(WorkspaceId: string, request: DeleteMembersRequest): DeleteMembersResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMembersWithOptions(WorkspaceId, request, headers, runtime);
}

model DeleteModelResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model DeleteModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteModelResponseBody(name='body'),
}

/**
 * @summary Deletes a model.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteModelResponse
 */
@context("deleteModelWithContext")
async function deleteModelWithOptions(ModelId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteModelResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteModel',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/models/${$URL.percentEncode(ModelId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a model.
 *
 * @return DeleteModelResponse
 */
async function deleteModel(ModelId: string): DeleteModelResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteModelWithOptions(ModelId, headers, runtime);
}

model DeleteModelLabelsRequest {
  labelKeys?: string(name='LabelKeys', description='The label key to be deleted. To delete multiple label keys, separate them with commas (,).', example='key1,key2'),
}

model DeleteModelLabelsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model DeleteModelLabelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteModelLabelsResponseBody(name='body'),
}

/**
 * @summary Deletes the labels of a model.
 *
 * @param request DeleteModelLabelsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteModelLabelsResponse
 */
@context("deleteModelLabelsWithContext")
async function deleteModelLabelsWithOptions(ModelId: string, request: DeleteModelLabelsRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteModelLabelsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.labelKeys)) {
    query['LabelKeys'] = request.labelKeys;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteModelLabels',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/models/${$URL.percentEncode(ModelId)}/labels`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes the labels of a model.
 *
 * @param request DeleteModelLabelsRequest
 * @return DeleteModelLabelsResponse
 */
async function deleteModelLabels(ModelId: string, request: DeleteModelLabelsRequest): DeleteModelLabelsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteModelLabelsWithOptions(ModelId, request, headers, runtime);
}

model DeleteModelVersionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model DeleteModelVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteModelVersionResponseBody(name='body'),
}

/**
 * @summary Deletes a model version.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteModelVersionResponse
 */
@context("deleteModelVersionWithContext")
async function deleteModelVersionWithOptions(ModelId: string, VersionName: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteModelVersionResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteModelVersion',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/models/${$URL.percentEncode(ModelId)}/versions/${$URL.percentEncode(VersionName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a model version.
 *
 * @return DeleteModelVersionResponse
 */
async function deleteModelVersion(ModelId: string, VersionName: string): DeleteModelVersionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteModelVersionWithOptions(ModelId, VersionName, headers, runtime);
}

model DeleteModelVersionLabelsRequest {
  labelKeys?: string(name='LabelKeys', description='The key of the tag to be deleted. Separate multiple tag keys with commas (,).', example='key1,key2'),
}

model DeleteModelVersionLabelsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model DeleteModelVersionLabelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteModelVersionLabelsResponseBody(name='body'),
}

/**
 * @summary Delete a model version tag.
 *
 * @param request DeleteModelVersionLabelsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteModelVersionLabelsResponse
 */
@context("deleteModelVersionLabelsWithContext")
async function deleteModelVersionLabelsWithOptions(ModelId: string, VersionName: string, request: DeleteModelVersionLabelsRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteModelVersionLabelsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.labelKeys)) {
    query['LabelKeys'] = request.labelKeys;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteModelVersionLabels',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/models/${$URL.percentEncode(ModelId)}/versions/${$URL.percentEncode(VersionName)}/labels`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete a model version tag.
 *
 * @param request DeleteModelVersionLabelsRequest
 * @return DeleteModelVersionLabelsResponse
 */
async function deleteModelVersionLabels(ModelId: string, VersionName: string, request: DeleteModelVersionLabelsRequest): DeleteModelVersionLabelsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteModelVersionLabelsWithOptions(ModelId, VersionName, request, headers, runtime);
}

model DeleteRunResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='ADF6D849-*****-7E7030F0CE53'),
}

model DeleteRunResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRunResponseBody(name='body'),
}

/**
 * @summary Deletes a run.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRunResponse
 */
@context("deleteRunWithContext")
async function deleteRunWithOptions(RunId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteRunResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteRun',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/runs/${$URL.percentEncode(RunId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a run.
 *
 * @return DeleteRunResponse
 */
async function deleteRun(RunId: string): DeleteRunResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRunWithOptions(RunId, headers, runtime);
}

model DeleteRunLabelResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ADF6D849-*****-7E7030F0CE53'),
}

model DeleteRunLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRunLabelResponseBody(name='body'),
}

/**
 * @summary Deletes a tag that is added to a run.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRunLabelResponse
 */
@context("deleteRunLabelWithContext")
async function deleteRunLabelWithOptions(RunId: string, Key: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteRunLabelResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteRunLabel',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/runs/${$URL.percentEncode(RunId)}/labels/${$URL.percentEncode(Key)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a tag that is added to a run.
 *
 * @return DeleteRunLabelResponse
 */
async function deleteRunLabel(RunId: string, Key: string): DeleteRunLabelResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRunLabelWithOptions(RunId, Key, headers, runtime);
}

model DeleteUserConfigRequest {
  configKey?: string(name='ConfigKey', description='The configuration item keys. Currently, only customizePAIAssumedRole.', example='tempStoragePath'),
  scope?: string(name='Scope', description='The scope. Valid values: subUser and owner.', example='subUser'),
}

model DeleteUserConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='dsjk****dfjksdf'),
}

model DeleteUserConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteUserConfigResponseBody(name='body'),
}

/**
 * @summary Deletes user configurations.
 *
 * @param request DeleteUserConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteUserConfigResponse
 */
@context("deleteUserConfigWithContext")
async function deleteUserConfigWithOptions(CategoryName: string, request: DeleteUserConfigRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteUserConfigResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.configKey)) {
    query['ConfigKey'] = request.configKey;
  }
  if (!$isNull(request.scope)) {
    query['Scope'] = request.scope;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteUserConfig',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/userconfigs/${$URL.percentEncode(CategoryName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes user configurations.
 *
 * @param request DeleteUserConfigRequest
 * @return DeleteUserConfigResponse
 */
async function deleteUserConfig(CategoryName: string, request: DeleteUserConfigRequest): DeleteUserConfigResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteUserConfigWithOptions(CategoryName, request, headers, runtime);
}

model DeleteWorkspaceResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model DeleteWorkspaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteWorkspaceResponseBody(name='body'),
}

/**
 * @summary Deletes a workspace. After you delete a workspace, the associated resources are not automatically released. You must manually release the resources.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteWorkspaceResponse
 */
@context("deleteWorkspaceWithContext")
async function deleteWorkspaceWithOptions(WorkspaceId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteWorkspaceResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteWorkspace',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a workspace. After you delete a workspace, the associated resources are not automatically released. You must manually release the resources.
 *
 * @return DeleteWorkspaceResponse
 */
async function deleteWorkspace(WorkspaceId: string): DeleteWorkspaceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteWorkspaceWithOptions(WorkspaceId, headers, runtime);
}

model DeleteWorkspaceResourceRequest {
  groupName?: string(name='GroupName', description='The name of the resource group. You can call [ListResources](https://help.aliyun.com/document_detail/449143.html) to obtain the name of the resource group.', example='group'),
  labels?: string(name='Labels', description='The tags. Multiple tags are separated by commas (,).', example='system.supported.eas=true'),
  option?: string(name='Option', description='The operation to perform. Valid values:

*   DetachAndDelete: disassociates a resource from a workspace and deletes the resource in the workspace. This is the default value.
*   Detach: disassociates a resource group from a workspace.', example='DetachAndDelete'),
  productType?: string(name='ProductType', description='**This field is no longer used and will be removed. Use the ResourceType field instead.', example='DLC'),
  resourceIds?: string(name='ResourceIds', description='The resource IDs. Multiple resource IDs are separated by commas (,). The GroupName values for the specified resources must be the same. You cannot leave both GroupName and ResourceIds empty. You can specify both parameters.', example='Resource-dks******jkf,Resource-adf******dss'),
  resourceType?: string(name='ResourceType', description='The resource type. Valid values:

*   ECS
*   Lingjun
*   ACS
*   FLINK
*   MaxCompute (This resource type is valid only if Option is set to Detach.)', example='DLC'),
}

model DeleteWorkspaceResourceResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  resourceIds?: [ string ](name='ResourceIds', description='The resource IDs.'),
}

model DeleteWorkspaceResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteWorkspaceResourceResponseBody(name='body'),
}

/**
 * @summary Deletes a resource from a workspace. The resource is not deleted at the underlying layer.
 *
 * @param request DeleteWorkspaceResourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteWorkspaceResourceResponse
 */
@context("deleteWorkspaceResourceWithContext")
async function deleteWorkspaceResourceWithOptions(WorkspaceId: string, request: DeleteWorkspaceResourceRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteWorkspaceResourceResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!$isNull(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!$isNull(request.option)) {
    query['Option'] = request.option;
  }
  if (!$isNull(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!$isNull(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteWorkspaceResource',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}/resources`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a resource from a workspace. The resource is not deleted at the underlying layer.
 *
 * @param request DeleteWorkspaceResourceRequest
 * @return DeleteWorkspaceResourceResponse
 */
async function deleteWorkspaceResource(WorkspaceId: string, request: DeleteWorkspaceResourceRequest): DeleteWorkspaceResourceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteWorkspaceResourceWithOptions(WorkspaceId, request, headers, runtime);
}

model GetCodeSourceResponseBody = {
  accessibility?: string(name='Accessibility', description='The visibility of the code source. Valid values:

*   PRIVATE: Visible only to you and the administrator of the workspace.
*   PUBLIC: Visible to all members in the workspace.', example='PRIVATE'),
  codeBranch?: string(name='CodeBranch', description='The code repository branch.', example='master'),
  codeCommit?: string(name='CodeCommit', description='The code commit ID.', example='44da10***********'),
  codeRepo?: string(name='CodeRepo', description='The address of the code repository.', example='https://code.aliyun.com/pai-dlc/examples.git'),
  codeRepoAccessToken?: string(name='CodeRepoAccessToken', description='The token used to access the code repository.', example='xxxx'),
  codeRepoUserName?: string(name='CodeRepoUserName', description='The username of the code repository.', example='user1'),
  codeSourceId?: string(name='CodeSourceId', description='The ID of the code source.', example='code-202**********'),
  description?: string(name='Description', description='The description of the code source.', example='This is my data source 1.'),
  displayName?: string(name='DisplayName', description='The name of the code source.', example='MyCodeSource1'),
  gmtCreateTime?: string(name='GmtCreateTime', description='The time when the code source was created, in the ISO8601 format.', example='2021-01-12T23:36:01.123Z'),
  gmtModifyTime?: string(name='GmtModifyTime', description='The time when the code source was modified, in the ISO8601 format.', example='2021-01-12T23:36:01.123Z'),
  mountPath?: string(name='MountPath', description='The local mount path of the code.', example='/root/code'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  userId?: string(name='UserId', description='The ID of the creator.', example='1722********'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='1234'),
}

model GetCodeSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCodeSourceResponseBody(name='body'),
}

/**
 * @summary Obtains the details of a code source.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCodeSourceResponse
 */
@context("getCodeSourceWithContext")
async function getCodeSourceWithOptions(CodeSourceId: string, headers: map[string]string, runtime: $RuntimeOptions): GetCodeSourceResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetCodeSource',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/codesources/${$URL.percentEncode(CodeSourceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the details of a code source.
 *
 * @return GetCodeSourceResponse
 */
async function getCodeSource(CodeSourceId: string): GetCodeSourceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getCodeSourceWithOptions(CodeSourceId, headers, runtime);
}

model GetConfigRequest {
  categoryName?: string(name='CategoryName', description='The category of the configuration item. Valid values:

*   CommonResourceConfig
*   DLCAutoRecycle
*   DLCPriorityConfig
*   DSWPriorityConfig
*   QuotaMaximumDuration
*   CommonTagConfig', example='CommonResourceConfig'),
  configKey?: string(name='ConfigKey', description='The key of the configuration item. Valid values:

*   tempStoragePath: Temporary storage path. This key can be used only when CategoryName is set to CommonResourceConfig.
*   isAutoRecycle: Automatic recycle configuration. This key can be used only when CategoryName is set to DLCAutoRecycle.
*   priorityConfig: Priority configuration. This key can be used only when CategoryName is set to DLCPriorityConfig or DSWPriorityConfig.
*   quotaMaximumDuration: Maximum run time of DLC jobs for a quota. This key can be used only when CategoryName is set to QuotaMaximumDuration.
*   predefinedTags: Predefined tags of the workspace. Created resources must include tags.', example='tempStoragePath'),
  verbose?: string(name='Verbose', description='The value of the configuration item.', example='oss://***'),
}

model GetConfigResponseBody = {
  categoryName?: string(name='CategoryName', description='The category of the configuration item. Valid values:

*   CommonResourceConfig
*   DLCAutoRecycle
*   DLCPriorityConfig
*   DSWPriorityConfig
*   QuotaMaximumDuration
*   CommonTagConfig', example='CommonResourceConfig'),
  configKey?: string(name='ConfigKey', description='The key of the configuration item. Valid values:

*   tempStoragePath: Temporary storage path. This key can be used only when CategoryName is set to CommonResourceConfig.
*   isAutoRecycle: Automatic recycle configuration. This key can be used only when CategoryName is set to DLCAutoRecycle.
*   priorityConfig: Priority configuration. This key can be used only when CategoryName is set to DLCPriorityConfig or DSWPriorityConfig.
*   quotaMaximumDuration: Maximum run time of DLC jobs for a quota. This key can be used only when CategoryName is set to QuotaMaximumDuration.
*   predefinedTags: Predefined tags of the workspace. Created resources must include tags.', example='tempStoragePath'),
  configValue?: string(name='ConfigValue', description='The value of the configuration item.', example='oss://***'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  labels?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='key1'),
      value?: string(name='Value', description='The tag value.', example='value1'),
    }
  ](name='Labels', description='The tags of the configuration item.'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A******C83E'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='1234******2'),
}

model GetConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetConfigResponseBody(name='body'),
}

/**
 * @summary Obtains a workspace configuration item.
 *
 * @param request GetConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetConfigResponse
 */
@context("getConfigWithContext")
async function getConfigWithOptions(WorkspaceId: string, request: GetConfigRequest, headers: map[string]string, runtime: $RuntimeOptions): GetConfigResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.categoryName)) {
    query['CategoryName'] = request.categoryName;
  }
  if (!$isNull(request.configKey)) {
    query['ConfigKey'] = request.configKey;
  }
  if (!$isNull(request.verbose)) {
    query['Verbose'] = request.verbose;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetConfig',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}/config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a workspace configuration item.
 *
 * @param request GetConfigRequest
 * @return GetConfigResponse
 */
async function getConfig(WorkspaceId: string, request: GetConfigRequest): GetConfigResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getConfigWithOptions(WorkspaceId, request, headers, runtime);
}

model GetConnectionRequest {
  encryptOption?: string(name='EncryptOption', description='The encryption settings. Valid values:

*   PlainText
*   Secret', example='PlainText'),
}

model GetConnectionResponseBody = {
  accessibility?: string(name='Accessibility', description='The resource accessibility. Valid values:

*   PUBLIC: All members in the workspace can access the workspace.
*   PRIVATE: Only the creator can access the workspace.', example='PRIVATE'),
  configs?: map[string]string(name='Configs', description='The connection configuration.'),
  connectionId?: string(name='ConnectionId', description='The connection ID.', example='conn-pai9m***mi47'),
  connectionName?: string(name='ConnectionName', description='The connection name.'),
  connectionType?: string(name='ConnectionType', description='The type of the connection. Valid values:

*   DashScopeConnection: Alibaba Cloud Model Studio connection.
*   OpenLLMConnection: Open source model connection.
*   MilvusConnection: Milvus connection.
*   OpenSearchConnection: OpenSearch connection.
*   LindormConnection: Lindorm connection.
*   ElasticsearchConnection: Elasticsearch connection.
*   HologresConnection: Hologres connection.
*   RDSConnection: RDS connection.
*   CustomConnection: Custom connection.', example='OpenSearchConnection'),
  creator?: string(name='Creator', description='The creator of the connection.', example='28632***898231'),
  description?: string(name='Description', description='The connection description.'),
  gmtCreateTime?: string(name='GmtCreateTime', description='The time when the connection is created, in UTC. The time follows the ISO 8601 standard.', example='2025-03-07T07:54:56Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', description='The time when the connection is modified, in UTC. The time follows the ISO 8601 standard.', example='2025-03-07T07:54:56Z'),
  models?: [ 
    {
      displayName?: string(name='DisplayName', description='The display name of the model.'),
      model?: string(name='Model', description='The model identifier.', example='model_001'),
      modelType?: string(name='ModelType', description='The model type. Valid values:

*   LLM
*   Embedding
*   ReRank', example='LLM'),
      toolCall?: boolean(name='ToolCall', description='Indicates whether a tool can be called by using ToolCall. Valid values:

*   true
*   false', example='true'),
    }
  ](name='Models', description='The models, which apply to model service connections.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  resourceMeta?: {
    extra?: string(name='Extra'),
    instanceId?: string(name='InstanceId', description='The instance ID.', example='ld-2vc1***v1zaqgzol'),
    instanceName?: string(name='InstanceName', description='The instance name.'),
  }(name='ResourceMeta', description='The instance resource information of the connection, which applies to database connections.'),
  secrets?: map[string]string(name='Secrets', description='The encrypted configuration, in key-value pairs. Examples: the database logon password and the key of the model connection.'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='11**43'),
}

model GetConnectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetConnectionResponseBody(name='body'),
}

/**
 * @summary Obtains the connection details.
 *
 * @param request GetConnectionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetConnectionResponse
 */
@context("getConnectionWithContext")
async function getConnectionWithOptions(ConnectionId: string, request: GetConnectionRequest, headers: map[string]string, runtime: $RuntimeOptions): GetConnectionResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.encryptOption)) {
    query['EncryptOption'] = request.encryptOption;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetConnection',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/connections/${$URL.percentEncode(ConnectionId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the connection details.
 *
 * @param request GetConnectionRequest
 * @return GetConnectionResponse
 */
async function getConnection(ConnectionId: string, request: GetConnectionRequest): GetConnectionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getConnectionWithOptions(ConnectionId, request, headers, runtime);
}

model GetDatasetResponseBody = {
  accessibility?: string(name='Accessibility', description='The visibility of the workspace. Valid values:

*   PRIVATE: The workspace is visible only to you and the administrator of the workspace.
*   PUBLIC: The workspace is visible to all users.', example='PRIVATE'),
  dataSourceType?: string(name='DataSourceType', description='The type of the data source. Valid values:

*   OSS: Object Storage Service (OSS)
*   NAS: File Storage NAS (NAS)', example='NAS'),
  dataType?: string(name='DataType', description='The data type. Valid values:

*   COMMON: common
*   PIC: picture
*   TEXT: text
*   VIDEO: video
*   AUDIO: audio', example='COMMON'),
  datasetId?: string(name='DatasetId', description='The dataset ID.', example='d-rbvg5wz****c9ks92'),
  description?: string(name='Description', description='The description.'),
  edition?: string(name='Edition'),
  gmtCreateTime?: string(name='GmtCreateTime', description='The creation time.', example='2021-01-30T12:51:33.028Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', description='The update time.', example='2021-01-30T12:51:33.028Z'),
  importInfo?: string(name='ImportInfo', description='The dataset configurations to be imported to a storage, such as OSS, NAS, or CPFS.

**OSS**

{\\\\
"region": "${region}",// The region ID\\\\
"bucket": "${bucket}",// The bucket name\\\\
"path": "${path}" // The file path\\\\
}\\\\


**NAS**

{\\\\
"region": "${region}",// The region ID\\\\
"fileSystemId": "${file_system_id}", // The file system ID\\\\
"path": "${path}", // The file system path\\\\
"mountTarget": "${mount_target}" // The mount point of the file system\\\\
}\\\\


**CPFS**

{\\\\
"region": "${region}",// The region ID\\\\
"fileSystemId": "${file_system_id}", // The file system ID\\\\
"protocolServiceId":"${protocol_service_id}", // The file system protocol service\\\\
"exportId": "${export_id}", // The file system export directory\\\\
"path": "${path}", // The file system path\\\\
}\\\\


**CPFS for Lingjun**

{\\\\
"region": "${region}",// The region ID\\\\
"fileSystemId": "${file_system_id}", // The file system ID\\\\
"path": "${path}", // The file system path\\\\
"mountTarget": "${mount_target}" // The mount point of the file system, CPFS for Lingjun only\\\\
"isVpcMount": boolean, // Whether the mount point is a VPC mount point, CPFS for Lingjun only\\\\
}\\\\', example='{
    "region": "cn-wulanchabu",
    "fileSystemId": "bmcpfs-xxxxxxxxxxx",
    "path": "/mnt",
    "mountTarget": "cpfs-xxxxxxxxxxxx-vpc-gacs9f.cn-wulanchabu.cpfs.aliyuncs.com",
    "isVpcMount": true
}'),
  isShared?: boolean(name='IsShared'),
  labels?: [
    Label
  ](name='Labels', description='The tags.'),
  latestVersion?: DatasetVersion(name='LatestVersion', description='The latest version of the dataset.'),
  mountAccess?: string(name='MountAccess', description='The access permission on the dataset when the dataset is mounted. Valid values:

*   RO: read-only permissions
*   RW: read and write permissions', example='RW'),
  mountAccessReadWriteRoleIdList?: [ string ](name='MountAccessReadWriteRoleIdList', description='The list of role names in the workspace that have read and write permissions on the mounted database. The names start with PAI are basic role names and the names start with role- are custom role names. If the list contains asterisks (\\\\*), all roles have read and write permissions.'),
  name?: string(name='Name', description='The dataset name.', example='myName'),
  options?: string(name='Options', description='The extended fields of the dataset v1 (initial version). The value is a JSON string. When you use the dataset in Deep Learning Containers (DLC), you can use the mountPath field to specify the default mount path of the dataset.', example='{
  "mountPath": "/mnt/data/"
}'),
  ownerId?: string(name='OwnerId', description='The ID of the Alibaba Could account.', example='1631044****3440'),
  property?: string(name='Property', description='The property of the dataset of the initial version v1. Valid values:

*   FILE
*   DIRECTORY', example='DIRECTORY'),
  provider?: string(name='Provider', description='The dataset provider. If the value pai is returned, the dataset is a public dataset in PAI.', example='pai'),
  providerType?: string(name='ProviderType', description='The type of the data source for the dataset. Valid values:

*   Ecs (default)
*   Lingjun', example='Ecs'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  sharedFrom?: DatasetShareRelationship(name='SharedFrom'),
  sharingConfig?: {
    sharedTo?: [
      DatasetShareRelationship
    ](name='SharedTo'),
  }(name='SharingConfig'),
  sourceDatasetId?: string(name='SourceDatasetId', description='The ID of the source dataset generated from a labeling job of iTAG.', example='d-rcdg3wxxxxxhc5jk87'),
  sourceDatasetVersion?: string(name='SourceDatasetVersion', description='The version of the source dataset generated from a labeling job of iTAG.', example='v2'),
  sourceId?: string(name='SourceId', description='The ID of the source for the dataset v1 (initial version). Valid values:

*   If SourceType is set to USER, the value of SourceId can be a custom string.
*   If SourceType is set to ITAG, the value of SourceId is the ID of the labeling job of iTAG.
*   If SourceType is set to PAI_PUBLIC_DATASET, SourceId is empty by default.', example='jdnhf***fnrimv'),
  sourceType?: string(name='SourceType', description='The type of the source for the dataset v1 (initial version). Valid values:

*   PAI-PUBLIC-DATASET: a public dataset of Platform for AI (PAI).
*   ITAG: a dataset generated from a labeling job of iTAG.
*   USER: a dataset registered by a user.', example='USER'),
  tagTemplateType?: string(name='TagTemplateType', description='The labeling template for the source dataset generated from a labeling job of iTAG.', example='TextClassification'),
  uri?: string(name='Uri', description='The URI of the initial version v1.

*   Sample format for the OSS data source: `oss://bucket.endpoint/object`
*   Sample formats for the NAS data source: `nas://<nasfisid>.region/subpath/to/dir/`: General-purpose NAS. `nas://<cpfs-fsid>.region/subpath/to/dir/`: Cloud Parallel File Storage (CPFS) 1.0. `nas://<cpfs-fsid>.region/<protocolserviceid>/`: CPFS 2.0. You can distinguish CPFS 1.0 and CPFS 2.0 file systems based on the format of the file system ID. The ID for CPFS 1.0 is in the cpfs-<8-bit ASCII characters> format. The ID for CPFS 2.0 is in the cpfs-<16-bit ASCII characters> format.', example='nas://09f****f2.cn-hangzhou/'),
  userId?: string(name='UserId', description='The ID of the user to which the dataset belongs.', example='2485765****023475'),
  workspaceId?: string(name='WorkspaceId', description='The ID of the workspace to which the dataset belongs.', example='478**'),
}

model GetDatasetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDatasetResponseBody(name='body'),
}

/**
 * @summary Obtains a dataset.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDatasetResponse
 */
@context("getDatasetWithContext")
async function getDatasetWithOptions(DatasetId: string, headers: map[string]string, runtime: $RuntimeOptions): GetDatasetResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDataset',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a dataset.
 *
 * @return GetDatasetResponse
 */
async function getDataset(DatasetId: string): GetDatasetResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getDatasetWithOptions(DatasetId, headers, runtime);
}

model GetDatasetFileMetaRequest {
  datasetVersion?: string(name='DatasetVersion', description='The dataset version.', example='v1'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='1234'),
}

model GetDatasetFileMetaResponseBody = {
  datasetFileMeta?: DatasetFileMetaContentGet(name='DatasetFileMeta', description='The queried metadata records of dataset files.'),
  datasetId?: string(name='DatasetId', description='The dataset ID.', example='d-rbvg5wz****c9ks92'),
  datasetVersion?: string(name='DatasetVersion', description='The dataset version.', example='v1'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='1234'),
}

model GetDatasetFileMetaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDatasetFileMetaResponseBody(name='body'),
}

/**
 * @summary Queries the metadata records of specific files in a dataset.
 *
 * @param request GetDatasetFileMetaRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDatasetFileMetaResponse
 */
@context("getDatasetFileMetaWithContext")
async function getDatasetFileMetaWithOptions(DatasetId: string, DatasetFileMetaId: string, request: GetDatasetFileMetaRequest, headers: map[string]string, runtime: $RuntimeOptions): GetDatasetFileMetaResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.datasetVersion)) {
    query['DatasetVersion'] = request.datasetVersion;
  }
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDatasetFileMeta',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/datasetfilemetas/${$URL.percentEncode(DatasetFileMetaId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the metadata records of specific files in a dataset.
 *
 * @param request GetDatasetFileMetaRequest
 * @return GetDatasetFileMetaResponse
 */
async function getDatasetFileMeta(DatasetId: string, DatasetFileMetaId: string, request: GetDatasetFileMetaRequest): GetDatasetFileMetaResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getDatasetFileMetaWithOptions(DatasetId, DatasetFileMetaId, request, headers, runtime);
}

model GetDatasetFileMetasStatisticsRequest {
  aggregateBy?: string(name='AggregateBy', description='Aggregates statistics based on the specified metadata field. The value is not case-sensitive. If not specified, the total number of dataset file metadata will be returned, instead of aggregation lists. Valid values:

*   filedir: the directory path of the file
*   file_type: the file type
*   tags.user: user-defined tag
*   tags.user-delete-ai-tags: algorithm tags deleted by the user
*   tags.ai: algorithm tags (aggregated by all tagging tasks)
*   tags.all: algorithm tags and user-defined tags (excluding alogorithm tags deleted by the user)', example='filedir'),
  datasetVersion?: string(name='DatasetVersion', description='The dataset version.

This parameter is required.', example='v1'),
  maxResults?: int32(name='MaxResults', description='The maximum number of results to be returned from a single query when the NextToken parameter is used in the query. Valid values: 1 to 100. Default value: 10.', example='10'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.

This parameter is required.', example='145883'),
}

model GetDatasetFileMetasStatisticsResponseBody = {
  datasetFileMetasStats?: [
    DatasetFileMetasStat
  ](name='DatasetFileMetasStats', description='The details of the returned aggregation list, including the number of each aggregate item. The list is by default sorted in descending order based on the count number.'),
  totalCount?: int32(name='TotalCount', description='The returned number. Example: the number of metadata records or the number of user-defined tags.', example='73'),
  requestId?: string(name='requestId', description='The request ID.', example='ADF6D849-*****-7E7030F0CE53'),
}

model GetDatasetFileMetasStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDatasetFileMetasStatisticsResponseBody(name='body'),
}

/**
 * @summary Obtains metadata statistics of a dataset.
 *
 * @param request GetDatasetFileMetasStatisticsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDatasetFileMetasStatisticsResponse
 */
@context("getDatasetFileMetasStatisticsWithContext")
async function getDatasetFileMetasStatisticsWithOptions(DatasetId: string, request: GetDatasetFileMetasStatisticsRequest, headers: map[string]string, runtime: $RuntimeOptions): GetDatasetFileMetasStatisticsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.aggregateBy)) {
    query['AggregateBy'] = request.aggregateBy;
  }
  if (!$isNull(request.datasetVersion)) {
    query['DatasetVersion'] = request.datasetVersion;
  }
  if (!$isNull(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDatasetFileMetasStatistics',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/statistics/datasets/${$URL.percentEncode(DatasetId)}/datasetfilemetas`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains metadata statistics of a dataset.
 *
 * @param request GetDatasetFileMetasStatisticsRequest
 * @return GetDatasetFileMetasStatisticsResponse
 */
async function getDatasetFileMetasStatistics(DatasetId: string, request: GetDatasetFileMetasStatisticsRequest): GetDatasetFileMetasStatisticsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getDatasetFileMetasStatisticsWithOptions(DatasetId, request, headers, runtime);
}

model GetDatasetJobRequest {
  datasetVersion?: string(name='DatasetVersion', description='The dataset version name.', example='v1'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='478**'),
}

model GetDatasetJobResponseBody = {
  completedFileCount?: long(name='CompletedFileCount', description='The total number of completed files.', example='990'),
  createTime?: string(name='CreateTime', description='The time when the job is started.', example='2024-11-15T07:06:42Z'),
  description?: string(name='Description', description='The job description.'),
  failedFileCount?: long(name='FailedFileCount', description='The total number of failed files.', example='10'),
  finishTime?: string(name='FinishTime', description='The time when the job ends.', example='2024-07-16T02:03:23Z'),
  jobAction?: string(name='JobAction', description='The action that is performed on the job.

Valid values:

*   SemanticIndex: semantic indexing
*   IntelligentTag: smart labeling
*   FileMetaExport: metadata export', example='SemanticIndex'),
  jobMode?: string(name='JobMode', description='The job mode.

Valid value:

*   Full: full data mode.', example='Full'),
  jobSpec?: string(name='JobSpec', description='The job details.', example='{\\\\"modelId\\\\":\\\\"xxx\\\\"}'),
  logs?: [ string ](name='Logs', description='The job logs.'),
  requestId?: string(name='RequestId', description='The request ID.', example='64B50C1D-D4C2-560C-86A3-A6ED****16D'),
  status?: string(name='Status', description='The job state.

Valid values:

*   Succeeded
*   Failed
*   Running
*   Pending
*   PartialFailed
*   Deleting
*   ManuallyStop', example='Running'),
  totalFileCount?: long(name='TotalFileCount', description='The total number of job files.', example='1000'),
}

model GetDatasetJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDatasetJobResponseBody(name='body'),
}

/**
 * @summary Obtains a dataset job.
 *
 * @param request GetDatasetJobRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDatasetJobResponse
 */
@context("getDatasetJobWithContext")
async function getDatasetJobWithOptions(DatasetId: string, DatasetJobId: string, request: GetDatasetJobRequest, headers: map[string]string, runtime: $RuntimeOptions): GetDatasetJobResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.datasetVersion)) {
    query['DatasetVersion'] = request.datasetVersion;
  }
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDatasetJob',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/datasetjobs/${$URL.percentEncode(DatasetJobId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a dataset job.
 *
 * @param request GetDatasetJobRequest
 * @return GetDatasetJobResponse
 */
async function getDatasetJob(DatasetId: string, DatasetJobId: string, request: GetDatasetJobRequest): GetDatasetJobResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getDatasetJobWithOptions(DatasetId, DatasetJobId, request, headers, runtime);
}

model GetDatasetJobConfigRequest {
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='114243'),
}

model GetDatasetJobConfigResponseBody = {
  config?: string(name='Config', description='The configuration content. Configuration format for MultimodalIntelligentTag:

{ "apiKey":"sk-xxxxxxxxxxxxxxxxxxxxx" }

MultimodalSemanticIndex

{ "defaultModelId": "xxx" "defaultModelVersion":"1.0.0" }', example='{ "apiKey":"sk-xxxxxxxxxxxxxxxxxxxxx" }'),
  configType?: string(name='ConfigType', description='The configuration type. Valid values:

*   MultimodalIntelligentTag
*   MultimodalSemanticIndex', example='MultimodalIntelligentTag'),
  createTime?: string(name='CreateTime', description='The time when the configuration is created.', example='2024-10-16T01:44:10Z'),
  datasetId?: string(name='DatasetId', description='The dataset ID.', example='d-lfd60v0p****ujtsdx'),
  modifyTime?: string(name='ModifyTime', description='The time when the configuration is modified.', example='2024-12-26T02:17:18Z'),
  requestId?: string(name='RequestId', description='The request ID.', example='D5BFFEE3-6025-443F-8A03-02D619B5C4B9'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='114243'),
}

model GetDatasetJobConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDatasetJobConfigResponseBody(name='body'),
}

/**
 * @summary Obtains a job configuration for a dataset.
 *
 * @param request GetDatasetJobConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDatasetJobConfigResponse
 */
@context("getDatasetJobConfigWithContext")
async function getDatasetJobConfigWithOptions(DatasetId: string, DatasetJobConfigId: string, request: GetDatasetJobConfigRequest, headers: map[string]string, runtime: $RuntimeOptions): GetDatasetJobConfigResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDatasetJobConfig',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/datasetjobconfigs/${$URL.percentEncode(DatasetJobConfigId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a job configuration for a dataset.
 *
 * @param request GetDatasetJobConfigRequest
 * @return GetDatasetJobConfigResponse
 */
async function getDatasetJobConfig(DatasetId: string, DatasetJobConfigId: string, request: GetDatasetJobConfigRequest): GetDatasetJobConfigResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getDatasetJobConfigWithOptions(DatasetId, DatasetJobConfigId, request, headers, runtime);
}

model GetDatasetVersionResponseBody = {
  dataCount?: long(name='DataCount', description='The number of data records.', example='10000'),
  dataSize?: long(name='DataSize', description='The size of the dataset.', example='10000'),
  dataSourceType?: string(name='DataSourceType', description='The type of the data source.

This parameter is required.'),
  datasetId?: string(name='DatasetId', description='The request ID.', example='d-dkdbnnap0g7b6su4yg'),
  description?: string(name='Description', description='The version description.'),
  gmtCreateTime?: string(name='GmtCreateTime', description='The creation time.', example='2023-12-13T10:22:05.694Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', description='The last modification time.', example='2023-12-13T10:22:05.694Z'),
  importInfo?: string(name='ImportInfo', description='The dataset configurations to be imported to a storage, such as Object Storage Service (OSS), File Storage NAS (NAS), or Cloud Parallel File Storage (CPFS).

**OSS**

{ "region": "${region}",// The region ID. $bucket = $options["bucket"]; // The bucket name. "path": "${path}" // The file path. }

**NAS**

**CPFS**

**CPFS for Lingjun**', example='{
    "region": "cn-wulanchabu",
    "fileSystemId": "bmcpfs-xxxxxxxxxxx",
    "path": "/mnt",
    "mountTarget": "cpfs-xxxxxxxxxxxx-vpc-gacs9f.cn-wulanchabu.cpfs.aliyuncs.com",
    "isVpcMount": true
}'),
  labels?: [
    Label
  ](name='Labels', description='The resource tags.'),
  mountAccess?: string(name='MountAccess', description='The access permission on the dataset when the dataset is mounted. Valid values:

*   RO: read-only permissions
*   RW: read and write permissions', example='RO'),
  options?: string(name='Options', description='The extended fields.', example='{
  "mountPath": "/mnt/data/"
}'),
  property?: string(name='Property', description='The property of the dataset.

This parameter is required.', example='DIRECTORY'),
  requestId?: string(name='RequestId', description='Id of the request', example='C55DF3DA-F120-5E37-A374-F49365531701'),
  sourceId?: string(name='SourceId', description='The ID of the source dataset.', example='d-rbvg5wzljzjhc9ks92'),
  sourceType?: string(name='SourceType', description='The type of the data source.', example='USER'),
  uri?: string(name='Uri', description='The sample URI of the dataset.

This parameter is required.', example='oss://ai4d-br7hx9ngzelo2o6uip.oss-cn-shanghai.aliyuncs.com/365349/data-1157703270994901/datasets/aka108o/'),
  versionName?: string(name='VersionName', description='The version name of the dataset.', example='v1'),
}

model GetDatasetVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDatasetVersionResponseBody(name='body'),
}

/**
 * @summary Obtains the information about a specified version of a dataset.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDatasetVersionResponse
 */
@context("getDatasetVersionWithContext")
async function getDatasetVersionWithOptions(DatasetId: string, VersionName: string, headers: map[string]string, runtime: $RuntimeOptions): GetDatasetVersionResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDatasetVersion',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/versions/${$URL.percentEncode(VersionName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the information about a specified version of a dataset.
 *
 * @return GetDatasetVersionResponse
 */
async function getDatasetVersion(DatasetId: string, VersionName: string): GetDatasetVersionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getDatasetVersionWithOptions(DatasetId, VersionName, headers, runtime);
}

model GetDefaultWorkspaceRequest {
  verbose?: boolean(name='Verbose', description='Specifies whether to show the details of the default workspace. The details include the conditions of the workspace in different phases. Valid values:

*   false (default)
*   true', example='false'),
}

model GetDefaultWorkspaceResponseBody = {
  conditions?: [ 
    {
      code?: long(name='Code', description='The returned status code. HTTP status code 200 indicates that the request was successful. Other HTTP status codes indicate that the request failed.', example='200'),
      message?: string(name='Message', description='The error message. If the returned status code is 200, this parameter is empty.', example='Create Failed'),
      type?: string(name='Type', description='The task type. Valid values:

*   CREATING: The workspace is being created.
*   WORKSPACE_CREATED: The workspace is created.
*   MEMBERS_ADDED: The member is added.
*   ENABLED: The workspace is created and the member is added.', example='CREATING'),
    }
  ](name='Conditions', description='The conditions of the default workspace in the creation process.'),
  creator?: string(name='Creator', description='The UID of the Alibaba Cloud account.', example='17915******4216'),
  description?: string(name='Description', description='The workspace description.', example='workspace description example'),
  displayName?: string(name='DisplayName', description='The display name of the workspace.', example='workspace-example'),
  envTypes?: [ string ](name='EnvTypes', description='The environments of the workspace. Valid values:

*   Workspaces in basic mode can run only in the production environment.
*   Workspaces in standard mode can run in both the development and production environments.'),
  gmtCreateTime?: string(name='GmtCreateTime', description='The time when the workspace was created, in UTC. The time follows the ISO 8601 standard.', example='2021-01-21T17:12:35.232Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', description='The time when the workspace was modified, in UTC. The time follows the ISO 8601 standard.', example='2021-01-21T17:12:35.232Z'),
  owner?: {
    userId?: string(name='UserId', description='The user ID.', example='17915******4216'),
    userKp?: string(name='UserKp', description='The user ID.', example='17915******4216'),
    userName?: string(name='UserName', description='The username.', example='username'),
  }(name='Owner', description='The UID of the Alibaba Cloud account.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  status?: string(name='Status', description='The workspace status. Valid values:

*   ENABLED
*   INITIALIZING
*   FAILURE
*   DISABLED
*   FROZEN
*   UPDATING', example='ENABLED'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='1234'),
  workspaceName?: string(name='WorkspaceName', description='The workspace name, which is unique in a region.', example='workspace-example'),
}

model GetDefaultWorkspaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDefaultWorkspaceResponseBody(name='body'),
}

/**
 * @summary Queries information about the default workspace.
 *
 * @param request GetDefaultWorkspaceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDefaultWorkspaceResponse
 */
@context("getDefaultWorkspaceWithContext")
async function getDefaultWorkspaceWithOptions(request: GetDefaultWorkspaceRequest, headers: map[string]string, runtime: $RuntimeOptions): GetDefaultWorkspaceResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.verbose)) {
    query['Verbose'] = request.verbose;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDefaultWorkspace',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/defaultWorkspaces`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries information about the default workspace.
 *
 * @param request GetDefaultWorkspaceRequest
 * @return GetDefaultWorkspaceResponse
 */
async function getDefaultWorkspace(request: GetDefaultWorkspaceRequest): GetDefaultWorkspaceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getDefaultWorkspaceWithOptions(request, headers, runtime);
}

model GetExperimentRequest {
  verbose?: boolean(name='Verbose', description='Specifies whether to obtain the latest run information associated with the experiment

Valid values:

*   true
*   false', example='false'),
}

model GetExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Experiment  
}

/**
 * @summary Obtains an experiment.
 *
 * @param request GetExperimentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetExperimentResponse
 */
@context("getExperimentWithContext")
async function getExperimentWithOptions(ExperimentId: string, request: GetExperimentRequest, headers: map[string]string, runtime: $RuntimeOptions): GetExperimentResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.verbose)) {
    query['Verbose'] = request.verbose;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetExperiment',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${$URL.percentEncode(ExperimentId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains an experiment.
 *
 * @param request GetExperimentRequest
 * @return GetExperimentResponse
 */
async function getExperiment(ExperimentId: string, request: GetExperimentRequest): GetExperimentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentWithOptions(ExperimentId, request, headers, runtime);
}

model GetImageRequest {
  verbose?: boolean(name='Verbose', description='Specifies whether to display non-essential information, which contains tags. Valid values:

*   false (default)
*   true', example='false'),
}

model GetImageResponseBody = {
  accessibility?: string(name='Accessibility', description='The accessibility of the image. Valid values:

*   PUBLIC: All members can access the workspace.
*   PRIVATE: Only the creator can access the workspace.', example='PUBLIC'),
  description?: string(name='Description', description='The image description.'),
  gmtCreateTime?: string(name='GmtCreateTime', description='The time when the image is created, in UTC. The time follows the ISO 8601 standard.', example='2021-01-21T17:12:35.232Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', description='The time when the image is modified, in UTC. The time follows the ISO 8601 standard.', example='2021-01-21T17:12:35.232Z'),
  imageUri?: string(name='ImageUri', description='The image address, which contains the version number.', example='registry.cn-hangzhou.aliyuncs.******ession/nlp:gpu'),
  labels?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='system.chipType'),
      value?: string(name='Value', description='The tag value.', example='GPU'),
    }
  ](name='Labels', description='The image tags, which are of the array data type. Each element in the array contains a key-value pair. The key of official tags is system.official and the tag value is true.'),
  name?: string(name='Name', description='The image name.', example='nlp-compression'),
  parentUserId?: string(name='ParentUserId', description='The Alibaba Cloud account of the creator.', example='15577******8921'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  size?: int32(name='Size', description='The size of the image. Unit: GB.', example='10'),
  sourceId?: string(name='SourceId', description='镜像来源 ID'),
  sourceType?: string(name='SourceType', description='镜像来源类型'),
  userId?: string(name='UserId', description='The user ID of the image.', example='15577******8921'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='15945'),
}

model GetImageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetImageResponseBody(name='body'),
}

/**
 * @summary Obtains the information about an image.
 *
 * @param request GetImageRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetImageResponse
 */
@context("getImageWithContext")
async function getImageWithOptions(ImageId: string, request: GetImageRequest, headers: map[string]string, runtime: $RuntimeOptions): GetImageResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.verbose)) {
    query['Verbose'] = request.verbose;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetImage',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/images/${$URL.percentEncode(ImageId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the information about an image.
 *
 * @param request GetImageRequest
 * @return GetImageResponse
 */
async function getImage(ImageId: string, request: GetImageRequest): GetImageResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getImageWithOptions(ImageId, request, headers, runtime);
}

model GetMemberRequest {
  memberId?: string(name='MemberId', description='The member ID. You must specify only one of the following parameters: UserId and MemberId.', example='145883-21513926******88039'),
  userId?: string(name='UserId', description='The ID of the Alibaba Cloud account. You can call [ListWorkspaceUsers](https://help.aliyun.com/document_detail/449133.html) to obtain the ID of the Alibaba Cloud account. You must specify only one of the following parameters: UserId and MemberId.', example='21513926******88039'),
}

model GetMemberResponseBody = {
  accountType?: string(name='AccountType'),
  displayName?: string(name='DisplayName', description='The display name of the member.', example='myDisplayName'),
  gmtCreateTime?: string(name='GmtCreateTime', description='The time when the workspace is created, in UTC. The time follows the ISO 8601 standard.', example='2021-01-21T17:12:35.232Z'),
  memberId?: string(name='MemberId', description='The member ID.', example='145883-21513926******88039'),
  memberName?: string(name='MemberName', description='The username.', example='user1'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  roles?: [ string ](name='Roles', description='The list of roles.'),
  userId?: string(name='UserId', description='The user ID.', example='21513926******88039'),
}

model GetMemberResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMemberResponseBody(name='body'),
}

/**
 * @summary Obtains a member in a workspace.
 *
 * @param request GetMemberRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMemberResponse
 */
@context("getMemberWithContext")
async function getMemberWithOptions(WorkspaceId: string, request: GetMemberRequest, headers: map[string]string, runtime: $RuntimeOptions): GetMemberResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.memberId)) {
    query['MemberId'] = request.memberId;
  }
  if (!$isNull(request.userId)) {
    query['UserId'] = request.userId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetMember',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}/member`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a member in a workspace.
 *
 * @param request GetMemberRequest
 * @return GetMemberResponse
 */
async function getMember(WorkspaceId: string, request: GetMemberRequest): GetMemberResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getMemberWithOptions(WorkspaceId, request, headers, runtime);
}

model GetModelResponseBody = {
  accessibility?: string(name='Accessibility', description='The visibility of the workspace.

*   PRIVATE: The workspace is visible only to you and the administrator of the workspace.
*   PUBLIC: The workspace is visible to all users.', example='PUBLIC'),
  domain?: string(name='Domain', description='The domain. This parameter specifies the domain for which the model is developed. Valid values: nlp and cv. nlp indicates natural language processing and cv indicates computer vision.', example='cv'),
  extraInfo?: map[string]any(name='ExtraInfo', description='Other information about the model.', example='{
	"RatingCount": 2866,
	"Rating": 4.94,
	"FavoriteCount": 34992,
	"CommentCount": 754,
	"CoverUris": ["https://e***u.oss-cn-hangzhou.aliyuncs.com/drea***w.png"],
	"TippedAmountCount": 32,
	"DownloadCount": 606056
}'),
  gmtCreateTime?: string(name='GmtCreateTime', description='The time when the model is created, in UTC. The time follows the ISO 8601 standard.', example='2021-01-30T12:51:33.028Z'),
  gmtLatestVersionModifiedTime?: string(name='GmtLatestVersionModifiedTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime', description='The time when the model is last modified, in UTC. The time follows the ISO 8601 standard.', example='2021-01-30T12:51:33.028Z'),
  labels?: [
    Label
  ](name='Labels', description='The model tags.'),
  latestVersion?: ModelVersion(name='LatestVersion', description='The latest version of the model.'),
  modelDescription?: string(name='ModelDescription', description='The model description.'),
  modelDoc?: string(name='ModelDoc', description='The documentation of the model.', example='https://***.md'),
  modelId?: string(name='ModelId', description='The model ID.', example='model-rbvg5wzljz****ks92'),
  modelName?: string(name='ModelName', description='The model name.'),
  modelType?: string(name='ModelType', description='The model type.', example='Checkpoint'),
  orderNumber?: long(name='OrderNumber', description='The sequence number of the model.', example='1'),
  origin?: string(name='Origin', description='The source of the model. The community or organization to which the model belongs, such as ModelScope or HuggingFace.', example='ModelScope'),
  ownerId?: string(name='OwnerId', description='The ID of the Alibaba Cloud account.', example='1234567890******'),
  parameterSize?: long(name='ParameterSize'),
  provider?: string(name='Provider', description='The provider.', example='pai'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  task?: string(name='Task', description='The task of the model. This parameter describes specific issues that the model solves, such as text-classification.', example='text-classification'),
  userId?: string(name='UserId', description='The user ID.', example='1234567890******'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='234**'),
}

model GetModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetModelResponseBody(name='body'),
}

/**
 * @summary Obtains the details of a specified model.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetModelResponse
 */
@context("getModelWithContext")
async function getModelWithOptions(ModelId: string, headers: map[string]string, runtime: $RuntimeOptions): GetModelResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetModel',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/models/${$URL.percentEncode(ModelId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the details of a specified model.
 *
 * @return GetModelResponse
 */
async function getModel(ModelId: string): GetModelResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getModelWithOptions(ModelId, headers, runtime);
}

model GetModelVersionResponseBody = {
  approvalStatus?: string(name='ApprovalStatus', description='The approval status. Valid values:

*   Pending
*   Approved
*   Rejected', example='Approved'),
  compressionSpec?: map[string]any(name='CompressionSpec', description='The compression configuration.', example='{}'),
  distillationSpec?: map[string]any(name='DistillationSpec'),
  evaluationSpec?: map[string]any(name='EvaluationSpec', description='The evaluation configuration.', example='{}'),
  extraInfo?: map[string]any(name='ExtraInfo', description='The additional information.', example='{
	"CoverUris": ["https://e***u.oss-cn-hangzhou.aliyuncs.com/st****017.preview.png"],
	"TrainedWords": ["albedo_overlord"]
}'),
  formatType?: string(name='FormatType', description='The model format. Valid values:

*   OfflineModel
*   SavedModel
*   Keras H5
*   Frozen Pb
*   Caffe Prototxt
*   TorchScript
*   XGBoost
*   PMML
*   AlinkModel
*   ONNX', example='SavedModel'),
  frameworkType?: string(name='FrameworkType', description='The model framework. Valid values:

*   Pytorch -XGBoost
*   Keras
*   Caffe
*   Alink
*   Xflow
*   TensorFlow', example='TensorFlow'),
  gmtCreateTime?: string(name='GmtCreateTime', description='The time when the model was created, in UTC. The time follows the ISO 8601 standard.', example='2021-01-30T12:51:33.028Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', description='The time when the model was last modified, in UTC. The time follows the ISO 8601 standard.', example='2021-01-30T12:51:33.028Z'),
  inferenceSpec?: map[string]any(name='InferenceSpec', description='Describes how to apply to downstream inference services. For example, describes the processor and container of Elastic Algorithm Service (EAS).', example='{
    "Processor": "tensorflow_gpu_1.12"
}'),
  labels?: [
    Label
  ](name='Labels', description='The labels.'),
  metrics?: map[string]any(name='Metrics', description='The metrics.', example='{}'),
  options?: string(name='Options', description='The extended field. The value of this parameter is a JSON string.', example='{}'),
  ownerId?: string(name='OwnerId', description='The ID of the Alibaba Cloud account.', example='1234567890******'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  sourceId?: string(name='SourceId', description='The source ID.

*   If the source type is Custom, this field is not limited.
*   If the source type is PAIFlow or TrainingService, the format is:

<!---->

    region=<region_id>,workspaceId=<workspace_id>,kind=<kind>,id=<id>

Take note of the following parameters:

*   region is the region ID.
*   workspaceId is the ID of the workspace.
*   kind is the type. Valid values: PipelineRun (PAIFlow) and ServiceJob (training service).
*   id is a unique identifier.', example='region=cn-shanghai,workspaceId=13**,kind=PipelineRun,id=run-sakdb****jdf'),
  sourceType?: string(name='SourceType', description='The source type of the model. Valid values:

*   Custom
*   PAIFlow
*   TrainingService', example='PAIFlow'),
  trainingSpec?: map[string]any(name='TrainingSpec', description='The training configurations used for fine-tuning and incremental training.', example='{}'),
  uri?: string(name='Uri', description='The URI of the model version, which is the location where the model is stored. Valid values:

*   The HTTP(S) address of the model. Example: `https://myweb.com/mymodel.tar.gz`.
*   The Object Storage Service (OSS) path of the model, in the format of `oss://<bucket>.<endpoint>/object`. For endpoint, see [OSS regions and endpoints](https://help.aliyun.com/document_detail/31837.html). Example: `oss://mybucket.oss-cn-beijing.aliyuncs.com/mypath/`.'),
  userId?: string(name='UserId', description='The user ID.', example='1234567890******'),
  versionDescription?: string(name='VersionDescription', description='The version description.'),
  versionName?: string(name='VersionName', description='The model version.', example='0.1.0'),
}

model GetModelVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetModelVersionResponseBody(name='body'),
}

/**
 * @summary Queries a model version.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetModelVersionResponse
 */
@context("getModelVersionWithContext")
async function getModelVersionWithOptions(ModelId: string, VersionName: string, headers: map[string]string, runtime: $RuntimeOptions): GetModelVersionResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetModelVersion',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/models/${$URL.percentEncode(ModelId)}/versions/${$URL.percentEncode(VersionName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a model version.
 *
 * @return GetModelVersionResponse
 */
async function getModelVersion(ModelId: string, VersionName: string): GetModelVersionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getModelVersionWithOptions(ModelId, VersionName, headers, runtime);
}

model GetPermissionRequest {
  accessibility?: string(name='Accessibility', description='The accessibility. Valid values:

*   PUBLIC: All members in the workspace can access the workspace.
*   PRIVATE: Only the creator can access the workspace.', example='PUBLIC'),
  creator?: string(name='Creator', description='The UID of the Alibaba Cloud account that is used to create the workspace.', example='17915******4216'),
  labels?: map[string]any(name='Labels'),
  option?: string(name='Option', description='The configuration. Separate multiple configurations with commas (,). Valid values:

*   ResourceEmpty: The Resource parameter is not configured.
*   DisableRam: The RAM check is not performed.', example='ResourceEmpty,DisableRam'),
  resource?: string(name='Resource', description='The resource.', example='job/dlc-ksd******s12'),
}

model GetPermissionShrinkRequest {
  accessibility?: string(name='Accessibility', description='The accessibility. Valid values:

*   PUBLIC: All members in the workspace can access the workspace.
*   PRIVATE: Only the creator can access the workspace.', example='PUBLIC'),
  creator?: string(name='Creator', description='The UID of the Alibaba Cloud account that is used to create the workspace.', example='17915******4216'),
  labelsShrink?: string(name='Labels'),
  option?: string(name='Option', description='The configuration. Separate multiple configurations with commas (,). Valid values:

*   ResourceEmpty: The Resource parameter is not configured.
*   DisableRam: The RAM check is not performed.', example='ResourceEmpty,DisableRam'),
  resource?: string(name='Resource', description='The resource.', example='job/dlc-ksd******s12'),
}

model GetPermissionResponseBody = {
  permissionCode?: string(name='PermissionCode', description='The permission name, which is unique in a region. For more information about permissions, see [Appendix: Roles and permissions](https://help.aliyun.com/document_detail/2840449.html).', example='PaiDLC:ListJobs'),
  permissionRules?: [ 
    {
      accessibility?: string(name='Accessibility', description='The accessibility. Valid values:

*   PUBLIC: All members can access the workspace.
*   PRIVATE: Only the creator can access the workspace.
*   ANY: All users can access the workspace.', example='PRIVATE'),
      entityAccessType?: string(name='EntityAccessType', description='The access type. If you set Accessibility to PUBLIC, all users can access the workspace. This parameter is invalid. If you set Accessibility to PRIVATE, the value of this parameter can be:

*   PRIVATE: Only the creator can access the workspace.
*   ANY: All users can access the workspace.', example='CREATOR'),
    }
  ](name='PermissionRules', description='The permission rules.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model GetPermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPermissionResponseBody(name='body'),
}

/**
 * @summary Obtains permissions on a workspace.
 *
 * @param tmpReq GetPermissionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPermissionResponse
 */
@context("getPermissionWithContext")
async function getPermissionWithOptions(WorkspaceId: string, PermissionCode: string, tmpReq: GetPermissionRequest, headers: map[string]string, runtime: $RuntimeOptions): GetPermissionResponse {
  tmpReq.validate();
  var request = new GetPermissionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.labels)) {
    request.labelsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labels, 'Labels', 'json');
  }
  var query : map[string]any = {};
  if (!$isNull(request.accessibility)) {
    query['Accessibility'] = request.accessibility;
  }
  if (!$isNull(request.creator)) {
    query['Creator'] = request.creator;
  }
  if (!$isNull(request.labelsShrink)) {
    query['Labels'] = request.labelsShrink;
  }
  if (!$isNull(request.option)) {
    query['Option'] = request.option;
  }
  if (!$isNull(request.resource)) {
    query['Resource'] = request.resource;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetPermission',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}/permissions/${$URL.percentEncode(PermissionCode)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains permissions on a workspace.
 *
 * @param request GetPermissionRequest
 * @return GetPermissionResponse
 */
async function getPermission(WorkspaceId: string, PermissionCode: string, request: GetPermissionRequest): GetPermissionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getPermissionWithOptions(WorkspaceId, PermissionCode, request, headers, runtime);
}

model GetRunRequest {
  verbose?: boolean(name='Verbose', description='Specifies whether to obtain the Metrics, Params, and Labels information. Default value: false.', example='true'),
}

model GetRunResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Run  
}

/**
 * @summary Queries the run information.
 *
 * @param request GetRunRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRunResponse
 */
@context("getRunWithContext")
async function getRunWithOptions(RunId: string, request: GetRunRequest, headers: map[string]string, runtime: $RuntimeOptions): GetRunResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.verbose)) {
    query['Verbose'] = request.verbose;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetRun',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/runs/${$URL.percentEncode(RunId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the run information.
 *
 * @param request GetRunRequest
 * @return GetRunResponse
 */
async function getRun(RunId: string, request: GetRunRequest): GetRunResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getRunWithOptions(RunId, request, headers, runtime);
}

model GetWorkspaceRequest {
  verbose?: boolean(name='Verbose', description='Specifies whether to display supplementary information such as the workspace owner. Valid values:

*   false (default)
*   true', example='true'),
}

model GetWorkspaceResponseBody = {
  adminNames?: [ string ](name='AdminNames', description='The names of the administrator accounts.'),
  creator?: string(name='Creator', description='The ID of the user who creates the workspace.', example='1157******94123'),
  description?: string(name='Description', description='The description of the workspace.', example='workspace description example'),
  displayName?: string(name='DisplayName', description='The display name of the workspace.', example='workspace-example'),
  envTypes?: [ string ](name='EnvTypes', description='The environment information of the workspace.

*   Workspaces in basic mode can run only in the production environment.
*   Workspaces in standard mode can run in both the development and production environments.'),
  extraInfos?: map[string]any(name='ExtraInfos', description='The additional information, which only contains the TenantId field.', example='{"TenantId": "4286******98"}'),
  gmtCreateTime?: string(name='GmtCreateTime', description='The time when the workspace is created, in UTC. The time follows the ISO 8601 standard.', example='2021-01-21T17:12:35.232Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', description='The time when the workspace is modified, in UTC. The time follows the ISO 8601 standard.', example='2021-01-21T17:12:35.232Z'),
  isDefault?: boolean(name='IsDefault', description='Indicates whether the workspace is the default workspace. Valid values:

*   false
*   true', example='true'),
  owner?: {
    displayName?: string(name='DisplayName', description='The display name.', example='mings****t'),
    userId?: string(name='UserId', description='The user ID.', example='1157******94123'),
    userKp?: string(name='UserKp', description='The user ID.', example='1157******94123'),
    userName?: string(name='UserName', description='The username.', example='mings****t'),
  }(name='Owner', description='The information about the workspace owner. This parameter is valid only when Verbose is set to true.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A0F049F0-8D69-5BAC-8F10-B4DED1B5A34C'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-acfmwp7rkyq****'),
  status?: string(name='Status', description='The workspace state. Valid values:

*   ENABLED
*   INITIALIZING
*   FAILURE:
*   DISABLED
*   FROZEN
*   UPDATING', example='ENABLED'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='1234'),
  workspaceName?: string(name='WorkspaceName', description='The name of the workspace.', example='workspace-example'),
}

model GetWorkspaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetWorkspaceResponseBody(name='body'),
}

/**
 * @summary Queries the details about a workspace.
 *
 * @param request GetWorkspaceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetWorkspaceResponse
 */
@context("getWorkspaceWithContext")
async function getWorkspaceWithOptions(WorkspaceId: string, request: GetWorkspaceRequest, headers: map[string]string, runtime: $RuntimeOptions): GetWorkspaceResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.verbose)) {
    query['Verbose'] = request.verbose;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetWorkspace',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details about a workspace.
 *
 * @param request GetWorkspaceRequest
 * @return GetWorkspaceResponse
 */
async function getWorkspace(WorkspaceId: string, request: GetWorkspaceRequest): GetWorkspaceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getWorkspaceWithOptions(WorkspaceId, request, headers, runtime);
}

model ListCodeSourcesRequest {
  displayName?: string(name='DisplayName', description='The display name of the code source. Fuzzy match is supported.', example='MyDataSource'),
  order?: string(name='Order', description='The order in which the entries are sorted by the specific field on the returned page. Valid values:

*   ASC (default)
*   DESC', example='desc'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20.', example='10'),
  sortBy?: string(name='SortBy', description='The field used for sorting. Valid values:

*   GmtModifyTime: the time when the code source was modified.
*   DisplayName: the display name.
*   CodeSourceId: the code source ID.
*   GmtCreateTime: the time when the code source was created. This is the default value.', example='GmtModifyTime'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='1234'),
}

model ListCodeSourcesResponseBody = {
  codeSources?: [
    CodeSourceItem
  ](name='CodeSources', description='The code sources.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  totalCount?: long(name='TotalCount', description='The total number of code sources that meet the filter conditions.', example='2'),
}

model ListCodeSourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCodeSourcesResponseBody(name='body'),
}

/**
 * @summary Lists code sources. Pagination, sorting, and filtering by condition are supported.
 *
 * @param request ListCodeSourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCodeSourcesResponse
 */
@context("listCodeSourcesWithContext")
async function listCodeSourcesWithOptions(request: ListCodeSourcesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListCodeSourcesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!$isNull(request.order)) {
    query['Order'] = request.order;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListCodeSources',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/codesources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Lists code sources. Pagination, sorting, and filtering by condition are supported.
 *
 * @param request ListCodeSourcesRequest
 * @return ListCodeSourcesResponse
 */
async function listCodeSources(request: ListCodeSourcesRequest): ListCodeSourcesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listCodeSourcesWithOptions(request, headers, runtime);
}

model ListConfigsRequest {
  categoryName?: string(name='CategoryName', description='The category of the configuration item. Supported categories:

*   CommonResourceConfig
*   DLCAutoRecycle
*   DLCPriorityConfig
*   DSWPriorityConfig
*   QuotaMaximumDuration
*   CommonTagConfig', example='CommonResourceConfig'),
  configKeys?: string(name='ConfigKeys', description='The key of the configuration item. Supported keys:

*   tempStoragePath: Temporary storage path. This key can be used only when CategoryName is set to CommonResourceConfig.
*   isAutoRecycle: Automatic recycle configuration. This key can be used only when CategoryName is set to DLCAutoRecycle.
*   priorityConfig: Priority configuration. This key can be used only when CategoryName is set to DLCPriorityConfig or DSWPriorityConfig.
*   quotaMaximumDuration: Maximum run time of DLC jobs for a quota. This key can be used only when CategoryName is set to QuotaMaximumDuration.
*   predefinedTags: The predefined tags of the workspace. All created resources must have tags', example='tempStoragePath'),
  labels?: string(name='Labels', description='The tags used as filter conditions. Separate multiple tags with commas (,). These conditions are in an AND relationship.', example='key1=value1,key2=value2'),
  verbose?: string(name='Verbose', description='Specifies whether to show the tag information.

*   true
*   false', example='true'),
}

model ListConfigsResponseBody = {
  configs?: [ 
    {
      configKey?: string(name='ConfigKey', description='The key of the configuration item. Supported keys:

*   tempStoragePath: Temporary storage path. This key can be used only when CategoryName is set to CommonResourceConfig.
*   isAutoRecycle: Automatic recycle configuration. This key can be used only when CategoryName is set to DLCAutoRecycle.
*   tempStoragePath: Temporary storage path. This key can be used only when CategoryName is set to CommonResourceConfig.
*   quotaMaximumDuration: Maximum run time of DLC jobs for a quota. This key can be used only when CategoryName is set to QuotaMaximumDuration.
*   predefinedTags: The predefined tags of the workspace. All created resources must have tags', example='tempTableLifecycle'),
      configValue?: string(name='ConfigValue', description='The value of the configuration item.', example='oss://***'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      labels?: [ 
        {
          key?: string(name='Key', description='The tag key.', example='key1'),
          value?: string(name='Value', description='The tag value.', example='value1'),
        }
      ](name='Labels', description='The tags of the configuration item.'),
    }
  ](name='Configs', description='The configuration items.'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A******C83E'),
  totalCount?: long(name='TotalCount', description='The number of items returned.', example='15'),
}

model ListConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListConfigsResponseBody(name='body'),
}

/**
 * @summary Obtains a list of workspace configurations.
 *
 * @param request ListConfigsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListConfigsResponse
 */
@context("listConfigsWithContext")
async function listConfigsWithOptions(WorkspaceId: string, request: ListConfigsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListConfigsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.categoryName)) {
    query['CategoryName'] = request.categoryName;
  }
  if (!$isNull(request.configKeys)) {
    query['ConfigKeys'] = request.configKeys;
  }
  if (!$isNull(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!$isNull(request.verbose)) {
    query['Verbose'] = request.verbose;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListConfigs',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}/configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a list of workspace configurations.
 *
 * @param request ListConfigsRequest
 * @return ListConfigsResponse
 */
async function listConfigs(WorkspaceId: string, request: ListConfigsRequest): ListConfigsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listConfigsWithOptions(WorkspaceId, request, headers, runtime);
}

model ListConnectionsRequest {
  connectionIds?: [ string ](name='ConnectionIds', description='The list of connection IDs.'),
  connectionName?: string(name='ConnectionName', description='The connection name.'),
  connectionTypes?: [ string ](name='ConnectionTypes', description='The list of connection types.'),
  creator?: string(name='Creator'),
  encryptOption?: string(name='EncryptOption', description='The encryption settings. Valid values:

*   PlainText
*   Secret', example='PlainText'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries per page.', example='10'),
  model?: string(name='Model', description='The model identifier.', example='model_001'),
  modelTypes?: [ string ](name='ModelTypes', description='The list of model types.'),
  nextToken?: string(name='NextToken', description='The pagination token that indicates the start position from which to retrieve data on the next page.', example='15'),
  order?: string(name='Order', description='The order in which the entries are sorted by the specific field on the returned page. This parameter must be used together with SortBy.

*   ASC: ascending order.
*   DESC: descending order. This is the default value.', example='DESC'),
  sortBy?: string(name='SortBy', description='The field used to sort the results in queries by page. Default value: GmtCreateTime. Valid value:

*   GmtCreateTime: The results are sorted by creation time. This is the default value.', example='GmtCreateTime'),
  toolCall?: boolean(name='ToolCall', description='Specifies whether a tool can be called by using ToolCall. Valid values:

*   true
*   false', example='true'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='478**'),
}

model ListConnectionsShrinkRequest {
  connectionIdsShrink?: string(name='ConnectionIds', description='The list of connection IDs.'),
  connectionName?: string(name='ConnectionName', description='The connection name.'),
  connectionTypesShrink?: string(name='ConnectionTypes', description='The list of connection types.'),
  creator?: string(name='Creator'),
  encryptOption?: string(name='EncryptOption', description='The encryption settings. Valid values:

*   PlainText
*   Secret', example='PlainText'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries per page.', example='10'),
  model?: string(name='Model', description='The model identifier.', example='model_001'),
  modelTypesShrink?: string(name='ModelTypes', description='The list of model types.'),
  nextToken?: string(name='NextToken', description='The pagination token that indicates the start position from which to retrieve data on the next page.', example='15'),
  order?: string(name='Order', description='The order in which the entries are sorted by the specific field on the returned page. This parameter must be used together with SortBy.

*   ASC: ascending order.
*   DESC: descending order. This is the default value.', example='DESC'),
  sortBy?: string(name='SortBy', description='The field used to sort the results in queries by page. Default value: GmtCreateTime. Valid value:

*   GmtCreateTime: The results are sorted by creation time. This is the default value.', example='GmtCreateTime'),
  toolCall?: boolean(name='ToolCall', description='Specifies whether a tool can be called by using ToolCall. Valid values:

*   true
*   false', example='true'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='478**'),
}

model ListConnectionsResponseBody = {
  connections?: [
    Connection
  ](name='Connections', description='The connection list.'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries per page.', example='10'),
  nextToken?: string(name='NextToken', description='The pagination token that indicates the start position from which to retrieve data on the next page.', example='15'),
  requestId?: string(name='RequestId', description='The request ID.', example='B2C51F93-1C07-5477-9705-5FDB****F19F'),
  totalCount?: int32(name='TotalCount', description='The total number of connections that meet the filter conditions.', example='27'),
}

model ListConnectionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListConnectionsResponseBody(name='body'),
}

/**
 * @summary Lists connections.
 *
 * @param tmpReq ListConnectionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListConnectionsResponse
 */
@context("listConnectionsWithContext")
async function listConnectionsWithOptions(tmpReq: ListConnectionsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListConnectionsResponse {
  tmpReq.validate();
  var request = new ListConnectionsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.connectionIds)) {
    request.connectionIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.connectionIds, 'ConnectionIds', 'simple');
  }
  if (!$isNull(tmpReq.connectionTypes)) {
    request.connectionTypesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.connectionTypes, 'ConnectionTypes', 'simple');
  }
  if (!$isNull(tmpReq.modelTypes)) {
    request.modelTypesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.modelTypes, 'ModelTypes', 'simple');
  }
  var query : map[string]any = {};
  if (!$isNull(request.connectionIdsShrink)) {
    query['ConnectionIds'] = request.connectionIdsShrink;
  }
  if (!$isNull(request.connectionName)) {
    query['ConnectionName'] = request.connectionName;
  }
  if (!$isNull(request.connectionTypesShrink)) {
    query['ConnectionTypes'] = request.connectionTypesShrink;
  }
  if (!$isNull(request.creator)) {
    query['Creator'] = request.creator;
  }
  if (!$isNull(request.encryptOption)) {
    query['EncryptOption'] = request.encryptOption;
  }
  if (!$isNull(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.model)) {
    query['Model'] = request.model;
  }
  if (!$isNull(request.modelTypesShrink)) {
    query['ModelTypes'] = request.modelTypesShrink;
  }
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.order)) {
    query['Order'] = request.order;
  }
  if (!$isNull(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!$isNull(request.toolCall)) {
    query['ToolCall'] = request.toolCall;
  }
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListConnections',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/connections`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Lists connections.
 *
 * @param request ListConnectionsRequest
 * @return ListConnectionsResponse
 */
async function listConnections(request: ListConnectionsRequest): ListConnectionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listConnectionsWithOptions(request, headers, runtime);
}

model ListDatasetFileMetasRequest {
  datasetVersion?: string(name='DatasetVersion', description='The dataset version.

This parameter is required.', example='v1'),
  endFileUpdateTime?: string(name='EndFileUpdateTime', description='The update time range to query. The end time. The time follows the ISO 8601 standard. This parameter is valid only when QueryType is set to TAG.

Use the UTC time format: yyyy-MM-ddTHH:mm:ss.SSSZ', example='2025-01-12T14:36:01Z'),
  endTagUpdateTime?: string(name='EndTagUpdateTime', description='Use the UTC time format: yyyy-MM-ddTHH:mm:ss.SSSZ', example='2025-01-12T14:36:01.000Z'),
  maxResults?: int32(name='MaxResults', example='10'),
  nextToken?: string(name='NextToken', description='The pagination token.

>  If you do not configure this parameter, the data on the first page is returned. A return value other than Null of this parameter indicates that not all entries have been returned. You can use this value as an input parameter to obtain entries on the next page. The value Null indicates that all query results have been returned.', example='90a6ee35-****-4cd4-927e-1f45e1cb8b62_1729644433000'),
  order?: string(name='Order', description='The order in which the entries are sorted by the specific field on the returned page. This parameter must be used together with SortBy. Default value: ASC.

*   ASC
*   DESC', example='DESC'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10. Maximum value: 1000.', example='10', deprecated=true),
  queryContentTypeIncludeAny?: [ string ](name='QueryContentTypeIncludeAny'),
  queryExpression?: string(name='QueryExpression'),
  queryFileDir?: string(name='QueryFileDir', example='cars/20250221/'),
  queryFileName?: string(name='QueryFileName', example='shuima'),
  queryFileTypeIncludeAny?: [ string ](name='QueryFileTypeIncludeAny'),
  queryImage?: string(name='QueryImage', example='oss://test-xxx-oss/car/0001.png'),
  queryTagsExclude?: [ string ](name='QueryTagsExclude'),
  queryTagsIncludeAll?: [ string ](name='QueryTagsIncludeAll'),
  queryTagsIncludeAny?: [ string ](name='QueryTagsIncludeAny'),
  queryText?: string(name='QueryText', description='The text content to be queried.'),
  queryType?: string(name='QueryType', description='The retrieval type.

*   TAG (default)
*   VECTOR', example='TAG'),
  scoreThreshold?: float(name='ScoreThreshold', description='The similarity score. Only dataset files whose similarity score is greater than the value of ScoreThreshold are returned. This parameter is valid only when QueryType is set to VECTOR.', example='0.6'),
  sortBy?: string(name='SortBy', description='The field used to sort the results. Default value: GmtCreateTime. Valid values:

*   FileCreateTime (default): The results are sorted by the time when the file is created.
*   FileUpdateTime: The results are sorted by the time when the file is last modified.', example='FileCreateTime'),
  startFileUpdateTime?: string(name='StartFileUpdateTime', description='The update time range to query. The start time. The time follows the ISO 8601 standard. This parameter is valid only when QueryType is set to TAG.

Use the UTC time format: yyyy-MM-ddTHH:mm:ss.SSSZ', example='2025-01-12T14:36:01Z'),
  startTagUpdateTime?: string(name='StartTagUpdateTime', description='Use the UTC time format: yyyy-MM-ddTHH:mm:ss.SSSZ', example='2025-01-12T14:36:01.000Z'),
  thumbnailMode?: string(name='ThumbnailMode', example='w_100'),
  topK?: int32(name='TopK', description='The number of search results to return. A maximum of Top K search results can be returned. This parameter is valid only when QueryType is set to VECTOR.', example='100'),
  workspaceId?: string(name='WorkspaceId', description='The ID of the workspace to which the dataset belongs. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.

This parameter is required.', example='105173'),
}

model ListDatasetFileMetasShrinkRequest {
  datasetVersion?: string(name='DatasetVersion', description='The dataset version.

This parameter is required.', example='v1'),
  endFileUpdateTime?: string(name='EndFileUpdateTime', description='The update time range to query. The end time. The time follows the ISO 8601 standard. This parameter is valid only when QueryType is set to TAG.

Use the UTC time format: yyyy-MM-ddTHH:mm:ss.SSSZ', example='2025-01-12T14:36:01Z'),
  endTagUpdateTime?: string(name='EndTagUpdateTime', description='Use the UTC time format: yyyy-MM-ddTHH:mm:ss.SSSZ', example='2025-01-12T14:36:01.000Z'),
  maxResults?: int32(name='MaxResults', example='10'),
  nextToken?: string(name='NextToken', description='The pagination token.

>  If you do not configure this parameter, the data on the first page is returned. A return value other than Null of this parameter indicates that not all entries have been returned. You can use this value as an input parameter to obtain entries on the next page. The value Null indicates that all query results have been returned.', example='90a6ee35-****-4cd4-927e-1f45e1cb8b62_1729644433000'),
  order?: string(name='Order', description='The order in which the entries are sorted by the specific field on the returned page. This parameter must be used together with SortBy. Default value: ASC.

*   ASC
*   DESC', example='DESC'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10. Maximum value: 1000.', example='10', deprecated=true),
  queryContentTypeIncludeAnyShrink?: string(name='QueryContentTypeIncludeAny'),
  queryExpression?: string(name='QueryExpression'),
  queryFileDir?: string(name='QueryFileDir', example='cars/20250221/'),
  queryFileName?: string(name='QueryFileName', example='shuima'),
  queryFileTypeIncludeAnyShrink?: string(name='QueryFileTypeIncludeAny'),
  queryImage?: string(name='QueryImage', example='oss://test-xxx-oss/car/0001.png'),
  queryTagsExcludeShrink?: string(name='QueryTagsExclude'),
  queryTagsIncludeAllShrink?: string(name='QueryTagsIncludeAll'),
  queryTagsIncludeAnyShrink?: string(name='QueryTagsIncludeAny'),
  queryText?: string(name='QueryText', description='The text content to be queried.'),
  queryType?: string(name='QueryType', description='The retrieval type.

*   TAG (default)
*   VECTOR', example='TAG'),
  scoreThreshold?: float(name='ScoreThreshold', description='The similarity score. Only dataset files whose similarity score is greater than the value of ScoreThreshold are returned. This parameter is valid only when QueryType is set to VECTOR.', example='0.6'),
  sortBy?: string(name='SortBy', description='The field used to sort the results. Default value: GmtCreateTime. Valid values:

*   FileCreateTime (default): The results are sorted by the time when the file is created.
*   FileUpdateTime: The results are sorted by the time when the file is last modified.', example='FileCreateTime'),
  startFileUpdateTime?: string(name='StartFileUpdateTime', description='The update time range to query. The start time. The time follows the ISO 8601 standard. This parameter is valid only when QueryType is set to TAG.

Use the UTC time format: yyyy-MM-ddTHH:mm:ss.SSSZ', example='2025-01-12T14:36:01Z'),
  startTagUpdateTime?: string(name='StartTagUpdateTime', description='Use the UTC time format: yyyy-MM-ddTHH:mm:ss.SSSZ', example='2025-01-12T14:36:01.000Z'),
  thumbnailMode?: string(name='ThumbnailMode', example='w_100'),
  topK?: int32(name='TopK', description='The number of search results to return. A maximum of Top K search results can be returned. This parameter is valid only when QueryType is set to VECTOR.', example='100'),
  workspaceId?: string(name='WorkspaceId', description='The ID of the workspace to which the dataset belongs. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.

This parameter is required.', example='105173'),
}

model ListDatasetFileMetasResponseBody = {
  datasetFileMetas?: [
    DatasetFileMeta
  ](name='DatasetFileMetas', description='The metadata records of the dataset files.'),
  datasetId?: string(name='DatasetId', description='The dataset ID.', example='d-rbvg5*****jhc9ks92'),
  datasetVersion?: string(name='DatasetVersion', description='The dataset version.', example='v1'),
  maxResults?: int32(name='MaxResults', example='10'),
  nextToken?: string(name='NextToken', description='The pagination token. If the number of results exceeds the maximum number of entries allowed per page, a pagination token is returned. This token can be used as an input parameter to obtain the next page of results. If all results are obtained, no token is returned.', example='90******-f5c5-4cd4-927e-1f45e1cb8b62_1729644433000'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30', deprecated=true),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='123'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='105173'),
}

model ListDatasetFileMetasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDatasetFileMetasResponseBody(name='body'),
}

/**
 * @summary Queries a list of dataset files.
 *
 * @param tmpReq ListDatasetFileMetasRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDatasetFileMetasResponse
 */
@context("listDatasetFileMetasWithContext")
async function listDatasetFileMetasWithOptions(DatasetId: string, tmpReq: ListDatasetFileMetasRequest, headers: map[string]string, runtime: $RuntimeOptions): ListDatasetFileMetasResponse {
  tmpReq.validate();
  var request = new ListDatasetFileMetasShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.queryContentTypeIncludeAny)) {
    request.queryContentTypeIncludeAnyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queryContentTypeIncludeAny, 'QueryContentTypeIncludeAny', 'simple');
  }
  if (!$isNull(tmpReq.queryFileTypeIncludeAny)) {
    request.queryFileTypeIncludeAnyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queryFileTypeIncludeAny, 'QueryFileTypeIncludeAny', 'simple');
  }
  if (!$isNull(tmpReq.queryTagsExclude)) {
    request.queryTagsExcludeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queryTagsExclude, 'QueryTagsExclude', 'simple');
  }
  if (!$isNull(tmpReq.queryTagsIncludeAll)) {
    request.queryTagsIncludeAllShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queryTagsIncludeAll, 'QueryTagsIncludeAll', 'simple');
  }
  if (!$isNull(tmpReq.queryTagsIncludeAny)) {
    request.queryTagsIncludeAnyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queryTagsIncludeAny, 'QueryTagsIncludeAny', 'simple');
  }
  var query : map[string]any = {};
  if (!$isNull(request.datasetVersion)) {
    query['DatasetVersion'] = request.datasetVersion;
  }
  if (!$isNull(request.endFileUpdateTime)) {
    query['EndFileUpdateTime'] = request.endFileUpdateTime;
  }
  if (!$isNull(request.endTagUpdateTime)) {
    query['EndTagUpdateTime'] = request.endTagUpdateTime;
  }
  if (!$isNull(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.order)) {
    query['Order'] = request.order;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.queryContentTypeIncludeAnyShrink)) {
    query['QueryContentTypeIncludeAny'] = request.queryContentTypeIncludeAnyShrink;
  }
  if (!$isNull(request.queryExpression)) {
    query['QueryExpression'] = request.queryExpression;
  }
  if (!$isNull(request.queryFileDir)) {
    query['QueryFileDir'] = request.queryFileDir;
  }
  if (!$isNull(request.queryFileName)) {
    query['QueryFileName'] = request.queryFileName;
  }
  if (!$isNull(request.queryFileTypeIncludeAnyShrink)) {
    query['QueryFileTypeIncludeAny'] = request.queryFileTypeIncludeAnyShrink;
  }
  if (!$isNull(request.queryImage)) {
    query['QueryImage'] = request.queryImage;
  }
  if (!$isNull(request.queryTagsExcludeShrink)) {
    query['QueryTagsExclude'] = request.queryTagsExcludeShrink;
  }
  if (!$isNull(request.queryTagsIncludeAllShrink)) {
    query['QueryTagsIncludeAll'] = request.queryTagsIncludeAllShrink;
  }
  if (!$isNull(request.queryTagsIncludeAnyShrink)) {
    query['QueryTagsIncludeAny'] = request.queryTagsIncludeAnyShrink;
  }
  if (!$isNull(request.queryText)) {
    query['QueryText'] = request.queryText;
  }
  if (!$isNull(request.queryType)) {
    query['QueryType'] = request.queryType;
  }
  if (!$isNull(request.scoreThreshold)) {
    query['ScoreThreshold'] = request.scoreThreshold;
  }
  if (!$isNull(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!$isNull(request.startFileUpdateTime)) {
    query['StartFileUpdateTime'] = request.startFileUpdateTime;
  }
  if (!$isNull(request.startTagUpdateTime)) {
    query['StartTagUpdateTime'] = request.startTagUpdateTime;
  }
  if (!$isNull(request.thumbnailMode)) {
    query['ThumbnailMode'] = request.thumbnailMode;
  }
  if (!$isNull(request.topK)) {
    query['TopK'] = request.topK;
  }
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListDatasetFileMetas',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/datasetfilemetas`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of dataset files.
 *
 * @param request ListDatasetFileMetasRequest
 * @return ListDatasetFileMetasResponse
 */
async function listDatasetFileMetas(DatasetId: string, request: ListDatasetFileMetasRequest): ListDatasetFileMetasResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listDatasetFileMetasWithOptions(DatasetId, request, headers, runtime);
}

model ListDatasetJobConfigsRequest {
  configType?: string(name='ConfigType', description='The configuration type.

*   MultimodalIntelligentTag
*   MultimodalSemanticIndex', example='MultimodalIntelligentTag'),
  datasetVersion?: string(name='DatasetVersion'),
  pageNumber?: string(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries per page. Default value: 10.', example='10'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='431514'),
}

model ListDatasetJobConfigsResponseBody = {
  datasetJobConfigs?: [
    DatasetJobConfig
  ](name='DatasetJobConfigs', description='The dataset job configurations.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  totalCount?: int32(name='TotalCount', description='The total number of entries.', example='15'),
}

model ListDatasetJobConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDatasetJobConfigsResponseBody(name='body'),
}

/**
 * @summary Queries the dataset job configurations at a time.
 *
 * @param request ListDatasetJobConfigsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDatasetJobConfigsResponse
 */
@context("listDatasetJobConfigsWithContext")
async function listDatasetJobConfigsWithOptions(DatasetId: string, request: ListDatasetJobConfigsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListDatasetJobConfigsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.configType)) {
    query['ConfigType'] = request.configType;
  }
  if (!$isNull(request.datasetVersion)) {
    query['DatasetVersion'] = request.datasetVersion;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListDatasetJobConfigs',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/datasetjobconfigs/`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the dataset job configurations at a time.
 *
 * @param request ListDatasetJobConfigsRequest
 * @return ListDatasetJobConfigsResponse
 */
async function listDatasetJobConfigs(DatasetId: string, request: ListDatasetJobConfigsRequest): ListDatasetJobConfigsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listDatasetJobConfigsWithOptions(DatasetId, request, headers, runtime);
}

model ListDatasetJobsRequest {
  datasetVersion?: string(name='DatasetVersion', description='The dataset version name.', example='v1'),
  jobAction?: string(name='JobAction', description='The action to be performed on the job.', example='SemanticIndex'),
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='50'),
  sortBy?: string(name='SortBy'),
  status?: string(name='Status'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='1234'),
}

model ListDatasetJobsResponseBody = {
  datasetJobs?: [
    DatasetJob
  ](name='DatasetJobs', description='The jobs in the dataset.'),
  requestId?: string(name='RequestId', description='The request ID.', example='8D7B2E70-F770-505B-A672-09F1D8F2EC1E'),
  totalCount?: int32(name='TotalCount', description='The total number of jobs.'),
}

model ListDatasetJobsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDatasetJobsResponseBody(name='body'),
}

/**
 * @summary Lists jobs in a dataset.
 *
 * @param request ListDatasetJobsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDatasetJobsResponse
 */
@context("listDatasetJobsWithContext")
async function listDatasetJobsWithOptions(DatasetId: string, request: ListDatasetJobsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListDatasetJobsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.datasetVersion)) {
    query['DatasetVersion'] = request.datasetVersion;
  }
  if (!$isNull(request.jobAction)) {
    query['JobAction'] = request.jobAction;
  }
  if (!$isNull(request.order)) {
    query['Order'] = request.order;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!$isNull(request.status)) {
    query['Status'] = request.status;
  }
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListDatasetJobs',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/datasetjobs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Lists jobs in a dataset.
 *
 * @param request ListDatasetJobsRequest
 * @return ListDatasetJobsResponse
 */
async function listDatasetJobs(DatasetId: string, request: ListDatasetJobsRequest): ListDatasetJobsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listDatasetJobsWithOptions(DatasetId, request, headers, runtime);
}

model ListDatasetVersionsRequest {
  labelKeys?: string(name='LabelKeys', description='The dataset tag keys, which are used to filter datasets. Datasets whose tag keys or tag values contain a specified string are filtered.', example='key1,key2'),
  labelValues?: string(name='LabelValues', description='The dataset tag values, which are used to filter datasets. Datasets whose tag keys or tag values contain a specified string are filtered.', example='value1,value2'),
  order?: string(name='Order', description='The order in which the entries are sorted by the specific field on the returned page. Default value: ASC. Valid values:

*   ASC: ascending order
*   DESC: descending order.', example='ASC'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10.

This parameter is required.', example='10'),
  properties?: string(name='Properties', description='The dataset properties. Valid values:

*   DIRECTORY
*   FILE', example='DIRECTORY'),
  sortBy?: string(name='SortBy', description='The field used to sort the results in queries by page. Default value: GmtCreateTime.
Valid values:

*   SourceType
*   DataSourceType
*   DataSize
*   DataCount
*   Property
*   GmtCreateTime: The results are sorted by creation time. This is the default value.
*   GmtModifiedTime: The results are sorted by modification time.
*   DatasetId', example='GmtCreateTime'),
  sourceId?: string(name='SourceId', description='The data source ID.

*   If SourceType is set to USER, the value of SourceId is a custom string.
*   If SourceType is set to ITAG, the value of SourceId is the ID of the labeling job of iTAG.
*   If SourceType is set to PAI_PUBLIC_DATASET, SourceId is empty by default.', example='d-a0xbe5n03bhqof46ce'),
  sourceTypes?: string(name='SourceTypes', description='The source type. Valid values:

*   PAI-PUBLIC-DATASET: a public dataset of Platform for AI (PAI).
*   ITAG: a dataset generated from a labeling job of iTAG.
*   USER: a dataset registered by a user.', example='USER'),
}

model ListDatasetVersionsResponseBody = {
  datasetVersions?: [
    DatasetVersion
  ](name='DatasetVersions', description='The dataset versions.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0648C5BB-68D0-54D2-92A5-607135B8806B'),
  totalCount?: int32(name='TotalCount', description='The number of dataset versions that meet the filter conditions.', example='5'),
}

model ListDatasetVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDatasetVersionsResponseBody(name='body'),
}

/**
 * @summary Lists dataset versions.
 *
 * @param request ListDatasetVersionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDatasetVersionsResponse
 */
@context("listDatasetVersionsWithContext")
async function listDatasetVersionsWithOptions(DatasetId: string, request: ListDatasetVersionsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListDatasetVersionsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.labelKeys)) {
    query['LabelKeys'] = request.labelKeys;
  }
  if (!$isNull(request.labelValues)) {
    query['LabelValues'] = request.labelValues;
  }
  if (!$isNull(request.order)) {
    query['Order'] = request.order;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.properties)) {
    query['Properties'] = request.properties;
  }
  if (!$isNull(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!$isNull(request.sourceId)) {
    query['SourceId'] = request.sourceId;
  }
  if (!$isNull(request.sourceTypes)) {
    query['SourceTypes'] = request.sourceTypes;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListDatasetVersions',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Lists dataset versions.
 *
 * @param request ListDatasetVersionsRequest
 * @return ListDatasetVersionsResponse
 */
async function listDatasetVersions(DatasetId: string, request: ListDatasetVersionsRequest): ListDatasetVersionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listDatasetVersionsWithOptions(DatasetId, request, headers, runtime);
}

model ListDatasetsRequest {
  accessibility?: string(name='Accessibility'),
  dataSourceTypes?: string(name='DataSourceTypes', description='The storage types of the data source. Multiple data source types are separated by commas (,). Valid values:

*   NAS: File Storage NAS (NAS).
*   OSS: Object Storage Service (OSS).', example='OSS'),
  dataTypes?: string(name='DataTypes', description='The dataset types. Multiple dataset types are separated by commas (,). Valid values:

*   Video: video
*   COMMON: common
*   TEXT: text
*   PIC: picture
*   AUDIO: audio', example='COMMON,TEXT'),
  edition?: string(name='Edition'),
  label?: string(name='Label', description='The dataset tag, which is used to filter datasets. Datasets whose tag key or tag value contains a specified string are filtered.', example='test'),
  name?: string(name='Name', description='The dataset name. Fuzzy search based on the dataset name is supported.', example='myName'),
  order?: string(name='Order', description='The order of specific fields of the entries on the returned page. Valid values: ASC and DESC. Default value: ASC.

*   ASC: The entries are sorted in ascending order.
*   DESC: The entries are sorted in descending order.', example='ASC'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10.', example='10'),
  properties?: string(name='Properties', description='The dataset properties. Multiple properties are separated by commas (,). Valid values:

*   DIRECTORY
*   FILE', example='FILE'),
  provider?: string(name='Provider', description='The dataset provider. If the value pai is returned, the dataset is a public dataset provided by PAI.', example='pai'),
  shareScope?: string(name='ShareScope'),
  sortBy?: string(name='SortBy', description='The field used for sorting.', example='GmtCreateTime'),
  sourceDatasetId?: string(name='SourceDatasetId', description='The ID of the iTAG labeled dataset that is used as the source dataset.', example='d-rcdg3wxxxxxhc5jk87'),
  sourceId?: string(name='SourceId', description='The data source ID.

*   If SourceType is set to USER, the value of SourceId is a custom string.
*   If SourceType is set to ITAG, the value of SourceId is the ID of the labeling job of iTAG.
*   If SourceType is set to PAI_PUBLIC_DATASET, SourceId is empty by default.', example='d-rbvg5wzljzjhc9ks92'),
  sourceTypes?: string(name='SourceTypes', description='The source types. Multiple source types are separated by commas (,). Valid values:

*   PAI-PUBLIC-DATASET: a public dataset of Platform for AI (PAI).
*   ITAG: a dataset generated from a labeling job of iTAG.
*   USER: a dataset registered by a user.', example='USER,ITAG'),
  workspaceId?: string(name='WorkspaceId', description='The ID of the workspace to which the dataset belongs. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID. If you do not specify this parameter, the default workspace is used. If the default workspace does not exist, an error is reported.', example='324**'),
}

model ListDatasetsResponseBody = {
  datasets?: [
    Dataset
  ](name='Datasets', description='The datasets.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  totalCount?: long(name='TotalCount', description='The total number of entries.', example='15'),
}

model ListDatasetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDatasetsResponseBody(name='body'),
}

/**
 * @summary Lists the datasets in a workspace.
 *
 * @param request ListDatasetsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDatasetsResponse
 */
@context("listDatasetsWithContext")
async function listDatasetsWithOptions(request: ListDatasetsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListDatasetsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.accessibility)) {
    query['Accessibility'] = request.accessibility;
  }
  if (!$isNull(request.dataSourceTypes)) {
    query['DataSourceTypes'] = request.dataSourceTypes;
  }
  if (!$isNull(request.dataTypes)) {
    query['DataTypes'] = request.dataTypes;
  }
  if (!$isNull(request.edition)) {
    query['Edition'] = request.edition;
  }
  if (!$isNull(request.label)) {
    query['Label'] = request.label;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.order)) {
    query['Order'] = request.order;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.properties)) {
    query['Properties'] = request.properties;
  }
  if (!$isNull(request.provider)) {
    query['Provider'] = request.provider;
  }
  if (!$isNull(request.shareScope)) {
    query['ShareScope'] = request.shareScope;
  }
  if (!$isNull(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!$isNull(request.sourceDatasetId)) {
    query['SourceDatasetId'] = request.sourceDatasetId;
  }
  if (!$isNull(request.sourceId)) {
    query['SourceId'] = request.sourceId;
  }
  if (!$isNull(request.sourceTypes)) {
    query['SourceTypes'] = request.sourceTypes;
  }
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListDatasets',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Lists the datasets in a workspace.
 *
 * @param request ListDatasetsRequest
 * @return ListDatasetsResponse
 */
async function listDatasets(request: ListDatasetsRequest): ListDatasetsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listDatasetsWithOptions(request, headers, runtime);
}

model ListExperimentRequest {
  labels?: string(name='Labels', description='The tag filter conditions. Multiple conditions are separated by commas (,). The format of a single condition filter is `key=value`.', example='is_evaluation:true'),
  maxResults?: long(name='MaxResults', description='The maximum number of entries in the request. Default value: 10.', example='10'),
  name?: string(name='Name', description='The experiment name.', example='exp-test'),
  options?: {
    matchNameExactly?: string(name='match_name_exactly', description='Specifies whether to exactly match the experiment by name. Valid values: true and false.', example='true'),
  }(name='Options', description='The optional parameters.'),
  order?: string(name='Order', description='The order of specific fields of results in a paged query (ascending or descending).

*   ASC: ascending order
*   DESC: descending order. This is the default value.', example='DESC'),
  orderBy?: string(name='OrderBy', description='The strings used for sorting. The following fields can be used for sorting: GmtCreateTime, Name, GmtModifiedTime, and ExperimentId. The sorting order can be ASC (default) and DESC.', example='GmtCreateTime DESC,Name ASC'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value starts from 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  pageToken?: long(name='PageToken', description='The pagination token, which starts from 0. Default value: 0.', example='0'),
  sortBy?: string(name='SortBy', description='The field used for sorting. The GmtCreateTime field is used.', example='GmtCreateTime'),
  verbose?: boolean(name='Verbose', description='Specifies whether to obtain the LatestRun value that is related to the experiment.', example='false'),
  workspaceId?: string(name='WorkspaceId', description='The ID of the workspace to which the experiment belongs. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.

>  If you do not specify a workspace ID, the system returns the experiments in the default workspace.', example='151739'),
}

model ListExperimentShrinkRequest {
  labels?: string(name='Labels', description='The tag filter conditions. Multiple conditions are separated by commas (,). The format of a single condition filter is `key=value`.', example='is_evaluation:true'),
  maxResults?: long(name='MaxResults', description='The maximum number of entries in the request. Default value: 10.', example='10'),
  name?: string(name='Name', description='The experiment name.', example='exp-test'),
  optionsShrink?: string(name='Options', description='The optional parameters.'),
  order?: string(name='Order', description='The order of specific fields of results in a paged query (ascending or descending).

*   ASC: ascending order
*   DESC: descending order. This is the default value.', example='DESC'),
  orderBy?: string(name='OrderBy', description='The strings used for sorting. The following fields can be used for sorting: GmtCreateTime, Name, GmtModifiedTime, and ExperimentId. The sorting order can be ASC (default) and DESC.', example='GmtCreateTime DESC,Name ASC'),
  pageNumber?: int32(name='PageNumber', description='The page number. The value starts from 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  pageToken?: long(name='PageToken', description='The pagination token, which starts from 0. Default value: 0.', example='0'),
  sortBy?: string(name='SortBy', description='The field used for sorting. The GmtCreateTime field is used.', example='GmtCreateTime'),
  verbose?: boolean(name='Verbose', description='Specifies whether to obtain the LatestRun value that is related to the experiment.', example='false'),
  workspaceId?: string(name='WorkspaceId', description='The ID of the workspace to which the experiment belongs. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.

>  If you do not specify a workspace ID, the system returns the experiments in the default workspace.', example='151739'),
}

model ListExperimentResponseBody = {
  experiments?: [
    Experiment
  ](name='Experiments', description='The list of experiments.'),
  nextPageToken?: long(name='NextPageToken', description='The pagination token. It can be used in the next request to retrieve a new page of results.', example='0'),
  totalCount?: long(name='TotalCount', description='The total number of entries.', example='5'),
  requestId?: string(name='requestId', description='The request ID.', example='0C6835C5-A424-5AFB-ACC2-F1E3CA1ABF7C'),
}

model ListExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListExperimentResponseBody(name='body'),
}

/**
 * @summary Lists experiments.
 *
 * @param tmpReq ListExperimentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListExperimentResponse
 */
@context("listExperimentWithContext")
async function listExperimentWithOptions(tmpReq: ListExperimentRequest, headers: map[string]string, runtime: $RuntimeOptions): ListExperimentResponse {
  tmpReq.validate();
  var request = new ListExperimentShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.options)) {
    request.optionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.options, 'Options', 'json');
  }
  var query : map[string]any = {};
  if (!$isNull(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!$isNull(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.optionsShrink)) {
    query['Options'] = request.optionsShrink;
  }
  if (!$isNull(request.order)) {
    query['Order'] = request.order;
  }
  if (!$isNull(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.pageToken)) {
    query['PageToken'] = request.pageToken;
  }
  if (!$isNull(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!$isNull(request.verbose)) {
    query['Verbose'] = request.verbose;
  }
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListExperiment',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Lists experiments.
 *
 * @param request ListExperimentRequest
 * @return ListExperimentResponse
 */
async function listExperiment(request: ListExperimentRequest): ListExperimentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listExperimentWithOptions(request, headers, runtime);
}

model ListFeaturesRequest {
  names?: string(name='Names', example='PaiConsole:IntegrateWithWorkspace'),
}

model ListFeaturesResponseBody = {
  features?: [ string ](name='Features'),
  requestId?: string(name='RequestId', example='5A14FA81-DD4E-******-6343FE44B941'),
  totalCount?: long(name='TotalCount', example='2'),
}

model ListFeaturesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFeaturesResponseBody(name='body'),
}

/**
 * @summary 列举特性
 *
 * @param request ListFeaturesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFeaturesResponse
 */
@context("listFeaturesWithContext")
async function listFeaturesWithOptions(request: ListFeaturesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListFeaturesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.names)) {
    query['Names'] = request.names;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListFeatures',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/features`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 列举特性
 *
 * @param request ListFeaturesRequest
 * @return ListFeaturesResponse
 */
async function listFeatures(request: ListFeaturesRequest): ListFeaturesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listFeaturesWithOptions(request, headers, runtime);
}

model ListImageLabelsRequest {
  imageId?: string(name='ImageId', description='The image ID. You can call [ListImages](https://help.aliyun.com/document_detail/449118.html) to obtain the image ID.', example='image-4c62******53uor'),
  labelFilter?: string(name='LabelFilter', description='The tag filter conditions, separated with commas (,). The format of a single condition filter is `key=value`. Takes effect independently from LabelKeys.', example='system.framework=XGBoost 1.6.0,system.official=true'),
  labelKeys?: string(name='LabelKeys', description='The tag keys, separated with commas (,). System tags start with system and take effect independently from LabelFilter.', example='system.framework,system.official'),
  region?: string(name='Region', description='The region where the image resides.', example='cn-shanghai'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='12345'),
}

model ListImageLabelsResponseBody = {
  labels?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='system.chipType'),
      value?: string(name='Value', description='The tag value.', example='GPU'),
    }
  ](name='Labels', description='The image tags.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  totalCount?: long(name='TotalCount', description='The total number of the images that meet the filter conditions.', example='2'),
}

model ListImageLabelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListImageLabelsResponseBody(name='body'),
}

/**
 * @summary Lists all tags of an image.
 *
 * @param request ListImageLabelsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListImageLabelsResponse
 */
@context("listImageLabelsWithContext")
async function listImageLabelsWithOptions(request: ListImageLabelsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListImageLabelsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!$isNull(request.labelFilter)) {
    query['LabelFilter'] = request.labelFilter;
  }
  if (!$isNull(request.labelKeys)) {
    query['LabelKeys'] = request.labelKeys;
  }
  if (!$isNull(request.region)) {
    query['Region'] = request.region;
  }
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListImageLabels',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/image/labels`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Lists all tags of an image.
 *
 * @param request ListImageLabelsRequest
 * @return ListImageLabelsResponse
 */
async function listImageLabels(request: ListImageLabelsRequest): ListImageLabelsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listImageLabelsWithOptions(request, headers, runtime);
}

model ListImagesRequest {
  accessibility?: string(name='Accessibility', description='The visibility of the image. This parameter is valid only for custom images.

*   PUBLIC: The image is visible to all users.
*   PRIVATE: The image is visible only to you and the administrator of the workspace.', example='PUBLIC'),
  imageUri?: string(name='ImageUri'),
  labels?: string(name='Labels', description='The tag filter conditions. Multiple conditions are separated by commas (,). The format of a single condition filter is `key=value`. The following keys are supported:

*   system.chipType
*   system.dsw.cudaVersion
*   system.dsw.fromImageId
*   system.dsw.fromInstanceId
*   system.dsw.id
*   system.dsw.os
*   system.dsw.osVersion
*   system.dsw.resourceType
*   system.dsw.rootImageId
*   system.dsw.stage
*   system.dsw.tag
*   system.dsw.type
*   system.framework
*   system.origin
*   system.pythonVersion
*   system.source
*   system.supported.dlc
*   system.supported.dsw', example='system.framework=XGBoost 1.6.0,system.official=true'),
  name?: string(name='Name', description='The image name. Fuzzy match is supported.', example='tensorflow_2.9'),
  order?: string(name='Order', description='The order in which the entries are sorted by the specific field on the returned page. This parameter must be used together with SortBy. Default value: ASC. Valid values:

*   ASC: ascending order
*   DESC: descending order.', example='DESC'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20.', example='20'),
  query?: string(name='Query', description='The image name and description that are used for fuzzy search.', example='name'),
  sortBy?: string(name='SortBy', description='The field used for sorting. The GmtCreateTime field is used.', example='GmtCreateTime'),
  verbose?: boolean(name='Verbose', description='Specifies whether to display non-essential information, which contains tags. Valid values:

*   true
*   false', example='true'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='20******55'),
}

model ListImagesResponseBody = {
  images?: [ 
    {
      accessibility?: string(name='Accessibility', description='The accessibility of the image. Valid values:

*   PUBLIC: All members can access the image.
*   PRIVATE: Only the creator can access the image.', example='PUBLIC'),
      description?: string(name='Description', description='The image description.', example='desc'),
      gmtCreateTime?: string(name='GmtCreateTime', description='The time when the image is created, in UTC. The time follows the ISO 8601 standard.', example='2021-01-21T17:12:35.232Z'),
      gmtModifiedTime?: string(name='GmtModifiedTime', description='The time when the image is modified, in UTC. The time follows the ISO 8601 standard.', example='2021-01-21T17:12:35.232Z'),
      imageId?: string(name='ImageId', description='The image ID.', example='image-tzi7f9******s45t'),
      imageUri?: string(name='ImageUri', description='The image address, which includes the version number.'),
      labels?: [ 
        {
          key?: string(name='Key', description='The tag key.', example='system.chipType'),
          value?: string(name='Value', description='The tag value.', example='GPU'),
        }
      ](name='Labels', description='The image tags.'),
      name?: string(name='Name', description='The image name.', example='tensorflow_2.9'),
      parentUserId?: string(name='ParentUserId', description='The ID of the Alibaba Cloud account.', example='15577******82932'),
      size?: int32(name='Size', description='The image size. Unit: GB.', example='2'),
      sourceId?: string(name='SourceId', description='镜像来源 ID'),
      sourceType?: string(name='SourceType', description='镜像来源类型'),
      userId?: string(name='UserId', description='The user ID.', example='15577******82932'),
      workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='20******55'),
    }
  ](name='Images', description='The images.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  totalCount?: long(name='TotalCount', description='The total number of returned images.', example='2'),
}

model ListImagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListImagesResponseBody(name='body'),
}

/**
 * @summary Queries a list of images.
 *
 * @param request ListImagesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListImagesResponse
 */
@context("listImagesWithContext")
async function listImagesWithOptions(request: ListImagesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListImagesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.accessibility)) {
    query['Accessibility'] = request.accessibility;
  }
  if (!$isNull(request.imageUri)) {
    query['ImageUri'] = request.imageUri;
  }
  if (!$isNull(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.order)) {
    query['Order'] = request.order;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.query)) {
    query['Query'] = request.query;
  }
  if (!$isNull(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!$isNull(request.verbose)) {
    query['Verbose'] = request.verbose;
  }
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListImages',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/images`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of images.
 *
 * @param request ListImagesRequest
 * @return ListImagesResponse
 */
async function listImages(request: ListImagesRequest): ListImagesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listImagesWithOptions(request, headers, runtime);
}

model ListMembersRequest {
  memberName?: string(name='MemberName', description='The member name. Fuzzy match is supported.', example='zhangsan'),
  pageNumber?: long(name='PageNumber', description='The page number of the workspace list. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20.', example='20'),
  roles?: string(name='Roles', description='The roles that are used to filter members. Multiple roles are separated by commas (,). Valid values:

*   PAI.AlgoDeveloper: algorithm developer
*   PAI.AlgoOperator: algorithm O\\\\&M engineer
*   PAI.LabelManager: labeling administrator
*   PAI.MaxComputeDeveloper: MaxCompute developer
*   PAI.WorkspaceAdmin: administrator
*   PAI.WorkspaceGuest: guest
*   PAI.WorkspaceOwner: owner', example='PAI.AlgoDeveloper'),
}

model ListMembersResponseBody = {
  members?: [ 
    {
      accountName?: string(name='AccountName'),
      accountType?: string(name='AccountType'),
      displayName?: string(name='DisplayName', description='The display name of the member.', example='myDisplayName'),
      gmtCreateTime?: string(name='GmtCreateTime', description='The time when the user is created, in UTC. The time follows the ISO 8601 standard.', example='2021-01-21T17:12:35.232Z'),
      memberId?: string(name='MemberId', description='The member ID.', example='14588*****51688039'),
      memberName?: string(name='MemberName', description='The username.', example='user1'),
      roles?: [ string ](name='Roles', description='The list of roles.'),
      userId?: string(name='UserId', description='The user ID.', example='215139******88039'),
    }
  ](name='Members', description='The members.'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  totalCount?: long(name='TotalCount', description='The number of members that meet the filter conditions.', example='1'),
}

model ListMembersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMembersResponseBody(name='body'),
}

/**
 * @summary Obtains the members in a workspace.
 *
 * @param request ListMembersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMembersResponse
 */
@context("listMembersWithContext")
async function listMembersWithOptions(WorkspaceId: string, request: ListMembersRequest, headers: map[string]string, runtime: $RuntimeOptions): ListMembersResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.memberName)) {
    query['MemberName'] = request.memberName;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.roles)) {
    query['Roles'] = request.roles;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMembers',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}/members`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the members in a workspace.
 *
 * @param request ListMembersRequest
 * @return ListMembersResponse
 */
async function listMembers(WorkspaceId: string, request: ListMembersRequest): ListMembersResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listMembersWithOptions(WorkspaceId, request, headers, runtime);
}

model ListModelVersionsRequest {
  approvalStatus?: string(name='ApprovalStatus', description='The approval status based on which the model versions are queried. Valid values:

*   Pending
*   Approved
*   Rejected', example='Approved'),
  formatType?: string(name='FormatType', description='The model format used to filter model versions. Valid values:

*   OfflineModel
*   SavedModel
*   Keras H5
*   Frozen Pb
*   Caffe Prototxt
*   TorchScript
*   XGBoost
*   PMML
*   AlinkModel
*   ONNX', example='SavedModel'),
  frameworkType?: string(name='FrameworkType', description='The framework used to filter model versions.

*   Pytorch -XGBoost
*   Keras
*   Caffe
*   Alink
*   Xflow
*   TensorFlow', example='TensorFlow'),
  label?: string(name='Label', description='The label. Model versions whose label key or label value contains a specific label are filtered.', example='key1'),
  order?: string(name='Order', description='The order in which the entries are sorted by the specific field on the returned page. Default value: ASC.

*   ASC
*   DESC', example='DESC'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10.', example='10'),
  sortBy?: string(name='SortBy', description='The field used to sort the results. The GmtCreateTime field is used for sorting.', example='GmtCreateTime'),
  sourceId?: string(name='SourceId', description='The source ID.

*   If the source type is Custom, this field is not limited.
*   If the source type is PAIFlow or TrainingService, the format is:

<!---->

    region=<region_id>,workspaceId=<workspace_id>,kind=<kind>,id=<id>

Take note of the following parameters:

*   region is the region ID.
*   workspaceId is the ID of the workspace.
*   kind is the type. Valid values: PipelineRun (PAIFlow) and ServiceJob (training service).
*   id is a unique identifier.', example='region=cn-shanghai,workspaceId=13**,kind=PipelineRun,id=run-sakdb****jdf'),
  sourceType?: string(name='SourceType', description='The source type used to filter model versions. Valid values:

*   Custom (default)
*   PAIFlow
*   TrainingService', example='PAIFlow'),
  versionName?: string(name='VersionName', description='The model version used to filter model versions.', example='1.0.1'),
}

model ListModelVersionsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC***3C83E'),
  totalCount?: long(name='TotalCount', description='The total number of model versions.', example='15'),
  versions?: [
    ModelVersion
  ](name='Versions', description='The model versions.'),
}

model ListModelVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModelVersionsResponseBody(name='body'),
}

/**
 * @summary Queries a list of model versions.
 *
 * @param request ListModelVersionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListModelVersionsResponse
 */
@context("listModelVersionsWithContext")
async function listModelVersionsWithOptions(ModelId: string, request: ListModelVersionsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListModelVersionsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.approvalStatus)) {
    query['ApprovalStatus'] = request.approvalStatus;
  }
  if (!$isNull(request.formatType)) {
    query['FormatType'] = request.formatType;
  }
  if (!$isNull(request.frameworkType)) {
    query['FrameworkType'] = request.frameworkType;
  }
  if (!$isNull(request.label)) {
    query['Label'] = request.label;
  }
  if (!$isNull(request.order)) {
    query['Order'] = request.order;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!$isNull(request.sourceId)) {
    query['SourceId'] = request.sourceId;
  }
  if (!$isNull(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!$isNull(request.versionName)) {
    query['VersionName'] = request.versionName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListModelVersions',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/models/${$URL.percentEncode(ModelId)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of model versions.
 *
 * @param request ListModelVersionsRequest
 * @return ListModelVersionsResponse
 */
async function listModelVersions(ModelId: string, request: ListModelVersionsRequest): ListModelVersionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listModelVersionsWithOptions(ModelId, request, headers, runtime);
}

model ListModelsRequest {
  collections?: string(name='Collections', description='The collection where the model is located. You can specify multiple collections and separate them with commas (,).', example='AI4D,QuickStart'),
  conditions?: [ 
    {
      column?: string(name='Column'),
      operator?: string(name='Operator'),
      value?: string(name='Value'),
    }
  ](name='Conditions'),
  domain?: string(name='Domain', description='The domain. Only models in the domain are returned. Valid values: nlp (Natural Language Processing) and cv (Computer Vision).', example='nlp'),
  label?: string(name='Label', description='The label. Models whose label key or label value contains a specific label are filtered.', example='key1'),
  modelName?: string(name='ModelName', description='The model name used to filter the returned models.'),
  modelType?: string(name='ModelType', description='The model type.', example='Endpoint'),
  order?: string(name='Order', description='The order in which the entries are sorted by the specific field on the returned page. Default value: ASC.

*   ASC
*   DESC', example='DESC'),
  origin?: string(name='Origin', description='The model source used to filter the models that belong to a community or organization, such as ModelScope and Hugging Face.', example='ModelScope'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10.', example='10'),
  provider?: string(name='Provider', description='The provider. If you configure this parameter, only the models exposed by the provider are returned. If you leave this parameter empty, only models owned by the user are returned.', example='pai'),
  query?: string(name='Query', description='The query condition. For example, if you set the value to nlp, all models that match ModelName, Domain, Task, LabelKey, and LabelValue are returned.', example='nlp'),
  sortBy?: string(name='SortBy', description='The field used to sort the results. The GmtCreateTime field is used for sorting.', example='GmtCreateTime'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='key1'),
      value?: string(name='Value', description='The tag value.', example='value1'),
    }
  ](name='Tag', description='The tags of the model.'),
  task?: string(name='Task', description='The task used to filter the models that belong to the task type. Example: text-classification.', example='text-classification'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. Only models in this workspace are queried. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='324**'),
}

model ListModelsShrinkRequest {
  collections?: string(name='Collections', description='The collection where the model is located. You can specify multiple collections and separate them with commas (,).', example='AI4D,QuickStart'),
  conditionsShrink?: string(name='Conditions'),
  domain?: string(name='Domain', description='The domain. Only models in the domain are returned. Valid values: nlp (Natural Language Processing) and cv (Computer Vision).', example='nlp'),
  label?: string(name='Label', description='The label. Models whose label key or label value contains a specific label are filtered.', example='key1'),
  modelName?: string(name='ModelName', description='The model name used to filter the returned models.'),
  modelType?: string(name='ModelType', description='The model type.', example='Endpoint'),
  order?: string(name='Order', description='The order in which the entries are sorted by the specific field on the returned page. Default value: ASC.

*   ASC
*   DESC', example='DESC'),
  origin?: string(name='Origin', description='The model source used to filter the models that belong to a community or organization, such as ModelScope and Hugging Face.', example='ModelScope'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10.', example='10'),
  provider?: string(name='Provider', description='The provider. If you configure this parameter, only the models exposed by the provider are returned. If you leave this parameter empty, only models owned by the user are returned.', example='pai'),
  query?: string(name='Query', description='The query condition. For example, if you set the value to nlp, all models that match ModelName, Domain, Task, LabelKey, and LabelValue are returned.', example='nlp'),
  sortBy?: string(name='SortBy', description='The field used to sort the results. The GmtCreateTime field is used for sorting.', example='GmtCreateTime'),
  tagShrink?: string(name='Tag', description='The tags of the model.'),
  task?: string(name='Task', description='The task used to filter the models that belong to the task type. Example: text-classification.', example='text-classification'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. Only models in this workspace are queried. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='324**'),
}

model ListModelsResponseBody = {
  models?: [
    Model
  ](name='Models', description='The models.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  totalCount?: long(name='TotalCount', description='The total number of models.', example='15'),
}

model ListModelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModelsResponseBody(name='body'),
}

/**
 * @summary Queries a list of models.
 *
 * @param tmpReq ListModelsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListModelsResponse
 */
@context("listModelsWithContext")
async function listModelsWithOptions(tmpReq: ListModelsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListModelsResponse {
  tmpReq.validate();
  var request = new ListModelsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.conditions)) {
    request.conditionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.conditions, 'Conditions', 'json');
  }
  if (!$isNull(tmpReq.tag)) {
    request.tagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tag, 'Tag', 'json');
  }
  var query : map[string]any = {};
  if (!$isNull(request.collections)) {
    query['Collections'] = request.collections;
  }
  if (!$isNull(request.conditionsShrink)) {
    query['Conditions'] = request.conditionsShrink;
  }
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.label)) {
    query['Label'] = request.label;
  }
  if (!$isNull(request.modelName)) {
    query['ModelName'] = request.modelName;
  }
  if (!$isNull(request.modelType)) {
    query['ModelType'] = request.modelType;
  }
  if (!$isNull(request.order)) {
    query['Order'] = request.order;
  }
  if (!$isNull(request.origin)) {
    query['Origin'] = request.origin;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.provider)) {
    query['Provider'] = request.provider;
  }
  if (!$isNull(request.query)) {
    query['Query'] = request.query;
  }
  if (!$isNull(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!$isNull(request.tagShrink)) {
    query['Tag'] = request.tagShrink;
  }
  if (!$isNull(request.task)) {
    query['Task'] = request.task;
  }
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListModels',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/models`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of models.
 *
 * @param request ListModelsRequest
 * @return ListModelsResponse
 */
async function listModels(request: ListModelsRequest): ListModelsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listModelsWithOptions(request, headers, runtime);
}

model ListPermissionsResponseBody = {
  permissions?: [ 
    {
      permissionCode?: string(name='PermissionCode', description='The permission name, which is unique in a region. For more information about permissions, see [Appendix: Roles and permissions](https://help.aliyun.com/document_detail/2840449.html). The example value PaiDLC:GetTensorboard indicates the permission to view details about a TensorBoard job on the Deep Learning Containers (DLC) page.', example='PaiDLC:GetTensorboard'),
      permissionRules?: [ 
        {
          accessibility?: string(name='Accessibility', description='The accessibility of the permission rule. Valid values:

*   PUBLIC: All members in the workspace can access the permission rule.
*   PRIVATE: Only the creator can access the permission rule.
*   ANY: All users can access the permission rule.', example='PRIVATE'),
          entityAccessType?: string(name='EntityAccessType', description='The type of access. If you set Accessibility to PUBLIC, all users can access the workspace. This parameter is invalid. If you set Accessibility to PRIVATE, the permissions are determined based on the value of EntityAccessType. The value of EntityAccessType can be:

*   CREATOR: Only the creator can access the workspace.
*   ANY: All users can access the workspace.', example='CREATOR'),
        }
      ](name='PermissionRules', description='The permission rules.'),
    }
  ](name='Permissions', description='The permissions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='2AE63638-5420-56DC-B******8174039A0'),
  totalCount?: long(name='TotalCount', description='The number of permissions that meet the filter conditions.', example='1'),
}

model ListPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPermissionsResponseBody(name='body'),
}

/**
 * @summary Lists the permissions that a user has in a workspace.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPermissionsResponse
 */
@context("listPermissionsWithContext")
async function listPermissionsWithOptions(WorkspaceId: string, headers: map[string]string, runtime: $RuntimeOptions): ListPermissionsResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ListPermissions',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}/permissions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Lists the permissions that a user has in a workspace.
 *
 * @return ListPermissionsResponse
 */
async function listPermissions(WorkspaceId: string): ListPermissionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listPermissionsWithOptions(WorkspaceId, headers, runtime);
}

model ListProductsRequest {
  productCodes?: string(name='ProductCodes', example='PAI_isolate'),
  serviceCodes?: string(name='ServiceCodes', example='oss'),
  verbose?: boolean(name='Verbose'),
}

model ListProductsResponseBody = {
  products?: [ 
    {
      hasPermissionToPurchase?: boolean(name='HasPermissionToPurchase'),
      isPurchased?: boolean(name='IsPurchased', example='true'),
      productCode?: string(name='ProductCode', example='DataWorks_isolate'),
      productId?: string(name='ProductId'),
      purchaseUrl?: string(name='PurchaseUrl', example='https://common-buy.aliy'),
    }
  ](name='Products'),
  requestId?: string(name='RequestId', example='1e195c5116124202371861018d5bde'),
  services?: [ 
    {
      isOpen?: boolean(name='IsOpen', example='true'),
      openUrl?: string(name='OpenUrl'),
      serviceCode?: string(name='ServiceCode', example='oss'),
    }
  ](name='Services'),
}

model ListProductsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProductsResponseBody(name='body'),
}

/**
 * @summary 列举产品
 *
 * @param request ListProductsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListProductsResponse
 */
@context("listProductsWithContext")
async function listProductsWithOptions(request: ListProductsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListProductsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.productCodes)) {
    query['ProductCodes'] = request.productCodes;
  }
  if (!$isNull(request.serviceCodes)) {
    query['ServiceCodes'] = request.serviceCodes;
  }
  if (!$isNull(request.verbose)) {
    query['Verbose'] = request.verbose;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListProducts',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/products`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 列举产品
 *
 * @param request ListProductsRequest
 * @return ListProductsResponse
 */
async function listProducts(request: ListProductsRequest): ListProductsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductsWithOptions(request, headers, runtime);
}

model ListQuotasRequest {
  name?: string(name='Name', description='The quota name. Fuzzy search is supported.', example='quota-name'),
}

model ListQuotasResponseBody = {
  quotas?: [ 
    {
      displayName?: string(name='DisplayName', description='The alias of the quota.'),
      id?: string(name='Id', description='The quota ID.', example='1828233'),
      mode?: string(name='Mode', description='The billing method. Valid values:

*   isolate: subscription
*   share: pay-as-you-go', example='isolate'),
      name?: string(name='Name', description='The quota name.', example='quota-name'),
      productCode?: string(name='ProductCode', description='The product code. Valid values:

*   PAI_isolate: CPU subscription resource groups of PAI
*   PAI_share: GPU pay-as-you-go resource groups of PAI', example='MaxCompute_share'),
      quotaType?: string(name='QuotaType', description='The quota type. Valid value:

PAI: indicates GPU resource groups of MaxCompute.', example='MaxCompute'),
      specs?: [ 
        {
          name?: string(name='Name', description='The specification name.', example='cu'),
          type?: string(name='Type', description='The specification type. The parameter can be left empty.', example='string'),
          value?: string(name='Value', description='The specification value.', example='11500'),
        }
      ](name='Specs', description='The quota specifications.', example='{\\\\"cu\\\\":\\\\"11500\\\\",\\\\"minCu\\\\":\\\\"2300\\\\",\\\\"parentId\\\\":\\\\"0\\\\"}'),
    }
  ](name='Quotas', description='The returned quotas.'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  totalCount?: long(name='TotalCount', description='The number of quotas that meet the filter conditions.', example='1'),
}

model ListQuotasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQuotasResponseBody(name='body'),
}

/**
 * @summary Obtains the list of quotas.
 *
 * @param request ListQuotasRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQuotasResponse
 */
@context("listQuotasWithContext")
async function listQuotasWithOptions(request: ListQuotasRequest, headers: map[string]string, runtime: $RuntimeOptions): ListQuotasResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListQuotas',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/quotas`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the list of quotas.
 *
 * @param request ListQuotasRequest
 * @return ListQuotasResponse
 */
async function listQuotas(request: ListQuotasRequest): ListQuotasResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listQuotasWithOptions(request, headers, runtime);
}

model ListResourcesRequest {
  groupName?: string(name='GroupName', description='The name of the resource group. You can call [ListResources](https://help.aliyun.com/document_detail/449143.html) to obtain the name of the resource group.', example='group'),
  labels?: string(name='Labels', description='Tag-based filter conditions. Multiple conditions are separated by commas (,). Only resources that meet all the specified tag-based filter conditions are returned.

This parameter is available only for resources whose ProductType is ACS.', example='system.supported.dsw=true,system.supported.dlc=true'),
  option?: string(name='Option', description='The operation to perform. Valid values:

*   ListResourceByWorkspace: obtains the resources in the workspace. This is the default value.
*   ListResource: obtains the resources of the user.', example='ListResourceByWorkspace'),
  pageNumber?: long(name='PageNumber', description='The page number. The pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20.', example='20'),
  productTypes?: string(name='ProductTypes', description='**This field is no longer used and will be removed. Use the ResourceType field instead.', example='MaxCompute'),
  quotaIds?: string(name='QuotaIds', description='The quota IDs, which are separated by commas (,). Only resources that contain all the specified quotas are returned.

>  This parameter is available only for resources whose ResourceTypes is ACS.', example='quota-k******da,quota-cd******w'),
  resourceName?: string(name='ResourceName', description='The resource name. The value must meet the following requirements:

*   The name must be 3 to 28 characters in length.
*   The name is unique in the region.', example='resource'),
  resourceTypes?: string(name='ResourceTypes', description='The resource types. Valid values:

*   MaxCompute
*   ECS
*   Lingjun
*   ACS
*   FLINK', example='MaxCompute'),
  verbose?: boolean(name='Verbose', description='Specifies whether to show detailed information, which includes the Quotas field. Valid values:

*   true (default)
*   false', example='true'),
  verboseFields?: string(name='VerboseFields', description='The fields to return. Multiple fields are separated by commas (,). Valid values:

*   Quota
*   Label
*   IsDefault', example='Quota,IsDefault'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.

*   This parameter is required when the Option parameter is set to ListResourceByWorkspace.
*   You do not need to configure this parameter when the Option parameter is set to ListResource.', example='123'),
}

model ListResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='1e195c5116124202371861018d5bde'),
  resources?: [ 
    {
      encryption?: {
        algorithm?: string(name='Algorithm', description='The encryption algorithm.', example='AESCTR'),
        enabled?: boolean(name='Enabled', description='Indicates whether the resources are encrypted.', example='false'),
        key?: string(name='Key', description='The primary key for the encryption.', example='DEFAULT'),
      }(name='Encryption', description='The encryption information, which is valid only for MaxCompute resources.'),
      envType?: string(name='EnvType', description='The environment type. Valid values:

*   dev: development environment
*   prod: production environment', example='prod'),
      executor?: {
        ownerId?: string(name='OwnerId', description='This parameter is invalid and deprecated.', example='110973******7793'),
      }(name='Executor', description='This parameter is invalid and deprecated.'),
      gmtCreateTime?: string(name='GmtCreateTime', description='The time when the resource group is created, in UTC. The time follows the ISO 8601 standard.', example='2021-01-21T17:12:35.232Z'),
      groupName?: string(name='GroupName', description='The name of the resource group, which is unique within the Alibaba Cloud account.', example='groupName'),
      id?: string(name='Id', description='The resource ID.', example='123'),
      isDefault?: boolean(name='IsDefault', description='Indicates whether the resource is the default resource. Each type of resources has a default resource. Valid values:

*   true
*   false', example='true'),
      labels?: [ 
        {
          key?: string(name='Key', description='The tag key.', example='system.supported.dsw'),
          value?: string(name='Value', description='The tag value.', example='true'),
        }
      ](name='Labels', description='The tags.'),
      name?: string(name='Name', description='The resource name.', example='ResourceName'),
      productType?: string(name='ProductType', description='**This field is no longer used and will be removed. Use the ResourceType field.', example='MaxCompute'),
      quotas?: [ 
        {
          cardType?: string(name='CardType', description='The resource group type. Valid values:

*   CPU
*   GPU', example='cpu'),
          displayName?: string(name='DisplayName', description='The alias of the quota.'),
          id?: string(name='Id', description='The quota ID.', example='123'),
          mode?: string(name='Mode', description='The billing method. Valid values:

*   isolate: subscription
*   share: pay-as-you-go', example='develop'),
          name?: string(name='Name', description='The quota name.', example='QuotaName'),
          productCode?: string(name='ProductCode', description='The product code. Valid values:

*   PAI_isolate: CPU subscription resource groups of PAI
*   PAI_share: GPU pay-as-you-go resource groups of PAI
*   MaxCompute_share: pay-as-you-go resource groups of MaxCompute
*   MaxCompute_isolate: subscription resource groups of MaxCompute
*   DataWorks_isolate: subscription resource groups of DataWorks
*   DataWorks_share: pay-as-you-go resource groups of DataWorks
*   DLC_share: pay-as-you-go resource groups of Deep Learning Containers (DLC)', example='MaxCompute_isolate'),
          quotaType?: string(name='QuotaType', description='The quota type. Valid values:

*   PAI
*   MaxCompute
*   DLC', example='MaxCompute'),
          specs?: [ 
            {
              name?: string(name='Name', description='The specification name.', example='cu'),
              value?: string(name='Value', description='The specification description.', example='11500'),
            }
          ](name='Specs', description='The quota specifications.', example='{\\\\"cu\\\\":\\\\"11500\\\\",\\\\"minCu\\\\":\\\\"2300\\\\",\\\\"parentId\\\\":\\\\"0\\\\"}'),
        }
      ](name='Quotas', description='The quotas.'),
      resourceType?: string(name='ResourceType', description='The resource type. Valid values:

*   MaxCompute
*   DLC
*   FLINK', example='MaxCompute'),
      spec?: map[string]any(name='Spec', description='The resource specification.', example='对于MaxCompute {"Endpoint": "odps.alibaba-inc.com", "Project": "mignshi"}'),
      workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='123'),
    }
  ](name='Resources', description='The resources.'),
  totalCount?: long(name='TotalCount', description='The number of resources that meet the filter conditions.', example='2'),
}

model ListResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListResourcesResponseBody(name='body'),
}

/**
 * @summary Queries the resources that are associated with a workspace.
 *
 * @param request ListResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListResourcesResponse
 */
@context("listResourcesWithContext")
async function listResourcesWithOptions(request: ListResourcesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListResourcesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!$isNull(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!$isNull(request.option)) {
    query['Option'] = request.option;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.productTypes)) {
    query['ProductTypes'] = request.productTypes;
  }
  if (!$isNull(request.quotaIds)) {
    query['QuotaIds'] = request.quotaIds;
  }
  if (!$isNull(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!$isNull(request.resourceTypes)) {
    query['ResourceTypes'] = request.resourceTypes;
  }
  if (!$isNull(request.verbose)) {
    query['Verbose'] = request.verbose;
  }
  if (!$isNull(request.verboseFields)) {
    query['VerboseFields'] = request.verboseFields;
  }
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListResources',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/resources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the resources that are associated with a workspace.
 *
 * @param request ListResourcesRequest
 * @return ListResourcesResponse
 */
async function listResources(request: ListResourcesRequest): ListResourcesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourcesWithOptions(request, headers, runtime);
}

model ListRunMetricsRequest {
  key?: string(name='Key', description='The metric key of the run.

This parameter is required.', example='loss'),
  maxResults?: long(name='MaxResults', description='The maximum number of entries in the request. Default value: 10.', example='100'),
  pageToken?: long(name='PageToken', description='The pagination token, which starts from 0. Default value: 0.', example='0'),
}

model ListRunMetricsResponseBody = {
  metrics?: [
    RunMetric
  ](name='Metrics', description='The metrics.'),
  nextPageToken?: long(name='NextPageToken', description='The pagination token that is used to retrieve the next page. You do not need to specify this parameter for the first request. You must specify the pagination token in the result of the previous query. If the pagination token is 0, no next page exists. You can obtain the pagination token that is used to retrieve the next page in the value of the **NextPageToken** field.', example='0'),
  requestId?: string(name='requestId', description='Id of the request', example='ADF6D849-*****-7E7030F0CE53'),
}

model ListRunMetricsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRunMetricsResponseBody(name='body'),
}

/**
 * @summary Lists the metrics for a run.
 *
 * @param request ListRunMetricsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRunMetricsResponse
 */
@context("listRunMetricsWithContext")
async function listRunMetricsWithOptions(RunId: string, request: ListRunMetricsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListRunMetricsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.key)) {
    query['Key'] = request.key;
  }
  if (!$isNull(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.pageToken)) {
    query['PageToken'] = request.pageToken;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListRunMetrics',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/runs/${$URL.percentEncode(RunId)}/metrics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Lists the metrics for a run.
 *
 * @param request ListRunMetricsRequest
 * @return ListRunMetricsResponse
 */
async function listRunMetrics(RunId: string, request: ListRunMetricsRequest): ListRunMetricsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listRunMetricsWithOptions(RunId, request, headers, runtime);
}

model ListRunsRequest {
  experimentId?: string(name='ExperimentId', description='The ID of the experiment that the run belongs.', example='exp-1zpfthdx******'),
  gmtCreateTime?: string(name='GmtCreateTime', description='The time when the instance was created.', example='2021-01-30T12:51:33.028Z'),
  labels?: string(name='Labels', description='The label. Exact match is supported. Valid values:

*   Single-label query: Set the value to is_evaluation.
*   Multi-label query (not recommended in non-special scenarios and may have performance issues): Set the value to is_evaluation:true,LLM_evaluation:true. Multiple labels are separated with commas (,), indicating that the key-value pairs of multiple labels must be matched at the same time.', example='is_evaluation:true'),
  maxResults?: long(name='MaxResults', description='The maximum number of entries in the request. Default value: 10.', example='10'),
  name?: string(name='Name', description='The run name.', example='myName'),
  order?: string(name='Order', description='The order in which the entries are sorted by the specific field on the returned page. This parameter must be used together with SortBy.

*   ASC
*   DESC (default)', example='DESC'),
  orderBy?: string(name='OrderBy', description='The strings by which the results are sorted. The following parameters can be used to sort the results: GmtCreateTime and Name. The sorting order can be ASC (default) and DESC. Separate multiple strings with commas (,).', example='GmtCreateTime DESC,Name ASC'),
  pageNumber?: long(name='PageNumber', description='The page number. The value must be greater than 0. Default value: 1.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='10'),
  pageToken?: long(name='PageToken', description='The pagination token, which starts from 0. Default value: 0.', example='0'),
  sortBy?: string(name='SortBy', description='The field used for sorting. Valid values:

*   Name: the name of the run.
*   GmtCreateTime: the time when the run is created.', example='GmtCreateTime'),
  sourceId?: string(name='SourceId', description='The ID of the workload associated with the run.', example='job-rbvg5wzlj****'),
  sourceType?: string(name='SourceType', description='The type of the workload associated with the run.', example='TrainingService'),
  verbose?: boolean(name='Verbose', description='Specifies whether to show detailed information, including Metrics, Params, and Labels. Valid values:

*   true
*   false (default)', example='true'),
  workspaceId?: string(name='WorkspaceId', description='The ID of the workspace to which the experiment belongs. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.

>  If you do not specify a workspace ID, the system returns the runs of the default workspace.', example='22840'),
}

model ListRunsResponseBody = {
  nextPageToken?: long(name='NextPageToken', description='The pagination token that is used to retrieve the next page. You do not need to specify this parameter for the first request. You must specify the pagination token in the result of the previous query. If the pagination token is 0, no next page exists. You can obtain the pagination token that is used to retrieve the next page in the value of the **NextPageToken** field.', example='0'),
  runs?: [
    Run
  ](name='Runs', description='The runs.'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned. By default, this parameter is not returned.', example='1'),
  requestId?: string(name='requestId', description='The request ID.', example='ADF6D849-*****-7E7030F0CE53'),
}

model ListRunsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRunsResponseBody(name='body'),
}

/**
 * @summary Queries a list of runs.
 *
 * @param request ListRunsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRunsResponse
 */
@context("listRunsWithContext")
async function listRunsWithOptions(request: ListRunsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListRunsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.experimentId)) {
    query['ExperimentId'] = request.experimentId;
  }
  if (!$isNull(request.gmtCreateTime)) {
    query['GmtCreateTime'] = request.gmtCreateTime;
  }
  if (!$isNull(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!$isNull(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.order)) {
    query['Order'] = request.order;
  }
  if (!$isNull(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.pageToken)) {
    query['PageToken'] = request.pageToken;
  }
  if (!$isNull(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!$isNull(request.sourceId)) {
    query['SourceId'] = request.sourceId;
  }
  if (!$isNull(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!$isNull(request.verbose)) {
    query['Verbose'] = request.verbose;
  }
  if (!$isNull(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListRuns',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/runs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of runs.
 *
 * @param request ListRunsRequest
 * @return ListRunsResponse
 */
async function listRuns(request: ListRunsRequest): ListRunsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listRunsWithOptions(request, headers, runtime);
}

model ListUserConfigsRequest {
  categoryNames?: string(name='CategoryNames', description='The category. Currently, only DataPrivacyConfig is supported.', example='DataPrivacyConfig'),
  configKeys?: string(name='ConfigKeys', description='The configuration item keys. Currently, only customizePAIAssumedRole is supported.', example='customizePAIAssumedRole'),
}

model ListUserConfigsResponseBody = {
  configs?: [ 
    {
      categoryName?: string(name='CategoryName', description='The category. Currently, only DataPrivacyConfig is supported.', example='DataPrivacyConfig'),
      configKey?: string(name='ConfigKey', description='The key of the configuration item.', example='customizePAIAssumedRole'),
      configValue?: string(name='ConfigValue', description='The value of the configuration item.', example='role'),
      scope?: string(name='Scope', description='The scope. Currently, subUser and owner are supported.', example='subUser'),
    }
  ](name='Configs', description='The configurations list.'),
  requestId?: string(name='RequestId', description='The request ID.', example='sdjksdk-******-dsfds'),
  totalCount?: long(name='TotalCount', description='The number of items returned.', example='15'),
}

model ListUserConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserConfigsResponseBody(name='body'),
}

/**
 * @summary Queries user information.
 *
 * @param request ListUserConfigsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUserConfigsResponse
 */
@context("listUserConfigsWithContext")
async function listUserConfigsWithOptions(request: ListUserConfigsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListUserConfigsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.categoryNames)) {
    query['CategoryNames'] = request.categoryNames;
  }
  if (!$isNull(request.configKeys)) {
    query['ConfigKeys'] = request.configKeys;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListUserConfigs',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/userconfigs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries user information.
 *
 * @param request ListUserConfigsRequest
 * @return ListUserConfigsResponse
 */
async function listUserConfigs(request: ListUserConfigsRequest): ListUserConfigsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listUserConfigsWithOptions(request, headers, runtime);
}

model ListWorkspaceUsersRequest {
  userId?: string(name='UserId'),
  userName?: string(name='UserName', description='The display names of users who can be added to the workspace as members.', example='doctest****'),
}

model ListWorkspaceUsersResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='1e195c5116124202371861018d5bde'),
  totalCount?: long(name='TotalCount', description='The number of users who meet the filter conditions.', example='2'),
  users?: [ 
    {
      userId?: string(name='UserId', description='The user ID.', example='1611******3000'),
      userName?: string(name='UserName', description='The username.', example='she******mo'),
    }
  ](name='Users', description='The users.'),
}

model ListWorkspaceUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWorkspaceUsersResponseBody(name='body'),
}

/**
 * @summary Lists the users who do not belong to a workspace. These users can be added to the workspace as members.
 *
 * @param request ListWorkspaceUsersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListWorkspaceUsersResponse
 */
@context("listWorkspaceUsersWithContext")
async function listWorkspaceUsersWithOptions(WorkspaceId: string, request: ListWorkspaceUsersRequest, headers: map[string]string, runtime: $RuntimeOptions): ListWorkspaceUsersResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!$isNull(request.userName)) {
    query['UserName'] = request.userName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListWorkspaceUsers',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}/users`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Lists the users who do not belong to a workspace. These users can be added to the workspace as members.
 *
 * @param request ListWorkspaceUsersRequest
 * @return ListWorkspaceUsersResponse
 */
async function listWorkspaceUsers(WorkspaceId: string, request: ListWorkspaceUsersRequest): ListWorkspaceUsersResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listWorkspaceUsersWithOptions(WorkspaceId, request, headers, runtime);
}

model ListWorkspacesRequest {
  fields?: string(name='Fields', description='The list of returned fields of workspace details. Used to limit the fields in the returned results. Separate multiple fields with commas (,). Currently, only Id is supported, which is the workspace ID.', example='Id'),
  moduleList?: string(name='ModuleList', description='The modules, separated by commas (,). Default value: PAI.', example='PAI'),
  option?: string(name='Option', description='The query options. Valid values:

*   GetWorkspaces (default): Obtains a list of Workspaces.
*   GetResourceLimits: Obtains a list of ResourceLimits.', example='GetWorkspaces'),
  order?: string(name='Order', description='The order of results (ascending or descending). Valid values:

*   ASC: ascending order. This is the default value.
*   DESC: descending order.', example='ASC'),
  pageNumber?: long(name='PageNumber', description='The page number of the workspace list. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20.', example='20'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID. To obtain the ID of a resource group, see [View basic information of a resource group](https://help.aliyun.com/document_detail/151181.html).', example='rg-acfmwp7rky****'),
  sortBy?: string(name='SortBy', description='Specifies how to sort the results. Default value: GmtCreateTime. Valid values:

*   GmtCreateTime: Sort by the time when created.
*   GmtModifiedTime: Sort by the time when modified.', example='GmtCreateTime'),
  status?: string(name='Status', description='The workspace status. Valid values:

*   ENABLED
*   INITIALIZING
*   FAILURE
*   DISABLED
*   FROZEN
*   UPDATING', example='ENABLED'),
  userId?: string(name='UserId'),
  verbose?: boolean(name='Verbose', description='Specifies whether to display workspace details. Valid values:

*   false (default)
*   true', example='true'),
  workspaceIds?: string(name='WorkspaceIds', description='The workspace IDs. Separate multiple IDs by commas (,).', example='123,234'),
  workspaceName?: string(name='WorkspaceName', description='The name of the workspace.', example='abc'),
}

model ListWorkspacesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='8D7B2E70-F770-505B-A672-09F1D8F2EC1E'),
  resourceLimits?: map[string]any(name='ResourceLimits', description='The type and quantity of resources that can be activated in a workspace. This list is returned when the Option is set to GetResourceLimits. Valid values:

*   MaxCompute_share: pay-as-you-go MaxCompute
*   MaxCompute_isolate: subscription MaxCompute
*   DLC_share: pay-as-you-go DLC
*   PAI_Isolate: subscription PAI
*   PAI_share: pay-as-you-go PAI
*   DataWorks_isolate: subscription DataWorks
*   DataWorks_share: pay-as-you-go DataWorks', example='{
   "MaxCompute_share": 1,
   "MaxCompute_isolate": 1,
   "DLC_share": 1
}'),
  totalCount?: long(name='TotalCount', description='The number of workspaces that meet the query conditions.', example='1'),
  workspaces?: [ 
    {
      adminNames?: [ string ](name='AdminNames', description='The names of the administrator accounts.'),
      creator?: string(name='Creator', description='The user ID of the creator.', example='122424353535'),
      description?: string(name='Description', description='The description of the workspace.', example='workspace description example'),
      envTypes?: [ string ](name='EnvTypes', description='The environment types of the workspace.'),
      extraInfos?: map[string]any(name='ExtraInfos', description='the additional information. Only contains TenantId.', example='{"TenantId": "4286******98"}'),
      gmtCreateTime?: string(name='GmtCreateTime', description='The time when the workspace was created. The time (UTC+0) follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ss.SSSZ format.', example='2021-01-21T17:12:35.232Z'),
      gmtModifiedTime?: string(name='GmtModifiedTime', description='The time when the workspace was modified. The time (UTC+0) follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ss.SSSZ format.', example='2021-01-21T17:12:35.232Z'),
      isDefault?: boolean(name='IsDefault', description='Indicates whether the workspace is the default workspace.', example='false'),
      status?: string(name='Status', description='The status of the workspace.', example='ENABLED'),
      workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='123'),
      workspaceName?: string(name='WorkspaceName', description='The name of the workspace.', example='workspace-example'),
      resourceGroupId?: string(name='resourceGroupId', description='The resource group ID.', example='rg-acfmwp7rky****'),
    }
  ](name='Workspaces', description='The list of workspace details. This list is returned when Option is set to GetWorkspaces.'),
}

model ListWorkspacesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWorkspacesResponseBody(name='body'),
}

/**
 * @summary Lists all workspaces in a region.
 *
 * @description You can use the option parameter to specify query options, so as to obtain different information about the workspaces.
 *
 * @param request ListWorkspacesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListWorkspacesResponse
 */
@context("listWorkspacesWithContext")
async function listWorkspacesWithOptions(request: ListWorkspacesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListWorkspacesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.fields)) {
    query['Fields'] = request.fields;
  }
  if (!$isNull(request.moduleList)) {
    query['ModuleList'] = request.moduleList;
  }
  if (!$isNull(request.option)) {
    query['Option'] = request.option;
  }
  if (!$isNull(request.order)) {
    query['Order'] = request.order;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!$isNull(request.status)) {
    query['Status'] = request.status;
  }
  if (!$isNull(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!$isNull(request.verbose)) {
    query['Verbose'] = request.verbose;
  }
  if (!$isNull(request.workspaceIds)) {
    query['WorkspaceIds'] = request.workspaceIds;
  }
  if (!$isNull(request.workspaceName)) {
    query['WorkspaceName'] = request.workspaceName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListWorkspaces',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Lists all workspaces in a region.
 *
 * @description You can use the option parameter to specify query options, so as to obtain different information about the workspaces.
 *
 * @param request ListWorkspacesRequest
 * @return ListWorkspacesResponse
 */
async function listWorkspaces(request: ListWorkspacesRequest): ListWorkspacesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listWorkspacesWithOptions(request, headers, runtime);
}

model LogRunMetricsRequest {
  metrics?: [
    RunMetric
  ](name='Metrics', description='The metrics.'),
}

model LogRunMetricsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='ADF6D849-*****-7E7030F0CE53'),
}

model LogRunMetricsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: LogRunMetricsResponseBody(name='body'),
}

/**
 * @summary Logs multiple metrics for a run at a time.
 *
 * @param request LogRunMetricsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return LogRunMetricsResponse
 */
@context("logRunMetricsWithContext")
async function logRunMetricsWithOptions(RunId: string, request: LogRunMetricsRequest, headers: map[string]string, runtime: $RuntimeOptions): LogRunMetricsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.metrics)) {
    body['Metrics'] = request.metrics;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'LogRunMetrics',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/runs/${$URL.percentEncode(RunId)}/metrics/action/log`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Logs multiple metrics for a run at a time.
 *
 * @param request LogRunMetricsRequest
 * @return LogRunMetricsResponse
 */
async function logRunMetrics(RunId: string, request: LogRunMetricsRequest): LogRunMetricsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return logRunMetricsWithOptions(RunId, request, headers, runtime);
}

model PublishCodeSourceResponseBody = {
  codeSourceId?: string(name='CodeSourceId', description='The ID of the code source that is successfully published.', example='code-a797*******'),
  requestId?: string(name='RequestId', description='The request ID. You can use the ID to locate logs and troubleshoot issues.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model PublishCodeSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PublishCodeSourceResponseBody(name='body'),
}

/**
 * @summary Publishes a private code source to a workspace to make the code source publicly accessible.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishCodeSourceResponse
 */
@context("publishCodeSourceWithContext")
async function publishCodeSourceWithOptions(CodeSourceId: string, headers: map[string]string, runtime: $RuntimeOptions): PublishCodeSourceResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'PublishCodeSource',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/codesources/${$URL.percentEncode(CodeSourceId)}/publish`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Publishes a private code source to a workspace to make the code source publicly accessible.
 *
 * @return PublishCodeSourceResponse
 */
async function publishCodeSource(CodeSourceId: string): PublishCodeSourceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return publishCodeSourceWithOptions(CodeSourceId, headers, runtime);
}

model PublishDatasetResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A0F049F0-8D69-5BAC-8F10-B******A34C'),
}

model PublishDatasetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PublishDatasetResponseBody(name='body'),
}

/**
 * @summary Publishes a private dataset in a workspace.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishDatasetResponse
 */
@context("publishDatasetWithContext")
async function publishDatasetWithOptions(DatasetId: string, headers: map[string]string, runtime: $RuntimeOptions): PublishDatasetResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'PublishDataset',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/publish`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Publishes a private dataset in a workspace.
 *
 * @return PublishDatasetResponse
 */
async function publishDataset(DatasetId: string): PublishDatasetResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return publishDatasetWithOptions(DatasetId, headers, runtime);
}

model PublishImageResponseBody = {
  imageId?: string(name='ImageId', description='The image ID.', example='image-dk******fa'),
  requestId?: string(name='RequestId', description='The request ID.', example='A0F049F0-8D69-5BAC-8F10-B******A34C'),
}

model PublishImageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PublishImageResponseBody(name='body'),
}

/**
 * @summary Publishes an image. After the image is published, the visibility of the image is changed from PRIVATE to PUBLIC.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishImageResponse
 */
@context("publishImageWithContext")
async function publishImageWithOptions(ImageId: string, headers: map[string]string, runtime: $RuntimeOptions): PublishImageResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'PublishImage',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/images/${$URL.percentEncode(ImageId)}/publish`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Publishes an image. After the image is published, the visibility of the image is changed from PRIVATE to PUBLIC.
 *
 * @return PublishImageResponse
 */
async function publishImage(ImageId: string): PublishImageResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return publishImageWithOptions(ImageId, headers, runtime);
}

model RemoveImageResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model RemoveImageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveImageResponseBody(name='body'),
}

/**
 * @summary Removes an image.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveImageResponse
 */
@context("removeImageWithContext")
async function removeImageWithOptions(ImageId: string, headers: map[string]string, runtime: $RuntimeOptions): RemoveImageResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'RemoveImage',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/images/${$URL.percentEncode(ImageId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Removes an image.
 *
 * @return RemoveImageResponse
 */
async function removeImage(ImageId: string): RemoveImageResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return removeImageWithOptions(ImageId, headers, runtime);
}

model RemoveImageLabelsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model RemoveImageLabelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveImageLabelsResponseBody(name='body'),
}

/**
 * @summary Removes an image tag.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveImageLabelsResponse
 */
@context("removeImageLabelsWithContext")
async function removeImageLabelsWithOptions(ImageId: string, LabelKey: string, headers: map[string]string, runtime: $RuntimeOptions): RemoveImageLabelsResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'RemoveImageLabels',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/images/${$URL.percentEncode(ImageId)}/labels/${$URL.percentEncode(LabelKey)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Removes an image tag.
 *
 * @return RemoveImageLabelsResponse
 */
async function removeImageLabels(ImageId: string, LabelKey: string): RemoveImageLabelsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return removeImageLabelsWithOptions(ImageId, LabelKey, headers, runtime);
}

model RemoveMemberRoleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model RemoveMemberRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveMemberRoleResponseBody(name='body'),
}

/**
 * @summary Removes a member role.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveMemberRoleResponse
 */
@context("removeMemberRoleWithContext")
async function removeMemberRoleWithOptions(WorkspaceId: string, MemberId: string, RoleName: string, headers: map[string]string, runtime: $RuntimeOptions): RemoveMemberRoleResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'RemoveMemberRole',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}/members/${$URL.percentEncode(MemberId)}/roles/${$URL.percentEncode(RoleName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Removes a member role.
 *
 * @return RemoveMemberRoleResponse
 */
async function removeMemberRole(WorkspaceId: string, MemberId: string, RoleName: string): RemoveMemberRoleResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return removeMemberRoleWithOptions(WorkspaceId, MemberId, RoleName, headers, runtime);
}

model SetExperimentLabelsRequest {
  labels?: [
    LabelInfo
  ](name='Labels', description='The tags.'),
}

model SetExperimentLabelsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model SetExperimentLabelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetExperimentLabelsResponseBody(name='body'),
}

/**
 * @summary Updates a experiment tag.
 *
 * @param request SetExperimentLabelsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetExperimentLabelsResponse
 */
@context("setExperimentLabelsWithContext")
async function setExperimentLabelsWithOptions(ExperimentId: string, request: SetExperimentLabelsRequest, headers: map[string]string, runtime: $RuntimeOptions): SetExperimentLabelsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.labels)) {
    body['Labels'] = request.labels;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'SetExperimentLabels',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${$URL.percentEncode(ExperimentId)}/labels`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a experiment tag.
 *
 * @param request SetExperimentLabelsRequest
 * @return SetExperimentLabelsResponse
 */
async function setExperimentLabels(ExperimentId: string, request: SetExperimentLabelsRequest): SetExperimentLabelsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return setExperimentLabelsWithOptions(ExperimentId, request, headers, runtime);
}

model SetUserConfigsRequest {
  configs?: [ 
    {
      categoryName?: string(name='CategoryName', description='The category. Only DataPrivacyConfig is supported.

This parameter is required.', example='DataPrivacyConfig'),
      configKey?: string(name='ConfigKey', description='The key of the configuration item.

This parameter is required.', example='customizePAIAssumedRole'),
      configValue?: string(name='ConfigValue', description='The value of the configuration item.

This parameter is required.', example='role'),
      scope?: string(name='Scope', description='The scope. Valid values: subUser and owner.

This parameter is required.', example='owner'),
    }
  ](name='Configs', description='The configurations list.'),
}

model SetUserConfigsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='dsjk****dfjksdf'),
}

model SetUserConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetUserConfigsResponseBody(name='body'),
}

/**
 * @summary Updates the user configurations.
 *
 * @param request SetUserConfigsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetUserConfigsResponse
 */
@context("setUserConfigsWithContext")
async function setUserConfigsWithOptions(request: SetUserConfigsRequest, headers: map[string]string, runtime: $RuntimeOptions): SetUserConfigsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.configs)) {
    body['Configs'] = request.configs;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'SetUserConfigs',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/userconfigs`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the user configurations.
 *
 * @param request SetUserConfigsRequest
 * @return SetUserConfigsResponse
 */
async function setUserConfigs(request: SetUserConfigsRequest): SetUserConfigsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return setUserConfigsWithOptions(request, headers, runtime);
}

model StopDatasetJobRequest {
  datasetVersion?: string(name='DatasetVersion', description='The dataset version.', example='v1'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='478**'),
}

model StopDatasetJobResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F620FFD3-FFDC-5873-A70C-6971CC45F467'),
}

model StopDatasetJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopDatasetJobResponseBody(name='body'),
}

/**
 * @summary Stops a dataset job.
 *
 * @param request StopDatasetJobRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopDatasetJobResponse
 */
@context("stopDatasetJobWithContext")
async function stopDatasetJobWithOptions(DatasetId: string, DatasetJobId: string, request: StopDatasetJobRequest, headers: map[string]string, runtime: $RuntimeOptions): StopDatasetJobResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.datasetVersion)) {
    body['DatasetVersion'] = request.datasetVersion;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'StopDatasetJob',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/datasetjobs/${$URL.percentEncode(DatasetJobId)}/action/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Stops a dataset job.
 *
 * @param request StopDatasetJobRequest
 * @return StopDatasetJobResponse
 */
async function stopDatasetJob(DatasetId: string, DatasetJobId: string, request: StopDatasetJobRequest): StopDatasetJobResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return stopDatasetJobWithOptions(DatasetId, DatasetJobId, request, headers, runtime);
}

model UpdateCodeSourceRequest {
  codeBranch?: string(name='CodeBranch', description='The name of the code branch.', example='dev'),
  codeCommit?: string(name='CodeCommit', description='The code commit ID.', example='3a6*****'),
  codeRepo?: string(name='CodeRepo', description='The address of the code repository.', example='https://code.aliyun.com/******'),
  codeRepoAccessToken?: string(name='CodeRepoAccessToken', description='The access token corresponding to the username.', example='***'),
  codeRepoUserName?: string(name='CodeRepoUserName', description='The username used to access the code repository.', example='demo-user'),
  description?: string(name='Description', description='The description of the code build.'),
  displayName?: string(name='DisplayName', description='The name of the code build.', example='MyCodeSource1'),
  mountPath?: string(name='MountPath', description='The default mount path.', example='/root/code/code-source-1'),
}

model UpdateCodeSourceResponseBody = {
  codeSourceId?: string(name='CodeSourceId', description='The ID of the code build.', example='code-20********'),
  requestId?: string(name='RequestId', description='The request ID.', example='40325405-579C-4D82****'),
}

model UpdateCodeSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCodeSourceResponseBody(name='body'),
}

/**
 * @summary Updates a code build.
 *
 * @param request UpdateCodeSourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCodeSourceResponse
 */
@context("updateCodeSourceWithContext")
async function updateCodeSourceWithOptions(CodeSourceId: string, request: UpdateCodeSourceRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateCodeSourceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.codeBranch)) {
    body['CodeBranch'] = request.codeBranch;
  }
  if (!$isNull(request.codeCommit)) {
    body['CodeCommit'] = request.codeCommit;
  }
  if (!$isNull(request.codeRepo)) {
    body['CodeRepo'] = request.codeRepo;
  }
  if (!$isNull(request.codeRepoAccessToken)) {
    body['CodeRepoAccessToken'] = request.codeRepoAccessToken;
  }
  if (!$isNull(request.codeRepoUserName)) {
    body['CodeRepoUserName'] = request.codeRepoUserName;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.displayName)) {
    body['DisplayName'] = request.displayName;
  }
  if (!$isNull(request.mountPath)) {
    body['MountPath'] = request.mountPath;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateCodeSource',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/codesources/${$URL.percentEncode(CodeSourceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a code build.
 *
 * @param request UpdateCodeSourceRequest
 * @return UpdateCodeSourceResponse
 */
async function updateCodeSource(CodeSourceId: string, request: UpdateCodeSourceRequest): UpdateCodeSourceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCodeSourceWithOptions(CodeSourceId, request, headers, runtime);
}

model UpdateConfigRequest {
  categoryName?: string(name='CategoryName', description='The category of the configuration item. Valid values:

*   CommonResourceConfig
*   DLCAutoRecycle
*   DLCPriorityConfig
*   DSWPriorityConfig
*   QuotaMaximumDuration
*   CommonTagConfig', example='CommonResourceConfig'),
  configKey?: string(name='ConfigKey', description='The key of the configuration item. Valid values:

*   tempStoragePath: Temporary storage path. This key can be used only when CategoryName is set to CommonResourceConfig.
*   isAutoRecycle: Automatic recycle configuration. This key can be used only when CategoryName is set to DLCAutoRecycle.
*   priorityConfig: Priority configuration. This key can be used only when CategoryName is set to DLCPriorityConfig or DSWPriorityConfig.
*   quotaMaximumDuration: Maximum run time of DLC jobs for a quota. This key can be used only when CategoryName is set to QuotaMaximumDuration.
*   predefinedTags: Preset tags of the workspace. Created resources must include tags.', example='tempStoragePath'),
  configValue?: string(name='ConfigValue', description='The value of the configuration item.', example='oss://***'),
  labels?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='key1'),
      value?: string(name='Value', description='The tag value.', example='value1'),
    }
  ](name='Labels', description='The tags of the configuration item.'),
}

model UpdateConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A******C83E'),
}

model UpdateConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateConfigResponseBody(name='body'),
}

/**
 * @summary Updates or adds a workspace configuration item.
 *
 * @param request UpdateConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateConfigResponse
 */
@context("updateConfigWithContext")
async function updateConfigWithOptions(WorkspaceId: string, request: UpdateConfigRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateConfigResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.categoryName)) {
    body['CategoryName'] = request.categoryName;
  }
  if (!$isNull(request.configKey)) {
    body['ConfigKey'] = request.configKey;
  }
  if (!$isNull(request.configValue)) {
    body['ConfigValue'] = request.configValue;
  }
  if (!$isNull(request.labels)) {
    body['Labels'] = request.labels;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateConfig',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}/config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates or adds a workspace configuration item.
 *
 * @param request UpdateConfigRequest
 * @return UpdateConfigResponse
 */
async function updateConfig(WorkspaceId: string, request: UpdateConfigRequest): UpdateConfigResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateConfigWithOptions(WorkspaceId, request, headers, runtime);
}

model UpdateConfigsRequest {
  configs?: [ 
    {
      categoryName?: string(name='CategoryName', description='The category of the configuration item. Supported categories:

*   CommonResourceConfig
*   DLCAutoRecycle
*   DLCPriorityConfig
*   DSWPriorityConfig
*   QuotaMaximumDuration
*   CommonTagConfig', example='CommonResourceConfig'),
      configKey?: string(name='ConfigKey', description='The key of the configuration item. Supported keys:

*   tempStoragePath: Temporary storage path. This key can be used only when CategoryName is set to CommonResourceConfig.
*   isAutoRecycle: Automatic recycle configuration. This key can be used only when CategoryName is set to DLCAutoRecycle.
*   tempStoragePath: Temporary storage path. This key can be used only when CategoryName is set to CommonResourceConfig.
*   quotaMaximumDuration: Maximum run time of DLC jobs for a quota. This key can be used only when CategoryName is set to QuotaMaximumDuration.
*   predefinedTags: The predefined tags of the workspace. All created resources must have tags.', example='tempStoragePath'),
      configValue?: string(name='ConfigValue', description='The value of the configuration item.

*   When ConfigKey is predefinedTags, the ConfigValue follows this format: [{"Type":"Tag","Key":"Key1","Value":"{"Products":"DLC,DSW,EAS","Values":"value1,value2,value3"}"}]. "Products" indicates the products that use the predefined tags.', example='oss://test/s/'),
      labels?: [ 
        {
          key?: string(name='Key', description='The tag key.', example='key1'),
          value?: string(name='Value', description='The value of the tag.', example='value1'),
        }
      ](name='Labels', description='The tags of the configuration item.'),
    }
  ](name='Configs', description='The list of workspace configurations to update or add.'),
}

model UpdateConfigsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A******C83E'),
}

model UpdateConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateConfigsResponseBody(name='body'),
}

/**
 * @summary Updates or adds workspace configurations in batches.
 *
 * @param request UpdateConfigsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateConfigsResponse
 */
@context("updateConfigsWithContext")
async function updateConfigsWithOptions(WorkspaceId: string, request: UpdateConfigsRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateConfigsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.configs)) {
    body['Configs'] = request.configs;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateConfigs',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}/configs`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates or adds workspace configurations in batches.
 *
 * @param request UpdateConfigsRequest
 * @return UpdateConfigsResponse
 */
async function updateConfigs(WorkspaceId: string, request: UpdateConfigsRequest): UpdateConfigsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateConfigsWithOptions(WorkspaceId, request, headers, runtime);
}

model UpdateConnectionRequest {
  configs?: map[string]string(name='Configs', description='The connection configuration. The connection configuration is in the key-value format. The keys configured for different connection types are different. For more information, see the supplementary description of the request parameters in CreateConnection.'),
  description?: string(name='Description', description='The connection description.'),
  models?: [ 
    {
      displayName?: string(name='DisplayName', description='The display name of the model.', example='car_tag'),
      model?: string(name='Model', description='The model identifier.', example='model_001'),
      modelType?: string(name='ModelType', description='The model type. Valid values:

*   LLM
*   Embedding
*   ReRank', example='LLM'),
      toolCall?: boolean(name='ToolCall', description='Indicates whether tool calling is supported. Valid values:

*   true
*   false', example='true'),
    }
  ](name='Models', description='The models.'),
  secrets?: map[string]string(name='Secrets', description='The key-value configuration to be encrypted, such as the database logon password and the key for model connection.'),
}

model UpdateConnectionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A0F049F0-8D69-5BAC-8F10-B******A34C'),
}

model UpdateConnectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateConnectionResponseBody(name='body'),
}

/**
 * @summary Updates a connection.
 *
 * @param request UpdateConnectionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateConnectionResponse
 */
@context("updateConnectionWithContext")
async function updateConnectionWithOptions(ConnectionId: string, request: UpdateConnectionRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateConnectionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.configs)) {
    body['Configs'] = request.configs;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.models)) {
    body['Models'] = request.models;
  }
  if (!$isNull(request.secrets)) {
    body['Secrets'] = request.secrets;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateConnection',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/connections/${$URL.percentEncode(ConnectionId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a connection.
 *
 * @param request UpdateConnectionRequest
 * @return UpdateConnectionResponse
 */
async function updateConnection(ConnectionId: string, request: UpdateConnectionRequest): UpdateConnectionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateConnectionWithOptions(ConnectionId, request, headers, runtime);
}

model UpdateDatasetRequest {
  description?: string(name='Description', description='The description of the dataset.'),
  edition?: string(name='Edition'),
  mountAccessReadWriteRoleIdList?: [ string ](name='MountAccessReadWriteRoleIdList', description='The list of role names in the workspace that have read and write permissions on the mounted database. The names starting with PAI are basic role names, and the names starting with role- are custom role names. If the list contains asterisks (\\\\*), all roles have read and write permissions.

*   If you set the value to ["PAI.AlgoOperator", "role-hiuwpd01ncrokkgp21"], the account of the specified role is granted the read and write permissions.
*   If you set the value to ["\\\\*"], all accounts are granted the read and write permissions.
*   If you set the value to [], only the creator of the dataset has the read and write permissions.'),
  name?: string(name='Name', description='The dataset name. You can call [ListDatasets](https://help.aliyun.com/document_detail/457222.html) to obtain the dataset name.', example='myName'),
  options?: string(name='Options', description='The extended field, which is a JSON string. When you use the dataset in Deep Learning Containers (DLC), you can set mountPath to specify the default mount path of the dataset.', example='{
  "mountPath": "/mnt/data/"
}'),
  sharingConfig?: {
    sharedTo?: [
      DatasetShareRelationship
    ](name='SharedTo'),
  }(name='SharingConfig', nullable=true),
}

model UpdateDatasetResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model UpdateDatasetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDatasetResponseBody(name='body'),
}

/**
 * @summary Updates the name, description, and other information about a dataset.
 *
 * @param request UpdateDatasetRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDatasetResponse
 */
@context("updateDatasetWithContext")
async function updateDatasetWithOptions(DatasetId: string, request: UpdateDatasetRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateDatasetResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.edition)) {
    body['Edition'] = request.edition;
  }
  if (!$isNull(request.mountAccessReadWriteRoleIdList)) {
    body['MountAccessReadWriteRoleIdList'] = request.mountAccessReadWriteRoleIdList;
  }
  if (!$isNull(request.name)) {
    body['Name'] = request.name;
  }
  if (!$isNull(request.options)) {
    body['Options'] = request.options;
  }
  if (!$isNull(request.sharingConfig)) {
    body['SharingConfig'] = request.sharingConfig;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateDataset',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the name, description, and other information about a dataset.
 *
 * @param request UpdateDatasetRequest
 * @return UpdateDatasetResponse
 */
async function updateDataset(DatasetId: string, request: UpdateDatasetRequest): UpdateDatasetResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDatasetWithOptions(DatasetId, request, headers, runtime);
}

model UpdateDatasetFileMetasRequest {
  datasetFileMetas?: [
    DatasetFileMetaConentUpdate
  ](name='DatasetFileMetas', description='The metadata records to be updated for the dataset files.

This parameter is required.'),
  datasetVersion?: string(name='DatasetVersion', description='The dataset version.', example='v1'),
  tagJobId?: string(name='TagJobId', description='The ID of the tagging job that is associated with the metadata tag of the dataset file.', example='dsjob-hv0b1****u8taig3y'),
  workspaceId?: string(name='WorkspaceId', description='The ID of the workspace to which the dataset belongs. To obtain the workspace ID, see [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html).', example='796**'),
}

model UpdateDatasetFileMetasResponseBody = {
  failedDetails?: [
    DatasetFileMetaResponse
  ](name='FailedDetails', description='The metadata records that fail to be updated for the dataset files.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  status?: boolean(name='Status', description='Indicates whether the metadata records of all dataset files were updated. Valid values: true and false. If the value is false, view the failure details specified by FailedDetails.', example='true'),
}

model UpdateDatasetFileMetasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDatasetFileMetasResponseBody(name='body'),
}

/**
 * @summary Updates the metadata records of multiple files in a dataset at a time.
 *
 * @param request UpdateDatasetFileMetasRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDatasetFileMetasResponse
 */
@context("updateDatasetFileMetasWithContext")
async function updateDatasetFileMetasWithOptions(DatasetId: string, request: UpdateDatasetFileMetasRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateDatasetFileMetasResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.datasetFileMetas)) {
    body['DatasetFileMetas'] = request.datasetFileMetas;
  }
  if (!$isNull(request.datasetVersion)) {
    body['DatasetVersion'] = request.datasetVersion;
  }
  if (!$isNull(request.tagJobId)) {
    body['TagJobId'] = request.tagJobId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateDatasetFileMetas',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/datasetfilemetas`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the metadata records of multiple files in a dataset at a time.
 *
 * @param request UpdateDatasetFileMetasRequest
 * @return UpdateDatasetFileMetasResponse
 */
async function updateDatasetFileMetas(DatasetId: string, request: UpdateDatasetFileMetasRequest): UpdateDatasetFileMetasResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDatasetFileMetasWithOptions(DatasetId, request, headers, runtime);
}

model UpdateDatasetJobRequest {
  datasetVersion?: string(name='DatasetVersion', description='The dataset version name.', example='v1'),
  description?: string(name='Description', description='The dataset job description.'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='478**'),
}

model UpdateDatasetJobResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model UpdateDatasetJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDatasetJobResponseBody(name='body'),
}

/**
 * @summary Updates a dataset job.
 *
 * @param request UpdateDatasetJobRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDatasetJobResponse
 */
@context("updateDatasetJobWithContext")
async function updateDatasetJobWithOptions(DatasetId: string, DatasetJobId: string, request: UpdateDatasetJobRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateDatasetJobResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.datasetVersion)) {
    body['DatasetVersion'] = request.datasetVersion;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateDatasetJob',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/datasetjobs/${$URL.percentEncode(DatasetJobId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a dataset job.
 *
 * @param request UpdateDatasetJobRequest
 * @return UpdateDatasetJobResponse
 */
async function updateDatasetJob(DatasetId: string, DatasetJobId: string, request: UpdateDatasetJobRequest): UpdateDatasetJobResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDatasetJobWithOptions(DatasetId, DatasetJobId, request, headers, runtime);
}

model UpdateDatasetJobConfigRequest {
  config?: string(name='Config', description='The configuration content. Formats:

*   MultimodalIntelligentTag

{ "apiKey":"sk-xxxxxxxxxxxxxxxxxxxxx" }

*   MultimodalSemanticIndex

{ "defaultModelId": "xxx" "defaultModelVersion":"1.0.0" }', example='{ "apiKey":"sk-xxxxxxxxxxxxxxxxxxxxx" }'),
  configType?: string(name='ConfigType', description='The configuration type.

*   MultimodalIntelligentTag
*   MultimodalSemanticIndex', example='MultimodalSemanticIndex'),
  workspaceId?: string(name='WorkspaceId', description='The workspace ID.', example='167497'),
}

model UpdateDatasetJobConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D5BFFEE3-6025-443F-8A03-02D619B5C4B9'),
}

model UpdateDatasetJobConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDatasetJobConfigResponseBody(name='body'),
}

/**
 * @summary Updates a job configuration for a dataset.
 *
 * @param request UpdateDatasetJobConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDatasetJobConfigResponse
 */
@context("updateDatasetJobConfigWithContext")
async function updateDatasetJobConfigWithOptions(DatasetId: string, DatasetJobConfigId: string, request: UpdateDatasetJobConfigRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateDatasetJobConfigResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.config)) {
    body['Config'] = request.config;
  }
  if (!$isNull(request.configType)) {
    body['ConfigType'] = request.configType;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateDatasetJobConfig',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/datasetjobconfigs/${$URL.percentEncode(DatasetJobConfigId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a job configuration for a dataset.
 *
 * @param request UpdateDatasetJobConfigRequest
 * @return UpdateDatasetJobConfigResponse
 */
async function updateDatasetJobConfig(DatasetId: string, DatasetJobConfigId: string, request: UpdateDatasetJobConfigRequest): UpdateDatasetJobConfigResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDatasetJobConfigWithOptions(DatasetId, DatasetJobConfigId, request, headers, runtime);
}

model UpdateDatasetVersionRequest {
  dataCount?: long(name='DataCount', example='100'),
  dataSize?: long(name='DataSize', example='100000'),
  description?: string(name='Description'),
  options?: string(name='Options', example='{
  "mountPath": "/mnt/data/"
}'),
}

model UpdateDatasetVersionResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateDatasetVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDatasetVersionResponseBody(name='body'),
}

/**
 * @summary Updates the information about a specified version of a dataset.
 *
 * @param request UpdateDatasetVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDatasetVersionResponse
 */
@context("updateDatasetVersionWithContext")
async function updateDatasetVersionWithOptions(DatasetId: string, VersionName: string, request: UpdateDatasetVersionRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateDatasetVersionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.dataCount)) {
    body['DataCount'] = request.dataCount;
  }
  if (!$isNull(request.dataSize)) {
    body['DataSize'] = request.dataSize;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.options)) {
    body['Options'] = request.options;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateDatasetVersion',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasets/${$URL.percentEncode(DatasetId)}/versions/${$URL.percentEncode(VersionName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the information about a specified version of a dataset.
 *
 * @param request UpdateDatasetVersionRequest
 * @return UpdateDatasetVersionResponse
 */
async function updateDatasetVersion(DatasetId: string, VersionName: string, request: UpdateDatasetVersionRequest): UpdateDatasetVersionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDatasetVersionWithOptions(DatasetId, VersionName, request, headers, runtime);
}

model UpdateDefaultWorkspaceRequest {
  workspaceId?: string(name='WorkspaceId', description='The workspace ID. You can call [ListWorkspaces](https://help.aliyun.com/document_detail/449124.html) to obtain the workspace ID.', example='12345'),
}

model UpdateDefaultWorkspaceResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='17915******4216'),
}

model UpdateDefaultWorkspaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDefaultWorkspaceResponseBody(name='body'),
}

/**
 * @summary Specifies a workspace as the default workspace.
 *
 * @param request UpdateDefaultWorkspaceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDefaultWorkspaceResponse
 */
@context("updateDefaultWorkspaceWithContext")
async function updateDefaultWorkspaceWithOptions(request: UpdateDefaultWorkspaceRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateDefaultWorkspaceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateDefaultWorkspace',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/defaultWorkspaces`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Specifies a workspace as the default workspace.
 *
 * @param request UpdateDefaultWorkspaceRequest
 * @return UpdateDefaultWorkspaceResponse
 */
async function updateDefaultWorkspace(request: UpdateDefaultWorkspaceRequest): UpdateDefaultWorkspaceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDefaultWorkspaceWithOptions(request, headers, runtime);
}

model UpdateExperimentRequest {
  accessibility?: string(name='Accessibility', description='The accessibility of the experiment in the workspace. Valid values:

*   PRIVATE: The experiment is accessible only to you and the administrator of the workspace.
*   PUBLIC: The experiment is accessible to all users in the workspace.', example='PRIVATE'),
  name?: string(name='Name', description='The experiment name. The name must meet the following requirements:

*   The name must start with a letter.
*   The name can contain letters, digits, underscores (_), and hyphens (-).
*   The name must be 1 to 63 characters in length.', example='myName'),
}

model UpdateExperimentResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model UpdateExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateExperimentResponseBody(name='body'),
}

/**
 * @summary Updates an experiment.
 *
 * @param request UpdateExperimentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateExperimentResponse
 */
@context("updateExperimentWithContext")
async function updateExperimentWithOptions(ExperimentId: string, request: UpdateExperimentRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateExperimentResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.accessibility)) {
    body['Accessibility'] = request.accessibility;
  }
  if (!$isNull(request.name)) {
    body['Name'] = request.name;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateExperiment',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${$URL.percentEncode(ExperimentId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates an experiment.
 *
 * @param request UpdateExperimentRequest
 * @return UpdateExperimentResponse
 */
async function updateExperiment(ExperimentId: string, request: UpdateExperimentRequest): UpdateExperimentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExperimentWithOptions(ExperimentId, request, headers, runtime);
}

model UpdateModelRequest {
  accessibility?: string(name='Accessibility', description='The visibility of the model in the workspace. Valid values:

*   PRIVATE: The model is visible only to you and the administrator of the workspace.
*   PUBLIC: The model is visible to all users in the workspace.', example='PUBLIC'),
  domain?: string(name='Domain', description='The domain. This parameter describes the domain in which the model is applied. Valid values: nlp (natural language processing) and cv (computer vision).', example='nlp'),
  extraInfo?: map[string]any(name='ExtraInfo', description='Other information about the model.', example='{
	"RatingCount": 2866,
	"Rating": 4.94,
	"FavoriteCount": 34992,
	"CommentCount": 754,
	"CoverUris": ["https://e***u.oss-cn-hangzhou.aliyuncs.com/drea***w.png"],
	"TippedAmountCount": 32,
	"DownloadCount": 606056
}'),
  modelDescription?: string(name='ModelDescription', description='The model description.'),
  modelDoc?: string(name='ModelDoc', description='The documentation of the model.', example='https://*.md'),
  modelName?: string(name='ModelName', description='The model name, which must be 1 to 127 characters in length.'),
  modelType?: string(name='ModelType', description='The model type. Valid values: Checkpoint and LoRA.', example='Checkpoint'),
  orderNumber?: long(name='OrderNumber', description='The sequence number of the model. This parameter can be used for custom sorting.', example='0'),
  origin?: string(name='Origin', description='The source of the model. This parameter describes the community or organization to which the source model belongs. Valid values: ModelScope and HuggingFace.', example='ModelScope'),
  parameterSize?: long(name='ParameterSize'),
  task?: string(name='Task', description='The task. This parameter specifies the specific issue that the model resolves. Example: text-classification.', example='text-classification'),
}

model UpdateModelResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A0F049F0-8D69-5BAC-8F10-B******A34C'),
}

model UpdateModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateModelResponseBody(name='body'),
}

/**
 * @summary Updates the basic configuration information about a model.
 *
 * @param request UpdateModelRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateModelResponse
 */
@context("updateModelWithContext")
async function updateModelWithOptions(ModelId: string, request: UpdateModelRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateModelResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.accessibility)) {
    body['Accessibility'] = request.accessibility;
  }
  if (!$isNull(request.domain)) {
    body['Domain'] = request.domain;
  }
  if (!$isNull(request.extraInfo)) {
    body['ExtraInfo'] = request.extraInfo;
  }
  if (!$isNull(request.modelDescription)) {
    body['ModelDescription'] = request.modelDescription;
  }
  if (!$isNull(request.modelDoc)) {
    body['ModelDoc'] = request.modelDoc;
  }
  if (!$isNull(request.modelName)) {
    body['ModelName'] = request.modelName;
  }
  if (!$isNull(request.modelType)) {
    body['ModelType'] = request.modelType;
  }
  if (!$isNull(request.orderNumber)) {
    body['OrderNumber'] = request.orderNumber;
  }
  if (!$isNull(request.origin)) {
    body['Origin'] = request.origin;
  }
  if (!$isNull(request.parameterSize)) {
    body['ParameterSize'] = request.parameterSize;
  }
  if (!$isNull(request.task)) {
    body['Task'] = request.task;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateModel',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/models/${$URL.percentEncode(ModelId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the basic configuration information about a model.
 *
 * @param request UpdateModelRequest
 * @return UpdateModelResponse
 */
async function updateModel(ModelId: string, request: UpdateModelRequest): UpdateModelResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateModelWithOptions(ModelId, request, headers, runtime);
}

model UpdateModelVersionRequest {
  approvalStatus?: string(name='ApprovalStatus', description='The approval status. Valid values:

*   Pending
*   Approved
*   Rejected', example='Approved'),
  compressionSpec?: map[string]any(name='CompressionSpec', description='The compression configuration.', example='{}'),
  distillationSpec?: map[string]any(name='DistillationSpec'),
  evaluationSpec?: map[string]any(name='EvaluationSpec', description='The evaluation configuration.', example='{}'),
  extraInfo?: map[string]any(name='ExtraInfo', description='The additional information.', example='{
	"CoverUris": ["https://e***u.oss-cn-hangzhou.aliyuncs.com/st****017.preview.png"],
	"TrainedWords": ["albedo_overlord"]
}'),
  inferenceSpec?: map[string]any(name='InferenceSpec', description='Describes how to apply to downstream inference services. For example, describes the processor and container of Elastic Algorithm Service (EAS). Example: `{ "processor": "tensorflow_gpu_1.12" }`.', example='{     "processor": "tensorflow_gpu_1.12" }'),
  metrics?: map[string]any(name='Metrics', description='The model metrics. The length after serialization is limited to 8,192.', example='{
  "Results": [{
    "Dataset": {
      "DatasetId": "d-sdkjanksaklerhfd"
    },
    "Metrics": {
      "cer": 0.175
    }
  }, {
    "Dataset": {
      "Uri": "oss://xxxx/"
    },
    "Metrics": {
      "cer": 0.172
    }
  }]
}'),
  options?: string(name='Options', description='The extended field, which is of the JsonString type.', example='{}'),
  sourceId?: string(name='SourceId', description='The source ID.

*   If the source type is Custom, this field is not limited.
*   If the source type is PAIFlow or TrainingService, the format is:

<!---->

    region=<region_id>,workspaceId=<workspace_id>,kind=<kind>,id=<id>

Take note of the following parameters:

*   region is the region ID.
*   workspaceId is the ID of the workspace.
*   kind is the type. Valid values: PipelineRun (PAIFlow) and ServiceJob (training service).
*   id is a unique identifier.', example='region=cn-shanghai,workspaceId=13**,kind=PipelineRun,id=run-sakdb****jdf'),
  sourceType?: string(name='SourceType', description='The type of the model source. Valid values:

*   Custom (default)
*   PAIFlow
*   TrainingService', example='PAIFlow'),
  trainingSpec?: map[string]any(name='TrainingSpec', description='The training configurations used for fine-tuning and incremental training.', example='{}'),
  versionDescription?: string(name='VersionDescription', description='The model version description.'),
}

model UpdateModelVersionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D5BFFEE3-6025-443F-8A03-02D61***C4B9'),
}

model UpdateModelVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateModelVersionResponseBody(name='body'),
}

/**
 * @summary Updates a model version.
 *
 * @param request UpdateModelVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateModelVersionResponse
 */
@context("updateModelVersionWithContext")
async function updateModelVersionWithOptions(ModelId: string, VersionName: string, request: UpdateModelVersionRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateModelVersionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.approvalStatus)) {
    body['ApprovalStatus'] = request.approvalStatus;
  }
  if (!$isNull(request.compressionSpec)) {
    body['CompressionSpec'] = request.compressionSpec;
  }
  if (!$isNull(request.distillationSpec)) {
    body['DistillationSpec'] = request.distillationSpec;
  }
  if (!$isNull(request.evaluationSpec)) {
    body['EvaluationSpec'] = request.evaluationSpec;
  }
  if (!$isNull(request.extraInfo)) {
    body['ExtraInfo'] = request.extraInfo;
  }
  if (!$isNull(request.inferenceSpec)) {
    body['InferenceSpec'] = request.inferenceSpec;
  }
  if (!$isNull(request.metrics)) {
    body['Metrics'] = request.metrics;
  }
  if (!$isNull(request.options)) {
    body['Options'] = request.options;
  }
  if (!$isNull(request.sourceId)) {
    body['SourceId'] = request.sourceId;
  }
  if (!$isNull(request.sourceType)) {
    body['SourceType'] = request.sourceType;
  }
  if (!$isNull(request.trainingSpec)) {
    body['TrainingSpec'] = request.trainingSpec;
  }
  if (!$isNull(request.versionDescription)) {
    body['VersionDescription'] = request.versionDescription;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateModelVersion',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/models/${$URL.percentEncode(ModelId)}/versions/${$URL.percentEncode(VersionName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a model version.
 *
 * @param request UpdateModelVersionRequest
 * @return UpdateModelVersionResponse
 */
async function updateModelVersion(ModelId: string, VersionName: string, request: UpdateModelVersionRequest): UpdateModelVersionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateModelVersionWithOptions(ModelId, VersionName, request, headers, runtime);
}

model UpdateRunRequest {
  labels?: [
    Label
  ](name='Labels', description='The labels.'),
  name?: string(name='Name', description='The run name. The name must meet the following requirements:

*   The name must start with a letter.
*   The name can contain letters, digits, underscores (_), and hyphens (-).
*   The name must be 1 to 63 characters in length.', example='myName'),
  params?: [
    RunParam
  ](name='Params', description='The parameters.'),
}

model UpdateRunResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='ADF6D849-*****-7E7030F0CE53'),
}

model UpdateRunResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRunResponseBody(name='body'),
}

/**
 * @summary Updates the run information.
 *
 * @param request UpdateRunRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRunResponse
 */
@context("updateRunWithContext")
async function updateRunWithOptions(RunId: string, request: UpdateRunRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateRunResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!$isNull(request.name)) {
    body['Name'] = request.name;
  }
  if (!$isNull(request.params)) {
    body['Params'] = request.params;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateRun',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/runs/${$URL.percentEncode(RunId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the run information.
 *
 * @param request UpdateRunRequest
 * @return UpdateRunResponse
 */
async function updateRun(RunId: string, request: UpdateRunRequest): UpdateRunResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRunWithOptions(RunId, request, headers, runtime);
}

model UpdateWorkspaceRequest {
  description?: string(name='Description', description='The workspace description.', example='Description'),
  displayName?: string(name='DisplayName', description='The display name of the workspace.

*   The name must be 3 to 23 characters in length, and can contain letters, underscores (_), and digits.
*   The name must start with a letter.
*   The name must be unique in the current region.', example='workspace-example'),
}

model UpdateWorkspaceResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
}

model UpdateWorkspaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateWorkspaceResponseBody(name='body'),
}

/**
 * @summary Updates the name and description of a workspace.
 *
 * @param request UpdateWorkspaceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateWorkspaceResponse
 */
@context("updateWorkspaceWithContext")
async function updateWorkspaceWithOptions(WorkspaceId: string, request: UpdateWorkspaceRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateWorkspaceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.displayName)) {
    body['DisplayName'] = request.displayName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateWorkspace',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the name and description of a workspace.
 *
 * @param request UpdateWorkspaceRequest
 * @return UpdateWorkspaceResponse
 */
async function updateWorkspace(WorkspaceId: string, request: UpdateWorkspaceRequest): UpdateWorkspaceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateWorkspaceWithOptions(WorkspaceId, request, headers, runtime);
}

model UpdateWorkspaceResourceRequest {
  groupName?: string(name='GroupName', description='The group name.', example='group-kjds******sd'),
  isDefault?: boolean(name='IsDefault', description='Specifies whether the resource is the default resource. This parameter can only be set to true and cannot be set to false.', example='true'),
  labels?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='system.******'),
      value?: string(name='Value', description='The tag value.', example='True'),
    }
  ](name='Labels', description='The resource tags. If you specify multiple tags, only resources that meet all the specified tag-based filter conditions are returned.'),
  productType?: string(name='ProductType', description='**This field is no longer used and will be removed. Use the ResourceType field.', example='MaxCompute'),
  resourceIds?: [ string ](name='ResourceIds', description='The resource IDs.

You cannot leave both GroupName and ResourceIds empty. If you specify both the parameters, the value of GroupName of each resource ID in the dataset must be the same.'),
  resourceType?: string(name='ResourceType', description='The resource type. Valid values:

*   MaxCompute
*   ECS
*   Lingjun
*   ACS
*   FLINK', example='MaxCompute'),
  spec?: map[string]any(name='Spec', description='The specification of the resource.', example='{
      "clusterType": "share"
}'),
}

model UpdateWorkspaceResourceResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A14FA81-DD4E-******-6343FE44B941'),
  resourceIds?: [ string ](name='ResourceIds', description='The updated resource IDs.', example='Resource-dks******jkf'),
}

model UpdateWorkspaceResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateWorkspaceResourceResponseBody(name='body'),
}

/**
 * @summary Updates the resources of a workspace.
 *
 * @param request UpdateWorkspaceResourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateWorkspaceResourceResponse
 */
@context("updateWorkspaceResourceWithContext")
async function updateWorkspaceResourceWithOptions(WorkspaceId: string, request: UpdateWorkspaceResourceRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateWorkspaceResourceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.groupName)) {
    body['GroupName'] = request.groupName;
  }
  if (!$isNull(request.isDefault)) {
    body['IsDefault'] = request.isDefault;
  }
  if (!$isNull(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!$isNull(request.productType)) {
    body['ProductType'] = request.productType;
  }
  if (!$isNull(request.resourceIds)) {
    body['ResourceIds'] = request.resourceIds;
  }
  if (!$isNull(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.spec)) {
    body['Spec'] = request.spec;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateWorkspaceResource',
    version = '2021-02-04',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${$URL.percentEncode(WorkspaceId)}/resources`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the resources of a workspace.
 *
 * @param request UpdateWorkspaceResourceRequest
 * @return UpdateWorkspaceResourceResponse
 */
async function updateWorkspaceResource(WorkspaceId: string, request: UpdateWorkspaceResourceRequest): UpdateWorkspaceResourceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateWorkspaceResourceWithOptions(WorkspaceId, request, headers, runtime);
}

