/**
 *
 */
import Util;
import XML;
import Credential;
import FileForm;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('dataworks', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model Collection {
  collectionType?: string(name='CollectionType', example='album'),
  comment?: string(name='Comment', example='comment'),
  createTime?: long(name='CreateTime', example='1668600147617'),
  level?: int32(name='Level', example='1'),
  name?: string(name='Name', example='collectionName'),
  ownerId?: string(name='OwnerId', example='1234444'),
  ownerName?: string(name='OwnerName', example='owner'),
  qualifiedName?: string(name='QualifiedName', example='album.12334'),
  updateTime?: long(name='UpdateTime', example='1668600148617'),
}

model Entity {
  entityContent?: map[string]any(name='EntityContent'),
  qualifiedName?: string(name='QualifiedName', example='maxcompute_table.563f0357118d05ef145d6bddf2966cc23e86ca8f2f013f915e565afdf09f7a23'),
  tenantId?: long(name='TenantId', example='12345'),
}

model SuccessInfoValue = {
  success?: boolean(name='Success'),
  message?: string(name='Message'),
}

model AbolishDeploymentRequest {
  id?: string(name='Id', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model AbolishDeploymentResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AbolishDeploymentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AbolishDeploymentResponseBody(name='body'),
}

/**
 * @summary 终止发布流程
 *
 * @param request AbolishDeploymentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AbolishDeploymentResponse
 */
async function abolishDeploymentWithOptions(request: AbolishDeploymentRequest, runtime: Util.RuntimeOptions): AbolishDeploymentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AbolishDeployment',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 终止发布流程
 *
 * @param request AbolishDeploymentRequest
 * @return AbolishDeploymentResponse
 */
async function abolishDeployment(request: AbolishDeploymentRequest): AbolishDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  return abolishDeploymentWithOptions(request, runtime);
}

model AddBusinessBaselineVirtualNodeRequest {
  baselineId?: long(name='BaselineId', description='This parameter is required.'),
  nodeId?: long(name='NodeId', description='This parameter is required.'),
}

model AddBusinessBaselineVirtualNodeResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddBusinessBaselineVirtualNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddBusinessBaselineVirtualNodeResponseBody(name='body'),
}

/**
 * @param request AddBusinessBaselineVirtualNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddBusinessBaselineVirtualNodeResponse
 */
async function addBusinessBaselineVirtualNodeWithOptions(request: AddBusinessBaselineVirtualNodeRequest, runtime: Util.RuntimeOptions): AddBusinessBaselineVirtualNodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.baselineId)) {
    body['BaselineId'] = request.baselineId;
  }
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddBusinessBaselineVirtualNode',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddBusinessBaselineVirtualNodeRequest
 * @return AddBusinessBaselineVirtualNodeResponse
 */
async function addBusinessBaselineVirtualNode(request: AddBusinessBaselineVirtualNodeRequest): AddBusinessBaselineVirtualNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBusinessBaselineVirtualNodeWithOptions(request, runtime);
}

model AddMetaCollectionEntityRequest {
  collectionQualifiedName?: string(name='CollectionQualifiedName', description='This parameter is required.'),
  entityQualifiedName?: string(name='EntityQualifiedName', description='This parameter is required.'),
  remark?: string(name='Remark'),
}

model AddMetaCollectionEntityResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  status?: boolean(name='Status'),
  success?: boolean(name='Success'),
}

model AddMetaCollectionEntityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddMetaCollectionEntityResponseBody(name='body'),
}

/**
 * @summary 添加entity到collectioin中
 *
 * @param request AddMetaCollectionEntityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddMetaCollectionEntityResponse
 */
async function addMetaCollectionEntityWithOptions(request: AddMetaCollectionEntityRequest, runtime: Util.RuntimeOptions): AddMetaCollectionEntityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.collectionQualifiedName)) {
    query['CollectionQualifiedName'] = request.collectionQualifiedName;
  }
  if (!Util.isUnset(request.entityQualifiedName)) {
    query['EntityQualifiedName'] = request.entityQualifiedName;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddMetaCollectionEntity',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 添加entity到collectioin中
 *
 * @param request AddMetaCollectionEntityRequest
 * @return AddMetaCollectionEntityResponse
 */
async function addMetaCollectionEntity(request: AddMetaCollectionEntityRequest): AddMetaCollectionEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMetaCollectionEntityWithOptions(request, runtime);
}

model AddProjectMemberToRoleRequest {
  clientToken?: string(name='ClientToken'),
  operator?: string(name='Operator'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  roleCode?: string(name='RoleCode', description='This parameter is required.'),
  userId?: string(name='UserId', description='This parameter is required.'),
}

model AddProjectMemberToRoleResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddProjectMemberToRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddProjectMemberToRoleResponseBody(name='body'),
}

/**
 * @summary 空间成员授予新角色
 *
 * @param request AddProjectMemberToRoleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddProjectMemberToRoleResponse
 */
async function addProjectMemberToRoleWithOptions(request: AddProjectMemberToRoleRequest, runtime: Util.RuntimeOptions): AddProjectMemberToRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.roleCode)) {
    query['RoleCode'] = request.roleCode;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddProjectMemberToRole',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 空间成员授予新角色
 *
 * @param request AddProjectMemberToRoleRequest
 * @return AddProjectMemberToRoleResponse
 */
async function addProjectMemberToRole(request: AddProjectMemberToRoleRequest): AddProjectMemberToRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addProjectMemberToRoleWithOptions(request, runtime);
}

model AddToMetaCategoryRequest {
  categoryId?: long(name='CategoryId', description='This parameter is required.'),
  tableGuid?: string(name='TableGuid', description='This parameter is required.'),
}

model AddToMetaCategoryResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddToMetaCategoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddToMetaCategoryResponseBody(name='body'),
}

/**
 * @param request AddToMetaCategoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddToMetaCategoryResponse
 */
async function addToMetaCategoryWithOptions(request: AddToMetaCategoryRequest, runtime: Util.RuntimeOptions): AddToMetaCategoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.categoryId)) {
    query['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.tableGuid)) {
    query['TableGuid'] = request.tableGuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddToMetaCategory',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddToMetaCategoryRequest
 * @return AddToMetaCategoryResponse
 */
async function addToMetaCategory(request: AddToMetaCategoryRequest): AddToMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addToMetaCategoryWithOptions(request, runtime);
}

model AttachDataQualityRulesToEvaluationTaskRequest {
  dataQualityEvaluationTaskId?: long(name='DataQualityEvaluationTaskId', description='This parameter is required.'),
  dataQualityRuleIds?: [ long ](name='DataQualityRuleIds', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model AttachDataQualityRulesToEvaluationTaskShrinkRequest {
  dataQualityEvaluationTaskId?: long(name='DataQualityEvaluationTaskId', description='This parameter is required.'),
  dataQualityRuleIdsShrink?: string(name='DataQualityRuleIds', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model AttachDataQualityRulesToEvaluationTaskResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AttachDataQualityRulesToEvaluationTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AttachDataQualityRulesToEvaluationTaskResponseBody(name='body'),
}

/**
 * @summary 把数据质量规则关联到数据质量校验任务上
 *
 * @param tmpReq AttachDataQualityRulesToEvaluationTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachDataQualityRulesToEvaluationTaskResponse
 */
async function attachDataQualityRulesToEvaluationTaskWithOptions(tmpReq: AttachDataQualityRulesToEvaluationTaskRequest, runtime: Util.RuntimeOptions): AttachDataQualityRulesToEvaluationTaskResponse {
  Util.validateModel(tmpReq);
  var request = new AttachDataQualityRulesToEvaluationTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dataQualityRuleIds)) {
    request.dataQualityRuleIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dataQualityRuleIds, 'DataQualityRuleIds', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataQualityEvaluationTaskId)) {
    body['DataQualityEvaluationTaskId'] = request.dataQualityEvaluationTaskId;
  }
  if (!Util.isUnset(request.dataQualityRuleIdsShrink)) {
    body['DataQualityRuleIds'] = request.dataQualityRuleIdsShrink;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AttachDataQualityRulesToEvaluationTask',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 把数据质量规则关联到数据质量校验任务上
 *
 * @param request AttachDataQualityRulesToEvaluationTaskRequest
 * @return AttachDataQualityRulesToEvaluationTaskResponse
 */
async function attachDataQualityRulesToEvaluationTask(request: AttachDataQualityRulesToEvaluationTaskRequest): AttachDataQualityRulesToEvaluationTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachDataQualityRulesToEvaluationTaskWithOptions(request, runtime);
}

model BatchUpdateTableOwnerRequest {
  operatorId?: string(name='OperatorId'),
  ownerId?: string(name='OwnerId'),
  tableGuids?: string(name='TableGuids'),
}

model BatchUpdateTableOwnerResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchUpdateTableOwnerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchUpdateTableOwnerResponseBody(name='body'),
}

/**
 * @param request BatchUpdateTableOwnerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchUpdateTableOwnerResponse
 */
async function batchUpdateTableOwnerWithOptions(request: BatchUpdateTableOwnerRequest, runtime: Util.RuntimeOptions): BatchUpdateTableOwnerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.operatorId)) {
    query['OperatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.tableGuids)) {
    query['TableGuids'] = request.tableGuids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchUpdateTableOwner',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchUpdateTableOwnerRequest
 * @return BatchUpdateTableOwnerResponse
 */
async function batchUpdateTableOwner(request: BatchUpdateTableOwnerRequest): BatchUpdateTableOwnerResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchUpdateTableOwnerWithOptions(request, runtime);
}

model BatchUpdateTasksRequest {
  comment?: string(name='Comment'),
  tasks?: [ 
    {
      dataSource?: {
        name?: string(name='Name'),
      }(name='DataSource'),
      description?: string(name='Description'),
      envType?: string(name='EnvType'),
      id?: long(name='Id', description='This parameter is required.'),
      name?: string(name='Name'),
      owner?: string(name='Owner'),
      rerunInterval?: int32(name='RerunInterval'),
      rerunMode?: string(name='RerunMode'),
      rerunTimes?: int32(name='RerunTimes'),
      runtimeResource?: {
        cu?: string(name='Cu'),
        image?: string(name='Image'),
        resourceGroupId?: string(name='ResourceGroupId'),
      }(name='RuntimeResource'),
      tags?: [ 
        {
          key?: string(name='Key', description='This parameter is required.'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      timeout?: int32(name='Timeout'),
      trigger?: {
        cron?: string(name='Cron'),
        endTime?: string(name='EndTime'),
        recurrence?: string(name='Recurrence'),
        startTime?: string(name='StartTime'),
        type?: string(name='Type'),
      }(name='Trigger'),
    }
  ](name='Tasks'),
}

model BatchUpdateTasksShrinkRequest {
  comment?: string(name='Comment'),
  tasksShrink?: string(name='Tasks'),
}

model BatchUpdateTasksResponseBody = {
  requestId?: string(name='RequestId'),
}

model BatchUpdateTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchUpdateTasksResponseBody(name='body'),
}

/**
 * @param tmpReq BatchUpdateTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchUpdateTasksResponse
 */
async function batchUpdateTasksWithOptions(tmpReq: BatchUpdateTasksRequest, runtime: Util.RuntimeOptions): BatchUpdateTasksResponse {
  Util.validateModel(tmpReq);
  var request = new BatchUpdateTasksShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tasks)) {
    request.tasksShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tasks, 'Tasks', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.tasksShrink)) {
    body['Tasks'] = request.tasksShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchUpdateTasks',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchUpdateTasksRequest
 * @return BatchUpdateTasksResponse
 */
async function batchUpdateTasks(request: BatchUpdateTasksRequest): BatchUpdateTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchUpdateTasksWithOptions(request, runtime);
}

model CheckMetaPartitionRequest {
  clusterId?: string(name='ClusterId'),
  dataSourceType?: string(name='DataSourceType'),
  databaseName?: string(name='DatabaseName'),
  partition?: string(name='Partition', description='This parameter is required.'),
  tableGuid?: string(name='TableGuid'),
  tableName?: string(name='TableName'),
}

model CheckMetaPartitionResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model CheckMetaPartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckMetaPartitionResponseBody(name='body'),
}

/**
 * @param request CheckMetaPartitionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckMetaPartitionResponse
 */
async function checkMetaPartitionWithOptions(request: CheckMetaPartitionRequest, runtime: Util.RuntimeOptions): CheckMetaPartitionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    query['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partition)) {
    query['Partition'] = request.partition;
  }
  if (!Util.isUnset(request.tableGuid)) {
    query['TableGuid'] = request.tableGuid;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckMetaPartition',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CheckMetaPartitionRequest
 * @return CheckMetaPartitionResponse
 */
async function checkMetaPartition(request: CheckMetaPartitionRequest): CheckMetaPartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkMetaPartitionWithOptions(request, runtime);
}

model CheckMetaTableRequest {
  clusterId?: string(name='ClusterId'),
  dataSourceType?: string(name='DataSourceType'),
  databaseName?: string(name='DatabaseName'),
  tableGuid?: string(name='TableGuid'),
  tableName?: string(name='TableName'),
}

model CheckMetaTableResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model CheckMetaTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckMetaTableResponseBody(name='body'),
}

/**
 * @param request CheckMetaTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckMetaTableResponse
 */
async function checkMetaTableWithOptions(request: CheckMetaTableRequest, runtime: Util.RuntimeOptions): CheckMetaTableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    query['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableGuid)) {
    query['TableGuid'] = request.tableGuid;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckMetaTable',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CheckMetaTableRequest
 * @return CheckMetaTableResponse
 */
async function checkMetaTable(request: CheckMetaTableRequest): CheckMetaTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkMetaTableWithOptions(request, runtime);
}

model CheckProjectNameRequest {
  operator?: string(name='Operator'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
}

model CheckProjectNameResponseBody = {
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckProjectNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckProjectNameResponseBody(name='body'),
}

/**
 * @summary 检查项目唯一标识
 *
 * @param request CheckProjectNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckProjectNameResponse
 */
async function checkProjectNameWithOptions(request: CheckProjectNameRequest, runtime: Util.RuntimeOptions): CheckProjectNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckProjectName',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 检查项目唯一标识
 *
 * @param request CheckProjectNameRequest
 * @return CheckProjectNameResponse
 */
async function checkProjectName(request: CheckProjectNameRequest): CheckProjectNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkProjectNameWithOptions(request, runtime);
}

model ClearNodeQuotaRequest {
  nodeIds?: string(name='NodeIds', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
  refreshTaskInstance?: boolean(name='RefreshTaskInstance'),
}

model ClearNodeQuotaResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ClearNodeQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ClearNodeQuotaResponseBody(name='body'),
}

/**
 * @summary 清除节点quota
 *
 * @param request ClearNodeQuotaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ClearNodeQuotaResponse
 */
async function clearNodeQuotaWithOptions(request: ClearNodeQuotaRequest, runtime: Util.RuntimeOptions): ClearNodeQuotaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nodeIds)) {
    query['NodeIds'] = request.nodeIds;
  }
  if (!Util.isUnset(request.projectEnv)) {
    query['ProjectEnv'] = request.projectEnv;
  }
  if (!Util.isUnset(request.refreshTaskInstance)) {
    query['RefreshTaskInstance'] = request.refreshTaskInstance;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ClearNodeQuota',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 清除节点quota
 *
 * @param request ClearNodeQuotaRequest
 * @return ClearNodeQuotaResponse
 */
async function clearNodeQuota(request: ClearNodeQuotaRequest): ClearNodeQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return clearNodeQuotaWithOptions(request, runtime);
}

model CommandPublicModelEngineRequest {
  projectId?: string(name='ProjectId', description='This parameter is required.'),
  text?: string(name='Text', description='This parameter is required.'),
}

model CommandPublicModelEngineResponseBody = {
  requestId?: string(name='RequestId'),
  returnValue?: string(name='ReturnValue'),
}

model CommandPublicModelEngineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CommandPublicModelEngineResponseBody(name='body'),
}

/**
 * @param request CommandPublicModelEngineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CommandPublicModelEngineResponse
 */
async function commandPublicModelEngineWithOptions(request: CommandPublicModelEngineRequest, runtime: Util.RuntimeOptions): CommandPublicModelEngineResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.text)) {
    body['Text'] = request.text;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CommandPublicModelEngine',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CommandPublicModelEngineRequest
 * @return CommandPublicModelEngineResponse
 */
async function commandPublicModelEngine(request: CommandPublicModelEngineRequest): CommandPublicModelEngineResponse {
  var runtime = new Util.RuntimeOptions{};
  return commandPublicModelEngineWithOptions(request, runtime);
}

model CreateBusinessRequest {
  businessName?: string(name='BusinessName', description='This parameter is required.'),
  description?: string(name='Description'),
  owner?: string(name='Owner'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  useType?: string(name='UseType'),
}

model CreateBusinessResponseBody = {
  businessId?: long(name='BusinessId'),
  requestId?: string(name='RequestId'),
}

model CreateBusinessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateBusinessResponseBody(name='body'),
}

/**
 * @param request CreateBusinessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBusinessResponse
 */
async function createBusinessWithOptions(request: CreateBusinessRequest, runtime: Util.RuntimeOptions): CreateBusinessResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.businessName)) {
    body['BusinessName'] = request.businessName;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  if (!Util.isUnset(request.useType)) {
    body['UseType'] = request.useType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateBusiness',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateBusinessRequest
 * @return CreateBusinessResponse
 */
async function createBusiness(request: CreateBusinessRequest): CreateBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBusinessWithOptions(request, runtime);
}

model CreateBusinessBaselineRequest {
  alertFlag?: boolean(name='AlertFlag', description='This parameter is required.'),
  alertInterval?: int32(name='AlertInterval'),
  alertTarget?: string(name='AlertTarget'),
  baselineDescription?: string(name='BaselineDescription', description='This parameter is required.'),
  baselineName?: string(name='BaselineName', description='This parameter is required.'),
  baselineType?: string(name='BaselineType', description='This parameter is required.'),
  bizName?: string(name='BizName', description='This parameter is required.'),
  defaultParentNodeId?: long(name='DefaultParentNodeId', description='This parameter is required.'),
  errorRule?: string(name='ErrorRule'),
  expHour?: int32(name='ExpHour'),
  expMinu?: int32(name='ExpMinu'),
  hourExpDetail?: string(name='HourExpDetail'),
  hourSlaDetail?: string(name='HourSlaDetail'),
  maxAlertTimes?: int32(name='MaxAlertTimes'),
  owner?: string(name='Owner', description='This parameter is required.'),
  priority?: int32(name='Priority', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  slaHour?: int32(name='SlaHour'),
  slaMinu?: int32(name='SlaMinu'),
  slowRule?: string(name='SlowRule'),
  useFlag?: boolean(name='UseFlag', description='This parameter is required.'),
}

model CreateBusinessBaselineResponseBody = {
  baselineId?: long(name='BaselineId'),
  requestId?: string(name='RequestId'),
}

model CreateBusinessBaselineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateBusinessBaselineResponseBody(name='body'),
}

/**
 * @param request CreateBusinessBaselineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBusinessBaselineResponse
 */
async function createBusinessBaselineWithOptions(request: CreateBusinessBaselineRequest, runtime: Util.RuntimeOptions): CreateBusinessBaselineResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alertFlag)) {
    body['AlertFlag'] = request.alertFlag;
  }
  if (!Util.isUnset(request.alertInterval)) {
    body['AlertInterval'] = request.alertInterval;
  }
  if (!Util.isUnset(request.alertTarget)) {
    body['AlertTarget'] = request.alertTarget;
  }
  if (!Util.isUnset(request.baselineDescription)) {
    body['BaselineDescription'] = request.baselineDescription;
  }
  if (!Util.isUnset(request.baselineName)) {
    body['BaselineName'] = request.baselineName;
  }
  if (!Util.isUnset(request.baselineType)) {
    body['BaselineType'] = request.baselineType;
  }
  if (!Util.isUnset(request.bizName)) {
    body['BizName'] = request.bizName;
  }
  if (!Util.isUnset(request.defaultParentNodeId)) {
    body['DefaultParentNodeId'] = request.defaultParentNodeId;
  }
  if (!Util.isUnset(request.errorRule)) {
    body['ErrorRule'] = request.errorRule;
  }
  if (!Util.isUnset(request.expHour)) {
    body['ExpHour'] = request.expHour;
  }
  if (!Util.isUnset(request.expMinu)) {
    body['ExpMinu'] = request.expMinu;
  }
  if (!Util.isUnset(request.hourExpDetail)) {
    body['HourExpDetail'] = request.hourExpDetail;
  }
  if (!Util.isUnset(request.hourSlaDetail)) {
    body['HourSlaDetail'] = request.hourSlaDetail;
  }
  if (!Util.isUnset(request.maxAlertTimes)) {
    body['MaxAlertTimes'] = request.maxAlertTimes;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.priority)) {
    body['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.slaHour)) {
    body['SlaHour'] = request.slaHour;
  }
  if (!Util.isUnset(request.slaMinu)) {
    body['SlaMinu'] = request.slaMinu;
  }
  if (!Util.isUnset(request.slowRule)) {
    body['SlowRule'] = request.slowRule;
  }
  if (!Util.isUnset(request.useFlag)) {
    body['UseFlag'] = request.useFlag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateBusinessBaseline',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateBusinessBaselineRequest
 * @return CreateBusinessBaselineResponse
 */
async function createBusinessBaseline(request: CreateBusinessBaselineRequest): CreateBusinessBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBusinessBaselineWithOptions(request, runtime);
}

model CreateDIAlarmRuleRequest {
  clientToken?: string(name='ClientToken'),
  DIJobId?: long(name='DIJobId', description='任务ID，是告警规则关联的任务ID。

This parameter is required.'),
  description?: string(name='Description', description='描述。'),
  enabled?: boolean(name='Enabled', description='告警规则是否启用，默认不开启。'),
  metricType?: string(name='MetricType', description='告警指标类型，可选的枚举值：
- Heartbeat（任务状态报警）
- FailoverCount（failover次数报警）
- Delay（任务延迟报警）

This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  notificationSettings?: {
    inhibitionInterval?: int32(name='InhibitionInterval', deprecated=true),
    muteInterval?: int32(name='MuteInterval'),
    notificationChannels?: [ 
      {
        channels?: [ string ](name='Channels'),
        severity?: string(name='Severity'),
      }
    ](name='NotificationChannels'),
    notificationReceivers?: [ 
      {
        receiverType?: string(name='ReceiverType'),
        receiverValues?: [ string ](name='ReceiverValues'),
      }
    ](name='NotificationReceivers'),
  }(name='NotificationSettings', description='This parameter is required.'),
  triggerConditions?: [ 
    {
      ddlReportTags?: [ string ](name='DdlReportTags', deprecated=true),
      ddlTypes?: [ string ](name='DdlTypes'),
      duration?: long(name='Duration'),
      severity?: string(name='Severity'),
      threshold?: long(name='Threshold'),
    }
  ](name='TriggerConditions', description='This parameter is required.'),
}

model CreateDIAlarmRuleShrinkRequest {
  clientToken?: string(name='ClientToken'),
  DIJobId?: long(name='DIJobId', description='任务ID，是告警规则关联的任务ID。

This parameter is required.'),
  description?: string(name='Description', description='描述。'),
  enabled?: boolean(name='Enabled', description='告警规则是否启用，默认不开启。'),
  metricType?: string(name='MetricType', description='告警指标类型，可选的枚举值：
- Heartbeat（任务状态报警）
- FailoverCount（failover次数报警）
- Delay（任务延迟报警）

This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  notificationSettingsShrink?: string(name='NotificationSettings', description='This parameter is required.'),
  triggerConditionsShrink?: string(name='TriggerConditions', description='This parameter is required.'),
}

model CreateDIAlarmRuleResponseBody = {
  DIAlarmRuleId?: string(name='DIAlarmRuleId', deprecated=true),
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateDIAlarmRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDIAlarmRuleResponseBody(name='body'),
}

/**
 * @summary 创建数据集成报警规则
 *
 * @param tmpReq CreateDIAlarmRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDIAlarmRuleResponse
 */
async function createDIAlarmRuleWithOptions(tmpReq: CreateDIAlarmRuleRequest, runtime: Util.RuntimeOptions): CreateDIAlarmRuleResponse {
  Util.validateModel(tmpReq);
  var request = new CreateDIAlarmRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.notificationSettings)) {
    request.notificationSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.notificationSettings, 'NotificationSettings', 'json');
  }
  if (!Util.isUnset(tmpReq.triggerConditions)) {
    request.triggerConditionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.triggerConditions, 'TriggerConditions', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDIAlarmRule',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建数据集成报警规则
 *
 * @param request CreateDIAlarmRuleRequest
 * @return CreateDIAlarmRuleResponse
 */
async function createDIAlarmRule(request: CreateDIAlarmRuleRequest): CreateDIAlarmRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDIAlarmRuleWithOptions(request, runtime);
}

model CreateDIJobRequest {
  description?: string(name='Description'),
  destinationDataSourceSettings?: [ 
    {
      dataSourceName?: string(name='DataSourceName'),
    }
  ](name='DestinationDataSourceSettings', description='This parameter is required.'),
  destinationDataSourceType?: string(name='DestinationDataSourceType', description='This parameter is required.'),
  jobName?: string(name='JobName', deprecated=true),
  jobSettings?: {
    channelSettings?: string(name='ChannelSettings'),
    columnDataTypeSettings?: [ 
      {
        destinationDataType?: string(name='DestinationDataType'),
        sourceDataType?: string(name='SourceDataType'),
      }
    ](name='ColumnDataTypeSettings'),
    cycleScheduleSettings?: {
      cycleMigrationType?: string(name='CycleMigrationType'),
      scheduleParameters?: string(name='ScheduleParameters'),
    }(name='CycleScheduleSettings'),
    ddlHandlingSettings?: [ 
      {
        action?: string(name='Action'),
        type?: string(name='Type'),
      }
    ](name='DdlHandlingSettings'),
    runtimeSettings?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='RuntimeSettings'),
  }(name='JobSettings'),
  migrationType?: string(name='MigrationType', description='This parameter is required.'),
  name?: string(name='Name'),
  projectId?: long(name='ProjectId'),
  resourceSettings?: {
    offlineResourceSettings?: {
      requestedCu?: double(name='RequestedCu'),
      resourceGroupIdentifier?: string(name='ResourceGroupIdentifier'),
    }(name='OfflineResourceSettings'),
    realtimeResourceSettings?: {
      requestedCu?: double(name='RequestedCu'),
      resourceGroupIdentifier?: string(name='ResourceGroupIdentifier'),
    }(name='RealtimeResourceSettings'),
    scheduleResourceSettings?: {
      requestedCu?: double(name='RequestedCu'),
      resourceGroupIdentifier?: string(name='ResourceGroupIdentifier'),
    }(name='ScheduleResourceSettings'),
  }(name='ResourceSettings', description='This parameter is required.'),
  sourceDataSourceSettings?: [ 
    {
      dataSourceName?: string(name='DataSourceName'),
      dataSourceProperties?: {
        encoding?: string(name='Encoding'),
        timezone?: string(name='Timezone'),
      }(name='DataSourceProperties'),
    }
  ](name='SourceDataSourceSettings', description='This parameter is required.'),
  sourceDataSourceType?: string(name='SourceDataSourceType', description='This parameter is required.'),
  tableMappings?: [ 
    {
      sourceObjectSelectionRules?: [ 
        {
          action?: string(name='Action'),
          expression?: string(name='Expression'),
          expressionType?: string(name='ExpressionType'),
          objectType?: string(name='ObjectType'),
        }
      ](name='SourceObjectSelectionRules'),
      transformationRules?: [ 
        {
          ruleActionType?: string(name='RuleActionType'),
          ruleName?: string(name='RuleName'),
          ruleTargetType?: string(name='RuleTargetType'),
        }
      ](name='TransformationRules'),
    }
  ](name='TableMappings', description='This parameter is required.'),
  transformationRules?: [ 
    {
      ruleActionType?: string(name='RuleActionType'),
      ruleExpression?: string(name='RuleExpression'),
      ruleName?: string(name='RuleName'),
      ruleTargetType?: string(name='RuleTargetType'),
    }
  ](name='TransformationRules'),
}

model CreateDIJobShrinkRequest {
  description?: string(name='Description'),
  destinationDataSourceSettingsShrink?: string(name='DestinationDataSourceSettings', description='This parameter is required.'),
  destinationDataSourceType?: string(name='DestinationDataSourceType', description='This parameter is required.'),
  jobName?: string(name='JobName', deprecated=true),
  jobSettingsShrink?: string(name='JobSettings'),
  migrationType?: string(name='MigrationType', description='This parameter is required.'),
  name?: string(name='Name'),
  projectId?: long(name='ProjectId'),
  resourceSettingsShrink?: string(name='ResourceSettings', description='This parameter is required.'),
  sourceDataSourceSettingsShrink?: string(name='SourceDataSourceSettings', description='This parameter is required.'),
  sourceDataSourceType?: string(name='SourceDataSourceType', description='This parameter is required.'),
  tableMappingsShrink?: string(name='TableMappings', description='This parameter is required.'),
  transformationRulesShrink?: string(name='TransformationRules'),
}

model CreateDIJobResponseBody = {
  DIJobId?: long(name='DIJobId', deprecated=true),
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateDIJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDIJobResponseBody(name='body'),
}

/**
 * @summary 创建数据集成任务
 *
 * @param tmpReq CreateDIJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDIJobResponse
 */
async function createDIJobWithOptions(tmpReq: CreateDIJobRequest, runtime: Util.RuntimeOptions): CreateDIJobResponse {
  Util.validateModel(tmpReq);
  var request = new CreateDIJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.destinationDataSourceSettings)) {
    request.destinationDataSourceSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.destinationDataSourceSettings, 'DestinationDataSourceSettings', 'json');
  }
  if (!Util.isUnset(tmpReq.jobSettings)) {
    request.jobSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.jobSettings, 'JobSettings', 'json');
  }
  if (!Util.isUnset(tmpReq.resourceSettings)) {
    request.resourceSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceSettings, 'ResourceSettings', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceDataSourceSettings)) {
    request.sourceDataSourceSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceDataSourceSettings, 'SourceDataSourceSettings', 'json');
  }
  if (!Util.isUnset(tmpReq.tableMappings)) {
    request.tableMappingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tableMappings, 'TableMappings', 'json');
  }
  if (!Util.isUnset(tmpReq.transformationRules)) {
    request.transformationRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.transformationRules, 'TransformationRules', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDIJob',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建数据集成任务
 *
 * @param request CreateDIJobRequest
 * @return CreateDIJobResponse
 */
async function createDIJob(request: CreateDIJobRequest): CreateDIJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDIJobWithOptions(request, runtime);
}

model CreateDagComplementRequest {
  bizBeginTime?: string(name='BizBeginTime'),
  bizEndTime?: string(name='BizEndTime'),
  endBizDate?: string(name='EndBizDate', description='This parameter is required.'),
  excludeNodeIds?: string(name='ExcludeNodeIds'),
  includeNodeIds?: string(name='IncludeNodeIds', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  nodeParams?: string(name='NodeParams'),
  parallelism?: boolean(name='Parallelism', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
  rootNodeId?: long(name='RootNodeId', description='This parameter is required.'),
  startBizDate?: string(name='StartBizDate', description='This parameter is required.'),
  startFutureInstanceImmediately?: boolean(name='StartFutureInstanceImmediately'),
}

model CreateDagComplementResponseBody = {
  data?: [ long ](name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateDagComplementResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDagComplementResponseBody(name='body'),
}

/**
 * @param request CreateDagComplementRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDagComplementResponse
 */
async function createDagComplementWithOptions(request: CreateDagComplementRequest, runtime: Util.RuntimeOptions): CreateDagComplementResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizBeginTime)) {
    body['BizBeginTime'] = request.bizBeginTime;
  }
  if (!Util.isUnset(request.bizEndTime)) {
    body['BizEndTime'] = request.bizEndTime;
  }
  if (!Util.isUnset(request.endBizDate)) {
    body['EndBizDate'] = request.endBizDate;
  }
  if (!Util.isUnset(request.excludeNodeIds)) {
    body['ExcludeNodeIds'] = request.excludeNodeIds;
  }
  if (!Util.isUnset(request.includeNodeIds)) {
    body['IncludeNodeIds'] = request.includeNodeIds;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.nodeParams)) {
    body['NodeParams'] = request.nodeParams;
  }
  if (!Util.isUnset(request.parallelism)) {
    body['Parallelism'] = request.parallelism;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  if (!Util.isUnset(request.rootNodeId)) {
    body['RootNodeId'] = request.rootNodeId;
  }
  if (!Util.isUnset(request.startBizDate)) {
    body['StartBizDate'] = request.startBizDate;
  }
  if (!Util.isUnset(request.startFutureInstanceImmediately)) {
    body['StartFutureInstanceImmediately'] = request.startFutureInstanceImmediately;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDagComplement',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateDagComplementRequest
 * @return CreateDagComplementResponse
 */
async function createDagComplement(request: CreateDagComplementRequest): CreateDagComplementResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDagComplementWithOptions(request, runtime);
}

model CreateDagTestRequest {
  bizdate?: string(name='Bizdate', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  nodeId?: long(name='NodeId', description='This parameter is required.'),
  nodeParams?: string(name='NodeParams'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
}

model CreateDagTestResponseBody = {
  dagId?: long(name='DagId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDagTestResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDagTestResponseBody(name='body'),
}

/**
 * @param request CreateDagTestRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDagTestResponse
 */
async function createDagTestWithOptions(request: CreateDagTestRequest, runtime: Util.RuntimeOptions): CreateDagTestResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizdate)) {
    body['Bizdate'] = request.bizdate;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.nodeParams)) {
    body['NodeParams'] = request.nodeParams;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDagTest',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateDagTestRequest
 * @return CreateDagTestResponse
 */
async function createDagTest(request: CreateDagTestRequest): CreateDagTestResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDagTestWithOptions(request, runtime);
}

model CreateDataQualityEvaluationTaskRequest {
  dataQualityRules?: [ 
    {
      checkingConfig?: {
        referencedSamplesFilter?: string(name='ReferencedSamplesFilter'),
        thresholds?: {
          critical?: {
            operator?: string(name='Operator'),
            value?: string(name='Value'),
          }(name='Critical'),
          expected?: {
            operator?: string(name='Operator'),
            value?: string(name='Value'),
          }(name='Expected'),
          warned?: {
            operator?: string(name='Operator'),
            value?: string(name='Value'),
          }(name='Warned'),
        }(name='Thresholds'),
        type?: string(name='Type'),
      }(name='CheckingConfig'),
      description?: string(name='Description'),
      enabled?: boolean(name='Enabled'),
      errorHandlers?: [ 
        {
          errorDataFilter?: string(name='ErrorDataFilter'),
          type?: string(name='Type'),
        }
      ](name='ErrorHandlers'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      samplingConfig?: {
        metric?: string(name='Metric'),
        metricParameters?: string(name='MetricParameters'),
        samplingFilter?: string(name='SamplingFilter'),
        settingConfig?: string(name='SettingConfig'),
      }(name='SamplingConfig'),
      severity?: string(name='Severity'),
      templateCode?: string(name='TemplateCode'),
    }
  ](name='DataQualityRules'),
  dataSourceId?: long(name='DataSourceId'),
  description?: string(name='Description', description='质量监控任务描述'),
  hooks?: [ 
    {
      condition?: string(name='Condition', description='Hook触发条件'),
      type?: string(name='Type', description='Hook类型'),
    }
  ](name='Hooks', description='数据质量校验任务实例生命周期中的回调设置，目前只支持一个阻塞调度任务的Hook'),
  name?: string(name='Name', description='质量监控任务名称

This parameter is required.'),
  notifications?: {
    condition?: string(name='Condition', description='通知触发条件'),
    notifications?: [ 
      {
        notificationChannels?: [ 
          {
            channels?: [ string ](name='Channels', description='通知方式'),
          }
        ](name='NotificationChannels', description='通知方式'),
        notificationReceivers?: [ 
          {
            extension?: string(name='Extension', description='扩展信息，格式为 json，例如钉钉机器人支持 at 所有人'),
            receiverType?: string(name='ReceiverType', description='告警接收人类型'),
            receiverValues?: [ string ](name='ReceiverValues', description='告警接收人'),
          }
        ](name='NotificationReceivers', description='告警接收人设置'),
      }
    ](name='Notifications', description='具体的消息通知设置'),
  }(name='Notifications', description='数据质量校验任务通知订阅配置'),
  projectId?: long(name='ProjectId', description='项目空间Id'),
  runtimeConf?: string(name='RuntimeConf', description='使用数据源时的一些设置，目前只支持指定EMR的yarn队列、采集EMR表时把SQL引擎指定为SPARK-SQL'),
  target?: {
    databaseType?: string(name='DatabaseType', description='表所属的数据库类型'),
    partitionSpec?: string(name='PartitionSpec', description='分区表的分区设置'),
    tableGuid?: string(name='TableGuid', description='表在数据地图中的唯一ID'),
  }(name='Target', description='参看 DataQualityTarget示例	数据质量校验任务的监控对象，参考 DataQualityTarget'),
  trigger?: {
    taskIds?: [ long ](name='TaskIds', description='具体指明哪些调度节点的实例执行成功后可以触发'),
    type?: string(name='Type', description='何种事件可以触发质量校验任务执行'),
  }(name='Trigger', description='数据质量校验任务的触发配置'),
}

model CreateDataQualityEvaluationTaskShrinkRequest {
  dataQualityRulesShrink?: string(name='DataQualityRules'),
  dataSourceId?: long(name='DataSourceId'),
  description?: string(name='Description', description='质量监控任务描述'),
  hooksShrink?: string(name='Hooks', description='数据质量校验任务实例生命周期中的回调设置，目前只支持一个阻塞调度任务的Hook'),
  name?: string(name='Name', description='质量监控任务名称

This parameter is required.'),
  notificationsShrink?: string(name='Notifications', description='数据质量校验任务通知订阅配置'),
  projectId?: long(name='ProjectId', description='项目空间Id'),
  runtimeConf?: string(name='RuntimeConf', description='使用数据源时的一些设置，目前只支持指定EMR的yarn队列、采集EMR表时把SQL引擎指定为SPARK-SQL'),
  targetShrink?: string(name='Target', description='参看 DataQualityTarget示例	数据质量校验任务的监控对象，参考 DataQualityTarget'),
  triggerShrink?: string(name='Trigger', description='数据质量校验任务的触发配置'),
}

model CreateDataQualityEvaluationTaskResponseBody = {
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateDataQualityEvaluationTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDataQualityEvaluationTaskResponseBody(name='body'),
}

/**
 * @summary 创建DataWorks数据质量监控
 *
 * @param tmpReq CreateDataQualityEvaluationTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDataQualityEvaluationTaskResponse
 */
async function createDataQualityEvaluationTaskWithOptions(tmpReq: CreateDataQualityEvaluationTaskRequest, runtime: Util.RuntimeOptions): CreateDataQualityEvaluationTaskResponse {
  Util.validateModel(tmpReq);
  var request = new CreateDataQualityEvaluationTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dataQualityRules)) {
    request.dataQualityRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dataQualityRules, 'DataQualityRules', 'json');
  }
  if (!Util.isUnset(tmpReq.hooks)) {
    request.hooksShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.hooks, 'Hooks', 'json');
  }
  if (!Util.isUnset(tmpReq.notifications)) {
    request.notificationsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.notifications, 'Notifications', 'json');
  }
  if (!Util.isUnset(tmpReq.target)) {
    request.targetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.target, 'Target', 'json');
  }
  if (!Util.isUnset(tmpReq.trigger)) {
    request.triggerShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.trigger, 'Trigger', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataQualityRulesShrink)) {
    body['DataQualityRules'] = request.dataQualityRulesShrink;
  }
  if (!Util.isUnset(request.dataSourceId)) {
    body['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.hooksShrink)) {
    body['Hooks'] = request.hooksShrink;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.notificationsShrink)) {
    body['Notifications'] = request.notificationsShrink;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.runtimeConf)) {
    body['RuntimeConf'] = request.runtimeConf;
  }
  if (!Util.isUnset(request.targetShrink)) {
    body['Target'] = request.targetShrink;
  }
  if (!Util.isUnset(request.triggerShrink)) {
    body['Trigger'] = request.triggerShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataQualityEvaluationTask',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建DataWorks数据质量监控
 *
 * @param request CreateDataQualityEvaluationTaskRequest
 * @return CreateDataQualityEvaluationTaskResponse
 */
async function createDataQualityEvaluationTask(request: CreateDataQualityEvaluationTaskRequest): CreateDataQualityEvaluationTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataQualityEvaluationTaskWithOptions(request, runtime);
}

model CreateDataQualityEvaluationTaskInstanceRequest {
  dataQualityEvaluationTaskId?: long(name='DataQualityEvaluationTaskId', description='This parameter is required.'),
  parameters?: string(name='Parameters', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  runtimeResource?: {
    cu?: double(name='Cu'),
    resourceGroupId?: string(name='ResourceGroupId'),
  }(name='RuntimeResource'),
}

model CreateDataQualityEvaluationTaskInstanceShrinkRequest {
  dataQualityEvaluationTaskId?: long(name='DataQualityEvaluationTaskId', description='This parameter is required.'),
  parameters?: string(name='Parameters', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  runtimeResourceShrink?: string(name='RuntimeResource'),
}

model CreateDataQualityEvaluationTaskInstanceResponseBody = {
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateDataQualityEvaluationTaskInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDataQualityEvaluationTaskInstanceResponseBody(name='body'),
}

/**
 * @summary 创建数据质量校验任务实例
 *
 * @param tmpReq CreateDataQualityEvaluationTaskInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDataQualityEvaluationTaskInstanceResponse
 */
async function createDataQualityEvaluationTaskInstanceWithOptions(tmpReq: CreateDataQualityEvaluationTaskInstanceRequest, runtime: Util.RuntimeOptions): CreateDataQualityEvaluationTaskInstanceResponse {
  Util.validateModel(tmpReq);
  var request = new CreateDataQualityEvaluationTaskInstanceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.runtimeResource)) {
    request.runtimeResourceShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.runtimeResource, 'RuntimeResource', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataQualityEvaluationTaskId)) {
    body['DataQualityEvaluationTaskId'] = request.dataQualityEvaluationTaskId;
  }
  if (!Util.isUnset(request.parameters)) {
    body['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.runtimeResourceShrink)) {
    body['RuntimeResource'] = request.runtimeResourceShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataQualityEvaluationTaskInstance',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建数据质量校验任务实例
 *
 * @param request CreateDataQualityEvaluationTaskInstanceRequest
 * @return CreateDataQualityEvaluationTaskInstanceResponse
 */
async function createDataQualityEvaluationTaskInstance(request: CreateDataQualityEvaluationTaskInstanceRequest): CreateDataQualityEvaluationTaskInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataQualityEvaluationTaskInstanceWithOptions(request, runtime);
}

model CreateDataQualityRuleRequest {
  checkingConfig?: {
    referencedSamplesFilter?: string(name='ReferencedSamplesFilter'),
    thresholds?: {
      critical?: {
        expression?: string(name='Expression'),
        operator?: string(name='Operator'),
        value?: string(name='Value'),
      }(name='Critical'),
      expected?: {
        expression?: string(name='Expression'),
        operator?: string(name='Operator'),
        value?: string(name='Value'),
      }(name='Expected'),
      warned?: {
        expression?: string(name='Expression'),
        operator?: string(name='Operator'),
        value?: string(name='Value'),
      }(name='Warned'),
    }(name='Thresholds'),
    type?: string(name='Type'),
  }(name='CheckingConfig'),
  description?: string(name='Description'),
  enabled?: boolean(name='Enabled'),
  errorHandlers?: [ 
    {
      errorDataFilter?: string(name='ErrorDataFilter'),
      type?: string(name='Type'),
    }
  ](name='ErrorHandlers'),
  name?: string(name='Name', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  samplingConfig?: {
    metric?: string(name='Metric'),
    metricParameters?: string(name='MetricParameters'),
    samplingFilter?: string(name='SamplingFilter'),
    settingConfig?: string(name='SettingConfig'),
  }(name='SamplingConfig'),
  severity?: string(name='Severity'),
  target?: {
    databaseType?: string(name='DatabaseType'),
    partitionSpec?: string(name='PartitionSpec'),
    tableGuid?: string(name='TableGuid', description='This parameter is required.'),
    type?: string(name='Type'),
  }(name='Target'),
  templateCode?: string(name='TemplateCode'),
}

model CreateDataQualityRuleShrinkRequest {
  checkingConfigShrink?: string(name='CheckingConfig'),
  description?: string(name='Description'),
  enabled?: boolean(name='Enabled'),
  errorHandlersShrink?: string(name='ErrorHandlers'),
  name?: string(name='Name', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  samplingConfigShrink?: string(name='SamplingConfig'),
  severity?: string(name='Severity'),
  targetShrink?: string(name='Target'),
  templateCode?: string(name='TemplateCode'),
}

model CreateDataQualityRuleResponseBody = {
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateDataQualityRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDataQualityRuleResponseBody(name='body'),
}

/**
 * @summary 创建质量规则
 *
 * @param tmpReq CreateDataQualityRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDataQualityRuleResponse
 */
async function createDataQualityRuleWithOptions(tmpReq: CreateDataQualityRuleRequest, runtime: Util.RuntimeOptions): CreateDataQualityRuleResponse {
  Util.validateModel(tmpReq);
  var request = new CreateDataQualityRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.checkingConfig)) {
    request.checkingConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.checkingConfig, 'CheckingConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.errorHandlers)) {
    request.errorHandlersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.errorHandlers, 'ErrorHandlers', 'json');
  }
  if (!Util.isUnset(tmpReq.samplingConfig)) {
    request.samplingConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.samplingConfig, 'SamplingConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.target)) {
    request.targetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.target, 'Target', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkingConfigShrink)) {
    body['CheckingConfig'] = request.checkingConfigShrink;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.enabled)) {
    body['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.errorHandlersShrink)) {
    body['ErrorHandlers'] = request.errorHandlersShrink;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.samplingConfigShrink)) {
    body['SamplingConfig'] = request.samplingConfigShrink;
  }
  if (!Util.isUnset(request.severity)) {
    body['Severity'] = request.severity;
  }
  if (!Util.isUnset(request.targetShrink)) {
    body['Target'] = request.targetShrink;
  }
  if (!Util.isUnset(request.templateCode)) {
    body['TemplateCode'] = request.templateCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataQualityRule',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建质量规则
 *
 * @param request CreateDataQualityRuleRequest
 * @return CreateDataQualityRuleResponse
 */
async function createDataQualityRule(request: CreateDataQualityRuleRequest): CreateDataQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataQualityRuleWithOptions(request, runtime);
}

model CreateDataQualityRuleTemplateRequest {
  checkingConfig?: {
    referencedSamplesFilter?: string(name='ReferencedSamplesFilter'),
    type?: string(name='Type'),
  }(name='CheckingConfig'),
  directoryPath?: string(name='DirectoryPath'),
  name?: string(name='Name', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  samplingConfig?: {
    metric?: string(name='Metric'),
    metricParameters?: string(name='MetricParameters'),
    settingConfig?: string(name='SettingConfig'),
  }(name='SamplingConfig'),
  visibleScope?: string(name='VisibleScope'),
}

model CreateDataQualityRuleTemplateShrinkRequest {
  checkingConfigShrink?: string(name='CheckingConfig'),
  directoryPath?: string(name='DirectoryPath'),
  name?: string(name='Name', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  samplingConfigShrink?: string(name='SamplingConfig'),
  visibleScope?: string(name='VisibleScope'),
}

model CreateDataQualityRuleTemplateResponseBody = {
  code?: string(name='Code'),
  requestId?: string(name='RequestId'),
}

model CreateDataQualityRuleTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDataQualityRuleTemplateResponseBody(name='body'),
}

/**
 * @summary 创建规则模版
 *
 * @param tmpReq CreateDataQualityRuleTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDataQualityRuleTemplateResponse
 */
async function createDataQualityRuleTemplateWithOptions(tmpReq: CreateDataQualityRuleTemplateRequest, runtime: Util.RuntimeOptions): CreateDataQualityRuleTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new CreateDataQualityRuleTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.checkingConfig)) {
    request.checkingConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.checkingConfig, 'CheckingConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.samplingConfig)) {
    request.samplingConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.samplingConfig, 'SamplingConfig', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkingConfigShrink)) {
    body['CheckingConfig'] = request.checkingConfigShrink;
  }
  if (!Util.isUnset(request.directoryPath)) {
    body['DirectoryPath'] = request.directoryPath;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.samplingConfigShrink)) {
    body['SamplingConfig'] = request.samplingConfigShrink;
  }
  if (!Util.isUnset(request.visibleScope)) {
    body['VisibleScope'] = request.visibleScope;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataQualityRuleTemplate',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建规则模版
 *
 * @param request CreateDataQualityRuleTemplateRequest
 * @return CreateDataQualityRuleTemplateResponse
 */
async function createDataQualityRuleTemplate(request: CreateDataQualityRuleTemplateRequest): CreateDataQualityRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataQualityRuleTemplateWithOptions(request, runtime);
}

model CreateDataSourceRequest {
  content?: string(name='Content', description='This parameter is required.'),
  dataSourceType?: string(name='DataSourceType', description='This parameter is required.'),
  description?: string(name='Description'),
  envType?: int32(name='EnvType', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  operator?: string(name='Operator'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  subType?: string(name='SubType'),
}

model CreateDataSourceResponseBody = {
  data?: long(name='Data'),
  httpStatusCode?: string(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDataSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDataSourceResponseBody(name='body'),
}

/**
 * @summary 创建数据源
 *
 * @param request CreateDataSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDataSourceResponse
 */
async function createDataSourceWithOptions(request: CreateDataSourceRequest, runtime: Util.RuntimeOptions): CreateDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    query['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.envType)) {
    query['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.subType)) {
    query['SubType'] = request.subType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataSource',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建数据源
 *
 * @param request CreateDataSourceRequest
 * @return CreateDataSourceResponse
 */
async function createDataSource(request: CreateDataSourceRequest): CreateDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataSourceWithOptions(request, runtime);
}

model CreateDeploymentRequest {
  description?: string(name='Description'),
  objectIds?: [ string ](name='ObjectIds', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='项目Id

This parameter is required.'),
  type?: string(name='Type', description='This parameter is required.'),
}

model CreateDeploymentShrinkRequest {
  description?: string(name='Description'),
  objectIdsShrink?: string(name='ObjectIds', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='项目Id

This parameter is required.'),
  type?: string(name='Type', description='This parameter is required.'),
}

model CreateDeploymentResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateDeploymentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDeploymentResponseBody(name='body'),
}

/**
 * @summary 创建发布流程
 *
 * @param tmpReq CreateDeploymentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDeploymentResponse
 */
async function createDeploymentWithOptions(tmpReq: CreateDeploymentRequest, runtime: Util.RuntimeOptions): CreateDeploymentResponse {
  Util.validateModel(tmpReq);
  var request = new CreateDeploymentShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.objectIds)) {
    request.objectIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.objectIds, 'ObjectIds', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.objectIdsShrink)) {
    body['ObjectIds'] = request.objectIdsShrink;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDeployment',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建发布流程
 *
 * @param request CreateDeploymentRequest
 * @return CreateDeploymentResponse
 */
async function createDeployment(request: CreateDeploymentRequest): CreateDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDeploymentWithOptions(request, runtime);
}

model CreateFileRequest {
  advancedSettings?: string(name='AdvancedSettings'),
  applyScheduleImmediately?: boolean(name='ApplyScheduleImmediately'),
  autoParsing?: boolean(name='AutoParsing'),
  autoRerunIntervalMillis?: int32(name='AutoRerunIntervalMillis'),
  autoRerunTimes?: int32(name='AutoRerunTimes'),
  connectionName?: string(name='ConnectionName'),
  content?: string(name='Content'),
  createFolderIfNotExists?: boolean(name='CreateFolderIfNotExists'),
  cronExpress?: string(name='CronExpress'),
  cycleType?: string(name='CycleType'),
  dependentNodeIdList?: string(name='DependentNodeIdList'),
  dependentType?: string(name='DependentType'),
  endEffectDate?: long(name='EndEffectDate'),
  fileDescription?: string(name='FileDescription'),
  fileFolderPath?: string(name='FileFolderPath'),
  fileName?: string(name='FileName', description='This parameter is required.'),
  fileType?: int32(name='FileType', description='This parameter is required.'),
  ignoreParentSkipRunningProperty?: boolean(name='IgnoreParentSkipRunningProperty'),
  imageId?: string(name='ImageId'),
  inputList?: string(name='InputList'),
  inputParameters?: string(name='InputParameters'),
  outputParameters?: string(name='OutputParameters'),
  owner?: string(name='Owner'),
  paraValue?: string(name='ParaValue'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  rerunMode?: string(name='RerunMode'),
  resourceGroupId?: long(name='ResourceGroupId'),
  resourceGroupIdentifier?: string(name='ResourceGroupIdentifier'),
  schedulerType?: string(name='SchedulerType'),
  startEffectDate?: long(name='StartEffectDate'),
  startImmediately?: boolean(name='StartImmediately'),
  stop?: boolean(name='Stop'),
  timeout?: int32(name='Timeout'),
}

model CreateFileResponseBody = {
  data?: long(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFileResponseBody(name='body'),
}

/**
 * @param request CreateFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFileResponse
 */
async function createFileWithOptions(request: CreateFileRequest, runtime: Util.RuntimeOptions): CreateFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.advancedSettings)) {
    body['AdvancedSettings'] = request.advancedSettings;
  }
  if (!Util.isUnset(request.applyScheduleImmediately)) {
    body['ApplyScheduleImmediately'] = request.applyScheduleImmediately;
  }
  if (!Util.isUnset(request.autoParsing)) {
    body['AutoParsing'] = request.autoParsing;
  }
  if (!Util.isUnset(request.autoRerunIntervalMillis)) {
    body['AutoRerunIntervalMillis'] = request.autoRerunIntervalMillis;
  }
  if (!Util.isUnset(request.autoRerunTimes)) {
    body['AutoRerunTimes'] = request.autoRerunTimes;
  }
  if (!Util.isUnset(request.connectionName)) {
    body['ConnectionName'] = request.connectionName;
  }
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.createFolderIfNotExists)) {
    body['CreateFolderIfNotExists'] = request.createFolderIfNotExists;
  }
  if (!Util.isUnset(request.cronExpress)) {
    body['CronExpress'] = request.cronExpress;
  }
  if (!Util.isUnset(request.cycleType)) {
    body['CycleType'] = request.cycleType;
  }
  if (!Util.isUnset(request.dependentNodeIdList)) {
    body['DependentNodeIdList'] = request.dependentNodeIdList;
  }
  if (!Util.isUnset(request.dependentType)) {
    body['DependentType'] = request.dependentType;
  }
  if (!Util.isUnset(request.endEffectDate)) {
    body['EndEffectDate'] = request.endEffectDate;
  }
  if (!Util.isUnset(request.fileDescription)) {
    body['FileDescription'] = request.fileDescription;
  }
  if (!Util.isUnset(request.fileFolderPath)) {
    body['FileFolderPath'] = request.fileFolderPath;
  }
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.fileType)) {
    body['FileType'] = request.fileType;
  }
  if (!Util.isUnset(request.ignoreParentSkipRunningProperty)) {
    body['IgnoreParentSkipRunningProperty'] = request.ignoreParentSkipRunningProperty;
  }
  if (!Util.isUnset(request.imageId)) {
    body['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.inputList)) {
    body['InputList'] = request.inputList;
  }
  if (!Util.isUnset(request.inputParameters)) {
    body['InputParameters'] = request.inputParameters;
  }
  if (!Util.isUnset(request.outputParameters)) {
    body['OutputParameters'] = request.outputParameters;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.paraValue)) {
    body['ParaValue'] = request.paraValue;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  if (!Util.isUnset(request.rerunMode)) {
    body['RerunMode'] = request.rerunMode;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceGroupIdentifier)) {
    body['ResourceGroupIdentifier'] = request.resourceGroupIdentifier;
  }
  if (!Util.isUnset(request.schedulerType)) {
    body['SchedulerType'] = request.schedulerType;
  }
  if (!Util.isUnset(request.startEffectDate)) {
    body['StartEffectDate'] = request.startEffectDate;
  }
  if (!Util.isUnset(request.startImmediately)) {
    body['StartImmediately'] = request.startImmediately;
  }
  if (!Util.isUnset(request.stop)) {
    body['Stop'] = request.stop;
  }
  if (!Util.isUnset(request.timeout)) {
    body['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFile',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateFileRequest
 * @return CreateFileResponse
 */
async function createFile(request: CreateFileRequest): CreateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFileWithOptions(request, runtime);
}

model CreateFolderRequest {
  folderPath?: string(name='FolderPath', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model CreateFolderResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateFolderResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFolderResponseBody(name='body'),
}

/**
 * @param request CreateFolderRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFolderResponse
 */
async function createFolderWithOptions(request: CreateFolderRequest, runtime: Util.RuntimeOptions): CreateFolderResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.folderPath)) {
    body['FolderPath'] = request.folderPath;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFolder',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateFolderRequest
 * @return CreateFolderResponse
 */
async function createFolder(request: CreateFolderRequest): CreateFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFolderWithOptions(request, runtime);
}

model CreateFunctionRequest {
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  spec?: string(name='Spec', description='This parameter is required.'),
}

model CreateFunctionResponseBody = {
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFunctionResponseBody(name='body'),
}

/**
 * @summary 创建udf函数
 *
 * @param request CreateFunctionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFunctionResponse
 */
async function createFunctionWithOptions(request: CreateFunctionRequest, runtime: Util.RuntimeOptions): CreateFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.spec)) {
    body['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFunction',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建udf函数
 *
 * @param request CreateFunctionRequest
 * @return CreateFunctionResponse
 */
async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFunctionWithOptions(request, runtime);
}

model CreateManualDagRequest {
  bizDate?: string(name='BizDate', description='This parameter is required.'),
  dagParameters?: string(name='DagParameters'),
  excludeNodeIds?: string(name='ExcludeNodeIds'),
  flowName?: string(name='FlowName', description='This parameter is required.'),
  includeNodeIds?: string(name='IncludeNodeIds'),
  nodeParameters?: string(name='NodeParameters'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
}

model CreateManualDagResponseBody = {
  dagId?: long(name='DagId'),
  requestId?: string(name='RequestId'),
}

model CreateManualDagResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateManualDagResponseBody(name='body'),
}

/**
 * @param request CreateManualDagRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateManualDagResponse
 */
async function createManualDagWithOptions(request: CreateManualDagRequest, runtime: Util.RuntimeOptions): CreateManualDagResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizDate)) {
    body['BizDate'] = request.bizDate;
  }
  if (!Util.isUnset(request.dagParameters)) {
    body['DagParameters'] = request.dagParameters;
  }
  if (!Util.isUnset(request.excludeNodeIds)) {
    body['ExcludeNodeIds'] = request.excludeNodeIds;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.includeNodeIds)) {
    body['IncludeNodeIds'] = request.includeNodeIds;
  }
  if (!Util.isUnset(request.nodeParameters)) {
    body['NodeParameters'] = request.nodeParameters;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateManualDag',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateManualDagRequest
 * @return CreateManualDagResponse
 */
async function createManualDag(request: CreateManualDagRequest): CreateManualDagResponse {
  var runtime = new Util.RuntimeOptions{};
  return createManualDagWithOptions(request, runtime);
}

model CreateMetaCollectionRequest {
  collectionType?: string(name='CollectionType', description='This parameter is required.'),
  comment?: string(name='Comment'),
  name?: string(name='Name', description='This parameter is required.'),
  parentQualifiedName?: string(name='ParentQualifiedName'),
}

model CreateMetaCollectionResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: string(name='HttpStatusCode'),
  qualifiedName?: string(name='QualifiedName'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateMetaCollectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMetaCollectionResponseBody(name='body'),
}

/**
 * @summary 创建 collection
 *
 * @param request CreateMetaCollectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMetaCollectionResponse
 */
async function createMetaCollectionWithOptions(request: CreateMetaCollectionRequest, runtime: Util.RuntimeOptions): CreateMetaCollectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.collectionType)) {
    query['CollectionType'] = request.collectionType;
  }
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.parentQualifiedName)) {
    query['ParentQualifiedName'] = request.parentQualifiedName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMetaCollection',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建 collection
 *
 * @param request CreateMetaCollectionRequest
 * @return CreateMetaCollectionResponse
 */
async function createMetaCollection(request: CreateMetaCollectionRequest): CreateMetaCollectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMetaCollectionWithOptions(request, runtime);
}

model CreateNodeRequest {
  containerId?: string(name='ContainerId'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  scene?: string(name='Scene', description='This parameter is required.'),
  spec?: string(name='Spec', description='This parameter is required.'),
}

model CreateNodeResponseBody = {
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateNodeResponseBody(name='body'),
}

/**
 * @summary 创建节点
 *
 * @param request CreateNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNodeResponse
 */
async function createNodeWithOptions(request: CreateNodeRequest, runtime: Util.RuntimeOptions): CreateNodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.containerId)) {
    body['ContainerId'] = request.containerId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.scene)) {
    body['Scene'] = request.scene;
  }
  if (!Util.isUnset(request.spec)) {
    body['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateNode',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建节点
 *
 * @param request CreateNodeRequest
 * @return CreateNodeResponse
 */
async function createNode(request: CreateNodeRequest): CreateNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNodeWithOptions(request, runtime);
}

model CreateProjectRequest {
  displayName?: string(name='DisplayName', description='This parameter is required.'),
  operator?: string(name='Operator', description='This parameter is required.'),
  projectDesc?: string(name='ProjectDesc'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
}

model CreateProjectResponseBody = {
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateProjectResponseBody(name='body'),
}

/**
 * @summary 创建Dataworks 项目空间
 *
 * @param request CreateProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProjectResponse
 */
async function createProjectWithOptions(request: CreateProjectRequest, runtime: Util.RuntimeOptions): CreateProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.projectDesc)) {
    query['ProjectDesc'] = request.projectDesc;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateProject',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建Dataworks 项目空间
 *
 * @param request CreateProjectRequest
 * @return CreateProjectResponse
 */
async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProjectWithOptions(request, runtime);
}

model CreateProjectMemberRequest {
  clientToken?: string(name='ClientToken'),
  operator?: string(name='Operator'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  roleCode?: string(name='RoleCode', description='This parameter is required.'),
  userId?: string(name='UserId', description='This parameter is required.'),
}

model CreateProjectMemberResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateProjectMemberResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateProjectMemberResponseBody(name='body'),
}

/**
 * @summary add member to project with roles
 *
 * @param request CreateProjectMemberRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProjectMemberResponse
 */
async function createProjectMemberWithOptions(request: CreateProjectMemberRequest, runtime: Util.RuntimeOptions): CreateProjectMemberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.roleCode)) {
    query['RoleCode'] = request.roleCode;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateProjectMember',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary add member to project with roles
 *
 * @param request CreateProjectMemberRequest
 * @return CreateProjectMemberResponse
 */
async function createProjectMember(request: CreateProjectMemberRequest): CreateProjectMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProjectMemberWithOptions(request, runtime);
}

model CreateQualityEntityRequest {
  entityLevel?: int32(name='EntityLevel', description='This parameter is required.'),
  envType?: string(name='EnvType', description='This parameter is required.'),
  matchExpression?: string(name='MatchExpression', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
  tableName?: string(name='TableName', description='This parameter is required.'),
}

model CreateQualityEntityResponseBody = {
  data?: int32(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateQualityEntityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateQualityEntityResponseBody(name='body'),
}

/**
 * @param request CreateQualityEntityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateQualityEntityResponse
 */
async function createQualityEntityWithOptions(request: CreateQualityEntityRequest, runtime: Util.RuntimeOptions): CreateQualityEntityResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.entityLevel)) {
    body['EntityLevel'] = request.entityLevel;
  }
  if (!Util.isUnset(request.envType)) {
    body['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.matchExpression)) {
    body['MatchExpression'] = request.matchExpression;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateQualityEntity',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateQualityEntityRequest
 * @return CreateQualityEntityResponse
 */
async function createQualityEntity(request: CreateQualityEntityRequest): CreateQualityEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQualityEntityWithOptions(request, runtime);
}

model CreateQualityFollowerRequest {
  alarmMode?: int32(name='AlarmMode', description='This parameter is required.'),
  entityId?: long(name='EntityId', description='This parameter is required.'),
  follower?: string(name='Follower', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
}

model CreateQualityFollowerResponseBody = {
  data?: int32(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateQualityFollowerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateQualityFollowerResponseBody(name='body'),
}

/**
 * @param request CreateQualityFollowerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateQualityFollowerResponse
 */
async function createQualityFollowerWithOptions(request: CreateQualityFollowerRequest, runtime: Util.RuntimeOptions): CreateQualityFollowerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alarmMode)) {
    body['AlarmMode'] = request.alarmMode;
  }
  if (!Util.isUnset(request.entityId)) {
    body['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.follower)) {
    body['Follower'] = request.follower;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateQualityFollower',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateQualityFollowerRequest
 * @return CreateQualityFollowerResponse
 */
async function createQualityFollower(request: CreateQualityFollowerRequest): CreateQualityFollowerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQualityFollowerWithOptions(request, runtime);
}

model CreateQualityRuleRequest {
  blockType?: int32(name='BlockType', description='This parameter is required.'),
  checker?: int32(name='Checker'),
  comment?: string(name='Comment'),
  criticalThreshold?: string(name='CriticalThreshold'),
  entityId?: long(name='EntityId', description='This parameter is required.'),
  expectValue?: string(name='ExpectValue'),
  methodName?: string(name='MethodName'),
  operator?: string(name='Operator'),
  predictType?: int32(name='PredictType', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
  property?: string(name='Property'),
  propertyType?: string(name='PropertyType'),
  ruleName?: string(name='RuleName', description='This parameter is required.'),
  ruleType?: int32(name='RuleType', description='This parameter is required.'),
  templateId?: int32(name='TemplateId'),
  trend?: string(name='Trend'),
  warningThreshold?: string(name='WarningThreshold'),
  whereCondition?: string(name='WhereCondition'),
}

model CreateQualityRuleResponseBody = {
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateQualityRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateQualityRuleResponseBody(name='body'),
}

/**
 * @param request CreateQualityRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateQualityRuleResponse
 */
async function createQualityRuleWithOptions(request: CreateQualityRuleRequest, runtime: Util.RuntimeOptions): CreateQualityRuleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.blockType)) {
    body['BlockType'] = request.blockType;
  }
  if (!Util.isUnset(request.checker)) {
    body['Checker'] = request.checker;
  }
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.criticalThreshold)) {
    body['CriticalThreshold'] = request.criticalThreshold;
  }
  if (!Util.isUnset(request.entityId)) {
    body['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.expectValue)) {
    body['ExpectValue'] = request.expectValue;
  }
  if (!Util.isUnset(request.methodName)) {
    body['MethodName'] = request.methodName;
  }
  if (!Util.isUnset(request.operator)) {
    body['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.predictType)) {
    body['PredictType'] = request.predictType;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.property)) {
    body['Property'] = request.property;
  }
  if (!Util.isUnset(request.propertyType)) {
    body['PropertyType'] = request.propertyType;
  }
  if (!Util.isUnset(request.ruleName)) {
    body['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleType)) {
    body['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.trend)) {
    body['Trend'] = request.trend;
  }
  if (!Util.isUnset(request.warningThreshold)) {
    body['WarningThreshold'] = request.warningThreshold;
  }
  if (!Util.isUnset(request.whereCondition)) {
    body['WhereCondition'] = request.whereCondition;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateQualityRule',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateQualityRuleRequest
 * @return CreateQualityRuleResponse
 */
async function createQualityRule(request: CreateQualityRuleRequest): CreateQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQualityRuleWithOptions(request, runtime);
}

model CreateRemindRequest {
  alertInterval?: int32(name='AlertInterval'),
  alertMethods?: string(name='AlertMethods'),
  alertTargets?: string(name='AlertTargets'),
  alertUnit?: string(name='AlertUnit', description='This parameter is required.'),
  baselineIds?: string(name='BaselineIds'),
  bizProcessIds?: string(name='BizProcessIds'),
  detail?: string(name='Detail'),
  dndEnd?: string(name='DndEnd'),
  maxAlertTimes?: int32(name='MaxAlertTimes'),
  nodeIds?: string(name='NodeIds'),
  projectId?: long(name='ProjectId'),
  remindName?: string(name='RemindName', description='This parameter is required.'),
  remindType?: string(name='RemindType', description='This parameter is required.'),
  remindUnit?: string(name='RemindUnit', description='This parameter is required.'),
  robotUrls?: string(name='RobotUrls'),
}

model CreateRemindResponseBody = {
  data?: long(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateRemindResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRemindResponseBody(name='body'),
}

/**
 * @param request CreateRemindRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRemindResponse
 */
async function createRemindWithOptions(request: CreateRemindRequest, runtime: Util.RuntimeOptions): CreateRemindResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alertInterval)) {
    body['AlertInterval'] = request.alertInterval;
  }
  if (!Util.isUnset(request.alertMethods)) {
    body['AlertMethods'] = request.alertMethods;
  }
  if (!Util.isUnset(request.alertTargets)) {
    body['AlertTargets'] = request.alertTargets;
  }
  if (!Util.isUnset(request.alertUnit)) {
    body['AlertUnit'] = request.alertUnit;
  }
  if (!Util.isUnset(request.baselineIds)) {
    body['BaselineIds'] = request.baselineIds;
  }
  if (!Util.isUnset(request.bizProcessIds)) {
    body['BizProcessIds'] = request.bizProcessIds;
  }
  if (!Util.isUnset(request.detail)) {
    body['Detail'] = request.detail;
  }
  if (!Util.isUnset(request.dndEnd)) {
    body['DndEnd'] = request.dndEnd;
  }
  if (!Util.isUnset(request.maxAlertTimes)) {
    body['MaxAlertTimes'] = request.maxAlertTimes;
  }
  if (!Util.isUnset(request.nodeIds)) {
    body['NodeIds'] = request.nodeIds;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.remindName)) {
    body['RemindName'] = request.remindName;
  }
  if (!Util.isUnset(request.remindType)) {
    body['RemindType'] = request.remindType;
  }
  if (!Util.isUnset(request.remindUnit)) {
    body['RemindUnit'] = request.remindUnit;
  }
  if (!Util.isUnset(request.robotUrls)) {
    body['RobotUrls'] = request.robotUrls;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRemind',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateRemindRequest
 * @return CreateRemindResponse
 */
async function createRemind(request: CreateRemindRequest): CreateRemindResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRemindWithOptions(request, runtime);
}

model CreateResourceRequest {
  projectId?: long(name='ProjectId', description='资源文件的项目id

This parameter is required.'),
  spec?: string(name='Spec', description='This parameter is required.'),
}

model CreateResourceResponseBody = {
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateResourceResponseBody(name='body'),
}

/**
 * @summary 创建资源文件
 *
 * @param request CreateResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateResourceResponse
 */
async function createResourceWithOptions(request: CreateResourceRequest, runtime: Util.RuntimeOptions): CreateResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.spec)) {
    body['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResource',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建资源文件
 *
 * @param request CreateResourceRequest
 * @return CreateResourceResponse
 */
async function createResource(request: CreateResourceRequest): CreateResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createResourceWithOptions(request, runtime);
}

model CreateResourceFileRequest {
  content?: string(name='Content'),
  fileDescription?: string(name='FileDescription'),
  fileFolderPath?: string(name='FileFolderPath', description='This parameter is required.'),
  fileName?: string(name='FileName', description='This parameter is required.'),
  fileType?: int32(name='FileType', description='This parameter is required.'),
  originResourceName?: string(name='OriginResourceName', description='This parameter is required.'),
  owner?: string(name='Owner'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  registerToCalcEngine?: boolean(name='RegisterToCalcEngine', description='This parameter is required.'),
  resourceFile?: string(name='ResourceFile'),
  storageURL?: string(name='StorageURL'),
  uploadMode?: boolean(name='UploadMode'),
}

model CreateResourceFileAdvanceRequest {
  content?: string(name='Content'),
  fileDescription?: string(name='FileDescription'),
  fileFolderPath?: string(name='FileFolderPath', description='This parameter is required.'),
  fileName?: string(name='FileName', description='This parameter is required.'),
  fileType?: int32(name='FileType', description='This parameter is required.'),
  originResourceName?: string(name='OriginResourceName', description='This parameter is required.'),
  owner?: string(name='Owner'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  registerToCalcEngine?: boolean(name='RegisterToCalcEngine', description='This parameter is required.'),
  resourceFileObject?: readable(name='ResourceFile'),
  storageURL?: string(name='StorageURL'),
  uploadMode?: boolean(name='UploadMode'),
}

model CreateResourceFileResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateResourceFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateResourceFileResponseBody(name='body'),
}

/**
 * @summary 支持用户指定自己的文件（比如jar，py，arhive，file等）创建数据开发资源文件
 *
 * @param request CreateResourceFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateResourceFileResponse
 */
async function createResourceFileWithOptions(request: CreateResourceFileRequest, runtime: Util.RuntimeOptions): CreateResourceFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.fileDescription)) {
    body['FileDescription'] = request.fileDescription;
  }
  if (!Util.isUnset(request.fileFolderPath)) {
    body['FileFolderPath'] = request.fileFolderPath;
  }
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.fileType)) {
    body['FileType'] = request.fileType;
  }
  if (!Util.isUnset(request.originResourceName)) {
    body['OriginResourceName'] = request.originResourceName;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.registerToCalcEngine)) {
    body['RegisterToCalcEngine'] = request.registerToCalcEngine;
  }
  if (!Util.isUnset(request.resourceFile)) {
    body['ResourceFile'] = request.resourceFile;
  }
  if (!Util.isUnset(request.storageURL)) {
    body['StorageURL'] = request.storageURL;
  }
  if (!Util.isUnset(request.uploadMode)) {
    body['UploadMode'] = request.uploadMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourceFile',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 支持用户指定自己的文件（比如jar，py，arhive，file等）创建数据开发资源文件
 *
 * @param request CreateResourceFileRequest
 * @return CreateResourceFileResponse
 */
async function createResourceFile(request: CreateResourceFileRequest): CreateResourceFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createResourceFileWithOptions(request, runtime);
}

async function createResourceFileAdvance(request: CreateResourceFileAdvanceRequest, runtime: Util.RuntimeOptions): CreateResourceFileResponse {
  // Step 0: init client
  var credentialModel: Credential.CredentialModel = null;
  if (Util.isUnset(@credential)) {
    throw {
      code = 'InvalidCredentials',
      message = 'Please set up the credentials correctly. If you are setting them through environment variables, please ensure that ALIBABA_CLOUD_ACCESS_KEY_ID and ALIBABA_CLOUD_ACCESS_KEY_SECRET are set correctly. See https://help.aliyun.com/zh/sdk/developer-reference/configure-the-alibaba-cloud-accesskey-environment-variable-on-linux-macos-and-windows-systems for more details.'
    }
  }
  credentialModel = @credential.getCredential();
  var accessKeyId = credentialModel.accessKeyId;
  var accessKeySecret = credentialModel.accessKeySecret;
  var securityToken = credentialModel.securityToken;
  var credentialType = credentialModel.type;
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.empty(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenApi(authConfig);
  var authRequest = {
    Product = 'dataworks',
    RegionId = @regionId,
  };
  var authReq = new OpenApi.OpenApiRequest{
    query = OpenApiUtil.query(authRequest),
  };
  var authParams = new OpenApi.Params{
    action = 'AuthorizeFileUpload',
    version = '2019-12-19',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  var authResponse : object = {};
  var fileObj = new FileForm.FileField{};
  var ossHeader: object = {};
  var tmpBody: object = {};
  var useAccelerate: boolean = false;
  var authResponseBody: map[string]string = {};
  var createResourceFileReq = new CreateResourceFileRequest{};
  OpenApiUtil.convert(request, createResourceFileReq);

  if(!Util.isUnset(request.resourceFileObject)) {
    var tmpResp0: any = authClient.callApi(authParams, authReq, runtime);
    authResponse = Util.assertAsMap(tmpResp0);
    tmpBody = Util.assertAsMap(authResponse['body']);
    useAccelerate = Util.assertAsBoolean(tmpBody['UseAccelerate']);
    authResponseBody = Util.stringifyMapValue(tmpBody);
    fileObj = new FileForm.FileField{
      filename = authResponseBody['ObjectKey'],
      content = request.resourceFileObject,
      contentType = '',
    };
    ossHeader = {
      host = `${authResponseBody['Bucket']}.${OpenApiUtil.getEndpoint(authResponseBody['Endpoint'], useAccelerate, @endpointType)}`,
      OSSAccessKeyId = authResponseBody['AccessKeyId'],
      policy = authResponseBody['EncodedPolicy'],
      Signature = authResponseBody['Signature'],
      key = authResponseBody['ObjectKey'],
      file = fileObj,
      success_action_status = '201',
    };
    _postOSSObject(authResponseBody['Bucket'], ossHeader);
    createResourceFileReq.resourceFile = `http://${authResponseBody['Bucket']}.${authResponseBody['Endpoint']}/${authResponseBody['ObjectKey']}`;
  }
  var createResourceFileResp = createResourceFileWithOptions(createResourceFileReq, runtime);
  return createResourceFileResp;
}

model CreateUdfFileRequest {
  className?: string(name='ClassName', description='This parameter is required.'),
  cmdDescription?: string(name='CmdDescription'),
  example?: string(name='Example'),
  fileFolderPath?: string(name='FileFolderPath'),
  fileName?: string(name='FileName', description='This parameter is required.'),
  functionType?: string(name='FunctionType', description='This parameter is required.'),
  parameterDescription?: string(name='ParameterDescription'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  resources?: string(name='Resources', description='This parameter is required.'),
  returnValue?: string(name='ReturnValue'),
  udfDescription?: string(name='UdfDescription'),
}

model CreateUdfFileResponseBody = {
  data?: long(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateUdfFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateUdfFileResponseBody(name='body'),
}

/**
 * @param request CreateUdfFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUdfFileResponse
 */
async function createUdfFileWithOptions(request: CreateUdfFileRequest, runtime: Util.RuntimeOptions): CreateUdfFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.className)) {
    body['ClassName'] = request.className;
  }
  if (!Util.isUnset(request.cmdDescription)) {
    body['CmdDescription'] = request.cmdDescription;
  }
  if (!Util.isUnset(request.example)) {
    body['Example'] = request.example;
  }
  if (!Util.isUnset(request.fileFolderPath)) {
    body['FileFolderPath'] = request.fileFolderPath;
  }
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.functionType)) {
    body['FunctionType'] = request.functionType;
  }
  if (!Util.isUnset(request.parameterDescription)) {
    body['ParameterDescription'] = request.parameterDescription;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  if (!Util.isUnset(request.resources)) {
    body['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.returnValue)) {
    body['ReturnValue'] = request.returnValue;
  }
  if (!Util.isUnset(request.udfDescription)) {
    body['UdfDescription'] = request.udfDescription;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateUdfFile',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateUdfFileRequest
 * @return CreateUdfFileResponse
 */
async function createUdfFile(request: CreateUdfFileRequest): CreateUdfFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUdfFileWithOptions(request, runtime);
}

model CreateWorkflowDefinitionRequest {
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  spec?: string(name='Spec', description='This parameter is required.'),
}

model CreateWorkflowDefinitionResponseBody = {
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateWorkflowDefinitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateWorkflowDefinitionResponseBody(name='body'),
}

/**
 * @summary 创建工作流
 *
 * @param request CreateWorkflowDefinitionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateWorkflowDefinitionResponse
 */
async function createWorkflowDefinitionWithOptions(request: CreateWorkflowDefinitionRequest, runtime: Util.RuntimeOptions): CreateWorkflowDefinitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.spec)) {
    body['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateWorkflowDefinition',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建工作流
 *
 * @param request CreateWorkflowDefinitionRequest
 * @return CreateWorkflowDefinitionResponse
 */
async function createWorkflowDefinition(request: CreateWorkflowDefinitionRequest): CreateWorkflowDefinitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createWorkflowDefinitionWithOptions(request, runtime);
}

model CreateWorkflowInstancesRequest {
  autoStartEnabled?: boolean(name='AutoStartEnabled'),
  comment?: string(name='Comment'),
  defaultRunProperties?: {
    alert?: {
      noticeType?: string(name='NoticeType'),
      type?: string(name='Type'),
    }(name='Alert'),
    analysis?: {
      blocked?: boolean(name='Blocked'),
      enabled?: boolean(name='Enabled'),
    }(name='Analysis'),
    excludeProjectIds?: [ long ](name='ExcludeProjectIds'),
    excludeTaskIds?: [ long ](name='ExcludeTaskIds'),
    includeProjectIds?: [ long ](name='IncludeProjectIds'),
    includeTaskIds?: [ long ](name='IncludeTaskIds'),
    mode?: string(name='Mode'),
    order?: string(name='Order'),
    parallelism?: int32(name='Parallelism'),
    rootTaskIds?: [ long ](name='RootTaskIds'),
    runPolicy?: {
      endTime?: string(name='EndTime'),
      immediately?: boolean(name='Immediately'),
      startTime?: string(name='StartTime'),
      type?: string(name='Type'),
    }(name='RunPolicy'),
    runtimeResource?: string(name='RuntimeResource'),
  }(name='DefaultRunProperties'),
  envType?: string(name='EnvType'),
  name?: string(name='Name', description='This parameter is required.'),
  periods?: {
    bizDates?: [ 
      {
        endBizDate?: string(name='EndBizDate', description='This parameter is required.'),
        startBizDate?: string(name='StartBizDate', description='This parameter is required.'),
      }
    ](name='BizDates', description='This parameter is required.'),
    endTime?: string(name='EndTime'),
    startTime?: string(name='StartTime'),
  }(name='Periods'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  taskParameters?: string(name='TaskParameters'),
  type?: string(name='Type', description='This parameter is required.'),
  workflowId?: long(name='WorkflowId', description='This parameter is required.'),
  workflowParameters?: string(name='WorkflowParameters'),
}

model CreateWorkflowInstancesShrinkRequest {
  autoStartEnabled?: boolean(name='AutoStartEnabled'),
  comment?: string(name='Comment'),
  defaultRunPropertiesShrink?: string(name='DefaultRunProperties'),
  envType?: string(name='EnvType'),
  name?: string(name='Name', description='This parameter is required.'),
  periodsShrink?: string(name='Periods'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  taskParameters?: string(name='TaskParameters'),
  type?: string(name='Type', description='This parameter is required.'),
  workflowId?: long(name='WorkflowId', description='This parameter is required.'),
  workflowParameters?: string(name='WorkflowParameters'),
}

model CreateWorkflowInstancesResponseBody = {
  operationId?: string(name='OperationId'),
  requestId?: string(name='RequestId'),
}

model CreateWorkflowInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateWorkflowInstancesResponseBody(name='body'),
}

/**
 * @param tmpReq CreateWorkflowInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateWorkflowInstancesResponse
 */
async function createWorkflowInstancesWithOptions(tmpReq: CreateWorkflowInstancesRequest, runtime: Util.RuntimeOptions): CreateWorkflowInstancesResponse {
  Util.validateModel(tmpReq);
  var request = new CreateWorkflowInstancesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.defaultRunProperties)) {
    request.defaultRunPropertiesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.defaultRunProperties, 'DefaultRunProperties', 'json');
  }
  if (!Util.isUnset(tmpReq.periods)) {
    request.periodsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.periods, 'Periods', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoStartEnabled)) {
    body['AutoStartEnabled'] = request.autoStartEnabled;
  }
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.defaultRunPropertiesShrink)) {
    body['DefaultRunProperties'] = request.defaultRunPropertiesShrink;
  }
  if (!Util.isUnset(request.envType)) {
    body['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.periodsShrink)) {
    body['Periods'] = request.periodsShrink;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.taskParameters)) {
    body['TaskParameters'] = request.taskParameters;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  if (!Util.isUnset(request.workflowId)) {
    body['WorkflowId'] = request.workflowId;
  }
  if (!Util.isUnset(request.workflowParameters)) {
    body['WorkflowParameters'] = request.workflowParameters;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateWorkflowInstances',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateWorkflowInstancesRequest
 * @return CreateWorkflowInstancesResponse
 */
async function createWorkflowInstances(request: CreateWorkflowInstancesRequest): CreateWorkflowInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createWorkflowInstancesWithOptions(request, runtime);
}

model DeleteBaselineConfigRequest {
  baselineId?: long(name='BaselineId', description='This parameter is required.'),
}

model DeleteBaselineConfigResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteBaselineConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteBaselineConfigResponseBody(name='body'),
}

/**
 * @param request DeleteBaselineConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBaselineConfigResponse
 */
async function deleteBaselineConfigWithOptions(request: DeleteBaselineConfigRequest, runtime: Util.RuntimeOptions): DeleteBaselineConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.baselineId)) {
    body['BaselineId'] = request.baselineId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBaselineConfig',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteBaselineConfigRequest
 * @return DeleteBaselineConfigResponse
 */
async function deleteBaselineConfig(request: DeleteBaselineConfigRequest): DeleteBaselineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBaselineConfigWithOptions(request, runtime);
}

model DeleteBusinessRequest {
  businessId?: long(name='BusinessId', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model DeleteBusinessResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteBusinessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteBusinessResponseBody(name='body'),
}

/**
 * @param request DeleteBusinessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBusinessResponse
 */
async function deleteBusinessWithOptions(request: DeleteBusinessRequest, runtime: Util.RuntimeOptions): DeleteBusinessResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.businessId)) {
    body['BusinessId'] = request.businessId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBusiness',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteBusinessRequest
 * @return DeleteBusinessResponse
 */
async function deleteBusiness(request: DeleteBusinessRequest): DeleteBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBusinessWithOptions(request, runtime);
}

model DeleteDIAlarmRuleRequest {
  DIAlarmRuleId?: long(name='DIAlarmRuleId', deprecated=true),
  DIJobId?: long(name='DIJobId'),
  id?: long(name='Id'),
}

model DeleteDIAlarmRuleResponseBody = {
  requestId?: string(name='RequestId', description='代表资源一级ID的资源属性字段'),
  success?: boolean(name='Success'),
}

model DeleteDIAlarmRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDIAlarmRuleResponseBody(name='body'),
}

/**
 * @summary 删除数据集成报警规则
 *
 * @param request DeleteDIAlarmRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDIAlarmRuleResponse
 */
async function deleteDIAlarmRuleWithOptions(request: DeleteDIAlarmRuleRequest, runtime: Util.RuntimeOptions): DeleteDIAlarmRuleResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDIAlarmRule',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除数据集成报警规则
 *
 * @param request DeleteDIAlarmRuleRequest
 * @return DeleteDIAlarmRuleResponse
 */
async function deleteDIAlarmRule(request: DeleteDIAlarmRuleRequest): DeleteDIAlarmRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDIAlarmRuleWithOptions(request, runtime);
}

model DeleteDIJobRequest {
  DIJobId?: long(name='DIJobId', deprecated=true),
  id?: long(name='Id'),
  projectId?: long(name='ProjectId'),
}

model DeleteDIJobResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDIJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDIJobResponseBody(name='body'),
}

/**
 * @summary 删除数据集成任务
 *
 * @param request DeleteDIJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDIJobResponse
 */
async function deleteDIJobWithOptions(request: DeleteDIJobRequest, runtime: Util.RuntimeOptions): DeleteDIJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDIJob',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除数据集成任务
 *
 * @param request DeleteDIJobRequest
 * @return DeleteDIJobResponse
 */
async function deleteDIJob(request: DeleteDIJobRequest): DeleteDIJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDIJobWithOptions(request, runtime);
}

model DeleteDataQualityEvaluationTaskRequest {
  id?: long(name='Id'),
  projectId?: long(name='ProjectId'),
}

model DeleteDataQualityEvaluationTaskResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDataQualityEvaluationTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDataQualityEvaluationTaskResponseBody(name='body'),
}

/**
 * @summary 删除数据质量校验任务
 *
 * @param request DeleteDataQualityEvaluationTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDataQualityEvaluationTaskResponse
 */
async function deleteDataQualityEvaluationTaskWithOptions(request: DeleteDataQualityEvaluationTaskRequest, runtime: Util.RuntimeOptions): DeleteDataQualityEvaluationTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataQualityEvaluationTask',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除数据质量校验任务
 *
 * @param request DeleteDataQualityEvaluationTaskRequest
 * @return DeleteDataQualityEvaluationTaskResponse
 */
async function deleteDataQualityEvaluationTask(request: DeleteDataQualityEvaluationTaskRequest): DeleteDataQualityEvaluationTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDataQualityEvaluationTaskWithOptions(request, runtime);
}

model DeleteDataQualityRuleRequest {
  id?: long(name='Id'),
  projectId?: long(name='ProjectId'),
}

model DeleteDataQualityRuleResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDataQualityRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDataQualityRuleResponseBody(name='body'),
}

/**
 * @summary 删除质量规则
 *
 * @param request DeleteDataQualityRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDataQualityRuleResponse
 */
async function deleteDataQualityRuleWithOptions(request: DeleteDataQualityRuleRequest, runtime: Util.RuntimeOptions): DeleteDataQualityRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataQualityRule',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除质量规则
 *
 * @param request DeleteDataQualityRuleRequest
 * @return DeleteDataQualityRuleResponse
 */
async function deleteDataQualityRule(request: DeleteDataQualityRuleRequest): DeleteDataQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDataQualityRuleWithOptions(request, runtime);
}

model DeleteDataQualityRuleTemplateRequest {
  code?: string(name='Code', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
}

model DeleteDataQualityRuleTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDataQualityRuleTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDataQualityRuleTemplateResponseBody(name='body'),
}

/**
 * @summary 删除自定义模版
 *
 * @param request DeleteDataQualityRuleTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDataQualityRuleTemplateResponse
 */
async function deleteDataQualityRuleTemplateWithOptions(request: DeleteDataQualityRuleTemplateRequest, runtime: Util.RuntimeOptions): DeleteDataQualityRuleTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.code)) {
    query['Code'] = request.code;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataQualityRuleTemplate',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除自定义模版
 *
 * @param request DeleteDataQualityRuleTemplateRequest
 * @return DeleteDataQualityRuleTemplateResponse
 */
async function deleteDataQualityRuleTemplate(request: DeleteDataQualityRuleTemplateRequest): DeleteDataQualityRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDataQualityRuleTemplateWithOptions(request, runtime);
}

model DeleteDataSourceRequest {
  dataSourceId?: long(name='DataSourceId', description='This parameter is required.'),
  operator?: string(name='Operator'),
}

model DeleteDataSourceResponseBody = {
  data?: boolean(name='Data'),
  httpStatusCode?: string(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDataSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDataSourceResponseBody(name='body'),
}

/**
 * @param request DeleteDataSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDataSourceResponse
 */
async function deleteDataSourceWithOptions(request: DeleteDataSourceRequest, runtime: Util.RuntimeOptions): DeleteDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataSourceId)) {
    query['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataSource',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteDataSourceRequest
 * @return DeleteDataSourceResponse
 */
async function deleteDataSource(request: DeleteDataSourceRequest): DeleteDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDataSourceWithOptions(request, runtime);
}

model DeleteFileRequest {
  fileId?: long(name='FileId', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model DeleteFileResponseBody = {
  deploymentId?: long(name='DeploymentId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFileResponseBody(name='body'),
}

/**
 * @param request DeleteFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFileResponse
 */
async function deleteFileWithOptions(request: DeleteFileRequest, runtime: Util.RuntimeOptions): DeleteFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFile',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteFileRequest
 * @return DeleteFileResponse
 */
async function deleteFile(request: DeleteFileRequest): DeleteFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFileWithOptions(request, runtime);
}

model DeleteFolderRequest {
  folderId?: string(name='FolderId', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model DeleteFolderResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteFolderResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFolderResponseBody(name='body'),
}

/**
 * @param request DeleteFolderRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFolderResponse
 */
async function deleteFolderWithOptions(request: DeleteFolderRequest, runtime: Util.RuntimeOptions): DeleteFolderResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.folderId)) {
    body['FolderId'] = request.folderId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFolder',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteFolderRequest
 * @return DeleteFolderResponse
 */
async function deleteFolder(request: DeleteFolderRequest): DeleteFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFolderWithOptions(request, runtime);
}

model DeleteFromMetaCategoryRequest {
  categoryId?: long(name='CategoryId', description='This parameter is required.'),
  tableGuid?: string(name='TableGuid', description='This parameter is required.'),
}

model DeleteFromMetaCategoryResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteFromMetaCategoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFromMetaCategoryResponseBody(name='body'),
}

/**
 * @param request DeleteFromMetaCategoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFromMetaCategoryResponse
 */
async function deleteFromMetaCategoryWithOptions(request: DeleteFromMetaCategoryRequest, runtime: Util.RuntimeOptions): DeleteFromMetaCategoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.categoryId)) {
    query['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.tableGuid)) {
    query['TableGuid'] = request.tableGuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFromMetaCategory',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteFromMetaCategoryRequest
 * @return DeleteFromMetaCategoryResponse
 */
async function deleteFromMetaCategory(request: DeleteFromMetaCategoryRequest): DeleteFromMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFromMetaCategoryWithOptions(request, runtime);
}

model DeleteFunctionRequest {
  id?: long(name='Id', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model DeleteFunctionResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFunctionResponseBody(name='body'),
}

/**
 * @summary 删除udf函数
 *
 * @param request DeleteFunctionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFunctionResponse
 */
async function deleteFunctionWithOptions(request: DeleteFunctionRequest, runtime: Util.RuntimeOptions): DeleteFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunction',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除udf函数
 *
 * @param request DeleteFunctionRequest
 * @return DeleteFunctionResponse
 */
async function deleteFunction(request: DeleteFunctionRequest): DeleteFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFunctionWithOptions(request, runtime);
}

model DeleteMetaCollectionRequest {
  qualifiedName?: string(name='QualifiedName', description='This parameter is required.'),
}

model DeleteMetaCollectionResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  status?: boolean(name='Status'),
  success?: boolean(name='Success'),
}

model DeleteMetaCollectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMetaCollectionResponseBody(name='body'),
}

/**
 * @summary 删除 collection
 *
 * @param request DeleteMetaCollectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMetaCollectionResponse
 */
async function deleteMetaCollectionWithOptions(request: DeleteMetaCollectionRequest, runtime: Util.RuntimeOptions): DeleteMetaCollectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.qualifiedName)) {
    query['QualifiedName'] = request.qualifiedName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMetaCollection',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除 collection
 *
 * @param request DeleteMetaCollectionRequest
 * @return DeleteMetaCollectionResponse
 */
async function deleteMetaCollection(request: DeleteMetaCollectionRequest): DeleteMetaCollectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetaCollectionWithOptions(request, runtime);
}

model DeleteMetaCollectionEntityRequest {
  collectionQualifiedName?: string(name='CollectionQualifiedName', description='This parameter is required.'),
  entityQualifiedName?: string(name='EntityQualifiedName', description='This parameter is required.'),
}

model DeleteMetaCollectionEntityResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  status?: boolean(name='Status'),
  success?: boolean(name='Success'),
}

model DeleteMetaCollectionEntityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMetaCollectionEntityResponseBody(name='body'),
}

/**
 * @summary 添加entity到collectioin中
 *
 * @param request DeleteMetaCollectionEntityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMetaCollectionEntityResponse
 */
async function deleteMetaCollectionEntityWithOptions(request: DeleteMetaCollectionEntityRequest, runtime: Util.RuntimeOptions): DeleteMetaCollectionEntityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.collectionQualifiedName)) {
    query['CollectionQualifiedName'] = request.collectionQualifiedName;
  }
  if (!Util.isUnset(request.entityQualifiedName)) {
    query['EntityQualifiedName'] = request.entityQualifiedName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMetaCollectionEntity',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 添加entity到collectioin中
 *
 * @param request DeleteMetaCollectionEntityRequest
 * @return DeleteMetaCollectionEntityResponse
 */
async function deleteMetaCollectionEntity(request: DeleteMetaCollectionEntityRequest): DeleteMetaCollectionEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetaCollectionEntityWithOptions(request, runtime);
}

model DeleteNodeRequest {
  id?: long(name='Id', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model DeleteNodeResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteNodeResponseBody(name='body'),
}

/**
 * @summary 删除节点
 *
 * @param request DeleteNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNodeResponse
 */
async function deleteNodeWithOptions(request: DeleteNodeRequest, runtime: Util.RuntimeOptions): DeleteNodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNode',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除节点
 *
 * @param request DeleteNodeRequest
 * @return DeleteNodeResponse
 */
async function deleteNode(request: DeleteNodeRequest): DeleteNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNodeWithOptions(request, runtime);
}

model DeleteProjectRequest {
  immediate?: boolean(name='Immediate'),
  needDeleteCalc?: boolean(name='NeedDeleteCalc'),
  operator?: string(name='Operator'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model DeleteProjectResponseBody = {
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteProjectResponseBody(name='body'),
}

/**
 * @summary 删除项目
 *
 * @param request DeleteProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteProjectResponse
 */
async function deleteProjectWithOptions(request: DeleteProjectRequest, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.immediate)) {
    query['Immediate'] = request.immediate;
  }
  if (!Util.isUnset(request.needDeleteCalc)) {
    query['NeedDeleteCalc'] = request.needDeleteCalc;
  }
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProject',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除项目
 *
 * @param request DeleteProjectRequest
 * @return DeleteProjectResponse
 */
async function deleteProject(request: DeleteProjectRequest): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProjectWithOptions(request, runtime);
}

model DeleteQualityEntityRequest {
  entityId?: long(name='EntityId', description='This parameter is required.'),
  envType?: string(name='EnvType', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
}

model DeleteQualityEntityResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteQualityEntityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteQualityEntityResponseBody(name='body'),
}

/**
 * @param request DeleteQualityEntityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteQualityEntityResponse
 */
async function deleteQualityEntityWithOptions(request: DeleteQualityEntityRequest, runtime: Util.RuntimeOptions): DeleteQualityEntityResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.entityId)) {
    body['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.envType)) {
    body['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteQualityEntity',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteQualityEntityRequest
 * @return DeleteQualityEntityResponse
 */
async function deleteQualityEntity(request: DeleteQualityEntityRequest): DeleteQualityEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQualityEntityWithOptions(request, runtime);
}

model DeleteQualityFollowerRequest {
  followerId?: long(name='FollowerId', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
}

model DeleteQualityFollowerResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteQualityFollowerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteQualityFollowerResponseBody(name='body'),
}

/**
 * @param request DeleteQualityFollowerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteQualityFollowerResponse
 */
async function deleteQualityFollowerWithOptions(request: DeleteQualityFollowerRequest, runtime: Util.RuntimeOptions): DeleteQualityFollowerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.followerId)) {
    body['FollowerId'] = request.followerId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteQualityFollower',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteQualityFollowerRequest
 * @return DeleteQualityFollowerResponse
 */
async function deleteQualityFollower(request: DeleteQualityFollowerRequest): DeleteQualityFollowerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQualityFollowerWithOptions(request, runtime);
}

model DeleteQualityRuleRequest {
  projectId?: long(name='ProjectId'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
  ruleId?: long(name='RuleId', description='This parameter is required.'),
}

model DeleteQualityRuleResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteQualityRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteQualityRuleResponseBody(name='body'),
}

/**
 * @param request DeleteQualityRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteQualityRuleResponse
 */
async function deleteQualityRuleWithOptions(request: DeleteQualityRuleRequest, runtime: Util.RuntimeOptions): DeleteQualityRuleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.ruleId)) {
    body['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteQualityRule',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteQualityRuleRequest
 * @return DeleteQualityRuleResponse
 */
async function deleteQualityRule(request: DeleteQualityRuleRequest): DeleteQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQualityRuleWithOptions(request, runtime);
}

model DeleteRemindRequest {
  remindId?: long(name='RemindId', description='This parameter is required.'),
}

model DeleteRemindResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteRemindResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRemindResponseBody(name='body'),
}

/**
 * @param request DeleteRemindRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRemindResponse
 */
async function deleteRemindWithOptions(request: DeleteRemindRequest, runtime: Util.RuntimeOptions): DeleteRemindResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.remindId)) {
    body['RemindId'] = request.remindId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRemind',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteRemindRequest
 * @return DeleteRemindResponse
 */
async function deleteRemind(request: DeleteRemindRequest): DeleteRemindResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRemindWithOptions(request, runtime);
}

model DeleteResourceRequest {
  id?: long(name='Id', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model DeleteResourceResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteResourceResponseBody(name='body'),
}

/**
 * @summary 删除资源文件
 *
 * @param request DeleteResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteResourceResponse
 */
async function deleteResourceWithOptions(request: DeleteResourceRequest, runtime: Util.RuntimeOptions): DeleteResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteResource',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除资源文件
 *
 * @param request DeleteResourceRequest
 * @return DeleteResourceResponse
 */
async function deleteResource(request: DeleteResourceRequest): DeleteResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteResourceWithOptions(request, runtime);
}

model DeleteWorkflowRequest {
  clientUniqueCode?: string(name='ClientUniqueCode'),
  envType?: string(name='EnvType'),
  id?: long(name='Id', description='This parameter is required.'),
}

model DeleteWorkflowResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteWorkflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteWorkflowResponseBody(name='body'),
}

/**
 * @param request DeleteWorkflowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteWorkflowResponse
 */
async function deleteWorkflowWithOptions(request: DeleteWorkflowRequest, runtime: Util.RuntimeOptions): DeleteWorkflowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientUniqueCode)) {
    body['ClientUniqueCode'] = request.clientUniqueCode;
  }
  if (!Util.isUnset(request.envType)) {
    body['EnvType'] = request.envType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWorkflow',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteWorkflowRequest
 * @return DeleteWorkflowResponse
 */
async function deleteWorkflow(request: DeleteWorkflowRequest): DeleteWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWorkflowWithOptions(request, runtime);
}

model DeleteWorkflowDefinitionRequest {
  id?: long(name='Id', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model DeleteWorkflowDefinitionResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteWorkflowDefinitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteWorkflowDefinitionResponseBody(name='body'),
}

/**
 * @summary 删除工作流
 *
 * @param request DeleteWorkflowDefinitionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteWorkflowDefinitionResponse
 */
async function deleteWorkflowDefinitionWithOptions(request: DeleteWorkflowDefinitionRequest, runtime: Util.RuntimeOptions): DeleteWorkflowDefinitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWorkflowDefinition',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除工作流
 *
 * @param request DeleteWorkflowDefinitionRequest
 * @return DeleteWorkflowDefinitionResponse
 */
async function deleteWorkflowDefinition(request: DeleteWorkflowDefinitionRequest): DeleteWorkflowDefinitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWorkflowDefinitionWithOptions(request, runtime);
}

model DeployFileRequest {
  comment?: string(name='Comment'),
  fileId?: long(name='FileId'),
  nodeId?: long(name='NodeId'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model DeployFileResponseBody = {
  data?: long(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeployFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeployFileResponseBody(name='body'),
}

/**
 * @param request DeployFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeployFileResponse
 */
async function deployFileWithOptions(request: DeployFileRequest, runtime: Util.RuntimeOptions): DeployFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeployFile',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeployFileRequest
 * @return DeployFileResponse
 */
async function deployFile(request: DeployFileRequest): DeployFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deployFileWithOptions(request, runtime);
}

model DetachDataQualityRulesFromEvaluationTaskRequest {
  dataQualityEvaluationTaskId?: long(name='DataQualityEvaluationTaskId', description='This parameter is required.'),
  dataQualityRuleIds?: [ long ](name='DataQualityRuleIds', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model DetachDataQualityRulesFromEvaluationTaskShrinkRequest {
  dataQualityEvaluationTaskId?: long(name='DataQualityEvaluationTaskId', description='This parameter is required.'),
  dataQualityRuleIdsShrink?: string(name='DataQualityRuleIds', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model DetachDataQualityRulesFromEvaluationTaskResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DetachDataQualityRulesFromEvaluationTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DetachDataQualityRulesFromEvaluationTaskResponseBody(name='body'),
}

/**
 * @summary 取消数据质量规则和数据质量校验任务的关联
 *
 * @param tmpReq DetachDataQualityRulesFromEvaluationTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachDataQualityRulesFromEvaluationTaskResponse
 */
async function detachDataQualityRulesFromEvaluationTaskWithOptions(tmpReq: DetachDataQualityRulesFromEvaluationTaskRequest, runtime: Util.RuntimeOptions): DetachDataQualityRulesFromEvaluationTaskResponse {
  Util.validateModel(tmpReq);
  var request = new DetachDataQualityRulesFromEvaluationTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dataQualityRuleIds)) {
    request.dataQualityRuleIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dataQualityRuleIds, 'DataQualityRuleIds', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataQualityEvaluationTaskId)) {
    body['DataQualityEvaluationTaskId'] = request.dataQualityEvaluationTaskId;
  }
  if (!Util.isUnset(request.dataQualityRuleIdsShrink)) {
    body['DataQualityRuleIds'] = request.dataQualityRuleIdsShrink;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetachDataQualityRulesFromEvaluationTask',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 取消数据质量规则和数据质量校验任务的关联
 *
 * @param request DetachDataQualityRulesFromEvaluationTaskRequest
 * @return DetachDataQualityRulesFromEvaluationTaskResponse
 */
async function detachDataQualityRulesFromEvaluationTask(request: DetachDataQualityRulesFromEvaluationTaskRequest): DetachDataQualityRulesFromEvaluationTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachDataQualityRulesFromEvaluationTaskWithOptions(request, runtime);
}

model DisableCheckerForProjectRequest {
  checkerIdentifier?: string(name='CheckerIdentifier', description='This parameter is required.'),
  checkerType?: string(name='CheckerType', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model DisableCheckerForProjectResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableCheckerForProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableCheckerForProjectResponseBody(name='body'),
}

/**
 * @summary 关闭项目空间下的检查器
 *
 * @param request DisableCheckerForProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableCheckerForProjectResponse
 */
async function disableCheckerForProjectWithOptions(request: DisableCheckerForProjectRequest, runtime: Util.RuntimeOptions): DisableCheckerForProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkerIdentifier)) {
    body['CheckerIdentifier'] = request.checkerIdentifier;
  }
  if (!Util.isUnset(request.checkerType)) {
    body['CheckerType'] = request.checkerType;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DisableCheckerForProject',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 关闭项目空间下的检查器
 *
 * @param request DisableCheckerForProjectRequest
 * @return DisableCheckerForProjectResponse
 */
async function disableCheckerForProject(request: DisableCheckerForProjectRequest): DisableCheckerForProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableCheckerForProjectWithOptions(request, runtime);
}

model DisableProjectExtensionRequest {
  extensionCode?: string(name='ExtensionCode', description='This parameter is required.'),
  operator?: string(name='Operator', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model DisableProjectExtensionResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableProjectExtensionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableProjectExtensionResponseBody(name='body'),
}

/**
 * @summary 禁用项目空间的扩展程序
 *
 * @param request DisableProjectExtensionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableProjectExtensionResponse
 */
async function disableProjectExtensionWithOptions(request: DisableProjectExtensionRequest, runtime: Util.RuntimeOptions): DisableProjectExtensionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extensionCode)) {
    body['ExtensionCode'] = request.extensionCode;
  }
  if (!Util.isUnset(request.operator)) {
    body['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DisableProjectExtension',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 禁用项目空间的扩展程序
 *
 * @param request DisableProjectExtensionRequest
 * @return DisableProjectExtensionResponse
 */
async function disableProjectExtension(request: DisableProjectExtensionRequest): DisableProjectExtensionResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableProjectExtensionWithOptions(request, runtime);
}

model EnableCheckerForProjectRequest {
  checkerIdentifier?: string(name='CheckerIdentifier', description='This parameter is required.'),
  checkerType?: string(name='CheckerType', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model EnableCheckerForProjectResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableCheckerForProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableCheckerForProjectResponseBody(name='body'),
}

/**
 * @summary 为项目空间开启检查器
 *
 * @param request EnableCheckerForProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableCheckerForProjectResponse
 */
async function enableCheckerForProjectWithOptions(request: EnableCheckerForProjectRequest, runtime: Util.RuntimeOptions): EnableCheckerForProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkerIdentifier)) {
    body['CheckerIdentifier'] = request.checkerIdentifier;
  }
  if (!Util.isUnset(request.checkerType)) {
    body['CheckerType'] = request.checkerType;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EnableCheckerForProject',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 为项目空间开启检查器
 *
 * @param request EnableCheckerForProjectRequest
 * @return EnableCheckerForProjectResponse
 */
async function enableCheckerForProject(request: EnableCheckerForProjectRequest): EnableCheckerForProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableCheckerForProjectWithOptions(request, runtime);
}

model EnableProjectExtensionRequest {
  extensionCode?: string(name='ExtensionCode', description='This parameter is required.'),
  operator?: string(name='Operator', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model EnableProjectExtensionResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableProjectExtensionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableProjectExtensionResponseBody(name='body'),
}

/**
 * @summary 开启项目空间的扩展程序
 *
 * @param request EnableProjectExtensionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableProjectExtensionResponse
 */
async function enableProjectExtensionWithOptions(request: EnableProjectExtensionRequest, runtime: Util.RuntimeOptions): EnableProjectExtensionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extensionCode)) {
    body['ExtensionCode'] = request.extensionCode;
  }
  if (!Util.isUnset(request.operator)) {
    body['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EnableProjectExtension',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 开启项目空间的扩展程序
 *
 * @param request EnableProjectExtensionRequest
 * @return EnableProjectExtensionResponse
 */
async function enableProjectExtension(request: EnableProjectExtensionRequest): EnableProjectExtensionResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableProjectExtensionWithOptions(request, runtime);
}

model EstablishRelationTableToBusinessRequest {
  businessId?: string(name='BusinessId', description='This parameter is required.'),
  folderId?: string(name='FolderId'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  tableGuid?: string(name='TableGuid', description='This parameter is required.'),
}

model EstablishRelationTableToBusinessResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EstablishRelationTableToBusinessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EstablishRelationTableToBusinessResponseBody(name='body'),
}

/**
 * @param request EstablishRelationTableToBusinessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EstablishRelationTableToBusinessResponse
 */
async function establishRelationTableToBusinessWithOptions(request: EstablishRelationTableToBusinessRequest, runtime: Util.RuntimeOptions): EstablishRelationTableToBusinessResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.businessId)) {
    body['BusinessId'] = request.businessId;
  }
  if (!Util.isUnset(request.folderId)) {
    body['FolderId'] = request.folderId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  if (!Util.isUnset(request.tableGuid)) {
    body['TableGuid'] = request.tableGuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EstablishRelationTableToBusiness',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request EstablishRelationTableToBusinessRequest
 * @return EstablishRelationTableToBusinessResponse
 */
async function establishRelationTableToBusiness(request: EstablishRelationTableToBusinessRequest): EstablishRelationTableToBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return establishRelationTableToBusinessWithOptions(request, runtime);
}

model ExecDeploymentStageRequest {
  code?: string(name='Code', description='This parameter is required.'),
  id?: string(name='Id', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model ExecDeploymentStageResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExecDeploymentStageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExecDeploymentStageResponseBody(name='body'),
}

/**
 * @summary 执行Deployment一个阶段
 *
 * @param request ExecDeploymentStageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExecDeploymentStageResponse
 */
async function execDeploymentStageWithOptions(request: ExecDeploymentStageRequest, runtime: Util.RuntimeOptions): ExecDeploymentStageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.code)) {
    body['Code'] = request.code;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ExecDeploymentStage',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 执行Deployment一个阶段
 *
 * @param request ExecDeploymentStageRequest
 * @return ExecDeploymentStageResponse
 */
async function execDeploymentStage(request: ExecDeploymentStageRequest): ExecDeploymentStageResponse {
  var runtime = new Util.RuntimeOptions{};
  return execDeploymentStageWithOptions(request, runtime);
}

model ExecuteAdhocWorkflowInstanceRequest {
  bizDate?: long(name='BizDate'),
  envType?: string(name='EnvType'),
  name?: string(name='Name', description='This parameter is required.'),
  owner?: string(name='Owner', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  tasks?: [ 
    {
      clientUniqueCode?: string(name='ClientUniqueCode', description='This parameter is required.'),
      dataSource?: {
        name?: string(name='Name'),
      }(name='DataSource'),
      dependencies?: [ 
        {
          upstreamOutput?: string(name='UpstreamOutput'),
        }
      ](name='Dependencies'),
      inputs?: {
        variables?: [ 
          {
            name?: string(name='Name'),
            value?: string(name='Value'),
          }
        ](name='Variables'),
      }(name='Inputs'),
      name?: string(name='Name', description='This parameter is required.'),
      outputs?: {
        taskOutputs?: [ 
          {
            output?: string(name='Output'),
          }
        ](name='TaskOutputs'),
        variables?: [ 
          {
            name?: string(name='Name'),
            type?: string(name='Type'),
            value?: string(name='Value'),
          }
        ](name='Variables'),
      }(name='Outputs'),
      owner?: string(name='Owner', description='This parameter is required.'),
      runtimeResource?: {
        cu?: string(name='Cu'),
        image?: string(name='Image'),
        resourceGroupId?: string(name='ResourceGroupId', description='This parameter is required.'),
      }(name='RuntimeResource', description='This parameter is required.'),
      script?: {
        content?: string(name='Content'),
        parameters?: string(name='Parameters'),
      }(name='Script'),
      timeout?: int32(name='Timeout'),
      type?: string(name='Type', description='This parameter is required.'),
    }
  ](name='Tasks', description='This parameter is required.'),
}

model ExecuteAdhocWorkflowInstanceShrinkRequest {
  bizDate?: long(name='BizDate'),
  envType?: string(name='EnvType'),
  name?: string(name='Name', description='This parameter is required.'),
  owner?: string(name='Owner', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  tasksShrink?: string(name='Tasks', description='This parameter is required.'),
}

model ExecuteAdhocWorkflowInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  workflowInstanceId?: long(name='WorkflowInstanceId'),
}

model ExecuteAdhocWorkflowInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExecuteAdhocWorkflowInstanceResponseBody(name='body'),
}

/**
 * @param tmpReq ExecuteAdhocWorkflowInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExecuteAdhocWorkflowInstanceResponse
 */
async function executeAdhocWorkflowInstanceWithOptions(tmpReq: ExecuteAdhocWorkflowInstanceRequest, runtime: Util.RuntimeOptions): ExecuteAdhocWorkflowInstanceResponse {
  Util.validateModel(tmpReq);
  var request = new ExecuteAdhocWorkflowInstanceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tasks)) {
    request.tasksShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tasks, 'Tasks', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizDate)) {
    body['BizDate'] = request.bizDate;
  }
  if (!Util.isUnset(request.envType)) {
    body['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.tasksShrink)) {
    body['Tasks'] = request.tasksShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteAdhocWorkflowInstance',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ExecuteAdhocWorkflowInstanceRequest
 * @return ExecuteAdhocWorkflowInstanceResponse
 */
async function executeAdhocWorkflowInstance(request: ExecuteAdhocWorkflowInstanceRequest): ExecuteAdhocWorkflowInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeAdhocWorkflowInstanceWithOptions(request, runtime);
}

model GetAssetInstanceRequest {
  projectName?: string(name='ProjectName', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  uuid?: string(name='Uuid', description='This parameter is required.'),
}

model GetAssetInstanceResponseBody = {
  data?: {
    categoryPathNameList?: [ string ](name='CategoryPathNameList'),
    categoryUuid?: string(name='CategoryUuid'),
    code?: string(name='Code'),
    creatorId?: string(name='CreatorId'),
    creatorName?: string(name='CreatorName'),
    customInfo?: map[string]any(name='CustomInfo'),
    description?: string(name='Description'),
    gmtCreate?: long(name='GmtCreate'),
    gmtModified?: long(name='GmtModified'),
    gmtOnline?: long(name='GmtOnline'),
    gmtStorage?: long(name='GmtStorage'),
    metricsMap?: map[string]any(name='MetricsMap'),
    modifierId?: string(name='ModifierId'),
    modifierName?: string(name='ModifierName'),
    name?: string(name='Name'),
    objectDefineShowName?: string(name='ObjectDefineShowName'),
    objectDefineUuid?: string(name='ObjectDefineUuid'),
    ownerId?: string(name='OwnerId'),
    ownerName?: string(name='OwnerName'),
    uuid?: string(name='Uuid'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAssetInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAssetInstanceResponseBody(name='body'),
}

/**
 * @param request GetAssetInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAssetInstanceResponse
 */
async function getAssetInstanceWithOptions(request: GetAssetInstanceRequest, runtime: Util.RuntimeOptions): GetAssetInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAssetInstance',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetAssetInstanceRequest
 * @return GetAssetInstanceResponse
 */
async function getAssetInstance(request: GetAssetInstanceRequest): GetAssetInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAssetInstanceWithOptions(request, runtime);
}

model GetAssetInstanceStatisticsRequest {
  categoryUuid?: string(name='CategoryUuid'),
  objectDefineUuidList?: [ string ](name='ObjectDefineUuidList'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  type?: string(name='Type', description='This parameter is required.'),
}

model GetAssetInstanceStatisticsResponseBody = {
  data?: [ 
    {
      cnt?: long(name='Cnt'),
      name?: string(name='Name'),
      parentUuid?: string(name='ParentUuid'),
      uuid?: string(name='Uuid'),
      uuidList?: [ string ](name='UuidList'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAssetInstanceStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAssetInstanceStatisticsResponseBody(name='body'),
}

/**
 * @param request GetAssetInstanceStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAssetInstanceStatisticsResponse
 */
async function getAssetInstanceStatisticsWithOptions(request: GetAssetInstanceStatisticsRequest, runtime: Util.RuntimeOptions): GetAssetInstanceStatisticsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAssetInstanceStatistics',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetAssetInstanceStatisticsRequest
 * @return GetAssetInstanceStatisticsResponse
 */
async function getAssetInstanceStatistics(request: GetAssetInstanceStatisticsRequest): GetAssetInstanceStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAssetInstanceStatisticsWithOptions(request, runtime);
}

model GetBaselineConfigRequest {
  baselineId?: long(name='BaselineId', description='This parameter is required.'),
}

model GetBaselineConfigResponseBody = {
  data?: {
    baselineId?: long(name='BaselineId'),
    baselineName?: string(name='BaselineName'),
    baselineType?: string(name='BaselineType'),
    expHour?: int32(name='ExpHour'),
    expMinu?: int32(name='ExpMinu'),
    hourExpDetail?: string(name='HourExpDetail'),
    hourSlaDetail?: string(name='HourSlaDetail'),
    isDefault?: boolean(name='IsDefault'),
    owner?: string(name='Owner'),
    priority?: int32(name='Priority'),
    projectId?: long(name='ProjectId'),
    slaHour?: int32(name='SlaHour'),
    slaMinu?: int32(name='SlaMinu'),
    useFlag?: boolean(name='UseFlag'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetBaselineConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetBaselineConfigResponseBody(name='body'),
}

/**
 * @param request GetBaselineConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetBaselineConfigResponse
 */
async function getBaselineConfigWithOptions(request: GetBaselineConfigRequest, runtime: Util.RuntimeOptions): GetBaselineConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.baselineId)) {
    body['BaselineId'] = request.baselineId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetBaselineConfig',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetBaselineConfigRequest
 * @return GetBaselineConfigResponse
 */
async function getBaselineConfig(request: GetBaselineConfigRequest): GetBaselineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBaselineConfigWithOptions(request, runtime);
}

model GetBaselineKeyPathRequest {
  baselineId?: long(name='BaselineId', description='This parameter is required.'),
  bizdate?: string(name='Bizdate', description='This parameter is required.'),
  inGroupId?: int32(name='InGroupId', description='This parameter is required.'),
}

model GetBaselineKeyPathResponseBody = {
  data?: [ 
    {
      bizdate?: long(name='Bizdate'),
      inGroupId?: int32(name='InGroupId'),
      instanceId?: long(name='InstanceId'),
      nodeId?: long(name='NodeId'),
      nodeName?: string(name='NodeName'),
      owner?: string(name='Owner'),
      prgType?: int32(name='PrgType'),
      projectId?: long(name='ProjectId'),
      runs?: [ 
        {
          absTime?: long(name='AbsTime'),
          beginCast?: long(name='BeginCast'),
          beginRunningTime?: long(name='BeginRunningTime'),
          beginWaitResTime?: long(name='BeginWaitResTime'),
          beginWaitTimeTime?: long(name='BeginWaitTimeTime'),
          bizdate?: long(name='Bizdate'),
          cycTime?: long(name='CycTime'),
          endCast?: long(name='EndCast'),
          finishTime?: long(name='FinishTime'),
          inGroupId?: int32(name='InGroupId'),
          instanceId?: long(name='InstanceId'),
          nodeId?: long(name='NodeId'),
          nodeName?: string(name='NodeName'),
          owner?: string(name='Owner'),
          projectId?: long(name='ProjectId'),
          status?: string(name='Status'),
        }
      ](name='Runs'),
      topics?: [ 
        {
          addTime?: long(name='AddTime'),
          instanceId?: long(name='InstanceId'),
          topicId?: long(name='TopicId'),
          topicName?: string(name='TopicName'),
        }
      ](name='Topics'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetBaselineKeyPathResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetBaselineKeyPathResponseBody(name='body'),
}

/**
 * @param request GetBaselineKeyPathRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetBaselineKeyPathResponse
 */
async function getBaselineKeyPathWithOptions(request: GetBaselineKeyPathRequest, runtime: Util.RuntimeOptions): GetBaselineKeyPathResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.baselineId)) {
    body['BaselineId'] = request.baselineId;
  }
  if (!Util.isUnset(request.bizdate)) {
    body['Bizdate'] = request.bizdate;
  }
  if (!Util.isUnset(request.inGroupId)) {
    body['InGroupId'] = request.inGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetBaselineKeyPath',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetBaselineKeyPathRequest
 * @return GetBaselineKeyPathResponse
 */
async function getBaselineKeyPath(request: GetBaselineKeyPathRequest): GetBaselineKeyPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBaselineKeyPathWithOptions(request, runtime);
}

model GetBaselineStatusRequest {
  baselineId?: long(name='BaselineId', description='This parameter is required.'),
  bizdate?: string(name='Bizdate', description='This parameter is required.'),
  inGroupId?: int32(name='InGroupId', description='This parameter is required.'),
}

model GetBaselineStatusResponseBody = {
  data?: {
    baselineId?: long(name='BaselineId'),
    baselineName?: string(name='BaselineName'),
    bizdate?: long(name='Bizdate'),
    blockInstance?: {
      endCast?: long(name='EndCast'),
      finishTime?: long(name='FinishTime'),
      instanceId?: long(name='InstanceId'),
      nodeId?: long(name='NodeId'),
      nodeName?: string(name='NodeName'),
      owner?: string(name='Owner'),
      projectId?: long(name='ProjectId'),
      status?: string(name='Status'),
    }(name='BlockInstance'),
    buffer?: float(name='Buffer'),
    endCast?: long(name='EndCast'),
    expTime?: long(name='ExpTime'),
    finishStatus?: string(name='FinishStatus'),
    finishTime?: long(name='FinishTime'),
    inGroupId?: int32(name='InGroupId'),
    lastInstance?: {
      endCast?: long(name='EndCast'),
      finishTime?: long(name='FinishTime'),
      instanceId?: long(name='InstanceId'),
      nodeId?: long(name='NodeId'),
      nodeName?: string(name='NodeName'),
      owner?: string(name='Owner'),
      projectId?: long(name='ProjectId'),
      status?: string(name='Status'),
    }(name='LastInstance'),
    owner?: string(name='Owner'),
    priority?: int32(name='Priority'),
    projectId?: long(name='ProjectId'),
    slaTime?: long(name='SlaTime'),
    status?: string(name='Status'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetBaselineStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetBaselineStatusResponseBody(name='body'),
}

/**
 * @param request GetBaselineStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetBaselineStatusResponse
 */
async function getBaselineStatusWithOptions(request: GetBaselineStatusRequest, runtime: Util.RuntimeOptions): GetBaselineStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.baselineId)) {
    body['BaselineId'] = request.baselineId;
  }
  if (!Util.isUnset(request.bizdate)) {
    body['Bizdate'] = request.bizdate;
  }
  if (!Util.isUnset(request.inGroupId)) {
    body['InGroupId'] = request.inGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetBaselineStatus',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetBaselineStatusRequest
 * @return GetBaselineStatusResponse
 */
async function getBaselineStatus(request: GetBaselineStatusRequest): GetBaselineStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBaselineStatusWithOptions(request, runtime);
}

model GetBusinessRequest {
  businessId?: long(name='BusinessId', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model GetBusinessResponseBody = {
  data?: {
    businessId?: long(name='BusinessId'),
    businessName?: string(name='BusinessName'),
    description?: string(name='Description'),
    owner?: string(name='Owner'),
    projectId?: string(name='ProjectId'),
    useType?: string(name='UseType'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetBusinessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetBusinessResponseBody(name='body'),
}

/**
 * @param request GetBusinessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetBusinessResponse
 */
async function getBusinessWithOptions(request: GetBusinessRequest, runtime: Util.RuntimeOptions): GetBusinessResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.businessId)) {
    body['BusinessId'] = request.businessId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetBusiness',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetBusinessRequest
 * @return GetBusinessResponse
 */
async function getBusiness(request: GetBusinessRequest): GetBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBusinessWithOptions(request, runtime);
}

model GetCreateWorkflowInstancesResultRequest {
  operationId?: string(name='OperationId', description='This parameter is required.'),
}

model GetCreateWorkflowInstancesResultResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    failureMessage?: string(name='FailureMessage'),
    status?: string(name='Status'),
    workflowInstanceIds?: [ long ](name='WorkflowInstanceIds'),
  }(name='Result'),
}

model GetCreateWorkflowInstancesResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCreateWorkflowInstancesResultResponseBody(name='body'),
}

/**
 * @summary 查询异步创建工作流实例的结果
 *
 * @param request GetCreateWorkflowInstancesResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCreateWorkflowInstancesResultResponse
 */
async function getCreateWorkflowInstancesResultWithOptions(request: GetCreateWorkflowInstancesResultRequest, runtime: Util.RuntimeOptions): GetCreateWorkflowInstancesResultResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCreateWorkflowInstancesResult',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询异步创建工作流实例的结果
 *
 * @param request GetCreateWorkflowInstancesResultRequest
 * @return GetCreateWorkflowInstancesResultResponse
 */
async function getCreateWorkflowInstancesResult(request: GetCreateWorkflowInstancesResultRequest): GetCreateWorkflowInstancesResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCreateWorkflowInstancesResultWithOptions(request, runtime);
}

model GetDIJobRequest {
  DIJobId?: long(name='DIJobId', deprecated=true),
  id?: long(name='Id'),
  projectId?: long(name='ProjectId'),
  withDetails?: boolean(name='WithDetails'),
}

model GetDIJobResponseBody = {
  pagingInfo?: {
    DIJobId?: string(name='DIJobId', deprecated=true),
    description?: string(name='Description'),
    destinationDataSourceSettings?: [ 
      {
        dataSourceName?: string(name='DataSourceName'),
      }
    ](name='DestinationDataSourceSettings'),
    destinationDataSourceType?: string(name='DestinationDataSourceType'),
    id?: long(name='Id'),
    jobName?: string(name='JobName'),
    jobSettings?: {
      channelSettings?: string(name='ChannelSettings'),
      columnDataTypeSettings?: [ 
        {
          destinationDataType?: string(name='DestinationDataType'),
          sourceDataType?: string(name='SourceDataType'),
        }
      ](name='ColumnDataTypeSettings'),
      cycleScheduleSettings?: {
        cycleMigrationType?: string(name='CycleMigrationType'),
        scheduleParameters?: string(name='ScheduleParameters'),
      }(name='CycleScheduleSettings'),
      ddlHandlingSettings?: [ 
        {
          action?: string(name='Action'),
          type?: string(name='Type'),
        }
      ](name='DdlHandlingSettings'),
      runtimeSettings?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='RuntimeSettings'),
    }(name='JobSettings'),
    jobStatus?: string(name='JobStatus'),
    migrationType?: string(name='MigrationType'),
    projectId?: long(name='ProjectId'),
    resourceSettings?: {
      offlineResourceSettings?: {
        requestedCu?: double(name='RequestedCu'),
        resourceGroupIdentifier?: string(name='ResourceGroupIdentifier'),
      }(name='OfflineResourceSettings'),
      realtimeResourceSettings?: {
        requestedCu?: double(name='RequestedCu'),
        resourceGroupIdentifier?: string(name='ResourceGroupIdentifier'),
      }(name='RealtimeResourceSettings'),
      scheduleResourceSettings?: {
        requestedCu?: double(name='RequestedCu'),
        resourceGroupIdentifier?: string(name='ResourceGroupIdentifier'),
      }(name='ScheduleResourceSettings'),
    }(name='ResourceSettings'),
    sourceDataSourceSettings?: [ 
      {
        dataSourceName?: string(name='DataSourceName'),
        dataSourceProperties?: {
          encoding?: string(name='Encoding'),
          timezone?: string(name='Timezone'),
        }(name='DataSourceProperties'),
      }
    ](name='SourceDataSourceSettings'),
    sourceDataSourceType?: string(name='SourceDataSourceType'),
    tableMappings?: [ 
      {
        sourceObjectSelectionRules?: [ 
          {
            action?: string(name='Action'),
            expression?: string(name='Expression'),
            expressionType?: string(name='ExpressionType'),
            objectType?: string(name='ObjectType'),
          }
        ](name='SourceObjectSelectionRules'),
        transformationRules?: [ 
          {
            ruleActionType?: string(name='RuleActionType'),
            ruleName?: string(name='RuleName'),
            ruleTargetType?: string(name='RuleTargetType'),
          }
        ](name='TransformationRules'),
      }
    ](name='TableMappings'),
    transformationRules?: [ 
      {
        ruleActionType?: string(name='RuleActionType'),
        ruleExpression?: string(name='RuleExpression'),
        ruleName?: string(name='RuleName'),
        ruleTargetType?: string(name='RuleTargetType'),
      }
    ](name='TransformationRules'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId', description='代表创建时间的资源属性字段'),
}

model GetDIJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDIJobResponseBody(name='body'),
}

/**
 * @summary 查看数据集成任务
 *
 * @param request GetDIJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDIJobResponse
 */
async function getDIJobWithOptions(request: GetDIJobRequest, runtime: Util.RuntimeOptions): GetDIJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDIJob',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查看数据集成任务
 *
 * @param request GetDIJobRequest
 * @return GetDIJobResponse
 */
async function getDIJob(request: GetDIJobRequest): GetDIJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDIJobWithOptions(request, runtime);
}

model GetDIJobLogRequest {
  DIJobId?: long(name='DIJobId', deprecated=true),
  failoverId?: long(name='FailoverId'),
  id?: long(name='Id'),
  instanceId?: long(name='InstanceId'),
  nodeType?: string(name='NodeType'),
  pageNumber?: int32(name='PageNumber'),
}

model GetDIJobLogResponseBody = {
  log?: string(name='Log', description='代表资源一级ID的资源属性字段'),
  requestId?: string(name='RequestId'),
}

model GetDIJobLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDIJobLogResponseBody(name='body'),
}

/**
 * @summary 获取数据集成任务日志
 *
 * @param request GetDIJobLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDIJobLogResponse
 */
async function getDIJobLogWithOptions(request: GetDIJobLogRequest, runtime: Util.RuntimeOptions): GetDIJobLogResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDIJobLog',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取数据集成任务日志
 *
 * @param request GetDIJobLogRequest
 * @return GetDIJobLogResponse
 */
async function getDIJobLog(request: GetDIJobLogRequest): GetDIJobLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDIJobLogWithOptions(request, runtime);
}

model GetDagRequest {
  dagId?: long(name='DagId', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
}

model GetDagResponseBody = {
  data?: {
    bizdate?: long(name='Bizdate'),
    createTime?: long(name='CreateTime'),
    createUser?: string(name='CreateUser'),
    dagId?: long(name='DagId'),
    finishTime?: long(name='FinishTime'),
    gmtdate?: long(name='Gmtdate'),
    modifyTime?: long(name='ModifyTime'),
    name?: string(name='Name'),
    projectId?: long(name='ProjectId'),
    startTime?: long(name='StartTime'),
    status?: string(name='Status'),
    type?: string(name='Type'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetDagResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDagResponseBody(name='body'),
}

/**
 * @param request GetDagRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDagResponse
 */
async function getDagWithOptions(request: GetDagRequest, runtime: Util.RuntimeOptions): GetDagResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dagId)) {
    body['DagId'] = request.dagId;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDag',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetDagRequest
 * @return GetDagResponse
 */
async function getDag(request: GetDagRequest): GetDagResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDagWithOptions(request, runtime);
}

model GetDataQualityEvaluationTaskRequest {
  id?: long(name='Id'),
}

model GetDataQualityEvaluationTaskResponseBody = {
  dataQualityEvaluationTask?: {
    description?: string(name='Description', description='质量监控任务描述'),
    hooks?: [ 
      {
        condition?: string(name='Condition', description='Hook触发条件'),
        type?: string(name='Type', description='Hook类型'),
      }
    ](name='Hooks', description='数据质量校验任务实例生命周期中的回调设置，目前只支持一个阻塞调度任务的Hook'),
    id?: long(name='Id', description='代表资源一级ID的资源属性字段'),
    name?: string(name='Name', description='质量监控任务名称

This parameter is required.'),
    notifications?: {
      condition?: string(name='Condition', description='通知触发条件'),
      notifications?: [ 
        {
          notificationChannels?: [ 
            {
              channels?: [ string ](name='Channels', description='通知方式'),
            }
          ](name='NotificationChannels', description='通知方式'),
          notificationReceivers?: [ 
            {
              extension?: string(name='Extension', description='扩展信息，格式为 json，例如钉钉机器人支持 at 所有人'),
              receiverType?: string(name='ReceiverType', description='告警接收人类型'),
              receiverValues?: [ string ](name='ReceiverValues', description='告警接收人'),
            }
          ](name='NotificationReceivers', description='告警接收人设置'),
        }
      ](name='Notifications', description='具体的消息通知设置'),
    }(name='Notifications', description='数据质量校验任务通知订阅配置'),
    projectId?: long(name='ProjectId', description='项目空间Id'),
    runtimeConf?: string(name='RuntimeConf', description='使用数据源时的一些设置，目前只支持指定EMR的yarn队列、采集EMR表时把SQL引擎指定为SPARK-SQL'),
    target?: {
      databaseType?: string(name='DatabaseType', description='表所属的数据库类型'),
      partitionSpec?: string(name='PartitionSpec'),
      tableGuid?: string(name='TableGuid', description='表在数据地图中的唯一ID'),
      type?: string(name='Type', description='监控对象类型'),
    }(name='Target', description='参看 DataQualityTarget示例	数据质量校验任务的监控对象，参考 DataQualityTarget'),
    trigger?: {
      taskIds?: [ long ](name='TaskIds', description='具体指明哪些调度节点的实例执行成功后可以触发'),
      type?: string(name='Type', description='何种事件可以触发质量校验任务执行'),
    }(name='Trigger', description='数据质量校验任务的触发配置'),
  }(name='DataQualityEvaluationTask'),
  requestId?: string(name='RequestId'),
}

model GetDataQualityEvaluationTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDataQualityEvaluationTaskResponseBody(name='body'),
}

/**
 * @summary 查询数据质量校验任务详情
 *
 * @param request GetDataQualityEvaluationTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDataQualityEvaluationTaskResponse
 */
async function getDataQualityEvaluationTaskWithOptions(request: GetDataQualityEvaluationTaskRequest, runtime: Util.RuntimeOptions): GetDataQualityEvaluationTaskResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDataQualityEvaluationTask',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询数据质量校验任务详情
 *
 * @param request GetDataQualityEvaluationTaskRequest
 * @return GetDataQualityEvaluationTaskResponse
 */
async function getDataQualityEvaluationTask(request: GetDataQualityEvaluationTaskRequest): GetDataQualityEvaluationTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataQualityEvaluationTaskWithOptions(request, runtime);
}

model GetDataQualityEvaluationTaskInstanceRequest {
  id?: long(name='Id'),
}

model GetDataQualityEvaluationTaskInstanceResponseBody = {
  dataQualityEvaluationTaskInstance?: {
    createTime?: long(name='CreateTime'),
    finishTime?: long(name='FinishTime'),
    id?: long(name='Id'),
    parameters?: string(name='Parameters'),
    projectId?: long(name='ProjectId'),
    status?: string(name='Status'),
    task?: {
      description?: string(name='Description'),
      hooks?: [ 
        {
          condition?: string(name='Condition'),
          type?: string(name='Type'),
        }
      ](name='Hooks'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      notifications?: {
        condition?: string(name='Condition'),
        notifications?: [ 
          {
            notificationChannels?: [ 
              {
                channels?: [ string ](name='Channels'),
              }
            ](name='NotificationChannels'),
            notificationReceivers?: [ 
              {
                extension?: string(name='Extension'),
                receiverType?: string(name='ReceiverType'),
                receiverValues?: [ string ](name='ReceiverValues'),
              }
            ](name='NotificationReceivers'),
          }
        ](name='Notifications'),
      }(name='Notifications'),
      projectId?: long(name='ProjectId'),
      runtimeConf?: string(name='RuntimeConf'),
      target?: {
        databaseType?: string(name='DatabaseType'),
        partitionSpec?: string(name='PartitionSpec'),
        tableGuid?: string(name='TableGuid'),
        type?: string(name='Type'),
      }(name='Target'),
      trigger?: {
        taskIds?: [ long ](name='TaskIds'),
        type?: string(name='Type'),
      }(name='Trigger'),
    }(name='Task'),
    triggerContext?: string(name='TriggerContext'),
  }(name='DataQualityEvaluationTaskInstance'),
  requestId?: string(name='RequestId'),
}

model GetDataQualityEvaluationTaskInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDataQualityEvaluationTaskInstanceResponseBody(name='body'),
}

/**
 * @summary 获取数据质量校验任务实例详情
 *
 * @param request GetDataQualityEvaluationTaskInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDataQualityEvaluationTaskInstanceResponse
 */
async function getDataQualityEvaluationTaskInstanceWithOptions(request: GetDataQualityEvaluationTaskInstanceRequest, runtime: Util.RuntimeOptions): GetDataQualityEvaluationTaskInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDataQualityEvaluationTaskInstance',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取数据质量校验任务实例详情
 *
 * @param request GetDataQualityEvaluationTaskInstanceRequest
 * @return GetDataQualityEvaluationTaskInstanceResponse
 */
async function getDataQualityEvaluationTaskInstance(request: GetDataQualityEvaluationTaskInstanceRequest): GetDataQualityEvaluationTaskInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataQualityEvaluationTaskInstanceWithOptions(request, runtime);
}

model GetDataQualityRuleRequest {
  id?: long(name='Id'),
}

model GetDataQualityRuleResponseBody = {
  dataQualityRule?: {
    checkingConfig?: {
      referencedSamplesFilter?: string(name='ReferencedSamplesFilter'),
      thresholds?: {
        critical?: {
          expression?: string(name='Expression'),
          operator?: string(name='Operator'),
          value?: string(name='Value'),
        }(name='Critical'),
        expected?: {
          expression?: string(name='Expression'),
          operator?: string(name='Operator'),
          value?: string(name='Value'),
        }(name='Expected'),
        warned?: {
          expression?: string(name='Expression'),
          operator?: string(name='Operator'),
          value?: string(name='Value'),
        }(name='Warned'),
      }(name='Thresholds'),
      type?: string(name='Type'),
    }(name='CheckingConfig'),
    description?: string(name='Description'),
    enabled?: boolean(name='Enabled'),
    errorHandlers?: [ 
      {
        errorDataFilter?: string(name='ErrorDataFilter'),
        type?: string(name='Type'),
      }
    ](name='ErrorHandlers'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    projectId?: long(name='ProjectId'),
    samplingConfig?: {
      metric?: string(name='Metric'),
      metricParameters?: string(name='MetricParameters'),
      samplingFilter?: string(name='SamplingFilter'),
      settingConfig?: string(name='SettingConfig'),
    }(name='SamplingConfig'),
    severity?: string(name='Severity'),
    target?: {
      databaseType?: string(name='DatabaseType'),
      partitionSpec?: string(name='PartitionSpec'),
      tableGuid?: string(name='TableGuid'),
      type?: string(name='Type'),
    }(name='Target'),
    templateCode?: string(name='TemplateCode'),
    tenantId?: long(name='TenantId'),
  }(name='DataQualityRule'),
  requestId?: string(name='RequestId'),
}

model GetDataQualityRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDataQualityRuleResponseBody(name='body'),
}

/**
 * @summary 查询质量规则详情
 *
 * @param request GetDataQualityRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDataQualityRuleResponse
 */
async function getDataQualityRuleWithOptions(request: GetDataQualityRuleRequest, runtime: Util.RuntimeOptions): GetDataQualityRuleResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDataQualityRule',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询质量规则详情
 *
 * @param request GetDataQualityRuleRequest
 * @return GetDataQualityRuleResponse
 */
async function getDataQualityRule(request: GetDataQualityRuleRequest): GetDataQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataQualityRuleWithOptions(request, runtime);
}

model GetDataQualityRuleTemplateRequest {
  code?: string(name='Code', description='This parameter is required.'),
}

model GetDataQualityRuleTemplateResponseBody = {
  dataQualityRuleTemplate?: {
    checkingConfig?: {
      referencedSamplesFilter?: string(name='ReferencedSamplesFilter'),
      type?: string(name='Type'),
    }(name='CheckingConfig'),
    code?: string(name='Code'),
    directoryPath?: string(name='DirectoryPath'),
    name?: string(name='Name'),
    projectId?: long(name='ProjectId'),
    samplingConfig?: {
      metric?: string(name='Metric'),
      metricParameters?: string(name='MetricParameters'),
      settingConfig?: string(name='SettingConfig'),
    }(name='SamplingConfig'),
    visibleScope?: string(name='VisibleScope'),
  }(name='DataQualityRuleTemplate'),
  requestId?: string(name='RequestId'),
}

model GetDataQualityRuleTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDataQualityRuleTemplateResponseBody(name='body'),
}

/**
 * @summary 获取质量规则模版详情
 *
 * @param request GetDataQualityRuleTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDataQualityRuleTemplateResponse
 */
async function getDataQualityRuleTemplateWithOptions(request: GetDataQualityRuleTemplateRequest, runtime: Util.RuntimeOptions): GetDataQualityRuleTemplateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDataQualityRuleTemplate',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取质量规则模版详情
 *
 * @param request GetDataQualityRuleTemplateRequest
 * @return GetDataQualityRuleTemplateResponse
 */
async function getDataQualityRuleTemplate(request: GetDataQualityRuleTemplateRequest): GetDataQualityRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataQualityRuleTemplateWithOptions(request, runtime);
}

model GetDataServiceApiRequest {
  apiId?: long(name='ApiId', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  tenantId?: long(name='TenantId', description='This parameter is required.'),
}

model GetDataServiceApiResponseBody = {
  data?: {
    apiId?: long(name='ApiId'),
    apiMode?: int32(name='ApiMode'),
    apiName?: string(name='ApiName'),
    apiPath?: string(name='ApiPath'),
    createdTime?: string(name='CreatedTime'),
    creatorId?: string(name='CreatorId'),
    description?: string(name='Description'),
    folderId?: long(name='FolderId'),
    groupId?: string(name='GroupId'),
    modifiedTime?: string(name='ModifiedTime'),
    operatorId?: string(name='OperatorId'),
    projectId?: long(name='ProjectId'),
    protocols?: [ int32 ](name='Protocols'),
    registrationDetails?: {
      failedResultSample?: string(name='FailedResultSample'),
      registrationErrorCodes?: [ 
        {
          errorCode?: string(name='ErrorCode'),
          errorMessage?: string(name='ErrorMessage'),
          errorSolution?: string(name='ErrorSolution'),
        }
      ](name='RegistrationErrorCodes'),
      registrationRequestParameters?: [ 
        {
          columnName?: string(name='ColumnName'),
          defaultValue?: string(name='DefaultValue'),
          exampleValue?: string(name='ExampleValue'),
          isRequiredParameter?: boolean(name='IsRequiredParameter'),
          parameterDataType?: int32(name='ParameterDataType'),
          parameterDescription?: string(name='ParameterDescription'),
          parameterName?: string(name='ParameterName'),
          parameterOperator?: int32(name='ParameterOperator'),
          parameterPosition?: int32(name='ParameterPosition'),
        }
      ](name='RegistrationRequestParameters'),
      serviceContentType?: int32(name='ServiceContentType'),
      serviceHost?: string(name='ServiceHost'),
      servicePath?: string(name='ServicePath'),
      serviceRequestBodyDescription?: string(name='ServiceRequestBodyDescription'),
      successfulResultSample?: string(name='SuccessfulResultSample'),
    }(name='RegistrationDetails'),
    requestMethod?: int32(name='RequestMethod'),
    responseContentType?: int32(name='ResponseContentType'),
    scriptDetails?: {
      isPagedResponse?: boolean(name='IsPagedResponse'),
      script?: string(name='Script'),
      scriptConnection?: {
        connectionId?: long(name='ConnectionId'),
        tableName?: string(name='TableName'),
      }(name='ScriptConnection'),
      scriptRequestParameters?: [ 
        {
          columnName?: string(name='ColumnName'),
          defaultValue?: string(name='DefaultValue'),
          exampleValue?: string(name='ExampleValue'),
          isRequiredParameter?: boolean(name='IsRequiredParameter'),
          parameterDataType?: int32(name='ParameterDataType'),
          parameterDescription?: string(name='ParameterDescription'),
          parameterName?: string(name='ParameterName'),
          parameterOperator?: int32(name='ParameterOperator'),
          parameterPosition?: int32(name='ParameterPosition'),
        }
      ](name='ScriptRequestParameters'),
      scriptResponseParameters?: [ 
        {
          columnName?: string(name='ColumnName'),
          exampleValue?: string(name='ExampleValue'),
          parameterDataType?: int32(name='ParameterDataType'),
          parameterDescription?: string(name='ParameterDescription'),
          parameterName?: string(name='ParameterName'),
        }
      ](name='ScriptResponseParameters'),
    }(name='ScriptDetails'),
    status?: int32(name='Status'),
    tenantId?: long(name='TenantId'),
    timeout?: int32(name='Timeout'),
    visibleRange?: int32(name='VisibleRange'),
    wizardDetails?: {
      isPagedResponse?: boolean(name='IsPagedResponse'),
      wizardConnection?: {
        connectionId?: long(name='ConnectionId'),
        tableName?: string(name='TableName'),
      }(name='WizardConnection'),
      wizardRequestParameters?: [ 
        {
          columnName?: string(name='ColumnName'),
          defaultValue?: string(name='DefaultValue'),
          exampleValue?: string(name='ExampleValue'),
          isRequiredParameter?: boolean(name='IsRequiredParameter'),
          parameterDataType?: int32(name='ParameterDataType'),
          parameterDescription?: string(name='ParameterDescription'),
          parameterName?: string(name='ParameterName'),
          parameterOperator?: int32(name='ParameterOperator'),
          parameterPosition?: int32(name='ParameterPosition'),
        }
      ](name='WizardRequestParameters'),
      wizardResponseParameters?: [ 
        {
          columnName?: string(name='ColumnName'),
          exampleValue?: string(name='ExampleValue'),
          parameterDataType?: int32(name='ParameterDataType'),
          parameterDescription?: string(name='ParameterDescription'),
          parameterName?: string(name='ParameterName'),
        }
      ](name='WizardResponseParameters'),
    }(name='WizardDetails'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataServiceApiResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDataServiceApiResponseBody(name='body'),
}

/**
 * @param request GetDataServiceApiRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDataServiceApiResponse
 */
async function getDataServiceApiWithOptions(request: GetDataServiceApiRequest, runtime: Util.RuntimeOptions): GetDataServiceApiResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apiId)) {
    body['ApiId'] = request.apiId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDataServiceApi',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetDataServiceApiRequest
 * @return GetDataServiceApiResponse
 */
async function getDataServiceApi(request: GetDataServiceApiRequest): GetDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataServiceApiWithOptions(request, runtime);
}

model GetDataSourceInnerRequest {
  envType?: string(name='EnvType', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  operator?: string(name='Operator', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model GetDataSourceInnerResponseBody = {
  dataSource?: {
    connectionProperties?: string(name='ConnectionProperties'),
    connectionPropertiesMode?: string(name='ConnectionPropertiesMode'),
    createTime?: long(name='CreateTime'),
    createUser?: string(name='CreateUser'),
    description?: string(name='Description'),
    id?: long(name='Id'),
    modifyTime?: long(name='ModifyTime'),
    modifyUser?: string(name='ModifyUser'),
    name?: string(name='Name'),
    projectId?: long(name='ProjectId'),
    qualifiedName?: string(name='QualifiedName'),
    type?: string(name='Type'),
  }(name='DataSource'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataSourceInnerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDataSourceInnerResponseBody(name='body'),
}

/**
 * @summary 根据name、envType、projectId、baseId等信息获取数据源配置
 *
 * @param request GetDataSourceInnerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDataSourceInnerResponse
 */
async function getDataSourceInnerWithOptions(request: GetDataSourceInnerRequest, runtime: Util.RuntimeOptions): GetDataSourceInnerResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDataSourceInner',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 根据name、envType、projectId、baseId等信息获取数据源配置
 *
 * @param request GetDataSourceInnerRequest
 * @return GetDataSourceInnerResponse
 */
async function getDataSourceInner(request: GetDataSourceInnerRequest): GetDataSourceInnerResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataSourceInnerWithOptions(request, runtime);
}

model GetDeploymentRequest {
  deploymentId?: long(name='DeploymentId', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model GetDeploymentResponseBody = {
  data?: {
    deployment?: {
      checkingStatus?: int32(name='CheckingStatus'),
      createTime?: long(name='CreateTime'),
      creatorId?: string(name='CreatorId'),
      errorMessage?: string(name='ErrorMessage'),
      executeTime?: long(name='ExecuteTime'),
      fromEnvironment?: int32(name='FromEnvironment'),
      handlerId?: string(name='HandlerId'),
      name?: string(name='Name'),
      status?: int32(name='Status'),
      toEnvironment?: int32(name='ToEnvironment'),
    }(name='Deployment'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetDeploymentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDeploymentResponseBody(name='body'),
}

/**
 * @param request GetDeploymentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDeploymentResponse
 */
async function getDeploymentWithOptions(request: GetDeploymentRequest, runtime: Util.RuntimeOptions): GetDeploymentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deploymentId)) {
    body['DeploymentId'] = request.deploymentId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDeployment',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetDeploymentRequest
 * @return GetDeploymentResponse
 */
async function getDeployment(request: GetDeploymentRequest): GetDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeploymentWithOptions(request, runtime);
}

model GetDeploymentPipelineRequest {
  id?: string(name='Id', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model GetDeploymentPipelineResponseBody = {
  pipeline?: {
    createTime?: long(name='CreateTime', description='发布包创建时间戳'),
    creator?: string(name='Creator', description='创建人'),
    id?: string(name='Id', description='发布流程Id'),
    message?: string(name='Message'),
    modifyTime?: long(name='ModifyTime', description='修改时间'),
    projectId?: long(name='ProjectId'),
    stages?: [ 
      {
        code?: string(name='Code', description='阶段代号'),
        description?: string(name='Description', description='阶段描述'),
        detail?: map[string]any(name='Detail'),
        message?: string(name='Message', description='阶段信息'),
        name?: string(name='Name', description='阶段名称'),
        status?: string(name='Status', description='阶段状态'),
        step?: int32(name='Step', description='步骤'),
        type?: string(name='Type', description='阶段类型'),
      }
    ](name='Stages', description='步骤详情'),
    status?: string(name='Status', description='发布流程状态'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model GetDeploymentPipelineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDeploymentPipelineResponseBody(name='body'),
}

/**
 * @summary 获取发布流程详情
 *
 * @param request GetDeploymentPipelineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDeploymentPipelineResponse
 */
async function getDeploymentPipelineWithOptions(request: GetDeploymentPipelineRequest, runtime: Util.RuntimeOptions): GetDeploymentPipelineResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeploymentPipeline',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取发布流程详情
 *
 * @param request GetDeploymentPipelineRequest
 * @return GetDeploymentPipelineResponse
 */
async function getDeploymentPipeline(request: GetDeploymentPipelineRequest): GetDeploymentPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeploymentPipelineWithOptions(request, runtime);
}

model GetExtensionRequest {
  extensionCode?: string(name='ExtensionCode', description='This parameter is required.'),
}

model GetExtensionResponseBody = {
  extension?: {
    bindEventList?: [ 
      {
        eventCode?: string(name='EventCode'),
        eventName?: string(name='EventName'),
      }
    ](name='BindEventList'),
    detailUrl?: string(name='DetailUrl'),
    eventCategoryList?: [ 
      {
        categoryCode?: string(name='CategoryCode'),
        categoryName?: string(name='CategoryName'),
      }
    ](name='EventCategoryList'),
    extensionCode?: string(name='ExtensionCode'),
    extensionDesc?: string(name='ExtensionDesc'),
    extensionName?: string(name='ExtensionName'),
    helpDocUrl?: string(name='HelpDocUrl'),
    optionSetting?: string(name='OptionSetting'),
    parameterSetting?: string(name='ParameterSetting'),
    projectTesting?: long(name='ProjectTesting'),
    status?: int32(name='Status'),
  }(name='Extension'),
  requestId?: string(name='RequestId'),
}

model GetExtensionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetExtensionResponseBody(name='body'),
}

/**
 * @summary 获取某个扩展程序详情
 *
 * @param request GetExtensionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetExtensionResponse
 */
async function getExtensionWithOptions(request: GetExtensionRequest, runtime: Util.RuntimeOptions): GetExtensionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.extensionCode)) {
    query['ExtensionCode'] = request.extensionCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExtension',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取某个扩展程序详情
 *
 * @param request GetExtensionRequest
 * @return GetExtensionResponse
 */
async function getExtension(request: GetExtensionRequest): GetExtensionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getExtensionWithOptions(request, runtime);
}

model GetFileRequest {
  fileId?: long(name='FileId'),
  nodeId?: long(name='NodeId'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model GetFileResponseBody = {
  data?: {
    file?: {
      autoParsing?: boolean(name='AutoParsing'),
      bizId?: long(name='BizId'),
      commitStatus?: string(name='CommitStatus'),
      connectionName?: string(name='ConnectionName'),
      content?: string(name='Content'),
      createTime?: long(name='CreateTime'),
      createUser?: string(name='CreateUser'),
      currentVersion?: int32(name='CurrentVersion'),
      deletedStatus?: string(name='DeletedStatus'),
      fileDescription?: string(name='FileDescription'),
      fileFolderId?: string(name='FileFolderId'),
      fileId?: string(name='FileId'),
      fileName?: string(name='FileName'),
      fileType?: int32(name='FileType'),
      isMaxCompute?: boolean(name='IsMaxCompute'),
      lastEditTime?: long(name='LastEditTime'),
      lastEditUser?: string(name='LastEditUser'),
      nodeId?: long(name='NodeId'),
      owner?: string(name='Owner'),
      parentId?: long(name='ParentId'),
      useType?: string(name='UseType'),
    }(name='File'),
    nodeConfiguration?: {
      applyScheduleImmediately?: string(name='ApplyScheduleImmediately'),
      autoRerunIntervalMillis?: int32(name='AutoRerunIntervalMillis'),
      autoRerunTimes?: int32(name='AutoRerunTimes'),
      cronExpress?: string(name='CronExpress'),
      cycleType?: string(name='CycleType'),
      dependentNodeIdList?: string(name='DependentNodeIdList'),
      dependentType?: string(name='DependentType'),
      endEffectDate?: long(name='EndEffectDate'),
      ignoreParentSkipRunningProperty?: string(name='IgnoreParentSkipRunningProperty'),
      imageId?: string(name='ImageId'),
      inputList?: [ 
        {
          input?: string(name='Input'),
          parseType?: string(name='ParseType'),
        }
      ](name='InputList'),
      inputParameters?: [ 
        {
          parameterName?: string(name='ParameterName'),
          valueSource?: string(name='ValueSource'),
        }
      ](name='InputParameters'),
      outputList?: [ 
        {
          output?: string(name='Output'),
          refTableName?: string(name='RefTableName'),
        }
      ](name='OutputList'),
      outputParameters?: [ 
        {
          description?: string(name='Description'),
          parameterName?: string(name='ParameterName'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='OutputParameters'),
      paraValue?: string(name='ParaValue'),
      rerunMode?: string(name='RerunMode'),
      resourceGroupId?: long(name='ResourceGroupId'),
      schedulerType?: string(name='SchedulerType'),
      startEffectDate?: long(name='StartEffectDate'),
      startImmediately?: boolean(name='StartImmediately'),
      stop?: boolean(name='Stop'),
      timeout?: int32(name='Timeout'),
    }(name='NodeConfiguration'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFileResponseBody(name='body'),
}

/**
 * @param request GetFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileResponse
 */
async function getFileWithOptions(request: GetFileRequest, runtime: Util.RuntimeOptions): GetFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetFile',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetFileRequest
 * @return GetFileResponse
 */
async function getFile(request: GetFileRequest): GetFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileWithOptions(request, runtime);
}

model GetFileVersionRequest {
  fileId?: long(name='FileId', description='This parameter is required.'),
  fileVersion?: int32(name='FileVersion', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model GetFileVersionResponseBody = {
  data?: {
    changeType?: string(name='ChangeType'),
    comment?: string(name='Comment'),
    commitTime?: long(name='CommitTime'),
    commitUser?: string(name='CommitUser'),
    fileContent?: string(name='FileContent'),
    fileName?: string(name='FileName'),
    filePropertyContent?: string(name='FilePropertyContent'),
    fileVersion?: int32(name='FileVersion'),
    isCurrentProd?: boolean(name='IsCurrentProd'),
    nodeContent?: string(name='NodeContent'),
    nodeId?: long(name='NodeId'),
    status?: string(name='Status'),
    useType?: string(name='UseType'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetFileVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFileVersionResponseBody(name='body'),
}

/**
 * @param request GetFileVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileVersionResponse
 */
async function getFileVersionWithOptions(request: GetFileVersionRequest, runtime: Util.RuntimeOptions): GetFileVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.fileVersion)) {
    body['FileVersion'] = request.fileVersion;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetFileVersion',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetFileVersionRequest
 * @return GetFileVersionResponse
 */
async function getFileVersion(request: GetFileVersionRequest): GetFileVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileVersionWithOptions(request, runtime);
}

model GetFolderRequest {
  folderId?: string(name='FolderId'),
  folderPath?: string(name='FolderPath'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model GetFolderResponseBody = {
  data?: {
    folderId?: string(name='FolderId'),
    folderPath?: string(name='FolderPath'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetFolderResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFolderResponseBody(name='body'),
}

/**
 * @param request GetFolderRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFolderResponse
 */
async function getFolderWithOptions(request: GetFolderRequest, runtime: Util.RuntimeOptions): GetFolderResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.folderId)) {
    body['FolderId'] = request.folderId;
  }
  if (!Util.isUnset(request.folderPath)) {
    body['FolderPath'] = request.folderPath;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetFolder',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetFolderRequest
 * @return GetFolderResponse
 */
async function getFolder(request: GetFolderRequest): GetFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFolderWithOptions(request, runtime);
}

model GetFunctionRequest {
  id?: long(name='Id', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
}

model GetFunctionResponseBody = {
  function?: {
    createTime?: long(name='CreateTime'),
    id?: long(name='Id'),
    modifyTime?: long(name='ModifyTime'),
    name?: string(name='Name'),
    owner?: string(name='Owner'),
    projectId?: long(name='ProjectId'),
    spec?: string(name='Spec'),
  }(name='Function'),
  requestId?: string(name='RequestId'),
}

model GetFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionResponseBody(name='body'),
}

/**
 * @summary 获取函数信息
 *
 * @param request GetFunctionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionResponse
 */
async function getFunctionWithOptions(request: GetFunctionRequest, runtime: Util.RuntimeOptions): GetFunctionResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunction',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取函数信息
 *
 * @param request GetFunctionRequest
 * @return GetFunctionResponse
 */
async function getFunction(request: GetFunctionRequest): GetFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFunctionWithOptions(request, runtime);
}

model GetIDEEventDetailRequest {
  messageId?: string(name='MessageId', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model GetIDEEventDetailResponseBody = {
  eventDetail?: {
    committedFile?: {
      changeType?: string(name='ChangeType'),
      comment?: string(name='Comment'),
      committor?: string(name='Committor'),
      content?: string(name='Content'),
      fileId?: long(name='FileId'),
      fileName?: string(name='FileName'),
      filePropertyContent?: {
        businessId?: long(name='BusinessId'),
        currentVersion?: long(name='CurrentVersion'),
        dataSourceName?: string(name='DataSourceName'),
        folderId?: string(name='FolderId'),
        owner?: string(name='Owner'),
        parentFileId?: long(name='ParentFileId'),
      }(name='FilePropertyContent'),
      fileType?: long(name='FileType'),
      nodeConfiguration?: {
        autoRerunIntervalMillis?: long(name='AutoRerunIntervalMillis'),
        autoRerunTimes?: long(name='AutoRerunTimes'),
        cronExpress?: string(name='CronExpress'),
        cycleType?: string(name='CycleType'),
        dependentNodeIdList?: string(name='DependentNodeIdList'),
        dependentType?: string(name='DependentType'),
        inputList?: [ 
          {
            input?: string(name='Input'),
            parseType?: string(name='ParseType'),
          }
        ](name='InputList'),
        outputList?: [ 
          {
            output?: string(name='Output'),
            refTableName?: string(name='RefTableName'),
          }
        ](name='OutputList'),
        paraValue?: string(name='ParaValue'),
        rerunMode?: string(name='RerunMode'),
        resourceGroupId?: long(name='ResourceGroupId'),
        schedulerType?: string(name='SchedulerType'),
      }(name='NodeConfiguration'),
      nodeId?: long(name='NodeId'),
      useType?: string(name='UseType'),
    }(name='CommittedFile'),
    deletedFile?: {
      businessId?: long(name='BusinessId'),
      content?: string(name='Content'),
      currentVersion?: long(name='CurrentVersion'),
      dataSourceName?: string(name='DataSourceName'),
      fileId?: long(name='FileId'),
      fileName?: string(name='FileName'),
      fileType?: long(name='FileType'),
      folderId?: string(name='FolderId'),
      nodeId?: long(name='NodeId'),
      owner?: string(name='Owner'),
      parentFileId?: long(name='ParentFileId'),
      useType?: string(name='UseType'),
    }(name='DeletedFile'),
    fileExecutionCommand?: {
      content?: string(name='Content'),
      dataSourceName?: string(name='DataSourceName'),
      fileId?: long(name='FileId'),
      fileType?: long(name='FileType'),
    }(name='FileExecutionCommand'),
    tableModel?: {
      columns?: [ 
        {
          columnName?: string(name='ColumnName'),
          columnType?: string(name='ColumnType'),
          comment?: string(name='Comment'),
          isPartitionColumn?: boolean(name='IsPartitionColumn'),
        }
      ](name='Columns'),
      comment?: string(name='Comment'),
      dataSourceName?: string(name='DataSourceName'),
      env?: string(name='Env'),
      lifeCycle?: long(name='LifeCycle'),
      location?: string(name='Location'),
      owner?: string(name='Owner'),
      tableName?: string(name='TableName'),
    }(name='TableModel'),
  }(name='EventDetail'),
  requestId?: string(name='RequestId'),
}

model GetIDEEventDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetIDEEventDetailResponseBody(name='body'),
}

/**
 * @summary 获取扩展点触发时的数据快照
 *
 * @param request GetIDEEventDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetIDEEventDetailResponse
 */
async function getIDEEventDetailWithOptions(request: GetIDEEventDetailRequest, runtime: Util.RuntimeOptions): GetIDEEventDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.messageId)) {
    body['MessageId'] = request.messageId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetIDEEventDetail',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取扩展点触发时的数据快照
 *
 * @param request GetIDEEventDetailRequest
 * @return GetIDEEventDetailResponse
 */
async function getIDEEventDetail(request: GetIDEEventDetailRequest): GetIDEEventDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIDEEventDetailWithOptions(request, runtime);
}

model GetIdeNodeRequest {
  id?: long(name='Id', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
}

model GetIdeNodeResponseBody = {
  node?: {
    createTime?: long(name='CreateTime'),
    id?: long(name='Id'),
    modifyTime?: long(name='ModifyTime'),
    name?: string(name='Name'),
    owner?: string(name='Owner'),
    projectId?: long(name='ProjectId'),
    spec?: string(name='Spec'),
    taskId?: long(name='TaskId'),
  }(name='Node'),
  requestId?: string(name='RequestId'),
}

model GetIdeNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetIdeNodeResponseBody(name='body'),
}

/**
 * @param request GetIdeNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetIdeNodeResponse
 */
async function getIdeNodeWithOptions(request: GetIdeNodeRequest, runtime: Util.RuntimeOptions): GetIdeNodeResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetIdeNode',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetIdeNodeRequest
 * @return GetIdeNodeResponse
 */
async function getIdeNode(request: GetIdeNodeRequest): GetIdeNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIdeNodeWithOptions(request, runtime);
}

model GetInstanceRequest {
  instanceId?: long(name='InstanceId', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
}

model GetInstanceResponseBody = {
  data?: {
    baselineId?: long(name='BaselineId'),
    beginRunningTime?: long(name='BeginRunningTime'),
    beginWaitResTime?: long(name='BeginWaitResTime'),
    beginWaitTimeTime?: long(name='BeginWaitTimeTime'),
    bizdate?: long(name='Bizdate'),
    connection?: string(name='Connection'),
    createTime?: long(name='CreateTime'),
    cycTime?: long(name='CycTime'),
    dagId?: long(name='DagId'),
    dagType?: string(name='DagType'),
    dqcDescription?: string(name='DqcDescription'),
    dqcType?: int32(name='DqcType'),
    errorMessage?: string(name='ErrorMessage'),
    finishTime?: long(name='FinishTime'),
    instanceId?: long(name='InstanceId'),
    modifyTime?: long(name='ModifyTime'),
    nodeId?: long(name='NodeId'),
    nodeName?: string(name='NodeName'),
    paramValues?: string(name='ParamValues'),
    priority?: int32(name='Priority'),
    relatedFlowId?: long(name='RelatedFlowId'),
    repeatInterval?: long(name='RepeatInterval'),
    repeatability?: boolean(name='Repeatability'),
    status?: string(name='Status'),
    taskRerunTime?: int32(name='TaskRerunTime'),
    taskType?: string(name='TaskType'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetInstanceResponseBody(name='body'),
}

/**
 * @param request GetInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceResponse
 */
async function getInstanceWithOptions(request: GetInstanceRequest, runtime: Util.RuntimeOptions): GetInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetInstance',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetInstanceRequest
 * @return GetInstanceResponse
 */
async function getInstance(request: GetInstanceRequest): GetInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceWithOptions(request, runtime);
}

model GetInstanceInfluenceRequest {
  instanceId?: long(name='InstanceId', description='This parameter is required.'),
}

model GetInstanceInfluenceResponseBody = {
  instanceInfluence?: {
    influences?: [ 
      {
        baselineId?: long(name='BaselineId'),
        baselineName?: string(name='BaselineName'),
        bizdate?: long(name='Bizdate'),
        buffer?: long(name='Buffer'),
        inGroupId?: int32(name='InGroupId'),
        owner?: string(name='Owner'),
        priority?: int32(name='Priority'),
        projectId?: long(name='ProjectId'),
        status?: string(name='Status'),
      }
    ](name='Influences'),
    instanceId?: long(name='InstanceId'),
  }(name='InstanceInfluence'),
  requestId?: string(name='RequestId'),
}

model GetInstanceInfluenceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetInstanceInfluenceResponseBody(name='body'),
}

/**
 * @param request GetInstanceInfluenceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceInfluenceResponse
 */
async function getInstanceInfluenceWithOptions(request: GetInstanceInfluenceRequest, runtime: Util.RuntimeOptions): GetInstanceInfluenceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceInfluence',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetInstanceInfluenceRequest
 * @return GetInstanceInfluenceResponse
 */
async function getInstanceInfluence(request: GetInstanceInfluenceRequest): GetInstanceInfluenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceInfluenceWithOptions(request, runtime);
}

model GetInstanceLogRequest {
  instanceId?: long(name='InstanceId', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
}

model GetInstanceLogResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetInstanceLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetInstanceLogResponseBody(name='body'),
}

/**
 * @param request GetInstanceLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceLogResponse
 */
async function getInstanceLogWithOptions(request: GetInstanceLogRequest, runtime: Util.RuntimeOptions): GetInstanceLogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceLog',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetInstanceLogRequest
 * @return GetInstanceLogResponse
 */
async function getInstanceLog(request: GetInstanceLogRequest): GetInstanceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceLogWithOptions(request, runtime);
}

model GetInstanceStatusCountRequest {
  bizDate?: string(name='BizDate', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model GetInstanceStatusCountResponseBody = {
  requestId?: string(name='RequestId'),
  statusCount?: {
    failureCount?: int32(name='FailureCount'),
    notRunCount?: int32(name='NotRunCount'),
    runningCount?: int32(name='RunningCount'),
    successCount?: int32(name='SuccessCount'),
    totalCount?: int32(name='TotalCount'),
    waitResCount?: int32(name='WaitResCount'),
    waitTimeCount?: int32(name='WaitTimeCount'),
  }(name='StatusCount'),
}

model GetInstanceStatusCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetInstanceStatusCountResponseBody(name='body'),
}

/**
 * @param request GetInstanceStatusCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceStatusCountResponse
 */
async function getInstanceStatusCountWithOptions(request: GetInstanceStatusCountRequest, runtime: Util.RuntimeOptions): GetInstanceStatusCountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizDate)) {
    body['BizDate'] = request.bizDate;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceStatusCount',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetInstanceStatusCountRequest
 * @return GetInstanceStatusCountResponse
 */
async function getInstanceStatusCount(request: GetInstanceStatusCountRequest): GetInstanceStatusCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceStatusCountWithOptions(request, runtime);
}

model GetManualDagInstancesRequest {
  dagId?: string(name='DagId', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
}

model GetManualDagInstancesResponseBody = {
  instances?: [ 
    {
      beginRunningTime?: long(name='BeginRunningTime'),
      beginWaitResTime?: long(name='BeginWaitResTime'),
      beginWaitTimeTime?: long(name='BeginWaitTimeTime'),
      bizDate?: long(name='BizDate'),
      createTime?: long(name='CreateTime'),
      cycTime?: long(name='CycTime'),
      dagId?: long(name='DagId'),
      dagType?: string(name='DagType'),
      finishTime?: long(name='FinishTime'),
      instanceId?: long(name='InstanceId'),
      modifyTime?: long(name='ModifyTime'),
      nodeId?: long(name='NodeId'),
      nodeName?: string(name='NodeName'),
      paramValues?: string(name='ParamValues'),
      status?: string(name='Status'),
    }
  ](name='Instances'),
  requestId?: string(name='RequestId'),
}

model GetManualDagInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetManualDagInstancesResponseBody(name='body'),
}

/**
 * @param request GetManualDagInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetManualDagInstancesResponse
 */
async function getManualDagInstancesWithOptions(request: GetManualDagInstancesRequest, runtime: Util.RuntimeOptions): GetManualDagInstancesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dagId)) {
    body['DagId'] = request.dagId;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetManualDagInstances',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetManualDagInstancesRequest
 * @return GetManualDagInstancesResponse
 */
async function getManualDagInstances(request: GetManualDagInstancesRequest): GetManualDagInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getManualDagInstancesWithOptions(request, runtime);
}

model GetMetaCategoryRequest {
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  parentCategoryId?: long(name='ParentCategoryId'),
}

model GetMetaCategoryResponseBody = {
  data?: {
    dataEntityList?: [ 
      {
        categoryId?: long(name='CategoryId'),
        comment?: string(name='Comment'),
        createTime?: long(name='CreateTime'),
        depth?: int32(name='Depth'),
        lastOperatorId?: string(name='LastOperatorId'),
        modifiedTime?: long(name='ModifiedTime'),
        name?: string(name='Name'),
        ownerId?: string(name='OwnerId'),
        parentCategoryId?: long(name='ParentCategoryId'),
      }
    ](name='DataEntityList'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetMetaCategoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetaCategoryResponseBody(name='body'),
}

/**
 * @param request GetMetaCategoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaCategoryResponse
 */
async function getMetaCategoryWithOptions(request: GetMetaCategoryRequest, runtime: Util.RuntimeOptions): GetMetaCategoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parentCategoryId)) {
    query['ParentCategoryId'] = request.parentCategoryId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaCategory',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMetaCategoryRequest
 * @return GetMetaCategoryResponse
 */
async function getMetaCategory(request: GetMetaCategoryRequest): GetMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaCategoryWithOptions(request, runtime);
}

model GetMetaCollectionDetailRequest {
  qualifiedName?: string(name='QualifiedName', description='This parameter is required.'),
}

model GetMetaCollectionDetailResponseBody = {
  collection?: Collection(name='Collection'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaCollectionDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetaCollectionDetailResponseBody(name='body'),
}

/**
 * @summary 获取collection详情
 *
 * @param request GetMetaCollectionDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaCollectionDetailResponse
 */
async function getMetaCollectionDetailWithOptions(request: GetMetaCollectionDetailRequest, runtime: Util.RuntimeOptions): GetMetaCollectionDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.qualifiedName)) {
    query['QualifiedName'] = request.qualifiedName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaCollectionDetail',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取collection详情
 *
 * @param request GetMetaCollectionDetailRequest
 * @return GetMetaCollectionDetailResponse
 */
async function getMetaCollectionDetail(request: GetMetaCollectionDetailRequest): GetMetaCollectionDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaCollectionDetailWithOptions(request, runtime);
}

model GetMetaColumnLineageRequest {
  clusterId?: string(name='ClusterId'),
  columnGuid?: string(name='ColumnGuid'),
  columnName?: string(name='ColumnName'),
  dataSourceType?: string(name='DataSourceType'),
  databaseName?: string(name='DatabaseName'),
  direction?: string(name='Direction', description='This parameter is required.'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tableName?: string(name='TableName'),
}

model GetMetaColumnLineageResponseBody = {
  data?: {
    dataEntityList?: [ 
      {
        clusterId?: string(name='ClusterId'),
        columnGuid?: string(name='ColumnGuid'),
        columnName?: string(name='ColumnName'),
        databaseName?: string(name='DatabaseName'),
        tableName?: string(name='TableName'),
      }
    ](name='DataEntityList'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetMetaColumnLineageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetaColumnLineageResponseBody(name='body'),
}

/**
 * @param request GetMetaColumnLineageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaColumnLineageResponse
 */
async function getMetaColumnLineageWithOptions(request: GetMetaColumnLineageRequest, runtime: Util.RuntimeOptions): GetMetaColumnLineageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.columnGuid)) {
    query['ColumnGuid'] = request.columnGuid;
  }
  if (!Util.isUnset(request.columnName)) {
    query['ColumnName'] = request.columnName;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    query['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaColumnLineage',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMetaColumnLineageRequest
 * @return GetMetaColumnLineageResponse
 */
async function getMetaColumnLineage(request: GetMetaColumnLineageRequest): GetMetaColumnLineageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaColumnLineageWithOptions(request, runtime);
}

model GetMetaDBInfoRequest {
  appGuid?: string(name='AppGuid'),
  clusterId?: string(name='ClusterId'),
  dataSourceType?: string(name='DataSourceType'),
  databaseName?: string(name='DatabaseName'),
}

model GetMetaDBInfoResponseBody = {
  data?: {
    appGuid?: string(name='AppGuid'),
    clusterBizId?: string(name='ClusterBizId'),
    comment?: string(name='Comment'),
    createTime?: long(name='CreateTime'),
    endpoint?: string(name='Endpoint'),
    envType?: int32(name='EnvType'),
    location?: string(name='Location'),
    modifyTime?: long(name='ModifyTime'),
    name?: string(name='Name'),
    ownerId?: string(name='OwnerId'),
    ownerName?: string(name='OwnerName'),
    ownerUserId?: string(name='OwnerUserId'),
    projectId?: long(name='ProjectId'),
    projectName?: string(name='ProjectName'),
    projectNameCn?: string(name='ProjectNameCn'),
    tenantId?: long(name='TenantId'),
    type?: string(name='Type'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetMetaDBInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetaDBInfoResponseBody(name='body'),
}

/**
 * @param request GetMetaDBInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaDBInfoResponse
 */
async function getMetaDBInfoWithOptions(request: GetMetaDBInfoRequest, runtime: Util.RuntimeOptions): GetMetaDBInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appGuid)) {
    query['AppGuid'] = request.appGuid;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    query['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaDBInfo',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMetaDBInfoRequest
 * @return GetMetaDBInfoResponse
 */
async function getMetaDBInfo(request: GetMetaDBInfoRequest): GetMetaDBInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaDBInfoWithOptions(request, runtime);
}

model GetMetaDBTableListRequest {
  appGuid?: string(name='AppGuid'),
  clusterId?: string(name='ClusterId'),
  dataSourceType?: string(name='DataSourceType'),
  databaseName?: string(name='DatabaseName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model GetMetaDBTableListResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    tableEntityList?: [ 
      {
        databaseName?: string(name='DatabaseName'),
        tableGuid?: string(name='TableGuid'),
        tableName?: string(name='TableName'),
      }
    ](name='TableEntityList'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetMetaDBTableListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetaDBTableListResponseBody(name='body'),
}

/**
 * @param request GetMetaDBTableListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaDBTableListResponse
 */
async function getMetaDBTableListWithOptions(request: GetMetaDBTableListRequest, runtime: Util.RuntimeOptions): GetMetaDBTableListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appGuid)) {
    query['AppGuid'] = request.appGuid;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    query['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaDBTableList',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMetaDBTableListRequest
 * @return GetMetaDBTableListResponse
 */
async function getMetaDBTableList(request: GetMetaDBTableListRequest): GetMetaDBTableListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaDBTableListWithOptions(request, runtime);
}

model GetMetaTableBasicInfoRequest {
  clusterId?: string(name='ClusterId'),
  dataSourceType?: string(name='DataSourceType'),
  databaseName?: string(name='DatabaseName'),
  extension?: boolean(name='Extension'),
  tableGuid?: string(name='TableGuid'),
  tableName?: string(name='TableName'),
}

model GetMetaTableBasicInfoResponseBody = {
  data?: {
    caption?: string(name='Caption'),
    clusterId?: string(name='ClusterId'),
    comment?: string(name='Comment'),
    createTime?: long(name='CreateTime'),
    dataSize?: long(name='DataSize'),
    databaseName?: string(name='DatabaseName'),
    envType?: int32(name='EnvType'),
    favoriteCount?: long(name='FavoriteCount'),
    isPartitionTable?: boolean(name='IsPartitionTable'),
    isView?: boolean(name='IsView'),
    isVisible?: int32(name='IsVisible'),
    lastAccessTime?: long(name='LastAccessTime'),
    lastDdlTime?: long(name='LastDdlTime'),
    lastModifyTime?: long(name='LastModifyTime'),
    lifeCycle?: int32(name='LifeCycle'),
    location?: string(name='Location'),
    ownerId?: string(name='OwnerId'),
    partitionKeys?: string(name='PartitionKeys'),
    projectId?: long(name='ProjectId'),
    projectName?: string(name='ProjectName'),
    readCount?: long(name='ReadCount'),
    tableGuid?: string(name='TableGuid'),
    tableName?: string(name='TableName'),
    tenantId?: long(name='TenantId'),
    viewCount?: long(name='ViewCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetMetaTableBasicInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetaTableBasicInfoResponseBody(name='body'),
}

/**
 * @param request GetMetaTableBasicInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaTableBasicInfoResponse
 */
async function getMetaTableBasicInfoWithOptions(request: GetMetaTableBasicInfoRequest, runtime: Util.RuntimeOptions): GetMetaTableBasicInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    query['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.extension)) {
    query['Extension'] = request.extension;
  }
  if (!Util.isUnset(request.tableGuid)) {
    query['TableGuid'] = request.tableGuid;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableBasicInfo',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMetaTableBasicInfoRequest
 * @return GetMetaTableBasicInfoResponse
 */
async function getMetaTableBasicInfo(request: GetMetaTableBasicInfoRequest): GetMetaTableBasicInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableBasicInfoWithOptions(request, runtime);
}

model GetMetaTableChangeLogRequest {
  changeType?: string(name='ChangeType'),
  endDate?: string(name='EndDate'),
  objectType?: string(name='ObjectType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startDate?: string(name='StartDate'),
  tableGuid?: string(name='TableGuid', description='This parameter is required.'),
}

model GetMetaTableChangeLogResponseBody = {
  data?: {
    dataEntityList?: [ 
      {
        changeContent?: string(name='ChangeContent'),
        changeType?: string(name='ChangeType'),
        createTime?: long(name='CreateTime'),
        modifiedTime?: long(name='ModifiedTime'),
        objectType?: string(name='ObjectType'),
        operator?: string(name='Operator'),
      }
    ](name='DataEntityList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetMetaTableChangeLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetaTableChangeLogResponseBody(name='body'),
}

/**
 * @param request GetMetaTableChangeLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaTableChangeLogResponse
 */
async function getMetaTableChangeLogWithOptions(request: GetMetaTableChangeLogRequest, runtime: Util.RuntimeOptions): GetMetaTableChangeLogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.changeType)) {
    body['ChangeType'] = request.changeType;
  }
  if (!Util.isUnset(request.endDate)) {
    body['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.objectType)) {
    body['ObjectType'] = request.objectType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    body['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.tableGuid)) {
    body['TableGuid'] = request.tableGuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableChangeLog',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMetaTableChangeLogRequest
 * @return GetMetaTableChangeLogResponse
 */
async function getMetaTableChangeLog(request: GetMetaTableChangeLogRequest): GetMetaTableChangeLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableChangeLogWithOptions(request, runtime);
}

model GetMetaTableColumnRequest {
  clusterId?: string(name='ClusterId'),
  dataSourceType?: string(name='DataSourceType'),
  databaseName?: string(name='DatabaseName'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tableGuid?: string(name='TableGuid'),
  tableName?: string(name='TableName'),
}

model GetMetaTableColumnResponseBody = {
  data?: {
    columnList?: [ 
      {
        caption?: string(name='Caption'),
        columnGuid?: string(name='ColumnGuid'),
        columnName?: string(name='ColumnName'),
        columnType?: string(name='ColumnType'),
        comment?: string(name='Comment'),
        displayName?: string(name='DisplayName'),
        isForeignKey?: boolean(name='IsForeignKey'),
        isPartitionColumn?: boolean(name='IsPartitionColumn'),
        isPrimaryKey?: boolean(name='IsPrimaryKey'),
        position?: int32(name='Position'),
        relationCount?: string(name='RelationCount'),
      }
    ](name='ColumnList'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetMetaTableColumnResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetaTableColumnResponseBody(name='body'),
}

/**
 * @param request GetMetaTableColumnRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaTableColumnResponse
 */
async function getMetaTableColumnWithOptions(request: GetMetaTableColumnRequest, runtime: Util.RuntimeOptions): GetMetaTableColumnResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    query['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tableGuid)) {
    query['TableGuid'] = request.tableGuid;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableColumn',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMetaTableColumnRequest
 * @return GetMetaTableColumnResponse
 */
async function getMetaTableColumn(request: GetMetaTableColumnRequest): GetMetaTableColumnResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableColumnWithOptions(request, runtime);
}

model GetMetaTableIntroWikiRequest {
  tableGuid?: string(name='TableGuid', description='This parameter is required.'),
  wikiVersion?: long(name='WikiVersion'),
}

model GetMetaTableIntroWikiResponseBody = {
  data?: {
    content?: string(name='Content'),
    createTime?: long(name='CreateTime'),
    creator?: string(name='Creator'),
    creatorName?: string(name='CreatorName'),
    modifiedTime?: long(name='ModifiedTime'),
    version?: long(name='Version'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetMetaTableIntroWikiResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetaTableIntroWikiResponseBody(name='body'),
}

/**
 * @param request GetMetaTableIntroWikiRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaTableIntroWikiResponse
 */
async function getMetaTableIntroWikiWithOptions(request: GetMetaTableIntroWikiRequest, runtime: Util.RuntimeOptions): GetMetaTableIntroWikiResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tableGuid)) {
    query['TableGuid'] = request.tableGuid;
  }
  if (!Util.isUnset(request.wikiVersion)) {
    query['WikiVersion'] = request.wikiVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableIntroWiki',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMetaTableIntroWikiRequest
 * @return GetMetaTableIntroWikiResponse
 */
async function getMetaTableIntroWiki(request: GetMetaTableIntroWikiRequest): GetMetaTableIntroWikiResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableIntroWikiWithOptions(request, runtime);
}

model GetMetaTableLineageRequest {
  clusterId?: string(name='ClusterId'),
  dataSourceType?: string(name='DataSourceType'),
  databaseName?: string(name='DatabaseName'),
  direction?: string(name='Direction', description='This parameter is required.'),
  nextPrimaryKey?: string(name='NextPrimaryKey'),
  pageSize?: int32(name='PageSize'),
  tableGuid?: string(name='TableGuid'),
  tableName?: string(name='TableName'),
}

model GetMetaTableLineageResponseBody = {
  data?: {
    dataEntityList?: [ 
      {
        tableGuid?: string(name='TableGuid'),
        tableName?: string(name='TableName'),
      }
    ](name='DataEntityList'),
    hasNext?: boolean(name='HasNext'),
    nextPrimaryKey?: string(name='NextPrimaryKey'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetMetaTableLineageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetaTableLineageResponseBody(name='body'),
}

/**
 * @param request GetMetaTableLineageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaTableLineageResponse
 */
async function getMetaTableLineageWithOptions(request: GetMetaTableLineageRequest, runtime: Util.RuntimeOptions): GetMetaTableLineageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    query['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.nextPrimaryKey)) {
    query['NextPrimaryKey'] = request.nextPrimaryKey;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tableGuid)) {
    query['TableGuid'] = request.tableGuid;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableLineage',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMetaTableLineageRequest
 * @return GetMetaTableLineageResponse
 */
async function getMetaTableLineage(request: GetMetaTableLineageRequest): GetMetaTableLineageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableLineageWithOptions(request, runtime);
}

model GetMetaTableListByCategoryRequest {
  categoryId?: long(name='CategoryId', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model GetMetaTableListByCategoryResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    tableGuidList?: [ string ](name='TableGuidList'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetMetaTableListByCategoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetaTableListByCategoryResponseBody(name='body'),
}

/**
 * @param request GetMetaTableListByCategoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaTableListByCategoryResponse
 */
async function getMetaTableListByCategoryWithOptions(request: GetMetaTableListByCategoryRequest, runtime: Util.RuntimeOptions): GetMetaTableListByCategoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.categoryId)) {
    query['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableListByCategory',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMetaTableListByCategoryRequest
 * @return GetMetaTableListByCategoryResponse
 */
async function getMetaTableListByCategory(request: GetMetaTableListByCategoryRequest): GetMetaTableListByCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableListByCategoryWithOptions(request, runtime);
}

model GetMetaTableOutputRequest {
  endDate?: string(name='EndDate', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startDate?: string(name='StartDate', description='This parameter is required.'),
  tableGuid?: string(name='TableGuid', description='This parameter is required.'),
  taskId?: string(name='TaskId'),
}

model GetMetaTableOutputResponseBody = {
  data?: {
    dataEntityList?: [ 
      {
        endTime?: string(name='EndTime'),
        projectId?: long(name='ProjectId'),
        startTime?: string(name='StartTime'),
        tableGuid?: string(name='TableGuid'),
        taskId?: string(name='TaskId'),
        taskInstanceId?: long(name='TaskInstanceId'),
        waitTime?: string(name='WaitTime'),
      }
    ](name='DataEntityList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetMetaTableOutputResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetaTableOutputResponseBody(name='body'),
}

/**
 * @param request GetMetaTableOutputRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaTableOutputResponse
 */
async function getMetaTableOutputWithOptions(request: GetMetaTableOutputRequest, runtime: Util.RuntimeOptions): GetMetaTableOutputResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.tableGuid)) {
    query['TableGuid'] = request.tableGuid;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableOutput',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMetaTableOutputRequest
 * @return GetMetaTableOutputResponse
 */
async function getMetaTableOutput(request: GetMetaTableOutputRequest): GetMetaTableOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableOutputWithOptions(request, runtime);
}

model GetMetaTablePartitionRequest {
  clusterId?: string(name='ClusterId'),
  dataSourceType?: string(name='DataSourceType'),
  databaseName?: string(name='DatabaseName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  tableGuid?: string(name='TableGuid'),
  tableName?: string(name='TableName'),
}

model GetMetaTablePartitionResponseBody = {
  data?: {
    dataEntityList?: [ 
      {
        comment?: string(name='Comment'),
        createTime?: long(name='CreateTime'),
        dataSize?: long(name='DataSize'),
        modifiedTime?: long(name='ModifiedTime'),
        partitionGuid?: string(name='PartitionGuid'),
        partitionLocation?: string(name='PartitionLocation'),
        partitionName?: string(name='PartitionName'),
        partitionPath?: string(name='PartitionPath'),
        partitionType?: string(name='PartitionType'),
        recordCount?: long(name='RecordCount'),
        tableGuid?: string(name='TableGuid'),
      }
    ](name='DataEntityList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetMetaTablePartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetaTablePartitionResponseBody(name='body'),
}

/**
 * @param request GetMetaTablePartitionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaTablePartitionResponse
 */
async function getMetaTablePartitionWithOptions(request: GetMetaTablePartitionRequest, runtime: Util.RuntimeOptions): GetMetaTablePartitionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    query['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tableGuid)) {
    query['TableGuid'] = request.tableGuid;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTablePartition',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMetaTablePartitionRequest
 * @return GetMetaTablePartitionResponse
 */
async function getMetaTablePartition(request: GetMetaTablePartitionRequest): GetMetaTablePartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTablePartitionWithOptions(request, runtime);
}

model GetMetaTableProducingTasksRequest {
  clusterId?: string(name='ClusterId'),
  dataSourceType?: string(name='DataSourceType'),
  dbName?: string(name='DbName'),
  schemaName?: string(name='SchemaName'),
  tableGuid?: string(name='TableGuid'),
  tableName?: string(name='TableName'),
}

model GetMetaTableProducingTasksResponseBody = {
  data?: [ 
    {
      taskId?: string(name='taskId'),
      taskName?: string(name='taskName'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaTableProducingTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetaTableProducingTasksResponseBody(name='body'),
}

/**
 * @summary 获取Table的产出任务列表
 *
 * @param request GetMetaTableProducingTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaTableProducingTasksResponse
 */
async function getMetaTableProducingTasksWithOptions(request: GetMetaTableProducingTasksRequest, runtime: Util.RuntimeOptions): GetMetaTableProducingTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    query['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.dbName)) {
    query['DbName'] = request.dbName;
  }
  if (!Util.isUnset(request.schemaName)) {
    query['SchemaName'] = request.schemaName;
  }
  if (!Util.isUnset(request.tableGuid)) {
    query['TableGuid'] = request.tableGuid;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableProducingTasks',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取Table的产出任务列表
 *
 * @param request GetMetaTableProducingTasksRequest
 * @return GetMetaTableProducingTasksResponse
 */
async function getMetaTableProducingTasks(request: GetMetaTableProducingTasksRequest): GetMetaTableProducingTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableProducingTasksWithOptions(request, runtime);
}

model GetNodeRequest {
  nodeId?: long(name='NodeId', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
}

model GetNodeResponseBody = {
  data?: {
    baselineId?: long(name='BaselineId'),
    connection?: string(name='Connection'),
    cronExpress?: string(name='CronExpress'),
    description?: string(name='Description'),
    dqcDescription?: string(name='DqcDescription'),
    dqcType?: int32(name='DqcType'),
    nodeId?: long(name='NodeId'),
    nodeName?: string(name='NodeName'),
    ownerId?: string(name='OwnerId'),
    paramValues?: string(name='ParamValues'),
    priority?: int32(name='Priority'),
    programType?: string(name='ProgramType'),
    projectId?: long(name='ProjectId'),
    quota?: string(name='Quota'),
    relatedFlowId?: long(name='RelatedFlowId'),
    repeatInterval?: long(name='RepeatInterval'),
    repeatability?: string(name='Repeatability'),
    resGroupName?: string(name='ResGroupName'),
    schedulerType?: string(name='SchedulerType'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetNodeResponseBody(name='body'),
}

/**
 * @param request GetNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetNodeResponse
 */
async function getNodeWithOptions(request: GetNodeRequest, runtime: Util.RuntimeOptions): GetNodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetNode',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetNodeRequest
 * @return GetNodeResponse
 */
async function getNode(request: GetNodeRequest): GetNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeWithOptions(request, runtime);
}

model GetNodeChildrenRequest {
  nodeId?: long(name='NodeId', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
}

model GetNodeChildrenResponseBody = {
  data?: {
    nodes?: [ 
      {
        baselineId?: long(name='BaselineId'),
        cronExpress?: string(name='CronExpress'),
        nodeId?: long(name='NodeId'),
        nodeName?: string(name='NodeName'),
        ownerId?: string(name='OwnerId'),
        priority?: int32(name='Priority'),
        programType?: string(name='ProgramType'),
        projectId?: long(name='ProjectId'),
        repeatability?: boolean(name='Repeatability'),
        schedulerType?: string(name='SchedulerType'),
      }
    ](name='Nodes'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetNodeChildrenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetNodeChildrenResponseBody(name='body'),
}

/**
 * @param request GetNodeChildrenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetNodeChildrenResponse
 */
async function getNodeChildrenWithOptions(request: GetNodeChildrenRequest, runtime: Util.RuntimeOptions): GetNodeChildrenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeChildren',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetNodeChildrenRequest
 * @return GetNodeChildrenResponse
 */
async function getNodeChildren(request: GetNodeChildrenRequest): GetNodeChildrenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeChildrenWithOptions(request, runtime);
}

model GetNodeCodeRequest {
  nodeId?: long(name='NodeId', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
}

model GetNodeCodeResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetNodeCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetNodeCodeResponseBody(name='body'),
}

/**
 * @param request GetNodeCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetNodeCodeResponse
 */
async function getNodeCodeWithOptions(request: GetNodeCodeRequest, runtime: Util.RuntimeOptions): GetNodeCodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeCode',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetNodeCodeRequest
 * @return GetNodeCodeResponse
 */
async function getNodeCode(request: GetNodeCodeRequest): GetNodeCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeCodeWithOptions(request, runtime);
}

model GetNodeCodeReviewRequest {
  fileId?: long(name='FileId'),
  fileVersion?: int32(name='FileVersion', description='This parameter is required.'),
  nodeId?: long(name='NodeId'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model GetNodeCodeReviewResponseBody = {
  data?: {
    executor?: string(name='Executor'),
    fileId?: string(name='FileId'),
    fileName?: string(name='FileName'),
    fileType?: long(name='FileType'),
    id?: long(name='Id'),
    lastReviewTime?: string(name='LastReviewTime'),
    projectId?: long(name='ProjectId'),
    requestDesc?: string(name='RequestDesc'),
    reviewedObjectType?: string(name='ReviewedObjectType'),
    status?: string(name='Status'),
    submitTime?: string(name='SubmitTime'),
    submitter?: string(name='Submitter'),
    version?: long(name='Version'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetNodeCodeReviewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetNodeCodeReviewResponseBody(name='body'),
}

/**
 * @summary 获取节点对应版本评审单详情
 *
 * @param request GetNodeCodeReviewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetNodeCodeReviewResponse
 */
async function getNodeCodeReviewWithOptions(request: GetNodeCodeReviewRequest, runtime: Util.RuntimeOptions): GetNodeCodeReviewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.fileVersion)) {
    body['FileVersion'] = request.fileVersion;
  }
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeCodeReview',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取节点对应版本评审单详情
 *
 * @param request GetNodeCodeReviewRequest
 * @return GetNodeCodeReviewResponse
 */
async function getNodeCodeReview(request: GetNodeCodeReviewRequest): GetNodeCodeReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeCodeReviewWithOptions(request, runtime);
}

model GetNodeOnBaselineRequest {
  baselineId?: long(name='BaselineId', description='This parameter is required.'),
}

model GetNodeOnBaselineResponseBody = {
  data?: [ 
    {
      nodeId?: long(name='NodeId'),
      nodeName?: string(name='NodeName'),
      owner?: string(name='Owner'),
      projectId?: long(name='ProjectId'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetNodeOnBaselineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetNodeOnBaselineResponseBody(name='body'),
}

/**
 * @param request GetNodeOnBaselineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetNodeOnBaselineResponse
 */
async function getNodeOnBaselineWithOptions(request: GetNodeOnBaselineRequest, runtime: Util.RuntimeOptions): GetNodeOnBaselineResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.baselineId)) {
    body['BaselineId'] = request.baselineId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeOnBaseline',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetNodeOnBaselineRequest
 * @return GetNodeOnBaselineResponse
 */
async function getNodeOnBaseline(request: GetNodeOnBaselineRequest): GetNodeOnBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeOnBaselineWithOptions(request, runtime);
}

model GetNodeParentsRequest {
  nodeId?: long(name='NodeId', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
}

model GetNodeParentsResponseBody = {
  data?: {
    nodes?: [ 
      {
        baselineId?: long(name='BaselineId'),
        cronExpress?: string(name='CronExpress'),
        nodeId?: long(name='NodeId'),
        nodeName?: string(name='NodeName'),
        ownerId?: string(name='OwnerId'),
        priority?: int32(name='Priority'),
        programType?: string(name='ProgramType'),
        projectId?: long(name='ProjectId'),
        repeatability?: boolean(name='Repeatability'),
        schedulerType?: string(name='SchedulerType'),
      }
    ](name='Nodes'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetNodeParentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetNodeParentsResponseBody(name='body'),
}

/**
 * @param request GetNodeParentsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetNodeParentsResponse
 */
async function getNodeParentsWithOptions(request: GetNodeParentsRequest, runtime: Util.RuntimeOptions): GetNodeParentsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeParents',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetNodeParentsRequest
 * @return GetNodeParentsResponse
 */
async function getNodeParents(request: GetNodeParentsRequest): GetNodeParentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeParentsWithOptions(request, runtime);
}

model GetOptionValueForProjectRequest {
  extensionCode?: string(name='ExtensionCode', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model GetOptionValueForProjectResponseBody = {
  optionValue?: string(name='OptionValue'),
  requestId?: string(name='RequestId'),
}

model GetOptionValueForProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetOptionValueForProjectResponseBody(name='body'),
}

/**
 * @summary 获取扩展程序选项配置在项目空间下的配置
 *
 * @param request GetOptionValueForProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOptionValueForProjectResponse
 */
async function getOptionValueForProjectWithOptions(request: GetOptionValueForProjectRequest, runtime: Util.RuntimeOptions): GetOptionValueForProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extensionCode)) {
    body['ExtensionCode'] = request.extensionCode;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetOptionValueForProject',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取扩展程序选项配置在项目空间下的配置
 *
 * @param request GetOptionValueForProjectRequest
 * @return GetOptionValueForProjectResponse
 */
async function getOptionValueForProject(request: GetOptionValueForProjectRequest): GetOptionValueForProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOptionValueForProjectWithOptions(request, runtime);
}

model GetProjectRequest {
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model GetProjectResponseBody = {
  data?: {
    appkey?: string(name='Appkey'),
    baseProject?: boolean(name='BaseProject'),
    defaultDiResourceGroupIdentifier?: string(name='DefaultDiResourceGroupIdentifier'),
    destination?: int32(name='Destination'),
    devStorageQuota?: string(name='DevStorageQuota'),
    developmentType?: int32(name='DevelopmentType'),
    disableDevelopment?: boolean(name='DisableDevelopment'),
    envTypes?: [ string ](name='EnvTypes'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    isAllowDownload?: int32(name='IsAllowDownload'),
    isDefault?: int32(name='IsDefault'),
    maxFlowNode?: int32(name='MaxFlowNode'),
    prodStorageQuota?: string(name='ProdStorageQuota'),
    projectDescription?: string(name='ProjectDescription'),
    projectId?: int32(name='ProjectId'),
    projectIdentifier?: string(name='ProjectIdentifier'),
    projectMode?: int32(name='ProjectMode'),
    projectName?: string(name='ProjectName'),
    projectOwnerBaseId?: string(name='ProjectOwnerBaseId'),
    protectedMode?: int32(name='ProtectedMode'),
    residentArea?: string(name='ResidentArea'),
    schedulerMaxRetryTimes?: int32(name='SchedulerMaxRetryTimes'),
    schedulerRetryInterval?: int32(name='SchedulerRetryInterval'),
    status?: int32(name='Status'),
    tablePrivacyMode?: int32(name='TablePrivacyMode'),
    tenantId?: long(name='TenantId'),
    useProxyOdpsAccount?: boolean(name='UseProxyOdpsAccount'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetProjectResponseBody(name='body'),
}

/**
 * @param request GetProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetProjectResponse
 */
async function getProjectWithOptions(request: GetProjectRequest, runtime: Util.RuntimeOptions): GetProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProject',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetProjectRequest
 * @return GetProjectResponse
 */
async function getProject(request: GetProjectRequest): GetProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProjectWithOptions(request, runtime);
}

model GetQualityEntityRequest {
  envType?: string(name='EnvType', description='This parameter is required.'),
  matchExpression?: string(name='MatchExpression'),
  projectId?: long(name='ProjectId'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
  tableName?: string(name='TableName', description='This parameter is required.'),
}

model GetQualityEntityResponseBody = {
  data?: [ 
    {
      createTime?: long(name='CreateTime'),
      entityLevel?: int32(name='EntityLevel'),
      envType?: string(name='EnvType'),
      followers?: string(name='Followers'),
      hasRelativeNode?: boolean(name='HasRelativeNode'),
      id?: long(name='Id'),
      matchExpression?: string(name='MatchExpression'),
      modifyTime?: long(name='ModifyTime'),
      modifyUser?: string(name='ModifyUser'),
      onDuty?: string(name='OnDuty'),
      onDutyAccountName?: string(name='OnDutyAccountName'),
      projectName?: string(name='ProjectName'),
      relativeNode?: string(name='RelativeNode'),
      sql?: int32(name='Sql'),
      tableName?: string(name='TableName'),
      task?: int32(name='Task'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetQualityEntityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQualityEntityResponseBody(name='body'),
}

/**
 * @param request GetQualityEntityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetQualityEntityResponse
 */
async function getQualityEntityWithOptions(request: GetQualityEntityRequest, runtime: Util.RuntimeOptions): GetQualityEntityResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.envType)) {
    body['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.matchExpression)) {
    body['MatchExpression'] = request.matchExpression;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetQualityEntity',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetQualityEntityRequest
 * @return GetQualityEntityResponse
 */
async function getQualityEntity(request: GetQualityEntityRequest): GetQualityEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQualityEntityWithOptions(request, runtime);
}

model GetQualityFollowerRequest {
  entityId?: long(name='EntityId', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
}

model GetQualityFollowerResponseBody = {
  data?: [ 
    {
      alarmMode?: int32(name='AlarmMode'),
      entityId?: string(name='EntityId'),
      follower?: string(name='Follower'),
      followerAccountName?: string(name='FollowerAccountName'),
      id?: long(name='Id'),
      projectName?: string(name='ProjectName'),
      tableName?: string(name='TableName'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetQualityFollowerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQualityFollowerResponseBody(name='body'),
}

/**
 * @param request GetQualityFollowerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetQualityFollowerResponse
 */
async function getQualityFollowerWithOptions(request: GetQualityFollowerRequest, runtime: Util.RuntimeOptions): GetQualityFollowerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.entityId)) {
    body['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetQualityFollower',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetQualityFollowerRequest
 * @return GetQualityFollowerResponse
 */
async function getQualityFollower(request: GetQualityFollowerRequest): GetQualityFollowerResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQualityFollowerWithOptions(request, runtime);
}

model GetQualityRuleRequest {
  projectId?: long(name='ProjectId'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
  ruleId?: long(name='RuleId', description='This parameter is required.'),
}

model GetQualityRuleResponseBody = {
  data?: {
    blockType?: int32(name='BlockType'),
    checker?: int32(name='Checker'),
    checkerName?: string(name='CheckerName'),
    comment?: string(name='Comment'),
    criticalThreshold?: string(name='CriticalThreshold'),
    entityId?: long(name='EntityId'),
    expectValue?: string(name='ExpectValue'),
    fixCheck?: boolean(name='FixCheck'),
    id?: long(name='Id'),
    methodId?: int32(name='MethodId'),
    methodName?: string(name='MethodName'),
    onDuty?: string(name='OnDuty'),
    onDutyAccountName?: string(name='OnDutyAccountName'),
    openSwitch?: boolean(name='OpenSwitch'),
    operator?: string(name='Operator'),
    predictType?: int32(name='PredictType'),
    property?: string(name='Property'),
    ruleName?: string(name='RuleName'),
    ruleType?: int32(name='RuleType'),
    templateId?: int32(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    trend?: string(name='Trend'),
    warningThreshold?: string(name='WarningThreshold'),
    whereCondition?: string(name='WhereCondition'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetQualityRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQualityRuleResponseBody(name='body'),
}

/**
 * @param request GetQualityRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetQualityRuleResponse
 */
async function getQualityRuleWithOptions(request: GetQualityRuleRequest, runtime: Util.RuntimeOptions): GetQualityRuleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.ruleId)) {
    body['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetQualityRule',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetQualityRuleRequest
 * @return GetQualityRuleResponse
 */
async function getQualityRule(request: GetQualityRuleRequest): GetQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQualityRuleWithOptions(request, runtime);
}

model GetRemindRequest {
  remindId?: long(name='RemindId', description='This parameter is required.'),
}

model GetRemindResponseBody = {
  data?: {
    alertInterval?: int32(name='AlertInterval'),
    alertMethods?: [ string ](name='AlertMethods'),
    alertTargets?: [ string ](name='AlertTargets'),
    alertUnit?: string(name='AlertUnit'),
    baselines?: [ 
      {
        baselineId?: long(name='BaselineId'),
        baselineName?: string(name='BaselineName'),
      }
    ](name='Baselines'),
    bizProcesses?: [ 
      {
        bizId?: long(name='BizId'),
        bizProcessName?: string(name='BizProcessName'),
      }
    ](name='BizProcesses'),
    detail?: string(name='Detail'),
    dndEnd?: string(name='DndEnd'),
    dndStart?: string(name='DndStart'),
    founder?: string(name='Founder'),
    maxAlertTimes?: int32(name='MaxAlertTimes'),
    nodes?: [ 
      {
        nodeId?: long(name='NodeId'),
        nodeName?: string(name='NodeName'),
        owner?: string(name='Owner'),
        projectId?: long(name='ProjectId'),
      }
    ](name='Nodes'),
    projects?: [ 
      {
        projectId?: long(name='ProjectId'),
      }
    ](name='Projects'),
    remindId?: long(name='RemindId'),
    remindName?: string(name='RemindName'),
    remindType?: string(name='RemindType'),
    remindUnit?: string(name='RemindUnit'),
    robots?: [ 
      {
        atAll?: boolean(name='AtAll'),
        webUrl?: string(name='WebUrl'),
      }
    ](name='Robots'),
    useflag?: boolean(name='Useflag'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetRemindResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRemindResponseBody(name='body'),
}

/**
 * @param request GetRemindRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRemindResponse
 */
async function getRemindWithOptions(request: GetRemindRequest, runtime: Util.RuntimeOptions): GetRemindResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.remindId)) {
    body['RemindId'] = request.remindId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetRemind',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetRemindRequest
 * @return GetRemindResponse
 */
async function getRemind(request: GetRemindRequest): GetRemindResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRemindWithOptions(request, runtime);
}

model GetResourceRequest {
  id?: long(name='Id', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
}

model GetResourceResponseBody = {
  requestId?: string(name='RequestId'),
  resource?: {
    createTime?: long(name='CreateTime'),
    id?: long(name='Id'),
    modifyTime?: long(name='ModifyTime'),
    name?: string(name='Name'),
    owner?: string(name='Owner'),
    projectId?: long(name='ProjectId'),
    spec?: string(name='Spec'),
  }(name='Resource'),
}

model GetResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetResourceResponseBody(name='body'),
}

/**
 * @summary 获取资源文件
 *
 * @param request GetResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetResourceResponse
 */
async function getResourceWithOptions(request: GetResourceRequest, runtime: Util.RuntimeOptions): GetResourceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResource',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取资源文件
 *
 * @param request GetResourceRequest
 * @return GetResourceResponse
 */
async function getResource(request: GetResourceRequest): GetResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResourceWithOptions(request, runtime);
}

model GetTaskRequest {
  envType?: string(name='EnvType'),
  id?: long(name='Id', description='This parameter is required.'),
}

model GetTaskResponseBody = {
  requestId?: string(name='RequestId'),
  task?: {
    baselineId?: long(name='BaselineId'),
    createTime?: long(name='CreateTime'),
    createUser?: string(name='CreateUser'),
    dataSource?: {
      name?: string(name='Name'),
    }(name='DataSource'),
    dependencies?: [ 
      {
        type?: string(name='Type'),
        upstreamOutput?: string(name='UpstreamOutput'),
        upstreamTaskId?: string(name='UpstreamTaskId'),
      }
    ](name='Dependencies'),
    description?: string(name='Description'),
    envType?: string(name='EnvType'),
    id?: long(name='Id'),
    inputs?: {
      variables?: [ 
        {
          name?: string(name='Name'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='Variables'),
    }(name='Inputs'),
    instanceMode?: string(name='InstanceMode'),
    modifyTime?: long(name='ModifyTime'),
    modifyUser?: string(name='ModifyUser'),
    name?: string(name='Name'),
    outputs?: {
      taskOutputs?: [ 
        {
          output?: string(name='Output'),
        }
      ](name='TaskOutputs'),
      variables?: [ 
        {
          name?: string(name='Name'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='Variables'),
    }(name='Outputs'),
    owner?: string(name='Owner'),
    priority?: int32(name='Priority'),
    projectId?: long(name='ProjectId'),
    rerunInterval?: int32(name='RerunInterval'),
    rerunMode?: string(name='RerunMode'),
    rerunTimes?: int32(name='RerunTimes'),
    runtimeResource?: {
      cu?: string(name='Cu'),
      image?: string(name='Image'),
      resourceGroupId?: string(name='ResourceGroupId'),
    }(name='RuntimeResource'),
    script?: {
      content?: string(name='Content'),
      parameters?: string(name='Parameters'),
    }(name='Script'),
    subTasks?: {
      subTasks?: [ 
        {
          baselineId?: long(name='BaselineId'),
          createTime?: long(name='CreateTime'),
          createUser?: string(name='CreateUser'),
          dataSource?: {
            name?: string(name='Name'),
          }(name='DataSource'),
          description?: string(name='Description'),
          envType?: string(name='EnvType'),
          id?: long(name='Id'),
          modifyTime?: long(name='ModifyTime'),
          modifyUser?: string(name='ModifyUser'),
          name?: string(name='Name'),
          owner?: string(name='Owner'),
          priority?: int32(name='Priority'),
          projectId?: long(name='ProjectId'),
          rerunInterval?: int32(name='RerunInterval'),
          rerunMode?: string(name='RerunMode'),
          rerunTimes?: int32(name='RerunTimes'),
          runtimeResource?: {
            cu?: string(name='Cu'),
            image?: string(name='Image'),
            resourceGroupId?: string(name='ResourceGroupId'),
          }(name='RuntimeResource'),
          tenantId?: long(name='TenantId'),
          timeout?: int32(name='Timeout'),
          trigger?: {
            cron?: string(name='Cron'),
            endTime?: string(name='EndTime'),
            recurrence?: string(name='Recurrence'),
            startTime?: string(name='StartTime'),
            type?: string(name='Type'),
          }(name='Trigger'),
          type?: string(name='Type'),
          workflowId?: long(name='WorkflowId'),
        }
      ](name='SubTasks'),
      type?: string(name='Type'),
    }(name='SubTasks'),
    tags?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='Tags'),
    tenantId?: long(name='TenantId'),
    timeout?: int32(name='Timeout'),
    trigger?: {
      cron?: string(name='Cron'),
      endTime?: string(name='EndTime'),
      recurrence?: string(name='Recurrence'),
      startTime?: string(name='StartTime'),
      type?: string(name='Type'),
    }(name='Trigger'),
    type?: string(name='Type'),
    workflowId?: long(name='WorkflowId'),
  }(name='Task'),
}

model GetTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTaskResponseBody(name='body'),
}

/**
 * @param request GetTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTaskResponse
 */
async function getTaskWithOptions(request: GetTaskRequest, runtime: Util.RuntimeOptions): GetTaskResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTask',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetTaskRequest
 * @return GetTaskResponse
 */
async function getTask(request: GetTaskRequest): GetTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskWithOptions(request, runtime);
}

model GetTaskInfluenceBaselineRequest {
  taskId?: long(name='TaskId', description='This parameter is required.'),
}

model GetTaskInfluenceBaselineResponseBody = {
  requestId?: string(name='RequestId'),
  taskInfluence?: {
    influences?: [ 
      {
        baselineId?: long(name='BaselineId'),
        baselineName?: string(name='BaselineName'),
        owner?: string(name='Owner'),
        priority?: int32(name='Priority'),
        projectId?: long(name='ProjectId'),
      }
    ](name='Influences'),
    taskId?: long(name='TaskId'),
  }(name='TaskInfluence'),
}

model GetTaskInfluenceBaselineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTaskInfluenceBaselineResponseBody(name='body'),
}

/**
 * @summary 获取任务关联的基线信息
 *
 * @param request GetTaskInfluenceBaselineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTaskInfluenceBaselineResponse
 */
async function getTaskInfluenceBaselineWithOptions(request: GetTaskInfluenceBaselineRequest, runtime: Util.RuntimeOptions): GetTaskInfluenceBaselineResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskInfluenceBaseline',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取任务关联的基线信息
 *
 * @param request GetTaskInfluenceBaselineRequest
 * @return GetTaskInfluenceBaselineResponse
 */
async function getTaskInfluenceBaseline(request: GetTaskInfluenceBaselineRequest): GetTaskInfluenceBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskInfluenceBaselineWithOptions(request, runtime);
}

model GetTaskInstanceRequest {
  id?: long(name='Id', description='This parameter is required.'),
}

model GetTaskInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  taskInstance?: {
    baselineId?: long(name='BaselineId'),
    bizdate?: long(name='Bizdate'),
    createTime?: long(name='CreateTime'),
    createUser?: string(name='CreateUser'),
    dataSource?: {
      name?: string(name='Name'),
    }(name='DataSource'),
    description?: string(name='Description'),
    envType?: string(name='EnvType'),
    finishedTime?: long(name='FinishedTime'),
    id?: long(name='Id'),
    inputs?: {
      variables?: [ 
        {
          name?: string(name='Name'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='Variables'),
    }(name='Inputs'),
    modifyTime?: long(name='ModifyTime'),
    modifyUser?: string(name='ModifyUser'),
    outputs?: {
      taskOutputs?: [ 
        {
          output?: string(name='Output'),
        }
      ](name='TaskOutputs'),
      variables?: [ 
        {
          name?: string(name='Name'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='Variables'),
    }(name='Outputs'),
    owner?: string(name='Owner'),
    periodNumber?: int32(name='PeriodNumber'),
    priority?: int32(name='Priority'),
    projectId?: long(name='ProjectId'),
    rerunMode?: string(name='RerunMode'),
    runNumber?: int32(name='RunNumber'),
    runtime?: {
      gateway?: string(name='Gateway'),
      processId?: string(name='ProcessId'),
    }(name='Runtime'),
    runtimeResource?: {
      cu?: string(name='Cu'),
      image?: string(name='Image'),
      resourceGroupId?: string(name='ResourceGroupId'),
    }(name='RuntimeResource'),
    script?: {
      content?: string(name='Content'),
      parameters?: string(name='Parameters'),
    }(name='Script'),
    startedTime?: long(name='StartedTime'),
    status?: string(name='Status'),
    tags?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='Tags'),
    taskId?: long(name='TaskId'),
    taskName?: string(name='TaskName'),
    taskType?: string(name='TaskType'),
    tenantId?: long(name='TenantId'),
    timeout?: int32(name='Timeout'),
    triggerRecurrence?: string(name='TriggerRecurrence'),
    triggerTime?: long(name='TriggerTime'),
    triggerType?: string(name='TriggerType'),
    workflowId?: long(name='WorkflowId'),
    workflowInstanceId?: long(name='WorkflowInstanceId'),
    workflowInstanceType?: string(name='WorkflowInstanceType'),
    workflowName?: string(name='WorkflowName'),
  }(name='TaskInstance'),
}

model GetTaskInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTaskInstanceResponseBody(name='body'),
}

/**
 * @param request GetTaskInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTaskInstanceResponse
 */
async function getTaskInstanceWithOptions(request: GetTaskInstanceRequest, runtime: Util.RuntimeOptions): GetTaskInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskInstance',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetTaskInstanceRequest
 * @return GetTaskInstanceResponse
 */
async function getTaskInstance(request: GetTaskInstanceRequest): GetTaskInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskInstanceWithOptions(request, runtime);
}

model GetTaskInstanceLogRequest {
  id?: long(name='Id', description='This parameter is required.'),
  runNumber?: int32(name='RunNumber'),
}

model GetTaskInstanceLogResponseBody = {
  requestId?: string(name='RequestId'),
  taskInstanceLog?: string(name='TaskInstanceLog'),
}

model GetTaskInstanceLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTaskInstanceLogResponseBody(name='body'),
}

/**
 * @param request GetTaskInstanceLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTaskInstanceLogResponse
 */
async function getTaskInstanceLogWithOptions(request: GetTaskInstanceLogRequest, runtime: Util.RuntimeOptions): GetTaskInstanceLogResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskInstanceLog',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetTaskInstanceLogRequest
 * @return GetTaskInstanceLogResponse
 */
async function getTaskInstanceLog(request: GetTaskInstanceLogRequest): GetTaskInstanceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskInstanceLogWithOptions(request, runtime);
}

model GetTopicRequest {
  topicId?: long(name='TopicId', description='This parameter is required.'),
}

model GetTopicResponseBody = {
  data?: {
    addTime?: long(name='AddTime'),
    alertTime?: long(name='AlertTime'),
    assigner?: string(name='Assigner'),
    baselineBuffer?: long(name='BaselineBuffer'),
    baselineId?: long(name='BaselineId'),
    baselineInGroupId?: int32(name='BaselineInGroupId'),
    baselineName?: string(name='BaselineName'),
    baselineStatus?: string(name='BaselineStatus'),
    buffer?: long(name='Buffer'),
    dealTime?: long(name='DealTime'),
    dealUser?: string(name='DealUser'),
    fixTime?: long(name='FixTime'),
    happenTime?: long(name='HappenTime'),
    instanceId?: long(name='InstanceId'),
    nextAlertTime?: long(name='NextAlertTime'),
    nodeId?: long(name='NodeId'),
    nodeName?: string(name='NodeName'),
    owner?: string(name='Owner'),
    projectId?: long(name='ProjectId'),
    topicId?: long(name='TopicId'),
    topicName?: string(name='TopicName'),
    topicStatus?: string(name='TopicStatus'),
    topicType?: string(name='TopicType'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTopicResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTopicResponseBody(name='body'),
}

/**
 * @param request GetTopicRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTopicResponse
 */
async function getTopicWithOptions(request: GetTopicRequest, runtime: Util.RuntimeOptions): GetTopicResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.topicId)) {
    body['TopicId'] = request.topicId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTopic',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetTopicRequest
 * @return GetTopicResponse
 */
async function getTopic(request: GetTopicRequest): GetTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTopicWithOptions(request, runtime);
}

model GetTopicInfluenceRequest {
  topicId?: long(name='TopicId', description='This parameter is required.'),
}

model GetTopicInfluenceResponseBody = {
  data?: {
    influences?: [ 
      {
        baselineId?: long(name='BaselineId'),
        baselineName?: string(name='BaselineName'),
        bizdate?: long(name='Bizdate'),
        buffer?: long(name='Buffer'),
        inGroupId?: int32(name='InGroupId'),
        owner?: string(name='Owner'),
        priority?: int32(name='Priority'),
        projectId?: long(name='ProjectId'),
        status?: string(name='Status'),
      }
    ](name='Influences'),
    topicId?: long(name='TopicId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTopicInfluenceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTopicInfluenceResponseBody(name='body'),
}

/**
 * @param request GetTopicInfluenceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTopicInfluenceResponse
 */
async function getTopicInfluenceWithOptions(request: GetTopicInfluenceRequest, runtime: Util.RuntimeOptions): GetTopicInfluenceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.topicId)) {
    body['TopicId'] = request.topicId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTopicInfluence',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetTopicInfluenceRequest
 * @return GetTopicInfluenceResponse
 */
async function getTopicInfluence(request: GetTopicInfluenceRequest): GetTopicInfluenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTopicInfluenceWithOptions(request, runtime);
}

model GetWorkflowRequest {
  envType?: string(name='EnvType'),
  id?: long(name='Id', description='This parameter is required.'),
}

model GetWorkflowResponseBody = {
  requestId?: string(name='RequestId'),
  workflow?: {
    clientUniqueCode?: string(name='ClientUniqueCode'),
    createTime?: long(name='CreateTime'),
    createUser?: string(name='CreateUser'),
    dependencies?: [ 
      {
        type?: string(name='Type'),
        upstreamOutput?: string(name='UpstreamOutput'),
        upstreamTaskId?: long(name='UpstreamTaskId'),
      }
    ](name='Dependencies'),
    description?: string(name='Description'),
    envType?: string(name='EnvType'),
    id?: long(name='Id'),
    modifyTime?: long(name='ModifyTime'),
    modifyUser?: string(name='ModifyUser'),
    name?: string(name='Name'),
    outputs?: {
      taskOutputs?: [ 
        {
          output?: string(name='Output'),
        }
      ](name='TaskOutputs'),
    }(name='Outputs'),
    owner?: string(name='Owner'),
    parameters?: string(name='Parameters'),
    projectId?: long(name='ProjectId'),
    tags?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='Tags'),
    tasks?: [ 
      {
        baselineId?: long(name='BaselineId'),
        clientUniqueCode?: string(name='ClientUniqueCode'),
        createTime?: long(name='CreateTime'),
        createUser?: string(name='CreateUser'),
        dataSource?: {
          name?: string(name='Name'),
        }(name='DataSource'),
        description?: string(name='Description'),
        envType?: string(name='EnvType'),
        id?: long(name='Id'),
        modifyTime?: long(name='ModifyTime'),
        modifyUser?: string(name='ModifyUser'),
        name?: string(name='Name'),
        owner?: string(name='Owner'),
        priority?: int32(name='Priority'),
        projectId?: long(name='ProjectId'),
        rerunInterval?: int32(name='RerunInterval'),
        rerunMode?: string(name='RerunMode'),
        rerunTimes?: int32(name='RerunTimes'),
        runtimeResource?: {
          cu?: string(name='Cu'),
          image?: string(name='Image'),
          resourceGroupId?: string(name='ResourceGroupId'),
        }(name='RuntimeResource'),
        timeout?: int32(name='Timeout'),
        triggerRecurrence?: string(name='TriggerRecurrence'),
        type?: string(name='Type'),
        workflowId?: long(name='WorkflowId'),
      }
    ](name='Tasks'),
    trigger?: {
      cron?: string(name='Cron'),
      endTime?: string(name='EndTime'),
      recurrence?: string(name='Recurrence'),
      startTime?: string(name='StartTime'),
      type?: string(name='Type'),
    }(name='Trigger'),
  }(name='Workflow'),
}

model GetWorkflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetWorkflowResponseBody(name='body'),
}

/**
 * @param request GetWorkflowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetWorkflowResponse
 */
async function getWorkflowWithOptions(request: GetWorkflowRequest, runtime: Util.RuntimeOptions): GetWorkflowResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWorkflow',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetWorkflowRequest
 * @return GetWorkflowResponse
 */
async function getWorkflow(request: GetWorkflowRequest): GetWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWorkflowWithOptions(request, runtime);
}

model GetWorkflowDefinitionRequest {
  id?: long(name='Id', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
}

model GetWorkflowDefinitionResponseBody = {
  requestId?: string(name='RequestId'),
  workflowDefinition?: {
    createTime?: long(name='CreateTime'),
    id?: long(name='Id'),
    modifyTime?: long(name='ModifyTime'),
    name?: string(name='Name'),
    owner?: string(name='Owner'),
    projectId?: long(name='ProjectId'),
    spec?: string(name='Spec'),
    workflowId?: long(name='WorkflowId'),
  }(name='WorkflowDefinition'),
}

model GetWorkflowDefinitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetWorkflowDefinitionResponseBody(name='body'),
}

/**
 * @summary 获取工作流详情
 *
 * @param request GetWorkflowDefinitionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetWorkflowDefinitionResponse
 */
async function getWorkflowDefinitionWithOptions(request: GetWorkflowDefinitionRequest, runtime: Util.RuntimeOptions): GetWorkflowDefinitionResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWorkflowDefinition',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取工作流详情
 *
 * @param request GetWorkflowDefinitionRequest
 * @return GetWorkflowDefinitionResponse
 */
async function getWorkflowDefinition(request: GetWorkflowDefinitionRequest): GetWorkflowDefinitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWorkflowDefinitionWithOptions(request, runtime);
}

model GetWorkflowInstanceRequest {
  id?: long(name='Id', description='This parameter is required.'),
}

model GetWorkflowInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  workflowInstance?: {
    bizDate?: long(name='BizDate'),
    createTime?: long(name='CreateTime'),
    createUser?: string(name='CreateUser'),
    envType?: string(name='EnvType'),
    finishedTime?: long(name='FinishedTime'),
    id?: long(name='Id'),
    modifyTime?: long(name='ModifyTime'),
    modifyUser?: string(name='ModifyUser'),
    name?: string(name='Name'),
    projectId?: long(name='ProjectId'),
    startedTime?: long(name='StartedTime'),
    status?: string(name='Status'),
    type?: string(name='Type'),
    waitingResourceTime?: long(name='WaitingResourceTime'),
    waitingTriggerTime?: long(name='WaitingTriggerTime'),
    workflowId?: long(name='WorkflowId'),
  }(name='WorkflowInstance'),
}

model GetWorkflowInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetWorkflowInstanceResponseBody(name='body'),
}

/**
 * @param request GetWorkflowInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetWorkflowInstanceResponse
 */
async function getWorkflowInstanceWithOptions(request: GetWorkflowInstanceRequest, runtime: Util.RuntimeOptions): GetWorkflowInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWorkflowInstance',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetWorkflowInstanceRequest
 * @return GetWorkflowInstanceResponse
 */
async function getWorkflowInstance(request: GetWorkflowInstanceRequest): GetWorkflowInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWorkflowInstanceWithOptions(request, runtime);
}

model ImportWorkflowDefinitionRequest {
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  spec?: string(name='Spec', description='This parameter is required.'),
}

model ImportWorkflowDefinitionResponseBody = {
  asyncJob?: {
    completed?: boolean(name='Completed'),
    createTime?: long(name='CreateTime'),
    error?: string(name='Error'),
    id?: string(name='Id'),
    progress?: int32(name='Progress'),
    response?: string(name='Response'),
    status?: string(name='Status'),
    type?: string(name='Type'),
  }(name='AsyncJob'),
  requestId?: string(name='RequestId'),
}

model ImportWorkflowDefinitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ImportWorkflowDefinitionResponseBody(name='body'),
}

/**
 * @summary 调用此接口，可以将通过FlowSpec定义的工作流节点和其内部的子节点都导入到数据开发中
 *
 * @param request ImportWorkflowDefinitionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportWorkflowDefinitionResponse
 */
async function importWorkflowDefinitionWithOptions(request: ImportWorkflowDefinitionRequest, runtime: Util.RuntimeOptions): ImportWorkflowDefinitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.spec)) {
    body['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ImportWorkflowDefinition',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 调用此接口，可以将通过FlowSpec定义的工作流节点和其内部的子节点都导入到数据开发中
 *
 * @param request ImportWorkflowDefinitionRequest
 * @return ImportWorkflowDefinitionResponse
 */
async function importWorkflowDefinition(request: ImportWorkflowDefinitionRequest): ImportWorkflowDefinitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return importWorkflowDefinitionWithOptions(request, runtime);
}

model ListAlertMessagesRequest {
  alertMethods?: string(name='AlertMethods'),
  alertRuleTypes?: string(name='AlertRuleTypes'),
  alertUser?: string(name='AlertUser'),
  baselineId?: long(name='BaselineId'),
  beginTime?: string(name='BeginTime', description='This parameter is required.'),
  endTime?: string(name='EndTime', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  remindId?: long(name='RemindId'),
}

model ListAlertMessagesResponseBody = {
  data?: {
    alertMessages?: [ 
      {
        alertId?: long(name='AlertId'),
        alertMessageStatus?: string(name='AlertMessageStatus'),
        alertMethod?: string(name='AlertMethod'),
        alertTime?: long(name='AlertTime'),
        alertUser?: string(name='AlertUser'),
        content?: string(name='Content'),
        instances?: [ 
          {
            instanceId?: long(name='InstanceId'),
            nodeId?: long(name='NodeId'),
            nodeName?: string(name='NodeName'),
            projectId?: long(name='ProjectId'),
            status?: string(name='Status'),
          }
        ](name='Instances'),
        nodes?: [ 
          {
            nodeId?: long(name='NodeId'),
            nodeName?: string(name='NodeName'),
            owner?: string(name='Owner'),
            projectId?: long(name='ProjectId'),
          }
        ](name='Nodes'),
        remindId?: long(name='RemindId'),
        remindName?: string(name='RemindName'),
        slaAlert?: {
          baselineId?: long(name='BaselineId'),
          baselineName?: string(name='BaselineName'),
          baselineOwner?: string(name='BaselineOwner'),
          bizdate?: long(name='Bizdate'),
          inGroupId?: int32(name='InGroupId'),
          projectId?: long(name='ProjectId'),
          status?: string(name='Status'),
        }(name='SlaAlert'),
        source?: string(name='Source'),
        topics?: [ 
          {
            instanceId?: long(name='InstanceId'),
            nodeId?: long(name='NodeId'),
            topicId?: long(name='TopicId'),
            topicName?: string(name='TopicName'),
            topicOwner?: string(name='TopicOwner'),
            topicStatus?: string(name='TopicStatus'),
          }
        ](name='Topics'),
      }
    ](name='AlertMessages'),
    pageNumber?: string(name='PageNumber'),
    pageSize?: string(name='PageSize'),
    totalCount?: string(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAlertMessagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAlertMessagesResponseBody(name='body'),
}

/**
 * @param request ListAlertMessagesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAlertMessagesResponse
 */
async function listAlertMessagesWithOptions(request: ListAlertMessagesRequest, runtime: Util.RuntimeOptions): ListAlertMessagesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alertMethods)) {
    body['AlertMethods'] = request.alertMethods;
  }
  if (!Util.isUnset(request.alertRuleTypes)) {
    body['AlertRuleTypes'] = request.alertRuleTypes;
  }
  if (!Util.isUnset(request.alertUser)) {
    body['AlertUser'] = request.alertUser;
  }
  if (!Util.isUnset(request.baselineId)) {
    body['BaselineId'] = request.baselineId;
  }
  if (!Util.isUnset(request.beginTime)) {
    body['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remindId)) {
    body['RemindId'] = request.remindId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListAlertMessages',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListAlertMessagesRequest
 * @return ListAlertMessagesResponse
 */
async function listAlertMessages(request: ListAlertMessagesRequest): ListAlertMessagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlertMessagesWithOptions(request, runtime);
}

model ListBaselineConfigsRequest {
  baselineTypes?: string(name='BaselineTypes'),
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  priority?: string(name='Priority'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  searchText?: string(name='SearchText'),
  useflag?: boolean(name='Useflag'),
}

model ListBaselineConfigsResponseBody = {
  data?: {
    baselines?: [ 
      {
        baselineId?: long(name='BaselineId'),
        baselineName?: string(name='BaselineName'),
        baselineType?: string(name='BaselineType'),
        expHour?: int32(name='ExpHour'),
        expMinu?: int32(name='ExpMinu'),
        hourExpDetail?: string(name='HourExpDetail'),
        hourSlaDetail?: string(name='HourSlaDetail'),
        isDefault?: boolean(name='IsDefault'),
        owner?: string(name='Owner'),
        priority?: int32(name='Priority'),
        projectId?: long(name='ProjectId'),
        slaHour?: int32(name='SlaHour'),
        slaMinu?: int32(name='SlaMinu'),
        useFlag?: boolean(name='UseFlag'),
      }
    ](name='Baselines'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListBaselineConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListBaselineConfigsResponseBody(name='body'),
}

/**
 * @param request ListBaselineConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListBaselineConfigsResponse
 */
async function listBaselineConfigsWithOptions(request: ListBaselineConfigsRequest, runtime: Util.RuntimeOptions): ListBaselineConfigsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.baselineTypes)) {
    body['BaselineTypes'] = request.baselineTypes;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.priority)) {
    body['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.searchText)) {
    body['SearchText'] = request.searchText;
  }
  if (!Util.isUnset(request.useflag)) {
    body['Useflag'] = request.useflag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListBaselineConfigs',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListBaselineConfigsRequest
 * @return ListBaselineConfigsResponse
 */
async function listBaselineConfigs(request: ListBaselineConfigsRequest): ListBaselineConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBaselineConfigsWithOptions(request, runtime);
}

model ListBaselineStatusesRequest {
  baselineTypes?: string(name='BaselineTypes'),
  bizdate?: string(name='Bizdate', description='This parameter is required.'),
  finishStatus?: string(name='FinishStatus'),
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  priority?: string(name='Priority'),
  searchText?: string(name='SearchText'),
  status?: string(name='Status'),
  topicId?: long(name='TopicId'),
}

model ListBaselineStatusesResponseBody = {
  data?: {
    baselineStatuses?: [ 
      {
        baselineId?: long(name='BaselineId'),
        baselineName?: string(name='BaselineName'),
        bizdate?: long(name='Bizdate'),
        buffer?: long(name='Buffer'),
        endCast?: long(name='EndCast'),
        expTime?: long(name='ExpTime'),
        finishStatus?: string(name='FinishStatus'),
        finishTime?: long(name='FinishTime'),
        inGroupId?: int32(name='InGroupId'),
        owner?: string(name='Owner'),
        priority?: int32(name='Priority'),
        projectId?: long(name='ProjectId'),
        slaTime?: long(name='SlaTime'),
        status?: string(name='Status'),
      }
    ](name='BaselineStatuses'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListBaselineStatusesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListBaselineStatusesResponseBody(name='body'),
}

/**
 * @param request ListBaselineStatusesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListBaselineStatusesResponse
 */
async function listBaselineStatusesWithOptions(request: ListBaselineStatusesRequest, runtime: Util.RuntimeOptions): ListBaselineStatusesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.baselineTypes)) {
    body['BaselineTypes'] = request.baselineTypes;
  }
  if (!Util.isUnset(request.bizdate)) {
    body['Bizdate'] = request.bizdate;
  }
  if (!Util.isUnset(request.finishStatus)) {
    body['FinishStatus'] = request.finishStatus;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.priority)) {
    body['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.searchText)) {
    body['SearchText'] = request.searchText;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  if (!Util.isUnset(request.topicId)) {
    body['TopicId'] = request.topicId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListBaselineStatuses',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListBaselineStatusesRequest
 * @return ListBaselineStatusesResponse
 */
async function listBaselineStatuses(request: ListBaselineStatusesRequest): ListBaselineStatusesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBaselineStatusesWithOptions(request, runtime);
}

model ListBusinessRequest {
  keyword?: string(name='Keyword'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model ListBusinessResponseBody = {
  data?: {
    business?: [ 
      {
        businessId?: long(name='BusinessId'),
        businessName?: string(name='BusinessName'),
        description?: string(name='Description'),
        owner?: string(name='Owner'),
        projectId?: long(name='ProjectId'),
        useType?: string(name='UseType'),
      }
    ](name='Business'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListBusinessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListBusinessResponseBody(name='body'),
}

/**
 * @param request ListBusinessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListBusinessResponse
 */
async function listBusinessWithOptions(request: ListBusinessRequest, runtime: Util.RuntimeOptions): ListBusinessResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.keyword)) {
    body['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListBusiness',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListBusinessRequest
 * @return ListBusinessResponse
 */
async function listBusiness(request: ListBusinessRequest): ListBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBusinessWithOptions(request, runtime);
}

model ListCheckersForProjectRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model ListCheckersForProjectResponseBody = {
  checkers?: [ 
    {
      checkerIdentifier?: string(name='CheckerIdentifier'),
      checkerType?: string(name='CheckerType'),
      description?: string(name='Description'),
      fileTypes?: string(name='FileTypes'),
      helpDocUrl?: string(name='HelpDocUrl'),
      name?: string(name='Name'),
      owner?: string(name='Owner'),
    }
  ](name='Checkers'),
  requestId?: string(name='RequestId'),
}

model ListCheckersForProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCheckersForProjectResponseBody(name='body'),
}

/**
 * @summary 获取项目空间下已开启的检查器列表
 *
 * @param request ListCheckersForProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckersForProjectResponse
 */
async function listCheckersForProjectWithOptions(request: ListCheckersForProjectRequest, runtime: Util.RuntimeOptions): ListCheckersForProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListCheckersForProject',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取项目空间下已开启的检查器列表
 *
 * @param request ListCheckersForProjectRequest
 * @return ListCheckersForProjectResponse
 */
async function listCheckersForProject(request: ListCheckersForProjectRequest): ListCheckersForProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCheckersForProjectWithOptions(request, runtime);
}

model ListDIAlarmRulesRequest {
  DIAlarmRuleId?: long(name='DIAlarmRuleId'),
  jobId?: long(name='JobId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListDIAlarmRulesResponseBody = {
  pagingInfo?: {
    DIJobAlarmRules?: [ 
      {
        DIAlarmRuleId?: long(name='DIAlarmRuleId', deprecated=true),
        DIJobId?: long(name='DIJobId'),
        description?: string(name='Description'),
        enabled?: boolean(name='Enabled'),
        id?: long(name='Id'),
        metricType?: string(name='MetricType'),
        name?: string(name='Name'),
        notificationSettings?: {
          inhibitionInterval?: long(name='InhibitionInterval', deprecated=true),
          muteInterval?: long(name='MuteInterval'),
          notificationChannels?: [ 
            {
              channels?: [ string ](name='Channels'),
              severity?: string(name='Severity'),
            }
          ](name='NotificationChannels'),
          notificationReceivers?: [ 
            {
              receiverType?: string(name='ReceiverType'),
              receiverValues?: [ string ](name='ReceiverValues'),
            }
          ](name='NotificationReceivers'),
        }(name='NotificationSettings'),
        triggerConditions?: [ 
          {
            ddlReportTags?: [ string ](name='DdlReportTags', deprecated=true),
            ddlTypes?: [ string ](name='DdlTypes'),
            duration?: long(name='Duration'),
            severity?: string(name='Severity'),
            threshold?: long(name='Threshold'),
          }
        ](name='TriggerConditions'),
      }
    ](name='DIJobAlarmRules'),
    pageNumber?: long(name='PageNumber'),
    pageSize?: long(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListDIAlarmRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDIAlarmRulesResponseBody(name='body'),
}

/**
 * @summary 查看数据集成报警规则
 *
 * @param request ListDIAlarmRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDIAlarmRulesResponse
 */
async function listDIAlarmRulesWithOptions(request: ListDIAlarmRulesRequest, runtime: Util.RuntimeOptions): ListDIAlarmRulesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDIAlarmRules',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查看数据集成报警规则
 *
 * @param request ListDIAlarmRulesRequest
 * @return ListDIAlarmRulesResponse
 */
async function listDIAlarmRules(request: ListDIAlarmRulesRequest): ListDIAlarmRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDIAlarmRulesWithOptions(request, runtime);
}

model ListDIJobEventsRequest {
  DIJobId?: long(name='DIJobId'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  eventType?: string(name='EventType', description='This parameter is required.'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
}

model ListDIJobEventsResponseBody = {
  pagingInfo?: {
    DIJobEvent?: [ 
      {
        action?: string(name='Action'),
        channels?: string(name='Channels'),
        createTime?: string(name='CreateTime'),
        detail?: string(name='Detail'),
        dstSql?: string(name='DstSql'),
        dstTable?: string(name='DstTable'),
        failoverMessage?: string(name='FailoverMessage'),
        id?: string(name='Id'),
        severity?: string(name='Severity'),
        srcSql?: string(name='SrcSql'),
        srcTable?: string(name='SrcTable'),
        status?: string(name='Status'),
        type?: string(name='Type'),
      }
    ](name='DIJobEvent'),
    pageNumber?: long(name='PageNumber'),
    pageSize?: long(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListDIJobEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDIJobEventsResponseBody(name='body'),
}

/**
 * @summary 获取数据集成任务事件
 *
 * @param request ListDIJobEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDIJobEventsResponse
 */
async function listDIJobEventsWithOptions(request: ListDIJobEventsRequest, runtime: Util.RuntimeOptions): ListDIJobEventsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDIJobEvents',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取数据集成任务事件
 *
 * @param request ListDIJobEventsRequest
 * @return ListDIJobEventsResponse
 */
async function listDIJobEvents(request: ListDIJobEventsRequest): ListDIJobEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDIJobEventsWithOptions(request, runtime);
}

model ListDIJobMetricsRequest {
  DIJobId?: long(name='DIJobId'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  metricName?: [ string ](name='MetricName', description='This parameter is required.'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
}

model ListDIJobMetricsShrinkRequest {
  DIJobId?: long(name='DIJobId'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  metricNameShrink?: string(name='MetricName', description='This parameter is required.'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
}

model ListDIJobMetricsResponseBody = {
  pagingInfo?: {
    jobMetrics?: [ 
      {
        name?: string(name='Name'),
        seriesList?: [ 
          {
            time?: long(name='Time'),
            value?: double(name='Value'),
          }
        ](name='SeriesList'),
      }
    ](name='JobMetrics'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListDIJobMetricsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDIJobMetricsResponseBody(name='body'),
}

/**
 * @summary 获取数据集成任务指标
 *
 * @param tmpReq ListDIJobMetricsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDIJobMetricsResponse
 */
async function listDIJobMetricsWithOptions(tmpReq: ListDIJobMetricsRequest, runtime: Util.RuntimeOptions): ListDIJobMetricsResponse {
  Util.validateModel(tmpReq);
  var request = new ListDIJobMetricsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.metricName)) {
    request.metricNameShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.metricName, 'MetricName', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDIJobMetrics',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取数据集成任务指标
 *
 * @param request ListDIJobMetricsRequest
 * @return ListDIJobMetricsResponse
 */
async function listDIJobMetrics(request: ListDIJobMetricsRequest): ListDIJobMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDIJobMetricsWithOptions(request, runtime);
}

model ListDIJobRunDetailsRequest {
  DIJobId?: long(name='DIJobId', description='This parameter is required.'),
  instanceId?: long(name='InstanceId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  sourceDataSourceName?: string(name='SourceDataSourceName'),
  sourceDatabaseName?: string(name='SourceDatabaseName'),
  sourceSchemaName?: string(name='SourceSchemaName'),
  sourceTableName?: string(name='SourceTableName'),
}

model ListDIJobRunDetailsResponseBody = {
  pagingInfo?: {
    jobRunInfos?: [ 
      {
        destinationDatabaseName?: string(name='DestinationDatabaseName'),
        destinationDatasourceName?: string(name='DestinationDatasourceName'),
        destinationSchemaName?: string(name='DestinationSchemaName'),
        destinationTableName?: string(name='DestinationTableName'),
        fullMigrationErrorMessage?: string(name='FullMigrationErrorMessage'),
        fullMigrationStatus?: string(name='FullMigrationStatus'),
        offlineErrorRecords?: long(name='OfflineErrorRecords'),
        offlineTotalBytes?: long(name='OfflineTotalBytes'),
        offlineTotalRecords?: long(name='OfflineTotalRecords'),
        realtimeMigrationErrorMessage?: string(name='RealtimeMigrationErrorMessage'),
        realtimeMigrationStatus?: string(name='RealtimeMigrationStatus'),
        sourceDatabaseName?: string(name='SourceDatabaseName'),
        sourceDatasourceName?: string(name='SourceDatasourceName'),
        sourceSchemaName?: string(name='SourceSchemaName'),
        sourceTableName?: string(name='SourceTableName'),
        structureMigrationErrorMessage?: string(name='StructureMigrationErrorMessage'),
        structureMigrationStatus?: string(name='StructureMigrationStatus'),
      }
    ](name='JobRunInfos'),
    pageNumber?: string(name='PageNumber'),
    pageSize?: string(name='PageSize'),
    totalCount?: string(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListDIJobRunDetailsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDIJobRunDetailsResponseBody(name='body'),
}

/**
 * @summary 获取数据集成运行信息
 *
 * @param request ListDIJobRunDetailsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDIJobRunDetailsResponse
 */
async function listDIJobRunDetailsWithOptions(request: ListDIJobRunDetailsRequest, runtime: Util.RuntimeOptions): ListDIJobRunDetailsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDIJobRunDetails',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取数据集成运行信息
 *
 * @param request ListDIJobRunDetailsRequest
 * @return ListDIJobRunDetailsResponse
 */
async function listDIJobRunDetails(request: ListDIJobRunDetailsRequest): ListDIJobRunDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDIJobRunDetailsWithOptions(request, runtime);
}

model ListDIJobsRequest {
  destinationDataSourceType?: string(name='DestinationDataSourceType'),
  migrationType?: string(name='MigrationType'),
  name?: string(name='Name'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  sourceDataSourceType?: string(name='SourceDataSourceType'),
}

model ListDIJobsResponseBody = {
  pagingInfo?: {
    DIJobs?: [ 
      {
        DIJobId?: long(name='DIJobId', deprecated=true),
        destinationDataSourceType?: string(name='DestinationDataSourceType'),
        id?: long(name='Id'),
        jobName?: string(name='JobName'),
        jobStatus?: string(name='JobStatus'),
        migrationType?: string(name='MigrationType'),
        projectId?: long(name='ProjectId'),
        sourceDataSourceType?: string(name='SourceDataSourceType'),
      }
    ](name='DIJobs'),
    pageNumber?: long(name='PageNumber'),
    pageSize?: long(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListDIJobsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDIJobsResponseBody(name='body'),
}

/**
 * @summary 获取数据集成任务
 *
 * @param request ListDIJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDIJobsResponse
 */
async function listDIJobsWithOptions(request: ListDIJobsRequest, runtime: Util.RuntimeOptions): ListDIJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDIJobs',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取数据集成任务
 *
 * @param request ListDIJobsRequest
 * @return ListDIJobsResponse
 */
async function listDIJobs(request: ListDIJobsRequest): ListDIJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDIJobsWithOptions(request, runtime);
}

model ListDataQualityEvaluationTaskInstancesRequest {
  bizdateFrom?: string(name='BizdateFrom'),
  bizdateTo?: string(name='BizdateTo'),
  createTimeFrom?: long(name='CreateTimeFrom'),
  createTimeTo?: long(name='CreateTimeTo'),
  dataQualityEvaluationTaskId?: long(name='DataQualityEvaluationTaskId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  tableGuid?: string(name='TableGuid'),
  triggerClient?: string(name='TriggerClient'),
  triggerClientId?: string(name='TriggerClientId'),
}

model ListDataQualityEvaluationTaskInstancesResponseBody = {
  pagingInfo?: {
    dataQualityEvaluationTaskInstances?: [ 
      {
        createTime?: long(name='CreateTime'),
        finishTime?: long(name='FinishTime'),
        id?: long(name='Id'),
        parameters?: string(name='Parameters'),
        projectId?: long(name='ProjectId'),
        status?: string(name='Status'),
        task?: {
          description?: string(name='Description', description='质量监控任务描述'),
          hooks?: [ 
            {
              condition?: string(name='Condition', description='Hook触发条件'),
              type?: string(name='Type', description='Hook类型'),
            }
          ](name='Hooks', description='数据质量校验任务实例生命周期中的回调设置，目前只支持一个阻塞调度任务的Hook'),
          id?: long(name='Id', description='代表资源一级ID的资源属性字段'),
          name?: string(name='Name', description='质量监控任务名称

This parameter is required.'),
          notifications?: {
            condition?: string(name='Condition', description='通知触发条件'),
            notifications?: [ 
              {
                nofiticationReceivers?: [ 
                  {
                    extension?: string(name='Extension', description='扩展信息，格式为 json，例如钉钉机器人支持 at 所有人'),
                    receiverType?: string(name='ReceiverType', description='告警接收人类型'),
                    receiverValues?: [ string ](name='ReceiverValues', description='告警接收人'),
                  }
                ](name='NofiticationReceivers', description='告警接收人设置'),
                notificationChannels?: [ 
                  {
                    channels?: [ string ](name='Channels', description='通知方式'),
                  }
                ](name='NotificationChannels', description='通知方式'),
              }
            ](name='Notifications', description='具体的消息通知设置'),
          }(name='Notifications', description='数据质量校验任务通知订阅配置'),
          projectId?: long(name='ProjectId', description='项目空间Id'),
          regionId?: string(name='RegionId', description='代表region的资源属性字段'),
          runtimeConf?: string(name='RuntimeConf', description='使用数据源时的一些设置，目前只支持指定EMR的yarn队列、采集EMR表时把SQL引擎指定为SPARK-SQL'),
          target?: {
            databaseType?: string(name='DatabaseType', description='表所属的数据库类型'),
            partitionSpec?: string(name='PartitionSpec', description='分区表的分区设置'),
            tableGuid?: string(name='TableGuid', description='表在数据地图中的唯一ID'),
            type?: string(name='Type', description='监控对象类型'),
          }(name='Target', description='参看 DataQualityTarget示例	数据质量校验任务的监控对象，参考 DataQualityTarget'),
          trigger?: {
            taskIds?: [ long ](name='TaskIds', description='具体指明哪些调度节点的实例执行成功后可以触发'),
            type?: string(name='Type', description='何种事件可以触发质量校验任务执行'),
          }(name='Trigger', description='数据质量校验任务的触发配置'),
        }(name='Task'),
        triggerContext?: string(name='TriggerContext'),
      }
    ](name='DataQualityEvaluationTaskInstances'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListDataQualityEvaluationTaskInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataQualityEvaluationTaskInstancesResponseBody(name='body'),
}

/**
 * @summary ListDataQualityEvaluationTaskInstances
 *
 * @param request ListDataQualityEvaluationTaskInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataQualityEvaluationTaskInstancesResponse
 */
async function listDataQualityEvaluationTaskInstancesWithOptions(request: ListDataQualityEvaluationTaskInstancesRequest, runtime: Util.RuntimeOptions): ListDataQualityEvaluationTaskInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDataQualityEvaluationTaskInstances',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary ListDataQualityEvaluationTaskInstances
 *
 * @param request ListDataQualityEvaluationTaskInstancesRequest
 * @return ListDataQualityEvaluationTaskInstancesResponse
 */
async function listDataQualityEvaluationTaskInstances(request: ListDataQualityEvaluationTaskInstancesRequest): ListDataQualityEvaluationTaskInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataQualityEvaluationTaskInstancesWithOptions(request, runtime);
}

model ListDataQualityEvaluationTasksRequest {
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  tableGuid?: string(name='TableGuid'),
}

model ListDataQualityEvaluationTasksResponseBody = {
  pagingInfo?: {
    dataQualityEvaluationTasks?: [ 
      {
        description?: string(name='Description'),
        hooks?: [ 
          {
            condition?: string(name='Condition'),
            type?: string(name='Type'),
          }
        ](name='Hooks'),
        id?: long(name='Id'),
        name?: string(name='Name'),
        notifications?: {
          condition?: string(name='Condition'),
          notifications?: [ 
            {
              notificationChannels?: [ 
                {
                  channels?: [ string ](name='Channels'),
                }
              ](name='NotificationChannels'),
              notificationReceivers?: [ 
                {
                  extension?: string(name='Extension'),
                  receiverType?: string(name='ReceiverType'),
                  receiverValues?: [ string ](name='ReceiverValues'),
                }
              ](name='NotificationReceivers'),
            }
          ](name='Notifications'),
        }(name='Notifications'),
        projectId?: long(name='ProjectId'),
        runtimeConf?: string(name='RuntimeConf'),
        target?: {
          databaseType?: string(name='DatabaseType'),
          partitionSpec?: string(name='PartitionSpec'),
          tableGuid?: string(name='TableGuid'),
          type?: string(name='Type'),
        }(name='Target'),
        trigger?: {
          taskIds?: [ long ](name='TaskIds'),
          type?: string(name='Type'),
        }(name='Trigger'),
      }
    ](name='DataQualityEvaluationTasks'),
    pageNumber?: string(name='PageNumber'),
    pageSize?: string(name='PageSize'),
    totalCount?: string(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListDataQualityEvaluationTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataQualityEvaluationTasksResponseBody(name='body'),
}

/**
 * @param request ListDataQualityEvaluationTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataQualityEvaluationTasksResponse
 */
async function listDataQualityEvaluationTasksWithOptions(request: ListDataQualityEvaluationTasksRequest, runtime: Util.RuntimeOptions): ListDataQualityEvaluationTasksResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDataQualityEvaluationTasks',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListDataQualityEvaluationTasksRequest
 * @return ListDataQualityEvaluationTasksResponse
 */
async function listDataQualityEvaluationTasks(request: ListDataQualityEvaluationTasksRequest): ListDataQualityEvaluationTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataQualityEvaluationTasksWithOptions(request, runtime);
}

model ListDataQualityResultsRequest {
  bizdateFrom?: string(name='BizdateFrom'),
  bizdateTo?: string(name='BizdateTo'),
  createTimeFrom?: long(name='CreateTimeFrom'),
  createTimeTo?: long(name='CreateTimeTo'),
  dataQualityEvaluationTaskId?: long(name='DataQualityEvaluationTaskId'),
  dataQualityEvaluationTaskInstanceId?: long(name='DataQualityEvaluationTaskInstanceId'),
  dataQualityRuleId?: long(name='DataQualityRuleId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model ListDataQualityResultsResponseBody = {
  pagingInfo?: {
    dataQualityResults?: [ 
      {
        createTime?: long(name='CreateTime'),
        details?: [ 
          {
            checkedValue?: string(name='CheckedValue'),
            referencedValue?: string(name='ReferencedValue'),
            status?: string(name='Status'),
          }
        ](name='Details'),
        id?: long(name='Id'),
        rule?: {
          checkingConfig?: {
            referencedSamplesFilter?: string(name='ReferencedSamplesFilter'),
            thresholds?: {
              critical?: {
                operator?: string(name='Operator'),
                value?: string(name='Value'),
              }(name='Critical'),
              expected?: {
                operator?: string(name='Operator'),
                value?: string(name='Value'),
              }(name='Expected'),
              warned?: {
                operator?: string(name='Operator'),
                value?: string(name='Value'),
              }(name='Warned'),
            }(name='Thresholds'),
            type?: string(name='Type'),
          }(name='CheckingConfig'),
          description?: string(name='Description'),
          enabled?: boolean(name='Enabled'),
          errorHandlers?: [ 
            {
              errorDataFilter?: string(name='ErrorDataFilter'),
              type?: string(name='Type'),
            }
          ](name='ErrorHandlers'),
          id?: long(name='Id'),
          name?: string(name='Name'),
          projectId?: long(name='ProjectId'),
          samplingConfig?: {
            metric?: string(name='Metric'),
            metricParameters?: string(name='MetricParameters'),
            samplingFilter?: string(name='SamplingFilter'),
            settingConfig?: string(name='SettingConfig'),
          }(name='SamplingConfig'),
          severity?: string(name='Severity'),
          target?: {
            databaseType?: string(name='DatabaseType'),
            partitionSpec?: string(name='PartitionSpec'),
            tableGuid?: string(name='TableGuid'),
            type?: string(name='Type'),
          }(name='Target'),
          templateCode?: string(name='TemplateCode'),
        }(name='Rule'),
        sample?: string(name='Sample'),
        status?: string(name='Status'),
        taskInstanceId?: long(name='TaskInstanceId'),
      }
    ](name='DataQualityResults'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListDataQualityResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataQualityResultsResponseBody(name='body'),
}

/**
 * @param request ListDataQualityResultsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataQualityResultsResponse
 */
async function listDataQualityResultsWithOptions(request: ListDataQualityResultsRequest, runtime: Util.RuntimeOptions): ListDataQualityResultsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDataQualityResults',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListDataQualityResultsRequest
 * @return ListDataQualityResultsResponse
 */
async function listDataQualityResults(request: ListDataQualityResultsRequest): ListDataQualityResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataQualityResultsWithOptions(request, runtime);
}

model ListDataQualityRulesRequest {
  dataQualityEvaluationTaskId?: long(name='DataQualityEvaluationTaskId'),
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  tableGuid?: string(name='TableGuid'),
}

model ListDataQualityRulesResponseBody = {
  pagingInfo?: {
    dataQualityRules?: [ 
      {
        checkingConfig?: {
          referencedSamplesFilter?: string(name='ReferencedSamplesFilter'),
          thresholds?: {
            critical?: {
              expression?: string(name='Expression'),
              operator?: string(name='Operator'),
              value?: string(name='Value'),
            }(name='Critical'),
            expected?: {
              expression?: string(name='Expression'),
              operator?: string(name='Operator'),
              value?: string(name='Value'),
            }(name='Expected'),
            warned?: {
              expression?: string(name='Expression'),
              operator?: string(name='Operator'),
              value?: string(name='Value'),
            }(name='Warned'),
          }(name='Thresholds'),
          type?: string(name='Type'),
        }(name='CheckingConfig'),
        description?: string(name='Description'),
        enabled?: boolean(name='Enabled'),
        errorHandlers?: [ 
          {
            errorDataFilter?: string(name='ErrorDataFilter'),
            type?: string(name='Type'),
          }
        ](name='ErrorHandlers'),
        id?: long(name='Id'),
        name?: string(name='Name'),
        projectId?: long(name='ProjectId'),
        samplingConfig?: {
          metric?: string(name='Metric'),
          metricParameters?: string(name='MetricParameters'),
          samplingFilter?: string(name='SamplingFilter'),
          settingConfig?: string(name='SettingConfig'),
        }(name='SamplingConfig'),
        severity?: string(name='Severity'),
        target?: {
          databaseType?: string(name='DatabaseType'),
          partitionSpec?: string(name='PartitionSpec'),
          tableGuid?: string(name='TableGuid'),
          type?: string(name='Type'),
        }(name='Target'),
        templateCode?: string(name='TemplateCode'),
      }
    ](name='DataQualityRules'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListDataQualityRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataQualityRulesResponseBody(name='body'),
}

/**
 * @summary 质量监控规则分页查询
 *
 * @param request ListDataQualityRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataQualityRulesResponse
 */
async function listDataQualityRulesWithOptions(request: ListDataQualityRulesRequest, runtime: Util.RuntimeOptions): ListDataQualityRulesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDataQualityRules',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 质量监控规则分页查询
 *
 * @param request ListDataQualityRulesRequest
 * @return ListDataQualityRulesResponse
 */
async function listDataQualityRules(request: ListDataQualityRulesRequest): ListDataQualityRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataQualityRulesWithOptions(request, runtime);
}

model ListDataServiceApisRequest {
  apiNameKeyword?: string(name='ApiNameKeyword'),
  apiPathKeyword?: string(name='ApiPathKeyword'),
  creatorId?: string(name='CreatorId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  tenantId?: long(name='TenantId', description='This parameter is required.'),
}

model ListDataServiceApisResponseBody = {
  data?: {
    apis?: [ 
      {
        apiId?: long(name='ApiId'),
        apiMode?: int32(name='ApiMode'),
        apiName?: string(name='ApiName'),
        apiPath?: string(name='ApiPath'),
        createdTime?: string(name='CreatedTime'),
        creatorId?: string(name='CreatorId'),
        description?: string(name='Description'),
        folderId?: long(name='FolderId'),
        groupId?: string(name='GroupId'),
        modifiedTime?: string(name='ModifiedTime'),
        operatorId?: string(name='OperatorId'),
        projectId?: long(name='ProjectId'),
        protocols?: [ int32 ](name='Protocols'),
        registrationDetails?: {
          failedResultSample?: string(name='FailedResultSample'),
          registrationErrorCodes?: [ 
            {
              errorCode?: string(name='ErrorCode'),
              errorMessage?: string(name='ErrorMessage'),
              errorSolution?: string(name='ErrorSolution'),
            }
          ](name='RegistrationErrorCodes'),
          registrationRequestParameters?: [ 
            {
              columnName?: string(name='ColumnName'),
              defaultValue?: string(name='DefaultValue'),
              exampleValue?: string(name='ExampleValue'),
              isRequiredParameter?: boolean(name='IsRequiredParameter'),
              parameterDataType?: int32(name='ParameterDataType'),
              parameterDescription?: string(name='ParameterDescription'),
              parameterName?: string(name='ParameterName'),
              parameterOperator?: int32(name='ParameterOperator'),
              parameterPosition?: int32(name='ParameterPosition'),
            }
          ](name='RegistrationRequestParameters'),
          serviceContentType?: int32(name='ServiceContentType'),
          serviceHost?: string(name='ServiceHost'),
          servicePath?: string(name='ServicePath'),
          serviceRequestBodyDescription?: string(name='ServiceRequestBodyDescription'),
          successfulResultSample?: string(name='SuccessfulResultSample'),
        }(name='RegistrationDetails'),
        requestMethod?: int32(name='RequestMethod'),
        responseContentType?: int32(name='ResponseContentType'),
        scriptDetails?: {
          isPagedResponse?: boolean(name='IsPagedResponse'),
          script?: string(name='Script'),
          scriptConnection?: {
            connectionId?: long(name='ConnectionId'),
            tableName?: string(name='TableName'),
          }(name='ScriptConnection'),
          scriptRequestParameters?: [ 
            {
              columnName?: string(name='ColumnName'),
              defaultValue?: string(name='DefaultValue'),
              exampleValue?: string(name='ExampleValue'),
              isRequiredParameter?: boolean(name='IsRequiredParameter'),
              parameterDataType?: int32(name='ParameterDataType'),
              parameterDescription?: string(name='ParameterDescription'),
              parameterName?: string(name='ParameterName'),
              parameterOperator?: int32(name='ParameterOperator'),
              parameterPosition?: int32(name='ParameterPosition'),
            }
          ](name='ScriptRequestParameters'),
          scriptResponseParameters?: [ 
            {
              columnName?: string(name='ColumnName'),
              exampleValue?: string(name='ExampleValue'),
              parameterDataType?: int32(name='ParameterDataType'),
              parameterDescription?: string(name='ParameterDescription'),
              parameterName?: string(name='ParameterName'),
            }
          ](name='ScriptResponseParameters'),
        }(name='ScriptDetails'),
        status?: int32(name='Status'),
        tenantId?: long(name='TenantId'),
        timeout?: int32(name='Timeout'),
        visibleRange?: int32(name='VisibleRange'),
        wizardDetails?: {
          isPagedResponse?: boolean(name='IsPagedResponse'),
          wizardConnection?: {
            connectionId?: long(name='ConnectionId'),
            tableName?: string(name='TableName'),
          }(name='WizardConnection'),
          wizardRequestParameters?: [ 
            {
              columnName?: string(name='ColumnName'),
              defaultValue?: string(name='DefaultValue'),
              exampleValue?: string(name='ExampleValue'),
              isRequiredParameter?: boolean(name='IsRequiredParameter'),
              parameterDataType?: int32(name='ParameterDataType'),
              parameterDescription?: string(name='ParameterDescription'),
              parameterName?: string(name='ParameterName'),
              parameterOperator?: int32(name='ParameterOperator'),
              parameterPosition?: int32(name='ParameterPosition'),
            }
          ](name='WizardRequestParameters'),
          wizardResponseParameters?: [ 
            {
              columnName?: string(name='ColumnName'),
              exampleValue?: string(name='ExampleValue'),
              parameterDataType?: int32(name='ParameterDataType'),
              parameterDescription?: string(name='ParameterDescription'),
              parameterName?: string(name='ParameterName'),
            }
          ](name='WizardResponseParameters'),
        }(name='WizardDetails'),
      }
    ](name='Apis'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDataServiceApisResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataServiceApisResponseBody(name='body'),
}

/**
 * @param request ListDataServiceApisRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataServiceApisResponse
 */
async function listDataServiceApisWithOptions(request: ListDataServiceApisRequest, runtime: Util.RuntimeOptions): ListDataServiceApisResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apiNameKeyword)) {
    body['ApiNameKeyword'] = request.apiNameKeyword;
  }
  if (!Util.isUnset(request.apiPathKeyword)) {
    body['ApiPathKeyword'] = request.apiPathKeyword;
  }
  if (!Util.isUnset(request.creatorId)) {
    body['CreatorId'] = request.creatorId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDataServiceApis',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListDataServiceApisRequest
 * @return ListDataServiceApisResponse
 */
async function listDataServiceApis(request: ListDataServiceApisRequest): ListDataServiceApisResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServiceApisWithOptions(request, runtime);
}

model ListDataSourcesRequest {
  dataSourceType?: string(name='DataSourceType'),
  envType?: int32(name='EnvType'),
  name?: string(name='Name'),
  operator?: string(name='Operator'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  status?: string(name='Status'),
  subType?: string(name='SubType'),
}

model ListDataSourcesResponseBody = {
  data?: {
    dataSources?: [ 
      {
        bindingCalcEngineId?: int32(name='BindingCalcEngineId'),
        connectStatus?: int32(name='ConnectStatus'),
        content?: string(name='Content'),
        dataSourceType?: string(name='DataSourceType'),
        defaultEngine?: boolean(name='DefaultEngine'),
        description?: string(name='Description'),
        envType?: int32(name='EnvType'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: int32(name='Id'),
        name?: string(name='Name'),
        operator?: string(name='Operator'),
        projectId?: int32(name='ProjectId'),
        sequence?: int32(name='Sequence'),
        shared?: boolean(name='Shared'),
        status?: int32(name='Status'),
        subType?: string(name='SubType'),
        tenantId?: long(name='TenantId'),
      }
    ](name='DataSources'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDataSourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataSourcesResponseBody(name='body'),
}

/**
 * @param request ListDataSourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataSourcesResponse
 */
async function listDataSourcesWithOptions(request: ListDataSourcesRequest, runtime: Util.RuntimeOptions): ListDataSourcesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDataSources',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListDataSourcesRequest
 * @return ListDataSourcesResponse
 */
async function listDataSources(request: ListDataSourcesRequest): ListDataSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataSourcesWithOptions(request, runtime);
}

model ListDeploymentPipelinesRequest {
  creator?: string(name='Creator'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  status?: string(name='Status'),
}

model ListDeploymentPipelinesResponseBody = {
  pagingInfo?: {
    deployments?: [ 
      {
        createTime?: long(name='CreateTime', description='发布包创建时间戳'),
        creator?: string(name='Creator', description='创建人'),
        id?: string(name='Id', description='发布流程Id'),
        message?: string(name='Message'),
        modifyTime?: long(name='ModifyTime', description='修改时间'),
        projectId?: long(name='ProjectId', description='项目Id'),
        stages?: [ 
          {
            code?: string(name='Code', description='阶段代号'),
            description?: string(name='Description', description='阶段描述'),
            detail?: map[string]any(name='Detail', description='阶段详细信息'),
            message?: string(name='Message', description='阶段信息'),
            name?: string(name='Name', description='阶段名称'),
            status?: string(name='Status', description='阶段状态'),
            step?: int32(name='Step', description='步骤'),
            type?: string(name='Type', description='阶段类型'),
          }
        ](name='Stages', description='步骤详情'),
        status?: string(name='Status', description='发布流程状态'),
      }
    ](name='Deployments'),
    pageNumber?: string(name='PageNumber'),
    pageSize?: string(name='PageSize'),
    totalCount?: string(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListDeploymentPipelinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDeploymentPipelinesResponseBody(name='body'),
}

/**
 * @summary 分页获取发布流程
 *
 * @param request ListDeploymentPipelinesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDeploymentPipelinesResponse
 */
async function listDeploymentPipelinesWithOptions(request: ListDeploymentPipelinesRequest, runtime: Util.RuntimeOptions): ListDeploymentPipelinesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeploymentPipelines',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 分页获取发布流程
 *
 * @param request ListDeploymentPipelinesRequest
 * @return ListDeploymentPipelinesResponse
 */
async function listDeploymentPipelines(request: ListDeploymentPipelinesRequest): ListDeploymentPipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDeploymentPipelinesWithOptions(request, runtime);
}

model ListDeploymentsRequest {
  creator?: string(name='Creator'),
  endCreateTime?: long(name='EndCreateTime'),
  endExecuteTime?: long(name='EndExecuteTime'),
  executor?: string(name='Executor'),
  keyword?: string(name='Keyword'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  status?: int32(name='Status'),
}

model ListDeploymentsResponseBody = {
  data?: {
    deployments?: [ 
      {
        createTime?: long(name='CreateTime'),
        creator?: string(name='Creator'),
        errorMessage?: string(name='ErrorMessage'),
        executeTime?: long(name='ExecuteTime'),
        executor?: string(name='Executor'),
        id?: long(name='Id'),
        name?: string(name='Name'),
        status?: int32(name='Status'),
      }
    ](name='Deployments'),
    pageNumber?: long(name='PageNumber'),
    pageSize?: long(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListDeploymentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDeploymentsResponseBody(name='body'),
}

/**
 * @summary 查询发布包列表
 *
 * @param request ListDeploymentsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDeploymentsResponse
 */
async function listDeploymentsWithOptions(request: ListDeploymentsRequest, runtime: Util.RuntimeOptions): ListDeploymentsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.creator)) {
    body['Creator'] = request.creator;
  }
  if (!Util.isUnset(request.endCreateTime)) {
    body['EndCreateTime'] = request.endCreateTime;
  }
  if (!Util.isUnset(request.endExecuteTime)) {
    body['EndExecuteTime'] = request.endExecuteTime;
  }
  if (!Util.isUnset(request.executor)) {
    body['Executor'] = request.executor;
  }
  if (!Util.isUnset(request.keyword)) {
    body['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDeployments',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询发布包列表
 *
 * @param request ListDeploymentsRequest
 * @return ListDeploymentsResponse
 */
async function listDeployments(request: ListDeploymentsRequest): ListDeploymentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDeploymentsWithOptions(request, runtime);
}

model ListDownstreamTaskInstancesRequest {
  id?: long(name='Id', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListDownstreamTaskInstancesResponseBody = {
  pagingInfo?: {
    downstreamTaskInstances?: [ 
      {
        dependencyType?: string(name='DependencyType'),
        taskInstance?: {
          baselineId?: long(name='BaselineId'),
          bizdate?: long(name='Bizdate'),
          createTime?: long(name='CreateTime'),
          createUser?: string(name='CreateUser'),
          dataSource?: {
            name?: string(name='Name'),
          }(name='DataSource'),
          description?: string(name='Description'),
          envType?: string(name='EnvType'),
          finishedTime?: long(name='FinishedTime'),
          id?: long(name='Id'),
          modifyTime?: long(name='ModifyTime'),
          modifyUser?: string(name='ModifyUser'),
          owner?: string(name='Owner'),
          periodNumber?: int32(name='PeriodNumber'),
          priority?: int32(name='Priority'),
          projectId?: long(name='ProjectId'),
          rerunMode?: string(name='RerunMode'),
          runNumber?: int32(name='RunNumber'),
          runtime?: {
            gateway?: string(name='Gateway'),
            processId?: string(name='ProcessId'),
          }(name='Runtime'),
          runtimeResource?: {
            cu?: string(name='Cu'),
            image?: string(name='Image'),
            resourceGroupId?: string(name='ResourceGroupId'),
          }(name='RuntimeResource'),
          startedTime?: long(name='StartedTime'),
          status?: string(name='Status'),
          taskId?: long(name='TaskId'),
          taskName?: string(name='TaskName'),
          taskType?: string(name='TaskType'),
          tenantId?: long(name='TenantId'),
          timeout?: int32(name='Timeout'),
          triggerRecurrence?: string(name='TriggerRecurrence'),
          triggerTime?: long(name='TriggerTime'),
          triggerType?: string(name='TriggerType'),
          waitingResourceTime?: long(name='WaitingResourceTime'),
          waitingTriggerTime?: long(name='WaitingTriggerTime'),
          workflowId?: long(name='WorkflowId'),
          workflowInstanceId?: long(name='WorkflowInstanceId'),
          workflowInstanceType?: string(name='WorkflowInstanceType'),
          workflowName?: string(name='WorkflowName'),
        }(name='TaskInstance'),
      }
    ](name='DownstreamTaskInstances'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListDownstreamTaskInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDownstreamTaskInstancesResponseBody(name='body'),
}

/**
 * @param request ListDownstreamTaskInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDownstreamTaskInstancesResponse
 */
async function listDownstreamTaskInstancesWithOptions(request: ListDownstreamTaskInstancesRequest, runtime: Util.RuntimeOptions): ListDownstreamTaskInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDownstreamTaskInstances',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListDownstreamTaskInstancesRequest
 * @return ListDownstreamTaskInstancesResponse
 */
async function listDownstreamTaskInstances(request: ListDownstreamTaskInstancesRequest): ListDownstreamTaskInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDownstreamTaskInstancesWithOptions(request, runtime);
}

model ListDownstreamTasksRequest {
  envType?: string(name='EnvType'),
  id?: long(name='Id', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListDownstreamTasksResponseBody = {
  pagingInfo?: {
    downstreamTasks?: [ 
      {
        dependencyType?: string(name='DependencyType'),
        task?: {
          baselineId?: long(name='BaselineId'),
          createTime?: long(name='CreateTime'),
          createUser?: string(name='CreateUser'),
          dataSource?: {
            name?: string(name='Name'),
          }(name='DataSource'),
          description?: string(name='Description'),
          envType?: string(name='EnvType'),
          id?: long(name='Id'),
          instanceMode?: string(name='InstanceMode'),
          modifyTime?: long(name='ModifyTime'),
          modifyUser?: string(name='ModifyUser'),
          name?: string(name='Name'),
          owner?: string(name='Owner'),
          priority?: int32(name='Priority'),
          projectId?: long(name='ProjectId'),
          rerunInterval?: int32(name='RerunInterval'),
          rerunMode?: string(name='RerunMode'),
          rerunTimes?: int32(name='RerunTimes'),
          runtimeResource?: {
            cu?: string(name='Cu'),
            image?: string(name='Image'),
            resourceGroupId?: string(name='ResourceGroupId'),
          }(name='RuntimeResource'),
          tenantId?: long(name='TenantId'),
          timeout?: int32(name='Timeout'),
          trigger?: {
            cron?: string(name='Cron'),
            endTime?: string(name='EndTime'),
            recurrence?: string(name='Recurrence'),
            startTime?: string(name='StartTime'),
            timezone?: string(name='Timezone'),
            type?: string(name='Type'),
          }(name='Trigger'),
          type?: string(name='Type'),
          workflowId?: long(name='WorkflowId'),
        }(name='Task'),
      }
    ](name='DownstreamTasks'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListDownstreamTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDownstreamTasksResponseBody(name='body'),
}

/**
 * @param request ListDownstreamTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDownstreamTasksResponse
 */
async function listDownstreamTasksWithOptions(request: ListDownstreamTasksRequest, runtime: Util.RuntimeOptions): ListDownstreamTasksResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDownstreamTasks',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListDownstreamTasksRequest
 * @return ListDownstreamTasksResponse
 */
async function listDownstreamTasks(request: ListDownstreamTasksRequest): ListDownstreamTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDownstreamTasksWithOptions(request, runtime);
}

model ListEnabledExtensionProjectsRequest {
  extensionCode?: string(name='ExtensionCode'),
}

model ListEnabledExtensionProjectsResponseBody = {
  requestId?: string(name='RequestId'),
  projectIds?: [ long ](name='projectIds'),
}

model ListEnabledExtensionProjectsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEnabledExtensionProjectsResponseBody(name='body'),
}

/**
 * @summary 查询扩展程序开启的项目空间列表
 *
 * @param request ListEnabledExtensionProjectsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListEnabledExtensionProjectsResponse
 */
async function listEnabledExtensionProjectsWithOptions(request: ListEnabledExtensionProjectsRequest, runtime: Util.RuntimeOptions): ListEnabledExtensionProjectsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.extensionCode)) {
    query['ExtensionCode'] = request.extensionCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEnabledExtensionProjects',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询扩展程序开启的项目空间列表
 *
 * @param request ListEnabledExtensionProjectsRequest
 * @return ListEnabledExtensionProjectsResponse
 */
async function listEnabledExtensionProjects(request: ListEnabledExtensionProjectsRequest): ListEnabledExtensionProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEnabledExtensionProjectsWithOptions(request, runtime);
}

model ListEnabledExtensionsForProjectRequest {
  eventCode?: string(name='EventCode', description='This parameter is required.'),
  fileType?: string(name='FileType'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model ListEnabledExtensionsForProjectResponseBody = {
  extensions?: [ 
    {
      createUser?: string(name='CreateUser'),
      extensionCode?: string(name='ExtensionCode'),
      extensionDesc?: string(name='ExtensionDesc'),
      extensionName?: string(name='ExtensionName'),
      modifyUser?: string(name='ModifyUser'),
      owner?: string(name='Owner'),
      parameterSetting?: string(name='ParameterSetting'),
      tenantId?: long(name='TenantId'),
    }
  ](name='Extensions'),
  requestId?: string(name='RequestId'),
}

model ListEnabledExtensionsForProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEnabledExtensionsForProjectResponseBody(name='body'),
}

/**
 * @summary 调用ListEnabledExtensionsForProject来获取项目空间下已经开启的扩展程序列表，包含系统扩展程序和自定义扩展程序
 *
 * @param request ListEnabledExtensionsForProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListEnabledExtensionsForProjectResponse
 */
async function listEnabledExtensionsForProjectWithOptions(request: ListEnabledExtensionsForProjectRequest, runtime: Util.RuntimeOptions): ListEnabledExtensionsForProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventCode)) {
    body['EventCode'] = request.eventCode;
  }
  if (!Util.isUnset(request.fileType)) {
    body['FileType'] = request.fileType;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListEnabledExtensionsForProject',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 调用ListEnabledExtensionsForProject来获取项目空间下已经开启的扩展程序列表，包含系统扩展程序和自定义扩展程序
 *
 * @param request ListEnabledExtensionsForProjectRequest
 * @return ListEnabledExtensionsForProjectResponse
 */
async function listEnabledExtensionsForProject(request: ListEnabledExtensionsForProjectRequest): ListEnabledExtensionsForProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEnabledExtensionsForProjectWithOptions(request, runtime);
}

model ListFileVersionsRequest {
  fileId?: long(name='FileId', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model ListFileVersionsResponseBody = {
  data?: {
    fileVersions?: [ 
      {
        changeType?: string(name='ChangeType'),
        comment?: string(name='Comment'),
        commitTime?: long(name='CommitTime'),
        commitUser?: string(name='CommitUser'),
        fileContent?: string(name='FileContent'),
        fileName?: string(name='FileName'),
        filePropertyContent?: string(name='FilePropertyContent'),
        fileVersion?: int32(name='FileVersion'),
        isCurrentProd?: boolean(name='IsCurrentProd'),
        nodeContent?: string(name='NodeContent'),
        nodeId?: long(name='NodeId'),
        status?: string(name='Status'),
        useType?: string(name='UseType'),
      }
    ](name='FileVersions'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListFileVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFileVersionsResponseBody(name='body'),
}

/**
 * @param request ListFileVersionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFileVersionsResponse
 */
async function listFileVersionsWithOptions(request: ListFileVersionsRequest, runtime: Util.RuntimeOptions): ListFileVersionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFileVersions',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListFileVersionsRequest
 * @return ListFileVersionsResponse
 */
async function listFileVersions(request: ListFileVersionsRequest): ListFileVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFileVersionsWithOptions(request, runtime);
}

model ListFilesRequest {
  fileFolderPath?: string(name='FileFolderPath'),
  fileTypes?: string(name='FileTypes'),
  keyword?: string(name='Keyword'),
  nodeId?: long(name='NodeId'),
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  useType?: string(name='UseType'),
}

model ListFilesResponseBody = {
  data?: {
    files?: [ 
      {
        autoParsing?: boolean(name='AutoParsing'),
        bizId?: long(name='BizId'),
        commitStatus?: int32(name='CommitStatus'),
        connectionName?: string(name='ConnectionName'),
        content?: string(name='Content'),
        createTime?: long(name='CreateTime'),
        createUser?: string(name='CreateUser'),
        currentVersion?: int32(name='CurrentVersion'),
        fileDescription?: string(name='FileDescription'),
        fileFolderId?: string(name='FileFolderId'),
        fileId?: long(name='FileId'),
        fileName?: string(name='FileName'),
        fileType?: int32(name='FileType'),
        isMaxCompute?: boolean(name='IsMaxCompute'),
        lastEditTime?: long(name='LastEditTime'),
        lastEditUser?: string(name='LastEditUser'),
        nodeId?: long(name='NodeId'),
        owner?: string(name='Owner'),
        parentId?: long(name='ParentId'),
        useType?: string(name='UseType'),
      }
    ](name='Files'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFilesResponseBody(name='body'),
}

/**
 * @param request ListFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFilesResponse
 */
async function listFilesWithOptions(request: ListFilesRequest, runtime: Util.RuntimeOptions): ListFilesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fileFolderPath)) {
    body['FileFolderPath'] = request.fileFolderPath;
  }
  if (!Util.isUnset(request.fileTypes)) {
    body['FileTypes'] = request.fileTypes;
  }
  if (!Util.isUnset(request.keyword)) {
    body['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  if (!Util.isUnset(request.useType)) {
    body['UseType'] = request.useType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFiles',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListFilesRequest
 * @return ListFilesResponse
 */
async function listFiles(request: ListFilesRequest): ListFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFilesWithOptions(request, runtime);
}

model ListFoldersRequest {
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  parentFolderPath?: string(name='ParentFolderPath', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model ListFoldersResponseBody = {
  data?: {
    folders?: [ 
      {
        folderId?: string(name='FolderId'),
        folderPath?: string(name='FolderPath'),
      }
    ](name='Folders'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListFoldersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFoldersResponseBody(name='body'),
}

/**
 * @param request ListFoldersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFoldersResponse
 */
async function listFoldersWithOptions(request: ListFoldersRequest, runtime: Util.RuntimeOptions): ListFoldersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parentFolderPath)) {
    body['ParentFolderPath'] = request.parentFolderPath;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFolders',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListFoldersRequest
 * @return ListFoldersResponse
 */
async function listFolders(request: ListFoldersRequest): ListFoldersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFoldersWithOptions(request, runtime);
}

model ListFunctionsRequest {
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  type?: string(name='Type'),
}

model ListFunctionsResponseBody = {
  pagingInfo?: {
    functions?: [ 
      {
        armResource?: string(name='ArmResource', description='ARM集群资源文件列表'),
        className?: string(name='ClassName', description='函数实现类名'),
        commandDescription?: string(name='CommandDescription', description='命令描述'),
        createTime?: long(name='CreateTime', description='代表创建时间的资源属性字段'),
        dataSource?: {
          name?: string(name='Name', description='数据源名称'),
          type?: string(name='Type', description='数据源类型'),
        }(name='DataSource', description='函数注册到的数据源信息'),
        databaseName?: string(name='DatabaseName', description='数据库名，可选'),
        description?: string(name='Description', description='对funciotn的描述'),
        embeddedCode?: string(name='EmbeddedCode', description='嵌套函数代码内容'),
        embeddedCodeType?: string(name='EmbeddedCodeType', description='嵌套代码类型'),
        embeddedResourceType?: string(name='EmbeddedResourceType', description='嵌套资源类型'),
        exampleDescription?: string(name='ExampleDescription', description='示例说明'),
        fileResource?: string(name='FileResource', description='函数的实现代码'),
        id?: long(name='Id', description='代表资源一级ID的资源属性字段'),
        modifyTime?: long(name='ModifyTime', description='修改时间'),
        name?: string(name='Name', description='代表资源名称的资源属性字段'),
        owner?: string(name='Owner', description='函数责任人'),
        parameterDescription?: string(name='ParameterDescription', description='命令描述'),
        projectId?: long(name='ProjectId', description='项目Id'),
        returnValueDescription?: string(name='ReturnValueDescription', description='返回值说明'),
        runtimeResource?: {
          resourceGroupId?: string(name='ResourceGroupId', description='运行时资源组Id'),
        }(name='RuntimeResource', description='运行时资源组信息'),
        script?: {
          id?: long(name='Id', description='脚本的id'),
          path?: string(name='Path', description='脚本路径'),
          runtime?: {
            command?: string(name='Command', description='脚本所属类型'),
          }(name='Runtime', description='脚本的运行时信息'),
        }(name='Script', description='工作流的脚本信息'),
        type?: string(name='Type', description='函数类型'),
      }
    ](name='Functions'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListFunctionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionsResponseBody(name='body'),
}

/**
 * @summary 获取udf函数列表
 *
 * @param request ListFunctionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFunctionsResponse
 */
async function listFunctionsWithOptions(request: ListFunctionsRequest, runtime: Util.RuntimeOptions): ListFunctionsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctions',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取udf函数列表
 *
 * @param request ListFunctionsRequest
 * @return ListFunctionsResponse
 */
async function listFunctions(request: ListFunctionsRequest): ListFunctionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFunctionsWithOptions(request, runtime);
}

model ListIdeNodesRequest {
  containerId?: string(name='ContainerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  recurrence?: string(name='Recurrence'),
  rerunMode?: string(name='RerunMode'),
  scene?: string(name='Scene'),
}

model ListIdeNodesResponseBody = {
  pagingInfo?: {
    nodes?: [ 
      {
        createTime?: long(name='CreateTime', description='节点的创建时间'),
        dataSource?: {
          name?: string(name='Name', description='数据源名称'),
          type?: string(name='Type', description='数据源类型'),
        }(name='DataSource', description='数据源信息'),
        description?: string(name='Description', description='描述'),
        id?: long(name='Id'),
        inputs?: {
          nodeOutputs?: [ 
            {
              data?: string(name='Data', description='节点输出'),
            }
          ](name='NodeOutputs', description='节点输出列表'),
          tables?: [ 
            {
              guid?: string(name='Guid', description='表id'),
            }
          ](name='Tables', description='表列表'),
          variables?: [ 
            {
              artifactType?: string(name='ArtifactType', description='制品类型'),
              id?: long(name='Id', description='变量id'),
              name?: string(name='Name', description='变量名'),
              node?: {
                output?: string(name='Output', description='节点输出'),
              }(name='Node', description='变量所属节点'),
              scope?: string(name='Scope', description='范围'),
              type?: string(name='Type', description='类型'),
              value?: string(name='Value', description='变量值'),
            }
          ](name='Variables', description='变量列表'),
        }(name='Inputs', description='节点输入'),
        modifyTime?: long(name='ModifyTime', description='属性修改时间'),
        name?: string(name='Name', description='节点名'),
        outputs?: {
          nodeOutputs?: [ 
            {
              data?: string(name='Data', description='节点输出'),
            }
          ](name='NodeOutputs', description='节点输出列表'),
          tables?: [ 
            {
              guid?: string(name='Guid', description='表id'),
            }
          ](name='Tables', description='表列表'),
          variables?: [ 
            {
              artifactType?: string(name='ArtifactType', description='制品类型'),
              id?: long(name='Id', description='变量id'),
              name?: string(name='Name', description='变量名'),
              node?: {
                output?: string(name='Output', description='节点输出'),
              }(name='Node', description='变量所属节点'),
              scope?: string(name='Scope', description='范围'),
              type?: string(name='Type', description='类型'),
              value?: string(name='Value', description='变量值'),
            }
          ](name='Variables', description='变量列表'),
        }(name='Outputs', description='节点输出'),
        owner?: string(name='Owner', description='节点的责任人'),
        projectId?: long(name='ProjectId'),
        recurrence?: string(name='Recurrence'),
        runtimeResource?: {
          resourceGroupId?: string(name='ResourceGroupId', description='资源组id'),
        }(name='RuntimeResource', description='资源组信息'),
        script?: {
          id?: long(name='Id', description='脚本的id'),
          path?: string(name='Path', description='脚本路径'),
          runtime?: {
            command?: string(name='Command', description='脚本所属类型'),
          }(name='Runtime', description='脚本的运行时信息'),
        }(name='Script', description='工作流的脚本信息'),
        strategy?: {
          instanceMode?: string(name='InstanceMode', description='生成实例的模式'),
          rerunInterval?: int32(name='RerunInterval', description='重试时间间隔'),
          rerunMode?: string(name='RerunMode', description='允许重跑的模式'),
          rerunTimes?: int32(name='RerunTimes', description='重试次数'),
          timeout?: int32(name='Timeout', description='超时时间'),
        }(name='Strategy', description='调度策略'),
        tags?: [ 
          {
            key?: string(name='Key', description='标签键'),
            value?: string(name='Value', description='标签值'),
          }
        ](name='Tags', description='标签信息'),
        taskId?: long(name='TaskId', description='调度任务Id'),
        trigger?: {
          cron?: string(name='Cron', description='触发器的cron表达式'),
          endTime?: string(name='EndTime', description='结束时间，格式为yyyy-MM-dd HH:mm:ss'),
          id?: long(name='Id', description='触发器id'),
          startTime?: string(name='StartTime', description='开始时间，格式为yyyy-MM-dd HH:mm:ss'),
          timezone?: string(name='Timezone', description='时区'),
          type?: string(name='Type', description='触发器类型'),
        }(name='Trigger', description='触发器信息'),
      }
    ](name='Nodes'),
    pageNumber?: string(name='PageNumber'),
    pageSize?: string(name='PageSize'),
    totalCount?: string(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListIdeNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListIdeNodesResponseBody(name='body'),
}

/**
 * @summary 获取节点列表
 *
 * @param request ListIdeNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListIdeNodesResponse
 */
async function listIdeNodesWithOptions(request: ListIdeNodesRequest, runtime: Util.RuntimeOptions): ListIdeNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIdeNodes',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取节点列表
 *
 * @param request ListIdeNodesRequest
 * @return ListIdeNodesResponse
 */
async function listIdeNodes(request: ListIdeNodesRequest): ListIdeNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIdeNodesWithOptions(request, runtime);
}

model ListInstancesRequest {
  beginBizdate?: string(name='BeginBizdate'),
  bizName?: string(name='BizName'),
  bizdate?: string(name='Bizdate'),
  dagId?: long(name='DagId'),
  endBizdate?: string(name='EndBizdate'),
  nodeId?: long(name='NodeId'),
  nodeName?: string(name='NodeName'),
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  programType?: string(name='ProgramType'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  status?: string(name='Status'),
}

model ListInstancesResponseBody = {
  data?: {
    instances?: [ 
      {
        baselineId?: long(name='BaselineId'),
        beginRunningTime?: long(name='BeginRunningTime'),
        beginWaitResTime?: long(name='BeginWaitResTime'),
        beginWaitTimeTime?: long(name='BeginWaitTimeTime'),
        bizdate?: long(name='Bizdate'),
        connection?: string(name='Connection'),
        createTime?: long(name='CreateTime'),
        cycTime?: long(name='CycTime'),
        dagId?: long(name='DagId'),
        dagType?: string(name='DagType'),
        dqcDescription?: string(name='DqcDescription'),
        dqcType?: int32(name='DqcType'),
        errorMessage?: string(name='ErrorMessage'),
        finishTime?: long(name='FinishTime'),
        instanceId?: long(name='InstanceId'),
        modifyTime?: long(name='ModifyTime'),
        nodeId?: int32(name='NodeId'),
        nodeName?: string(name='NodeName'),
        paramValues?: string(name='ParamValues'),
        priority?: int32(name='Priority'),
        relatedFlowId?: long(name='RelatedFlowId'),
        repeatInterval?: long(name='RepeatInterval'),
        repeatability?: boolean(name='Repeatability'),
        status?: string(name='Status'),
        taskRerunTime?: int32(name='TaskRerunTime'),
        taskType?: string(name='TaskType'),
      }
    ](name='Instances'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstancesResponseBody(name='body'),
}

/**
 * @param request ListInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstancesResponse
 */
async function listInstancesWithOptions(request: ListInstancesRequest, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.beginBizdate)) {
    body['BeginBizdate'] = request.beginBizdate;
  }
  if (!Util.isUnset(request.bizName)) {
    body['BizName'] = request.bizName;
  }
  if (!Util.isUnset(request.bizdate)) {
    body['Bizdate'] = request.bizdate;
  }
  if (!Util.isUnset(request.dagId)) {
    body['DagId'] = request.dagId;
  }
  if (!Util.isUnset(request.endBizdate)) {
    body['EndBizdate'] = request.endBizdate;
  }
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.nodeName)) {
    body['NodeName'] = request.nodeName;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.programType)) {
    body['ProgramType'] = request.programType;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListInstancesRequest
 * @return ListInstancesResponse
 */
async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstancesWithOptions(request, runtime);
}

model ListMetaCollectionEntitiesRequest {
  collectionQualifiedName?: string(name='CollectionQualifiedName', description='This parameter is required.'),
  entityType?: string(name='EntityType'),
  keyword?: string(name='Keyword'),
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize'),
}

model ListMetaCollectionEntitiesResponseBody = {
  data?: {
    entityList?: [
      Entity
    ](name='EntityList'),
    nextToken?: string(name='NextToken'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListMetaCollectionEntitiesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMetaCollectionEntitiesResponseBody(name='body'),
}

/**
 * @summary List entities in collection
 *
 * @param request ListMetaCollectionEntitiesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMetaCollectionEntitiesResponse
 */
async function listMetaCollectionEntitiesWithOptions(request: ListMetaCollectionEntitiesRequest, runtime: Util.RuntimeOptions): ListMetaCollectionEntitiesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.collectionQualifiedName)) {
    query['CollectionQualifiedName'] = request.collectionQualifiedName;
  }
  if (!Util.isUnset(request.entityType)) {
    query['EntityType'] = request.entityType;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMetaCollectionEntities',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary List entities in collection
 *
 * @param request ListMetaCollectionEntitiesRequest
 * @return ListMetaCollectionEntitiesResponse
 */
async function listMetaCollectionEntities(request: ListMetaCollectionEntitiesRequest): ListMetaCollectionEntitiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMetaCollectionEntitiesWithOptions(request, runtime);
}

model ListMetaCollectionsRequest {
  administrator?: string(name='Administrator'),
  collectionType?: string(name='CollectionType', description='This parameter is required.'),
  creator?: string(name='Creator'),
  follower?: string(name='Follower'),
  keyword?: string(name='Keyword'),
  nextToken?: string(name='NextToken'),
  orderBy?: string(name='OrderBy'),
  pageSize?: int32(name='PageSize'),
  parentQualifiedName?: string(name='ParentQualifiedName'),
}

model ListMetaCollectionsResponseBody = {
  data?: {
    collectionList?: [
      Collection
    ](name='CollectionList'),
    nextToken?: string(name='NextToken'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListMetaCollectionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMetaCollectionsResponseBody(name='body'),
}

/**
 * @param request ListMetaCollectionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMetaCollectionsResponse
 */
async function listMetaCollectionsWithOptions(request: ListMetaCollectionsRequest, runtime: Util.RuntimeOptions): ListMetaCollectionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.administrator)) {
    query['Administrator'] = request.administrator;
  }
  if (!Util.isUnset(request.collectionType)) {
    query['CollectionType'] = request.collectionType;
  }
  if (!Util.isUnset(request.creator)) {
    query['Creator'] = request.creator;
  }
  if (!Util.isUnset(request.follower)) {
    query['Follower'] = request.follower;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parentQualifiedName)) {
    query['ParentQualifiedName'] = request.parentQualifiedName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMetaCollections',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMetaCollectionsRequest
 * @return ListMetaCollectionsResponse
 */
async function listMetaCollections(request: ListMetaCollectionsRequest): ListMetaCollectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMetaCollectionsWithOptions(request, runtime);
}

model ListNodeDependenciesRequest {
  id?: long(name='Id', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model ListNodeDependenciesResponseBody = {
  pagingInfo?: {
    nodes?: [ 
      {
        createTime?: long(name='CreateTime', description='节点的创建时间'),
        dataSource?: {
          name?: string(name='Name', description='数据源名称'),
          type?: string(name='Type', description='数据源类型'),
        }(name='DataSource', description='数据源信息'),
        description?: string(name='Description', description='描述'),
        id?: long(name='Id'),
        inputs?: {
          nodeOutputs?: [ 
            {
              data?: string(name='Data', description='节点输出'),
            }
          ](name='NodeOutputs', description='节点输出列表'),
          tables?: [ 
            {
              guid?: string(name='Guid', description='表id'),
            }
          ](name='Tables', description='表列表'),
          variables?: [ 
            {
              artifactType?: string(name='ArtifactType', description='制品类型'),
              id?: long(name='Id', description='变量id'),
              name?: string(name='Name', description='变量名'),
              node?: {
                output?: string(name='Output', description='节点输出'),
              }(name='Node', description='变量所属节点'),
              scope?: string(name='Scope', description='范围'),
              type?: string(name='Type', description='类型'),
              value?: string(name='Value', description='变量值'),
            }
          ](name='Variables', description='变量列表'),
        }(name='Inputs', description='节点输入'),
        modifyTime?: long(name='ModifyTime', description='属性修改时间'),
        name?: string(name='Name', description='节点名'),
        outputs?: {
          nodeOutputs?: [ 
            {
              data?: string(name='Data', description='节点输出'),
            }
          ](name='NodeOutputs', description='节点输出列表'),
          tables?: [ 
            {
              guid?: string(name='Guid', description='表id'),
            }
          ](name='Tables', description='表列表'),
          variables?: [ 
            {
              artifactType?: string(name='ArtifactType', description='制品类型'),
              id?: long(name='Id', description='变量id'),
              name?: string(name='Name', description='变量名'),
              node?: {
                output?: string(name='Output', description='节点输出'),
              }(name='Node', description='变量所属节点'),
              scope?: string(name='Scope', description='范围'),
              type?: string(name='Type', description='类型'),
              value?: string(name='Value', description='变量值'),
            }
          ](name='Variables', description='变量列表'),
        }(name='Outputs', description='节点输出'),
        owner?: string(name='Owner', description='节点的责任人'),
        projectId?: long(name='ProjectId'),
        recurrence?: string(name='Recurrence'),
        runtimeResource?: {
          resourceGroupId?: string(name='ResourceGroupId', description='资源组id'),
        }(name='RuntimeResource', description='资源组信息'),
        script?: {
          id?: long(name='Id', description='脚本的id'),
          path?: string(name='Path', description='脚本路径'),
          runtime?: {
            command?: string(name='Command', description='脚本所属类型'),
          }(name='Runtime', description='脚本的运行时信息'),
        }(name='Script', description='工作流的脚本信息'),
        strategy?: {
          instanceMode?: string(name='InstanceMode', description='生成实例的模式'),
          rerunInterval?: int32(name='RerunInterval', description='重试时间间隔'),
          rerunMode?: string(name='RerunMode', description='允许重跑的模式'),
          rerunTimes?: int32(name='RerunTimes', description='重试次数'),
          timeout?: int32(name='Timeout', description='超时时间'),
        }(name='Strategy', description='调度策略'),
        tags?: [ 
          {
            key?: string(name='Key', description='标签键'),
            value?: string(name='Value', description='标签值'),
          }
        ](name='Tags', description='标签信息'),
        taskId?: string(name='TaskId', description='调度任务Id'),
        trigger?: {
          cron?: string(name='Cron', description='触发器的cron表达式'),
          endTime?: string(name='EndTime', description='结束时间，格式为yyyy-MM-dd HH:mm:ss'),
          id?: long(name='Id', description='触发器id'),
          startTime?: string(name='StartTime', description='开始时间，格式为yyyy-MM-dd HH:mm:ss'),
          timezone?: string(name='Timezone', description='时区'),
          type?: string(name='Type', description='触发器类型'),
        }(name='Trigger', description='触发器信息'),
      }
    ](name='Nodes'),
    pageNumber?: string(name='PageNumber'),
    pageSize?: string(name='PageSize'),
    totalCount?: string(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListNodeDependenciesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListNodeDependenciesResponseBody(name='body'),
}

/**
 * @summary 获取节点依赖列表
 *
 * @param request ListNodeDependenciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListNodeDependenciesResponse
 */
async function listNodeDependenciesWithOptions(request: ListNodeDependenciesRequest, runtime: Util.RuntimeOptions): ListNodeDependenciesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNodeDependencies',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取节点依赖列表
 *
 * @param request ListNodeDependenciesRequest
 * @return ListNodeDependenciesResponse
 */
async function listNodeDependencies(request: ListNodeDependenciesRequest): ListNodeDependenciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodeDependenciesWithOptions(request, runtime);
}

model ListNodeIORequest {
  ioType?: string(name='IoType', description='This parameter is required.'),
  nodeId?: long(name='NodeId', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
}

model ListNodeIOResponseBody = {
  data?: [ 
    {
      data?: string(name='Data'),
      nodeId?: long(name='NodeId'),
      tableName?: string(name='TableName'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model ListNodeIOResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListNodeIOResponseBody(name='body'),
}

/**
 * @param request ListNodeIORequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListNodeIOResponse
 */
async function listNodeIOWithOptions(request: ListNodeIORequest, runtime: Util.RuntimeOptions): ListNodeIOResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ioType)) {
    body['IoType'] = request.ioType;
  }
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListNodeIO',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListNodeIORequest
 * @return ListNodeIOResponse
 */
async function listNodeIO(request: ListNodeIORequest): ListNodeIOResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodeIOWithOptions(request, runtime);
}

model ListNodesRequest {
  bizName?: string(name='BizName'),
  nodeName?: string(name='NodeName'),
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  programType?: string(name='ProgramType'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model ListNodesResponseBody = {
  data?: {
    nodes?: [ 
      {
        baselineId?: long(name='BaselineId'),
        connection?: string(name='Connection'),
        cronExpress?: string(name='CronExpress'),
        description?: string(name='Description'),
        dqcDescription?: string(name='DqcDescription'),
        dqcType?: int32(name='DqcType'),
        nodeId?: long(name='NodeId'),
        nodeName?: string(name='NodeName'),
        ownerId?: string(name='OwnerId'),
        paramValues?: string(name='ParamValues'),
        priority?: int32(name='Priority'),
        programType?: string(name='ProgramType'),
        projectId?: long(name='ProjectId'),
        quota?: string(name='Quota'),
        relatedFlowId?: long(name='RelatedFlowId'),
        repeatInterval?: long(name='RepeatInterval'),
        repeatability?: boolean(name='Repeatability'),
        resGroupName?: string(name='ResGroupName'),
        schedulerType?: string(name='SchedulerType'),
      }
    ](name='Nodes'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListNodesResponseBody(name='body'),
}

/**
 * @param request ListNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListNodesResponse
 */
async function listNodesWithOptions(request: ListNodesRequest, runtime: Util.RuntimeOptions): ListNodesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizName)) {
    body['BizName'] = request.bizName;
  }
  if (!Util.isUnset(request.nodeName)) {
    body['NodeName'] = request.nodeName;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.programType)) {
    body['ProgramType'] = request.programType;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListNodes',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListNodesRequest
 * @return ListNodesResponse
 */
async function listNodes(request: ListNodesRequest): ListNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodesWithOptions(request, runtime);
}

model ListProgramTypeCountRequest {
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model ListProgramTypeCountResponseBody = {
  programTypeAndCounts?: [ 
    {
      count?: int32(name='Count'),
      programType?: string(name='ProgramType'),
    }
  ](name='ProgramTypeAndCounts'),
  requestId?: string(name='RequestId'),
}

model ListProgramTypeCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProgramTypeCountResponseBody(name='body'),
}

/**
 * @param request ListProgramTypeCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListProgramTypeCountResponse
 */
async function listProgramTypeCountWithOptions(request: ListProgramTypeCountRequest, runtime: Util.RuntimeOptions): ListProgramTypeCountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListProgramTypeCount',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListProgramTypeCountRequest
 * @return ListProgramTypeCountResponse
 */
async function listProgramTypeCount(request: ListProgramTypeCountRequest): ListProgramTypeCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProgramTypeCountWithOptions(request, runtime);
}

model ListProjectMembersRequest {
  operator?: string(name='Operator'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  roleCode?: string(name='RoleCode'),
}

model ListProjectMembersResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    projectMemberList?: [ 
      {
        nick?: string(name='Nick'),
        projectMemberId?: string(name='ProjectMemberId'),
        projectMemberName?: string(name='ProjectMemberName'),
        projectMemberType?: string(name='ProjectMemberType'),
        projectRoleList?: [ 
          {
            projectRoleCode?: string(name='ProjectRoleCode'),
            projectRoleId?: int32(name='ProjectRoleId'),
            projectRoleName?: string(name='ProjectRoleName'),
            projectRoleType?: string(name='ProjectRoleType'),
          }
        ](name='ProjectRoleList'),
        status?: string(name='Status'),
      }
    ](name='ProjectMemberList'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListProjectMembersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProjectMembersResponseBody(name='body'),
}

/**
 * @param request ListProjectMembersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListProjectMembersResponse
 */
async function listProjectMembersWithOptions(request: ListProjectMembersRequest, runtime: Util.RuntimeOptions): ListProjectMembersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.roleCode)) {
    query['RoleCode'] = request.roleCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProjectMembers',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListProjectMembersRequest
 * @return ListProjectMembersResponse
 */
async function listProjectMembers(request: ListProjectMembersRequest): ListProjectMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectMembersWithOptions(request, runtime);
}

model ListProjectRolesRequest {
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model ListProjectRolesResponseBody = {
  projectRoleList?: [ 
    {
      projectRoleCode?: string(name='ProjectRoleCode'),
      projectRoleId?: int32(name='ProjectRoleId'),
      projectRoleName?: string(name='ProjectRoleName'),
      projectRoleType?: string(name='ProjectRoleType'),
    }
  ](name='ProjectRoleList'),
  requestId?: string(name='RequestId'),
}

model ListProjectRolesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProjectRolesResponseBody(name='body'),
}

/**
 * @param request ListProjectRolesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListProjectRolesResponse
 */
async function listProjectRolesWithOptions(request: ListProjectRolesRequest, runtime: Util.RuntimeOptions): ListProjectRolesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProjectRoles',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListProjectRolesRequest
 * @return ListProjectRolesResponse
 */
async function listProjectRoles(request: ListProjectRolesRequest): ListProjectRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectRolesWithOptions(request, runtime);
}

model ListProjectsOfMemberRequest {
  memberBaseId?: string(name='MemberBaseId', description='This parameter is required.'),
  memberRoleCode?: string(name='MemberRoleCode'),
  operator?: string(name='Operator'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListProjectsOfMemberResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: string(name='PageSize'),
    projects?: [ 
      {
        createTime?: long(name='CreateTime'),
        displayName?: string(name='DisplayName'),
        envTypes?: [ string ](name='EnvTypes'),
        isDefault?: boolean(name='IsDefault'),
        projectDesc?: string(name='ProjectDesc'),
        projectId?: long(name='ProjectId'),
        projectMode?: string(name='ProjectMode'),
        projectName?: string(name='ProjectName'),
        projectOwnerBaseId?: string(name='ProjectOwnerBaseId'),
        status?: string(name='Status'),
      }
    ](name='Projects'),
    totalCount?: string(name='TotalCount'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListProjectsOfMemberResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProjectsOfMemberResponseBody(name='body'),
}

/**
 * @summary 查询指定用户所在空间
 *
 * @param request ListProjectsOfMemberRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListProjectsOfMemberResponse
 */
async function listProjectsOfMemberWithOptions(request: ListProjectsOfMemberRequest, runtime: Util.RuntimeOptions): ListProjectsOfMemberResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProjectsOfMember',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询指定用户所在空间
 *
 * @param request ListProjectsOfMemberRequest
 * @return ListProjectsOfMemberResponse
 */
async function listProjectsOfMember(request: ListProjectsOfMemberRequest): ListProjectsOfMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectsOfMemberWithOptions(request, runtime);
}

model ListQualityResultsByEntityRequest {
  endDate?: string(name='EndDate', description='This parameter is required.'),
  entityId?: long(name='EntityId', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
  startDate?: string(name='StartDate', description='This parameter is required.'),
}

model ListQualityResultsByEntityResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    ruleChecks?: [ 
      {
        actualExpression?: string(name='ActualExpression'),
        beginTime?: long(name='BeginTime'),
        bizDate?: long(name='BizDate'),
        blockType?: int32(name='BlockType'),
        checkResult?: int32(name='CheckResult'),
        checkResultStatus?: int32(name='CheckResultStatus'),
        checkerId?: int32(name='CheckerId'),
        checkerName?: string(name='CheckerName'),
        checkerType?: int32(name='CheckerType'),
        comment?: string(name='Comment'),
        criticalThreshold?: float(name='CriticalThreshold'),
        dateType?: string(name='DateType'),
        discreteCheck?: boolean(name='DiscreteCheck'),
        endTime?: long(name='EndTime'),
        entityId?: long(name='EntityId'),
        expectValue?: float(name='ExpectValue'),
        externalId?: string(name='ExternalId'),
        externalType?: string(name='ExternalType'),
        fixedCheck?: boolean(name='FixedCheck'),
        id?: long(name='Id'),
        isPrediction?: boolean(name='IsPrediction'),
        lowerValue?: float(name='LowerValue'),
        matchExpression?: string(name='MatchExpression'),
        methodName?: string(name='MethodName'),
        op?: string(name='Op'),
        projectName?: string(name='ProjectName'),
        property?: string(name='Property'),
        referenceValue?: [ 
          {
            bizDate?: string(name='BizDate'),
            discreteProperty?: string(name='DiscreteProperty'),
            singleCheckResult?: int32(name='SingleCheckResult'),
            threshold?: float(name='Threshold'),
            value?: float(name='Value'),
          }
        ](name='ReferenceValue'),
        resultString?: string(name='ResultString'),
        ruleId?: long(name='RuleId'),
        ruleName?: string(name='RuleName'),
        sampleValue?: [ 
          {
            bizDate?: string(name='BizDate'),
            discreteProperty?: string(name='DiscreteProperty'),
            value?: float(name='Value'),
          }
        ](name='SampleValue'),
        tableName?: string(name='TableName'),
        taskId?: string(name='TaskId'),
        templateId?: int32(name='TemplateId'),
        templateName?: string(name='TemplateName'),
        timeCost?: string(name='TimeCost'),
        trend?: string(name='Trend'),
        upperValue?: float(name='UpperValue'),
        warningThreshold?: float(name='WarningThreshold'),
        whereCondition?: string(name='WhereCondition'),
      }
    ](name='RuleChecks'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListQualityResultsByEntityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQualityResultsByEntityResponseBody(name='body'),
}

/**
 * @param request ListQualityResultsByEntityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQualityResultsByEntityResponse
 */
async function listQualityResultsByEntityWithOptions(request: ListQualityResultsByEntityRequest, runtime: Util.RuntimeOptions): ListQualityResultsByEntityResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endDate)) {
    body['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.entityId)) {
    body['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.startDate)) {
    body['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListQualityResultsByEntity',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListQualityResultsByEntityRequest
 * @return ListQualityResultsByEntityResponse
 */
async function listQualityResultsByEntity(request: ListQualityResultsByEntityRequest): ListQualityResultsByEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQualityResultsByEntityWithOptions(request, runtime);
}

model ListQualityResultsByRuleRequest {
  endDate?: string(name='EndDate', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
  ruleId?: long(name='RuleId', description='This parameter is required.'),
  startDate?: string(name='StartDate', description='This parameter is required.'),
}

model ListQualityResultsByRuleResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    ruleChecks?: [ 
      {
        actualExpression?: string(name='ActualExpression'),
        beginTime?: long(name='BeginTime'),
        bizDate?: long(name='BizDate'),
        blockType?: int32(name='BlockType'),
        checkResult?: int32(name='CheckResult'),
        checkResultStatus?: int32(name='CheckResultStatus'),
        checkerId?: int32(name='CheckerId'),
        checkerName?: string(name='CheckerName'),
        checkerType?: int32(name='CheckerType'),
        comment?: string(name='Comment'),
        criticalThreshold?: float(name='CriticalThreshold'),
        dateType?: string(name='DateType'),
        discreteCheck?: boolean(name='DiscreteCheck'),
        endTime?: long(name='EndTime'),
        entityId?: long(name='EntityId'),
        expectValue?: float(name='ExpectValue'),
        externalId?: string(name='ExternalId'),
        externalType?: string(name='ExternalType'),
        fixedCheck?: boolean(name='FixedCheck'),
        id?: long(name='Id'),
        isPrediction?: boolean(name='IsPrediction'),
        lowerValue?: float(name='LowerValue'),
        matchExpression?: string(name='MatchExpression'),
        methodName?: string(name='MethodName'),
        op?: string(name='Op'),
        projectName?: string(name='ProjectName'),
        property?: string(name='Property'),
        referenceValue?: [ 
          {
            bizDate?: string(name='BizDate'),
            discreteProperty?: string(name='DiscreteProperty'),
            singleCheckResult?: int32(name='SingleCheckResult'),
            threshold?: float(name='Threshold'),
            value?: float(name='Value'),
          }
        ](name='ReferenceValue'),
        resultString?: string(name='ResultString'),
        ruleId?: long(name='RuleId'),
        ruleName?: string(name='RuleName'),
        sampleValue?: [ 
          {
            bizDate?: string(name='BizDate'),
            discreteProperty?: string(name='DiscreteProperty'),
            value?: float(name='Value'),
          }
        ](name='SampleValue'),
        tableName?: string(name='TableName'),
        taskId?: string(name='TaskId'),
        templateId?: int32(name='TemplateId'),
        templateName?: string(name='TemplateName'),
        timeCost?: string(name='TimeCost'),
        trend?: string(name='Trend'),
        upperValue?: float(name='UpperValue'),
        warningThreshold?: float(name='WarningThreshold'),
        whereCondition?: string(name='WhereCondition'),
      }
    ](name='RuleChecks'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListQualityResultsByRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQualityResultsByRuleResponseBody(name='body'),
}

/**
 * @param request ListQualityResultsByRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQualityResultsByRuleResponse
 */
async function listQualityResultsByRuleWithOptions(request: ListQualityResultsByRuleRequest, runtime: Util.RuntimeOptions): ListQualityResultsByRuleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endDate)) {
    body['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.ruleId)) {
    body['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.startDate)) {
    body['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListQualityResultsByRule',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListQualityResultsByRuleRequest
 * @return ListQualityResultsByRuleResponse
 */
async function listQualityResultsByRule(request: ListQualityResultsByRuleRequest): ListQualityResultsByRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQualityResultsByRuleWithOptions(request, runtime);
}

model ListQualityRulesRequest {
  entityId?: long(name='EntityId', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
}

model ListQualityRulesResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    rules?: [ 
      {
        blockType?: int32(name='BlockType'),
        checkerId?: int32(name='CheckerId'),
        comment?: string(name='Comment'),
        criticalThreshold?: string(name='CriticalThreshold'),
        entityId?: long(name='EntityId'),
        expectValue?: string(name='ExpectValue'),
        fixCheck?: boolean(name='FixCheck'),
        historyCriticalThreshold?: string(name='HistoryCriticalThreshold'),
        historyWarningThreshold?: string(name='HistoryWarningThreshold'),
        id?: long(name='Id'),
        matchExpression?: string(name='MatchExpression'),
        methodId?: int32(name='MethodId'),
        methodName?: string(name='MethodName'),
        onDuty?: string(name='OnDuty'),
        onDutyAccountName?: string(name='OnDutyAccountName'),
        predictType?: int32(name='PredictType'),
        projectName?: string(name='ProjectName'),
        property?: string(name='Property'),
        propertyKey?: string(name='PropertyKey'),
        ruleCheckerRelationId?: long(name='RuleCheckerRelationId'),
        ruleName?: string(name='RuleName'),
        ruleType?: int32(name='RuleType'),
        tableName?: string(name='TableName'),
        templateId?: int32(name='TemplateId'),
        templateName?: string(name='TemplateName'),
        trend?: string(name='Trend'),
        warningThreshold?: string(name='WarningThreshold'),
      }
    ](name='Rules'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListQualityRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQualityRulesResponseBody(name='body'),
}

/**
 * @param request ListQualityRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQualityRulesResponse
 */
async function listQualityRulesWithOptions(request: ListQualityRulesRequest, runtime: Util.RuntimeOptions): ListQualityRulesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.entityId)) {
    body['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListQualityRules',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListQualityRulesRequest
 * @return ListQualityRulesResponse
 */
async function listQualityRules(request: ListQualityRulesRequest): ListQualityRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQualityRulesWithOptions(request, runtime);
}

model ListRelatedTopicsRequest {
  baselineId?: long(name='BaselineId', description='This parameter is required.'),
  bizdate?: string(name='Bizdate', description='This parameter is required.'),
  inGroupId?: int32(name='InGroupId', description='This parameter is required.'),
  topicStatuses?: string(name='TopicStatuses'),
}

model ListRelatedTopicsResponseBody = {
  relatedTopics?: [ 
    {
      addTime?: long(name='AddTime'),
      fixTime?: long(name='FixTime'),
      happenTime?: long(name='HappenTime'),
      instanceId?: long(name='InstanceId'),
      nodeId?: long(name='NodeId'),
      nodeName?: string(name='NodeName'),
      nodeOwner?: string(name='NodeOwner'),
      projectId?: long(name='ProjectId'),
      topicId?: long(name='TopicId'),
      topicName?: string(name='TopicName'),
      topicStatus?: string(name='TopicStatus'),
      topicType?: string(name='TopicType'),
    }
  ](name='RelatedTopics'),
  requestId?: string(name='RequestId'),
}

model ListRelatedTopicsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRelatedTopicsResponseBody(name='body'),
}

/**
 * @param request ListRelatedTopicsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRelatedTopicsResponse
 */
async function listRelatedTopicsWithOptions(request: ListRelatedTopicsRequest, runtime: Util.RuntimeOptions): ListRelatedTopicsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.baselineId)) {
    body['BaselineId'] = request.baselineId;
  }
  if (!Util.isUnset(request.bizdate)) {
    body['Bizdate'] = request.bizdate;
  }
  if (!Util.isUnset(request.inGroupId)) {
    body['InGroupId'] = request.inGroupId;
  }
  if (!Util.isUnset(request.topicStatuses)) {
    body['TopicStatuses'] = request.topicStatuses;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListRelatedTopics',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListRelatedTopicsRequest
 * @return ListRelatedTopicsResponse
 */
async function listRelatedTopics(request: ListRelatedTopicsRequest): ListRelatedTopicsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRelatedTopicsWithOptions(request, runtime);
}

model ListRemindsRequest {
  alertTarget?: string(name='AlertTarget'),
  founder?: string(name='Founder'),
  nodeId?: long(name='NodeId'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  remindTypes?: string(name='RemindTypes'),
  searchText?: string(name='SearchText'),
}

model ListRemindsResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    reminds?: [ 
      {
        alertMethods?: [ string ](name='AlertMethods'),
        alertTargets?: [ string ](name='AlertTargets'),
        alertUnit?: string(name='AlertUnit'),
        baselineIds?: [ long ](name='BaselineIds'),
        bizProcessIds?: [ long ](name='BizProcessIds'),
        dndEnd?: string(name='DndEnd'),
        dndStart?: string(name='DndStart'),
        founder?: string(name='Founder'),
        nodeIds?: [ long ](name='NodeIds'),
        projectIds?: [ long ](name='ProjectIds'),
        remindId?: long(name='RemindId'),
        remindName?: string(name='RemindName'),
        remindType?: string(name='RemindType'),
        remindUnit?: string(name='RemindUnit'),
        useflag?: boolean(name='Useflag'),
      }
    ](name='Reminds'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListRemindsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRemindsResponseBody(name='body'),
}

/**
 * @param request ListRemindsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRemindsResponse
 */
async function listRemindsWithOptions(request: ListRemindsRequest, runtime: Util.RuntimeOptions): ListRemindsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alertTarget)) {
    body['AlertTarget'] = request.alertTarget;
  }
  if (!Util.isUnset(request.founder)) {
    body['Founder'] = request.founder;
  }
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remindTypes)) {
    body['RemindTypes'] = request.remindTypes;
  }
  if (!Util.isUnset(request.searchText)) {
    body['SearchText'] = request.searchText;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListReminds',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListRemindsRequest
 * @return ListRemindsResponse
 */
async function listReminds(request: ListRemindsRequest): ListRemindsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRemindsWithOptions(request, runtime);
}

model ListResourcesRequest {
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  type?: string(name='Type'),
}

model ListResourcesResponseBody = {
  pagingInfo?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    resources?: [ 
      {
        createTime?: long(name='CreateTime'),
        dataSource?: {
          name?: string(name='Name', description='数据源名称'),
          type?: string(name='Type', description='数据源类型'),
        }(name='DataSource', description='函数注册到的数据源信息'),
        id?: long(name='Id', description='代表资源组的资源属性字段'),
        modifyTime?: long(name='ModifyTime', description='资源文件的最近修改时间'),
        name?: string(name='Name', description='代表资源名称的资源属性字段'),
        owner?: string(name='Owner', description='资源文件的责任人'),
        projectId?: long(name='ProjectId', description='资源文件的项目id'),
        script?: {
          id?: long(name='Id', description='工作流脚本的id'),
          path?: string(name='Path', description='工作流的脚本路径'),
          runtime?: {
            command?: string(name='Command', description='脚本所属类型'),
          }(name='Runtime', description='脚本的运行时信息'),
        }(name='Script', description='工作流的脚本信息'),
        sourcePath?: string(name='SourcePath', description='文件目标存储路径'),
        sourceType?: string(name='SourceType', description='文件资源来源存储类型'),
        targetPath?: string(name='TargetPath', description='文件来源路径'),
        targetType?: string(name='TargetType', description='文件目标存储类型'),
        type?: string(name='Type', description='资源类型'),
      }
    ](name='Resources'),
    totalCount?: int32(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListResourcesResponseBody(name='body'),
}

/**
 * @summary 分页获取资源文件
 *
 * @param request ListResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListResourcesResponse
 */
async function listResourcesWithOptions(request: ListResourcesRequest, runtime: Util.RuntimeOptions): ListResourcesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResources',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 分页获取资源文件
 *
 * @param request ListResourcesRequest
 * @return ListResourcesResponse
 */
async function listResources(request: ListResourcesRequest): ListResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourcesWithOptions(request, runtime);
}

model ListShiftPersonnelsRequest {
  beginTime?: long(name='BeginTime', description='This parameter is required.'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  shiftPersonUID?: string(name='ShiftPersonUID'),
  shiftScheduleIdentifier?: string(name='ShiftScheduleIdentifier', description='This parameter is required.'),
  userType?: string(name='UserType'),
}

model ListShiftPersonnelsResponseBody = {
  paging?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    shiftPersons?: [ 
      {
        beginTime?: long(name='BeginTime'),
        endTime?: long(name='EndTime'),
        shiftPersonName?: string(name='ShiftPersonName'),
        shiftPersonUID?: string(name='ShiftPersonUID'),
      }
    ](name='ShiftPersons'),
    totalCount?: int32(name='TotalCount'),
  }(name='Paging'),
  requestId?: string(name='RequestId'),
}

model ListShiftPersonnelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListShiftPersonnelsResponseBody(name='body'),
}

/**
 * @param request ListShiftPersonnelsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListShiftPersonnelsResponse
 */
async function listShiftPersonnelsWithOptions(request: ListShiftPersonnelsRequest, runtime: Util.RuntimeOptions): ListShiftPersonnelsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.beginTime)) {
    body['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.shiftPersonUID)) {
    body['ShiftPersonUID'] = request.shiftPersonUID;
  }
  if (!Util.isUnset(request.shiftScheduleIdentifier)) {
    body['ShiftScheduleIdentifier'] = request.shiftScheduleIdentifier;
  }
  if (!Util.isUnset(request.userType)) {
    body['UserType'] = request.userType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListShiftPersonnels',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListShiftPersonnelsRequest
 * @return ListShiftPersonnelsResponse
 */
async function listShiftPersonnels(request: ListShiftPersonnelsRequest): ListShiftPersonnelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listShiftPersonnelsWithOptions(request, runtime);
}

model ListShiftSchedulesRequest {
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  shiftScheduleIdentifier?: string(name='ShiftScheduleIdentifier'),
  shiftScheduleName?: string(name='ShiftScheduleName'),
}

model ListShiftSchedulesResponseBody = {
  paging?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    shiftSchedules?: [ 
      {
        shiftScheduleIdentifier?: string(name='ShiftScheduleIdentifier'),
        shiftScheduleName?: string(name='ShiftScheduleName'),
      }
    ](name='ShiftSchedules'),
    totalCount?: int32(name='TotalCount'),
  }(name='Paging'),
  requestId?: string(name='RequestId'),
}

model ListShiftSchedulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListShiftSchedulesResponseBody(name='body'),
}

/**
 * @param request ListShiftSchedulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListShiftSchedulesResponse
 */
async function listShiftSchedulesWithOptions(request: ListShiftSchedulesRequest, runtime: Util.RuntimeOptions): ListShiftSchedulesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.shiftScheduleIdentifier)) {
    body['ShiftScheduleIdentifier'] = request.shiftScheduleIdentifier;
  }
  if (!Util.isUnset(request.shiftScheduleName)) {
    body['ShiftScheduleName'] = request.shiftScheduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListShiftSchedules',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListShiftSchedulesRequest
 * @return ListShiftSchedulesResponse
 */
async function listShiftSchedules(request: ListShiftSchedulesRequest): ListShiftSchedulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listShiftSchedulesWithOptions(request, runtime);
}

model ListTaskInstanceOperationLogsRequest {
  date?: long(name='Date'),
  id?: long(name='Id', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListTaskInstanceOperationLogsResponseBody = {
  pagingInfo?: {
    operationLogs?: [ 
      {
        createTime?: long(name='CreateTime'),
        operationContent?: string(name='OperationContent'),
        operationSeq?: long(name='OperationSeq'),
        taskInstanceId?: long(name='TaskInstanceId'),
        user?: string(name='User'),
      }
    ](name='OperationLogs'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListTaskInstanceOperationLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTaskInstanceOperationLogsResponseBody(name='body'),
}

/**
 * @param request ListTaskInstanceOperationLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTaskInstanceOperationLogsResponse
 */
async function listTaskInstanceOperationLogsWithOptions(request: ListTaskInstanceOperationLogsRequest, runtime: Util.RuntimeOptions): ListTaskInstanceOperationLogsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTaskInstanceOperationLogs',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListTaskInstanceOperationLogsRequest
 * @return ListTaskInstanceOperationLogsResponse
 */
async function listTaskInstanceOperationLogs(request: ListTaskInstanceOperationLogsRequest): ListTaskInstanceOperationLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTaskInstanceOperationLogsWithOptions(request, runtime);
}

model ListTaskInstancesRequest {
  bizdate?: long(name='Bizdate', description='This parameter is required.'),
  envType?: string(name='EnvType'),
  id?: long(name='Id'),
  ids?: [ long ](name='Ids'),
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  runtimeResource?: string(name='RuntimeResource'),
  sortBy?: string(name='SortBy'),
  status?: string(name='Status'),
  taskId?: long(name='TaskId'),
  taskIds?: [ long ](name='TaskIds'),
  taskName?: string(name='TaskName'),
  taskType?: string(name='TaskType'),
  triggerRecurrence?: string(name='TriggerRecurrence'),
  triggerType?: string(name='TriggerType'),
  workflowId?: long(name='WorkflowId'),
  workflowInstanceId?: long(name='WorkflowInstanceId'),
  workflowInstanceType?: string(name='WorkflowInstanceType'),
}

model ListTaskInstancesShrinkRequest {
  bizdate?: long(name='Bizdate', description='This parameter is required.'),
  envType?: string(name='EnvType'),
  id?: long(name='Id'),
  idsShrink?: string(name='Ids'),
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  runtimeResource?: string(name='RuntimeResource'),
  sortBy?: string(name='SortBy'),
  status?: string(name='Status'),
  taskId?: long(name='TaskId'),
  taskIdsShrink?: string(name='TaskIds'),
  taskName?: string(name='TaskName'),
  taskType?: string(name='TaskType'),
  triggerRecurrence?: string(name='TriggerRecurrence'),
  triggerType?: string(name='TriggerType'),
  workflowId?: long(name='WorkflowId'),
  workflowInstanceId?: long(name='WorkflowInstanceId'),
  workflowInstanceType?: string(name='WorkflowInstanceType'),
}

model ListTaskInstancesResponseBody = {
  pagingInfo?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    taskInstances?: [ 
      {
        baselineId?: long(name='BaselineId'),
        bizdate?: long(name='Bizdate'),
        createTime?: long(name='CreateTime'),
        createUser?: string(name='CreateUser'),
        dataSource?: {
          name?: string(name='Name'),
        }(name='DataSource'),
        description?: string(name='Description'),
        envType?: string(name='EnvType'),
        finishedTime?: long(name='FinishedTime'),
        id?: long(name='Id'),
        modifyTime?: long(name='ModifyTime'),
        modifyUser?: string(name='ModifyUser'),
        owner?: string(name='Owner'),
        periodNumber?: int32(name='PeriodNumber'),
        priority?: int32(name='Priority'),
        projectId?: long(name='ProjectId'),
        rerunMode?: string(name='RerunMode'),
        runNumber?: int32(name='RunNumber'),
        runtime?: {
          gateway?: string(name='Gateway'),
          processId?: string(name='ProcessId'),
        }(name='Runtime'),
        runtimeResource?: {
          cu?: string(name='Cu'),
          image?: string(name='Image'),
          resourceGroupId?: string(name='ResourceGroupId'),
        }(name='RuntimeResource'),
        scriptParameters?: string(name='ScriptParameters'),
        startedTime?: long(name='StartedTime'),
        status?: string(name='Status'),
        taskId?: long(name='TaskId'),
        taskName?: string(name='TaskName'),
        taskType?: string(name='TaskType'),
        tenantId?: long(name='TenantId'),
        timeout?: int32(name='Timeout'),
        triggerRecurrence?: string(name='TriggerRecurrence'),
        triggerTime?: long(name='TriggerTime'),
        triggerType?: string(name='TriggerType'),
        waitingResourceTime?: long(name='WaitingResourceTime'),
        waitingTriggerTime?: long(name='WaitingTriggerTime'),
        workflowId?: long(name='WorkflowId'),
        workflowInstanceId?: long(name='WorkflowInstanceId'),
        workflowInstanceType?: string(name='WorkflowInstanceType'),
        workflowName?: string(name='WorkflowName'),
      }
    ](name='TaskInstances'),
    totalCount?: int32(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListTaskInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTaskInstancesResponseBody(name='body'),
}

/**
 * @param tmpReq ListTaskInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTaskInstancesResponse
 */
async function listTaskInstancesWithOptions(tmpReq: ListTaskInstancesRequest, runtime: Util.RuntimeOptions): ListTaskInstancesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTaskInstancesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ids)) {
    request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, 'Ids', 'json');
  }
  if (!Util.isUnset(tmpReq.taskIds)) {
    request.taskIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.taskIds, 'TaskIds', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizdate)) {
    body['Bizdate'] = request.bizdate;
  }
  if (!Util.isUnset(request.envType)) {
    body['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.idsShrink)) {
    body['Ids'] = request.idsShrink;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.runtimeResource)) {
    body['RuntimeResource'] = request.runtimeResource;
  }
  if (!Util.isUnset(request.sortBy)) {
    body['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskIdsShrink)) {
    body['TaskIds'] = request.taskIdsShrink;
  }
  if (!Util.isUnset(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    body['TaskType'] = request.taskType;
  }
  if (!Util.isUnset(request.triggerRecurrence)) {
    body['TriggerRecurrence'] = request.triggerRecurrence;
  }
  if (!Util.isUnset(request.triggerType)) {
    body['TriggerType'] = request.triggerType;
  }
  if (!Util.isUnset(request.workflowId)) {
    body['WorkflowId'] = request.workflowId;
  }
  if (!Util.isUnset(request.workflowInstanceId)) {
    body['WorkflowInstanceId'] = request.workflowInstanceId;
  }
  if (!Util.isUnset(request.workflowInstanceType)) {
    body['WorkflowInstanceType'] = request.workflowInstanceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListTaskInstances',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListTaskInstancesRequest
 * @return ListTaskInstancesResponse
 */
async function listTaskInstances(request: ListTaskInstancesRequest): ListTaskInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTaskInstancesWithOptions(request, runtime);
}

model ListTaskOperationLogsRequest {
  date?: long(name='Date'),
  envType?: string(name='EnvType'),
  id?: long(name='Id', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListTaskOperationLogsResponseBody = {
  pagingInfo?: {
    operationLogs?: [ 
      {
        createTime?: long(name='CreateTime'),
        operationContent?: string(name='OperationContent'),
        operationSeq?: long(name='OperationSeq'),
        taskId?: long(name='TaskId'),
        user?: string(name='User'),
      }
    ](name='OperationLogs'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListTaskOperationLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTaskOperationLogsResponseBody(name='body'),
}

/**
 * @param request ListTaskOperationLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTaskOperationLogsResponse
 */
async function listTaskOperationLogsWithOptions(request: ListTaskOperationLogsRequest, runtime: Util.RuntimeOptions): ListTaskOperationLogsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTaskOperationLogs',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListTaskOperationLogsRequest
 * @return ListTaskOperationLogsResponse
 */
async function listTaskOperationLogs(request: ListTaskOperationLogsRequest): ListTaskOperationLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTaskOperationLogsWithOptions(request, runtime);
}

model ListTasksRequest {
  envType?: string(name='EnvType'),
  name?: string(name='Name'),
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  runtimeResource?: string(name='RuntimeResource'),
  sortBy?: string(name='SortBy'),
  taskType?: string(name='TaskType'),
  triggerRecurrence?: string(name='TriggerRecurrence'),
  triggerType?: string(name='TriggerType'),
  workflowId?: long(name='WorkflowId'),
}

model ListTasksResponseBody = {
  pagingInfo?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    tasks?: [ 
      {
        baselineId?: long(name='BaselineId'),
        createTime?: long(name='CreateTime'),
        createUser?: string(name='CreateUser'),
        dataSource?: {
          name?: string(name='Name'),
        }(name='DataSource'),
        description?: string(name='Description'),
        envType?: string(name='EnvType'),
        id?: long(name='Id'),
        instanceMode?: string(name='InstanceMode'),
        modifyTime?: long(name='ModifyTime'),
        modifyUser?: string(name='ModifyUser'),
        name?: string(name='Name'),
        owner?: string(name='Owner'),
        priority?: int32(name='Priority'),
        projectId?: long(name='ProjectId'),
        rerunInterval?: int32(name='RerunInterval'),
        rerunMode?: string(name='RerunMode'),
        rerunTimes?: int32(name='RerunTimes'),
        runtimeResource?: {
          cu?: string(name='Cu'),
          image?: string(name='Image'),
          resourceGroupId?: string(name='ResourceGroupId'),
        }(name='RuntimeResource'),
        scriptParameters?: string(name='ScriptParameters'),
        tenantId?: long(name='TenantId'),
        timeout?: int32(name='Timeout'),
        trigger?: {
          cron?: string(name='Cron'),
          endTime?: string(name='EndTime'),
          recurrence?: string(name='Recurrence'),
          startTime?: string(name='StartTime'),
          type?: string(name='Type'),
        }(name='Trigger'),
        type?: string(name='Type'),
        workflowId?: long(name='WorkflowId'),
      }
    ](name='Tasks'),
    totalCount?: int32(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTasksResponseBody(name='body'),
}

/**
 * @param request ListTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTasksResponse
 */
async function listTasksWithOptions(request: ListTasksRequest, runtime: Util.RuntimeOptions): ListTasksResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.envType)) {
    body['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.runtimeResource)) {
    body['RuntimeResource'] = request.runtimeResource;
  }
  if (!Util.isUnset(request.sortBy)) {
    body['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.taskType)) {
    body['TaskType'] = request.taskType;
  }
  if (!Util.isUnset(request.triggerRecurrence)) {
    body['TriggerRecurrence'] = request.triggerRecurrence;
  }
  if (!Util.isUnset(request.triggerType)) {
    body['TriggerType'] = request.triggerType;
  }
  if (!Util.isUnset(request.workflowId)) {
    body['WorkflowId'] = request.workflowId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListTasks',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListTasksRequest
 * @return ListTasksResponse
 */
async function listTasks(request: ListTasksRequest): ListTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTasksWithOptions(request, runtime);
}

model ListTopicsRequest {
  beginTime?: string(name='BeginTime', description='This parameter is required.'),
  endTime?: string(name='EndTime', description='This parameter is required.'),
  instanceId?: long(name='InstanceId'),
  nodeId?: long(name='NodeId'),
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  topicStatuses?: string(name='TopicStatuses'),
  topicTypes?: string(name='TopicTypes'),
}

model ListTopicsResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    topics?: [ 
      {
        addTime?: long(name='AddTime'),
        fixTime?: long(name='FixTime'),
        happenTime?: long(name='HappenTime'),
        instanceId?: long(name='InstanceId'),
        nodeId?: long(name='NodeId'),
        nodeName?: string(name='NodeName'),
        nodeOwner?: string(name='NodeOwner'),
        projectId?: long(name='ProjectId'),
        topicId?: long(name='TopicId'),
        topicName?: string(name='TopicName'),
        topicStatus?: string(name='TopicStatus'),
        topicType?: string(name='TopicType'),
      }
    ](name='Topics'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListTopicsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTopicsResponseBody(name='body'),
}

/**
 * @param request ListTopicsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTopicsResponse
 */
async function listTopicsWithOptions(request: ListTopicsRequest, runtime: Util.RuntimeOptions): ListTopicsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.beginTime)) {
    body['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.topicStatuses)) {
    body['TopicStatuses'] = request.topicStatuses;
  }
  if (!Util.isUnset(request.topicTypes)) {
    body['TopicTypes'] = request.topicTypes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListTopics',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListTopicsRequest
 * @return ListTopicsResponse
 */
async function listTopics(request: ListTopicsRequest): ListTopicsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTopicsWithOptions(request, runtime);
}

model ListUpstreamTaskInstancesRequest {
  id?: long(name='Id', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListUpstreamTaskInstancesResponseBody = {
  pagingInfo?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    upstreamTaskInstances?: [ 
      {
        dependencyType?: string(name='DependencyType'),
        taskInstance?: {
          baselineId?: long(name='BaselineId'),
          bizdate?: long(name='Bizdate'),
          createTime?: long(name='CreateTime'),
          createUser?: string(name='CreateUser'),
          dataSource?: {
            name?: string(name='Name'),
          }(name='DataSource'),
          description?: string(name='Description'),
          envType?: string(name='EnvType'),
          finishedTime?: long(name='FinishedTime'),
          id?: long(name='Id'),
          modifyTime?: long(name='ModifyTime'),
          modifyUser?: string(name='ModifyUser'),
          owner?: string(name='Owner'),
          periodNumber?: int32(name='PeriodNumber'),
          priority?: int32(name='Priority'),
          projectId?: long(name='ProjectId'),
          rerunMode?: string(name='RerunMode'),
          runNumber?: int32(name='RunNumber'),
          runtime?: {
            gateway?: string(name='Gateway'),
            processId?: string(name='ProcessId'),
          }(name='Runtime'),
          runtimeResource?: {
            cu?: string(name='Cu'),
            image?: string(name='Image'),
            resourceGroupId?: string(name='ResourceGroupId'),
          }(name='RuntimeResource'),
          startedTime?: long(name='StartedTime'),
          status?: string(name='Status'),
          taskId?: long(name='TaskId'),
          taskName?: string(name='TaskName'),
          taskType?: string(name='TaskType'),
          tenantId?: long(name='TenantId'),
          timeout?: int32(name='Timeout'),
          triggerRecurrence?: string(name='TriggerRecurrence'),
          triggerTime?: long(name='TriggerTime'),
          triggerType?: string(name='TriggerType'),
          waitingResourceTime?: long(name='WaitingResourceTime'),
          waitingTriggerTime?: long(name='WaitingTriggerTime'),
          workflowId?: long(name='WorkflowId'),
          workflowInstanceId?: long(name='WorkflowInstanceId'),
          workflowInstanceType?: string(name='WorkflowInstanceType'),
          workflowName?: string(name='WorkflowName'),
        }(name='TaskInstance'),
      }
    ](name='UpstreamTaskInstances'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListUpstreamTaskInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUpstreamTaskInstancesResponseBody(name='body'),
}

/**
 * @param request ListUpstreamTaskInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUpstreamTaskInstancesResponse
 */
async function listUpstreamTaskInstancesWithOptions(request: ListUpstreamTaskInstancesRequest, runtime: Util.RuntimeOptions): ListUpstreamTaskInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUpstreamTaskInstances',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListUpstreamTaskInstancesRequest
 * @return ListUpstreamTaskInstancesResponse
 */
async function listUpstreamTaskInstances(request: ListUpstreamTaskInstancesRequest): ListUpstreamTaskInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUpstreamTaskInstancesWithOptions(request, runtime);
}

model ListUpstreamTasksRequest {
  envType?: string(name='EnvType'),
  id?: long(name='Id', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListUpstreamTasksResponseBody = {
  pagingInfo?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    upstreamTasks?: [ 
      {
        dependencyType?: string(name='DependencyType'),
        task?: {
          baselineId?: long(name='BaselineId'),
          createTime?: long(name='CreateTime'),
          createUser?: string(name='CreateUser'),
          dataSource?: {
            name?: string(name='Name'),
          }(name='DataSource'),
          description?: string(name='Description'),
          envType?: string(name='EnvType'),
          id?: long(name='Id'),
          instanceMode?: string(name='InstanceMode'),
          modifyTime?: long(name='ModifyTime'),
          modifyUser?: string(name='ModifyUser'),
          name?: string(name='Name'),
          owner?: string(name='Owner'),
          priority?: int32(name='Priority'),
          projectId?: long(name='ProjectId'),
          rerunInterval?: int32(name='RerunInterval'),
          rerunMode?: string(name='RerunMode'),
          rerunTimes?: int32(name='RerunTimes'),
          runtimeResource?: {
            cu?: string(name='Cu'),
            image?: string(name='Image'),
            resourceGroupId?: string(name='ResourceGroupId'),
          }(name='RuntimeResource'),
          tenantId?: long(name='TenantId'),
          timeout?: int32(name='Timeout'),
          trigger?: {
            cron?: string(name='Cron'),
            endTime?: string(name='EndTime'),
            recurrence?: string(name='Recurrence'),
            startTime?: string(name='StartTime'),
            timezone?: string(name='Timezone'),
            type?: string(name='Type'),
          }(name='Trigger'),
          type?: string(name='Type'),
          workflowId?: long(name='WorkflowId'),
        }(name='Task'),
      }
    ](name='UpstreamTasks'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListUpstreamTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUpstreamTasksResponseBody(name='body'),
}

/**
 * @param request ListUpstreamTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUpstreamTasksResponse
 */
async function listUpstreamTasksWithOptions(request: ListUpstreamTasksRequest, runtime: Util.RuntimeOptions): ListUpstreamTasksResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUpstreamTasks',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListUpstreamTasksRequest
 * @return ListUpstreamTasksResponse
 */
async function listUpstreamTasks(request: ListUpstreamTasksRequest): ListUpstreamTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUpstreamTasksWithOptions(request, runtime);
}

model ListWorkflowDefinitionsRequest {
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  type?: string(name='Type'),
}

model ListWorkflowDefinitionsResponseBody = {
  pagingInfo?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    workflowDefinitions?: [ 
      {
        createTime?: long(name='CreateTime', description='工作流的创建时间'),
        description?: string(name='Description', description='工作流的描述'),
        id?: long(name='Id', description='工作流定义的唯一ID'),
        modifyTime?: long(name='ModifyTime', description='工作流的最近修改时间'),
        name?: string(name='Name', description='工作流的名称'),
        owner?: string(name='Owner', description='工作流的责任人'),
        projectId?: long(name='ProjectId', description='工作流定义的所属项目空间

This parameter is required.'),
        script?: {
          id?: long(name='Id', description='工作流脚本的id'),
          path?: string(name='Path', description='工作流的脚本路径'),
          runtime?: {
            command?: string(name='Command', description='脚本所属类型'),
          }(name='Runtime', description='脚本的运行时信息'),
        }(name='Script', description='工作流的脚本信息'),
        type?: string(name='Type', description='工作流类型，可选值：CycleWorkflow、ManualWorkflow，分别表示周期工作流和手动工作流'),
      }
    ](name='WorkflowDefinitions'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListWorkflowDefinitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWorkflowDefinitionsResponseBody(name='body'),
}

/**
 * @summary 获取workflowDefinition的列表
 *
 * @param request ListWorkflowDefinitionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListWorkflowDefinitionsResponse
 */
async function listWorkflowDefinitionsWithOptions(request: ListWorkflowDefinitionsRequest, runtime: Util.RuntimeOptions): ListWorkflowDefinitionsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkflowDefinitions',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取workflowDefinition的列表
 *
 * @param request ListWorkflowDefinitionsRequest
 * @return ListWorkflowDefinitionsResponse
 */
async function listWorkflowDefinitions(request: ListWorkflowDefinitionsRequest): ListWorkflowDefinitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listWorkflowDefinitionsWithOptions(request, runtime);
}

model ListWorkflowInstancesRequest {
  bizDate?: long(name='BizDate', description='This parameter is required.'),
  ids?: [ long ](name='Ids'),
  name?: string(name='Name'),
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  sortBy?: string(name='SortBy'),
  type?: string(name='Type'),
  workflowId?: long(name='WorkflowId'),
}

model ListWorkflowInstancesShrinkRequest {
  bizDate?: long(name='BizDate', description='This parameter is required.'),
  idsShrink?: string(name='Ids'),
  name?: string(name='Name'),
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  sortBy?: string(name='SortBy'),
  type?: string(name='Type'),
  workflowId?: long(name='WorkflowId'),
}

model ListWorkflowInstancesResponseBody = {
  pagingInfo?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    workflowInstances?: [ 
      {
        bizDate?: long(name='BizDate'),
        createTime?: long(name='CreateTime'),
        createUser?: string(name='CreateUser'),
        envType?: string(name='EnvType'),
        finishedTime?: long(name='FinishedTime'),
        id?: long(name='Id'),
        modifyTime?: long(name='ModifyTime'),
        modifyUser?: string(name='ModifyUser'),
        name?: string(name='Name'),
        projectId?: long(name='ProjectId'),
        startedTime?: long(name='StartedTime'),
        status?: string(name='Status'),
        type?: string(name='Type'),
        workflowId?: long(name='WorkflowId'),
      }
    ](name='WorkflowInstances'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListWorkflowInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWorkflowInstancesResponseBody(name='body'),
}

/**
 * @param tmpReq ListWorkflowInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListWorkflowInstancesResponse
 */
async function listWorkflowInstancesWithOptions(tmpReq: ListWorkflowInstancesRequest, runtime: Util.RuntimeOptions): ListWorkflowInstancesResponse {
  Util.validateModel(tmpReq);
  var request = new ListWorkflowInstancesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ids)) {
    request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, 'Ids', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizDate)) {
    body['BizDate'] = request.bizDate;
  }
  if (!Util.isUnset(request.idsShrink)) {
    body['Ids'] = request.idsShrink;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.sortBy)) {
    body['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  if (!Util.isUnset(request.workflowId)) {
    body['WorkflowId'] = request.workflowId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkflowInstances',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListWorkflowInstancesRequest
 * @return ListWorkflowInstancesResponse
 */
async function listWorkflowInstances(request: ListWorkflowInstancesRequest): ListWorkflowInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listWorkflowInstancesWithOptions(request, runtime);
}

model ListWorkflowsRequest {
  envType?: string(name='EnvType'),
  ids?: [ long ](name='Ids'),
  name?: string(name='Name'),
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  sortBy?: string(name='SortBy'),
  triggerType?: string(name='TriggerType'),
}

model ListWorkflowsShrinkRequest {
  envType?: string(name='EnvType'),
  idsShrink?: string(name='Ids'),
  name?: string(name='Name'),
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  sortBy?: string(name='SortBy'),
  triggerType?: string(name='TriggerType'),
}

model ListWorkflowsResponseBody = {
  pagingInfo?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    workflows?: [ 
      {
        clientUniqueCode?: string(name='ClientUniqueCode'),
        createTime?: long(name='CreateTime'),
        createUser?: string(name='CreateUser'),
        description?: string(name='Description'),
        envType?: string(name='EnvType'),
        id?: long(name='Id'),
        modifyTime?: long(name='ModifyTime'),
        modifyUser?: string(name='ModifyUser'),
        name?: string(name='Name'),
        owner?: string(name='Owner'),
        parameters?: string(name='Parameters'),
        projectId?: long(name='ProjectId'),
        trigger?: {
          cron?: string(name='Cron'),
          endTime?: string(name='EndTime'),
          recurrence?: string(name='Recurrence'),
          startTime?: string(name='StartTime'),
          type?: string(name='Type'),
        }(name='Trigger'),
      }
    ](name='Workflows'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId'),
}

model ListWorkflowsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWorkflowsResponseBody(name='body'),
}

/**
 * @param tmpReq ListWorkflowsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListWorkflowsResponse
 */
async function listWorkflowsWithOptions(tmpReq: ListWorkflowsRequest, runtime: Util.RuntimeOptions): ListWorkflowsResponse {
  Util.validateModel(tmpReq);
  var request = new ListWorkflowsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ids)) {
    request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, 'Ids', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.envType)) {
    body['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.idsShrink)) {
    body['Ids'] = request.idsShrink;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.sortBy)) {
    body['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.triggerType)) {
    body['TriggerType'] = request.triggerType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkflows',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListWorkflowsRequest
 * @return ListWorkflowsResponse
 */
async function listWorkflows(request: ListWorkflowsRequest): ListWorkflowsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listWorkflowsWithOptions(request, runtime);
}

model MoveFunctionRequest {
  id?: long(name='Id', description='This parameter is required.'),
  path?: string(name='Path', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model MoveFunctionResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model MoveFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MoveFunctionResponseBody(name='body'),
}

/**
 * @summary 移动funciton的路径
 *
 * @param request MoveFunctionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MoveFunctionResponse
 */
async function moveFunctionWithOptions(request: MoveFunctionRequest, runtime: Util.RuntimeOptions): MoveFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.path)) {
    body['Path'] = request.path;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'MoveFunction',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 移动funciton的路径
 *
 * @param request MoveFunctionRequest
 * @return MoveFunctionResponse
 */
async function moveFunction(request: MoveFunctionRequest): MoveFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveFunctionWithOptions(request, runtime);
}

model MoveNodeRequest {
  id?: long(name='Id', description='This parameter is required.'),
  path?: string(name='Path', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model MoveNodeResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model MoveNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MoveNodeResponseBody(name='body'),
}

/**
 * @summary 移动节点路径
 *
 * @param request MoveNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MoveNodeResponse
 */
async function moveNodeWithOptions(request: MoveNodeRequest, runtime: Util.RuntimeOptions): MoveNodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.path)) {
    body['Path'] = request.path;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'MoveNode',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 移动节点路径
 *
 * @param request MoveNodeRequest
 * @return MoveNodeResponse
 */
async function moveNode(request: MoveNodeRequest): MoveNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveNodeWithOptions(request, runtime);
}

model MoveResourceRequest {
  id?: long(name='Id', description='This parameter is required.'),
  path?: string(name='Path', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model MoveResourceResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model MoveResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MoveResourceResponseBody(name='body'),
}

/**
 * @summary 移动资源文件路径
 *
 * @param request MoveResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MoveResourceResponse
 */
async function moveResourceWithOptions(request: MoveResourceRequest, runtime: Util.RuntimeOptions): MoveResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.path)) {
    body['Path'] = request.path;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'MoveResource',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 移动资源文件路径
 *
 * @param request MoveResourceRequest
 * @return MoveResourceResponse
 */
async function moveResource(request: MoveResourceRequest): MoveResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveResourceWithOptions(request, runtime);
}

model MoveWorkflowDefinitionRequest {
  id?: long(name='Id', description='This parameter is required.'),
  path?: string(name='Path', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model MoveWorkflowDefinitionResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model MoveWorkflowDefinitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MoveWorkflowDefinitionResponseBody(name='body'),
}

/**
 * @summary 移动工作流的路径
 *
 * @param request MoveWorkflowDefinitionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MoveWorkflowDefinitionResponse
 */
async function moveWorkflowDefinitionWithOptions(request: MoveWorkflowDefinitionRequest, runtime: Util.RuntimeOptions): MoveWorkflowDefinitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.path)) {
    body['Path'] = request.path;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'MoveWorkflowDefinition',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 移动工作流的路径
 *
 * @param request MoveWorkflowDefinitionRequest
 * @return MoveWorkflowDefinitionResponse
 */
async function moveWorkflowDefinition(request: MoveWorkflowDefinitionRequest): MoveWorkflowDefinitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveWorkflowDefinitionWithOptions(request, runtime);
}

model OfflineNodeRequest {
  nodeId?: long(name='NodeId', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model OfflineNodeResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model OfflineNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OfflineNodeResponseBody(name='body'),
}

/**
 * @summary 运维中心下线节点OpenAPI
 *
 * @param request OfflineNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OfflineNodeResponse
 */
async function offlineNodeWithOptions(request: OfflineNodeRequest, runtime: Util.RuntimeOptions): OfflineNodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'OfflineNode',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 运维中心下线节点OpenAPI
 *
 * @param request OfflineNodeRequest
 * @return OfflineNodeResponse
 */
async function offlineNode(request: OfflineNodeRequest): OfflineNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return offlineNodeWithOptions(request, runtime);
}

model QueryDataVDatasetRequest {
  code?: string(name='Code', description='This parameter is required.'),
  conditions?: string(name='Conditions'),
  extInfo?: string(name='ExtInfo'),
  type?: string(name='Type'),
  userId?: string(name='UserId', description='This parameter is required.'),
}

model QueryDataVDatasetResponseBody = {
  data?: {
    body?: [ map[string]any ](name='body'),
    code?: string(name='code'),
    count?: int32(name='count'),
    headers?: [ 
      {
        fieldType?: string(name='fieldType'),
        key?: string(name='key'),
        type?: string(name='type'),
      }
    ](name='headers'),
    msg?: string(name='msg'),
    statusEnum?: string(name='statusEnum'),
  }(name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  requestId?: string(name='requestId'),
}

model QueryDataVDatasetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDataVDatasetResponseBody(name='body'),
}

/**
 * @summary DataV读取数据集结果
 *
 * @param request QueryDataVDatasetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDataVDatasetResponse
 */
async function queryDataVDatasetWithOptions(request: QueryDataVDatasetRequest, runtime: Util.RuntimeOptions): QueryDataVDatasetResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDataVDataset',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DataV读取数据集结果
 *
 * @param request QueryDataVDatasetRequest
 * @return QueryDataVDatasetResponse
 */
async function queryDataVDataset(request: QueryDataVDatasetRequest): QueryDataVDatasetResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDataVDatasetWithOptions(request, runtime);
}

model QueryPublicModelEngineRequest {
  permissionLevel?: string(name='PermissionLevel'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
  text?: string(name='Text', description='This parameter is required.'),
}

model QueryPublicModelEngineResponseBody = {
  requestId?: string(name='RequestId'),
  returnValue?: [  map[string]any ](name='ReturnValue'),
}

model QueryPublicModelEngineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPublicModelEngineResponseBody(name='body'),
}

/**
 * @summary Dataworks数据建模对外查询模型接口
 *
 * @param request QueryPublicModelEngineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryPublicModelEngineResponse
 */
async function queryPublicModelEngineWithOptions(request: QueryPublicModelEngineRequest, runtime: Util.RuntimeOptions): QueryPublicModelEngineResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.permissionLevel)) {
    body['PermissionLevel'] = request.permissionLevel;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.text)) {
    body['Text'] = request.text;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryPublicModelEngine',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Dataworks数据建模对外查询模型接口
 *
 * @param request QueryPublicModelEngineRequest
 * @return QueryPublicModelEngineResponse
 */
async function queryPublicModelEngine(request: QueryPublicModelEngineRequest): QueryPublicModelEngineResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPublicModelEngineWithOptions(request, runtime);
}

model RefreshDataVDatasetRequest {
  code?: string(name='Code', description='This parameter is required.'),
  userId?: string(name='UserId', description='This parameter is required.'),
}

model RefreshDataVDatasetResponseBody = {
  data?: {
    body?: [ map[string]any ](name='body'),
    code?: string(name='code'),
    count?: int32(name='count'),
    headers?: [ 
      {
        fieldType?: string(name='fieldType'),
        key?: string(name='key'),
        type?: string(name='type'),
      }
    ](name='headers'),
    msg?: string(name='msg'),
    statusEnum?: string(name='statusEnum'),
  }(name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  success?: boolean(name='success'),
}

model RefreshDataVDatasetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RefreshDataVDatasetResponseBody(name='body'),
}

/**
 * @summary 手动更新数据集
 *
 * @param request RefreshDataVDatasetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshDataVDatasetResponse
 */
async function refreshDataVDatasetWithOptions(request: RefreshDataVDatasetRequest, runtime: Util.RuntimeOptions): RefreshDataVDatasetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.code)) {
    query['Code'] = request.code;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshDataVDataset',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 手动更新数据集
 *
 * @param request RefreshDataVDatasetRequest
 * @return RefreshDataVDatasetResponse
 */
async function refreshDataVDataset(request: RefreshDataVDatasetRequest): RefreshDataVDatasetResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshDataVDatasetWithOptions(request, runtime);
}

model RemoveTaskInstanceDependenciesRequest {
  comment?: string(name='Comment'),
  id?: long(name='Id', description='This parameter is required.'),
  upstreamTaskInstanceIds?: [ long ](name='UpstreamTaskInstanceIds'),
}

model RemoveTaskInstanceDependenciesShrinkRequest {
  comment?: string(name='Comment'),
  id?: long(name='Id', description='This parameter is required.'),
  upstreamTaskInstanceIdsShrink?: string(name='UpstreamTaskInstanceIds'),
}

model RemoveTaskInstanceDependenciesResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RemoveTaskInstanceDependenciesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveTaskInstanceDependenciesResponseBody(name='body'),
}

/**
 * @param tmpReq RemoveTaskInstanceDependenciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveTaskInstanceDependenciesResponse
 */
async function removeTaskInstanceDependenciesWithOptions(tmpReq: RemoveTaskInstanceDependenciesRequest, runtime: Util.RuntimeOptions): RemoveTaskInstanceDependenciesResponse {
  Util.validateModel(tmpReq);
  var request = new RemoveTaskInstanceDependenciesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.upstreamTaskInstanceIds)) {
    request.upstreamTaskInstanceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.upstreamTaskInstanceIds, 'UpstreamTaskInstanceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.upstreamTaskInstanceIdsShrink)) {
    body['UpstreamTaskInstanceIds'] = request.upstreamTaskInstanceIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveTaskInstanceDependencies',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RemoveTaskInstanceDependenciesRequest
 * @return RemoveTaskInstanceDependenciesResponse
 */
async function removeTaskInstanceDependencies(request: RemoveTaskInstanceDependenciesRequest): RemoveTaskInstanceDependenciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeTaskInstanceDependenciesWithOptions(request, runtime);
}

model RemoveTaskParentRelationRequest {
  instanceId?: long(name='InstanceId', description='This parameter is required.'),
  parentInstanceIds?: string(name='ParentInstanceIds', description='This parameter is required.'),
}

model RemoveTaskParentRelationResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model RemoveTaskParentRelationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveTaskParentRelationResponseBody(name='body'),
}

/**
 * @summary 移除实例上游依赖
 *
 * @param request RemoveTaskParentRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveTaskParentRelationResponse
 */
async function removeTaskParentRelationWithOptions(request: RemoveTaskParentRelationRequest, runtime: Util.RuntimeOptions): RemoveTaskParentRelationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.parentInstanceIds)) {
    body['ParentInstanceIds'] = request.parentInstanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveTaskParentRelation',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 移除实例上游依赖
 *
 * @param request RemoveTaskParentRelationRequest
 * @return RemoveTaskParentRelationResponse
 */
async function removeTaskParentRelation(request: RemoveTaskParentRelationRequest): RemoveTaskParentRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeTaskParentRelationWithOptions(request, runtime);
}

model RenameFunctionRequest {
  id?: long(name='Id', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model RenameFunctionResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model RenameFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenameFunctionResponseBody(name='body'),
}

/**
 * @summary 对function重命名
 *
 * @param request RenameFunctionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RenameFunctionResponse
 */
async function renameFunctionWithOptions(request: RenameFunctionRequest, runtime: Util.RuntimeOptions): RenameFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RenameFunction',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 对function重命名
 *
 * @param request RenameFunctionRequest
 * @return RenameFunctionResponse
 */
async function renameFunction(request: RenameFunctionRequest): RenameFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  return renameFunctionWithOptions(request, runtime);
}

model RenameNodeRequest {
  id?: long(name='Id', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model RenameNodeResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RenameNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenameNodeResponseBody(name='body'),
}

/**
 * @summary 重命名节点
 *
 * @param request RenameNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RenameNodeResponse
 */
async function renameNodeWithOptions(request: RenameNodeRequest, runtime: Util.RuntimeOptions): RenameNodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RenameNode',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 重命名节点
 *
 * @param request RenameNodeRequest
 * @return RenameNodeResponse
 */
async function renameNode(request: RenameNodeRequest): RenameNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return renameNodeWithOptions(request, runtime);
}

model RenameResourceRequest {
  id?: long(name='Id', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model RenameResourceResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RenameResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenameResourceResponseBody(name='body'),
}

/**
 * @summary 对资源文件重命名
 *
 * @param request RenameResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RenameResourceResponse
 */
async function renameResourceWithOptions(request: RenameResourceRequest, runtime: Util.RuntimeOptions): RenameResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RenameResource',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 对资源文件重命名
 *
 * @param request RenameResourceRequest
 * @return RenameResourceResponse
 */
async function renameResource(request: RenameResourceRequest): RenameResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return renameResourceWithOptions(request, runtime);
}

model RenameWorkflowDefinitionRequest {
  id?: long(name='Id', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model RenameWorkflowDefinitionResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RenameWorkflowDefinitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenameWorkflowDefinitionResponseBody(name='body'),
}

/**
 * @summary 重命名工作流
 *
 * @param request RenameWorkflowDefinitionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RenameWorkflowDefinitionResponse
 */
async function renameWorkflowDefinitionWithOptions(request: RenameWorkflowDefinitionRequest, runtime: Util.RuntimeOptions): RenameWorkflowDefinitionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenameWorkflowDefinition',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 重命名工作流
 *
 * @param request RenameWorkflowDefinitionRequest
 * @return RenameWorkflowDefinitionResponse
 */
async function renameWorkflowDefinition(request: RenameWorkflowDefinitionRequest): RenameWorkflowDefinitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return renameWorkflowDefinitionWithOptions(request, runtime);
}

model RerunTaskInstancesRequest {
  comment?: string(name='Comment'),
  ids?: [ long ](name='Ids'),
}

model RerunTaskInstancesShrinkRequest {
  comment?: string(name='Comment'),
  idsShrink?: string(name='Ids'),
}

model RerunTaskInstancesResponseBody = {
  requestId?: string(name='RequestId'),
  successInfo?: map[string]SuccessInfoValue(name='SuccessInfo'),
}

model RerunTaskInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RerunTaskInstancesResponseBody(name='body'),
}

/**
 * @param tmpReq RerunTaskInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RerunTaskInstancesResponse
 */
async function rerunTaskInstancesWithOptions(tmpReq: RerunTaskInstancesRequest, runtime: Util.RuntimeOptions): RerunTaskInstancesResponse {
  Util.validateModel(tmpReq);
  var request = new RerunTaskInstancesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ids)) {
    request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, 'Ids', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.idsShrink)) {
    body['Ids'] = request.idsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RerunTaskInstances',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RerunTaskInstancesRequest
 * @return RerunTaskInstancesResponse
 */
async function rerunTaskInstances(request: RerunTaskInstancesRequest): RerunTaskInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return rerunTaskInstancesWithOptions(request, runtime);
}

model RestartInstanceRequest {
  instanceId?: long(name='InstanceId', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
}

model RestartInstanceResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model RestartInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestartInstanceResponseBody(name='body'),
}

/**
 * @param request RestartInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RestartInstanceResponse
 */
async function restartInstanceWithOptions(request: RestartInstanceRequest, runtime: Util.RuntimeOptions): RestartInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RestartInstance',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RestartInstanceRequest
 * @return RestartInstanceResponse
 */
async function restartInstance(request: RestartInstanceRequest): RestartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartInstanceWithOptions(request, runtime);
}

model ResumeInstanceRequest {
  instanceId?: long(name='InstanceId', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
}

model ResumeInstanceResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ResumeInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResumeInstanceResponseBody(name='body'),
}

/**
 * @param request ResumeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResumeInstanceResponse
 */
async function resumeInstanceWithOptions(request: ResumeInstanceRequest, runtime: Util.RuntimeOptions): ResumeInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ResumeInstance',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ResumeInstanceRequest
 * @return ResumeInstanceResponse
 */
async function resumeInstance(request: ResumeInstanceRequest): ResumeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumeInstanceWithOptions(request, runtime);
}

model ResumeTaskInstancesRequest {
  comment?: string(name='Comment'),
  ids?: [ long ](name='Ids'),
}

model ResumeTaskInstancesShrinkRequest {
  comment?: string(name='Comment'),
  idsShrink?: string(name='Ids'),
}

model ResumeTaskInstancesResponseBody = {
  requestId?: string(name='RequestId'),
  successInfo?: map[string]SuccessInfoValue(name='SuccessInfo'),
}

model ResumeTaskInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResumeTaskInstancesResponseBody(name='body'),
}

/**
 * @param tmpReq ResumeTaskInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResumeTaskInstancesResponse
 */
async function resumeTaskInstancesWithOptions(tmpReq: ResumeTaskInstancesRequest, runtime: Util.RuntimeOptions): ResumeTaskInstancesResponse {
  Util.validateModel(tmpReq);
  var request = new ResumeTaskInstancesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ids)) {
    request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, 'Ids', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.idsShrink)) {
    body['Ids'] = request.idsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ResumeTaskInstances',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ResumeTaskInstancesRequest
 * @return ResumeTaskInstancesResponse
 */
async function resumeTaskInstances(request: ResumeTaskInstancesRequest): ResumeTaskInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumeTaskInstancesWithOptions(request, runtime);
}

model RunTriggerNodeRequest {
  appId?: long(name='AppId', description='This parameter is required.'),
  bizDate?: long(name='BizDate', description='This parameter is required.'),
  cycleTime?: long(name='CycleTime', description='This parameter is required.'),
  nodeId?: long(name='NodeId', description='This parameter is required.'),
}

model RunTriggerNodeResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RunTriggerNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RunTriggerNodeResponseBody(name='body'),
}

/**
 * @summary 触发器节点API
 *
 * @param request RunTriggerNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RunTriggerNodeResponse
 */
async function runTriggerNodeWithOptions(request: RunTriggerNodeRequest, runtime: Util.RuntimeOptions): RunTriggerNodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.bizDate)) {
    body['BizDate'] = request.bizDate;
  }
  if (!Util.isUnset(request.cycleTime)) {
    body['CycleTime'] = request.cycleTime;
  }
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RunTriggerNode',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 触发器节点API
 *
 * @param request RunTriggerNodeRequest
 * @return RunTriggerNodeResponse
 */
async function runTriggerNode(request: RunTriggerNodeRequest): RunTriggerNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return runTriggerNodeWithOptions(request, runtime);
}

model SearchAssetCatalogsRequest {
  categoryUuidList?: [ string ](name='CategoryUuidList'),
  categoryUuidWithChild?: string(name='CategoryUuidWithChild'),
  keyword?: string(name='Keyword'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
}

model SearchAssetCatalogsResponseBody = {
  data?: {
    dataList?: [ 
      {
        gmtCreate?: long(name='GmtCreate'),
        gmtModified?: long(name='GmtModified'),
        name?: string(name='Name'),
        ownerId?: string(name='OwnerId'),
        ownerName?: string(name='OwnerName'),
        parentPath?: [ string ](name='ParentPath'),
        parentUuid?: string(name='ParentUuid'),
        uuid?: string(name='Uuid'),
      }
    ](name='DataList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SearchAssetCatalogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchAssetCatalogsResponseBody(name='body'),
}

/**
 * @param request SearchAssetCatalogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchAssetCatalogsResponse
 */
async function searchAssetCatalogsWithOptions(request: SearchAssetCatalogsRequest, runtime: Util.RuntimeOptions): SearchAssetCatalogsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchAssetCatalogs',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SearchAssetCatalogsRequest
 * @return SearchAssetCatalogsResponse
 */
async function searchAssetCatalogs(request: SearchAssetCatalogsRequest): SearchAssetCatalogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAssetCatalogsWithOptions(request, runtime);
}

model SearchAssetInstancesRequest {
  categoryUuidList?: [ string ](name='CategoryUuidList'),
  categoryUuidWithChild?: string(name='CategoryUuidWithChild'),
  keyword?: string(name='Keyword'),
  objectDefineGroupUuidList?: [ string ](name='ObjectDefineGroupUuidList'),
  orderByList?: [ string ](name='OrderByList'),
  pageNumber?: int32(name='PageNumber', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
}

model SearchAssetInstancesResponseBody = {
  data?: {
    dataList?: [ 
      {
        categoryPathNameList?: [ string ](name='CategoryPathNameList'),
        categoryUuid?: string(name='CategoryUuid'),
        code?: string(name='Code'),
        description?: string(name='Description'),
        gmtCreate?: long(name='GmtCreate'),
        gmtModified?: long(name='GmtModified'),
        gmtOnline?: long(name='GmtOnline'),
        gmtStorage?: long(name='GmtStorage'),
        metricsMap?: map[string]any(name='MetricsMap'),
        modifierId?: string(name='ModifierId'),
        modifierName?: string(name='ModifierName'),
        name?: string(name='Name'),
        objectDefineShowName?: string(name='ObjectDefineShowName'),
        objectDefineUuid?: string(name='ObjectDefineUuid'),
        ownerId?: string(name='OwnerId'),
        ownerName?: string(name='OwnerName'),
        uuid?: string(name='Uuid'),
      }
    ](name='DataList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SearchAssetInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchAssetInstancesResponseBody(name='body'),
}

/**
 * @param request SearchAssetInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchAssetInstancesResponse
 */
async function searchAssetInstancesWithOptions(request: SearchAssetInstancesRequest, runtime: Util.RuntimeOptions): SearchAssetInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchAssetInstances',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SearchAssetInstancesRequest
 * @return SearchAssetInstancesResponse
 */
async function searchAssetInstances(request: SearchAssetInstancesRequest): SearchAssetInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAssetInstancesWithOptions(request, runtime);
}

model SearchMetaTablesRequest {
  appGuid?: string(name='AppGuid'),
  clusterId?: string(name='ClusterId'),
  dataSourceType?: string(name='DataSourceType'),
  entityType?: int32(name='EntityType'),
  keyword?: string(name='Keyword', description='This parameter is required.'),
  ownerId?: string(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  scope?: string(name='Scope'),
}

model SearchMetaTablesResponseBody = {
  data?: {
    dataEntityList?: [ 
      {
        clusterId?: string(name='ClusterId'),
        comment?: string(name='Comment'),
        databaseName?: string(name='DatabaseName'),
        entityType?: int32(name='EntityType'),
        envType?: int32(name='EnvType'),
        ownerId?: string(name='OwnerId'),
        projectId?: long(name='ProjectId'),
        projectName?: string(name='ProjectName'),
        tableGuid?: string(name='TableGuid'),
        tableName?: string(name='TableName'),
        tenantId?: long(name='TenantId'),
      }
    ](name='DataEntityList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model SearchMetaTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchMetaTablesResponseBody(name='body'),
}

/**
 * @param request SearchMetaTablesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchMetaTablesResponse
 */
async function searchMetaTablesWithOptions(request: SearchMetaTablesRequest, runtime: Util.RuntimeOptions): SearchMetaTablesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appGuid)) {
    query['AppGuid'] = request.appGuid;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    query['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.entityType)) {
    query['EntityType'] = request.entityType;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.scope)) {
    query['Scope'] = request.scope;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchMetaTables',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SearchMetaTablesRequest
 * @return SearchMetaTablesResponse
 */
async function searchMetaTables(request: SearchMetaTablesRequest): SearchMetaTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchMetaTablesWithOptions(request, runtime);
}

model SearchNodesByOutputRequest {
  outputs?: string(name='Outputs', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
}

model SearchNodesByOutputResponseBody = {
  data?: map[string]any(name='Data'),
  requestId?: string(name='RequestId'),
}

model SearchNodesByOutputResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchNodesByOutputResponseBody(name='body'),
}

/**
 * @param request SearchNodesByOutputRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchNodesByOutputResponse
 */
async function searchNodesByOutputWithOptions(request: SearchNodesByOutputRequest, runtime: Util.RuntimeOptions): SearchNodesByOutputResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.outputs)) {
    body['Outputs'] = request.outputs;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchNodesByOutput',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SearchNodesByOutputRequest
 * @return SearchNodesByOutputResponse
 */
async function searchNodesByOutput(request: SearchNodesByOutputRequest): SearchNodesByOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchNodesByOutputWithOptions(request, runtime);
}

model SetSuccessInstanceRequest {
  instanceId?: long(name='InstanceId', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
}

model SetSuccessInstanceResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model SetSuccessInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetSuccessInstanceResponseBody(name='body'),
}

/**
 * @param request SetSuccessInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetSuccessInstanceResponse
 */
async function setSuccessInstanceWithOptions(request: SetSuccessInstanceRequest, runtime: Util.RuntimeOptions): SetSuccessInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SetSuccessInstance',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SetSuccessInstanceRequest
 * @return SetSuccessInstanceResponse
 */
async function setSuccessInstance(request: SetSuccessInstanceRequest): SetSuccessInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return setSuccessInstanceWithOptions(request, runtime);
}

model SetSuccessTaskInstancesRequest {
  comment?: string(name='Comment'),
  ids?: [ long ](name='Ids'),
}

model SetSuccessTaskInstancesShrinkRequest {
  comment?: string(name='Comment'),
  idsShrink?: string(name='Ids'),
}

model SetSuccessTaskInstancesResponseBody = {
  requestId?: string(name='RequestId'),
  successInfo?: map[string]SuccessInfoValue(name='SuccessInfo'),
}

model SetSuccessTaskInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetSuccessTaskInstancesResponseBody(name='body'),
}

/**
 * @param tmpReq SetSuccessTaskInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetSuccessTaskInstancesResponse
 */
async function setSuccessTaskInstancesWithOptions(tmpReq: SetSuccessTaskInstancesRequest, runtime: Util.RuntimeOptions): SetSuccessTaskInstancesResponse {
  Util.validateModel(tmpReq);
  var request = new SetSuccessTaskInstancesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ids)) {
    request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, 'Ids', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.idsShrink)) {
    body['Ids'] = request.idsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SetSuccessTaskInstances',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SetSuccessTaskInstancesRequest
 * @return SetSuccessTaskInstancesResponse
 */
async function setSuccessTaskInstances(request: SetSuccessTaskInstancesRequest): SetSuccessTaskInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return setSuccessTaskInstancesWithOptions(request, runtime);
}

model StartDIJobRequest {
  DIJobId?: long(name='DIJobId', deprecated=true),
  forceToRerun?: boolean(name='ForceToRerun'),
  id?: long(name='Id'),
  realtimeStartSettings?: {
    failoverSettings?: {
      interval?: long(name='Interval', deprecated=true),
      upperLimit?: long(name='UpperLimit', deprecated=true),
    }(name='FailoverSettings', deprecated=true),
    startTime?: long(name='StartTime'),
  }(name='RealtimeStartSettings'),
}

model StartDIJobShrinkRequest {
  DIJobId?: long(name='DIJobId', deprecated=true),
  forceToRerun?: boolean(name='ForceToRerun'),
  id?: long(name='Id'),
  realtimeStartSettingsShrink?: string(name='RealtimeStartSettings'),
}

model StartDIJobResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StartDIJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartDIJobResponseBody(name='body'),
}

/**
 * @summary 启动数据集成任务
 *
 * @param tmpReq StartDIJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartDIJobResponse
 */
async function startDIJobWithOptions(tmpReq: StartDIJobRequest, runtime: Util.RuntimeOptions): StartDIJobResponse {
  Util.validateModel(tmpReq);
  var request = new StartDIJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.realtimeStartSettings)) {
    request.realtimeStartSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.realtimeStartSettings, 'RealtimeStartSettings', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartDIJob',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 启动数据集成任务
 *
 * @param request StartDIJobRequest
 * @return StartDIJobResponse
 */
async function startDIJob(request: StartDIJobRequest): StartDIJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return startDIJobWithOptions(request, runtime);
}

model StartWorkflowInstancesRequest {
  comment?: string(name='Comment'),
  ids?: [ long ](name='Ids', description='This parameter is required.'),
}

model StartWorkflowInstancesShrinkRequest {
  comment?: string(name='Comment'),
  idsShrink?: string(name='Ids', description='This parameter is required.'),
}

model StartWorkflowInstancesResponseBody = {
  requestId?: string(name='RequestId'),
  successInfo?: map[string]SuccessInfoValue(name='SuccessInfo'),
}

model StartWorkflowInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartWorkflowInstancesResponseBody(name='body'),
}

/**
 * @param tmpReq StartWorkflowInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartWorkflowInstancesResponse
 */
async function startWorkflowInstancesWithOptions(tmpReq: StartWorkflowInstancesRequest, runtime: Util.RuntimeOptions): StartWorkflowInstancesResponse {
  Util.validateModel(tmpReq);
  var request = new StartWorkflowInstancesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ids)) {
    request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, 'Ids', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.idsShrink)) {
    body['Ids'] = request.idsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartWorkflowInstances',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request StartWorkflowInstancesRequest
 * @return StartWorkflowInstancesResponse
 */
async function startWorkflowInstances(request: StartWorkflowInstancesRequest): StartWorkflowInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return startWorkflowInstancesWithOptions(request, runtime);
}

model StopDIJobRequest {
  DIJobId?: long(name='DIJobId', deprecated=true),
  id?: long(name='Id'),
  instanceId?: long(name='InstanceId'),
}

model StopDIJobResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StopDIJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopDIJobResponseBody(name='body'),
}

/**
 * @summary 中止数据集成任务
 *
 * @param request StopDIJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopDIJobResponse
 */
async function stopDIJobWithOptions(request: StopDIJobRequest, runtime: Util.RuntimeOptions): StopDIJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopDIJob',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 中止数据集成任务
 *
 * @param request StopDIJobRequest
 * @return StopDIJobResponse
 */
async function stopDIJob(request: StopDIJobRequest): StopDIJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopDIJobWithOptions(request, runtime);
}

model StopInstanceRequest {
  instanceId?: long(name='InstanceId', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
}

model StopInstanceResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model StopInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopInstanceResponseBody(name='body'),
}

/**
 * @param request StopInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopInstanceResponse
 */
async function stopInstanceWithOptions(request: StopInstanceRequest, runtime: Util.RuntimeOptions): StopInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopInstance',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request StopInstanceRequest
 * @return StopInstanceResponse
 */
async function stopInstance(request: StopInstanceRequest): StopInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopInstanceWithOptions(request, runtime);
}

model StopTaskInstancesRequest {
  comment?: string(name='Comment'),
  ids?: [ long ](name='Ids'),
}

model StopTaskInstancesShrinkRequest {
  comment?: string(name='Comment'),
  idsShrink?: string(name='Ids'),
}

model StopTaskInstancesResponseBody = {
  requestId?: string(name='RequestId'),
  successInfo?: map[string]SuccessInfoValue(name='SuccessInfo'),
}

model StopTaskInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopTaskInstancesResponseBody(name='body'),
}

/**
 * @param tmpReq StopTaskInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopTaskInstancesResponse
 */
async function stopTaskInstancesWithOptions(tmpReq: StopTaskInstancesRequest, runtime: Util.RuntimeOptions): StopTaskInstancesResponse {
  Util.validateModel(tmpReq);
  var request = new StopTaskInstancesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ids)) {
    request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, 'Ids', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.idsShrink)) {
    body['Ids'] = request.idsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopTaskInstances',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request StopTaskInstancesRequest
 * @return StopTaskInstancesResponse
 */
async function stopTaskInstances(request: StopTaskInstancesRequest): StopTaskInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopTaskInstancesWithOptions(request, runtime);
}

model StopWorkflowInstancesRequest {
  comment?: string(name='Comment'),
  ids?: [ long ](name='Ids', description='This parameter is required.'),
}

model StopWorkflowInstancesShrinkRequest {
  comment?: string(name='Comment'),
  idsShrink?: string(name='Ids', description='This parameter is required.'),
}

model StopWorkflowInstancesResponseBody = {
  requestId?: string(name='RequestId'),
  successInfo?: map[string]SuccessInfoValue(name='SuccessInfo'),
}

model StopWorkflowInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopWorkflowInstancesResponseBody(name='body'),
}

/**
 * @param tmpReq StopWorkflowInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopWorkflowInstancesResponse
 */
async function stopWorkflowInstancesWithOptions(tmpReq: StopWorkflowInstancesRequest, runtime: Util.RuntimeOptions): StopWorkflowInstancesResponse {
  Util.validateModel(tmpReq);
  var request = new StopWorkflowInstancesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ids)) {
    request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, 'Ids', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.idsShrink)) {
    body['Ids'] = request.idsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopWorkflowInstances',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request StopWorkflowInstancesRequest
 * @return StopWorkflowInstancesResponse
 */
async function stopWorkflowInstances(request: StopWorkflowInstancesRequest): StopWorkflowInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopWorkflowInstancesWithOptions(request, runtime);
}

model SubmitFileRequest {
  comment?: string(name='Comment'),
  fileId?: long(name='FileId', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  skipAllDeployFileExtensions?: boolean(name='SkipAllDeployFileExtensions'),
}

model SubmitFileResponseBody = {
  data?: long(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubmitFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SubmitFileResponseBody(name='body'),
}

/**
 * @param request SubmitFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitFileResponse
 */
async function submitFileWithOptions(request: SubmitFileRequest, runtime: Util.RuntimeOptions): SubmitFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  if (!Util.isUnset(request.skipAllDeployFileExtensions)) {
    body['SkipAllDeployFileExtensions'] = request.skipAllDeployFileExtensions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SubmitFile',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SubmitFileRequest
 * @return SubmitFileResponse
 */
async function submitFile(request: SubmitFileRequest): SubmitFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFileWithOptions(request, runtime);
}

model SuspendInstanceRequest {
  instanceId?: long(name='InstanceId', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
}

model SuspendInstanceResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model SuspendInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SuspendInstanceResponseBody(name='body'),
}

/**
 * @param request SuspendInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SuspendInstanceResponse
 */
async function suspendInstanceWithOptions(request: SuspendInstanceRequest, runtime: Util.RuntimeOptions): SuspendInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SuspendInstance',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SuspendInstanceRequest
 * @return SuspendInstanceResponse
 */
async function suspendInstance(request: SuspendInstanceRequest): SuspendInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return suspendInstanceWithOptions(request, runtime);
}

model SuspendTaskInstancesRequest {
  comment?: string(name='Comment'),
  ids?: [ long ](name='Ids'),
}

model SuspendTaskInstancesShrinkRequest {
  comment?: string(name='Comment'),
  idsShrink?: string(name='Ids'),
}

model SuspendTaskInstancesResponseBody = {
  requestId?: string(name='RequestId'),
  successInfo?: map[string]SuccessInfoValue(name='SuccessInfo'),
}

model SuspendTaskInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SuspendTaskInstancesResponseBody(name='body'),
}

/**
 * @param tmpReq SuspendTaskInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SuspendTaskInstancesResponse
 */
async function suspendTaskInstancesWithOptions(tmpReq: SuspendTaskInstancesRequest, runtime: Util.RuntimeOptions): SuspendTaskInstancesResponse {
  Util.validateModel(tmpReq);
  var request = new SuspendTaskInstancesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ids)) {
    request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, 'Ids', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.idsShrink)) {
    body['Ids'] = request.idsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SuspendTaskInstances',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SuspendTaskInstancesRequest
 * @return SuspendTaskInstancesResponse
 */
async function suspendTaskInstances(request: SuspendTaskInstancesRequest): SuspendTaskInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return suspendTaskInstancesWithOptions(request, runtime);
}

model TriggerSchedulerTaskInstanceRequest {
  envType?: string(name='EnvType'),
  taskId?: long(name='TaskId', description='This parameter is required.'),
  triggerTime?: long(name='TriggerTime', description='This parameter is required.'),
}

model TriggerSchedulerTaskInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model TriggerSchedulerTaskInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TriggerSchedulerTaskInstanceResponseBody(name='body'),
}

/**
 * @param request TriggerSchedulerTaskInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TriggerSchedulerTaskInstanceResponse
 */
async function triggerSchedulerTaskInstanceWithOptions(request: TriggerSchedulerTaskInstanceRequest, runtime: Util.RuntimeOptions): TriggerSchedulerTaskInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.envType)) {
    query['EnvType'] = request.envType;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.triggerTime)) {
    body['TriggerTime'] = request.triggerTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TriggerSchedulerTaskInstance',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request TriggerSchedulerTaskInstanceRequest
 * @return TriggerSchedulerTaskInstanceResponse
 */
async function triggerSchedulerTaskInstance(request: TriggerSchedulerTaskInstanceRequest): TriggerSchedulerTaskInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return triggerSchedulerTaskInstanceWithOptions(request, runtime);
}

model UpdateBaselineRequest {
  alertEnabled?: boolean(name='AlertEnabled'),
  alertMarginThreshold?: int32(name='AlertMarginThreshold'),
  alertSettings?: [ 
    {
      alertInterval?: int32(name='AlertInterval'),
      alertMaximum?: int32(name='AlertMaximum'),
      alertMethods?: [ string ](name='AlertMethods'),
      alertRecipient?: string(name='AlertRecipient'),
      alertRecipientType?: string(name='AlertRecipientType'),
      alertType?: string(name='AlertType'),
      baselineAlertEnabled?: boolean(name='BaselineAlertEnabled'),
      dingRobots?: [ 
        {
          atAll?: boolean(name='AtAll'),
          webUrl?: string(name='WebUrl'),
        }
      ](name='DingRobots'),
      silenceEndTime?: string(name='SilenceEndTime'),
      silenceStartTime?: string(name='SilenceStartTime'),
      topicTypes?: [ string ](name='TopicTypes'),
      webhooks?: [ string ](name='Webhooks'),
    }
  ](name='AlertSettings'),
  baselineId?: long(name='BaselineId'),
  baselineName?: string(name='BaselineName'),
  baselineType?: string(name='BaselineType'),
  enabled?: boolean(name='Enabled'),
  nodeIds?: string(name='NodeIds'),
  overtimeSettings?: [ 
    {
      cycle?: int32(name='Cycle'),
      time?: string(name='Time'),
    }
  ](name='OvertimeSettings'),
  owner?: string(name='Owner'),
  priority?: int32(name='Priority'),
  projectId?: long(name='ProjectId'),
  removeNodeIds?: string(name='RemoveNodeIds'),
}

model UpdateBaselineShrinkRequest {
  alertEnabled?: boolean(name='AlertEnabled'),
  alertMarginThreshold?: int32(name='AlertMarginThreshold'),
  alertSettingsShrink?: string(name='AlertSettings'),
  baselineId?: long(name='BaselineId'),
  baselineName?: string(name='BaselineName'),
  baselineType?: string(name='BaselineType'),
  enabled?: boolean(name='Enabled'),
  nodeIds?: string(name='NodeIds'),
  overtimeSettingsShrink?: string(name='OvertimeSettings'),
  owner?: string(name='Owner'),
  priority?: int32(name='Priority'),
  projectId?: long(name='ProjectId'),
  removeNodeIds?: string(name='RemoveNodeIds'),
}

model UpdateBaselineResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateBaselineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateBaselineResponseBody(name='body'),
}

/**
 * @summary 修改基线
 *
 * @param tmpReq UpdateBaselineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateBaselineResponse
 */
async function updateBaselineWithOptions(tmpReq: UpdateBaselineRequest, runtime: Util.RuntimeOptions): UpdateBaselineResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateBaselineShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.alertSettings)) {
    request.alertSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alertSettings, 'AlertSettings', 'json');
  }
  if (!Util.isUnset(tmpReq.overtimeSettings)) {
    request.overtimeSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.overtimeSettings, 'OvertimeSettings', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.alertEnabled)) {
    body['AlertEnabled'] = request.alertEnabled;
  }
  if (!Util.isUnset(request.alertMarginThreshold)) {
    body['AlertMarginThreshold'] = request.alertMarginThreshold;
  }
  if (!Util.isUnset(request.alertSettingsShrink)) {
    body['AlertSettings'] = request.alertSettingsShrink;
  }
  if (!Util.isUnset(request.baselineId)) {
    body['BaselineId'] = request.baselineId;
  }
  if (!Util.isUnset(request.baselineName)) {
    body['BaselineName'] = request.baselineName;
  }
  if (!Util.isUnset(request.baselineType)) {
    body['BaselineType'] = request.baselineType;
  }
  if (!Util.isUnset(request.enabled)) {
    body['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.nodeIds)) {
    body['NodeIds'] = request.nodeIds;
  }
  if (!Util.isUnset(request.overtimeSettingsShrink)) {
    body['OvertimeSettings'] = request.overtimeSettingsShrink;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.priority)) {
    body['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.removeNodeIds)) {
    body['RemoveNodeIds'] = request.removeNodeIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBaseline',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改基线
 *
 * @param request UpdateBaselineRequest
 * @return UpdateBaselineResponse
 */
async function updateBaseline(request: UpdateBaselineRequest): UpdateBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBaselineWithOptions(request, runtime);
}

model UpdateBusinessRequest {
  businessId?: long(name='BusinessId', description='This parameter is required.'),
  businessName?: string(name='BusinessName'),
  description?: string(name='Description'),
  owner?: string(name='Owner'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model UpdateBusinessResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateBusinessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateBusinessResponseBody(name='body'),
}

/**
 * @param request UpdateBusinessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateBusinessResponse
 */
async function updateBusinessWithOptions(request: UpdateBusinessRequest, runtime: Util.RuntimeOptions): UpdateBusinessResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.businessId)) {
    body['BusinessId'] = request.businessId;
  }
  if (!Util.isUnset(request.businessName)) {
    body['BusinessName'] = request.businessName;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBusiness',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateBusinessRequest
 * @return UpdateBusinessResponse
 */
async function updateBusiness(request: UpdateBusinessRequest): UpdateBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBusinessWithOptions(request, runtime);
}

model UpdateBusinessBaselineRequest {
  alertFlag?: boolean(name='AlertFlag'),
  alertInterval?: int32(name='AlertInterval'),
  alertTarget?: string(name='AlertTarget'),
  baselineDescription?: string(name='BaselineDescription'),
  baselineId?: long(name='BaselineId', description='This parameter is required.'),
  baselineName?: string(name='BaselineName'),
  errorRule?: string(name='ErrorRule'),
  expHour?: int32(name='ExpHour'),
  expMinu?: int32(name='ExpMinu'),
  hourExpDetail?: string(name='HourExpDetail'),
  hourSlaDetail?: string(name='HourSlaDetail'),
  maxAlertTimes?: int32(name='MaxAlertTimes'),
  owner?: string(name='Owner'),
  priority?: int32(name='Priority'),
  slaHour?: int32(name='SlaHour'),
  slaMinu?: int32(name='SlaMinu'),
  slowRule?: string(name='SlowRule'),
  useFlag?: boolean(name='UseFlag'),
}

model UpdateBusinessBaselineResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateBusinessBaselineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateBusinessBaselineResponseBody(name='body'),
}

/**
 * @param request UpdateBusinessBaselineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateBusinessBaselineResponse
 */
async function updateBusinessBaselineWithOptions(request: UpdateBusinessBaselineRequest, runtime: Util.RuntimeOptions): UpdateBusinessBaselineResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alertFlag)) {
    body['AlertFlag'] = request.alertFlag;
  }
  if (!Util.isUnset(request.alertInterval)) {
    body['AlertInterval'] = request.alertInterval;
  }
  if (!Util.isUnset(request.alertTarget)) {
    body['AlertTarget'] = request.alertTarget;
  }
  if (!Util.isUnset(request.baselineDescription)) {
    body['BaselineDescription'] = request.baselineDescription;
  }
  if (!Util.isUnset(request.baselineId)) {
    body['BaselineId'] = request.baselineId;
  }
  if (!Util.isUnset(request.baselineName)) {
    body['BaselineName'] = request.baselineName;
  }
  if (!Util.isUnset(request.errorRule)) {
    body['ErrorRule'] = request.errorRule;
  }
  if (!Util.isUnset(request.expHour)) {
    body['ExpHour'] = request.expHour;
  }
  if (!Util.isUnset(request.expMinu)) {
    body['ExpMinu'] = request.expMinu;
  }
  if (!Util.isUnset(request.hourExpDetail)) {
    body['HourExpDetail'] = request.hourExpDetail;
  }
  if (!Util.isUnset(request.hourSlaDetail)) {
    body['HourSlaDetail'] = request.hourSlaDetail;
  }
  if (!Util.isUnset(request.maxAlertTimes)) {
    body['MaxAlertTimes'] = request.maxAlertTimes;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.priority)) {
    body['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.slaHour)) {
    body['SlaHour'] = request.slaHour;
  }
  if (!Util.isUnset(request.slaMinu)) {
    body['SlaMinu'] = request.slaMinu;
  }
  if (!Util.isUnset(request.slowRule)) {
    body['SlowRule'] = request.slowRule;
  }
  if (!Util.isUnset(request.useFlag)) {
    body['UseFlag'] = request.useFlag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBusinessBaseline',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateBusinessBaselineRequest
 * @return UpdateBusinessBaselineResponse
 */
async function updateBusinessBaseline(request: UpdateBusinessBaselineRequest): UpdateBusinessBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBusinessBaselineWithOptions(request, runtime);
}

model UpdateDIAlarmRuleRequest {
  DIAlarmRuleId?: long(name='DIAlarmRuleId', deprecated=true),
  DIJobId?: long(name='DIJobId'),
  description?: string(name='Description'),
  enabled?: boolean(name='Enabled'),
  id?: long(name='Id'),
  metricType?: string(name='MetricType'),
  name?: string(name='Name'),
  notificationSettings?: {
    inhibitionInterval?: long(name='InhibitionInterval', deprecated=true),
    muteInterval?: long(name='MuteInterval'),
    notificationChannels?: [ 
      {
        channels?: [ string ](name='Channels'),
        severity?: string(name='Severity'),
      }
    ](name='NotificationChannels'),
    notificationReceivers?: [ 
      {
        receiverType?: string(name='ReceiverType'),
        receiverValues?: [ string ](name='ReceiverValues'),
      }
    ](name='NotificationReceivers'),
  }(name='NotificationSettings'),
  triggerConditions?: [ 
    {
      ddlReportTags?: [ string ](name='DdlReportTags', deprecated=true),
      ddlTypes?: [ string ](name='DdlTypes'),
      duration?: long(name='Duration'),
      severity?: string(name='Severity'),
      threshold?: long(name='Threshold'),
    }
  ](name='TriggerConditions'),
}

model UpdateDIAlarmRuleShrinkRequest {
  DIAlarmRuleId?: long(name='DIAlarmRuleId', deprecated=true),
  DIJobId?: long(name='DIJobId'),
  description?: string(name='Description'),
  enabled?: boolean(name='Enabled'),
  id?: long(name='Id'),
  metricType?: string(name='MetricType'),
  name?: string(name='Name'),
  notificationSettingsShrink?: string(name='NotificationSettings'),
  triggerConditionsShrink?: string(name='TriggerConditions'),
}

model UpdateDIAlarmRuleResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDIAlarmRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDIAlarmRuleResponseBody(name='body'),
}

/**
 * @summary 更新数据集成报警规则
 *
 * @param tmpReq UpdateDIAlarmRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDIAlarmRuleResponse
 */
async function updateDIAlarmRuleWithOptions(tmpReq: UpdateDIAlarmRuleRequest, runtime: Util.RuntimeOptions): UpdateDIAlarmRuleResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateDIAlarmRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.notificationSettings)) {
    request.notificationSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.notificationSettings, 'NotificationSettings', 'json');
  }
  if (!Util.isUnset(tmpReq.triggerConditions)) {
    request.triggerConditionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.triggerConditions, 'TriggerConditions', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDIAlarmRule',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新数据集成报警规则
 *
 * @param request UpdateDIAlarmRuleRequest
 * @return UpdateDIAlarmRuleResponse
 */
async function updateDIAlarmRule(request: UpdateDIAlarmRuleRequest): UpdateDIAlarmRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDIAlarmRuleWithOptions(request, runtime);
}

model UpdateDIJobRequest {
  DIJobId?: long(name='DIJobId', deprecated=true),
  description?: string(name='Description'),
  id?: long(name='Id'),
  jobSettings?: {
    channelSettings?: string(name='ChannelSettings'),
    columnDataTypeSettings?: [ 
      {
        destinationDataType?: string(name='DestinationDataType'),
        sourceDataType?: string(name='SourceDataType'),
      }
    ](name='ColumnDataTypeSettings'),
    cycleScheduleSettings?: {
      scheduleParameters?: string(name='ScheduleParameters'),
    }(name='CycleScheduleSettings'),
    ddlHandlingSettings?: [ 
      {
        action?: string(name='Action'),
        type?: string(name='Type'),
      }
    ](name='DdlHandlingSettings'),
    runtimeSettings?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='RuntimeSettings'),
  }(name='JobSettings'),
  projectId?: long(name='ProjectId'),
  resourceSettings?: {
    offlineResourceSettings?: {
      requestedCu?: double(name='RequestedCu'),
      resourceGroupIdentifier?: string(name='ResourceGroupIdentifier'),
    }(name='OfflineResourceSettings'),
    realtimeResourceSettings?: {
      requestedCu?: double(name='RequestedCu'),
      resourceGroupIdentifier?: string(name='ResourceGroupIdentifier'),
    }(name='RealtimeResourceSettings'),
    scheduleResourceSettings?: {
      requestedCu?: double(name='RequestedCu'),
      resourceGroupIdentifier?: string(name='ResourceGroupIdentifier'),
    }(name='ScheduleResourceSettings'),
  }(name='ResourceSettings'),
  tableMappings?: [ 
    {
      sourceObjectSelectionRules?: [ 
        {
          action?: string(name='Action'),
          expression?: string(name='Expression'),
          expressionType?: string(name='ExpressionType'),
          objectType?: string(name='ObjectType'),
        }
      ](name='SourceObjectSelectionRules'),
      transformationRules?: [ 
        {
          ruleActionType?: string(name='RuleActionType'),
          ruleName?: string(name='RuleName'),
          ruleTargetType?: string(name='RuleTargetType'),
        }
      ](name='TransformationRules'),
    }
  ](name='TableMappings'),
  transformationRules?: [ 
    {
      ruleActionType?: string(name='RuleActionType'),
      ruleExpression?: string(name='RuleExpression'),
      ruleName?: string(name='RuleName'),
      ruleTargetType?: string(name='RuleTargetType'),
    }
  ](name='TransformationRules'),
}

model UpdateDIJobShrinkRequest {
  DIJobId?: long(name='DIJobId', deprecated=true),
  description?: string(name='Description'),
  id?: long(name='Id'),
  jobSettingsShrink?: string(name='JobSettings'),
  projectId?: long(name='ProjectId'),
  resourceSettingsShrink?: string(name='ResourceSettings'),
  tableMappingsShrink?: string(name='TableMappings'),
  transformationRulesShrink?: string(name='TransformationRules'),
}

model UpdateDIJobResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDIJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDIJobResponseBody(name='body'),
}

/**
 * @summary 更新数据集成任务
 *
 * @param tmpReq UpdateDIJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDIJobResponse
 */
async function updateDIJobWithOptions(tmpReq: UpdateDIJobRequest, runtime: Util.RuntimeOptions): UpdateDIJobResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateDIJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.jobSettings)) {
    request.jobSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.jobSettings, 'JobSettings', 'json');
  }
  if (!Util.isUnset(tmpReq.resourceSettings)) {
    request.resourceSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceSettings, 'ResourceSettings', 'json');
  }
  if (!Util.isUnset(tmpReq.tableMappings)) {
    request.tableMappingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tableMappings, 'TableMappings', 'json');
  }
  if (!Util.isUnset(tmpReq.transformationRules)) {
    request.transformationRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.transformationRules, 'TransformationRules', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDIJob',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新数据集成任务
 *
 * @param request UpdateDIJobRequest
 * @return UpdateDIJobResponse
 */
async function updateDIJob(request: UpdateDIJobRequest): UpdateDIJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDIJobWithOptions(request, runtime);
}

model UpdateDataQualityEvaluationTaskRequest {
  dataQualityRules?: [ 
    {
      checkingConfig?: {
        referencedSamplesFilter?: string(name='ReferencedSamplesFilter'),
        thresholds?: {
          critical?: {
            operator?: string(name='Operator'),
            value?: string(name='Value'),
          }(name='Critical'),
          expected?: {
            operator?: string(name='Operator'),
            value?: string(name='Value'),
          }(name='Expected'),
          warned?: {
            operator?: string(name='Operator'),
            value?: string(name='Value'),
          }(name='Warned'),
        }(name='Thresholds'),
        type?: string(name='Type'),
      }(name='CheckingConfig'),
      description?: string(name='Description'),
      enabled?: boolean(name='Enabled'),
      errorHandlers?: [ 
        {
          errorDataFilter?: string(name='ErrorDataFilter'),
          type?: string(name='Type'),
        }
      ](name='ErrorHandlers'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      samplingConfig?: {
        metric?: string(name='Metric'),
        metricParameters?: string(name='MetricParameters'),
        samplingFilter?: string(name='SamplingFilter'),
        settingConfig?: string(name='SettingConfig'),
      }(name='SamplingConfig'),
      severity?: string(name='Severity'),
      templateCode?: string(name='TemplateCode'),
    }
  ](name='DataQualityRules'),
  dataSourceId?: long(name='DataSourceId'),
  description?: string(name='Description', description='质量监控任务描述'),
  hooks?: [ 
    {
      condition?: string(name='Condition', description='Hook触发条件'),
      type?: string(name='Type', description='Hook类型'),
    }
  ](name='Hooks', description='数据质量校验任务实例生命周期中的回调设置，目前只支持一个阻塞调度任务的Hook'),
  id?: long(name='Id', description='This parameter is required.'),
  name?: string(name='Name', description='质量监控任务名称'),
  notifications?: {
    condition?: string(name='Condition', description='通知触发条件'),
    notifications?: [ 
      {
        notificationChannels?: [ 
          {
            channels?: [ string ](name='Channels', description='通知方式'),
          }
        ](name='NotificationChannels', description='通知方式'),
        notificationReceivers?: [ 
          {
            extension?: string(name='Extension', description='扩展信息，格式为 json，例如钉钉机器人支持 at 所有人'),
            receiverType?: string(name='ReceiverType', description='告警接收人类型'),
            receiverValues?: [ string ](name='ReceiverValues', description='告警接收人'),
          }
        ](name='NotificationReceivers', description='告警接收人设置'),
      }
    ](name='Notifications', description='具体的消息通知设置'),
  }(name='Notifications', description='数据质量校验任务通知订阅配置'),
  projectId?: long(name='ProjectId', description='项目空间Id

This parameter is required.'),
  runtimeConf?: string(name='RuntimeConf', description='使用数据源时的一些设置，目前只支持指定EMR的yarn队列、采集EMR表时把SQL引擎指定为SPARK-SQL'),
  target?: {
    databaseType?: string(name='DatabaseType', description='表所属的数据库类型'),
    partitionSpec?: string(name='PartitionSpec', description='分区表的分区设置'),
    tableGuid?: string(name='TableGuid', description='表在数据地图中的唯一ID'),
  }(name='Target', description='参看 DataQualityTarget示例	数据质量校验任务的监控对象，参考 DataQualityTarget'),
  trigger?: {
    taskIds?: [ long ](name='TaskIds', description='具体指明哪些调度节点的实例执行成功后可以触发'),
    type?: string(name='Type', description='何种事件可以触发质量校验任务执行'),
  }(name='Trigger', description='数据质量校验任务的触发配置'),
}

model UpdateDataQualityEvaluationTaskShrinkRequest {
  dataQualityRulesShrink?: string(name='DataQualityRules'),
  dataSourceId?: long(name='DataSourceId'),
  description?: string(name='Description', description='质量监控任务描述'),
  hooksShrink?: string(name='Hooks', description='数据质量校验任务实例生命周期中的回调设置，目前只支持一个阻塞调度任务的Hook'),
  id?: long(name='Id', description='This parameter is required.'),
  name?: string(name='Name', description='质量监控任务名称'),
  notificationsShrink?: string(name='Notifications', description='数据质量校验任务通知订阅配置'),
  projectId?: long(name='ProjectId', description='项目空间Id

This parameter is required.'),
  runtimeConf?: string(name='RuntimeConf', description='使用数据源时的一些设置，目前只支持指定EMR的yarn队列、采集EMR表时把SQL引擎指定为SPARK-SQL'),
  targetShrink?: string(name='Target', description='参看 DataQualityTarget示例	数据质量校验任务的监控对象，参考 DataQualityTarget'),
  triggerShrink?: string(name='Trigger', description='数据质量校验任务的触发配置'),
}

model UpdateDataQualityEvaluationTaskResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDataQualityEvaluationTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDataQualityEvaluationTaskResponseBody(name='body'),
}

/**
 * @summary 更新数据质量校验任务
 *
 * @param tmpReq UpdateDataQualityEvaluationTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDataQualityEvaluationTaskResponse
 */
async function updateDataQualityEvaluationTaskWithOptions(tmpReq: UpdateDataQualityEvaluationTaskRequest, runtime: Util.RuntimeOptions): UpdateDataQualityEvaluationTaskResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateDataQualityEvaluationTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dataQualityRules)) {
    request.dataQualityRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dataQualityRules, 'DataQualityRules', 'json');
  }
  if (!Util.isUnset(tmpReq.hooks)) {
    request.hooksShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.hooks, 'Hooks', 'json');
  }
  if (!Util.isUnset(tmpReq.notifications)) {
    request.notificationsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.notifications, 'Notifications', 'json');
  }
  if (!Util.isUnset(tmpReq.target)) {
    request.targetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.target, 'Target', 'json');
  }
  if (!Util.isUnset(tmpReq.trigger)) {
    request.triggerShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.trigger, 'Trigger', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataQualityRulesShrink)) {
    body['DataQualityRules'] = request.dataQualityRulesShrink;
  }
  if (!Util.isUnset(request.dataSourceId)) {
    body['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.hooksShrink)) {
    body['Hooks'] = request.hooksShrink;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.notificationsShrink)) {
    body['Notifications'] = request.notificationsShrink;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.runtimeConf)) {
    body['RuntimeConf'] = request.runtimeConf;
  }
  if (!Util.isUnset(request.targetShrink)) {
    body['Target'] = request.targetShrink;
  }
  if (!Util.isUnset(request.triggerShrink)) {
    body['Trigger'] = request.triggerShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDataQualityEvaluationTask',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新数据质量校验任务
 *
 * @param request UpdateDataQualityEvaluationTaskRequest
 * @return UpdateDataQualityEvaluationTaskResponse
 */
async function updateDataQualityEvaluationTask(request: UpdateDataQualityEvaluationTaskRequest): UpdateDataQualityEvaluationTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDataQualityEvaluationTaskWithOptions(request, runtime);
}

model UpdateDataQualityRuleRequest {
  checkingConfig?: {
    referencedSamplesFilter?: string(name='ReferencedSamplesFilter'),
    thresholds?: {
      critical?: {
        expression?: string(name='Expression'),
        operator?: string(name='Operator'),
        value?: string(name='Value'),
      }(name='Critical'),
      expected?: {
        expression?: string(name='Expression'),
        operator?: string(name='Operator'),
        value?: string(name='Value'),
      }(name='Expected'),
      warned?: {
        expression?: string(name='Expression'),
        operator?: string(name='Operator'),
        value?: string(name='Value'),
      }(name='Warned'),
    }(name='Thresholds'),
    type?: string(name='Type'),
  }(name='CheckingConfig'),
  description?: string(name='Description'),
  enabled?: boolean(name='Enabled'),
  errorHandlers?: [ 
    {
      errorDataFilter?: string(name='ErrorDataFilter'),
      type?: string(name='Type'),
    }
  ](name='ErrorHandlers'),
  id?: long(name='Id', description='This parameter is required.'),
  name?: string(name='Name'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  samplingConfig?: {
    metric?: string(name='Metric'),
    metricParameters?: string(name='MetricParameters'),
    samplingFilter?: string(name='SamplingFilter'),
    settingConfig?: string(name='SettingConfig'),
  }(name='SamplingConfig'),
  severity?: string(name='Severity'),
  target?: {
    databaseType?: string(name='DatabaseType'),
    partitionSpec?: string(name='PartitionSpec'),
    tableGuid?: string(name='TableGuid'),
    type?: string(name='Type'),
  }(name='Target'),
  templateCode?: string(name='TemplateCode'),
}

model UpdateDataQualityRuleShrinkRequest {
  checkingConfigShrink?: string(name='CheckingConfig'),
  description?: string(name='Description'),
  enabled?: boolean(name='Enabled'),
  errorHandlersShrink?: string(name='ErrorHandlers'),
  id?: long(name='Id', description='This parameter is required.'),
  name?: string(name='Name'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  samplingConfigShrink?: string(name='SamplingConfig'),
  severity?: string(name='Severity'),
  targetShrink?: string(name='Target'),
  templateCode?: string(name='TemplateCode'),
}

model UpdateDataQualityRuleResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDataQualityRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDataQualityRuleResponseBody(name='body'),
}

/**
 * @summary 更新质量规则
 *
 * @param tmpReq UpdateDataQualityRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDataQualityRuleResponse
 */
async function updateDataQualityRuleWithOptions(tmpReq: UpdateDataQualityRuleRequest, runtime: Util.RuntimeOptions): UpdateDataQualityRuleResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateDataQualityRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.checkingConfig)) {
    request.checkingConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.checkingConfig, 'CheckingConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.errorHandlers)) {
    request.errorHandlersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.errorHandlers, 'ErrorHandlers', 'json');
  }
  if (!Util.isUnset(tmpReq.samplingConfig)) {
    request.samplingConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.samplingConfig, 'SamplingConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.target)) {
    request.targetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.target, 'Target', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkingConfigShrink)) {
    body['CheckingConfig'] = request.checkingConfigShrink;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.enabled)) {
    body['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.errorHandlersShrink)) {
    body['ErrorHandlers'] = request.errorHandlersShrink;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.samplingConfigShrink)) {
    body['SamplingConfig'] = request.samplingConfigShrink;
  }
  if (!Util.isUnset(request.severity)) {
    body['Severity'] = request.severity;
  }
  if (!Util.isUnset(request.targetShrink)) {
    body['Target'] = request.targetShrink;
  }
  if (!Util.isUnset(request.templateCode)) {
    body['TemplateCode'] = request.templateCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDataQualityRule',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新质量规则
 *
 * @param request UpdateDataQualityRuleRequest
 * @return UpdateDataQualityRuleResponse
 */
async function updateDataQualityRule(request: UpdateDataQualityRuleRequest): UpdateDataQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDataQualityRuleWithOptions(request, runtime);
}

model UpdateDataQualityRuleTemplateRequest {
  checkingConfig?: {
    referencedSamplesFilter?: string(name='ReferencedSamplesFilter'),
    type?: string(name='Type'),
  }(name='CheckingConfig'),
  code?: string(name='Code', description='This parameter is required.'),
  directoryPath?: string(name='DirectoryPath'),
  name?: string(name='Name'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  samplingConfig?: {
    metric?: string(name='Metric'),
    metricParameters?: string(name='MetricParameters'),
    settingConfig?: string(name='SettingConfig'),
  }(name='SamplingConfig'),
}

model UpdateDataQualityRuleTemplateShrinkRequest {
  checkingConfigShrink?: string(name='CheckingConfig'),
  code?: string(name='Code', description='This parameter is required.'),
  directoryPath?: string(name='DirectoryPath'),
  name?: string(name='Name'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  samplingConfigShrink?: string(name='SamplingConfig'),
}

model UpdateDataQualityRuleTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDataQualityRuleTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDataQualityRuleTemplateResponseBody(name='body'),
}

/**
 * @summary 更新规则模版
 *
 * @param tmpReq UpdateDataQualityRuleTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDataQualityRuleTemplateResponse
 */
async function updateDataQualityRuleTemplateWithOptions(tmpReq: UpdateDataQualityRuleTemplateRequest, runtime: Util.RuntimeOptions): UpdateDataQualityRuleTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateDataQualityRuleTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.checkingConfig)) {
    request.checkingConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.checkingConfig, 'CheckingConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.samplingConfig)) {
    request.samplingConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.samplingConfig, 'SamplingConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkingConfigShrink)) {
    body['CheckingConfig'] = request.checkingConfigShrink;
  }
  if (!Util.isUnset(request.code)) {
    body['Code'] = request.code;
  }
  if (!Util.isUnset(request.directoryPath)) {
    body['DirectoryPath'] = request.directoryPath;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.samplingConfigShrink)) {
    body['SamplingConfig'] = request.samplingConfigShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDataQualityRuleTemplate',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新规则模版
 *
 * @param request UpdateDataQualityRuleTemplateRequest
 * @return UpdateDataQualityRuleTemplateResponse
 */
async function updateDataQualityRuleTemplate(request: UpdateDataQualityRuleTemplateRequest): UpdateDataQualityRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDataQualityRuleTemplateWithOptions(request, runtime);
}

model UpdateDataSourceRequest {
  content?: string(name='Content'),
  dataSourceId?: long(name='DataSourceId', description='This parameter is required.'),
  description?: string(name='Description'),
  envType?: int32(name='EnvType'),
  operator?: string(name='Operator'),
  status?: string(name='Status'),
}

model UpdateDataSourceResponseBody = {
  data?: boolean(name='Data'),
  httpStatusCode?: string(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDataSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDataSourceResponseBody(name='body'),
}

/**
 * @param request UpdateDataSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDataSourceResponse
 */
async function updateDataSourceWithOptions(request: UpdateDataSourceRequest, runtime: Util.RuntimeOptions): UpdateDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.dataSourceId)) {
    query['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.envType)) {
    query['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDataSource',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'PUT',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateDataSourceRequest
 * @return UpdateDataSourceResponse
 */
async function updateDataSource(request: UpdateDataSourceRequest): UpdateDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDataSourceWithOptions(request, runtime);
}

model UpdateFileRequest {
  advancedSettings?: string(name='AdvancedSettings'),
  applyScheduleImmediately?: boolean(name='ApplyScheduleImmediately'),
  autoParsing?: boolean(name='AutoParsing'),
  autoRerunIntervalMillis?: int32(name='AutoRerunIntervalMillis'),
  autoRerunTimes?: int32(name='AutoRerunTimes'),
  connectionName?: string(name='ConnectionName'),
  content?: string(name='Content'),
  cronExpress?: string(name='CronExpress'),
  cycleType?: string(name='CycleType'),
  dependentNodeIdList?: string(name='DependentNodeIdList'),
  dependentType?: string(name='DependentType'),
  endEffectDate?: long(name='EndEffectDate'),
  fileDescription?: string(name='FileDescription'),
  fileFolderPath?: string(name='FileFolderPath'),
  fileId?: long(name='FileId', description='This parameter is required.'),
  fileName?: string(name='FileName'),
  ignoreParentSkipRunningProperty?: boolean(name='IgnoreParentSkipRunningProperty'),
  imageId?: string(name='ImageId'),
  inputList?: string(name='InputList'),
  inputParameters?: string(name='InputParameters'),
  outputList?: string(name='OutputList'),
  outputParameters?: string(name='OutputParameters'),
  owner?: string(name='Owner'),
  paraValue?: string(name='ParaValue'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  rerunMode?: string(name='RerunMode'),
  resourceGroupIdentifier?: string(name='ResourceGroupIdentifier'),
  schedulerType?: string(name='SchedulerType'),
  startEffectDate?: long(name='StartEffectDate'),
  startImmediately?: boolean(name='StartImmediately'),
  stop?: boolean(name='Stop'),
  timeout?: int32(name='Timeout'),
}

model UpdateFileResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFileResponseBody(name='body'),
}

/**
 * @param request UpdateFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFileResponse
 */
async function updateFileWithOptions(request: UpdateFileRequest, runtime: Util.RuntimeOptions): UpdateFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.advancedSettings)) {
    body['AdvancedSettings'] = request.advancedSettings;
  }
  if (!Util.isUnset(request.applyScheduleImmediately)) {
    body['ApplyScheduleImmediately'] = request.applyScheduleImmediately;
  }
  if (!Util.isUnset(request.autoParsing)) {
    body['AutoParsing'] = request.autoParsing;
  }
  if (!Util.isUnset(request.autoRerunIntervalMillis)) {
    body['AutoRerunIntervalMillis'] = request.autoRerunIntervalMillis;
  }
  if (!Util.isUnset(request.autoRerunTimes)) {
    body['AutoRerunTimes'] = request.autoRerunTimes;
  }
  if (!Util.isUnset(request.connectionName)) {
    body['ConnectionName'] = request.connectionName;
  }
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.cronExpress)) {
    body['CronExpress'] = request.cronExpress;
  }
  if (!Util.isUnset(request.cycleType)) {
    body['CycleType'] = request.cycleType;
  }
  if (!Util.isUnset(request.dependentNodeIdList)) {
    body['DependentNodeIdList'] = request.dependentNodeIdList;
  }
  if (!Util.isUnset(request.dependentType)) {
    body['DependentType'] = request.dependentType;
  }
  if (!Util.isUnset(request.endEffectDate)) {
    body['EndEffectDate'] = request.endEffectDate;
  }
  if (!Util.isUnset(request.fileDescription)) {
    body['FileDescription'] = request.fileDescription;
  }
  if (!Util.isUnset(request.fileFolderPath)) {
    body['FileFolderPath'] = request.fileFolderPath;
  }
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.ignoreParentSkipRunningProperty)) {
    body['IgnoreParentSkipRunningProperty'] = request.ignoreParentSkipRunningProperty;
  }
  if (!Util.isUnset(request.imageId)) {
    body['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.inputList)) {
    body['InputList'] = request.inputList;
  }
  if (!Util.isUnset(request.inputParameters)) {
    body['InputParameters'] = request.inputParameters;
  }
  if (!Util.isUnset(request.outputList)) {
    body['OutputList'] = request.outputList;
  }
  if (!Util.isUnset(request.outputParameters)) {
    body['OutputParameters'] = request.outputParameters;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.paraValue)) {
    body['ParaValue'] = request.paraValue;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  if (!Util.isUnset(request.rerunMode)) {
    body['RerunMode'] = request.rerunMode;
  }
  if (!Util.isUnset(request.resourceGroupIdentifier)) {
    body['ResourceGroupIdentifier'] = request.resourceGroupIdentifier;
  }
  if (!Util.isUnset(request.schedulerType)) {
    body['SchedulerType'] = request.schedulerType;
  }
  if (!Util.isUnset(request.startEffectDate)) {
    body['StartEffectDate'] = request.startEffectDate;
  }
  if (!Util.isUnset(request.startImmediately)) {
    body['StartImmediately'] = request.startImmediately;
  }
  if (!Util.isUnset(request.stop)) {
    body['Stop'] = request.stop;
  }
  if (!Util.isUnset(request.timeout)) {
    body['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFile',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateFileRequest
 * @return UpdateFileResponse
 */
async function updateFile(request: UpdateFileRequest): UpdateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFileWithOptions(request, runtime);
}

model UpdateFolderRequest {
  folderId?: string(name='FolderId', description='This parameter is required.'),
  folderName?: string(name='FolderName', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model UpdateFolderResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateFolderResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFolderResponseBody(name='body'),
}

/**
 * @param request UpdateFolderRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFolderResponse
 */
async function updateFolderWithOptions(request: UpdateFolderRequest, runtime: Util.RuntimeOptions): UpdateFolderResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.folderId)) {
    body['FolderId'] = request.folderId;
  }
  if (!Util.isUnset(request.folderName)) {
    body['FolderName'] = request.folderName;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFolder',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateFolderRequest
 * @return UpdateFolderResponse
 */
async function updateFolder(request: UpdateFolderRequest): UpdateFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFolderWithOptions(request, runtime);
}

model UpdateFunctionRequest {
  id?: long(name='Id', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  spec?: string(name='Spec', description='This parameter is required.'),
}

model UpdateFunctionResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFunctionResponseBody(name='body'),
}

/**
 * @summary 更新udf函数
 *
 * @param request UpdateFunctionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFunctionResponse
 */
async function updateFunctionWithOptions(request: UpdateFunctionRequest, runtime: Util.RuntimeOptions): UpdateFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.spec)) {
    body['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFunction',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新udf函数
 *
 * @param request UpdateFunctionRequest
 * @return UpdateFunctionResponse
 */
async function updateFunction(request: UpdateFunctionRequest): UpdateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFunctionWithOptions(request, runtime);
}

model UpdateIDEEventResultRequest {
  checkResult?: string(name='CheckResult'),
  checkResultTip?: string(name='CheckResultTip'),
  extensionCode?: string(name='ExtensionCode'),
  messageId?: string(name='MessageId', description='扩展点消息UUID'),
}

model UpdateIDEEventResultResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIDEEventResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateIDEEventResultResponseBody(name='body'),
}

/**
 * @summary 回调扩展点消息的检查结果
 *
 * @param request UpdateIDEEventResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateIDEEventResultResponse
 */
async function updateIDEEventResultWithOptions(request: UpdateIDEEventResultRequest, runtime: Util.RuntimeOptions): UpdateIDEEventResultResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkResult)) {
    body['CheckResult'] = request.checkResult;
  }
  if (!Util.isUnset(request.checkResultTip)) {
    body['CheckResultTip'] = request.checkResultTip;
  }
  if (!Util.isUnset(request.extensionCode)) {
    body['ExtensionCode'] = request.extensionCode;
  }
  if (!Util.isUnset(request.messageId)) {
    body['MessageId'] = request.messageId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIDEEventResult',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 回调扩展点消息的检查结果
 *
 * @param request UpdateIDEEventResultRequest
 * @return UpdateIDEEventResultResponse
 */
async function updateIDEEventResult(request: UpdateIDEEventResultRequest): UpdateIDEEventResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIDEEventResultWithOptions(request, runtime);
}

model UpdateMetaCollectionRequest {
  comment?: string(name='Comment'),
  name?: string(name='Name'),
  qualifiedName?: string(name='QualifiedName', description='This parameter is required.'),
}

model UpdateMetaCollectionResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  status?: boolean(name='Status'),
  success?: boolean(name='Success'),
}

model UpdateMetaCollectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMetaCollectionResponseBody(name='body'),
}

/**
 * @summary 更新 collection
 *
 * @param request UpdateMetaCollectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMetaCollectionResponse
 */
async function updateMetaCollectionWithOptions(request: UpdateMetaCollectionRequest, runtime: Util.RuntimeOptions): UpdateMetaCollectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.qualifiedName)) {
    query['QualifiedName'] = request.qualifiedName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMetaCollection',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新 collection
 *
 * @param request UpdateMetaCollectionRequest
 * @return UpdateMetaCollectionResponse
 */
async function updateMetaCollection(request: UpdateMetaCollectionRequest): UpdateMetaCollectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMetaCollectionWithOptions(request, runtime);
}

model UpdateMetaTableRequest {
  caption?: string(name='Caption'),
  categoryId?: long(name='CategoryId'),
  tableGuid?: string(name='TableGuid', description='This parameter is required.'),
  visibility?: int32(name='Visibility'),
}

model UpdateMetaTableResponseBody = {
  requestId?: string(name='RequestId'),
  updateResult?: boolean(name='UpdateResult'),
}

model UpdateMetaTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMetaTableResponseBody(name='body'),
}

/**
 * @param request UpdateMetaTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMetaTableResponse
 */
async function updateMetaTableWithOptions(request: UpdateMetaTableRequest, runtime: Util.RuntimeOptions): UpdateMetaTableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caption)) {
    query['Caption'] = request.caption;
  }
  if (!Util.isUnset(request.categoryId)) {
    query['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.tableGuid)) {
    query['TableGuid'] = request.tableGuid;
  }
  if (!Util.isUnset(request.visibility)) {
    query['Visibility'] = request.visibility;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMetaTable',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateMetaTableRequest
 * @return UpdateMetaTableResponse
 */
async function updateMetaTable(request: UpdateMetaTableRequest): UpdateMetaTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMetaTableWithOptions(request, runtime);
}

model UpdateMetaTableIntroWikiRequest {
  content?: string(name='Content', description='This parameter is required.'),
  tableGuid?: string(name='TableGuid', description='This parameter is required.'),
}

model UpdateMetaTableIntroWikiResponseBody = {
  requestId?: string(name='RequestId'),
  updateResult?: boolean(name='UpdateResult'),
}

model UpdateMetaTableIntroWikiResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMetaTableIntroWikiResponseBody(name='body'),
}

/**
 * @param request UpdateMetaTableIntroWikiRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMetaTableIntroWikiResponse
 */
async function updateMetaTableIntroWikiWithOptions(request: UpdateMetaTableIntroWikiRequest, runtime: Util.RuntimeOptions): UpdateMetaTableIntroWikiResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tableGuid)) {
    query['TableGuid'] = request.tableGuid;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMetaTableIntroWiki',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateMetaTableIntroWikiRequest
 * @return UpdateMetaTableIntroWikiResponse
 */
async function updateMetaTableIntroWiki(request: UpdateMetaTableIntroWikiRequest): UpdateMetaTableIntroWikiResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMetaTableIntroWikiWithOptions(request, runtime);
}

model UpdateNodeRequest {
  id?: long(name='Id', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  spec?: string(name='Spec', description='This parameter is required.'),
}

model UpdateNodeResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateNodeResponseBody(name='body'),
}

/**
 * @summary 更新节点
 *
 * @param request UpdateNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNodeResponse
 */
async function updateNodeWithOptions(request: UpdateNodeRequest, runtime: Util.RuntimeOptions): UpdateNodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.spec)) {
    body['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNode',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新节点
 *
 * @param request UpdateNodeRequest
 * @return UpdateNodeResponse
 */
async function updateNode(request: UpdateNodeRequest): UpdateNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNodeWithOptions(request, runtime);
}

model UpdateNodeOwnerRequest {
  nodeId?: long(name='NodeId', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
  userId?: string(name='UserId', description='This parameter is required.'),
}

model UpdateNodeOwnerResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateNodeOwnerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateNodeOwnerResponseBody(name='body'),
}

/**
 * @param request UpdateNodeOwnerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNodeOwnerResponse
 */
async function updateNodeOwnerWithOptions(request: UpdateNodeOwnerRequest, runtime: Util.RuntimeOptions): UpdateNodeOwnerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNodeOwner',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateNodeOwnerRequest
 * @return UpdateNodeOwnerResponse
 */
async function updateNodeOwner(request: UpdateNodeOwnerRequest): UpdateNodeOwnerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNodeOwnerWithOptions(request, runtime);
}

model UpdateNodeQuotaRequest {
  nodeIds?: string(name='NodeIds', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
  quota?: string(name='Quota', description='This parameter is required.'),
  refreshTaskInstance?: boolean(name='RefreshTaskInstance'),
}

model UpdateNodeQuotaResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateNodeQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateNodeQuotaResponseBody(name='body'),
}

/**
 * @summary 修改节点quota
 *
 * @param request UpdateNodeQuotaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNodeQuotaResponse
 */
async function updateNodeQuotaWithOptions(request: UpdateNodeQuotaRequest, runtime: Util.RuntimeOptions): UpdateNodeQuotaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nodeIds)) {
    query['NodeIds'] = request.nodeIds;
  }
  if (!Util.isUnset(request.projectEnv)) {
    query['ProjectEnv'] = request.projectEnv;
  }
  if (!Util.isUnset(request.quota)) {
    query['Quota'] = request.quota;
  }
  if (!Util.isUnset(request.refreshTaskInstance)) {
    query['RefreshTaskInstance'] = request.refreshTaskInstance;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNodeQuota',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改节点quota
 *
 * @param request UpdateNodeQuotaRequest
 * @return UpdateNodeQuotaResponse
 */
async function updateNodeQuota(request: UpdateNodeQuotaRequest): UpdateNodeQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNodeQuotaWithOptions(request, runtime);
}

model UpdateNodeRunModeRequest {
  comment?: string(name='Comment'),
  nodeId?: long(name='NodeId', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
  schedulerType?: int32(name='SchedulerType', description='This parameter is required.'),
}

model UpdateNodeRunModeResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateNodeRunModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateNodeRunModeResponseBody(name='body'),
}

/**
 * @param request UpdateNodeRunModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNodeRunModeResponse
 */
async function updateNodeRunModeWithOptions(request: UpdateNodeRunModeRequest, runtime: Util.RuntimeOptions): UpdateNodeRunModeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  if (!Util.isUnset(request.schedulerType)) {
    body['SchedulerType'] = request.schedulerType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNodeRunMode',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateNodeRunModeRequest
 * @return UpdateNodeRunModeResponse
 */
async function updateNodeRunMode(request: UpdateNodeRunModeRequest): UpdateNodeRunModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNodeRunModeWithOptions(request, runtime);
}

model UpdateNodeStatisticRequest {
  avgCost?: int32(name='AvgCost', description='This parameter is required.'),
  expireTime?: string(name='ExpireTime'),
  nodeIds?: string(name='NodeIds', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
}

model UpdateNodeStatisticResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateNodeStatisticResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateNodeStatisticResponseBody(name='body'),
}

/**
 * @param request UpdateNodeStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNodeStatisticResponse
 */
async function updateNodeStatisticWithOptions(request: UpdateNodeStatisticRequest, runtime: Util.RuntimeOptions): UpdateNodeStatisticResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.avgCost)) {
    body['AvgCost'] = request.avgCost;
  }
  if (!Util.isUnset(request.expireTime)) {
    body['ExpireTime'] = request.expireTime;
  }
  if (!Util.isUnset(request.nodeIds)) {
    body['NodeIds'] = request.nodeIds;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNodeStatistic',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateNodeStatisticRequest
 * @return UpdateNodeStatisticResponse
 */
async function updateNodeStatistic(request: UpdateNodeStatisticRequest): UpdateNodeStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNodeStatisticWithOptions(request, runtime);
}

model UpdateProjectRequest {
  callerApp?: string(name='CallerApp'),
  disableDevelopment?: boolean(name='DisableDevelopment'),
  displayName?: string(name='DisplayName'),
  enableChangeNodeOwner?: boolean(name='EnableChangeNodeOwner'),
  isAllowDownload?: boolean(name='IsAllowDownload'),
  operator?: string(name='Operator'),
  projectDesc?: string(name='ProjectDesc'),
  projectId?: long(name='ProjectId'),
  projectName?: string(name='ProjectName'),
  projectOwnerBaseId?: string(name='ProjectOwnerBaseId'),
  status?: string(name='Status'),
}

model UpdateProjectResponseBody = {
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateProjectResponseBody(name='body'),
}

/**
 * @summary 更新项目
 *
 * @param request UpdateProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateProjectResponse
 */
async function updateProjectWithOptions(request: UpdateProjectRequest, runtime: Util.RuntimeOptions): UpdateProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.callerApp)) {
    query['CallerApp'] = request.callerApp;
  }
  if (!Util.isUnset(request.disableDevelopment)) {
    query['DisableDevelopment'] = request.disableDevelopment;
  }
  if (!Util.isUnset(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.enableChangeNodeOwner)) {
    query['EnableChangeNodeOwner'] = request.enableChangeNodeOwner;
  }
  if (!Util.isUnset(request.isAllowDownload)) {
    query['IsAllowDownload'] = request.isAllowDownload;
  }
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.projectDesc)) {
    query['ProjectDesc'] = request.projectDesc;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.projectOwnerBaseId)) {
    query['ProjectOwnerBaseId'] = request.projectOwnerBaseId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProject',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新项目
 *
 * @param request UpdateProjectRequest
 * @return UpdateProjectResponse
 */
async function updateProject(request: UpdateProjectRequest): UpdateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProjectWithOptions(request, runtime);
}

model UpdateQualityFollowerRequest {
  alarmMode?: int32(name='AlarmMode', description='This parameter is required.'),
  follower?: string(name='Follower', description='This parameter is required.'),
  followerId?: long(name='FollowerId', description='This parameter is required.'),
  projectId?: long(name='ProjectId'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
}

model UpdateQualityFollowerResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateQualityFollowerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateQualityFollowerResponseBody(name='body'),
}

/**
 * @param request UpdateQualityFollowerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateQualityFollowerResponse
 */
async function updateQualityFollowerWithOptions(request: UpdateQualityFollowerRequest, runtime: Util.RuntimeOptions): UpdateQualityFollowerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alarmMode)) {
    body['AlarmMode'] = request.alarmMode;
  }
  if (!Util.isUnset(request.follower)) {
    body['Follower'] = request.follower;
  }
  if (!Util.isUnset(request.followerId)) {
    body['FollowerId'] = request.followerId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateQualityFollower',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateQualityFollowerRequest
 * @return UpdateQualityFollowerResponse
 */
async function updateQualityFollower(request: UpdateQualityFollowerRequest): UpdateQualityFollowerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateQualityFollowerWithOptions(request, runtime);
}

model UpdateQualityRuleRequest {
  blockType?: int32(name='BlockType'),
  checker?: int32(name='Checker'),
  comment?: string(name='Comment'),
  criticalThreshold?: string(name='CriticalThreshold'),
  entityId?: long(name='EntityId'),
  expectValue?: string(name='ExpectValue'),
  id?: long(name='Id', description='This parameter is required.'),
  methodName?: string(name='MethodName'),
  openSwitch?: boolean(name='OpenSwitch', description='This parameter is required.'),
  operator?: string(name='Operator'),
  predictType?: int32(name='PredictType'),
  projectId?: long(name='ProjectId'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
  property?: string(name='Property'),
  propertyType?: string(name='PropertyType'),
  ruleName?: string(name='RuleName'),
  ruleType?: int32(name='RuleType'),
  templateId?: int32(name='TemplateId'),
  trend?: string(name='Trend'),
  warningThreshold?: string(name='WarningThreshold'),
  whereCondition?: string(name='WhereCondition'),
}

model UpdateQualityRuleResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateQualityRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateQualityRuleResponseBody(name='body'),
}

/**
 * @param request UpdateQualityRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateQualityRuleResponse
 */
async function updateQualityRuleWithOptions(request: UpdateQualityRuleRequest, runtime: Util.RuntimeOptions): UpdateQualityRuleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.blockType)) {
    body['BlockType'] = request.blockType;
  }
  if (!Util.isUnset(request.checker)) {
    body['Checker'] = request.checker;
  }
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.criticalThreshold)) {
    body['CriticalThreshold'] = request.criticalThreshold;
  }
  if (!Util.isUnset(request.entityId)) {
    body['EntityId'] = request.entityId;
  }
  if (!Util.isUnset(request.expectValue)) {
    body['ExpectValue'] = request.expectValue;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.methodName)) {
    body['MethodName'] = request.methodName;
  }
  if (!Util.isUnset(request.openSwitch)) {
    body['OpenSwitch'] = request.openSwitch;
  }
  if (!Util.isUnset(request.operator)) {
    body['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.predictType)) {
    body['PredictType'] = request.predictType;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.property)) {
    body['Property'] = request.property;
  }
  if (!Util.isUnset(request.propertyType)) {
    body['PropertyType'] = request.propertyType;
  }
  if (!Util.isUnset(request.ruleName)) {
    body['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleType)) {
    body['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.trend)) {
    body['Trend'] = request.trend;
  }
  if (!Util.isUnset(request.warningThreshold)) {
    body['WarningThreshold'] = request.warningThreshold;
  }
  if (!Util.isUnset(request.whereCondition)) {
    body['WhereCondition'] = request.whereCondition;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateQualityRule',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateQualityRuleRequest
 * @return UpdateQualityRuleResponse
 */
async function updateQualityRule(request: UpdateQualityRuleRequest): UpdateQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateQualityRuleWithOptions(request, runtime);
}

model UpdateRemindRequest {
  alertInterval?: int32(name='AlertInterval'),
  alertMethods?: string(name='AlertMethods'),
  alertTargets?: string(name='AlertTargets'),
  alertUnit?: string(name='AlertUnit'),
  baselineIds?: string(name='BaselineIds'),
  bizProcessIds?: string(name='BizProcessIds'),
  detail?: string(name='Detail'),
  dndEnd?: string(name='DndEnd'),
  maxAlertTimes?: int32(name='MaxAlertTimes'),
  nodeIds?: string(name='NodeIds'),
  projectId?: long(name='ProjectId'),
  remindId?: long(name='RemindId', description='This parameter is required.'),
  remindName?: string(name='RemindName'),
  remindType?: string(name='RemindType'),
  remindUnit?: string(name='RemindUnit'),
  robotUrls?: string(name='RobotUrls'),
  useFlag?: boolean(name='UseFlag'),
}

model UpdateRemindResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateRemindResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRemindResponseBody(name='body'),
}

/**
 * @param request UpdateRemindRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRemindResponse
 */
async function updateRemindWithOptions(request: UpdateRemindRequest, runtime: Util.RuntimeOptions): UpdateRemindResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alertInterval)) {
    body['AlertInterval'] = request.alertInterval;
  }
  if (!Util.isUnset(request.alertMethods)) {
    body['AlertMethods'] = request.alertMethods;
  }
  if (!Util.isUnset(request.alertTargets)) {
    body['AlertTargets'] = request.alertTargets;
  }
  if (!Util.isUnset(request.alertUnit)) {
    body['AlertUnit'] = request.alertUnit;
  }
  if (!Util.isUnset(request.baselineIds)) {
    body['BaselineIds'] = request.baselineIds;
  }
  if (!Util.isUnset(request.bizProcessIds)) {
    body['BizProcessIds'] = request.bizProcessIds;
  }
  if (!Util.isUnset(request.detail)) {
    body['Detail'] = request.detail;
  }
  if (!Util.isUnset(request.dndEnd)) {
    body['DndEnd'] = request.dndEnd;
  }
  if (!Util.isUnset(request.maxAlertTimes)) {
    body['MaxAlertTimes'] = request.maxAlertTimes;
  }
  if (!Util.isUnset(request.nodeIds)) {
    body['NodeIds'] = request.nodeIds;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.remindId)) {
    body['RemindId'] = request.remindId;
  }
  if (!Util.isUnset(request.remindName)) {
    body['RemindName'] = request.remindName;
  }
  if (!Util.isUnset(request.remindType)) {
    body['RemindType'] = request.remindType;
  }
  if (!Util.isUnset(request.remindUnit)) {
    body['RemindUnit'] = request.remindUnit;
  }
  if (!Util.isUnset(request.robotUrls)) {
    body['RobotUrls'] = request.robotUrls;
  }
  if (!Util.isUnset(request.useFlag)) {
    body['UseFlag'] = request.useFlag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRemind',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateRemindRequest
 * @return UpdateRemindResponse
 */
async function updateRemind(request: UpdateRemindRequest): UpdateRemindResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRemindWithOptions(request, runtime);
}

model UpdateResourceRequest {
  id?: long(name='Id', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  spec?: string(name='Spec', description='This parameter is required.'),
}

model UpdateResourceResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateResourceResponseBody(name='body'),
}

/**
 * @summary 更新资源文件
 *
 * @param request UpdateResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateResourceResponse
 */
async function updateResourceWithOptions(request: UpdateResourceRequest, runtime: Util.RuntimeOptions): UpdateResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.spec)) {
    body['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResource',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新资源文件
 *
 * @param request UpdateResourceRequest
 * @return UpdateResourceResponse
 */
async function updateResource(request: UpdateResourceRequest): UpdateResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateResourceWithOptions(request, runtime);
}

model UpdateTaskRequest {
  clientUniqueCode?: string(name='ClientUniqueCode'),
  dataSource?: {
    name?: string(name='Name'),
  }(name='DataSource'),
  dependencies?: [ 
    {
      type?: string(name='Type', description='This parameter is required.'),
      upstreamOutput?: string(name='UpstreamOutput'),
      upstreamTaskId?: long(name='UpstreamTaskId'),
    }
  ](name='Dependencies'),
  description?: string(name='Description'),
  envType?: string(name='EnvType'),
  id?: long(name='Id', description='This parameter is required.'),
  inputs?: {
    variables?: [ 
      {
        name?: string(name='Name'),
        type?: string(name='Type', description='This parameter is required.'),
        value?: string(name='Value'),
      }
    ](name='Variables'),
  }(name='Inputs'),
  instanceMode?: string(name='InstanceMode'),
  name?: string(name='Name', description='This parameter is required.'),
  outputs?: {
    taskOutputs?: [ 
      {
        output?: string(name='Output'),
      }
    ](name='TaskOutputs'),
    variables?: [ 
      {
        name?: string(name='Name'),
        type?: string(name='Type', description='This parameter is required.'),
        value?: string(name='Value'),
      }
    ](name='Variables'),
  }(name='Outputs'),
  owner?: string(name='Owner', description='This parameter is required.'),
  rerunInterval?: int32(name='RerunInterval'),
  rerunMode?: string(name='RerunMode', description='This parameter is required.'),
  rerunTimes?: int32(name='RerunTimes'),
  runtimeResource?: {
    cu?: string(name='Cu'),
    image?: string(name='Image'),
    resourceGroupId?: string(name='ResourceGroupId', description='This parameter is required.'),
  }(name='RuntimeResource', description='This parameter is required.'),
  script?: {
    content?: string(name='Content'),
    parameters?: string(name='Parameters'),
  }(name='Script'),
  tags?: [ 
    {
      key?: string(name='Key', description='This parameter is required.'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
  timeout?: int32(name='Timeout'),
  trigger?: {
    cron?: string(name='Cron'),
    endTime?: string(name='EndTime'),
    recurrence?: string(name='Recurrence'),
    startTime?: string(name='StartTime'),
    type?: string(name='Type', description='This parameter is required.'),
  }(name='Trigger', description='This parameter is required.'),
}

model UpdateTaskShrinkRequest {
  clientUniqueCode?: string(name='ClientUniqueCode'),
  dataSourceShrink?: string(name='DataSource'),
  dependenciesShrink?: string(name='Dependencies'),
  description?: string(name='Description'),
  envType?: string(name='EnvType'),
  id?: long(name='Id', description='This parameter is required.'),
  inputsShrink?: string(name='Inputs'),
  instanceMode?: string(name='InstanceMode'),
  name?: string(name='Name', description='This parameter is required.'),
  outputsShrink?: string(name='Outputs'),
  owner?: string(name='Owner', description='This parameter is required.'),
  rerunInterval?: int32(name='RerunInterval'),
  rerunMode?: string(name='RerunMode', description='This parameter is required.'),
  rerunTimes?: int32(name='RerunTimes'),
  runtimeResourceShrink?: string(name='RuntimeResource', description='This parameter is required.'),
  scriptShrink?: string(name='Script'),
  tagsShrink?: string(name='Tags'),
  timeout?: int32(name='Timeout'),
  triggerShrink?: string(name='Trigger', description='This parameter is required.'),
}

model UpdateTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateTaskResponseBody(name='body'),
}

/**
 * @param tmpReq UpdateTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTaskResponse
 */
async function updateTaskWithOptions(tmpReq: UpdateTaskRequest, runtime: Util.RuntimeOptions): UpdateTaskResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dataSource)) {
    request.dataSourceShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dataSource, 'DataSource', 'json');
  }
  if (!Util.isUnset(tmpReq.dependencies)) {
    request.dependenciesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dependencies, 'Dependencies', 'json');
  }
  if (!Util.isUnset(tmpReq.inputs)) {
    request.inputsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.inputs, 'Inputs', 'json');
  }
  if (!Util.isUnset(tmpReq.outputs)) {
    request.outputsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.outputs, 'Outputs', 'json');
  }
  if (!Util.isUnset(tmpReq.runtimeResource)) {
    request.runtimeResourceShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.runtimeResource, 'RuntimeResource', 'json');
  }
  if (!Util.isUnset(tmpReq.script)) {
    request.scriptShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.script, 'Script', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  if (!Util.isUnset(tmpReq.trigger)) {
    request.triggerShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.trigger, 'Trigger', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientUniqueCode)) {
    body['ClientUniqueCode'] = request.clientUniqueCode;
  }
  if (!Util.isUnset(request.dataSourceShrink)) {
    body['DataSource'] = request.dataSourceShrink;
  }
  if (!Util.isUnset(request.dependenciesShrink)) {
    body['Dependencies'] = request.dependenciesShrink;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.envType)) {
    body['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.inputsShrink)) {
    body['Inputs'] = request.inputsShrink;
  }
  if (!Util.isUnset(request.instanceMode)) {
    body['InstanceMode'] = request.instanceMode;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.outputsShrink)) {
    body['Outputs'] = request.outputsShrink;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.rerunInterval)) {
    body['RerunInterval'] = request.rerunInterval;
  }
  if (!Util.isUnset(request.rerunMode)) {
    body['RerunMode'] = request.rerunMode;
  }
  if (!Util.isUnset(request.rerunTimes)) {
    body['RerunTimes'] = request.rerunTimes;
  }
  if (!Util.isUnset(request.runtimeResourceShrink)) {
    body['RuntimeResource'] = request.runtimeResourceShrink;
  }
  if (!Util.isUnset(request.scriptShrink)) {
    body['Script'] = request.scriptShrink;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    body['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.timeout)) {
    body['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.triggerShrink)) {
    body['Trigger'] = request.triggerShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTask',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateTaskRequest
 * @return UpdateTaskResponse
 */
async function updateTask(request: UpdateTaskRequest): UpdateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTaskWithOptions(request, runtime);
}

model UpdateTaskInstancesRequest {
  comment?: string(name='Comment'),
  taskInstances?: [ 
    {
      dataSource?: {
        name?: string(name='Name'),
      }(name='DataSource'),
      id?: long(name='Id', description='This parameter is required.'),
      priority?: int32(name='Priority'),
      runtimeResource?: string(name='RuntimeResource'),
    }
  ](name='TaskInstances'),
}

model UpdateTaskInstancesShrinkRequest {
  comment?: string(name='Comment'),
  taskInstancesShrink?: string(name='TaskInstances'),
}

model UpdateTaskInstancesResponseBody = {
  requestId?: string(name='RequestId'),
  successInfo?: map[string]SuccessInfoValue(name='SuccessInfo'),
}

model UpdateTaskInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateTaskInstancesResponseBody(name='body'),
}

/**
 * @param tmpReq UpdateTaskInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTaskInstancesResponse
 */
async function updateTaskInstancesWithOptions(tmpReq: UpdateTaskInstancesRequest, runtime: Util.RuntimeOptions): UpdateTaskInstancesResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateTaskInstancesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.taskInstances)) {
    request.taskInstancesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.taskInstances, 'TaskInstances', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.taskInstancesShrink)) {
    body['TaskInstances'] = request.taskInstancesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTaskInstances',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateTaskInstancesRequest
 * @return UpdateTaskInstancesResponse
 */
async function updateTaskInstances(request: UpdateTaskInstancesRequest): UpdateTaskInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTaskInstancesWithOptions(request, runtime);
}

model UpdateTaskScheduleExpressRequest {
  baseId?: string(name='BaseId', description='This parameter is required.'),
  projectEnv?: string(name='ProjectEnv', description='This parameter is required.'),
  scheduleExpress?: string(name='ScheduleExpress', description='This parameter is required.'),
  taskId?: long(name='TaskId', description='This parameter is required.'),
  tenantId?: long(name='TenantId', description='This parameter is required.'),
}

model UpdateTaskScheduleExpressResponseBody = {
  requestId?: string(name='RequestId'),
  returnCode?: string(name='ReturnCode'),
  returnErrorSolution?: string(name='ReturnErrorSolution'),
  returnMessage?: string(name='ReturnMessage'),
  returnValue?: boolean(name='ReturnValue'),
}

model UpdateTaskScheduleExpressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateTaskScheduleExpressResponseBody(name='body'),
}

/**
 * @param request UpdateTaskScheduleExpressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTaskScheduleExpressResponse
 */
async function updateTaskScheduleExpressWithOptions(request: UpdateTaskScheduleExpressRequest, runtime: Util.RuntimeOptions): UpdateTaskScheduleExpressResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.baseId)) {
    body['BaseId'] = request.baseId;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  if (!Util.isUnset(request.scheduleExpress)) {
    body['ScheduleExpress'] = request.scheduleExpress;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTaskScheduleExpress',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateTaskScheduleExpressRequest
 * @return UpdateTaskScheduleExpressResponse
 */
async function updateTaskScheduleExpress(request: UpdateTaskScheduleExpressRequest): UpdateTaskScheduleExpressResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTaskScheduleExpressWithOptions(request, runtime);
}

model UpdateUdfFileRequest {
  className?: string(name='ClassName', description='This parameter is required.'),
  cmdDescription?: string(name='CmdDescription'),
  example?: string(name='Example'),
  fileFolderPath?: string(name='FileFolderPath'),
  fileId?: string(name='FileId', description='This parameter is required.'),
  functionType?: string(name='FunctionType', description='This parameter is required.'),
  parameterDescription?: string(name='ParameterDescription'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  resources?: string(name='Resources', description='This parameter is required.'),
  returnValue?: string(name='ReturnValue'),
  udfDescription?: string(name='UdfDescription'),
}

model UpdateUdfFileResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateUdfFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateUdfFileResponseBody(name='body'),
}

/**
 * @param request UpdateUdfFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateUdfFileResponse
 */
async function updateUdfFileWithOptions(request: UpdateUdfFileRequest, runtime: Util.RuntimeOptions): UpdateUdfFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.className)) {
    body['ClassName'] = request.className;
  }
  if (!Util.isUnset(request.cmdDescription)) {
    body['CmdDescription'] = request.cmdDescription;
  }
  if (!Util.isUnset(request.example)) {
    body['Example'] = request.example;
  }
  if (!Util.isUnset(request.fileFolderPath)) {
    body['FileFolderPath'] = request.fileFolderPath;
  }
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.functionType)) {
    body['FunctionType'] = request.functionType;
  }
  if (!Util.isUnset(request.parameterDescription)) {
    body['ParameterDescription'] = request.parameterDescription;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  if (!Util.isUnset(request.resources)) {
    body['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.returnValue)) {
    body['ReturnValue'] = request.returnValue;
  }
  if (!Util.isUnset(request.udfDescription)) {
    body['UdfDescription'] = request.udfDescription;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUdfFile',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateUdfFileRequest
 * @return UpdateUdfFileResponse
 */
async function updateUdfFile(request: UpdateUdfFileRequest): UpdateUdfFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUdfFileWithOptions(request, runtime);
}

model UpdateWorkbenchEventResultRequest {
  checkResult?: string(name='CheckResult'),
  checkResultTip?: string(name='CheckResultTip'),
  extensionCode?: string(name='ExtensionCode'),
  messageId?: string(name='MessageId'),
}

model UpdateWorkbenchEventResultResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateWorkbenchEventResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateWorkbenchEventResultResponseBody(name='body'),
}

/**
 * @summary 更新运维中心扩展程序的回调结果
 *
 * @param request UpdateWorkbenchEventResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateWorkbenchEventResultResponse
 */
async function updateWorkbenchEventResultWithOptions(request: UpdateWorkbenchEventResultRequest, runtime: Util.RuntimeOptions): UpdateWorkbenchEventResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkResult)) {
    query['CheckResult'] = request.checkResult;
  }
  if (!Util.isUnset(request.checkResultTip)) {
    query['CheckResultTip'] = request.checkResultTip;
  }
  if (!Util.isUnset(request.extensionCode)) {
    query['ExtensionCode'] = request.extensionCode;
  }
  if (!Util.isUnset(request.messageId)) {
    query['MessageId'] = request.messageId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWorkbenchEventResult',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新运维中心扩展程序的回调结果
 *
 * @param request UpdateWorkbenchEventResultRequest
 * @return UpdateWorkbenchEventResultResponse
 */
async function updateWorkbenchEventResult(request: UpdateWorkbenchEventResultRequest): UpdateWorkbenchEventResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWorkbenchEventResultWithOptions(request, runtime);
}

model UpdateWorkflowRequest {
  clientUniqueCode?: string(name='ClientUniqueCode'),
  dependencies?: [ 
    {
      type?: string(name='Type', description='This parameter is required.'),
      upstreamOutput?: string(name='UpstreamOutput'),
      upstreamTaskId?: long(name='UpstreamTaskId'),
    }
  ](name='Dependencies'),
  description?: string(name='Description'),
  envType?: string(name='EnvType'),
  id?: long(name='Id', description='This parameter is required.'),
  instanceMode?: string(name='InstanceMode'),
  name?: string(name='Name', description='This parameter is required.'),
  outputs?: {
    taskOutputs?: [ 
      {
        output?: string(name='Output'),
      }
    ](name='TaskOutputs'),
  }(name='Outputs'),
  owner?: string(name='Owner', description='This parameter is required.'),
  parameters?: string(name='Parameters'),
  tags?: [ 
    {
      key?: string(name='Key', description='This parameter is required.'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
  tasks?: [ 
    {
      baseLineId?: long(name='BaseLineId'),
      clientUniqueCode?: string(name='ClientUniqueCode'),
      dataSource?: {
        name?: string(name='Name'),
      }(name='DataSource'),
      dependencies?: [ 
        {
          type?: string(name='Type', description='This parameter is required.'),
          upstreamOutput?: string(name='UpstreamOutput'),
          upstreamTaskId?: long(name='UpstreamTaskId'),
        }
      ](name='Dependencies'),
      description?: string(name='Description'),
      envType?: string(name='EnvType'),
      id?: long(name='Id'),
      inputs?: {
        variables?: [ 
          {
            name?: string(name='Name'),
            type?: string(name='Type', description='This parameter is required.'),
            value?: string(name='Value'),
          }
        ](name='Variables'),
      }(name='Inputs'),
      name?: string(name='Name', description='This parameter is required.'),
      outputs?: {
        taskOutputs?: [ 
          {
            output?: string(name='Output'),
          }
        ](name='TaskOutputs'),
        variables?: [ 
          {
            name?: string(name='Name'),
            type?: string(name='Type', description='This parameter is required.'),
            value?: string(name='Value'),
          }
        ](name='Variables'),
      }(name='Outputs'),
      owner?: string(name='Owner', description='This parameter is required.'),
      rerunInterval?: int32(name='RerunInterval'),
      rerunMode?: string(name='RerunMode', description='This parameter is required.'),
      rerunTimes?: int32(name='RerunTimes'),
      runtimeResource?: {
        cu?: string(name='Cu'),
        image?: string(name='Image'),
        resourceGroupId?: string(name='ResourceGroupId', description='This parameter is required.'),
      }(name='RuntimeResource', description='This parameter is required.'),
      script?: {
        content?: string(name='Content'),
        parameters?: string(name='Parameters'),
      }(name='Script'),
      tags?: [ 
        {
          key?: string(name='Key', description='This parameter is required.'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      timeout?: int32(name='Timeout'),
      trigger?: {
        recurrence?: string(name='Recurrence', description='This parameter is required.'),
        type?: string(name='Type'),
      }(name='Trigger', description='This parameter is required.'),
      type?: string(name='Type', description='This parameter is required.'),
    }
  ](name='Tasks'),
  trigger?: {
    cron?: string(name='Cron'),
    endTime?: string(name='EndTime'),
    startTime?: string(name='StartTime'),
    type?: string(name='Type', description='This parameter is required.'),
  }(name='Trigger', description='This parameter is required.'),
}

model UpdateWorkflowShrinkRequest {
  clientUniqueCode?: string(name='ClientUniqueCode'),
  dependenciesShrink?: string(name='Dependencies'),
  description?: string(name='Description'),
  envType?: string(name='EnvType'),
  id?: long(name='Id', description='This parameter is required.'),
  instanceMode?: string(name='InstanceMode'),
  name?: string(name='Name', description='This parameter is required.'),
  outputsShrink?: string(name='Outputs'),
  owner?: string(name='Owner', description='This parameter is required.'),
  parameters?: string(name='Parameters'),
  tagsShrink?: string(name='Tags'),
  tasksShrink?: string(name='Tasks'),
  triggerShrink?: string(name='Trigger', description='This parameter is required.'),
}

model UpdateWorkflowResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateWorkflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateWorkflowResponseBody(name='body'),
}

/**
 * @param tmpReq UpdateWorkflowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateWorkflowResponse
 */
async function updateWorkflowWithOptions(tmpReq: UpdateWorkflowRequest, runtime: Util.RuntimeOptions): UpdateWorkflowResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateWorkflowShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dependencies)) {
    request.dependenciesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dependencies, 'Dependencies', 'json');
  }
  if (!Util.isUnset(tmpReq.outputs)) {
    request.outputsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.outputs, 'Outputs', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  if (!Util.isUnset(tmpReq.tasks)) {
    request.tasksShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tasks, 'Tasks', 'json');
  }
  if (!Util.isUnset(tmpReq.trigger)) {
    request.triggerShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.trigger, 'Trigger', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientUniqueCode)) {
    body['ClientUniqueCode'] = request.clientUniqueCode;
  }
  if (!Util.isUnset(request.dependenciesShrink)) {
    body['Dependencies'] = request.dependenciesShrink;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.envType)) {
    body['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.instanceMode)) {
    body['InstanceMode'] = request.instanceMode;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.outputsShrink)) {
    body['Outputs'] = request.outputsShrink;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.parameters)) {
    body['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    body['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.tasksShrink)) {
    body['Tasks'] = request.tasksShrink;
  }
  if (!Util.isUnset(request.triggerShrink)) {
    body['Trigger'] = request.triggerShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWorkflow',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateWorkflowRequest
 * @return UpdateWorkflowResponse
 */
async function updateWorkflow(request: UpdateWorkflowRequest): UpdateWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWorkflowWithOptions(request, runtime);
}

model UpdateWorkflowDefinitionRequest {
  id?: long(name='Id', description='This parameter is required.'),
  projectId?: long(name='ProjectId', description='This parameter is required.'),
  spec?: string(name='Spec', description='This parameter is required.'),
}

model UpdateWorkflowDefinitionResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateWorkflowDefinitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateWorkflowDefinitionResponseBody(name='body'),
}

/**
 * @summary 更新工作流
 *
 * @param request UpdateWorkflowDefinitionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateWorkflowDefinitionResponse
 */
async function updateWorkflowDefinitionWithOptions(request: UpdateWorkflowDefinitionRequest, runtime: Util.RuntimeOptions): UpdateWorkflowDefinitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.spec)) {
    body['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWorkflowDefinition',
    version = '2020-09-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新工作流
 *
 * @param request UpdateWorkflowDefinitionRequest
 * @return UpdateWorkflowDefinitionResponse
 */
async function updateWorkflowDefinition(request: UpdateWorkflowDefinitionRequest): UpdateWorkflowDefinitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWorkflowDefinitionWithOptions(request, runtime);
}

api _postOSSObject(bucketName: string, data: object): object {
  var form = Util.assertAsMap(data);
  var boundary = FileForm.getBoundary();
  var host = Util.assertAsString(form.host);
  __request.protocol = 'HTTPS';
  __request.method = 'POST';
  __request.pathname = `/`;
  __request.headers = {
    host = host,
    date = Util.getDateUTCString(),
    user-agent = Util.getUserAgent(''),
  };
  __request.headers.content-type = `multipart/form-data; boundary=${boundary}`;
  __request.body = FileForm.toFileForm(form, boundary);
} returns {
  var respMap : object = null;
  var bodyStr = Util.readAsString(__response.body);
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    respMap = XML.parseXml(bodyStr, null);
    var err = Util.assertAsMap(respMap.Error);
    throw {
      code = err.Code,
      message = err.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = err.RequestId,
        hostId = err.HostId,
      }
    };
  }
  respMap = XML.parseXml(bodyStr, null);
  return {
    ...respMap,
  };
}
