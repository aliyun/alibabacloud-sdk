/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'dataworks-public';
  @version = '2020-05-18';
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'dataworks.ap-northeast-1.aliyuncs.com',
    ap-south-1 = 'dataworks.ap-south-1.aliyuncs.com',
    ap-southeast-1 = 'dataworks.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'dataworks.ap-southeast-2.aliyuncs.com',
    ap-southeast-3 = 'dataworks.ap-southeast-3.aliyuncs.com',
    ap-southeast-5 = 'dataworks.ap-southeast-5.aliyuncs.com',
    cn-beijing = 'dataworks.cn-beijing.aliyuncs.com',
    cn-chengdu = 'dataworks.cn-chengdu.aliyuncs.com',
    cn-hangzhou = 'dataworks.cn-hangzhou.aliyuncs.com',
    cn-hongkong = 'dataworks.cn-hongkong.aliyuncs.com',
    cn-huhehaote = 'dataworks.aliyuncs.com',
    cn-qingdao = 'dataworks.aliyuncs.com',
    cn-shanghai = 'dataworks.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'dataworks.cn-shenzhen.aliyuncs.com',
    cn-zhangjiakou = 'dataworks.aliyuncs.com',
    eu-central-1 = 'dataworks.eu-central-1.aliyuncs.com',
    eu-west-1 = 'dataworks.eu-west-1.aliyuncs.com',
    me-east-1 = 'dataworks.me-east-1.aliyuncs.com',
    us-east-1 = 'dataworks.us-east-1.aliyuncs.com',
    us-west-1 = 'dataworks.us-west-1.aliyuncs.com',
    cn-hangzhou-finance = 'dataworks.aliyuncs.com',
    cn-shenzhen-finance-1 = 'dataworks.aliyuncs.com',
    cn-shanghai-finance-1 = 'dataworks.aliyuncs.com',
    cn-north-2-gov-1 = 'dataworks.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model AbolishDataServiceApiRequest {
  regionId: string(name='RegionId', position='Host'),
  apiId: long(name='ApiId', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
  tenantId: long(name='TenantId', position='Body'),
}

model AbolishDataServiceApiResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AbolishDataServiceApiResponse = {
  headers: map[string]string(name='headers'),
  body: AbolishDataServiceApiResponseBody(name='body'),
}

async function abolishDataServiceApi(request: AbolishDataServiceApiRequest): AbolishDataServiceApiResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AbolishDataServiceApi', 'POST', '/', 'json', true, 'form', request);
}

model AddProjectMemberToRoleRequest {
  regionId: string(name='RegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  projectId: long(name='ProjectId', minimum=0, maximum=10000000, position='Query'),
  roleCode: string(name='RoleCode', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model AddProjectMemberToRoleResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddProjectMemberToRoleResponse = {
  headers: map[string]string(name='headers'),
  body: AddProjectMemberToRoleResponseBody(name='body'),
}

async function addProjectMemberToRole(request: AddProjectMemberToRoleRequest): AddProjectMemberToRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddProjectMemberToRole', 'POST', '/', 'json', false, 'json', request);
}

model AddToMetaCategoryRequest {
  regionId: string(name='RegionId', position='Host'),
  categoryId: long(name='CategoryId', position='Query'),
  tableGuid: string(name='TableGuid', position='Query'),
}

model AddToMetaCategoryResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddToMetaCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: AddToMetaCategoryResponseBody(name='body'),
}

async function addToMetaCategory(request: AddToMetaCategoryRequest): AddToMetaCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddToMetaCategory', 'POST', '/', 'json', false, 'json', request);
}

model ApprovePermissionApplyOrderRequest {
  regionId: string(name='RegionId', position='Host'),
  approveAction: int32(name='ApproveAction', minimum=0, maximum=5, position='Query'),
  approveComment: string(name='ApproveComment', position='Query'),
  flowId: string(name='FlowId', position='Query'),
}

model ApprovePermissionApplyOrderResponseBody = {
  approveSuccess?: boolean(name='ApproveSuccess'),
  requestId?: string(name='RequestId'),
}

model ApprovePermissionApplyOrderResponse = {
  headers: map[string]string(name='headers'),
  body: ApprovePermissionApplyOrderResponseBody(name='body'),
}

async function approvePermissionApplyOrder(request: ApprovePermissionApplyOrderRequest): ApprovePermissionApplyOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ApprovePermissionApplyOrder', 'POST', '/', 'json', false, 'json', request);
}

model CheckFileDeploymentRequest {
  regionId: string(name='RegionId', position='Host'),
  checkDetailUrl?: string(name='CheckDetailUrl', position='Body'),
  checkerInstanceId: string(name='CheckerInstanceId', position='Body'),
  status: string(name='Status', position='Body'),
}

model CheckFileDeploymentResponseBody = {
  requestId?: string(name='RequestId'),
}

model CheckFileDeploymentResponse = {
  headers: map[string]string(name='headers'),
  body: CheckFileDeploymentResponseBody(name='body'),
}

async function checkFileDeployment(request: CheckFileDeploymentRequest): CheckFileDeploymentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckFileDeployment', 'POST', '/', 'json', true, 'form', request);
}

model CheckMetaPartitionRequest {
  regionId: string(name='RegionId', position='Host'),
  clusterId?: string(name='ClusterId', position='Query'),
  dataSourceType?: string(name='DataSourceType', position='Query'),
  databaseName?: string(name='DatabaseName', position='Query'),
  partition: string(name='Partition', position='Query'),
  tableGuid?: string(name='TableGuid', position='Query'),
  tableName?: string(name='TableName', position='Query'),
}

model CheckMetaPartitionResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckMetaPartitionResponse = {
  headers: map[string]string(name='headers'),
  body: CheckMetaPartitionResponseBody(name='body'),
}

async function checkMetaPartition(request: CheckMetaPartitionRequest): CheckMetaPartitionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckMetaPartition', 'POST', '/', 'json', false, 'json', request);
}

model CheckMetaTableRequest {
  regionId: string(name='RegionId', position='Host'),
  clusterId?: string(name='ClusterId', position='Query'),
  dataSourceType?: string(name='DataSourceType', position='Query'),
  databaseName?: string(name='DatabaseName', position='Query'),
  tableGuid?: string(name='TableGuid', position='Query'),
  tableName?: string(name='TableName', position='Query'),
}

model CheckMetaTableResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model CheckMetaTableResponse = {
  headers: map[string]string(name='headers'),
  body: CheckMetaTableResponseBody(name='body'),
}

async function checkMetaTable(request: CheckMetaTableRequest): CheckMetaTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckMetaTable', 'POST', '/', 'json', false, 'json', request);
}

model CreateBaselineRequest {
  regionId?: string(name='RegionId', position='Host'),
  alertMarginThreshold?: int32(name='AlertMarginThreshold', description='基线预警余量', position='Body'),
  baselineName: string(name='BaselineName', description='基线名', position='Body'),
  baselineType: string(name='BaselineType', description='基线类型 (DAILY, HOURLY)', position='Body'),
  overtimeSettings: [ 
    {
      cycle?: int32(name='Cycle', description='周期，取值范围 [1,24]'),
      time?: string(name='Time', description='承诺时间，hh:mm格式，hh的取值范围为[0,47]，mm的取值范围为[0,59]'),
    }
  ](name='OvertimeSettings', description='基线承诺时间', position='Body'),
  owner: string(name='Owner', description='责任人', position='Body'),
  priority: int32(name='Priority', description='基线优先级', position='Body'),
  projectId: long(name='ProjectId', description='项目id', position='Body'),
  taskIds?: string(name='TaskIds', position='Body'),
}

model CreateBaselineResponseBody = {
  data?: long(name='Data'),
  dynamicErrorCode?: string(name='DynamicErrorCode'),
  dynamicErrorMessage?: string(name='DynamicErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBaselineResponseBody(name='body'),
}

async function createBaseline(request: CreateBaselineRequest): CreateBaselineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBaseline', 'POST', '/', 'json', true, 'form', request);
}

model CreateBusinessRequest {
  regionId: string(name='RegionId', position='Host'),
  businessName: string(name='BusinessName', position='Body'),
  description?: string(name='Description', position='Body'),
  owner?: string(name='Owner', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
  useType?: string(name='UseType', position='Body'),
}

model CreateBusinessResponseBody = {
  businessId?: long(name='BusinessId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateBusinessResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBusinessResponseBody(name='body'),
}

async function createBusiness(request: CreateBusinessRequest): CreateBusinessResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBusiness', 'POST', '/', 'json', true, 'form', request);
}

model CreateConnectionRequest {
  regionId: string(name='RegionId', position='Host'),
  connectionType: string(name='ConnectionType', position='Query'),
  content: string(name='Content', position='Query'),
  description?: string(name='Description', position='Query'),
  envType: int32(name='EnvType', position='Query'),
  name: string(name='Name', position='Query'),
  projectId: long(name='ProjectId', position='Query'),
  subType?: string(name='SubType', position='Query'),
}

model CreateConnectionResponseBody = {
  data?: long(name='Data'),
  httpStatusCode?: string(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateConnectionResponseBody(name='body'),
}

async function createConnection(request: CreateConnectionRequest): CreateConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateConnection', 'POST', '/', 'json', false, 'json', request);
}

model CreateDISyncTaskRequest {
  regionId: string(name='RegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  taskContent: string(name='TaskContent', position='Query'),
  taskName?: string(name='TaskName', position='Query'),
  taskParam?: string(name='TaskParam', position='Query'),
  taskType: string(name='TaskType', position='Query'),
}

model CreateDISyncTaskResponseBody = {
  data?: {
    fileId?: long(name='FileId'),
    message?: string(name='Message'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDISyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDISyncTaskResponseBody(name='body'),
}

async function createDISyncTask(request: CreateDISyncTaskRequest): CreateDISyncTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDISyncTask', 'POST', '/', 'json', false, 'json', request);
}

model CreateDagComplementRequest {
  regionId: string(name='RegionId', position='Host'),
  bizBeginTime?: string(name='BizBeginTime', position='Body'),
  bizEndTime?: string(name='BizEndTime', position='Body'),
  endBizDate: string(name='EndBizDate', position='Body'),
  excludeNodeIds?: string(name='ExcludeNodeIds', position='Body'),
  includeNodeIds: string(name='IncludeNodeIds', position='Body'),
  name: string(name='Name', position='Body'),
  nodeParams?: string(name='NodeParams', position='Body'),
  parallelism: boolean(name='Parallelism', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
  rootNodeId: long(name='RootNodeId', position='Body'),
  startBizDate: string(name='StartBizDate', position='Body'),
}

model CreateDagComplementResponseBody = {
  data?: [ long ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDagComplementResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDagComplementResponseBody(name='body'),
}

async function createDagComplement(request: CreateDagComplementRequest): CreateDagComplementResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDagComplement', 'POST', '/', 'json', true, 'form', request);
}

model CreateDagTestRequest {
  regionId: string(name='RegionId', position='Host'),
  bizdate: string(name='Bizdate', position='Body'),
  name: string(name='Name', position='Body'),
  nodeId: long(name='NodeId', position='Body'),
  nodeParams?: string(name='NodeParams', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model CreateDagTestResponseBody = {
  data?: long(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDagTestResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDagTestResponseBody(name='body'),
}

async function createDagTest(request: CreateDagTestRequest): CreateDagTestResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDagTest', 'POST', '/', 'json', true, 'form', request);
}

model CreateDataServiceApiRequest {
  regionId: string(name='RegionId', position='Host'),
  apiDescription: string(name='ApiDescription', position='Body'),
  apiMode: int32(name='ApiMode', position='Body'),
  apiName: string(name='ApiName', position='Body'),
  apiPath: string(name='ApiPath', position='Body'),
  folderId?: long(name='FolderId', minimum=0, maximum=9223372036854775807, position='Body'),
  groupId: string(name='GroupId', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
  protocols: string(name='Protocols', position='Body'),
  registrationDetails?: string(name='RegistrationDetails', position='Body'),
  requestMethod: int32(name='RequestMethod', position='Body'),
  responseContentType: int32(name='ResponseContentType', position='Body'),
  scriptDetails?: string(name='ScriptDetails', position='Body'),
  tenantId: long(name='TenantId', position='Body'),
  timeout: int32(name='Timeout', position='Body'),
  visibleRange: int32(name='VisibleRange', position='Body'),
  wizardDetails?: string(name='WizardDetails', position='Body'),
}

model CreateDataServiceApiResponseBody = {
  data?: long(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDataServiceApiResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataServiceApiResponseBody(name='body'),
}

async function createDataServiceApi(request: CreateDataServiceApiRequest): CreateDataServiceApiResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDataServiceApi', 'POST', '/', 'json', true, 'form', request);
}

model CreateDataServiceApiAuthorityRequest {
  regionId: string(name='RegionId', position='Host'),
  apiId: long(name='ApiId', minimum=1, maximum=9223372036854775807, position='Body'),
  authorizedProjectId: long(name='AuthorizedProjectId', minimum=1, maximum=9223372036854775807, position='Body'),
  endTime: long(name='EndTime', minimum=1, maximum=9223372036854775807, position='Body'),
  projectId: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Body'),
  tenantId: long(name='TenantId', minimum=1, maximum=9223372036854775807, position='Body'),
}

model CreateDataServiceApiAuthorityResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDataServiceApiAuthorityResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataServiceApiAuthorityResponseBody(name='body'),
}

async function createDataServiceApiAuthority(request: CreateDataServiceApiAuthorityRequest): CreateDataServiceApiAuthorityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDataServiceApiAuthority', 'POST', '/', 'json', true, 'form', request);
}

model CreateDataServiceFolderRequest {
  regionId: string(name='RegionId', position='Host'),
  folderName: string(name='FolderName', position='Body'),
  groupId: string(name='GroupId', position='Body'),
  parentId: long(name='ParentId', minimum=0, maximum=9223372036854775807, position='Body'),
  projectId: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Body'),
  tenantId: long(name='TenantId', minimum=1, maximum=9223372036854775807, position='Body'),
}

model CreateDataServiceFolderResponseBody = {
  folderId?: long(name='FolderId'),
  requestId?: string(name='RequestId'),
}

model CreateDataServiceFolderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataServiceFolderResponseBody(name='body'),
}

async function createDataServiceFolder(request: CreateDataServiceFolderRequest): CreateDataServiceFolderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDataServiceFolder', 'POST', '/', 'json', true, 'form', request);
}

model CreateDataServiceGroupRequest {
  regionId: string(name='RegionId', position='Host'),
  apiGatewayGroupId: string(name='ApiGatewayGroupId', position='Body'),
  description?: string(name='Description', position='Body'),
  groupName: string(name='GroupName', position='Body'),
  projectId: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Body'),
  tenantId: long(name='TenantId', minimum=1, maximum=9223372036854775807, position='Body'),
}

model CreateDataServiceGroupResponseBody = {
  groupId?: string(name='GroupId'),
  requestId?: string(name='RequestId'),
}

model CreateDataServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataServiceGroupResponseBody(name='body'),
}

async function createDataServiceGroup(request: CreateDataServiceGroupRequest): CreateDataServiceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDataServiceGroup', 'POST', '/', 'json', true, 'form', request);
}

model CreateDataSourceRequest {
  regionId: string(name='RegionId', position='Host'),
  content: string(name='Content', position='Query'),
  dataSourceType: string(name='DataSourceType', position='Query'),
  description?: string(name='Description', position='Query'),
  envType: int32(name='EnvType', position='Query'),
  name: string(name='Name', position='Query'),
  projectId: long(name='ProjectId', position='Query'),
  subType?: string(name='SubType', position='Query'),
}

model CreateDataSourceResponseBody = {
  data?: long(name='Data'),
  httpStatusCode?: string(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataSourceResponseBody(name='body'),
}

async function createDataSource(request: CreateDataSourceRequest): CreateDataSourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDataSource', 'POST', '/', 'json', false, 'json', request);
}

model CreateExportMigrationRequest {
  regionId: string(name='RegionId', position='Host'),
  description?: string(name='Description', position='Body'),
  exportMode: string(name='ExportMode', position='Body'),
  exportObjectStatus?: string(name='ExportObjectStatus', position='Body'),
  incrementalSince?: long(name='IncrementalSince', position='Body'),
  name: string(name='Name', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
}

model CreateExportMigrationResponseBody = {
  data?: long(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateExportMigrationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateExportMigrationResponseBody(name='body'),
}

async function createExportMigration(request: CreateExportMigrationRequest): CreateExportMigrationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateExportMigration', 'POST', '/', 'json', true, 'form', request);
}

model CreateFileRequest {
  regionId: string(name='RegionId', position='Host'),
  advancedSettings?: string(name='AdvancedSettings', position='Body'),
  autoParsing?: boolean(name='AutoParsing', position='Body'),
  autoRerunIntervalMillis?: int32(name='AutoRerunIntervalMillis', position='Body'),
  autoRerunTimes?: int32(name='AutoRerunTimes', position='Body'),
  connectionName?: string(name='ConnectionName', position='Body'),
  content?: string(name='Content', position='Body'),
  cronExpress?: string(name='CronExpress', position='Body'),
  cycleType?: string(name='CycleType', position='Body'),
  dependentNodeIdList?: string(name='DependentNodeIdList', position='Body'),
  dependentType?: string(name='DependentType', position='Body'),
  endEffectDate?: long(name='EndEffectDate', minimum=0, position='Body'),
  fileDescription?: string(name='FileDescription', position='Body'),
  fileFolderPath?: string(name='FileFolderPath', position='Body'),
  fileName: string(name='FileName', position='Body'),
  fileType: int32(name='FileType', position='Body'),
  inputList?: string(name='InputList', position='Body'),
  inputParameters?: string(name='InputParameters', position='Body'),
  outputParameters?: string(name='OutputParameters', position='Body'),
  owner?: string(name='Owner', position='Body'),
  paraValue?: string(name='ParaValue', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
  rerunMode?: string(name='RerunMode', position='Body'),
  resourceGroupId?: long(name='ResourceGroupId', position='Body'),
  resourceGroupIdentifier?: string(name='ResourceGroupIdentifier', position='Body'),
  schedulerType?: string(name='SchedulerType', position='Body'),
  startEffectDate?: long(name='StartEffectDate', minimum=0, position='Body'),
  startImmediately?: boolean(name='StartImmediately', position='Body'),
  stop?: boolean(name='Stop', position='Body'),
}

model CreateFileResponseBody = {
  data?: long(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateFileResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFileResponseBody(name='body'),
}

async function createFile(request: CreateFileRequest): CreateFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFile', 'POST', '/', 'json', true, 'form', request);
}

model CreateFolderRequest {
  regionId: string(name='RegionId', position='Host'),
  folderPath: string(name='FolderPath', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
}

model CreateFolderResponseBody = {
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateFolderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFolderResponseBody(name='body'),
}

async function createFolder(request: CreateFolderRequest): CreateFolderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFolder', 'POST', '/', 'json', true, 'form', request);
}

model CreateManualDagRequest {
  regionId: string(name='RegionId', position='Host'),
  bizDate: string(name='BizDate', position='Body'),
  dagParameters?: string(name='DagParameters', position='Body'),
  excludeNodeIds?: string(name='ExcludeNodeIds', position='Body'),
  flowName: string(name='FlowName', position='Body'),
  includeNodeIds?: string(name='IncludeNodeIds', position='Body'),
  nodeParameters?: string(name='NodeParameters', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
  projectName: string(name='ProjectName', position='Body'),
}

model CreateManualDagResponseBody = {
  dagId?: long(name='DagId'),
  requestId?: string(name='RequestId'),
}

model CreateManualDagResponse = {
  headers: map[string]string(name='headers'),
  body: CreateManualDagResponseBody(name='body'),
}

async function createManualDag(request: CreateManualDagRequest): CreateManualDagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateManualDag', 'POST', '/', 'json', true, 'form', request);
}

model CreateMetaCategoryRequest {
  regionId: string(name='RegionId', position='Host'),
  comment?: string(name='Comment', position='Body'),
  name: string(name='Name', position='Body'),
  parentId?: long(name='ParentId', position='Body'),
}

model CreateMetaCategoryResponseBody = {
  data?: {
    categoryId?: long(name='CategoryId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateMetaCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMetaCategoryResponseBody(name='body'),
}

async function createMetaCategory(request: CreateMetaCategoryRequest): CreateMetaCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMetaCategory', 'POST', '/', 'json', true, 'form', request);
}

model CreatePermissionApplyOrderRequest {
  regionId: string(name='RegionId', position='Host'),
  applyObject: [ 
    {
      actions: string(name='Actions'),
      columnMetaList: [ 
        {
          name: string(name='Name'),
        }
      ](name='ColumnMetaList'),
      name: string(name='Name'),
    }
  ](name='ApplyObject', position='Query'),
  applyReason: string(name='ApplyReason', position='Query'),
  applyUserIds: string(name='ApplyUserIds', position='Query'),
  deadline?: long(name='Deadline', position='Query'),
  engineType?: string(name='EngineType', position='Query'),
  maxComputeProjectName: string(name='MaxComputeProjectName', position='Query'),
  orderType?: int32(name='OrderType', position='Query'),
  workspaceId: int32(name='WorkspaceId', minimum=0, maximum=999999, position='Query'),
}

model CreatePermissionApplyOrderResponseBody = {
  flowId?: [ string ](name='FlowId'),
  requestId?: string(name='RequestId'),
}

model CreatePermissionApplyOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePermissionApplyOrderResponseBody(name='body'),
}

async function createPermissionApplyOrder(request: CreatePermissionApplyOrderRequest): CreatePermissionApplyOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePermissionApplyOrder', 'POST', '/', 'json', false, 'json', request);
}

model CreateProjectMemberRequest {
  regionId: string(name='RegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  projectId: long(name='ProjectId', minimum=0, maximum=100000000, position='Query'),
  roleCode?: string(name='RoleCode', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model CreateProjectMemberResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateProjectMemberResponse = {
  headers: map[string]string(name='headers'),
  body: CreateProjectMemberResponseBody(name='body'),
}

async function createProjectMember(request: CreateProjectMemberRequest): CreateProjectMemberResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateProjectMember', 'POST', '/', 'json', false, 'json', request);
}

model CreateQualityEntityRequest {
  regionId?: string(name='RegionId', position='Host'),
  entityLevel: int32(name='EntityLevel', minimum=0, maximum=99, position='Body'),
  envType: string(name='EnvType', minLength=1, maxLength=64, position='Body'),
  matchExpression: string(name='MatchExpression', minLength=1, maxLength=128, position='Body'),
  projectName: string(name='ProjectName', position='Body'),
  tableName: string(name='TableName', minLength=1, maxLength=128, position='Body'),
}

model CreateQualityEntityResponseBody = {
  data?: int32(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateQualityEntityResponse = {
  headers: map[string]string(name='headers'),
  body: CreateQualityEntityResponseBody(name='body'),
}

async function createQualityEntity(request: CreateQualityEntityRequest): CreateQualityEntityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateQualityEntity', 'POST', '/', 'json', true, 'form', request);
}

model CreateQualityFollowerRequest {
  regionId: string(name='RegionId', position='Host'),
  alarmMode: int32(name='AlarmMode', position='Body'),
  entityId: long(name='EntityId', position='Body'),
  follower: string(name='Follower', position='Body'),
  projectName: string(name='ProjectName', position='Body'),
}

model CreateQualityFollowerResponseBody = {
  data?: int32(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateQualityFollowerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateQualityFollowerResponseBody(name='body'),
}

async function createQualityFollower(request: CreateQualityFollowerRequest): CreateQualityFollowerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateQualityFollower', 'POST', '/', 'json', true, 'form', request);
}

model CreateQualityRelativeNodeRequest {
  regionId?: string(name='RegionId', position='Host'),
  envType: string(name='EnvType', minLength=1, maxLength=40, position='Body'),
  matchExpression: string(name='MatchExpression', minLength=1, maxLength=80, position='Body'),
  nodeId: long(name='NodeId', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
  projectName: string(name='ProjectName', minLength=1, maxLength=128, position='Body'),
  tableName: string(name='TableName', minLength=1, maxLength=128, position='Body'),
  targetNodeProjectId: long(name='TargetNodeProjectId', position='Body'),
  targetNodeProjectName: string(name='TargetNodeProjectName', minLength=1, maxLength=128, position='Body'),
}

model CreateQualityRelativeNodeResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateQualityRelativeNodeResponse = {
  headers: map[string]string(name='headers'),
  body: CreateQualityRelativeNodeResponseBody(name='body'),
}

async function createQualityRelativeNode(request: CreateQualityRelativeNodeRequest): CreateQualityRelativeNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateQualityRelativeNode', 'POST', '/', 'json', true, 'form', request);
}

model CreateQualityRuleRequest {
  regionId: string(name='RegionId', position='Host'),
  blockType: int32(name='BlockType', minimum=0, maximum=1, position='Body'),
  checker?: int32(name='Checker', minimum=1, position='Body'),
  comment?: string(name='Comment', minLength=1, maxLength=128, position='Body'),
  criticalThreshold?: string(name='CriticalThreshold', position='Body'),
  entityId: long(name='EntityId', minimum=1, maximum=2147483647, position='Body'),
  expectValue?: string(name='ExpectValue', position='Body'),
  methodName?: string(name='MethodName', position='Body'),
  operator?: string(name='Operator', position='Body'),
  predictType: int32(name='PredictType', minimum=0, maximum=99, position='Body'),
  projectName: string(name='ProjectName', position='Body'),
  property?: string(name='Property', maxLength=128, position='Body'),
  propertyType?: string(name='PropertyType', position='Body'),
  ruleName: string(name='RuleName', maxLength=128, position='Body'),
  ruleType: int32(name='RuleType', minimum=0, maximum=99, position='Body'),
  templateId?: int32(name='TemplateId', minimum=1, position='Body'),
  trend?: string(name='Trend', position='Body'),
  warningThreshold?: string(name='WarningThreshold', position='Body'),
  whereCondition?: string(name='WhereCondition', position='Body'),
}

model CreateQualityRuleResponseBody = {
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateQualityRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateQualityRuleResponseBody(name='body'),
}

async function createQualityRule(request: CreateQualityRuleRequest): CreateQualityRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateQualityRule', 'POST', '/', 'json', true, 'form', request);
}

model CreateRemindRequest {
  regionId: string(name='RegionId', position='Host'),
  alertInterval?: int32(name='AlertInterval', minimum=1200, position='Body'),
  alertMethods: string(name='AlertMethods', position='Body'),
  alertTargets?: string(name='AlertTargets', position='Body'),
  alertUnit: string(name='AlertUnit', position='Body'),
  baselineIds?: string(name='BaselineIds', position='Body'),
  bizProcessIds?: string(name='BizProcessIds', position='Body'),
  detail?: string(name='Detail', position='Body'),
  dndEnd?: string(name='DndEnd', position='Body'),
  maxAlertTimes?: int32(name='MaxAlertTimes', minimum=1, maximum=10, position='Body'),
  nodeIds?: string(name='NodeIds', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  remindName: string(name='RemindName', position='Body'),
  remindType: string(name='RemindType', position='Body'),
  remindUnit: string(name='RemindUnit', position='Body'),
  robotUrls?: string(name='RobotUrls', position='Body'),
  webhooks?: string(name='Webhooks', position='Body'),
}

model CreateRemindResponseBody = {
  data?: long(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateRemindResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRemindResponseBody(name='body'),
}

async function createRemind(request: CreateRemindRequest): CreateRemindResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRemind', 'POST', '/', 'json', true, 'form', request);
}

model CreateTableRequest {
  regionId: string(name='RegionId', position='Host'),
  appGuid?: string(name='AppGuid', position='Query'),
  categoryId?: long(name='CategoryId', minimum=1, maximum=9223372036854775807, position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  columns: [ 
    {
      columnName: string(name='ColumnName'),
      columnNameCn?: string(name='ColumnNameCn'),
      columnType: string(name='ColumnType'),
      comment?: string(name='Comment'),
      isPartitionCol?: boolean(name='IsPartitionCol'),
      length?: int32(name='Length'),
      seqNumber?: int32(name='SeqNumber'),
    }
  ](name='Columns', position='Body'),
  comment?: string(name='Comment', position='Query'),
  endpoint?: string(name='Endpoint', position='Body'),
  envType?: int32(name='EnvType', position='Body'),
  externalTableType?: string(name='ExternalTableType', position='Query'),
  hasPart?: int32(name='HasPart', position='Query'),
  isView?: int32(name='IsView', position='Query'),
  lifeCycle?: int32(name='LifeCycle', position='Query'),
  location?: string(name='Location', position='Query'),
  logicalLevelId?: long(name='LogicalLevelId', minimum=1, maximum=9223372036854775807, position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  physicsLevelId?: long(name='PhysicsLevelId', minimum=1, maximum=9223372036854775807, position='Query'),
  projectId?: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Query'),
  schema?: string(name='Schema', position='Query'),
  tableName: string(name='TableName', position='Query'),
  themes?: [ 
    {
      themeId?: long(name='ThemeId', minimum=1, maximum=9223372036854775807),
      themeLevel?: int32(name='ThemeLevel'),
    }
  ](name='Themes', position='Body'),
  visibility?: int32(name='Visibility', position='Query'),
}

model CreateTableResponseBody = {
  requestId?: string(name='RequestId'),
  taskInfo?: {
    content?: string(name='Content'),
    nextTaskId?: string(name='NextTaskId'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
  }(name='TaskInfo'),
}

model CreateTableResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTableResponseBody(name='body'),
}

async function createTable(request: CreateTableRequest): CreateTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTable', 'POST', '/', 'json', true, 'form', request);
}

model CreateTableLevelRequest {
  regionId: string(name='RegionId', position='Host'),
  description?: string(name='Description', position='Query'),
  levelType: int32(name='LevelType', minimum=1, maximum=10, position='Query'),
  name: string(name='Name', position='Query'),
  projectId?: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Query'),
}

model CreateTableLevelResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  levelId?: long(name='LevelId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateTableLevelResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTableLevelResponseBody(name='body'),
}

async function createTableLevel(request: CreateTableLevelRequest): CreateTableLevelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTableLevel', 'POST', '/', 'json', false, 'json', request);
}

model CreateTableThemeRequest {
  regionId: string(name='RegionId', position='Host'),
  level: int32(name='Level', minimum=1, maximum=10, position='Query'),
  name: string(name='Name', position='Query'),
  parentId?: long(name='ParentId', minimum=1, maximum=9223372036854775807, position='Query'),
  projectId?: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Query'),
}

model CreateTableThemeResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  themeId?: long(name='ThemeId'),
}

model CreateTableThemeResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTableThemeResponseBody(name='body'),
}

async function createTableTheme(request: CreateTableThemeRequest): CreateTableThemeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTableTheme', 'POST', '/', 'json', false, 'json', request);
}

model CreateUdfFileRequest {
  regionId: string(name='RegionId', position='Host'),
  className: string(name='ClassName', position='Body'),
  cmdDescription?: string(name='CmdDescription', position='Body'),
  example?: string(name='Example', position='Body'),
  fileFolderPath?: string(name='FileFolderPath', position='Body'),
  fileName: string(name='FileName', position='Body'),
  functionType: string(name='FunctionType', position='Body'),
  parameterDescription?: string(name='ParameterDescription', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
  resources: string(name='Resources', position='Body'),
  returnValue?: string(name='ReturnValue', position='Body'),
  udfDescription?: string(name='UdfDescription', position='Body'),
}

model CreateUdfFileResponseBody = {
  data?: long(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateUdfFileResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUdfFileResponseBody(name='body'),
}

async function createUdfFile(request: CreateUdfFileRequest): CreateUdfFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUdfFile', 'POST', '/', 'json', true, 'form', request);
}

model DeleteBaselineRequest {
  regionId?: string(name='RegionId', position='Host'),
  baselineId: long(name='BaselineId', description='基线Id', position='Body'),
  projectId: long(name='ProjectId', description='项目空间ID', position='Body'),
}

model DeleteBaselineResponseBody = {
  data?: boolean(name='Data'),
  dynamicErrorCode?: string(name='DynamicErrorCode'),
  dynamicErrorMessage?: string(name='DynamicErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBaselineResponseBody(name='body'),
}

async function deleteBaseline(request: DeleteBaselineRequest): DeleteBaselineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBaseline', 'POST', '/', 'json', true, 'form', request);
}

model DeleteBusinessRequest {
  regionId: string(name='RegionId', position='Host'),
  businessId: long(name='BusinessId', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
}

model DeleteBusinessResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteBusinessResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBusinessResponseBody(name='body'),
}

async function deleteBusiness(request: DeleteBusinessRequest): DeleteBusinessResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBusiness', 'POST', '/', 'json', true, 'form', request);
}

model DeleteConnectionRequest {
  regionId: string(name='RegionId', position='Host'),
  connectionId: long(name='ConnectionId', position='Query'),
}

model DeleteConnectionResponseBody = {
  data?: boolean(name='Data'),
  httpStatusCode?: string(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteConnectionResponseBody(name='body'),
}

async function deleteConnection(request: DeleteConnectionRequest): DeleteConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteConnection', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDISyncTaskRequest {
  regionId: string(name='RegionId', position='Host'),
  fileId: long(name='FileId', minimum=1, maximum=9999999999999999, position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  taskType: string(name='TaskType', position='Query'),
}

model DeleteDISyncTaskResponseBody = {
  data?: {
    message?: string(name='Message'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDISyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDISyncTaskResponseBody(name='body'),
}

async function deleteDISyncTask(request: DeleteDISyncTaskRequest): DeleteDISyncTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDISyncTask', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDataServiceApiRequest {
  regionId: string(name='RegionId', position='Host'),
  apiId: long(name='ApiId', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
  tenantId: long(name='TenantId', position='Body'),
}

model DeleteDataServiceApiResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDataServiceApiResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataServiceApiResponseBody(name='body'),
}

async function deleteDataServiceApi(request: DeleteDataServiceApiRequest): DeleteDataServiceApiResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDataServiceApi', 'POST', '/', 'json', true, 'form', request);
}

model DeleteDataServiceApiAuthorityRequest {
  regionId: string(name='RegionId', position='Host'),
  apiId: long(name='ApiId', minimum=1, maximum=9223372036854775807, position='Body'),
  authorizedProjectId: long(name='AuthorizedProjectId', minimum=1, maximum=9223372036854775807, position='Body'),
  projectId: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Body'),
  tenantId: long(name='TenantId', minimum=1, maximum=9223372036854775807, position='Body'),
}

model DeleteDataServiceApiAuthorityResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDataServiceApiAuthorityResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataServiceApiAuthorityResponseBody(name='body'),
}

async function deleteDataServiceApiAuthority(request: DeleteDataServiceApiAuthorityRequest): DeleteDataServiceApiAuthorityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDataServiceApiAuthority', 'POST', '/', 'json', true, 'form', request);
}

model DeleteDataSourceRequest {
  regionId: string(name='RegionId', position='Host'),
  dataSourceId: long(name='DataSourceId', position='Query'),
}

model DeleteDataSourceResponseBody = {
  data?: boolean(name='Data'),
  httpStatusCode?: string(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataSourceResponseBody(name='body'),
}

async function deleteDataSource(request: DeleteDataSourceRequest): DeleteDataSourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDataSource', 'POST', '/', 'json', false, 'json', request);
}

model DeleteFileRequest {
  regionId: string(name='RegionId', position='Host'),
  fileId: long(name='FileId', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
}

model DeleteFileResponseBody = {
  deploymentId?: long(name='DeploymentId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteFileResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFileResponseBody(name='body'),
}

async function deleteFile(request: DeleteFileRequest): DeleteFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFile', 'POST', '/', 'json', true, 'form', request);
}

model DeleteFolderRequest {
  regionId: string(name='RegionId', position='Host'),
  folderId: string(name='FolderId', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
}

model DeleteFolderResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteFolderResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFolderResponseBody(name='body'),
}

async function deleteFolder(request: DeleteFolderRequest): DeleteFolderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFolder', 'POST', '/', 'json', true, 'form', request);
}

model DeleteFromMetaCategoryRequest {
  regionId: string(name='RegionId', position='Host'),
  categoryId: long(name='CategoryId', position='Query'),
  tableGuid: string(name='TableGuid', position='Query'),
}

model DeleteFromMetaCategoryResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteFromMetaCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFromMetaCategoryResponseBody(name='body'),
}

async function deleteFromMetaCategory(request: DeleteFromMetaCategoryRequest): DeleteFromMetaCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFromMetaCategory', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMetaCategoryRequest {
  regionId: string(name='RegionId', position='Host'),
  categoryId: long(name='CategoryId', position='Query'),
}

model DeleteMetaCategoryResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMetaCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMetaCategoryResponseBody(name='body'),
}

async function deleteMetaCategory(request: DeleteMetaCategoryRequest): DeleteMetaCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMetaCategory', 'GET', '/', 'json', false, 'json', request);
}

model DeleteProjectMemberRequest {
  regionId: string(name='RegionId', position='Host'),
  projectId: long(name='ProjectId', minimum=0, maximum=100000000, position='Query'),
  userId: string(name='UserId', position='Query'),
}

model DeleteProjectMemberResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteProjectMemberResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProjectMemberResponseBody(name='body'),
}

async function deleteProjectMember(request: DeleteProjectMemberRequest): DeleteProjectMemberResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteProjectMember', 'POST', '/', 'json', false, 'json', request);
}

model DeleteQualityEntityRequest {
  regionId: string(name='RegionId', position='Host'),
  entityId: long(name='EntityId', minimum=1, maximum=2147483647, position='Body'),
  envType: string(name='EnvType', position='Body'),
  projectName: string(name='ProjectName', position='Body'),
}

model DeleteQualityEntityResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteQualityEntityResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteQualityEntityResponseBody(name='body'),
}

async function deleteQualityEntity(request: DeleteQualityEntityRequest): DeleteQualityEntityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteQualityEntity', 'POST', '/', 'json', true, 'form', request);
}

model DeleteQualityFollowerRequest {
  regionId: string(name='RegionId', position='Host'),
  followerId: long(name='FollowerId', position='Body'),
  projectName: string(name='ProjectName', position='Body'),
}

model DeleteQualityFollowerResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteQualityFollowerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteQualityFollowerResponseBody(name='body'),
}

async function deleteQualityFollower(request: DeleteQualityFollowerRequest): DeleteQualityFollowerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteQualityFollower', 'POST', '/', 'json', true, 'form', request);
}

model DeleteQualityRelativeNodeRequest {
  regionId: string(name='RegionId', position='Host'),
  envType: string(name='EnvType', minLength=1, maxLength=40, position='Body'),
  matchExpression: string(name='MatchExpression', minLength=1, maxLength=80, position='Body'),
  nodeId: long(name='NodeId', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
  projectName: string(name='ProjectName', position='Body'),
  tableName: string(name='TableName', minLength=1, maxLength=128, position='Body'),
  targetNodeProjectId: long(name='TargetNodeProjectId', position='Body'),
  targetNodeProjectName: string(name='TargetNodeProjectName', minLength=1, maxLength=512, position='Body'),
}

model DeleteQualityRelativeNodeResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteQualityRelativeNodeResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteQualityRelativeNodeResponseBody(name='body'),
}

async function deleteQualityRelativeNode(request: DeleteQualityRelativeNodeRequest): DeleteQualityRelativeNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteQualityRelativeNode', 'POST', '/', 'json', true, 'form', request);
}

model DeleteQualityRuleRequest {
  regionId: string(name='RegionId', position='Host'),
  projectName: string(name='ProjectName', position='Body'),
  ruleId: long(name='RuleId', position='Body'),
}

model DeleteQualityRuleResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteQualityRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteQualityRuleResponseBody(name='body'),
}

async function deleteQualityRule(request: DeleteQualityRuleRequest): DeleteQualityRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteQualityRule', 'POST', '/', 'json', true, 'form', request);
}

model DeleteRemindRequest {
  regionId: string(name='RegionId', position='Host'),
  remindId: long(name='RemindId', position='Body'),
}

model DeleteRemindResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteRemindResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRemindResponseBody(name='body'),
}

async function deleteRemind(request: DeleteRemindRequest): DeleteRemindResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRemind', 'POST', '/', 'json', true, 'form', request);
}

model DeleteTableRequest {
  regionId: string(name='RegionId', position='Host'),
  appGuid?: string(name='AppGuid', position='Query'),
  envType?: int32(name='EnvType', minimum=0, maximum=1, position='Query'),
  projectId?: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Query'),
  schema?: string(name='Schema', position='Query'),
  tableName: string(name='TableName', position='Query'),
}

model DeleteTableResponseBody = {
  requestId?: string(name='RequestId'),
  taskInfo?: {
    content?: string(name='Content'),
    nextTaskId?: string(name='NextTaskId'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
  }(name='TaskInfo'),
}

model DeleteTableResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTableResponseBody(name='body'),
}

async function deleteTable(request: DeleteTableRequest): DeleteTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTable', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTableLevelRequest {
  regionId: string(name='RegionId', position='Host'),
  levelId: long(name='LevelId', minimum=1, maximum=9223372036854775807, position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Query'),
}

model DeleteTableLevelResponseBody = {
  deleteResult?: boolean(name='DeleteResult'),
  requestId?: string(name='RequestId'),
}

model DeleteTableLevelResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTableLevelResponseBody(name='body'),
}

async function deleteTableLevel(request: DeleteTableLevelRequest): DeleteTableLevelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTableLevel', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTableThemeRequest {
  regionId: string(name='RegionId', position='Host'),
  projectId?: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Query'),
  themeId: long(name='ThemeId', minimum=1, maximum=9223372036854775807, position='Query'),
}

model DeleteTableThemeResponseBody = {
  deleteResult?: boolean(name='DeleteResult'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteTableThemeResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTableThemeResponseBody(name='body'),
}

async function deleteTableTheme(request: DeleteTableThemeRequest): DeleteTableThemeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTableTheme', 'POST', '/', 'json', false, 'json', request);
}

model DeployDISyncTaskRequest {
  regionId: string(name='RegionId', position='Host'),
  fileId: long(name='FileId', minimum=1, maximum=9999999999999999, position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  taskType: string(name='TaskType', position='Query'),
}

model DeployDISyncTaskResponseBody = {
  data?: {
    message?: string(name='Message'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeployDISyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeployDISyncTaskResponseBody(name='body'),
}

async function deployDISyncTask(request: DeployDISyncTaskRequest): DeployDISyncTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeployDISyncTask', 'POST', '/', 'json', false, 'json', request);
}

model DeployFileRequest {
  regionId: string(name='RegionId', position='Host'),
  comment?: string(name='Comment', position='Body'),
  fileId?: long(name='FileId', position='Body'),
  nodeId?: long(name='NodeId', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
}

model DeployFileResponseBody = {
  data?: long(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeployFileResponse = {
  headers: map[string]string(name='headers'),
  body: DeployFileResponseBody(name='body'),
}

async function deployFile(request: DeployFileRequest): DeployFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeployFile', 'POST', '/', 'json', true, 'form', request);
}

model DesensitizeDataRequest {
  regionId: string(name='RegionId', position='Host'),
  data: string(name='Data', position='Body'),
  sceneCode: string(name='SceneCode', position='Body'),
}

model DesensitizeDataResponseBody = {
  desensitizeData?: string(name='DesensitizeData'),
  requestId?: string(name='RequestId'),
}

model DesensitizeDataResponse = {
  headers: map[string]string(name='headers'),
  body: DesensitizeDataResponseBody(name='body'),
}

async function desensitizeData(request: DesensitizeDataRequest): DesensitizeDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DesensitizeData', 'GET', '/', 'json', true, 'form', request);
}

model EstablishRelationTableToBusinessRequest {
  regionId: string(name='RegionId', position='Host'),
  businessId: string(name='BusinessId', position='Body'),
  folderId?: string(name='FolderId', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
  tableGuid: string(name='TableGuid', position='Body'),
}

model EstablishRelationTableToBusinessResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EstablishRelationTableToBusinessResponse = {
  headers: map[string]string(name='headers'),
  body: EstablishRelationTableToBusinessResponseBody(name='body'),
}

async function establishRelationTableToBusiness(request: EstablishRelationTableToBusinessRequest): EstablishRelationTableToBusinessResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EstablishRelationTableToBusiness', 'POST', '/', 'json', true, 'form', request);
}

model ExportDataSourcesRequest {
  regionId: string(name='RegionId', position='Host'),
  dataSourceType?: string(name='DataSourceType', position='Query'),
  envType?: int32(name='EnvType', position='Query'),
  name?: string(name='Name', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=100, position='Query'),
  pageSize?: int32(name='PageSize', maximum=100, position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  subType?: string(name='SubType', position='Query'),
}

model ExportDataSourcesResponseBody = {
  data?: {
    dataSources?: [ 
      {
        bindingCalcEngineId?: int32(name='BindingCalcEngineId'),
        connectStatus?: int32(name='ConnectStatus'),
        content?: string(name='Content'),
        dataSourceType?: string(name='DataSourceType'),
        defaultEngine?: boolean(name='DefaultEngine'),
        description?: string(name='Description'),
        envType?: int32(name='EnvType'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: int32(name='Id'),
        name?: string(name='Name'),
        operator?: string(name='Operator'),
        projectId?: int32(name='ProjectId'),
        sequence?: int32(name='Sequence'),
        shared?: boolean(name='Shared'),
        status?: int32(name='Status'),
        subType?: string(name='SubType'),
        tenantId?: long(name='TenantId'),
      }
    ](name='DataSources'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExportDataSourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ExportDataSourcesResponseBody(name='body'),
}

async function exportDataSources(request: ExportDataSourcesRequest): ExportDataSourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportDataSources', 'GET', '/', 'json', false, 'json', request);
}

model GenerateDISyncTaskConfigForCreatingRequest {
  regionId: string(name='RegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  taskParam: string(name='TaskParam', position='Query'),
  taskType: string(name='TaskType', position='Query'),
}

model GenerateDISyncTaskConfigForCreatingResponseBody = {
  data?: {
    message?: string(name='Message'),
    processId?: long(name='ProcessId'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GenerateDISyncTaskConfigForCreatingResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateDISyncTaskConfigForCreatingResponseBody(name='body'),
}

async function generateDISyncTaskConfigForCreating(request: GenerateDISyncTaskConfigForCreatingRequest): GenerateDISyncTaskConfigForCreatingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GenerateDISyncTaskConfigForCreating', 'POST', '/', 'json', false, 'json', request);
}

model GenerateDISyncTaskConfigForUpdatingRequest {
  regionId: string(name='RegionId', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  taskId: long(name='TaskId', minimum=0, maximum=9999999999999999, position='Query'),
  taskParam: string(name='TaskParam', position='Query'),
  taskType: string(name='TaskType', position='Query'),
}

model GenerateDISyncTaskConfigForUpdatingResponseBody = {
  data?: {
    message?: string(name='Message'),
    processId?: long(name='ProcessId'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GenerateDISyncTaskConfigForUpdatingResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateDISyncTaskConfigForUpdatingResponseBody(name='body'),
}

async function generateDISyncTaskConfigForUpdating(request: GenerateDISyncTaskConfigForUpdatingRequest): GenerateDISyncTaskConfigForUpdatingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GenerateDISyncTaskConfigForUpdating', 'POST', '/', 'json', false, 'json', request);
}

model GetBaselineRequest {
  regionId?: string(name='RegionId', position='Host'),
  baselineId: long(name='BaselineId', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
}

model GetBaselineResponseBody = {
  data?: {
    alertEnabled?: boolean(name='AlertEnabled', description='是否开启告警'),
    alertMarginThreshold?: int32(name='AlertMarginThreshold', description='预警余量，单位为分钟'),
    alertSettings?: [ 
      {
        alertInterval?: int32(name='AlertInterval', description='事件告警间隔'),
        alertMaximum?: int32(name='AlertMaximum', description='事件告警最大次数'),
        alertMethods?: [ string ](name='AlertMethods', description='告警方式'),
        alertRecipient?: string(name='AlertRecipient', description='告警接收人详情'),
        alertRecipientType?: string(name='AlertRecipientType', description='告警接收人类型'),
        alertType?: string(name='AlertType', description='告警类型，BASELINE / TOPIC'),
        baselineAlertEnabled?: boolean(name='BaselineAlertEnabled', description='基线告警开关，基线特有配置'),
        dingRobots?: [ 
          {
            atAll?: boolean(name='AtAll'),
            webUrl?: string(name='WebUrl'),
          }
        ](name='DingRobots', description='钉钉机器人列表'),
        silenceEndTime?: string(name='SilenceEndTime', description='静默结束时间'),
        silenceStartTime?: string(name='SilenceStartTime', description='静默开始时间'),
        topicTypes?: [ string ](name='TopicTypes', description='事件告警类型，事件特有配置'),
        webhooks?: [ string ](name='Webhooks', description='webhook 列表'),
      }
    ](name='AlertSettings', description='告警设置'),
    baselineId?: long(name='BaselineId', description='基线id'),
    baselineName?: string(name='BaselineName', description='基线名'),
    baselineType?: string(name='BaselineType', description='基线类型 (DAILY, HOURLY)'),
    enabled?: boolean(name='Enabled', description='是否开启基线'),
    overTimeSettings?: [ 
      {
        cycle?: int32(name='Cycle', description='周期，取值范围 [1,24]'),
        time?: string(name='Time', description='承诺时间，hh:mm格式，hh的取值范围为[0,47]，mm的取值范围为[0,59]'),
      }
    ](name='OverTimeSettings', description='基线承诺时间设置'),
    owner?: string(name='Owner', description='责任人'),
    priority?: int32(name='Priority', description='优先级'),
    projectId?: long(name='ProjectId', description='项目id'),
    taskIds?: [ long ](name='TaskIds', description='基线节点列表'),
  }(name='Data'),
  dynamicErrorCode?: string(name='DynamicErrorCode'),
  dynamicErrorMessage?: string(name='DynamicErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: GetBaselineResponseBody(name='body'),
}

async function getBaseline(request: GetBaselineRequest): GetBaselineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetBaseline', 'POST', '/', 'json', true, 'form', request);
}

model GetBaselineConfigRequest {
  regionId: string(name='RegionId', position='Host'),
  baselineId: long(name='BaselineId', position='Body'),
}

model GetBaselineConfigResponseBody = {
  data?: {
    baselineId?: long(name='BaselineId'),
    baselineName?: string(name='BaselineName'),
    baselineType?: string(name='BaselineType'),
    expHour?: int32(name='ExpHour'),
    expMinu?: int32(name='ExpMinu'),
    hourExpDetail?: string(name='HourExpDetail'),
    hourSlaDetail?: string(name='HourSlaDetail'),
    isDefault?: boolean(name='IsDefault'),
    owner?: string(name='Owner'),
    priority?: int32(name='Priority'),
    projectId?: long(name='ProjectId'),
    slaHour?: int32(name='SlaHour'),
    slaMinu?: int32(name='SlaMinu'),
    useFlag?: boolean(name='UseFlag'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetBaselineConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetBaselineConfigResponseBody(name='body'),
}

async function getBaselineConfig(request: GetBaselineConfigRequest): GetBaselineConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetBaselineConfig', 'POST', '/', 'json', true, 'form', request);
}

model GetBaselineKeyPathRequest {
  regionId: string(name='RegionId', position='Host'),
  baselineId: long(name='BaselineId', position='Body'),
  bizdate: string(name='Bizdate', position='Body'),
  inGroupId: int32(name='InGroupId', position='Body'),
}

model GetBaselineKeyPathResponseBody = {
  data?: [ 
    {
      bizdate?: long(name='Bizdate'),
      inGroupId?: int32(name='InGroupId'),
      instanceId?: long(name='InstanceId'),
      nodeId?: long(name='NodeId'),
      nodeName?: string(name='NodeName'),
      owner?: string(name='Owner'),
      prgType?: int32(name='PrgType'),
      projectId?: long(name='ProjectId'),
      runs?: [ 
        {
          absTime?: long(name='AbsTime'),
          beginCast?: long(name='BeginCast'),
          beginRunningTime?: long(name='BeginRunningTime'),
          beginWaitResTime?: long(name='BeginWaitResTime'),
          beginWaitTimeTime?: long(name='BeginWaitTimeTime'),
          bizdate?: long(name='Bizdate'),
          cycTime?: long(name='CycTime'),
          endCast?: long(name='EndCast'),
          finishTime?: long(name='FinishTime'),
          inGroupId?: int32(name='InGroupId'),
          instanceId?: long(name='InstanceId'),
          nodeId?: long(name='NodeId'),
          nodeName?: string(name='NodeName'),
          owner?: string(name='Owner'),
          projectId?: long(name='ProjectId'),
          status?: string(name='Status'),
        }
      ](name='Runs'),
      topics?: [ 
        {
          addTime?: long(name='AddTime'),
          instanceId?: long(name='InstanceId'),
          topicId?: long(name='TopicId'),
          topicName?: long(name='TopicName'),
        }
      ](name='Topics'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetBaselineKeyPathResponse = {
  headers: map[string]string(name='headers'),
  body: GetBaselineKeyPathResponseBody(name='body'),
}

async function getBaselineKeyPath(request: GetBaselineKeyPathRequest): GetBaselineKeyPathResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetBaselineKeyPath', 'POST', '/', 'json', true, 'form', request);
}

model GetBaselineStatusRequest {
  regionId: string(name='RegionId', position='Host'),
  baselineId: long(name='BaselineId', position='Body'),
  bizdate: string(name='Bizdate', position='Body'),
  inGroupId: int32(name='InGroupId', position='Body'),
}

model GetBaselineStatusResponseBody = {
  data?: {
    baselineId?: long(name='BaselineId'),
    baselineName?: string(name='BaselineName'),
    bizdate?: long(name='Bizdate'),
    blockInstance?: {
      endCast?: long(name='EndCast'),
      finishTime?: long(name='FinishTime'),
      instanceId?: long(name='InstanceId'),
      nodeId?: long(name='NodeId'),
      nodeName?: string(name='NodeName'),
      owner?: string(name='Owner'),
      projectId?: long(name='ProjectId'),
      status?: string(name='Status'),
    }(name='BlockInstance'),
    buffer?: float(name='Buffer'),
    endCast?: long(name='EndCast'),
    expTime?: long(name='ExpTime'),
    finishStatus?: string(name='FinishStatus'),
    finishTime?: long(name='FinishTime'),
    inGroupId?: int32(name='InGroupId'),
    lastInstance?: {
      endCast?: long(name='EndCast'),
      finishTime?: long(name='FinishTime'),
      instanceId?: long(name='InstanceId'),
      nodeId?: long(name='NodeId'),
      nodeName?: string(name='NodeName'),
      owner?: string(name='Owner'),
      projectId?: long(name='ProjectId'),
      status?: string(name='Status'),
    }(name='LastInstance'),
    owner?: string(name='Owner'),
    priority?: int32(name='Priority'),
    projectId?: long(name='ProjectId'),
    slaTime?: long(name='SlaTime'),
    status?: string(name='Status'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetBaselineStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetBaselineStatusResponseBody(name='body'),
}

async function getBaselineStatus(request: GetBaselineStatusRequest): GetBaselineStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetBaselineStatus', 'POST', '/', 'json', true, 'form', request);
}

model GetBusinessRequest {
  regionId: string(name='RegionId', position='Host'),
  businessId: long(name='BusinessId', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
}

model GetBusinessResponseBody = {
  data?: {
    businessId?: long(name='BusinessId'),
    businessName?: string(name='BusinessName'),
    description?: string(name='Description'),
    owner?: string(name='Owner'),
    projectId?: string(name='ProjectId'),
    useType?: string(name='UseType'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetBusinessResponse = {
  headers: map[string]string(name='headers'),
  body: GetBusinessResponseBody(name='body'),
}

async function getBusiness(request: GetBusinessRequest): GetBusinessResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetBusiness', 'POST', '/', 'json', true, 'form', request);
}

model GetDDLJobStatusRequest {
  regionId: string(name='RegionId', position='Host'),
  taskId: string(name='TaskId', position='Query'),
}

model GetDDLJobStatusResponseBody = {
  data?: {
    content?: string(name='Content'),
    nextTaskId?: string(name='NextTaskId'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetDDLJobStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetDDLJobStatusResponseBody(name='body'),
}

async function getDDLJobStatus(request: GetDDLJobStatusRequest): GetDDLJobStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDDLJobStatus', 'GET', '/', 'json', false, 'json', request);
}

model GetDISyncInstanceInfoRequest {
  regionId: string(name='RegionId', position='Host'),
  fileId: long(name='FileId', minimum=1, maximum=9999999999999999, position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  taskType: string(name='TaskType', position='Query'),
}

model GetDISyncInstanceInfoResponseBody = {
  data?: {
    message?: string(name='Message'),
    name?: string(name='Name'),
    solutionInfo?: {
      creatorName?: string(name='CreatorName'),
      id?: long(name='Id'),
      status?: string(name='Status'),
      stepDetail?: [ 
        {
          info?: string(name='Info'),
          status?: string(name='Status'),
          stepId?: long(name='StepId'),
          stepName?: string(name='StepName'),
        }
      ](name='StepDetail'),
    }(name='SolutionInfo'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDISyncInstanceInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetDISyncInstanceInfoResponseBody(name='body'),
}

async function getDISyncInstanceInfo(request: GetDISyncInstanceInfoRequest): GetDISyncInstanceInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDISyncInstanceInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetDISyncTaskRequest {
  regionId: string(name='RegionId', position='Host'),
  fileId: long(name='FileId', minimum=1, maximum=9999999999999999, position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  taskType: string(name='TaskType', position='Query'),
}

model GetDISyncTaskResponseBody = {
  data?: {
    code?: string(name='Code'),
    message?: string(name='Message'),
    solutionDetail?: {
      creatorName?: string(name='CreatorName'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      processContent?: string(name='ProcessContent'),
      processExtra?: string(name='ProcessExtra'),
      projectId?: long(name='ProjectId'),
      sourceType?: string(name='SourceType'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      submitTime?: string(name='SubmitTime'),
      type?: string(name='Type'),
    }(name='SolutionDetail'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDISyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetDISyncTaskResponseBody(name='body'),
}

async function getDISyncTask(request: GetDISyncTaskRequest): GetDISyncTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDISyncTask', 'POST', '/', 'json', false, 'json', request);
}

model GetDagRequest {
  regionId: string(name='RegionId', position='Host'),
  dagId: long(name='DagId', minimum=2, position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model GetDagResponseBody = {
  data?: {
    bizdate?: long(name='Bizdate'),
    createTime?: long(name='CreateTime'),
    createUser?: string(name='CreateUser'),
    dagId?: long(name='DagId'),
    finishTime?: long(name='FinishTime'),
    gmtdate?: long(name='Gmtdate'),
    modifyTime?: long(name='ModifyTime'),
    name?: string(name='Name'),
    opSeq?: long(name='OpSeq'),
    projectId?: long(name='ProjectId'),
    startTime?: long(name='StartTime'),
    status?: string(name='Status'),
    type?: string(name='Type'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDagResponse = {
  headers: map[string]string(name='headers'),
  body: GetDagResponseBody(name='body'),
}

async function getDag(request: GetDagRequest): GetDagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDag', 'POST', '/', 'json', true, 'form', request);
}

model GetDataServiceApiRequest {
  regionId: string(name='RegionId', position='Host'),
  apiId: long(name='ApiId', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
  tenantId: long(name='TenantId', position='Body'),
}

model GetDataServiceApiResponseBody = {
  data?: {
    apiId?: long(name='ApiId'),
    apiMode?: int32(name='ApiMode'),
    apiName?: string(name='ApiName'),
    apiPath?: string(name='ApiPath'),
    createdTime?: string(name='CreatedTime'),
    creatorId?: string(name='CreatorId'),
    description?: string(name='Description'),
    folderId?: long(name='FolderId'),
    groupId?: string(name='GroupId'),
    modifiedTime?: string(name='ModifiedTime'),
    operatorId?: string(name='OperatorId'),
    projectId?: long(name='ProjectId'),
    protocols?: [ int32 ](name='Protocols'),
    registrationDetails?: {
      failedResultSample?: string(name='FailedResultSample'),
      registrationErrorCodes?: [ 
        {
          errorCode?: string(name='ErrorCode'),
          errorMessage?: string(name='ErrorMessage'),
          errorSolution?: string(name='ErrorSolution'),
        }
      ](name='RegistrationErrorCodes'),
      registrationRequestParameters?: [ 
        {
          columnName?: string(name='ColumnName'),
          defaultValue?: string(name='DefaultValue'),
          exampleValue?: string(name='ExampleValue'),
          isRequiredParameter?: boolean(name='IsRequiredParameter'),
          parameterDataType?: int32(name='ParameterDataType'),
          parameterDescription?: string(name='ParameterDescription'),
          parameterName?: string(name='ParameterName'),
          parameterOperator?: int32(name='ParameterOperator'),
          parameterPosition?: int32(name='ParameterPosition'),
        }
      ](name='RegistrationRequestParameters'),
      serviceContentType?: int32(name='ServiceContentType'),
      serviceHost?: string(name='ServiceHost'),
      servicePath?: string(name='ServicePath'),
      serviceRequestBodyDescription?: string(name='ServiceRequestBodyDescription'),
      successfulResultSample?: string(name='SuccessfulResultSample'),
    }(name='RegistrationDetails'),
    requestMethod?: int32(name='RequestMethod'),
    responseContentType?: int32(name='ResponseContentType'),
    scriptDetails?: {
      isPagedResponse?: boolean(name='IsPagedResponse'),
      script?: string(name='Script'),
      scriptConnection?: {
        connectionId?: long(name='ConnectionId'),
        tableName?: string(name='TableName'),
      }(name='ScriptConnection'),
      scriptRequestParameters?: [ 
        {
          columnName?: string(name='ColumnName'),
          defaultValue?: string(name='DefaultValue'),
          exampleValue?: string(name='ExampleValue'),
          isRequiredParameter?: boolean(name='IsRequiredParameter'),
          parameterDataType?: int32(name='ParameterDataType'),
          parameterDescription?: string(name='ParameterDescription'),
          parameterName?: string(name='ParameterName'),
          parameterOperator?: int32(name='ParameterOperator'),
          parameterPosition?: int32(name='ParameterPosition'),
        }
      ](name='ScriptRequestParameters'),
      scriptResponseParameters?: [ 
        {
          columnName?: string(name='ColumnName'),
          exampleValue?: string(name='ExampleValue'),
          parameterDataType?: int32(name='ParameterDataType'),
          parameterDescription?: string(name='ParameterDescription'),
          parameterName?: string(name='ParameterName'),
        }
      ](name='ScriptResponseParameters'),
    }(name='ScriptDetails'),
    status?: int32(name='Status'),
    tenantId?: long(name='TenantId'),
    timeout?: int32(name='Timeout'),
    visibleRange?: int32(name='VisibleRange'),
    wizardDetails?: {
      isPagedResponse?: boolean(name='IsPagedResponse'),
      wizardConnection?: {
        connectionId?: long(name='ConnectionId'),
        tableName?: string(name='TableName'),
      }(name='WizardConnection'),
      wizardRequestParameters?: [ 
        {
          columnName?: string(name='ColumnName'),
          defaultValue?: string(name='DefaultValue'),
          exampleValue?: string(name='ExampleValue'),
          isRequiredParameter?: boolean(name='IsRequiredParameter'),
          parameterDataType?: int32(name='ParameterDataType'),
          parameterDescription?: string(name='ParameterDescription'),
          parameterName?: string(name='ParameterName'),
          parameterOperator?: int32(name='ParameterOperator'),
          parameterPosition?: int32(name='ParameterPosition'),
        }
      ](name='WizardRequestParameters'),
      wizardResponseParameters?: [ 
        {
          columnName?: string(name='ColumnName'),
          exampleValue?: string(name='ExampleValue'),
          parameterDataType?: int32(name='ParameterDataType'),
          parameterDescription?: string(name='ParameterDescription'),
          parameterName?: string(name='ParameterName'),
        }
      ](name='WizardResponseParameters'),
    }(name='WizardDetails'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataServiceApiResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataServiceApiResponseBody(name='body'),
}

async function getDataServiceApi(request: GetDataServiceApiRequest): GetDataServiceApiResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataServiceApi', 'POST', '/', 'json', true, 'form', request);
}

model GetDataServiceApiTestRequest {
  regionId: string(name='RegionId', position='Host'),
  testId: long(name='TestId', position='Query'),
}

model GetDataServiceApiTestResponseBody = {
  data?: {
    apiId?: long(name='ApiId'),
    costTime?: string(name='CostTime'),
    debugInfo?: string(name='DebugInfo'),
    nodesDebugInfo?: string(name='NodesDebugInfo'),
    paramMap?: string(name='ParamMap'),
    retCode?: long(name='RetCode'),
    retResult?: string(name='RetResult'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetDataServiceApiTestResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataServiceApiTestResponseBody(name='body'),
}

async function getDataServiceApiTest(request: GetDataServiceApiTestRequest): GetDataServiceApiTestResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataServiceApiTest', 'GET', '/', 'json', false, 'json', request);
}

model GetDataServiceApplicationRequest {
  regionId: string(name='RegionId', position='Host'),
  applicationId: long(name='ApplicationId', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
  tenantId: long(name='TenantId', position='Body'),
}

model GetDataServiceApplicationResponseBody = {
  data?: {
    applicationCode?: string(name='ApplicationCode'),
    applicationId?: long(name='ApplicationId'),
    applicationKey?: string(name='ApplicationKey'),
    applicationName?: string(name='ApplicationName'),
    applicationSecret?: string(name='ApplicationSecret'),
    projectId?: long(name='ProjectId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataServiceApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataServiceApplicationResponseBody(name='body'),
}

async function getDataServiceApplication(request: GetDataServiceApplicationRequest): GetDataServiceApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataServiceApplication', 'POST', '/', 'json', true, 'form', request);
}

model GetDataServiceFolderRequest {
  regionId: string(name='RegionId', position='Host'),
  folderId: long(name='FolderId', minimum=1, maximum=9223372036854775807, position='Body'),
  projectId: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Body'),
  tenantId: long(name='TenantId', minimum=1, maximum=9223372036854775807, position='Body'),
}

model GetDataServiceFolderResponseBody = {
  folder?: {
    createdTime?: string(name='CreatedTime'),
    folderId?: long(name='FolderId'),
    folderName?: string(name='FolderName'),
    groupId?: string(name='GroupId'),
    modifiedTime?: string(name='ModifiedTime'),
    parentId?: long(name='ParentId'),
    projectId?: long(name='ProjectId'),
    tenantId?: long(name='TenantId'),
  }(name='Folder'),
  requestId?: string(name='RequestId'),
}

model GetDataServiceFolderResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataServiceFolderResponseBody(name='body'),
}

async function getDataServiceFolder(request: GetDataServiceFolderRequest): GetDataServiceFolderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataServiceFolder', 'POST', '/', 'json', true, 'form', request);
}

model GetDataServiceGroupRequest {
  regionId: string(name='RegionId', position='Host'),
  groupId: string(name='GroupId', position='Body'),
  projectId: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Body'),
  tenantId: long(name='TenantId', minimum=1, maximum=9223372036854775807, position='Body'),
}

model GetDataServiceGroupResponseBody = {
  group?: {
    apiGatewayGroupId?: string(name='ApiGatewayGroupId'),
    createdTime?: string(name='CreatedTime'),
    creatorId?: string(name='CreatorId'),
    description?: string(name='Description'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    modifiedTime?: string(name='ModifiedTime'),
    projectId?: long(name='ProjectId'),
    tenantId?: long(name='TenantId'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model GetDataServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataServiceGroupResponseBody(name='body'),
}

async function getDataServiceGroup(request: GetDataServiceGroupRequest): GetDataServiceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataServiceGroup', 'POST', '/', 'json', true, 'form', request);
}

model GetDataServicePublishedApiRequest {
  regionId: string(name='RegionId', position='Host'),
  apiId: long(name='ApiId', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
  tenantId: long(name='TenantId', position='Body'),
}

model GetDataServicePublishedApiResponseBody = {
  data?: {
    apiId?: long(name='ApiId'),
    apiMode?: int32(name='ApiMode'),
    apiName?: string(name='ApiName'),
    apiPath?: string(name='ApiPath'),
    createdTime?: string(name='CreatedTime'),
    creatorId?: string(name='CreatorId'),
    description?: string(name='Description'),
    groupId?: string(name='GroupId'),
    modifiedTime?: string(name='ModifiedTime'),
    operatorId?: string(name='OperatorId'),
    projectId?: long(name='ProjectId'),
    protocols?: [ int32 ](name='Protocols'),
    registrationDetails?: {
      failedResultSample?: string(name='FailedResultSample'),
      registrationErrorCodes?: [ 
        {
          errorCode?: string(name='ErrorCode'),
          errorMessage?: string(name='ErrorMessage'),
          errorSolution?: string(name='ErrorSolution'),
        }
      ](name='RegistrationErrorCodes'),
      registrationRequestParameters?: [ 
        {
          defaultValue?: string(name='DefaultValue'),
          exampleValue?: string(name='ExampleValue'),
          isRequiredParameter?: boolean(name='IsRequiredParameter'),
          parameterDataType?: int32(name='ParameterDataType'),
          parameterDescription?: string(name='ParameterDescription'),
          parameterName?: string(name='ParameterName'),
          parameterOperator?: int32(name='ParameterOperator'),
          parameterPosition?: int32(name='ParameterPosition'),
        }
      ](name='RegistrationRequestParameters'),
      serviceContentType?: int32(name='ServiceContentType'),
      serviceHost?: string(name='ServiceHost'),
      servicePath?: string(name='ServicePath'),
      serviceRequestBodyDescription?: string(name='ServiceRequestBodyDescription'),
      successfulResultSample?: string(name='SuccessfulResultSample'),
    }(name='RegistrationDetails'),
    requestMethod?: int32(name='RequestMethod'),
    responseContentType?: int32(name='ResponseContentType'),
    scriptDetails?: {
      failedResultSample?: string(name='FailedResultSample'),
      isPagedResponse?: boolean(name='IsPagedResponse'),
      script?: string(name='Script'),
      scriptConnection?: {
        connectionId?: long(name='ConnectionId'),
        tableName?: string(name='TableName'),
      }(name='ScriptConnection'),
      scriptErrorCodes?: [ 
        {
          errorCode?: string(name='ErrorCode'),
          errorMessage?: string(name='ErrorMessage'),
          errorSolution?: string(name='ErrorSolution'),
        }
      ](name='ScriptErrorCodes'),
      scriptRequestParameters?: [ 
        {
          defaultValue?: string(name='DefaultValue'),
          exampleValue?: string(name='ExampleValue'),
          isRequiredParameter?: boolean(name='IsRequiredParameter'),
          parameterDataType?: int32(name='ParameterDataType'),
          parameterDescription?: string(name='ParameterDescription'),
          parameterName?: string(name='ParameterName'),
          parameterOperator?: int32(name='ParameterOperator'),
          parameterPosition?: int32(name='ParameterPosition'),
        }
      ](name='ScriptRequestParameters'),
      scriptResponseParameters?: [ 
        {
          exampleValue?: string(name='ExampleValue'),
          parameterDataType?: int32(name='ParameterDataType'),
          parameterDescription?: string(name='ParameterDescription'),
          parameterName?: string(name='ParameterName'),
        }
      ](name='ScriptResponseParameters'),
      successfulResultSample?: string(name='SuccessfulResultSample'),
    }(name='ScriptDetails'),
    status?: int32(name='Status'),
    tenantId?: long(name='TenantId'),
    timeout?: int32(name='Timeout'),
    visibleRange?: int32(name='VisibleRange'),
    wizardDetails?: {
      failedResultSample?: string(name='FailedResultSample'),
      isPagedResponse?: boolean(name='IsPagedResponse'),
      successfulResultSample?: string(name='SuccessfulResultSample'),
      wizardConnection?: {
        connectionId?: long(name='ConnectionId'),
        tableName?: string(name='TableName'),
      }(name='WizardConnection'),
      wizardErrorCodes?: [ 
        {
          errorCode?: string(name='ErrorCode'),
          errorMessage?: string(name='ErrorMessage'),
          errorSolution?: string(name='ErrorSolution'),
        }
      ](name='WizardErrorCodes'),
      wizardRequestParameters?: [ 
        {
          defaultValue?: string(name='DefaultValue'),
          exampleValue?: string(name='ExampleValue'),
          isRequiredParameter?: boolean(name='IsRequiredParameter'),
          parameterDataType?: int32(name='ParameterDataType'),
          parameterDescription?: string(name='ParameterDescription'),
          parameterName?: string(name='ParameterName'),
          parameterOperator?: int32(name='ParameterOperator'),
          parameterPosition?: int32(name='ParameterPosition'),
        }
      ](name='WizardRequestParameters'),
      wizardResponseParameters?: [ 
        {
          exampleValue?: string(name='ExampleValue'),
          parameterDataType?: int32(name='ParameterDataType'),
          parameterDescription?: string(name='ParameterDescription'),
          parameterName?: string(name='ParameterName'),
        }
      ](name='WizardResponseParameters'),
    }(name='WizardDetails'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataServicePublishedApiResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataServicePublishedApiResponseBody(name='body'),
}

async function getDataServicePublishedApi(request: GetDataServicePublishedApiRequest): GetDataServicePublishedApiResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataServicePublishedApi', 'POST', '/', 'json', true, 'form', request);
}

model GetDataSourceMetaRequest {
  regionId: string(name='RegionId', position='Host'),
  datasourceName: string(name='DatasourceName', position='Query'),
  envType?: string(name='EnvType', position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, maximum=100, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=100, position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
}

model GetDataSourceMetaResponseBody = {
  data?: {
    message?: string(name='Message'),
    meta?: string(name='Meta'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataSourceMetaResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataSourceMetaResponseBody(name='body'),
}

async function getDataSourceMeta(request: GetDataSourceMetaRequest): GetDataSourceMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataSourceMeta', 'POST', '/', 'json', false, 'json', request);
}

model GetDeploymentRequest {
  regionId: string(name='RegionId', position='Host'),
  deploymentId: long(name='DeploymentId', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
}

model GetDeploymentResponseBody = {
  data?: {
    deployedItems?: [ 
      {
        fileId?: long(name='FileId'),
        fileVersion?: long(name='FileVersion'),
        status?: int32(name='Status'),
      }
    ](name='DeployedItems'),
    deployment?: {
      checkingStatus?: int32(name='CheckingStatus'),
      createTime?: long(name='CreateTime'),
      creatorId?: string(name='CreatorId'),
      errorMessage?: string(name='ErrorMessage'),
      executeTime?: long(name='ExecuteTime'),
      fromEnvironment?: int32(name='FromEnvironment'),
      handlerId?: string(name='HandlerId'),
      name?: string(name='Name'),
      status?: int32(name='Status'),
      toEnvironment?: int32(name='ToEnvironment'),
    }(name='Deployment'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDeploymentResponse = {
  headers: map[string]string(name='headers'),
  body: GetDeploymentResponseBody(name='body'),
}

async function getDeployment(request: GetDeploymentRequest): GetDeploymentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDeployment', 'POST', '/', 'json', true, 'form', request);
}

model GetExtensionRequest {
  regionId?: string(name='RegionId', position='Host'),
  extensionCode: string(name='ExtensionCode', position='Query'),
}

model GetExtensionResponseBody = {
  extension?: {
    bindEventList?: [ 
      {
        eventCode?: string(name='EventCode'),
        eventName?: string(name='EventName'),
      }
    ](name='BindEventList'),
    detailUrl?: string(name='DetailUrl'),
    eventCategoryList?: [ 
      {
        categoryCode?: string(name='CategoryCode'),
        categoryName?: string(name='CategoryName'),
      }
    ](name='EventCategoryList'),
    extensionCode?: string(name='ExtensionCode'),
    extensionDesc?: string(name='ExtensionDesc'),
    extensionName?: string(name='ExtensionName'),
    helpDocUrl?: string(name='HelpDocUrl'),
    optionSetting?: string(name='OptionSetting'),
    parameterSetting?: string(name='ParameterSetting'),
    projectTesting?: long(name='ProjectTesting'),
    status?: int32(name='Status'),
  }(name='Extension'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetExtensionResponse = {
  headers: map[string]string(name='headers'),
  body: GetExtensionResponseBody(name='body'),
}

async function getExtension(request: GetExtensionRequest): GetExtensionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetExtension', 'POST', '/', 'json', false, 'json', request);
}

model GetFileRequest {
  regionId: string(name='RegionId', position='Host'),
  fileId?: long(name='FileId', position='Body'),
  nodeId?: long(name='NodeId', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
}

model GetFileResponseBody = {
  data?: {
    file?: {
      advancedSettings?: string(name='AdvancedSettings'),
      autoParsing?: boolean(name='AutoParsing'),
      bizId?: long(name='BizId'),
      businessId?: long(name='BusinessId'),
      commitStatus?: int32(name='CommitStatus'),
      connectionName?: string(name='ConnectionName'),
      content?: string(name='Content'),
      createTime?: long(name='CreateTime'),
      createUser?: string(name='CreateUser'),
      currentVersion?: int32(name='CurrentVersion'),
      deletedStatus?: string(name='DeletedStatus'),
      fileDescription?: string(name='FileDescription'),
      fileFolderId?: string(name='FileFolderId'),
      fileName?: string(name='FileName'),
      fileType?: int32(name='FileType'),
      isMaxCompute?: boolean(name='IsMaxCompute'),
      lastEditTime?: long(name='LastEditTime'),
      lastEditUser?: string(name='LastEditUser'),
      nodeId?: long(name='NodeId'),
      owner?: string(name='Owner'),
      parentId?: long(name='ParentId'),
      useType?: string(name='UseType'),
    }(name='File'),
    nodeConfiguration?: {
      autoRerunIntervalMillis?: int32(name='AutoRerunIntervalMillis'),
      autoRerunTimes?: int32(name='AutoRerunTimes'),
      cronExpress?: string(name='CronExpress'),
      cycleType?: string(name='CycleType'),
      dependentNodeIdList?: string(name='DependentNodeIdList'),
      dependentType?: string(name='DependentType'),
      endEffectDate?: long(name='EndEffectDate'),
      inputList?: [ 
        {
          input?: string(name='Input'),
          parseType?: string(name='ParseType'),
        }
      ](name='InputList'),
      inputParameters?: [ 
        {
          parameterName?: string(name='ParameterName'),
          valueSource?: string(name='ValueSource'),
        }
      ](name='InputParameters'),
      outputList?: [ 
        {
          output?: string(name='Output'),
          refTableName?: string(name='RefTableName'),
        }
      ](name='OutputList'),
      outputParameters?: [ 
        {
          description?: string(name='Description'),
          parameterName?: string(name='ParameterName'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='OutputParameters'),
      paraValue?: string(name='ParaValue'),
      rerunMode?: string(name='RerunMode'),
      resourceGroupId?: long(name='ResourceGroupId'),
      schedulerType?: string(name='SchedulerType'),
      startEffectDate?: long(name='StartEffectDate'),
      startImmediately?: boolean(name='StartImmediately'),
      stop?: boolean(name='Stop'),
    }(name='NodeConfiguration'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetFileResponse = {
  headers: map[string]string(name='headers'),
  body: GetFileResponseBody(name='body'),
}

async function getFile(request: GetFileRequest): GetFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetFile', 'POST', '/', 'json', true, 'form', request);
}

model GetFileTypeStatisticRequest {
  regionId: string(name='RegionId', position='Host'),
  projectEnv: string(name='ProjectEnv', position='Body'),
  projectId: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Body'),
}

model GetFileTypeStatisticResponseBody = {
  programTypeAndCounts?: [ 
    {
      count?: int32(name='Count'),
      programType?: string(name='ProgramType'),
    }
  ](name='ProgramTypeAndCounts'),
  requestId?: string(name='RequestId'),
}

model GetFileTypeStatisticResponse = {
  headers: map[string]string(name='headers'),
  body: GetFileTypeStatisticResponseBody(name='body'),
}

async function getFileTypeStatistic(request: GetFileTypeStatisticRequest): GetFileTypeStatisticResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetFileTypeStatistic', 'POST', '/', 'json', true, 'form', request);
}

model GetFileVersionRequest {
  regionId?: string(name='RegionId', position='Host'),
  fileId: long(name='FileId', position='Body'),
  fileVersion: int32(name='FileVersion', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
}

model GetFileVersionResponseBody = {
  data?: {
    changeType?: string(name='ChangeType'),
    comment?: string(name='Comment'),
    commitTime?: long(name='CommitTime'),
    commitUser?: string(name='CommitUser'),
    fileContent?: string(name='FileContent'),
    fileName?: string(name='FileName'),
    filePropertyContent?: string(name='FilePropertyContent'),
    fileVersion?: int32(name='FileVersion'),
    isCurrentProd?: boolean(name='IsCurrentProd'),
    nodeContent?: string(name='NodeContent'),
    nodeId?: long(name='NodeId'),
    status?: string(name='Status'),
    useType?: string(name='UseType'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetFileVersionResponse = {
  headers: map[string]string(name='headers'),
  body: GetFileVersionResponseBody(name='body'),
}

async function getFileVersion(request: GetFileVersionRequest): GetFileVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetFileVersion', 'POST', '/', 'json', true, 'form', request);
}

model GetFolderRequest {
  regionId: string(name='RegionId', position='Host'),
  folderId?: string(name='FolderId', position='Body'),
  folderPath?: string(name='FolderPath', minLength=1, position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
}

model GetFolderResponseBody = {
  data?: {
    folderId?: string(name='FolderId'),
    folderPath?: string(name='FolderPath'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetFolderResponse = {
  headers: map[string]string(name='headers'),
  body: GetFolderResponseBody(name='body'),
}

async function getFolder(request: GetFolderRequest): GetFolderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetFolder', 'POST', '/', 'json', true, 'form', request);
}

model GetIDEEventDetailRequest {
  regionId: string(name='RegionId', position='Host'),
  messageId: string(name='MessageId', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
}

model GetIDEEventDetailResponseBody = {
  eventDetail?: {
    committedFile?: {
      changeType?: string(name='ChangeType'),
      comment?: string(name='Comment'),
      committor?: string(name='Committor'),
      content?: string(name='Content'),
      fileId?: long(name='FileId'),
      fileName?: string(name='FileName'),
      filePropertyContent?: {
        businessId?: long(name='BusinessId'),
        currentVersion?: long(name='CurrentVersion'),
        dataSourceName?: string(name='DataSourceName'),
        folderId?: string(name='FolderId'),
        owner?: string(name='Owner'),
        parentFileId?: long(name='ParentFileId'),
      }(name='FilePropertyContent'),
      fileType?: long(name='FileType'),
      nodeConfiguration?: {
        autoRerunIntervalMillis?: long(name='AutoRerunIntervalMillis'),
        autoRerunTimes?: long(name='AutoRerunTimes'),
        cronExpress?: string(name='CronExpress'),
        cycleType?: string(name='CycleType'),
        dependentNodeIdList?: string(name='DependentNodeIdList'),
        dependentType?: string(name='DependentType'),
        inputList?: [ 
          {
            input?: string(name='Input'),
            parseType?: string(name='ParseType'),
          }
        ](name='InputList'),
        outputList?: [ 
          {
            output?: string(name='Output'),
            refTableName?: string(name='RefTableName'),
          }
        ](name='OutputList'),
        paraValue?: string(name='ParaValue'),
        rerunMode?: string(name='RerunMode'),
        resourceGroupId?: long(name='ResourceGroupId'),
        schedulerType?: string(name='SchedulerType'),
      }(name='NodeConfiguration'),
      nodeId?: long(name='NodeId'),
      useType?: string(name='UseType'),
    }(name='CommittedFile'),
    deletedFile?: {
      businessId?: long(name='BusinessId'),
      content?: string(name='Content'),
      currentVersion?: long(name='CurrentVersion'),
      dataSourceName?: string(name='DataSourceName'),
      fileId?: long(name='FileId'),
      fileName?: string(name='FileName'),
      fileType?: long(name='FileType'),
      folderId?: string(name='FolderId'),
      nodeId?: long(name='NodeId'),
      owner?: string(name='Owner'),
      parentFileId?: long(name='ParentFileId'),
      useType?: string(name='UseType'),
    }(name='DeletedFile'),
    fileExecutionCommand?: {
      content?: string(name='Content'),
      dataSourceName?: string(name='DataSourceName'),
      fileId?: long(name='FileId'),
      fileType?: long(name='FileType'),
    }(name='FileExecutionCommand'),
    tableModel?: {
      columns?: [ 
        {
          columnName?: string(name='ColumnName'),
          columnType?: string(name='ColumnType'),
          comment?: string(name='Comment'),
          isPartitionColumn?: boolean(name='IsPartitionColumn'),
        }
      ](name='Columns'),
      comment?: string(name='Comment'),
      dataSourceName?: string(name='DataSourceName'),
      env?: string(name='Env'),
      lifeCycle?: long(name='LifeCycle'),
      location?: string(name='Location'),
      tableName?: string(name='TableName'),
    }(name='TableModel'),
  }(name='EventDetail'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetIDEEventDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetIDEEventDetailResponseBody(name='body'),
}

async function getIDEEventDetail(request: GetIDEEventDetailRequest): GetIDEEventDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetIDEEventDetail', 'POST', '/', 'json', true, 'form', request);
}

model GetInstanceRequest {
  regionId: string(name='RegionId', position='Host'),
  instanceId: long(name='InstanceId', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model GetInstanceResponseBody = {
  data?: {
    baselineId?: long(name='BaselineId'),
    beginRunningTime?: long(name='BeginRunningTime'),
    beginWaitResTime?: long(name='BeginWaitResTime'),
    beginWaitTimeTime?: long(name='BeginWaitTimeTime'),
    bizdate?: long(name='Bizdate'),
    businessId?: long(name='BusinessId'),
    connection?: string(name='Connection'),
    createTime?: long(name='CreateTime'),
    createUser?: string(name='CreateUser'),
    cycTime?: long(name='CycTime'),
    dagId?: long(name='DagId'),
    dagType?: string(name='DagType'),
    dqcDescription?: string(name='DqcDescription'),
    dqcType?: int32(name='DqcType'),
    finishTime?: long(name='FinishTime'),
    instanceId?: long(name='InstanceId'),
    modifyTime?: long(name='ModifyTime'),
    nodeId?: long(name='NodeId'),
    nodeName?: string(name='NodeName'),
    paramValues?: string(name='ParamValues'),
    priority?: int32(name='Priority'),
    relatedFlowId?: long(name='RelatedFlowId'),
    repeatInterval?: long(name='RepeatInterval'),
    repeatability?: boolean(name='Repeatability'),
    status?: string(name='Status'),
    taskRerunTime?: int32(name='TaskRerunTime'),
    taskType?: string(name='TaskType'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceResponseBody(name='body'),
}

async function getInstance(request: GetInstanceRequest): GetInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetInstance', 'POST', '/', 'json', true, 'form', request);
}

model GetInstanceConsumeTimeRankRequest {
  regionId: string(name='RegionId', position='Host'),
  bizdate: string(name='Bizdate', position='Body'),
  projectId: long(name='ProjectId', minimum=2, maximum=99999999999, position='Body'),
}

model GetInstanceConsumeTimeRankResponseBody = {
  instanceConsumeTimeRank?: {
    consumeTimeRank?: [ 
      {
        bizdate?: long(name='Bizdate'),
        consumed?: long(name='Consumed'),
        instanceId?: long(name='InstanceId'),
        nodeId?: long(name='NodeId'),
        nodeName?: string(name='NodeName'),
        owner?: string(name='Owner'),
        prgType?: int32(name='PrgType'),
      }
    ](name='ConsumeTimeRank'),
    updateTime?: long(name='UpdateTime'),
  }(name='InstanceConsumeTimeRank'),
  requestId?: string(name='RequestId'),
}

model GetInstanceConsumeTimeRankResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceConsumeTimeRankResponseBody(name='body'),
}

async function getInstanceConsumeTimeRank(request: GetInstanceConsumeTimeRankRequest): GetInstanceConsumeTimeRankResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetInstanceConsumeTimeRank', 'POST', '/', 'json', true, 'form', request);
}

model GetInstanceCountTrendRequest {
  regionId: string(name='RegionId', position='Host'),
  beginDate: string(name='BeginDate', position='Body'),
  endDate: string(name='EndDate', position='Body'),
  projectId: long(name='ProjectId', minimum=2, maximum=99999999999, position='Body'),
}

model GetInstanceCountTrendResponseBody = {
  instanceCounts?: [ 
    {
      count?: int32(name='Count'),
      date?: long(name='Date'),
    }
  ](name='InstanceCounts'),
  requestId?: string(name='RequestId'),
}

model GetInstanceCountTrendResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceCountTrendResponseBody(name='body'),
}

async function getInstanceCountTrend(request: GetInstanceCountTrendRequest): GetInstanceCountTrendResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetInstanceCountTrend', 'POST', '/', 'json', true, 'form', request);
}

model GetInstanceErrorRankRequest {
  regionId: string(name='RegionId', position='Host'),
  projectId: long(name='ProjectId', minimum=2, maximum=99999999999, position='Body'),
}

model GetInstanceErrorRankResponseBody = {
  instanceErrorRank?: {
    errorRank?: [ 
      {
        count?: int32(name='Count'),
        nodeId?: long(name='NodeId'),
        nodeName?: string(name='NodeName'),
        owner?: string(name='Owner'),
        prgType?: int32(name='PrgType'),
        projectId?: long(name='ProjectId'),
      }
    ](name='ErrorRank'),
    updateTime?: long(name='UpdateTime'),
  }(name='InstanceErrorRank'),
  requestId?: string(name='RequestId'),
}

model GetInstanceErrorRankResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceErrorRankResponseBody(name='body'),
}

async function getInstanceErrorRank(request: GetInstanceErrorRankRequest): GetInstanceErrorRankResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetInstanceErrorRank', 'POST', '/', 'json', true, 'form', request);
}

model GetInstanceLogRequest {
  regionId: string(name='RegionId', position='Host'),
  instanceHistoryId?: long(name='InstanceHistoryId', position='Body'),
  instanceId: long(name='InstanceId', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model GetInstanceLogResponseBody = {
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetInstanceLogResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceLogResponseBody(name='body'),
}

async function getInstanceLog(request: GetInstanceLogRequest): GetInstanceLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetInstanceLog', 'POST', '/', 'json', true, 'form', request);
}

model GetInstanceStatusCountRequest {
  regionId: string(name='RegionId', position='Host'),
  bizDate: string(name='BizDate', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
  projectId: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Body'),
}

model GetInstanceStatusCountResponseBody = {
  requestId?: string(name='RequestId'),
  statusCount?: {
    failureCount?: int32(name='FailureCount'),
    notRunCount?: int32(name='NotRunCount'),
    runningCount?: int32(name='RunningCount'),
    successCount?: int32(name='SuccessCount'),
    totalCount?: int32(name='TotalCount'),
    waitResCount?: int32(name='WaitResCount'),
    waitTimeCount?: int32(name='WaitTimeCount'),
  }(name='StatusCount'),
}

model GetInstanceStatusCountResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceStatusCountResponseBody(name='body'),
}

async function getInstanceStatusCount(request: GetInstanceStatusCountRequest): GetInstanceStatusCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetInstanceStatusCount', 'POST', '/', 'json', true, 'form', request);
}

model GetInstanceStatusStatisticRequest {
  regionId: string(name='RegionId', position='Host'),
  bizDate: string(name='BizDate', minLength=10, maxLength=10, position='Body'),
  dagType?: string(name='DagType', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
  projectId: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Body'),
  schedulerType?: string(name='SchedulerType', position='Body'),
}

model GetInstanceStatusStatisticResponseBody = {
  requestId?: string(name='RequestId'),
  statusCount?: {
    failureCount?: int32(name='FailureCount'),
    notRunCount?: int32(name='NotRunCount'),
    runningCount?: int32(name='RunningCount'),
    successCount?: int32(name='SuccessCount'),
    totalCount?: int32(name='TotalCount'),
    waitResCount?: int32(name='WaitResCount'),
    waitTimeCount?: int32(name='WaitTimeCount'),
  }(name='StatusCount'),
}

model GetInstanceStatusStatisticResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceStatusStatisticResponseBody(name='body'),
}

async function getInstanceStatusStatistic(request: GetInstanceStatusStatisticRequest): GetInstanceStatusStatisticResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetInstanceStatusStatistic', 'POST', '/', 'json', true, 'form', request);
}

model GetManualDagInstancesRequest {
  regionId: string(name='RegionId', position='Host'),
  dagId: string(name='DagId', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
  projectName: string(name='ProjectName', position='Body'),
}

model GetManualDagInstancesResponseBody = {
  instances?: [ 
    {
      beginRunningTime?: long(name='BeginRunningTime'),
      beginWaitResTime?: long(name='BeginWaitResTime'),
      beginWaitTimeTime?: long(name='BeginWaitTimeTime'),
      bizDate?: long(name='BizDate'),
      createTime?: long(name='CreateTime'),
      createUser?: string(name='CreateUser'),
      cycTime?: long(name='CycTime'),
      dagId?: long(name='DagId'),
      dagType?: string(name='DagType'),
      finishTime?: long(name='FinishTime'),
      instanceId?: long(name='InstanceId'),
      modifyTime?: long(name='ModifyTime'),
      nodeId?: long(name='NodeId'),
      nodeName?: string(name='NodeName'),
      paramValues?: string(name='ParamValues'),
      status?: string(name='Status'),
      taskType?: string(name='TaskType'),
    }
  ](name='Instances'),
  requestId?: string(name='RequestId'),
}

model GetManualDagInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: GetManualDagInstancesResponseBody(name='body'),
}

async function getManualDagInstances(request: GetManualDagInstancesRequest): GetManualDagInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetManualDagInstances', 'POST', '/', 'json', true, 'form', request);
}

model GetMetaCategoryRequest {
  regionId: string(name='RegionId', position='Host'),
  pageNum?: int32(name='PageNum', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  parentCategoryId?: long(name='ParentCategoryId', position='Query'),
}

model GetMetaCategoryResponseBody = {
  data?: {
    dataEntityList?: [ 
      {
        categoryId?: long(name='CategoryId'),
        comment?: string(name='Comment'),
        createTime?: long(name='CreateTime'),
        depth?: int32(name='Depth'),
        lastOperatorId?: string(name='LastOperatorId'),
        modifiedTime?: long(name='ModifiedTime'),
        name?: string(name='Name'),
        ownerId?: string(name='OwnerId'),
        parentCategoryId?: long(name='ParentCategoryId'),
      }
    ](name='DataEntityList'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaCategoryResponseBody(name='body'),
}

async function getMetaCategory(request: GetMetaCategoryRequest): GetMetaCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetaCategory', 'POST', '/', 'json', false, 'json', request);
}

model GetMetaColumnLineageRequest {
  regionId: string(name='RegionId', position='Host'),
  clusterId?: string(name='ClusterId', position='Query'),
  columnGuid?: string(name='ColumnGuid', position='Query'),
  columnName?: string(name='ColumnName', position='Query'),
  dataSourceType?: string(name='DataSourceType', position='Query'),
  databaseName?: string(name='DatabaseName', position='Query'),
  direction: string(name='Direction', position='Query'),
  pageNum?: int32(name='PageNum', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  tableName?: string(name='TableName', position='Query'),
}

model GetMetaColumnLineageResponseBody = {
  data?: {
    dataEntityList?: [ 
      {
        clusterId?: string(name='ClusterId'),
        columnGuid?: string(name='ColumnGuid'),
        columnName?: string(name='ColumnName'),
        databaseName?: string(name='DatabaseName'),
        tableName?: string(name='TableName'),
      }
    ](name='DataEntityList'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaColumnLineageResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaColumnLineageResponseBody(name='body'),
}

async function getMetaColumnLineage(request: GetMetaColumnLineageRequest): GetMetaColumnLineageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetaColumnLineage', 'POST', '/', 'json', false, 'json', request);
}

model GetMetaDBInfoRequest {
  regionId: string(name='RegionId', position='Host'),
  appGuid?: string(name='AppGuid', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  dataSourceType?: string(name='DataSourceType', position='Query'),
  databaseName?: string(name='DatabaseName', position='Query'),
}

model GetMetaDBInfoResponseBody = {
  data?: {
    appGuid?: string(name='AppGuid'),
    clusterBizId?: string(name='ClusterBizId'),
    comment?: string(name='Comment'),
    createTime?: long(name='CreateTime'),
    endpoint?: string(name='Endpoint'),
    envType?: int32(name='EnvType'),
    location?: string(name='Location'),
    modifyTime?: long(name='ModifyTime'),
    name?: string(name='Name'),
    ownerId?: string(name='OwnerId'),
    ownerName?: string(name='OwnerName'),
    projectId?: long(name='ProjectId'),
    projectName?: string(name='ProjectName'),
    projectNameCn?: string(name='ProjectNameCn'),
    tenantId?: long(name='TenantId'),
    type?: string(name='Type'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetMetaDBInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaDBInfoResponseBody(name='body'),
}

async function getMetaDBInfo(request: GetMetaDBInfoRequest): GetMetaDBInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetaDBInfo', 'GET', '/', 'json', false, 'json', request);
}

model GetMetaDBTableListRequest {
  regionId: string(name='RegionId', position='Host'),
  appGuid?: string(name='AppGuid', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  dataSourceType?: string(name='DataSourceType', position='Query'),
  databaseName?: string(name='DatabaseName', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model GetMetaDBTableListResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    tableEntityList?: [ 
      {
        databaseName?: string(name='DatabaseName'),
        tableGuid?: string(name='TableGuid'),
        tableName?: string(name='TableName'),
      }
    ](name='TableEntityList'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetMetaDBTableListResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaDBTableListResponseBody(name='body'),
}

async function getMetaDBTableList(request: GetMetaDBTableListRequest): GetMetaDBTableListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetaDBTableList', 'POST', '/', 'json', false, 'json', request);
}

model GetMetaTableBasicInfoRequest {
  regionId: string(name='RegionId', position='Host'),
  clusterId?: string(name='ClusterId', position='Query'),
  dataSourceType?: string(name='DataSourceType', position='Query'),
  databaseName?: string(name='DatabaseName', position='Query'),
  extension?: boolean(name='Extension', position='Query'),
  tableGuid?: string(name='TableGuid', position='Query'),
  tableName?: string(name='TableName', position='Query'),
}

model GetMetaTableBasicInfoResponseBody = {
  data?: {
    caption?: string(name='Caption'),
    clusterId?: string(name='ClusterId'),
    columnCount?: int32(name='ColumnCount'),
    comment?: string(name='Comment'),
    createTime?: long(name='CreateTime'),
    dataSize?: long(name='DataSize'),
    databaseName?: string(name='DatabaseName'),
    envType?: int32(name='EnvType'),
    favoriteCount?: long(name='FavoriteCount'),
    isPartitionTable?: boolean(name='IsPartitionTable'),
    isView?: boolean(name='IsView'),
    isVisible?: int32(name='IsVisible'),
    lastAccessTime?: long(name='LastAccessTime'),
    lastDdlTime?: long(name='LastDdlTime'),
    lastModifyTime?: long(name='LastModifyTime'),
    lifeCycle?: int32(name='LifeCycle'),
    location?: string(name='Location'),
    ownerId?: string(name='OwnerId'),
    partitionKeys?: string(name='PartitionKeys'),
    projectId?: long(name='ProjectId'),
    projectName?: string(name='ProjectName'),
    readCount?: long(name='ReadCount'),
    schema?: string(name='Schema'),
    tableGuid?: string(name='TableGuid'),
    tableName?: string(name='TableName'),
    tenantId?: long(name='TenantId'),
    viewCount?: long(name='ViewCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaTableBasicInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableBasicInfoResponseBody(name='body'),
}

async function getMetaTableBasicInfo(request: GetMetaTableBasicInfoRequest): GetMetaTableBasicInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetaTableBasicInfo', 'GET', '/', 'json', false, 'json', request);
}

model GetMetaTableChangeLogRequest {
  regionId: string(name='RegionId', position='Host'),
  changeType?: string(name='ChangeType', position='Body'),
  endDate?: string(name='EndDate', position='Body'),
  objectType?: string(name='ObjectType', position='Body'),
  pageNumber?: int32(name='PageNumber', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  startDate?: string(name='StartDate', position='Body'),
  tableGuid: string(name='TableGuid', position='Body'),
}

model GetMetaTableChangeLogResponseBody = {
  data?: {
    dataEntityList?: [ 
      {
        changeContent?: string(name='ChangeContent'),
        changeType?: string(name='ChangeType'),
        createTime?: long(name='CreateTime'),
        modifiedTime?: long(name='ModifiedTime'),
        objectType?: string(name='ObjectType'),
        operator?: string(name='Operator'),
      }
    ](name='DataEntityList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaTableChangeLogResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableChangeLogResponseBody(name='body'),
}

async function getMetaTableChangeLog(request: GetMetaTableChangeLogRequest): GetMetaTableChangeLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetaTableChangeLog', 'POST', '/', 'json', true, 'form', request);
}

model GetMetaTableColumnRequest {
  regionId: string(name='RegionId', position='Host'),
  clusterId?: string(name='ClusterId', position='Query'),
  dataSourceType?: string(name='DataSourceType', position='Query'),
  databaseName?: string(name='DatabaseName', position='Query'),
  pageNum?: int32(name='PageNum', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  tableGuid?: string(name='TableGuid', position='Query'),
  tableName?: string(name='TableName', position='Query'),
}

model GetMetaTableColumnResponseBody = {
  data?: {
    columnList?: [ 
      {
        caption?: string(name='Caption'),
        columnGuid?: string(name='ColumnGuid'),
        columnName?: string(name='ColumnName'),
        columnType?: string(name='ColumnType'),
        comment?: string(name='Comment'),
        isForeignKey?: boolean(name='IsForeignKey'),
        isPartitionColumn?: boolean(name='IsPartitionColumn'),
        isPrimaryKey?: boolean(name='IsPrimaryKey'),
        position?: int32(name='Position'),
        relationCount?: long(name='RelationCount'),
      }
    ](name='ColumnList'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaTableColumnResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableColumnResponseBody(name='body'),
}

async function getMetaTableColumn(request: GetMetaTableColumnRequest): GetMetaTableColumnResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetaTableColumn', 'GET', '/', 'json', false, 'json', request);
}

model GetMetaTableFullInfoRequest {
  regionId: string(name='RegionId', position='Host'),
  clusterId?: string(name='ClusterId', position='Query'),
  dataSourceType?: string(name='DataSourceType', position='Query'),
  databaseName?: string(name='DatabaseName', position='Query'),
  pageNum?: int32(name='PageNum', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  tableGuid?: string(name='TableGuid', position='Query'),
  tableName?: string(name='TableName', position='Query'),
}

model GetMetaTableFullInfoResponseBody = {
  data?: {
    clusterId?: string(name='ClusterId'),
    columnList?: [ 
      {
        caption?: string(name='Caption'),
        columnGuid?: string(name='ColumnGuid'),
        columnName?: string(name='ColumnName'),
        columnType?: string(name='ColumnType'),
        comment?: string(name='Comment'),
        isForeignKey?: boolean(name='IsForeignKey'),
        isPartitionColumn?: boolean(name='IsPartitionColumn'),
        isPrimaryKey?: boolean(name='IsPrimaryKey'),
        position?: int32(name='Position'),
      }
    ](name='ColumnList'),
    comment?: string(name='Comment'),
    createTime?: long(name='CreateTime'),
    dataSize?: long(name='DataSize'),
    databaseName?: string(name='DatabaseName'),
    envType?: int32(name='EnvType'),
    isVisible?: int32(name='IsVisible'),
    lastAccessTime?: long(name='LastAccessTime'),
    lastDdlTime?: long(name='LastDdlTime'),
    lastModifyTime?: long(name='LastModifyTime'),
    lifeCycle?: int32(name='LifeCycle'),
    location?: string(name='Location'),
    ownerId?: string(name='OwnerId'),
    partitionKeys?: string(name='PartitionKeys'),
    projectId?: long(name='ProjectId'),
    projectName?: string(name='ProjectName'),
    schema?: string(name='Schema'),
    tableGuid?: string(name='TableGuid'),
    tableName?: string(name='TableName'),
    tenantId?: long(name='TenantId'),
    totalColumnCount?: long(name='TotalColumnCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaTableFullInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableFullInfoResponseBody(name='body'),
}

async function getMetaTableFullInfo(request: GetMetaTableFullInfoRequest): GetMetaTableFullInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetaTableFullInfo', 'GET', '/', 'json', false, 'json', request);
}

model GetMetaTableIntroWikiRequest {
  regionId: string(name='RegionId', position='Host'),
  tableGuid: string(name='TableGuid', position='Query'),
  wikiVersion?: long(name='WikiVersion', position='Query'),
}

model GetMetaTableIntroWikiResponseBody = {
  data?: {
    content?: string(name='Content'),
    createTime?: long(name='CreateTime'),
    creator?: string(name='Creator'),
    creatorName?: string(name='CreatorName'),
    modifiedTime?: long(name='ModifiedTime'),
    version?: long(name='Version'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaTableIntroWikiResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableIntroWikiResponseBody(name='body'),
}

async function getMetaTableIntroWiki(request: GetMetaTableIntroWikiRequest): GetMetaTableIntroWikiResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetaTableIntroWiki', 'POST', '/', 'json', false, 'json', request);
}

model GetMetaTableLineageRequest {
  regionId: string(name='RegionId', position='Host'),
  clusterId?: string(name='ClusterId', position='Query'),
  dataSourceType?: string(name='DataSourceType', position='Query'),
  databaseName?: string(name='DatabaseName', position='Query'),
  direction: string(name='Direction', position='Query'),
  nextPrimaryKey?: string(name='NextPrimaryKey', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  tableGuid?: string(name='TableGuid', position='Query'),
  tableName?: string(name='TableName', position='Query'),
}

model GetMetaTableLineageResponseBody = {
  data?: {
    dataEntityList?: [ 
      {
        createTimestamp?: long(name='CreateTimestamp'),
        tableGuid?: string(name='TableGuid'),
        tableName?: string(name='TableName'),
      }
    ](name='DataEntityList'),
    hasNext?: boolean(name='HasNext'),
    nextPrimaryKey?: string(name='NextPrimaryKey'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaTableLineageResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableLineageResponseBody(name='body'),
}

async function getMetaTableLineage(request: GetMetaTableLineageRequest): GetMetaTableLineageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetaTableLineage', 'POST', '/', 'json', false, 'json', request);
}

model GetMetaTableListByCategoryRequest {
  regionId: string(name='RegionId', position='Host'),
  categoryId: long(name='CategoryId', minimum=1, position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model GetMetaTableListByCategoryResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    tableGuidList?: [ string ](name='TableGuidList'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaTableListByCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableListByCategoryResponseBody(name='body'),
}

async function getMetaTableListByCategory(request: GetMetaTableListByCategoryRequest): GetMetaTableListByCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetaTableListByCategory', 'GET', '/', 'json', false, 'json', request);
}

model GetMetaTableOutputRequest {
  regionId: string(name='RegionId', position='Host'),
  endDate: string(name='EndDate', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  startDate: string(name='StartDate', position='Query'),
  tableGuid: string(name='TableGuid', position='Query'),
}

model GetMetaTableOutputResponseBody = {
  data?: {
    dataEntityList?: [ 
      {
        endTime?: string(name='EndTime'),
        projectId?: long(name='ProjectId'),
        startTime?: string(name='StartTime'),
        tableGuid?: string(name='TableGuid'),
        taskId?: string(name='TaskId'),
        taskInstanceId?: long(name='TaskInstanceId'),
        waitTime?: string(name='WaitTime'),
      }
    ](name='DataEntityList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaTableOutputResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableOutputResponseBody(name='body'),
}

async function getMetaTableOutput(request: GetMetaTableOutputRequest): GetMetaTableOutputResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetaTableOutput', 'POST', '/', 'json', false, 'json', request);
}

model GetMetaTablePartitionRequest {
  regionId: string(name='RegionId', position='Host'),
  clusterId?: string(name='ClusterId', position='Query'),
  dataSourceType?: string(name='DataSourceType', position='Query'),
  databaseName?: string(name='DatabaseName', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  sortCriterion?: {
    order?: string(name='Order'),
    sortField?: string(name='SortField'),
  }(name='SortCriterion', shrink='json', position='Query'),
  tableGuid?: string(name='TableGuid', position='Query'),
  tableName?: string(name='TableName', position='Query'),
}

model GetMetaTablePartitionResponseBody = {
  data?: {
    dataEntityList?: [ 
      {
        comment?: string(name='Comment'),
        createTime?: long(name='CreateTime'),
        dataSize?: long(name='DataSize'),
        modifiedTime?: long(name='ModifiedTime'),
        partitionGuid?: string(name='PartitionGuid'),
        partitionLocation?: string(name='PartitionLocation'),
        partitionName?: string(name='PartitionName'),
        partitionPath?: string(name='PartitionPath'),
        partitionType?: string(name='PartitionType'),
        recordCount?: long(name='RecordCount'),
        tableGuid?: string(name='TableGuid'),
      }
    ](name='DataEntityList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaTablePartitionResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTablePartitionResponseBody(name='body'),
}

async function getMetaTablePartition(request: GetMetaTablePartitionRequest): GetMetaTablePartitionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetaTablePartition', 'POST', '/', 'json', false, 'json', request);
}

model GetMetaTableThemeLevelRequest {
  regionId: string(name='RegionId', position='Host'),
  dataSourceType: string(name='DataSourceType', position='Query'),
  tableGuid: string(name='TableGuid', position='Query'),
}

model GetMetaTableThemeLevelResponseBody = {
  entity?: {
    level?: [ 
      {
        description?: string(name='Description'),
        levelId?: long(name='LevelId'),
        name?: string(name='Name'),
        type?: int32(name='Type'),
      }
    ](name='Level'),
    theme?: [ 
      {
        level?: int32(name='Level'),
        name?: string(name='Name'),
        parentId?: long(name='ParentId'),
        themeId?: long(name='ThemeId'),
      }
    ](name='Theme'),
  }(name='Entity'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaTableThemeLevelResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableThemeLevelResponseBody(name='body'),
}

async function getMetaTableThemeLevel(request: GetMetaTableThemeLevelRequest): GetMetaTableThemeLevelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetaTableThemeLevel', 'GET', '/', 'json', false, 'json', request);
}

model GetMigrationProcessRequest {
  regionId: string(name='RegionId', position='Host'),
  migrationId: long(name='MigrationId', minimum=1, position='Body'),
  projectId: long(name='ProjectId', minimum=2, position='Body'),
}

model GetMigrationProcessResponseBody = {
  data?: [ 
    {
      taskName?: string(name='TaskName'),
      taskStatus?: string(name='TaskStatus'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMigrationProcessResponse = {
  headers: map[string]string(name='headers'),
  body: GetMigrationProcessResponseBody(name='body'),
}

async function getMigrationProcess(request: GetMigrationProcessRequest): GetMigrationProcessResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMigrationProcess', 'POST', '/', 'json', true, 'form', request);
}

model GetMigrationSummaryRequest {
  regionId: string(name='RegionId', position='Host'),
  migrationId: long(name='MigrationId', minimum=1, position='Body'),
  projectId: long(name='ProjectId', minimum=2, position='Body'),
}

model GetMigrationSummaryResponseBody = {
  data?: {
    createUser?: string(name='CreateUser'),
    downloadUrl?: string(name='DownloadUrl'),
    gmtCreate?: long(name='GmtCreate'),
    gmtModified?: long(name='GmtModified'),
    migrationId?: long(name='MigrationId'),
    name?: string(name='Name'),
    opUser?: string(name='OpUser'),
    projectId?: long(name='ProjectId'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMigrationSummaryResponse = {
  headers: map[string]string(name='headers'),
  body: GetMigrationSummaryResponseBody(name='body'),
}

async function getMigrationSummary(request: GetMigrationSummaryRequest): GetMigrationSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMigrationSummary', 'POST', '/', 'json', true, 'form', request);
}

model GetNodeRequest {
  regionId: string(name='RegionId', position='Host'),
  nodeId: long(name='NodeId', minimum=2, position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model GetNodeResponseBody = {
  data?: {
    baselineId?: long(name='BaselineId'),
    businessId?: long(name='BusinessId'),
    connection?: string(name='Connection'),
    cronExpress?: string(name='CronExpress'),
    description?: string(name='Description'),
    dqcDescription?: string(name='DqcDescription'),
    dqcType?: int32(name='DqcType'),
    nodeId?: long(name='NodeId'),
    nodeName?: string(name='NodeName'),
    ownerId?: string(name='OwnerId'),
    paramValues?: string(name='ParamValues'),
    priority?: int32(name='Priority'),
    programType?: string(name='ProgramType'),
    projectId?: long(name='ProjectId'),
    relatedFlowId?: long(name='RelatedFlowId'),
    repeatInterval?: long(name='RepeatInterval'),
    repeatability?: string(name='Repeatability'),
    resGroupName?: string(name='ResGroupName'),
    schedulerType?: string(name='SchedulerType'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetNodeResponse = {
  headers: map[string]string(name='headers'),
  body: GetNodeResponseBody(name='body'),
}

async function getNode(request: GetNodeRequest): GetNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetNode', 'POST', '/', 'json', true, 'form', request);
}

model GetNodeChildrenRequest {
  regionId: string(name='RegionId', position='Host'),
  nodeId: long(name='NodeId', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model GetNodeChildrenResponseBody = {
  data?: {
    nodes?: [ 
      {
        baselineId?: long(name='BaselineId'),
        cronExpress?: string(name='CronExpress'),
        nodeId?: long(name='NodeId'),
        nodeName?: string(name='NodeName'),
        ownerId?: string(name='OwnerId'),
        priority?: int32(name='Priority'),
        programType?: string(name='ProgramType'),
        projectId?: long(name='ProjectId'),
        repeatability?: boolean(name='Repeatability'),
        schedulerType?: string(name='SchedulerType'),
      }
    ](name='Nodes'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetNodeChildrenResponse = {
  headers: map[string]string(name='headers'),
  body: GetNodeChildrenResponseBody(name='body'),
}

async function getNodeChildren(request: GetNodeChildrenRequest): GetNodeChildrenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetNodeChildren', 'POST', '/', 'json', true, 'form', request);
}

model GetNodeCodeRequest {
  regionId: string(name='RegionId', position='Host'),
  nodeId: long(name='NodeId', minimum=2, position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model GetNodeCodeResponseBody = {
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetNodeCodeResponse = {
  headers: map[string]string(name='headers'),
  body: GetNodeCodeResponseBody(name='body'),
}

async function getNodeCode(request: GetNodeCodeRequest): GetNodeCodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetNodeCode', 'POST', '/', 'json', true, 'form', request);
}

model GetNodeOnBaselineRequest {
  regionId: string(name='RegionId', position='Host'),
  baselineId: long(name='BaselineId', position='Body'),
}

model GetNodeOnBaselineResponseBody = {
  data?: [ 
    {
      nodeId?: long(name='NodeId'),
      nodeName?: string(name='NodeName'),
      owner?: string(name='Owner'),
      projectId?: long(name='ProjectId'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetNodeOnBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: GetNodeOnBaselineResponseBody(name='body'),
}

async function getNodeOnBaseline(request: GetNodeOnBaselineRequest): GetNodeOnBaselineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetNodeOnBaseline', 'POST', '/', 'json', true, 'form', request);
}

model GetNodeParentsRequest {
  regionId: string(name='RegionId', position='Host'),
  nodeId: long(name='NodeId', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model GetNodeParentsResponseBody = {
  data?: {
    nodes?: [ 
      {
        baselineId?: long(name='BaselineId'),
        cronExpress?: string(name='CronExpress'),
        nodeId?: long(name='NodeId'),
        nodeName?: string(name='NodeName'),
        ownerId?: string(name='OwnerId'),
        priority?: int32(name='Priority'),
        programType?: string(name='ProgramType'),
        projectId?: long(name='ProjectId'),
        repeatability?: boolean(name='Repeatability'),
        schedulerType?: string(name='SchedulerType'),
      }
    ](name='Nodes'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetNodeParentsResponse = {
  headers: map[string]string(name='headers'),
  body: GetNodeParentsResponseBody(name='body'),
}

async function getNodeParents(request: GetNodeParentsRequest): GetNodeParentsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetNodeParents', 'POST', '/', 'json', true, 'form', request);
}

model GetNodeTypeListInfoRequest {
  regionId: string(name='RegionId', position='Host'),
  keyword?: string(name='Keyword', position='Body'),
  locale?: string(name='Locale', position='Body'),
  pageNumber: int32(name='PageNumber', minimum=1, maximum=100, position='Body'),
  pageSize: int32(name='PageSize', minimum=0, maximum=100, position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
}

model GetNodeTypeListInfoResponseBody = {
  nodeTypeInfoList?: {
    nodeTypeInfo?: [ 
      {
        nodeType?: int32(name='NodeType'),
        nodeTypeName?: string(name='NodeTypeName'),
      }
    ](name='NodeTypeInfo'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='NodeTypeInfoList'),
  requestId?: string(name='RequestId'),
}

model GetNodeTypeListInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetNodeTypeListInfoResponseBody(name='body'),
}

async function getNodeTypeListInfo(request: GetNodeTypeListInfoRequest): GetNodeTypeListInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetNodeTypeListInfo', 'POST', '/', 'json', true, 'form', request);
}

model GetOpRiskDataRequest {
  regionId: string(name='RegionId', position='Host'),
  date: string(name='Date', position='Query'),
  name?: string(name='Name', position='Query'),
  pageNo: int32(name='PageNo', minimum=1, maximum=1000, position='Query'),
  pageSize: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  riskType?: string(name='RiskType', position='Query'),
}

model GetOpRiskDataResponseBody = {
  requestId?: string(name='RequestId'),
  riskData?: string(name='RiskData'),
}

model GetOpRiskDataResponse = {
  headers: map[string]string(name='headers'),
  body: GetOpRiskDataResponseBody(name='body'),
}

async function getOpRiskData(request: GetOpRiskDataRequest): GetOpRiskDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetOpRiskData', 'GET', '/', 'json', false, 'json', request);
}

model GetOpSensitiveDataRequest {
  regionId: string(name='RegionId', position='Host'),
  date: string(name='Date', position='Query'),
  name: string(name='Name', position='Query'),
  opType?: string(name='OpType', position='Query'),
  pageNo: int32(name='PageNo', minimum=1, maximum=1000, position='Query'),
  pageSize: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
}

model GetOpSensitiveDataResponseBody = {
  opSensitiveData?: string(name='OpSensitiveData'),
  requestId?: string(name='RequestId'),
}

model GetOpSensitiveDataResponse = {
  headers: map[string]string(name='headers'),
  body: GetOpSensitiveDataResponseBody(name='body'),
}

async function getOpSensitiveData(request: GetOpSensitiveDataRequest): GetOpSensitiveDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetOpSensitiveData', 'GET', '/', 'json', false, 'json', request);
}

model GetOptionValueForProjectRequest {
  regionId?: string(name='RegionId', position='Host'),
  extensionCode?: string(name='ExtensionCode', position='Body'),
  projectId?: string(name='ProjectId', position='Body'),
}

model GetOptionValueForProjectResponseBody = {
  optionValue?: string(name='OptionValue'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetOptionValueForProjectResponse = {
  headers: map[string]string(name='headers'),
  body: GetOptionValueForProjectResponseBody(name='body'),
}

async function getOptionValueForProject(request: GetOptionValueForProjectRequest): GetOptionValueForProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetOptionValueForProject', 'POST', '/', 'json', true, 'form', request);
}

model GetPermissionApplyOrderDetailRequest {
  regionId: string(name='RegionId', position='Host'),
  flowId: string(name='FlowId', position='Query'),
}

model GetPermissionApplyOrderDetailResponseBody = {
  applyOrderDetail?: {
    applyBaseId?: string(name='ApplyBaseId'),
    applyTimestamp?: long(name='ApplyTimestamp'),
    approveAccountList?: [ 
      {
        baseId?: string(name='BaseId'),
      }
    ](name='ApproveAccountList'),
    approveContent?: {
      applyReason?: string(name='ApplyReason'),
      deadline?: long(name='Deadline'),
      orderType?: int32(name='OrderType'),
      projectMeta?: {
        maxComputeProjectName?: string(name='MaxComputeProjectName'),
        objectMetaList?: [ 
          {
            columnMetaList?: [ 
              {
                columnComment?: string(name='ColumnComment'),
                columnName?: string(name='ColumnName'),
              }
            ](name='ColumnMetaList'),
            objectName?: string(name='ObjectName'),
          }
        ](name='ObjectMetaList'),
        workspaceId?: int32(name='WorkspaceId'),
      }(name='ProjectMeta'),
    }(name='ApproveContent'),
    flowId?: string(name='FlowId'),
    flowStatus?: int32(name='FlowStatus'),
    granteeObjectList?: [ 
      {
        granteeId?: string(name='GranteeId'),
        granteeName?: string(name='GranteeName'),
        granteeType?: int32(name='GranteeType'),
        granteeTypeSub?: int32(name='GranteeTypeSub'),
      }
    ](name='GranteeObjectList'),
  }(name='ApplyOrderDetail'),
  requestId?: string(name='RequestId'),
}

model GetPermissionApplyOrderDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetPermissionApplyOrderDetailResponseBody(name='body'),
}

async function getPermissionApplyOrderDetail(request: GetPermissionApplyOrderDetailRequest): GetPermissionApplyOrderDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPermissionApplyOrderDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetProjectRequest {
  regionId: string(name='RegionId', position='Host'),
  projectId: long(name='ProjectId', position='Query'),
}

model GetProjectResponseBody = {
  data?: {
    appkey?: string(name='Appkey'),
    baseProject?: boolean(name='BaseProject'),
    defaultDiResourceGroupIdentifier?: string(name='DefaultDiResourceGroupIdentifier'),
    destination?: int32(name='Destination'),
    devStorageQuota?: string(name='DevStorageQuota'),
    developmentType?: int32(name='DevelopmentType'),
    disableDevelopment?: boolean(name='DisableDevelopment'),
    envTypes?: [ string ](name='EnvTypes'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    isAllowDownload?: int32(name='IsAllowDownload'),
    isDefault?: int32(name='IsDefault'),
    maxFlowNode?: int32(name='MaxFlowNode'),
    prodStorageQuota?: string(name='ProdStorageQuota'),
    projectDescription?: string(name='ProjectDescription'),
    projectId?: int32(name='ProjectId'),
    projectIdentifier?: string(name='ProjectIdentifier'),
    projectMode?: int32(name='ProjectMode'),
    projectName?: string(name='ProjectName'),
    projectOwnerBaseId?: string(name='ProjectOwnerBaseId'),
    protectedMode?: int32(name='ProtectedMode'),
    residentArea?: string(name='ResidentArea'),
    resourceManagerResourceGroupId?: string(name='ResourceManagerResourceGroupId'),
    schedulerMaxRetryTimes?: int32(name='SchedulerMaxRetryTimes'),
    schedulerRetryInterval?: int32(name='SchedulerRetryInterval'),
    status?: int32(name='Status'),
    tablePrivacyMode?: int32(name='TablePrivacyMode'),
    tags?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='Tags'),
    tenantId?: long(name='TenantId'),
    useProxyOdpsAccount?: boolean(name='UseProxyOdpsAccount'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetProjectResponse = {
  headers: map[string]string(name='headers'),
  body: GetProjectResponseBody(name='body'),
}

async function getProject(request: GetProjectRequest): GetProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetProject', 'POST', '/', 'json', false, 'json', request);
}

model GetProjectDetailRequest {
  regionId: string(name='RegionId', position='Host'),
  projectId: long(name='ProjectId', position='Query'),
}

model GetProjectDetailResponseBody = {
  data?: {
    defaultDiResourceGroupIdentifier?: string(name='DefaultDiResourceGroupIdentifier'),
    developmentType?: int32(name='DevelopmentType'),
    disableDevelopment?: boolean(name='DisableDevelopment'),
    envTypes?: [ string ](name='EnvTypes'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    isAllowDownload?: int32(name='IsAllowDownload'),
    isDefault?: int32(name='IsDefault'),
    projectDescription?: string(name='ProjectDescription'),
    projectId?: int32(name='ProjectId'),
    projectIdentifier?: string(name='ProjectIdentifier'),
    projectMode?: int32(name='ProjectMode'),
    projectName?: string(name='ProjectName'),
    projectOwnerBaseId?: string(name='ProjectOwnerBaseId'),
    protectedMode?: int32(name='ProtectedMode'),
    residentArea?: string(name='ResidentArea'),
    resourceManagerResourceGroupId?: string(name='ResourceManagerResourceGroupId'),
    schedulerMaxRetryTimes?: int32(name='SchedulerMaxRetryTimes'),
    schedulerRetryInterval?: int32(name='SchedulerRetryInterval'),
    status?: int32(name='Status'),
    tablePrivacyMode?: int32(name='TablePrivacyMode'),
    tags?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='Tags'),
    tenantId?: long(name='TenantId'),
    useProxyOdpsAccount?: boolean(name='UseProxyOdpsAccount'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetProjectDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetProjectDetailResponseBody(name='body'),
}

async function getProjectDetail(request: GetProjectDetailRequest): GetProjectDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetProjectDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetQualityEntityRequest {
  regionId?: string(name='RegionId', position='Host'),
  envType: string(name='EnvType', minLength=1, maxLength=64, position='Body'),
  matchExpression?: string(name='MatchExpression', minLength=1, maxLength=128, position='Body'),
  projectName: string(name='ProjectName', minLength=1, maxLength=1024, position='Body'),
  tableName: string(name='TableName', minLength=1, maxLength=128, position='Body'),
}

model GetQualityEntityResponseBody = {
  data?: [ 
    {
      createTime?: long(name='CreateTime'),
      entityLevel?: int32(name='EntityLevel'),
      envType?: string(name='EnvType'),
      followers?: string(name='Followers'),
      hasRelativeNode?: boolean(name='HasRelativeNode'),
      id?: long(name='Id'),
      matchExpression?: string(name='MatchExpression'),
      modifyTime?: long(name='ModifyTime'),
      modifyUser?: string(name='ModifyUser'),
      onDuty?: string(name='OnDuty'),
      onDutyAccountName?: string(name='OnDutyAccountName'),
      projectName?: string(name='ProjectName'),
      relativeNode?: string(name='RelativeNode'),
      sql?: int32(name='Sql'),
      tableName?: string(name='TableName'),
      task?: int32(name='Task'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetQualityEntityResponse = {
  headers: map[string]string(name='headers'),
  body: GetQualityEntityResponseBody(name='body'),
}

async function getQualityEntity(request: GetQualityEntityRequest): GetQualityEntityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQualityEntity', 'POST', '/', 'json', true, 'form', request);
}

model GetQualityFollowerRequest {
  regionId: string(name='RegionId', position='Host'),
  entityId: long(name='EntityId', position='Body'),
  projectName: string(name='ProjectName', position='Body'),
}

model GetQualityFollowerResponseBody = {
  data?: [ 
    {
      alarmMode?: int32(name='AlarmMode'),
      entityId?: string(name='EntityId'),
      follower?: string(name='Follower'),
      followerAccountName?: string(name='FollowerAccountName'),
      id?: long(name='Id'),
      projectName?: string(name='ProjectName'),
      tableName?: string(name='TableName'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetQualityFollowerResponse = {
  headers: map[string]string(name='headers'),
  body: GetQualityFollowerResponseBody(name='body'),
}

async function getQualityFollower(request: GetQualityFollowerRequest): GetQualityFollowerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQualityFollower', 'POST', '/', 'json', true, 'form', request);
}

model GetQualityRuleRequest {
  regionId: string(name='RegionId', position='Host'),
  projectName: string(name='ProjectName', position='Body'),
  ruleId: long(name='RuleId', minimum=1, maximum=2147483647, position='Body'),
}

model GetQualityRuleResponseBody = {
  data?: {
    blockType?: int32(name='BlockType'),
    checker?: int32(name='Checker'),
    checkerName?: string(name='CheckerName'),
    comment?: string(name='Comment'),
    criticalThreshold?: string(name='CriticalThreshold'),
    entityId?: long(name='EntityId'),
    expectValue?: string(name='ExpectValue'),
    fixCheck?: boolean(name='FixCheck'),
    id?: long(name='Id'),
    methodId?: int32(name='MethodId'),
    methodName?: string(name='MethodName'),
    onDuty?: string(name='OnDuty'),
    onDutyAccountName?: string(name='OnDutyAccountName'),
    operator?: string(name='Operator'),
    predictType?: int32(name='PredictType'),
    property?: string(name='Property'),
    ruleName?: string(name='RuleName'),
    ruleType?: int32(name='RuleType'),
    templateId?: int32(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    trend?: string(name='Trend'),
    warningThreshold?: string(name='WarningThreshold'),
    whereCondition?: string(name='WhereCondition'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetQualityRuleResponse = {
  headers: map[string]string(name='headers'),
  body: GetQualityRuleResponseBody(name='body'),
}

async function getQualityRule(request: GetQualityRuleRequest): GetQualityRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQualityRule', 'POST', '/', 'json', true, 'form', request);
}

model GetRemindRequest {
  regionId: string(name='RegionId', position='Host'),
  remindId: long(name='RemindId', position='Body'),
}

model GetRemindResponseBody = {
  data?: {
    alertInterval?: int32(name='AlertInterval'),
    alertMethods?: [ string ](name='AlertMethods'),
    alertTargets?: [ string ](name='AlertTargets'),
    alertUnit?: string(name='AlertUnit'),
    baselines?: [ 
      {
        baselineId?: long(name='BaselineId'),
        baselineName?: string(name='BaselineName'),
      }
    ](name='Baselines'),
    bizProcesses?: [ 
      {
        bizId?: long(name='BizId'),
        bizProcessName?: string(name='BizProcessName'),
      }
    ](name='BizProcesses'),
    detail?: string(name='Detail'),
    dndEnd?: string(name='DndEnd'),
    dndStart?: string(name='DndStart'),
    founder?: string(name='Founder'),
    maxAlertTimes?: int32(name='MaxAlertTimes'),
    nodes?: [ 
      {
        nodeId?: long(name='NodeId'),
        nodeName?: string(name='NodeName'),
        owner?: string(name='Owner'),
        projectId?: long(name='ProjectId'),
      }
    ](name='Nodes'),
    projects?: [ 
      {
        projectId?: long(name='ProjectId'),
      }
    ](name='Projects'),
    remindId?: long(name='RemindId'),
    remindName?: string(name='RemindName'),
    remindType?: string(name='RemindType'),
    remindUnit?: string(name='RemindUnit'),
    robots?: [ 
      {
        atAll?: boolean(name='AtAll'),
        webUrl?: string(name='WebUrl'),
      }
    ](name='Robots'),
    useflag?: boolean(name='Useflag'),
    webhooks?: [ string ](name='Webhooks'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetRemindResponse = {
  headers: map[string]string(name='headers'),
  body: GetRemindResponseBody(name='body'),
}

async function getRemind(request: GetRemindRequest): GetRemindResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetRemind', 'POST', '/', 'json', true, 'form', request);
}

model GetSensitiveDataRequest {
  regionId: string(name='RegionId', position='Host'),
  name: string(name='Name', position='Query'),
  pageNo: int32(name='PageNo', minimum=1, maximum=1000, position='Query'),
  pageSize: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
}

model GetSensitiveDataResponseBody = {
  requestId?: string(name='RequestId'),
  sensitiveData?: map[string]any(name='SensitiveData'),
}

model GetSensitiveDataResponse = {
  headers: map[string]string(name='headers'),
  body: GetSensitiveDataResponseBody(name='body'),
}

async function getSensitiveData(request: GetSensitiveDataRequest): GetSensitiveDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSensitiveData', 'GET', '/', 'json', false, 'json', request);
}

model GetSuccessInstanceTrendRequest {
  regionId: string(name='RegionId', position='Host'),
  projectId: long(name='ProjectId', minimum=2, maximum=99999999999, position='Body'),
}

model GetSuccessInstanceTrendResponseBody = {
  instanceStatusTrend?: {
    avgTrend?: [ 
      {
        count?: int32(name='Count'),
        timePoint?: string(name='TimePoint'),
      }
    ](name='AvgTrend'),
    todayTrend?: [ 
      {
        count?: int32(name='Count'),
        timePoint?: string(name='TimePoint'),
      }
    ](name='TodayTrend'),
    yesterdayTrend?: [ 
      {
        count?: int32(name='Count'),
        timePoint?: string(name='TimePoint'),
      }
    ](name='YesterdayTrend'),
  }(name='InstanceStatusTrend'),
  requestId?: string(name='RequestId'),
}

model GetSuccessInstanceTrendResponse = {
  headers: map[string]string(name='headers'),
  body: GetSuccessInstanceTrendResponseBody(name='body'),
}

async function getSuccessInstanceTrend(request: GetSuccessInstanceTrendRequest): GetSuccessInstanceTrendResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSuccessInstanceTrend', 'POST', '/', 'json', true, 'form', request);
}

model GetTopicRequest {
  regionId: string(name='RegionId', position='Host'),
  topicId: long(name='TopicId', position='Body'),
}

model GetTopicResponseBody = {
  data?: {
    addTime?: long(name='AddTime'),
    alertTime?: long(name='AlertTime'),
    assigner?: string(name='Assigner'),
    baselineBuffer?: long(name='BaselineBuffer'),
    baselineId?: long(name='BaselineId'),
    baselineInGroupId?: int32(name='BaselineInGroupId'),
    baselineName?: string(name='BaselineName'),
    baselineStatus?: string(name='BaselineStatus'),
    buffer?: long(name='Buffer'),
    dealTime?: long(name='DealTime'),
    dealUser?: string(name='DealUser'),
    fixTime?: long(name='FixTime'),
    happenTime?: long(name='HappenTime'),
    instanceId?: long(name='InstanceId'),
    nextAlertTime?: long(name='NextAlertTime'),
    nodeId?: long(name='NodeId'),
    nodeName?: string(name='NodeName'),
    owner?: string(name='Owner'),
    projectId?: long(name='ProjectId'),
    topicId?: long(name='TopicId'),
    topicName?: string(name='TopicName'),
    topicStatus?: string(name='TopicStatus'),
    topicType?: string(name='TopicType'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTopicResponse = {
  headers: map[string]string(name='headers'),
  body: GetTopicResponseBody(name='body'),
}

async function getTopic(request: GetTopicRequest): GetTopicResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTopic', 'POST', '/', 'json', true, 'form', request);
}

model GetTopicInfluenceRequest {
  regionId: string(name='RegionId', position='Host'),
  topicId: long(name='TopicId', position='Body'),
}

model GetTopicInfluenceResponseBody = {
  data?: {
    influences?: [ 
      {
        baselineId?: long(name='BaselineId'),
        baselineName?: string(name='BaselineName'),
        bizdate?: long(name='Bizdate'),
        buffer?: long(name='Buffer'),
        inGroupId?: int32(name='InGroupId'),
        owner?: string(name='Owner'),
        priority?: int32(name='Priority'),
        projectId?: long(name='ProjectId'),
        status?: string(name='Status'),
      }
    ](name='Influences'),
    topicId?: long(name='TopicId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTopicInfluenceResponse = {
  headers: map[string]string(name='headers'),
  body: GetTopicInfluenceResponseBody(name='body'),
}

async function getTopicInfluence(request: GetTopicInfluenceRequest): GetTopicInfluenceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTopicInfluence', 'POST', '/', 'json', true, 'form', request);
}

model ImportDataSourcesRequest {
  regionId: string(name='RegionId', position='Host'),
  dataSources: string(name='DataSources', position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
}

model ImportDataSourcesResponseBody = {
  data?: {
    message?: string(name='Message'),
    status?: boolean(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ImportDataSourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ImportDataSourcesResponseBody(name='body'),
}

async function importDataSources(request: ImportDataSourcesRequest): ImportDataSourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportDataSources', 'POST', '/', 'json', false, 'json', request);
}

model ListAlertMessagesRequest {
  regionId: string(name='RegionId', position='Host'),
  alertMethods?: string(name='AlertMethods', position='Body'),
  alertRuleTypes?: string(name='AlertRuleTypes', position='Body'),
  alertUser?: string(name='AlertUser', position='Body'),
  baselineId?: long(name='BaselineId', description='基线ID，当 alertRuleTypes 包含 GLOBAL 时生效，与 RemindId 互斥', position='Body'),
  beginTime: string(name='BeginTime', position='Body'),
  endTime: string(name='EndTime', position='Body'),
  pageNumber: int32(name='PageNumber', position='Body'),
  pageSize: int32(name='PageSize', position='Body'),
  remindId?: long(name='RemindId', position='Body'),
}

model ListAlertMessagesResponseBody = {
  data?: {
    alertMessages?: [ 
      {
        alertId?: long(name='AlertId'),
        alertMessageStatus?: string(name='AlertMessageStatus'),
        alertMethod?: string(name='AlertMethod'),
        alertTime?: long(name='AlertTime'),
        alertUser?: string(name='AlertUser'),
        content?: string(name='Content'),
        instances?: [ 
          {
            instanceId?: long(name='InstanceId'),
            nodeId?: long(name='NodeId'),
            nodeName?: string(name='NodeName'),
            projectId?: long(name='ProjectId'),
            status?: string(name='Status'),
          }
        ](name='Instances'),
        nodes?: [ 
          {
            nodeId?: long(name='NodeId'),
            nodeName?: string(name='NodeName'),
            owner?: string(name='Owner'),
            projectId?: long(name='ProjectId'),
          }
        ](name='Nodes'),
        remindId?: long(name='RemindId'),
        remindName?: string(name='RemindName'),
        slaAlert?: {
          baselineId?: long(name='BaselineId'),
          baselineName?: string(name='BaselineName'),
          baselineOwner?: string(name='BaselineOwner'),
          bizdate?: long(name='Bizdate'),
          inGroupId?: int32(name='InGroupId'),
          projectId?: long(name='ProjectId'),
          status?: string(name='Status'),
        }(name='SlaAlert'),
        source?: string(name='Source'),
        topics?: [ 
          {
            instanceId?: long(name='InstanceId'),
            nodeId?: long(name='NodeId'),
            topicId?: long(name='TopicId'),
            topicName?: string(name='TopicName'),
            topicOwner?: string(name='TopicOwner'),
            topicStatus?: string(name='TopicStatus'),
          }
        ](name='Topics'),
      }
    ](name='AlertMessages'),
    pageNumber?: string(name='PageNumber'),
    pageSize?: string(name='PageSize'),
    totalCount?: string(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAlertMessagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlertMessagesResponseBody(name='body'),
}

async function listAlertMessages(request: ListAlertMessagesRequest): ListAlertMessagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAlertMessages', 'POST', '/', 'json', true, 'form', request);
}

model ListBaselineConfigsRequest {
  regionId: string(name='RegionId', position='Host'),
  baselineTypes?: string(name='BaselineTypes', position='Body'),
  owner?: string(name='Owner', position='Body'),
  pageNumber: int32(name='PageNumber', position='Body'),
  pageSize: int32(name='PageSize', position='Body'),
  priority?: string(name='Priority', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
  searchText?: string(name='SearchText', position='Body'),
  useflag?: boolean(name='Useflag', position='Body'),
}

model ListBaselineConfigsResponseBody = {
  data?: {
    baselines?: [ 
      {
        baselineId?: long(name='BaselineId'),
        baselineName?: string(name='BaselineName'),
        baselineType?: string(name='BaselineType'),
        expHour?: int32(name='ExpHour'),
        expMinu?: int32(name='ExpMinu'),
        hourExpDetail?: string(name='HourExpDetail'),
        hourSlaDetail?: string(name='HourSlaDetail'),
        isDefault?: boolean(name='IsDefault'),
        owner?: string(name='Owner'),
        priority?: int32(name='Priority'),
        projectId?: long(name='ProjectId'),
        slaHour?: int32(name='SlaHour'),
        slaMinu?: int32(name='SlaMinu'),
        useFlag?: boolean(name='UseFlag'),
      }
    ](name='Baselines'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListBaselineConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListBaselineConfigsResponseBody(name='body'),
}

async function listBaselineConfigs(request: ListBaselineConfigsRequest): ListBaselineConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListBaselineConfigs', 'POST', '/', 'json', true, 'form', request);
}

model ListBaselineStatusesRequest {
  regionId: string(name='RegionId', position='Host'),
  baselineTypes?: string(name='BaselineTypes', position='Body'),
  bizdate: string(name='Bizdate', position='Body'),
  finishStatus?: string(name='FinishStatus', position='Body'),
  owner?: string(name='Owner', position='Body'),
  pageNumber: int32(name='PageNumber', position='Body'),
  pageSize: int32(name='PageSize', position='Body'),
  priority?: string(name='Priority', position='Body'),
  searchText?: string(name='SearchText', position='Body'),
  status?: string(name='Status', position='Body'),
  topicId?: long(name='TopicId', position='Body'),
}

model ListBaselineStatusesResponseBody = {
  data?: {
    baselineStatuses?: [ 
      {
        baselineId?: long(name='BaselineId'),
        baselineName?: string(name='BaselineName'),
        bizdate?: long(name='Bizdate'),
        buffer?: long(name='Buffer'),
        endCast?: long(name='EndCast'),
        expTime?: long(name='ExpTime'),
        finishStatus?: string(name='FinishStatus'),
        finishTime?: long(name='FinishTime'),
        inGroupId?: int32(name='InGroupId'),
        owner?: string(name='Owner'),
        priority?: int32(name='Priority'),
        projectId?: long(name='ProjectId'),
        slaTime?: long(name='SlaTime'),
        status?: string(name='Status'),
      }
    ](name='BaselineStatuses'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListBaselineStatusesResponse = {
  headers: map[string]string(name='headers'),
  body: ListBaselineStatusesResponseBody(name='body'),
}

async function listBaselineStatuses(request: ListBaselineStatusesRequest): ListBaselineStatusesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListBaselineStatuses', 'POST', '/', 'json', true, 'form', request);
}

model ListBaselinesRequest {
  regionId?: string(name='RegionId', position='Host'),
  baselineTypes?: string(name='BaselineTypes', description='基线类型', position='Body'),
  enable?: boolean(name='Enable', description='是否开启基线', position='Body'),
  owner?: string(name='Owner', description='责任人', position='Body'),
  pageNumber: int32(name='PageNumber', position='Body'),
  pageSize: int32(name='PageSize', position='Body'),
  priority?: string(name='Priority', position='Body'),
  projectEnv?: string(name='ProjectEnv', position='Body'),
  projectId: long(name='ProjectId', description='项目空间id', position='Body'),
  searchText?: string(name='SearchText', description='基线名模糊查询', position='Body'),
}

model ListBaselinesResponseBody = {
  data?: {
    baselines?: [ 
      {
        alertEnabled?: boolean(name='AlertEnabled'),
        alertMarginThreshold?: int32(name='AlertMarginThreshold'),
        baselineId?: long(name='BaselineId'),
        baselineName?: string(name='BaselineName'),
        baselineType?: string(name='BaselineType'),
        enabled?: boolean(name='Enabled'),
        overTimeSettings?: [ 
          {
            cycle?: int32(name='Cycle'),
            time?: string(name='Time'),
          }
        ](name='OverTimeSettings'),
        owner?: string(name='Owner'),
        priority?: int32(name='Priority'),
        projectId?: long(name='ProjectId'),
      }
    ](name='Baselines'),
    pageNumber?: string(name='PageNumber'),
    pageSize?: string(name='PageSize'),
    totalCount?: string(name='TotalCount'),
  }(name='Data'),
  dynamicErrorCode?: string(name='DynamicErrorCode'),
  dynamicErrorMessage?: string(name='DynamicErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListBaselinesResponse = {
  headers: map[string]string(name='headers'),
  body: ListBaselinesResponseBody(name='body'),
}

async function listBaselines(request: ListBaselinesRequest): ListBaselinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListBaselines', 'POST', '/', 'json', true, 'form', request);
}

model ListBusinessRequest {
  regionId: string(name='RegionId', position='Host'),
  keyword?: string(name='Keyword', position='Body'),
  pageNumber: int32(name='PageNumber', minimum=1, position='Body'),
  pageSize: int32(name='PageSize', minimum=0, maximum=100, position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
}

model ListBusinessResponseBody = {
  data?: {
    business?: [ 
      {
        businessId?: long(name='BusinessId'),
        businessName?: string(name='BusinessName'),
        description?: string(name='Description'),
        owner?: string(name='Owner'),
        projectId?: long(name='ProjectId'),
        useType?: string(name='UseType'),
      }
    ](name='Business'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListBusinessResponse = {
  headers: map[string]string(name='headers'),
  body: ListBusinessResponseBody(name='body'),
}

async function listBusiness(request: ListBusinessRequest): ListBusinessResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListBusiness', 'POST', '/', 'json', true, 'form', request);
}

model ListCalcEnginesRequest {
  regionId: string(name='RegionId', position='Host'),
  calcEngineType: string(name='CalcEngineType', position='Query'),
  envType?: string(name='EnvType', position='Query'),
  name?: string(name='Name', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  projectId: long(name='ProjectId', position='Query'),
}

model ListCalcEnginesResponseBody = {
  data?: {
    calcEngines?: [ 
      {
        bindingProjectId?: int32(name='BindingProjectId'),
        bindingProjectName?: string(name='BindingProjectName'),
        calcEngineType?: string(name='CalcEngineType'),
        dwRegion?: string(name='DwRegion'),
        engineId?: int32(name='EngineId'),
        engineInfo?: map[string]any(name='EngineInfo'),
        envType?: string(name='EnvType'),
        gmtCreate?: string(name='GmtCreate'),
        isDefault?: boolean(name='IsDefault'),
        name?: string(name='Name'),
        region?: string(name='Region'),
        taskAuthType?: string(name='TaskAuthType'),
        tenantId?: long(name='TenantId'),
      }
    ](name='CalcEngines'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListCalcEnginesResponse = {
  headers: map[string]string(name='headers'),
  body: ListCalcEnginesResponseBody(name='body'),
}

async function listCalcEngines(request: ListCalcEnginesRequest): ListCalcEnginesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCalcEngines', 'POST', '/', 'json', false, 'json', request);
}

model ListConnectionsRequest {
  regionId: string(name='RegionId', position='Host'),
  connectionType?: string(name='ConnectionType', position='Query'),
  envType?: int32(name='EnvType', position='Query'),
  name?: string(name='Name', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  projectId: long(name='ProjectId', position='Query'),
  status?: string(name='Status', position='Query'),
  subType?: string(name='SubType', position='Query'),
}

model ListConnectionsResponseBody = {
  data?: {
    connections?: [ 
      {
        bindingCalcEngineId?: int32(name='BindingCalcEngineId'),
        connectStatus?: int32(name='ConnectStatus'),
        connectionType?: string(name='ConnectionType'),
        content?: string(name='Content'),
        defaultEngine?: boolean(name='DefaultEngine'),
        description?: string(name='Description'),
        envType?: int32(name='EnvType'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: int32(name='Id'),
        name?: string(name='Name'),
        operator?: string(name='Operator'),
        projectId?: int32(name='ProjectId'),
        sequence?: int32(name='Sequence'),
        shared?: boolean(name='Shared'),
        status?: int32(name='Status'),
        subType?: string(name='SubType'),
        tenantId?: long(name='TenantId'),
      }
    ](name='Connections'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListConnectionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListConnectionsResponseBody(name='body'),
}

async function listConnections(request: ListConnectionsRequest): ListConnectionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListConnections', 'GET', '/', 'json', false, 'json', request);
}

model ListDIProjectConfigRequest {
  regionId: string(name='RegionId', position='Host'),
  destinationType: string(name='DestinationType', position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
}

model ListDIProjectConfigResponseBody = {
  data?: {
    config?: string(name='Config'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDIProjectConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ListDIProjectConfigResponseBody(name='body'),
}

async function listDIProjectConfig(request: ListDIProjectConfigRequest): ListDIProjectConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDIProjectConfig', 'POST', '/', 'json', false, 'json', request);
}

model ListDagsRequest {
  regionId: string(name='RegionId', position='Host'),
  opSeq: long(name='OpSeq', minimum=2, position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model ListDagsResponseBody = {
  data?: {
    dags?: [ 
      {
        bizdate?: long(name='Bizdate'),
        createTime?: long(name='CreateTime'),
        createUser?: string(name='CreateUser'),
        dagId?: long(name='DagId'),
        finishTime?: long(name='FinishTime'),
        gmtdate?: long(name='Gmtdate'),
        modifyTime?: long(name='ModifyTime'),
        name?: string(name='Name'),
        opSeq?: long(name='OpSeq'),
        projectId?: long(name='ProjectId'),
        startTime?: long(name='StartTime'),
        status?: string(name='Status'),
        type?: string(name='Type'),
      }
    ](name='Dags'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDagsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDagsResponseBody(name='body'),
}

async function listDags(request: ListDagsRequest): ListDagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDags', 'POST', '/', 'json', true, 'form', request);
}

model ListDataServiceApiAuthoritiesRequest {
  regionId: string(name='RegionId', position='Host'),
  apiNameKeyword?: string(name='ApiNameKeyword', position='Body'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  projectId: long(name='ProjectId', position='Body'),
  tenantId: long(name='TenantId', position='Body'),
}

model ListDataServiceApiAuthoritiesResponseBody = {
  data?: {
    apiAuthorizationList?: [ 
      {
        apiId?: long(name='ApiId'),
        apiName?: string(name='ApiName'),
        apiPath?: string(name='ApiPath'),
        apiStatus?: int32(name='ApiStatus'),
        authorizationRecords?: [ 
          {
            createdTime?: string(name='CreatedTime'),
            creatorId?: string(name='CreatorId'),
            endTime?: string(name='EndTime'),
            projectId?: long(name='ProjectId'),
          }
        ](name='AuthorizationRecords'),
        createdTime?: string(name='CreatedTime'),
        creatorId?: string(name='CreatorId'),
        groupId?: string(name='GroupId'),
        modifiedTime?: string(name='ModifiedTime'),
        projectId?: long(name='ProjectId'),
        tenantId?: long(name='TenantId'),
      }
    ](name='ApiAuthorizationList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDataServiceApiAuthoritiesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataServiceApiAuthoritiesResponseBody(name='body'),
}

async function listDataServiceApiAuthorities(request: ListDataServiceApiAuthoritiesRequest): ListDataServiceApiAuthoritiesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataServiceApiAuthorities', 'POST', '/', 'json', true, 'form', request);
}

model ListDataServiceApiTestRequest {
  regionId: string(name='RegionId', position='Host'),
  apiId: long(name='ApiId', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListDataServiceApiTestResponseBody = {
  data?: [ 
    {
      apiId?: long(name='ApiId'),
      costTime?: int32(name='CostTime'),
      createTime?: long(name='CreateTime'),
      paramMap?: string(name='ParamMap'),
      retCode?: long(name='RetCode'),
      retResult?: string(name='RetResult'),
      status?: string(name='Status'),
      testId?: long(name='TestId'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model ListDataServiceApiTestResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataServiceApiTestResponseBody(name='body'),
}

async function listDataServiceApiTest(request: ListDataServiceApiTestRequest): ListDataServiceApiTestResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataServiceApiTest', 'GET', '/', 'json', false, 'json', request);
}

model ListDataServiceApisRequest {
  regionId: string(name='RegionId', position='Host'),
  apiNameKeyword?: string(name='ApiNameKeyword', position='Body'),
  apiPathKeyword?: string(name='ApiPathKeyword', position='Body'),
  creatorId?: string(name='CreatorId', position='Body'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Body'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Body'),
  projectId: long(name='ProjectId', position='Body'),
  tenantId: long(name='TenantId', position='Body'),
}

model ListDataServiceApisResponseBody = {
  data?: {
    apis?: [ 
      {
        apiId?: long(name='ApiId'),
        apiMode?: int32(name='ApiMode'),
        apiName?: string(name='ApiName'),
        apiPath?: string(name='ApiPath'),
        createdTime?: string(name='CreatedTime'),
        creatorId?: string(name='CreatorId'),
        description?: string(name='Description'),
        folderId?: long(name='FolderId'),
        groupId?: string(name='GroupId'),
        modifiedTime?: string(name='ModifiedTime'),
        operatorId?: string(name='OperatorId'),
        projectId?: long(name='ProjectId'),
        protocols?: [ int32 ](name='Protocols'),
        registrationDetails?: {
          failedResultSample?: string(name='FailedResultSample'),
          registrationErrorCodes?: [ 
            {
              errorCode?: string(name='ErrorCode'),
              errorMessage?: string(name='ErrorMessage'),
              errorSolution?: string(name='ErrorSolution'),
            }
          ](name='RegistrationErrorCodes'),
          registrationRequestParameters?: [ 
            {
              columnName?: string(name='ColumnName'),
              defaultValue?: string(name='DefaultValue'),
              exampleValue?: string(name='ExampleValue'),
              isRequiredParameter?: boolean(name='IsRequiredParameter'),
              parameterDataType?: int32(name='ParameterDataType'),
              parameterDescription?: string(name='ParameterDescription'),
              parameterName?: string(name='ParameterName'),
              parameterOperator?: int32(name='ParameterOperator'),
              parameterPosition?: int32(name='ParameterPosition'),
            }
          ](name='RegistrationRequestParameters'),
          serviceContentType?: int32(name='ServiceContentType'),
          serviceHost?: string(name='ServiceHost'),
          servicePath?: string(name='ServicePath'),
          serviceRequestBodyDescription?: string(name='ServiceRequestBodyDescription'),
          successfulResultSample?: string(name='SuccessfulResultSample'),
        }(name='RegistrationDetails'),
        requestMethod?: int32(name='RequestMethod'),
        responseContentType?: int32(name='ResponseContentType'),
        scriptDetails?: {
          isPagedResponse?: boolean(name='IsPagedResponse'),
          script?: string(name='Script'),
          scriptConnection?: {
            connectionId?: long(name='ConnectionId'),
            tableName?: string(name='TableName'),
          }(name='ScriptConnection'),
          scriptRequestParameters?: [ 
            {
              columnName?: string(name='ColumnName'),
              defaultValue?: string(name='DefaultValue'),
              exampleValue?: string(name='ExampleValue'),
              isRequiredParameter?: boolean(name='IsRequiredParameter'),
              parameterDataType?: int32(name='ParameterDataType'),
              parameterDescription?: string(name='ParameterDescription'),
              parameterName?: string(name='ParameterName'),
              parameterOperator?: int32(name='ParameterOperator'),
              parameterPosition?: int32(name='ParameterPosition'),
            }
          ](name='ScriptRequestParameters'),
          scriptResponseParameters?: [ 
            {
              columnName?: string(name='ColumnName'),
              exampleValue?: string(name='ExampleValue'),
              parameterDataType?: int32(name='ParameterDataType'),
              parameterDescription?: string(name='ParameterDescription'),
              parameterName?: string(name='ParameterName'),
            }
          ](name='ScriptResponseParameters'),
        }(name='ScriptDetails'),
        status?: int32(name='Status'),
        tenantId?: long(name='TenantId'),
        timeout?: int32(name='Timeout'),
        visibleRange?: int32(name='VisibleRange'),
        wizardDetails?: {
          isPagedResponse?: boolean(name='IsPagedResponse'),
          wizardConnection?: {
            connectionId?: long(name='ConnectionId'),
            tableName?: string(name='TableName'),
          }(name='WizardConnection'),
          wizardRequestParameters?: [ 
            {
              columnName?: string(name='ColumnName'),
              defaultValue?: string(name='DefaultValue'),
              exampleValue?: string(name='ExampleValue'),
              isRequiredParameter?: boolean(name='IsRequiredParameter'),
              parameterDataType?: int32(name='ParameterDataType'),
              parameterDescription?: string(name='ParameterDescription'),
              parameterName?: string(name='ParameterName'),
              parameterOperator?: int32(name='ParameterOperator'),
              parameterPosition?: int32(name='ParameterPosition'),
            }
          ](name='WizardRequestParameters'),
          wizardResponseParameters?: [ 
            {
              columnName?: string(name='ColumnName'),
              exampleValue?: string(name='ExampleValue'),
              parameterDataType?: int32(name='ParameterDataType'),
              parameterDescription?: string(name='ParameterDescription'),
              parameterName?: string(name='ParameterName'),
            }
          ](name='WizardResponseParameters'),
        }(name='WizardDetails'),
      }
    ](name='Apis'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDataServiceApisResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataServiceApisResponseBody(name='body'),
}

async function listDataServiceApis(request: ListDataServiceApisRequest): ListDataServiceApisResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataServiceApis', 'POST', '/', 'json', true, 'form', request);
}

model ListDataServiceApplicationsRequest {
  regionId: string(name='RegionId', position='Host'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Body'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Body'),
  projectIdList: string(name='ProjectIdList', position='Body'),
  tenantId: long(name='TenantId', position='Body'),
}

model ListDataServiceApplicationsResponseBody = {
  data?: {
    applications?: [ 
      {
        applicationId?: long(name='ApplicationId'),
        applicationName?: string(name='ApplicationName'),
        projectId?: long(name='ProjectId'),
      }
    ](name='Applications'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDataServiceApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataServiceApplicationsResponseBody(name='body'),
}

async function listDataServiceApplications(request: ListDataServiceApplicationsRequest): ListDataServiceApplicationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataServiceApplications', 'POST', '/', 'json', true, 'form', request);
}

model ListDataServiceAuthorizedApisRequest {
  regionId: string(name='RegionId', position='Host'),
  apiNameKeyword?: string(name='ApiNameKeyword', position='Body'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  projectId: long(name='ProjectId', position='Body'),
  tenantId: long(name='TenantId', position='Body'),
}

model ListDataServiceAuthorizedApisResponseBody = {
  data?: {
    apiAuthorizedList?: [ 
      {
        apiId?: long(name='ApiId'),
        apiName?: string(name='ApiName'),
        apiPath?: string(name='ApiPath'),
        apiStatus?: int32(name='ApiStatus'),
        createdTime?: string(name='CreatedTime'),
        creatorId?: string(name='CreatorId'),
        grantCreatedTime?: string(name='GrantCreatedTime'),
        grantEndTime?: string(name='GrantEndTime'),
        grantOperatorId?: string(name='GrantOperatorId'),
        groupId?: string(name='GroupId'),
        modifiedTime?: string(name='ModifiedTime'),
        projectId?: long(name='ProjectId'),
        tenantId?: long(name='TenantId'),
      }
    ](name='ApiAuthorizedList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDataServiceAuthorizedApisResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataServiceAuthorizedApisResponseBody(name='body'),
}

async function listDataServiceAuthorizedApis(request: ListDataServiceAuthorizedApisRequest): ListDataServiceAuthorizedApisResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataServiceAuthorizedApis', 'POST', '/', 'json', true, 'form', request);
}

model ListDataServiceFoldersRequest {
  regionId: string(name='RegionId', position='Host'),
  folderNameKeyword?: string(name='FolderNameKeyword', position='Body'),
  groupId?: string(name='GroupId', position='Body'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Body'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Body'),
  projectId: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Body'),
  tenantId: long(name='TenantId', minimum=1, maximum=9223372036854775807, position='Body'),
}

model ListDataServiceFoldersResponseBody = {
  folderPagingResult?: {
    folders?: [ 
      {
        createdTime?: string(name='CreatedTime'),
        folderId?: long(name='FolderId'),
        folderName?: string(name='FolderName'),
        groupId?: string(name='GroupId'),
        modifiedTime?: string(name='ModifiedTime'),
        parentId?: long(name='ParentId'),
        projectId?: long(name='ProjectId'),
        tenantId?: long(name='TenantId'),
      }
    ](name='Folders'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='FolderPagingResult'),
  requestId?: string(name='RequestId'),
}

model ListDataServiceFoldersResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataServiceFoldersResponseBody(name='body'),
}

async function listDataServiceFolders(request: ListDataServiceFoldersRequest): ListDataServiceFoldersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataServiceFolders', 'POST', '/', 'json', true, 'form', request);
}

model ListDataServiceGroupsRequest {
  regionId: string(name='RegionId', position='Host'),
  groupNameKeyword?: string(name='GroupNameKeyword', position='Body'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Body'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Body'),
  projectId: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Body'),
  tenantId: long(name='TenantId', minimum=1, maximum=9223372036854775807, position='Body'),
}

model ListDataServiceGroupsResponseBody = {
  groupPagingResult?: {
    groups?: [ 
      {
        apiGatewayGroupId?: string(name='ApiGatewayGroupId'),
        createdTime?: string(name='CreatedTime'),
        creatorId?: string(name='CreatorId'),
        description?: string(name='Description'),
        groupId?: string(name='GroupId'),
        groupName?: string(name='GroupName'),
        modifiedTime?: string(name='ModifiedTime'),
        projectId?: long(name='ProjectId'),
        tenantId?: long(name='TenantId'),
      }
    ](name='Groups'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='GroupPagingResult'),
  requestId?: string(name='RequestId'),
}

model ListDataServiceGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataServiceGroupsResponseBody(name='body'),
}

async function listDataServiceGroups(request: ListDataServiceGroupsRequest): ListDataServiceGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataServiceGroups', 'POST', '/', 'json', true, 'form', request);
}

model ListDataServicePublishedApisRequest {
  regionId: string(name='RegionId', position='Host'),
  apiNameKeyword?: string(name='ApiNameKeyword', position='Body'),
  apiPathKeyword?: string(name='ApiPathKeyword', position='Body'),
  creatorId?: string(name='CreatorId', position='Body'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Body'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Body'),
  projectId: long(name='ProjectId', position='Body'),
  tenantId: long(name='TenantId', position='Body'),
}

model ListDataServicePublishedApisResponseBody = {
  data?: {
    apis?: [ 
      {
        apiId?: long(name='ApiId'),
        apiMode?: int32(name='ApiMode'),
        apiName?: string(name='ApiName'),
        apiPath?: string(name='ApiPath'),
        createdTime?: string(name='CreatedTime'),
        creatorId?: string(name='CreatorId'),
        description?: string(name='Description'),
        groupId?: string(name='GroupId'),
        modifiedTime?: string(name='ModifiedTime'),
        operatorId?: string(name='OperatorId'),
        projectId?: long(name='ProjectId'),
        protocols?: [ int32 ](name='Protocols'),
        registrationDetails?: {
          failedResultSample?: string(name='FailedResultSample'),
          registrationErrorCodes?: [ 
            {
              errorCode?: string(name='ErrorCode'),
              errorMessage?: string(name='ErrorMessage'),
              errorSolution?: string(name='ErrorSolution'),
            }
          ](name='RegistrationErrorCodes'),
          registrationRequestParameters?: [ 
            {
              defaultValue?: string(name='DefaultValue'),
              exampleValue?: string(name='ExampleValue'),
              isRequiredParameter?: boolean(name='IsRequiredParameter'),
              parameterDataType?: int32(name='ParameterDataType'),
              parameterDescription?: string(name='ParameterDescription'),
              parameterName?: string(name='ParameterName'),
              parameterOperator?: int32(name='ParameterOperator'),
              parameterPosition?: int32(name='ParameterPosition'),
            }
          ](name='RegistrationRequestParameters'),
          serviceContentType?: int32(name='ServiceContentType'),
          serviceHost?: string(name='ServiceHost'),
          servicePath?: string(name='ServicePath'),
          serviceRequestBodyDescription?: string(name='ServiceRequestBodyDescription'),
          successfulResultSample?: string(name='SuccessfulResultSample'),
        }(name='RegistrationDetails'),
        requestMethod?: int32(name='RequestMethod'),
        responseContentType?: int32(name='ResponseContentType'),
        scriptDetails?: {
          failedResultSample?: string(name='FailedResultSample'),
          isPagedResponse?: boolean(name='IsPagedResponse'),
          script?: string(name='Script'),
          scriptConnection?: {
            connectionId?: long(name='ConnectionId'),
            tableName?: string(name='TableName'),
          }(name='ScriptConnection'),
          scriptErrorCodes?: [ 
            {
              errorCode?: string(name='ErrorCode'),
              errorMessage?: string(name='ErrorMessage'),
              errorSolution?: string(name='ErrorSolution'),
            }
          ](name='ScriptErrorCodes'),
          scriptRequestParameters?: [ 
            {
              defaultValue?: string(name='DefaultValue'),
              exampleValue?: string(name='ExampleValue'),
              isRequiredParameter?: boolean(name='IsRequiredParameter'),
              parameterDataType?: int32(name='ParameterDataType'),
              parameterDescription?: string(name='ParameterDescription'),
              parameterName?: string(name='ParameterName'),
              parameterOperator?: int32(name='ParameterOperator'),
              parameterPosition?: int32(name='ParameterPosition'),
            }
          ](name='ScriptRequestParameters'),
          scriptResponseParameters?: [ 
            {
              exampleValue?: string(name='ExampleValue'),
              parameterDataType?: int32(name='ParameterDataType'),
              parameterDescription?: string(name='ParameterDescription'),
              parameterName?: string(name='ParameterName'),
            }
          ](name='ScriptResponseParameters'),
          successfulResultSample?: string(name='SuccessfulResultSample'),
        }(name='ScriptDetails'),
        status?: int32(name='Status'),
        tenantId?: long(name='TenantId'),
        timeout?: int32(name='Timeout'),
        visibleRange?: int32(name='VisibleRange'),
        wizardDetails?: {
          failedResultSample?: string(name='FailedResultSample'),
          isPagedResponse?: boolean(name='IsPagedResponse'),
          successfulResultSample?: string(name='SuccessfulResultSample'),
          wizardConnection?: {
            connectionId?: long(name='ConnectionId'),
            tableName?: string(name='TableName'),
          }(name='WizardConnection'),
          wizardErrorCodes?: [ 
            {
              errorCode?: string(name='ErrorCode'),
              errorMessage?: string(name='ErrorMessage'),
              errorSolution?: string(name='ErrorSolution'),
            }
          ](name='WizardErrorCodes'),
          wizardRequestParameters?: [ 
            {
              defaultValue?: string(name='DefaultValue'),
              exampleValue?: string(name='ExampleValue'),
              isRequiredParameter?: boolean(name='IsRequiredParameter'),
              parameterDataType?: int32(name='ParameterDataType'),
              parameterDescription?: string(name='ParameterDescription'),
              parameterName?: string(name='ParameterName'),
              parameterOperator?: int32(name='ParameterOperator'),
              parameterPosition?: int32(name='ParameterPosition'),
            }
          ](name='WizardRequestParameters'),
          wizardResponseParameters?: [ 
            {
              exampleValue?: string(name='ExampleValue'),
              parameterDataType?: int32(name='ParameterDataType'),
              parameterDescription?: string(name='ParameterDescription'),
              parameterName?: string(name='ParameterName'),
            }
          ](name='WizardResponseParameters'),
        }(name='WizardDetails'),
      }
    ](name='Apis'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDataServicePublishedApisResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataServicePublishedApisResponseBody(name='body'),
}

async function listDataServicePublishedApis(request: ListDataServicePublishedApisRequest): ListDataServicePublishedApisResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataServicePublishedApis', 'POST', '/', 'json', true, 'form', request);
}

model ListDataSourcesRequest {
  regionId: string(name='RegionId', position='Host'),
  dataSourceType?: string(name='DataSourceType', position='Query'),
  envType?: int32(name='EnvType', position='Query'),
  name?: string(name='Name', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  projectId: long(name='ProjectId', position='Query'),
  status?: string(name='Status', position='Query'),
  subType?: string(name='SubType', position='Query'),
}

model ListDataSourcesResponseBody = {
  data?: {
    dataSources?: [ 
      {
        bindingCalcEngineId?: int32(name='BindingCalcEngineId'),
        connectStatus?: int32(name='ConnectStatus'),
        content?: string(name='Content'),
        dataSourceType?: string(name='DataSourceType'),
        defaultEngine?: boolean(name='DefaultEngine'),
        description?: string(name='Description'),
        envType?: int32(name='EnvType'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: int32(name='Id'),
        name?: string(name='Name'),
        operator?: string(name='Operator'),
        projectId?: int32(name='ProjectId'),
        sequence?: int32(name='Sequence'),
        shared?: boolean(name='Shared'),
        status?: int32(name='Status'),
        subType?: string(name='SubType'),
        tenantId?: long(name='TenantId'),
      }
    ](name='DataSources'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDataSourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataSourcesResponseBody(name='body'),
}

async function listDataSources(request: ListDataSourcesRequest): ListDataSourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataSources', 'GET', '/', 'json', false, 'json', request);
}

model ListDeploymentsRequest {
  region?: string(name='Region', position='Host'),
  regionId: string(name='RegionId', position='Host'),
  creator?: string(name='Creator', position='Body'),
  endCreateTime?: long(name='EndCreateTime', position='Body'),
  endExecuteTime?: long(name='EndExecuteTime', position='Body'),
  executor?: string(name='Executor', position='Body'),
  keyword?: string(name='Keyword', position='Body'),
  pageNumber?: int32(name='PageNumber', position='Body'),
  pageSize?: int32(name='PageSize', maximum=100, position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
  status?: int32(name='Status', position='Body'),
}

model ListDeploymentsResponseBody = {
  data?: {
    deployments?: [ 
      {
        createTime?: long(name='CreateTime'),
        creator?: string(name='Creator'),
        errorMessage?: string(name='ErrorMessage'),
        executeTime?: long(name='ExecuteTime'),
        executor?: string(name='Executor'),
        id?: long(name='Id'),
        name?: string(name='Name'),
        status?: int32(name='Status'),
      }
    ](name='Deployments'),
    pageNumber?: long(name='PageNumber'),
    pageSize?: long(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListDeploymentsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDeploymentsResponseBody(name='body'),
}

async function listDeployments(request: ListDeploymentsRequest): ListDeploymentsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDeployments', 'POST', '/', 'json', true, 'form', request);
}

model ListEnabledExtensionsForProjectRequest {
  regionId: string(name='RegionId', position='Host'),
  eventCode: string(name='EventCode', position='Body'),
  fileType?: string(name='FileType', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
}

model ListEnabledExtensionsForProjectResponseBody = {
  extensions?: [ 
    {
      createUser?: string(name='CreateUser'),
      extensionCode?: string(name='ExtensionCode'),
      extensionDesc?: string(name='ExtensionDesc'),
      extensionName?: string(name='ExtensionName'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      modifyUser?: string(name='ModifyUser'),
      owner?: string(name='Owner'),
      parameterSetting?: string(name='ParameterSetting'),
      tenantId?: long(name='TenantId'),
    }
  ](name='Extensions'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListEnabledExtensionsForProjectResponse = {
  headers: map[string]string(name='headers'),
  body: ListEnabledExtensionsForProjectResponseBody(name='body'),
}

async function listEnabledExtensionsForProject(request: ListEnabledExtensionsForProjectRequest): ListEnabledExtensionsForProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEnabledExtensionsForProject', 'POST', '/', 'json', true, 'form', request);
}

model ListExtensionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListExtensionsResponseBody = {
  pagingInfo?: {
    extensions?: [ 
      {
        bindEventList?: [ 
          {
            eventCode?: string(name='EventCode'),
            eventName?: string(name='EventName'),
          }
        ](name='BindEventList'),
        extensionCode?: string(name='ExtensionCode'),
        extensionDesc?: string(name='ExtensionDesc'),
        extensionName?: string(name='ExtensionName'),
        owner?: string(name='Owner'),
        status?: int32(name='Status'),
      }
    ](name='Extensions'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PagingInfo'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListExtensionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListExtensionsResponseBody(name='body'),
}

async function listExtensions(request: ListExtensionsRequest): ListExtensionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListExtensions', 'POST', '/', 'json', false, 'json', request);
}

model ListFileTypeRequest {
  regionId: string(name='RegionId', position='Host'),
  keyword?: string(name='Keyword', position='Body'),
  locale?: string(name='Locale', position='Body'),
  pageNumber: int32(name='PageNumber', position='Body'),
  pageSize: int32(name='PageSize', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
}

model ListFileTypeResponseBody = {
  nodeTypeInfoList?: {
    nodeTypeInfo?: [ 
      {
        nodeType?: int32(name='NodeType'),
        nodeTypeName?: string(name='NodeTypeName'),
      }
    ](name='NodeTypeInfo'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='NodeTypeInfoList'),
  requestId?: string(name='RequestId'),
}

model ListFileTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ListFileTypeResponseBody(name='body'),
}

async function listFileType(request: ListFileTypeRequest): ListFileTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFileType', 'POST', '/', 'json', true, 'form', request);
}

model ListFileVersionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  fileId: long(name='FileId', position='Body'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Body'),
  pageSize?: int32(name='PageSize', minimum=0, maximum=100, position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
}

model ListFileVersionsResponseBody = {
  data?: {
    fileVersions?: [ 
      {
        changeType?: string(name='ChangeType'),
        comment?: string(name='Comment'),
        commitTime?: long(name='CommitTime'),
        commitUser?: string(name='CommitUser'),
        fileContent?: string(name='FileContent'),
        fileName?: string(name='FileName'),
        filePropertyContent?: string(name='FilePropertyContent'),
        fileVersion?: int32(name='FileVersion'),
        isCurrentProd?: boolean(name='IsCurrentProd'),
        nodeContent?: string(name='NodeContent'),
        nodeId?: long(name='NodeId'),
        status?: string(name='Status'),
        useType?: string(name='UseType'),
      }
    ](name='FileVersions'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListFileVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFileVersionsResponseBody(name='body'),
}

async function listFileVersions(request: ListFileVersionsRequest): ListFileVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFileVersions', 'POST', '/', 'json', true, 'form', request);
}

model ListFilesRequest {
  regionId: string(name='RegionId', position='Host'),
  fileFolderPath?: string(name='FileFolderPath', position='Body'),
  fileTypes?: string(name='FileTypes', position='Body'),
  keyword?: string(name='Keyword', position='Body'),
  nodeId?: long(name='NodeId', position='Body'),
  owner?: string(name='Owner', position='Body'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Body'),
  pageSize?: int32(name='PageSize', minimum=0, maximum=100, position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
  useType?: string(name='UseType', position='Body'),
}

model ListFilesResponseBody = {
  data?: {
    files?: [ 
      {
        autoParsing?: boolean(name='AutoParsing'),
        bizId?: long(name='BizId'),
        businessId?: long(name='BusinessId'),
        commitStatus?: int32(name='CommitStatus'),
        connectionName?: string(name='ConnectionName'),
        content?: string(name='Content'),
        createTime?: long(name='CreateTime'),
        createUser?: string(name='CreateUser'),
        currentVersion?: int32(name='CurrentVersion'),
        fileDescription?: string(name='FileDescription'),
        fileFolderId?: string(name='FileFolderId'),
        fileId?: long(name='FileId'),
        fileName?: string(name='FileName'),
        fileType?: int32(name='FileType'),
        isMaxCompute?: boolean(name='IsMaxCompute'),
        lastEditTime?: long(name='LastEditTime'),
        lastEditUser?: string(name='LastEditUser'),
        nodeId?: long(name='NodeId'),
        owner?: string(name='Owner'),
        parentId?: long(name='ParentId'),
        useType?: string(name='UseType'),
      }
    ](name='Files'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListFilesResponse = {
  headers: map[string]string(name='headers'),
  body: ListFilesResponseBody(name='body'),
}

async function listFiles(request: ListFilesRequest): ListFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFiles', 'POST', '/', 'json', true, 'form', request);
}

model ListFoldersRequest {
  regionId: string(name='RegionId', position='Host'),
  pageNumber: int32(name='PageNumber', minimum=1, position='Body'),
  pageSize: int32(name='PageSize', minimum=0, maximum=100, position='Body'),
  parentFolderPath: string(name='ParentFolderPath', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
}

model ListFoldersResponseBody = {
  data?: {
    folders?: [ 
      {
        folderId?: string(name='FolderId'),
        folderPath?: string(name='FolderPath'),
      }
    ](name='Folders'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListFoldersResponse = {
  headers: map[string]string(name='headers'),
  body: ListFoldersResponseBody(name='body'),
}

async function listFolders(request: ListFoldersRequest): ListFoldersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFolders', 'POST', '/', 'json', true, 'form', request);
}

model ListInnerNodesRequest {
  regionId: string(name='RegionId', position='Host'),
  nodeName?: string(name='NodeName', position='Body'),
  outerNodeId: long(name='OuterNodeId', position='Body'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=100, position='Body'),
  pageSize?: int32(name='PageSize', minimum=10, maximum=100, position='Body'),
  programType?: string(name='ProgramType', position='Body'),
  projectEnv?: string(name='ProjectEnv', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
}

model ListInnerNodesResponseBody = {
  paging?: {
    nodes?: [ 
      {
        baselineId?: long(name='BaselineId'),
        businessId?: long(name='BusinessId'),
        connection?: string(name='Connection'),
        cronExpress?: string(name='CronExpress'),
        description?: string(name='Description'),
        dqcDescription?: string(name='DqcDescription'),
        dqcType?: string(name='DqcType'),
        nodeId?: long(name='NodeId'),
        nodeName?: string(name='NodeName'),
        ownerId?: string(name='OwnerId'),
        paramValues?: string(name='ParamValues'),
        priority?: int32(name='Priority'),
        programType?: string(name='ProgramType'),
        projectId?: long(name='ProjectId'),
        repeatInterval?: long(name='RepeatInterval'),
        repeatability?: boolean(name='Repeatability'),
        resGroupName?: string(name='ResGroupName'),
        schedulerType?: string(name='SchedulerType'),
      }
    ](name='Nodes'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Paging'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListInnerNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInnerNodesResponseBody(name='body'),
}

async function listInnerNodes(request: ListInnerNodesRequest): ListInnerNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInnerNodes', 'POST', '/', 'json', true, 'form', request);
}

model ListInstanceAmountRequest {
  regionId: string(name='RegionId', position='Host'),
  beginDate: string(name='BeginDate', position='Body'),
  endDate: string(name='EndDate', position='Body'),
  projectId: long(name='ProjectId', minimum=2, maximum=99999999999, position='Body'),
}

model ListInstanceAmountResponseBody = {
  instanceCounts?: [ 
    {
      count?: int32(name='Count'),
      date?: long(name='Date'),
    }
  ](name='InstanceCounts'),
  requestId?: string(name='RequestId'),
}

model ListInstanceAmountResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceAmountResponseBody(name='body'),
}

async function listInstanceAmount(request: ListInstanceAmountRequest): ListInstanceAmountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstanceAmount', 'POST', '/', 'json', true, 'form', request);
}

model ListInstanceHistoryRequest {
  regionId: string(name='RegionId', position='Host'),
  instanceId: long(name='InstanceId', position='Body'),
  projectEnv?: string(name='ProjectEnv', position='Body'),
}

model ListInstanceHistoryResponseBody = {
  instances?: [ 
    {
      beginRunningTime?: long(name='BeginRunningTime'),
      beginWaitResTime?: long(name='BeginWaitResTime'),
      beginWaitTimeTime?: long(name='BeginWaitTimeTime'),
      bizdate?: long(name='Bizdate'),
      createTime?: long(name='CreateTime'),
      cycTime?: long(name='CycTime'),
      dagId?: long(name='DagId'),
      dagType?: string(name='DagType'),
      errorMessage?: string(name='ErrorMessage'),
      finishTime?: long(name='FinishTime'),
      instanceHistoryId?: long(name='InstanceHistoryId'),
      instanceId?: long(name='InstanceId'),
      modifyTime?: long(name='ModifyTime'),
      nodeId?: long(name='NodeId'),
      nodeName?: string(name='NodeName'),
      status?: string(name='Status'),
      taskType?: string(name='TaskType'),
    }
  ](name='Instances'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListInstanceHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceHistoryResponseBody(name='body'),
}

async function listInstanceHistory(request: ListInstanceHistoryRequest): ListInstanceHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstanceHistory', 'POST', '/', 'json', true, 'form', request);
}

model ListInstancesRequest {
  regionId: string(name='RegionId', position='Host'),
  beginBizdate?: string(name='BeginBizdate', position='Body'),
  bizName?: string(name='BizName', position='Body'),
  bizdate?: string(name='Bizdate', position='Body'),
  dagId?: long(name='DagId', position='Body'),
  endBizdate?: string(name='EndBizdate', position='Body'),
  nodeId?: long(name='NodeId', position='Body'),
  nodeName?: string(name='NodeName', position='Body'),
  owner?: string(name='Owner', position='Body'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Body'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Body'),
  programType?: string(name='ProgramType', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
  status?: string(name='Status', position='Body'),
}

model ListInstancesResponseBody = {
  data?: {
    instances?: [ 
      {
        baselineId?: long(name='BaselineId'),
        beginRunningTime?: long(name='BeginRunningTime'),
        beginWaitResTime?: long(name='BeginWaitResTime'),
        beginWaitTimeTime?: long(name='BeginWaitTimeTime'),
        bizdate?: long(name='Bizdate'),
        businessId?: long(name='BusinessId'),
        connection?: string(name='Connection'),
        createTime?: long(name='CreateTime'),
        createUser?: string(name='CreateUser'),
        cycTime?: long(name='CycTime'),
        dagId?: long(name='DagId'),
        dagType?: string(name='DagType'),
        dqcDescription?: string(name='DqcDescription'),
        dqcType?: int32(name='DqcType'),
        errorMessage?: string(name='ErrorMessage'),
        finishTime?: long(name='FinishTime'),
        instanceId?: long(name='InstanceId'),
        modifyTime?: long(name='ModifyTime'),
        nodeId?: long(name='NodeId'),
        nodeName?: string(name='NodeName'),
        paramValues?: string(name='ParamValues'),
        priority?: int32(name='Priority'),
        relatedFlowId?: long(name='RelatedFlowId'),
        repeatInterval?: long(name='RepeatInterval'),
        repeatability?: boolean(name='Repeatability'),
        status?: string(name='Status'),
        taskRerunTime?: int32(name='TaskRerunTime'),
        taskType?: string(name='TaskType'),
      }
    ](name='Instances'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstances', 'POST', '/', 'json', true, 'form', request);
}

model ListManualDagInstancesRequest {
  regionId: string(name='RegionId', position='Host'),
  dagId: string(name='DagId', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
  projectName: string(name='ProjectName', position='Body'),
}

model ListManualDagInstancesResponseBody = {
  instances?: [ 
    {
      beginRunningTime?: long(name='BeginRunningTime'),
      beginWaitResTime?: long(name='BeginWaitResTime'),
      beginWaitTimeTime?: long(name='BeginWaitTimeTime'),
      bizDate?: long(name='BizDate'),
      createTime?: long(name='CreateTime'),
      createUser?: string(name='CreateUser'),
      cycTime?: long(name='CycTime'),
      dagId?: long(name='DagId'),
      dagType?: string(name='DagType'),
      finishTime?: long(name='FinishTime'),
      instanceId?: long(name='InstanceId'),
      modifyTime?: long(name='ModifyTime'),
      nodeId?: long(name='NodeId'),
      nodeName?: string(name='NodeName'),
      paramValues?: string(name='ParamValues'),
      status?: string(name='Status'),
      taskType?: string(name='TaskType'),
    }
  ](name='Instances'),
  requestId?: string(name='RequestId'),
}

model ListManualDagInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListManualDagInstancesResponseBody(name='body'),
}

async function listManualDagInstances(request: ListManualDagInstancesRequest): ListManualDagInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListManualDagInstances', 'POST', '/', 'json', true, 'form', request);
}

model ListMetaDBRequest {
  regionId: string(name='RegionId', position='Host'),
  clusterId?: string(name='ClusterId', position='Query'),
  dataSourceType: string(name='DataSourceType', position='Query'),
  pageNum?: int32(name='PageNum', minimum=1, maximum=10000, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  projectId: long(name='ProjectId', position='Query'),
}

model ListMetaDBResponseBody = {
  databaseInfo?: {
    dbList?: [ 
      {
        createTimeStamp?: long(name='CreateTimeStamp'),
        location?: string(name='Location'),
        modifiedTimeStamp?: long(name='ModifiedTimeStamp'),
        name?: string(name='Name'),
        ownerId?: string(name='OwnerId'),
        type?: string(name='Type'),
        UUID?: string(name='UUID'),
      }
    ](name='DbList'),
    totalCount?: long(name='TotalCount'),
  }(name='DatabaseInfo'),
  requestId?: string(name='RequestId'),
}

model ListMetaDBResponse = {
  headers: map[string]string(name='headers'),
  body: ListMetaDBResponseBody(name='body'),
}

async function listMetaDB(request: ListMetaDBRequest): ListMetaDBResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMetaDB', 'GET', '/', 'json', false, 'json', request);
}

model ListMigrationsRequest {
  regionId: string(name='RegionId', position='Host'),
  migrationType: string(name='MigrationType', description='Migration operation type, IMPORT/EXPORT', position='Body'),
  owner?: string(name='Owner', position='Body'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=100, position='Body'),
  pageSize?: int32(name='PageSize', minimum=10, maximum=100, position='Body'),
  projectId: long(name='ProjectId', description='Workspace Id', minimum=2, position='Body'),
}

model ListMigrationsResponseBody = {
  data?: {
    migrations?: [ 
      {
        createTime?: long(name='CreateTime'),
        createUser?: string(name='CreateUser'),
        createUserName?: string(name='CreateUserName'),
        description?: string(name='Description'),
        downloadUrl?: string(name='DownloadUrl'),
        id?: long(name='Id'),
        message?: string(name='Message'),
        migrationType?: string(name='MigrationType'),
        name?: string(name='Name'),
        packageType?: string(name='PackageType'),
        projectId?: long(name='ProjectId'),
        status?: string(name='Status'),
        tenantId?: long(name='TenantId'),
        updateTime?: long(name='UpdateTime'),
        updateUser?: string(name='UpdateUser'),
        updateUserName?: string(name='UpdateUserName'),
      }
    ](name='Migrations'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListMigrationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListMigrationsResponseBody(name='body'),
}

async function listMigrations(request: ListMigrationsRequest): ListMigrationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMigrations', 'POST', '/', 'json', true, 'form', request);
}

model ListNodeIORequest {
  regionId: string(name='RegionId', position='Host'),
  ioType: string(name='IoType', position='Body'),
  nodeId: long(name='NodeId', minimum=2, position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model ListNodeIOResponseBody = {
  data?: [ 
    {
      data?: string(name='Data'),
      nodeId?: long(name='NodeId'),
      tableName?: string(name='TableName'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListNodeIOResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodeIOResponseBody(name='body'),
}

async function listNodeIO(request: ListNodeIORequest): ListNodeIOResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListNodeIO', 'POST', '/', 'json', true, 'form', request);
}

model ListNodeInputOrOutputRequest {
  regionId: string(name='RegionId', position='Host'),
  ioType: string(name='IoType', position='Body'),
  nodeId: long(name='NodeId', minimum=2, position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model ListNodeInputOrOutputResponseBody = {
  data?: [ 
    {
      data?: string(name='Data'),
      nodeId?: long(name='NodeId'),
      tableName?: string(name='TableName'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListNodeInputOrOutputResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodeInputOrOutputResponseBody(name='body'),
}

async function listNodeInputOrOutput(request: ListNodeInputOrOutputRequest): ListNodeInputOrOutputResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListNodeInputOrOutput', 'POST', '/', 'json', true, 'form', request);
}

model ListNodesRequest {
  regionId: string(name='RegionId', position='Host'),
  bizName?: string(name='BizName', position='Body'),
  nodeName?: string(name='NodeName', position='Body'),
  owner?: string(name='Owner', position='Body'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Body'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Body'),
  programType?: string(name='ProgramType', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
}

model ListNodesResponseBody = {
  data?: {
    nodes?: [ 
      {
        baselineId?: long(name='BaselineId'),
        businessId?: long(name='BusinessId'),
        connection?: string(name='Connection'),
        cronExpress?: string(name='CronExpress'),
        description?: string(name='Description'),
        dqcDescription?: string(name='DqcDescription'),
        dqcType?: int32(name='DqcType'),
        nodeId?: long(name='NodeId'),
        nodeName?: string(name='NodeName'),
        ownerId?: string(name='OwnerId'),
        paramValues?: string(name='ParamValues'),
        priority?: int32(name='Priority'),
        programType?: string(name='ProgramType'),
        projectId?: long(name='ProjectId'),
        relatedFlowId?: long(name='RelatedFlowId'),
        repeatInterval?: long(name='RepeatInterval'),
        repeatability?: boolean(name='Repeatability'),
        resGroupName?: string(name='ResGroupName'),
        schedulerType?: string(name='SchedulerType'),
      }
    ](name='Nodes'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesResponseBody(name='body'),
}

async function listNodes(request: ListNodesRequest): ListNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListNodes', 'POST', '/', 'json', true, 'form', request);
}

model ListNodesByBaselineRequest {
  regionId: string(name='RegionId', position='Host'),
  baselineId: long(name='BaselineId', position='Body'),
}

model ListNodesByBaselineResponseBody = {
  data?: [ 
    {
      nodeId?: long(name='NodeId'),
      nodeName?: string(name='NodeName'),
      owner?: string(name='Owner'),
      projectId?: long(name='ProjectId'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model ListNodesByBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesByBaselineResponseBody(name='body'),
}

async function listNodesByBaseline(request: ListNodesByBaselineRequest): ListNodesByBaselineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListNodesByBaseline', 'POST', '/', 'json', true, 'form', request);
}

model ListNodesByOutputRequest {
  regionId: string(name='RegionId', position='Host'),
  outputs: string(name='Outputs', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model ListNodesByOutputResponseBody = {
  data?: [ 
    {
      nodeList?: [ 
        {
          baselineId?: long(name='BaselineId'),
          connection?: string(name='Connection'),
          cronExpress?: string(name='CronExpress'),
          description?: string(name='Description'),
          dqcDescription?: string(name='DqcDescription'),
          dqcType?: int32(name='DqcType'),
          fileType?: string(name='FileType'),
          nodeId?: long(name='NodeId'),
          nodeName?: string(name='NodeName'),
          ownerId?: string(name='OwnerId'),
          paramValues?: string(name='ParamValues'),
          priority?: int32(name='Priority'),
          programType?: string(name='ProgramType'),
          projectId?: long(name='ProjectId'),
          relatedFlowId?: long(name='RelatedFlowId'),
          repeatInterval?: int32(name='RepeatInterval'),
          repeatability?: boolean(name='Repeatability'),
          resGroupName?: string(name='ResGroupName'),
          schedulerType?: string(name='SchedulerType'),
        }
      ](name='NodeList'),
      output?: string(name='Output'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListNodesByOutputResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesByOutputResponseBody(name='body'),
}

async function listNodesByOutput(request: ListNodesByOutputRequest): ListNodesByOutputResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListNodesByOutput', 'POST', '/', 'json', true, 'form', request);
}

model ListPermissionApplyOrdersRequest {
  regionId: string(name='RegionId', position='Host'),
  endTime?: long(name='EndTime', position='Query'),
  engineType: string(name='EngineType', position='Query'),
  flowStatus?: int32(name='FlowStatus', position='Query'),
  maxComputeProjectName?: string(name='MaxComputeProjectName', position='Query'),
  orderType: int32(name='OrderType', minimum=1, maximum=1, position='Query'),
  pageNum?: int32(name='PageNum', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  queryType: int32(name='QueryType', minimum=0, maximum=1, position='Query'),
  startTime?: long(name='StartTime', position='Query'),
  tableName?: string(name='TableName', position='Query'),
  workspaceId?: int32(name='WorkspaceId', position='Query'),
}

model ListPermissionApplyOrdersResponseBody = {
  applyOrders?: {
    applyOrder?: [ 
      {
        applyBaseId?: string(name='ApplyBaseId'),
        applyTimestamp?: long(name='ApplyTimestamp'),
        approveContent?: {
          applyReason?: string(name='ApplyReason'),
          orderType?: int32(name='OrderType'),
          projectMeta?: {
            objectMetaList?: [ 
              {
                actions?: [ string ](name='Actions'),
                objectName?: string(name='ObjectName'),
              }
            ](name='ObjectMetaList'),
            workspaceName?: string(name='WorkspaceName'),
          }(name='ProjectMeta'),
        }(name='ApproveContent'),
        flowId?: string(name='FlowId'),
        flowStatus?: int32(name='FlowStatus'),
      }
    ](name='ApplyOrder'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='ApplyOrders'),
  requestId?: string(name='RequestId'),
}

model ListPermissionApplyOrdersResponse = {
  headers: map[string]string(name='headers'),
  body: ListPermissionApplyOrdersResponseBody(name='body'),
}

async function listPermissionApplyOrders(request: ListPermissionApplyOrdersRequest): ListPermissionApplyOrdersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPermissionApplyOrders', 'POST', '/', 'json', false, 'json', request);
}

model ListProgramTypeCountRequest {
  regionId: string(name='RegionId', position='Host'),
  projectEnv: string(name='ProjectEnv', position='Body'),
  projectId: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Body'),
}

model ListProgramTypeCountResponseBody = {
  programTypeAndCounts?: [ 
    {
      count?: int32(name='Count'),
      programType?: string(name='ProgramType'),
    }
  ](name='ProgramTypeAndCounts'),
  requestId?: string(name='RequestId'),
}

model ListProgramTypeCountResponse = {
  headers: map[string]string(name='headers'),
  body: ListProgramTypeCountResponseBody(name='body'),
}

async function listProgramTypeCount(request: ListProgramTypeCountRequest): ListProgramTypeCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListProgramTypeCount', 'POST', '/', 'json', true, 'form', request);
}

model ListProjectIdsRequest {
  regionId?: string(name='RegionId', position='Host'),
  userId: string(name='UserId', maxLength=10000000, position='Query'),
}

model ListProjectIdsResponseBody = {
  projectIds?: [ long ](name='ProjectIds'),
  requestId?: string(name='RequestId'),
}

model ListProjectIdsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectIdsResponseBody(name='body'),
}

async function listProjectIds(request: ListProjectIdsRequest): ListProjectIdsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListProjectIds', 'POST', '/', 'json', false, 'json', request);
}

model ListProjectMembersRequest {
  regionId: string(name='RegionId', position='Host'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=10000, position='Query'),
  pageSize?: int32(name='PageSize', minimum=5, maximum=20, position='Query'),
  projectId: long(name='ProjectId', minimum=0, maximum=10000000, position='Query'),
}

model ListProjectMembersResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    projectMemberList?: [ 
      {
        nick?: string(name='Nick'),
        projectMemberId?: string(name='ProjectMemberId'),
        projectMemberName?: string(name='ProjectMemberName'),
        projectMemberType?: string(name='ProjectMemberType'),
        projectRoleList?: [ 
          {
            projectRoleCode?: string(name='ProjectRoleCode'),
            projectRoleId?: int32(name='ProjectRoleId'),
            projectRoleName?: string(name='ProjectRoleName'),
            projectRoleType?: string(name='ProjectRoleType'),
          }
        ](name='ProjectRoleList'),
        status?: string(name='Status'),
      }
    ](name='ProjectMemberList'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListProjectMembersResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectMembersResponseBody(name='body'),
}

async function listProjectMembers(request: ListProjectMembersRequest): ListProjectMembersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListProjectMembers', 'POST', '/', 'json', false, 'json', request);
}

model ListProjectRolesRequest {
  regionId: string(name='RegionId', position='Host'),
  projectId: long(name='ProjectId', minimum=0, maximum=1000000, position='Query'),
}

model ListProjectRolesResponseBody = {
  projectRoleList?: [ 
    {
      projectRoleCode?: string(name='ProjectRoleCode'),
      projectRoleId?: int32(name='ProjectRoleId'),
      projectRoleName?: string(name='ProjectRoleName'),
      projectRoleType?: string(name='ProjectRoleType'),
    }
  ](name='ProjectRoleList'),
  requestId?: string(name='RequestId'),
}

model ListProjectRolesResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectRolesResponseBody(name='body'),
}

async function listProjectRoles(request: ListProjectRolesRequest): ListProjectRolesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListProjectRoles', 'POST', '/', 'json', false, 'json', request);
}

model ListProjectsRequest {
  regionId: string(name='RegionId', position='Host'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=10000000, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=10000000, position='Query'),
  resourceManagerResourceGroupId?: string(name='ResourceManagerResourceGroupId', position='Query'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags', shrink='json', position='Query'),
}

model ListProjectsResponseBody = {
  pageResult?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    projectList?: [ 
      {
        disableDevelopment?: boolean(name='DisableDevelopment'),
        isDefault?: int32(name='IsDefault'),
        projectDescription?: string(name='ProjectDescription'),
        projectId?: long(name='ProjectId'),
        projectIdentifier?: string(name='ProjectIdentifier'),
        projectName?: string(name='ProjectName'),
        projectOwnerBaseId?: string(name='ProjectOwnerBaseId'),
        projectStatus?: int32(name='ProjectStatus'),
        projectStatusCode?: string(name='ProjectStatusCode'),
        resourceManagerResourceGroupId?: string(name='ResourceManagerResourceGroupId'),
        tablePrivacyMode?: int32(name='TablePrivacyMode'),
        tags?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Tags'),
        useProxyOdpsAccount?: boolean(name='UseProxyOdpsAccount'),
      }
    ](name='ProjectList'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageResult'),
  requestId?: string(name='RequestId'),
}

model ListProjectsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectsResponseBody(name='body'),
}

async function listProjects(request: ListProjectsRequest): ListProjectsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListProjects', 'POST', '/', 'json', false, 'json', request);
}

model ListQualityResultsByEntityRequest {
  regionId?: string(name='RegionId', position='Host'),
  endDate: string(name='EndDate', position='Body'),
  entityId: int32(name='EntityId', minimum=1, maximum=2147483647, position='Body'),
  pageNumber: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Body'),
  pageSize: int32(name='PageSize', minimum=1, maximum=20, position='Body'),
  projectName: string(name='ProjectName', position='Body'),
  startDate: string(name='StartDate', position='Body'),
}

model ListQualityResultsByEntityResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    ruleChecks?: [ 
      {
        actualExpression?: string(name='ActualExpression'),
        beginTime?: long(name='BeginTime'),
        bizDate?: long(name='BizDate'),
        blockType?: int32(name='BlockType'),
        checkResult?: int32(name='CheckResult'),
        checkResultStatus?: int32(name='CheckResultStatus'),
        checkerId?: int32(name='CheckerId'),
        checkerName?: string(name='CheckerName'),
        checkerType?: int32(name='CheckerType'),
        comment?: string(name='Comment'),
        criticalThreshold?: float(name='CriticalThreshold'),
        dateType?: string(name='DateType'),
        discreteCheck?: boolean(name='DiscreteCheck'),
        endTime?: long(name='EndTime'),
        entityId?: int32(name='EntityId'),
        expectValue?: float(name='ExpectValue'),
        externalId?: string(name='ExternalId'),
        externalType?: string(name='ExternalType'),
        fixedCheck?: boolean(name='FixedCheck'),
        id?: int32(name='Id'),
        isPrediction?: boolean(name='IsPrediction'),
        lowerValue?: float(name='LowerValue'),
        matchExpression?: string(name='MatchExpression'),
        methodName?: string(name='MethodName'),
        op?: string(name='Op'),
        projectName?: string(name='ProjectName'),
        property?: string(name='Property'),
        referenceValue?: [ 
          {
            bizDate?: string(name='BizDate'),
            discreteProperty?: string(name='DiscreteProperty'),
            singleCheckResult?: int32(name='SingleCheckResult'),
            threshold?: float(name='Threshold'),
            value?: float(name='Value'),
          }
        ](name='ReferenceValue'),
        resultString?: string(name='ResultString'),
        ruleId?: int32(name='RuleId'),
        ruleName?: string(name='RuleName'),
        sampleValue?: [ 
          {
            bizDate?: string(name='BizDate'),
            discreteProperty?: string(name='DiscreteProperty'),
            value?: float(name='Value'),
          }
        ](name='SampleValue'),
        tableName?: string(name='TableName'),
        taskId?: string(name='TaskId'),
        templateId?: int32(name='TemplateId'),
        templateName?: string(name='TemplateName'),
        timeCost?: string(name='TimeCost'),
        trend?: string(name='Trend'),
        upperValue?: float(name='UpperValue'),
        warningThreshold?: float(name='WarningThreshold'),
        whereCondition?: string(name='WhereCondition'),
      }
    ](name='RuleChecks'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListQualityResultsByEntityResponse = {
  headers: map[string]string(name='headers'),
  body: ListQualityResultsByEntityResponseBody(name='body'),
}

async function listQualityResultsByEntity(request: ListQualityResultsByEntityRequest): ListQualityResultsByEntityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListQualityResultsByEntity', 'POST', '/', 'json', true, 'form', request);
}

model ListQualityResultsByRuleRequest {
  regionId?: string(name='RegionId', position='Host'),
  endDate: string(name='EndDate', position='Body'),
  pageNumber: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Body'),
  pageSize: int32(name='PageSize', minimum=1, maximum=20, position='Body'),
  projectName: string(name='ProjectName', position='Body'),
  ruleId: int32(name='RuleId', minimum=1, maximum=2147483647, position='Body'),
  startDate: string(name='StartDate', position='Body'),
}

model ListQualityResultsByRuleResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    ruleChecks?: [ 
      {
        actualExpression?: string(name='ActualExpression'),
        beginTime?: long(name='BeginTime'),
        bizDate?: long(name='BizDate'),
        blockType?: int32(name='BlockType'),
        checkResult?: int32(name='CheckResult'),
        checkResultStatus?: int32(name='CheckResultStatus'),
        checkerId?: int32(name='CheckerId'),
        checkerName?: string(name='CheckerName'),
        checkerType?: int32(name='CheckerType'),
        comment?: string(name='Comment'),
        criticalThreshold?: float(name='CriticalThreshold'),
        dateType?: string(name='DateType'),
        discreteCheck?: boolean(name='DiscreteCheck'),
        endTime?: long(name='EndTime'),
        entityId?: int32(name='EntityId'),
        expectValue?: float(name='ExpectValue'),
        externalId?: string(name='ExternalId'),
        externalType?: string(name='ExternalType'),
        fixedCheck?: boolean(name='FixedCheck'),
        id?: int32(name='Id'),
        isPrediction?: boolean(name='IsPrediction'),
        lowerValue?: float(name='LowerValue'),
        matchExpression?: string(name='MatchExpression'),
        methodName?: string(name='MethodName'),
        op?: string(name='Op'),
        projectName?: string(name='ProjectName'),
        property?: string(name='Property'),
        referenceValue?: [ 
          {
            bizDate?: string(name='BizDate'),
            discreteProperty?: string(name='DiscreteProperty'),
            singleCheckResult?: int32(name='SingleCheckResult'),
            threshold?: float(name='Threshold'),
            value?: float(name='Value'),
          }
        ](name='ReferenceValue'),
        resultString?: string(name='ResultString'),
        ruleId?: int32(name='RuleId'),
        ruleName?: string(name='RuleName'),
        sampleValue?: [ 
          {
            bizDate?: string(name='BizDate'),
            discreteProperty?: string(name='DiscreteProperty'),
            value?: float(name='Value'),
          }
        ](name='SampleValue'),
        tableName?: string(name='TableName'),
        taskId?: string(name='TaskId'),
        templateId?: int32(name='TemplateId'),
        templateName?: string(name='TemplateName'),
        timeCost?: string(name='TimeCost'),
        trend?: string(name='Trend'),
        upperValue?: float(name='UpperValue'),
        warningThreshold?: float(name='WarningThreshold'),
        whereCondition?: string(name='WhereCondition'),
      }
    ](name='RuleChecks'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListQualityResultsByRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ListQualityResultsByRuleResponseBody(name='body'),
}

async function listQualityResultsByRule(request: ListQualityResultsByRuleRequest): ListQualityResultsByRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListQualityResultsByRule', 'POST', '/', 'json', true, 'form', request);
}

model ListQualityRulesRequest {
  regionId?: string(name='RegionId', position='Host'),
  entityId: long(name='EntityId', position='Body'),
  pageNumber: int32(name='PageNumber', minimum=1, position='Body'),
  pageSize: int32(name='PageSize', minimum=1, maximum=20, position='Body'),
  projectName: string(name='ProjectName', position='Body'),
}

model ListQualityRulesResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    rules?: [ 
      {
        blockType?: int32(name='BlockType'),
        checkerId?: int32(name='CheckerId'),
        comment?: string(name='Comment'),
        criticalThreshold?: string(name='CriticalThreshold'),
        entityId?: int32(name='EntityId'),
        expectValue?: string(name='ExpectValue'),
        fixCheck?: boolean(name='FixCheck'),
        historyCriticalThreshold?: string(name='HistoryCriticalThreshold'),
        historyWarningThreshold?: string(name='HistoryWarningThreshold'),
        id?: int32(name='Id'),
        matchExpression?: string(name='MatchExpression'),
        methodId?: int32(name='MethodId'),
        methodName?: string(name='MethodName'),
        onDuty?: string(name='OnDuty'),
        onDutyAccountName?: string(name='OnDutyAccountName'),
        projectName?: string(name='ProjectName'),
        property?: string(name='Property'),
        propertyKey?: string(name='PropertyKey'),
        ruleCheckerRelationId?: int32(name='RuleCheckerRelationId'),
        ruleName?: string(name='RuleName', description='规则名称'),
        ruleType?: int32(name='RuleType'),
        tableName?: string(name='TableName'),
        templateId?: int32(name='TemplateId'),
        templateName?: string(name='TemplateName'),
        trend?: string(name='Trend'),
        warningThreshold?: string(name='WarningThreshold'),
      }
    ](name='Rules'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListQualityRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListQualityRulesResponseBody(name='body'),
}

async function listQualityRules(request: ListQualityRulesRequest): ListQualityRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListQualityRules', 'POST', '/', 'json', true, 'form', request);
}

model ListRefDISyncTasksRequest {
  regionId: string(name='RegionId', position='Host'),
  datasourceName: string(name='DatasourceName', position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=100000, position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  refType: string(name='RefType', position='Query'),
  taskType: string(name='TaskType', position='Query'),
}

model ListRefDISyncTasksResponseBody = {
  data?: {
    DISyncTasks?: [ 
      {
        diDestinationDatasource?: string(name='DiDestinationDatasource'),
        diSourceDatasource?: string(name='DiSourceDatasource'),
        nodeId?: long(name='NodeId'),
        nodeName?: string(name='NodeName'),
        taskType?: string(name='TaskType'),
      }
    ](name='DISyncTasks'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListRefDISyncTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListRefDISyncTasksResponseBody(name='body'),
}

async function listRefDISyncTasks(request: ListRefDISyncTasksRequest): ListRefDISyncTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListRefDISyncTasks', 'POST', '/', 'json', false, 'json', request);
}

model ListRemindsRequest {
  regionId: string(name='RegionId', position='Host'),
  alertTarget?: string(name='AlertTarget', position='Body'),
  founder?: string(name='Founder', position='Body'),
  nodeId?: long(name='NodeId', position='Body'),
  pageNumber: int32(name='PageNumber', position='Body'),
  pageSize: int32(name='PageSize', position='Body'),
  remindTypes?: string(name='RemindTypes', position='Body'),
  searchText?: string(name='SearchText', position='Body'),
}

model ListRemindsResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    reminds?: [ 
      {
        alertMethods?: [ string ](name='AlertMethods'),
        alertTargets?: [ string ](name='AlertTargets'),
        alertUnit?: string(name='AlertUnit'),
        baselineIds?: [ long ](name='BaselineIds'),
        bizProcessIds?: [ long ](name='BizProcessIds'),
        dndEnd?: string(name='DndEnd'),
        dndStart?: string(name='DndStart'),
        founder?: string(name='Founder'),
        nodeIds?: [ long ](name='NodeIds'),
        projectIds?: [ long ](name='ProjectIds'),
        remindId?: long(name='RemindId'),
        remindName?: string(name='RemindName'),
        remindType?: string(name='RemindType'),
        remindUnit?: string(name='RemindUnit'),
        useflag?: boolean(name='Useflag'),
      }
    ](name='Reminds'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListRemindsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRemindsResponseBody(name='body'),
}

async function listReminds(request: ListRemindsRequest): ListRemindsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListReminds', 'POST', '/', 'json', true, 'form', request);
}

model ListResourceGroupsRequest {
  regionId: string(name='RegionId', position='Host'),
  bizExtKey?: string(name='BizExtKey', position='Query'),
  keyword?: string(name='Keyword', position='Query'),
  resourceGroupType: int32(name='ResourceGroupType', position='Query'),
  resourceManagerResourceGroupId?: string(name='ResourceManagerResourceGroupId', position='Query'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags', shrink='json', position='Query'),
}

model ListResourceGroupsResponseBody = {
  data?: [ 
    {
      bizExtKey?: string(name='BizExtKey'),
      cluster?: string(name='Cluster'),
      createTime?: string(name='CreateTime'),
      enableKp?: boolean(name='EnableKp'),
      id?: long(name='Id'),
      identifier?: string(name='Identifier'),
      isDefault?: boolean(name='IsDefault'),
      mode?: string(name='Mode'),
      name?: string(name='Name'),
      resourceGroupType?: string(name='ResourceGroupType'),
      resourceManagerResourceGroupId?: string(name='ResourceManagerResourceGroupId'),
      sequence?: int32(name='Sequence'),
      specs?: map[string]any(name='Specs'),
      status?: int32(name='Status'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      tenantId?: long(name='TenantId'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListResourceGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListResourceGroupsResponseBody(name='body'),
}

async function listResourceGroups(request: ListResourceGroupsRequest): ListResourceGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListResourceGroups', 'POST', '/', 'json', false, 'json', request);
}

model ListShiftPersonnelsRequest {
  regionId?: string(name='RegionId', position='Host'),
  beginTime: long(name='BeginTime', position='Body'),
  endTime: long(name='EndTime', position='Body'),
  shiftPersonUID?: string(name='ShiftPersonUID', position='Body'),
  shiftScheduleIdentifier: string(name='ShiftScheduleIdentifier', position='Body'),
  userType?: string(name='UserType', position='Body'),
}

model ListShiftPersonnelsResponseBody = {
  paging?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    shiftPersons?: [ 
      {
        beginTime?: long(name='BeginTime'),
        endTime?: long(name='EndTime'),
        shiftPersonName?: string(name='ShiftPersonName'),
        shiftPersonUID?: string(name='ShiftPersonUID'),
      }
    ](name='ShiftPersons'),
    totalCount?: int32(name='TotalCount'),
  }(name='Paging'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListShiftPersonnelsResponse = {
  headers: map[string]string(name='headers'),
  body: ListShiftPersonnelsResponseBody(name='body'),
}

async function listShiftPersonnels(request: ListShiftPersonnelsRequest): ListShiftPersonnelsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListShiftPersonnels', 'POST', '/', 'json', true, 'form', request);
}

model ListShiftSchedulesRequest {
  regionId: string(name='RegionId', position='Host'),
  owner?: string(name='Owner', position='Body'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=100, position='Body'),
  pageSize?: int32(name='PageSize', minimum=10, maximum=100, position='Body'),
  shiftScheduleName?: string(name='ShiftScheduleName', position='Body'),
}

model ListShiftSchedulesResponseBody = {
  paging?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    shiftSchedules?: [ 
      {
        shiftScheduleIdentifier?: string(name='ShiftScheduleIdentifier'),
        shiftScheduleName?: string(name='ShiftScheduleName'),
      }
    ](name='ShiftSchedules'),
    totalCount?: int32(name='TotalCount'),
  }(name='Paging'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListShiftSchedulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListShiftSchedulesResponseBody(name='body'),
}

async function listShiftSchedules(request: ListShiftSchedulesRequest): ListShiftSchedulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListShiftSchedules', 'POST', '/', 'json', true, 'form', request);
}

model ListSuccessInstanceAmountRequest {
  regionId: string(name='RegionId', position='Host'),
  projectId: long(name='ProjectId', minimum=2, maximum=99999999999, position='Body'),
}

model ListSuccessInstanceAmountResponseBody = {
  instanceStatusTrend?: {
    avgTrend?: [ 
      {
        count?: int32(name='Count'),
        timePoint?: string(name='TimePoint'),
      }
    ](name='AvgTrend'),
    todayTrend?: [ 
      {
        count?: int32(name='Count'),
        timePoint?: string(name='TimePoint'),
      }
    ](name='TodayTrend'),
    yesterdayTrend?: [ 
      {
        count?: int32(name='Count'),
        timePoint?: string(name='TimePoint'),
      }
    ](name='YesterdayTrend'),
  }(name='InstanceStatusTrend'),
  requestId?: string(name='RequestId'),
}

model ListSuccessInstanceAmountResponse = {
  headers: map[string]string(name='headers'),
  body: ListSuccessInstanceAmountResponseBody(name='body'),
}

async function listSuccessInstanceAmount(request: ListSuccessInstanceAmountRequest): ListSuccessInstanceAmountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSuccessInstanceAmount', 'POST', '/', 'json', true, 'form', request);
}

model ListTableLevelRequest {
  regionId: string(name='RegionId', position='Host'),
  levelType: int32(name='LevelType', minimum=0, maximum=10, position='Query'),
  pageNum?: int32(name='PageNum', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Query'),
}

model ListTableLevelResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tableLevelInfo?: {
    levelList?: [ 
      {
        description?: string(name='Description'),
        levelId?: long(name='LevelId'),
        levelType?: int32(name='LevelType'),
        name?: string(name='Name'),
        projectId?: long(name='ProjectId'),
      }
    ](name='LevelList'),
    totalCount?: long(name='TotalCount'),
  }(name='TableLevelInfo'),
}

model ListTableLevelResponse = {
  headers: map[string]string(name='headers'),
  body: ListTableLevelResponseBody(name='body'),
}

async function listTableLevel(request: ListTableLevelRequest): ListTableLevelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTableLevel', 'GET', '/', 'json', false, 'json', request);
}

model ListTableThemeRequest {
  regionId: string(name='RegionId', position='Host'),
  pageNum?: int32(name='PageNum', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  parentId?: long(name='ParentId', minimum=1, maximum=9223372036854775807, position='Query'),
  projectId?: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Query'),
}

model ListTableThemeResponseBody = {
  data?: {
    themeList?: [ 
      {
        createTimeStamp?: long(name='CreateTimeStamp'),
        creator?: string(name='Creator'),
        level?: int32(name='Level'),
        name?: string(name='Name'),
        parentId?: long(name='ParentId'),
        projectId?: long(name='ProjectId'),
        themeId?: long(name='ThemeId'),
      }
    ](name='ThemeList'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListTableThemeResponse = {
  headers: map[string]string(name='headers'),
  body: ListTableThemeResponseBody(name='body'),
}

async function listTableTheme(request: ListTableThemeRequest): ListTableThemeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTableTheme', 'GET', '/', 'json', false, 'json', request);
}

model ListTopicsRequest {
  regionId: string(name='RegionId', position='Host'),
  beginTime: string(name='BeginTime', position='Body'),
  endTime: string(name='EndTime', position='Body'),
  instanceId?: long(name='InstanceId', position='Body'),
  nodeId?: long(name='NodeId', position='Body'),
  owner?: string(name='Owner', position='Body'),
  pageNumber: int32(name='PageNumber', minimum=1, maximum=30, position='Body'),
  pageSize: int32(name='PageSize', minimum=1, maximum=100, position='Body'),
  topicStatuses?: string(name='TopicStatuses', position='Body'),
  topicTypes?: string(name='TopicTypes', position='Body'),
}

model ListTopicsResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    topics?: [ 
      {
        addTime?: long(name='AddTime'),
        fixTime?: long(name='FixTime'),
        happenTime?: long(name='HappenTime'),
        instanceId?: long(name='InstanceId'),
        nodeId?: long(name='NodeId'),
        nodeName?: string(name='NodeName'),
        nodeOwner?: string(name='NodeOwner'),
        projectId?: long(name='ProjectId'),
        topicId?: long(name='TopicId'),
        topicName?: string(name='TopicName'),
        topicStatus?: string(name='TopicStatus'),
        topicType?: string(name='TopicType'),
      }
    ](name='Topics'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListTopicsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTopicsResponseBody(name='body'),
}

async function listTopics(request: ListTopicsRequest): ListTopicsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTopics', 'POST', '/', 'json', true, 'form', request);
}

model OfflineNodeRequest {
  regionId: string(name='RegionId', position='Host'),
  nodeId: long(name='NodeId', minimum=2, position='Body'),
  projectId: long(name='ProjectId', minimum=1, position='Body'),
}

model OfflineNodeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: string(name='Success'),
}

model OfflineNodeResponse = {
  headers: map[string]string(name='headers'),
  body: OfflineNodeResponseBody(name='body'),
}

async function offlineNode(request: OfflineNodeRequest): OfflineNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OfflineNode', 'POST', '/', 'json', true, 'form', request);
}

model PublishDataServiceApiRequest {
  regionId: string(name='RegionId', position='Host'),
  apiId: long(name='ApiId', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
  tenantId: long(name='TenantId', position='Body'),
}

model PublishDataServiceApiResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PublishDataServiceApiResponse = {
  headers: map[string]string(name='headers'),
  body: PublishDataServiceApiResponseBody(name='body'),
}

async function publishDataServiceApi(request: PublishDataServiceApiRequest): PublishDataServiceApiResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PublishDataServiceApi', 'POST', '/', 'json', true, 'form', request);
}

model QueryDISyncTaskConfigProcessResultRequest {
  regionId: string(name='RegionId', position='Host'),
  asyncProcessId: long(name='AsyncProcessId', minimum=1, maximum=9999999999999999, position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  taskType: string(name='TaskType', position='Query'),
}

model QueryDISyncTaskConfigProcessResultResponseBody = {
  data?: {
    message?: string(name='Message'),
    status?: string(name='Status'),
    taskContent?: string(name='TaskContent'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDISyncTaskConfigProcessResultResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDISyncTaskConfigProcessResultResponseBody(name='body'),
}

async function queryDISyncTaskConfigProcessResult(request: QueryDISyncTaskConfigProcessResultRequest): QueryDISyncTaskConfigProcessResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDISyncTaskConfigProcessResult', 'POST', '/', 'json', false, 'json', request);
}

model QueryPublicModelEngineRequest {
  regionId?: string(name='RegionId', position='Host'),
  projectId: string(name='ProjectId', position='Body'),
  text: string(name='Text', position='Body'),
}

model QueryPublicModelEngineResponseBody = {
  requestId?: string(name='RequestId'),
  returnValue?: [  map[string]any ](name='ReturnValue'),
}

model QueryPublicModelEngineResponse = {
  headers: map[string]string(name='headers'),
  body: QueryPublicModelEngineResponseBody(name='body'),
}

async function queryPublicModelEngine(request: QueryPublicModelEngineRequest): QueryPublicModelEngineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryPublicModelEngine', 'POST', '/', 'json', true, 'form', request);
}

model RemoveProjectMemberFromRoleRequest {
  regionId: string(name='RegionId', position='Host'),
  projectId: long(name='ProjectId', minimum=0, maximum=10000000, position='Query'),
  roleCode: string(name='RoleCode', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model RemoveProjectMemberFromRoleResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveProjectMemberFromRoleResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveProjectMemberFromRoleResponseBody(name='body'),
}

async function removeProjectMemberFromRole(request: RemoveProjectMemberFromRoleRequest): RemoveProjectMemberFromRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveProjectMemberFromRole', 'POST', '/', 'json', false, 'json', request);
}

model RestartInstanceRequest {
  regionId: string(name='RegionId', position='Host'),
  instanceId: long(name='InstanceId', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model RestartInstanceResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RestartInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RestartInstanceResponseBody(name='body'),
}

async function restartInstance(request: RestartInstanceRequest): RestartInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestartInstance', 'POST', '/', 'json', true, 'form', request);
}

model ResumeInstanceRequest {
  regionId: string(name='RegionId', position='Host'),
  instanceId: long(name='InstanceId', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model ResumeInstanceResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ResumeInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ResumeInstanceResponseBody(name='body'),
}

async function resumeInstance(request: ResumeInstanceRequest): ResumeInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResumeInstance', 'POST', '/', 'json', true, 'form', request);
}

model RevokeColumnPermissionRequest {
  regionId: string(name='RegionId', position='Host'),
  columns: string(name='Columns', position='Query'),
  maxComputeProjectName: string(name='MaxComputeProjectName', position='Query'),
  revokeUserId?: string(name='RevokeUserId', position='Query'),
  revokeUserName?: string(name='RevokeUserName', position='Query'),
  tableName: string(name='TableName', position='Query'),
  workspaceId: long(name='WorkspaceId', minimum=1, maximum=9999999, position='Query'),
}

model RevokeColumnPermissionResponseBody = {
  requestId?: string(name='RequestId'),
  revokeSuccess?: boolean(name='RevokeSuccess'),
}

model RevokeColumnPermissionResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeColumnPermissionResponseBody(name='body'),
}

async function revokeColumnPermission(request: RevokeColumnPermissionRequest): RevokeColumnPermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokeColumnPermission', 'POST', '/', 'json', false, 'json', request);
}

model RevokeTablePermissionRequest {
  regionId: string(name='RegionId', position='Host'),
  actions: string(name='Actions', position='Query'),
  maxComputeProjectName: string(name='MaxComputeProjectName', position='Query'),
  revokeUserId?: string(name='RevokeUserId', position='Query'),
  revokeUserName?: string(name='RevokeUserName', position='Query'),
  tableName: string(name='TableName', position='Query'),
  workspaceId: long(name='WorkspaceId', minimum=1, maximum=9999999, position='Query'),
}

model RevokeTablePermissionResponseBody = {
  requestId?: string(name='RequestId'),
  revokeSuccess?: boolean(name='RevokeSuccess'),
}

model RevokeTablePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeTablePermissionResponseBody(name='body'),
}

async function revokeTablePermission(request: RevokeTablePermissionRequest): RevokeTablePermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokeTablePermission', 'POST', '/', 'json', false, 'json', request);
}

model RunCycleDagNodesRequest {
  regionId: string(name='RegionId', position='Host'),
  bizBeginTime?: string(name='BizBeginTime', position='Body'),
  bizEndTime?: string(name='BizEndTime', position='Body'),
  endBizDate: string(name='EndBizDate', position='Body'),
  excludeNodeIds?: string(name='ExcludeNodeIds', position='Body'),
  includeNodeIds: string(name='IncludeNodeIds', position='Body'),
  name: string(name='Name', maxLength=128, position='Body'),
  nodeParams?: string(name='NodeParams', position='Body'),
  parallelism: boolean(name='Parallelism', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
  rootNodeId: long(name='RootNodeId', position='Body'),
  startBizDate: string(name='StartBizDate', position='Body'),
  startFutureInstanceImmediately?: boolean(name='StartFutureInstanceImmediately', position='Body'),
}

model RunCycleDagNodesResponseBody = {
  data?: [ long ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RunCycleDagNodesResponse = {
  headers: map[string]string(name='headers'),
  body: RunCycleDagNodesResponseBody(name='body'),
}

async function runCycleDagNodes(request: RunCycleDagNodesRequest): RunCycleDagNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunCycleDagNodes', 'POST', '/', 'json', true, 'form', request);
}

model RunManualDagNodesRequest {
  regionId: string(name='RegionId', position='Host'),
  bizDate: string(name='BizDate', position='Body'),
  dagParameters?: string(name='DagParameters', position='Body'),
  excludeNodeIds?: string(name='ExcludeNodeIds', position='Body'),
  flowName: string(name='FlowName', position='Body'),
  includeNodeIds?: string(name='IncludeNodeIds', position='Body'),
  nodeParameters?: string(name='NodeParameters', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectName: string(name='ProjectName', position='Body'),
}

model RunManualDagNodesResponseBody = {
  dagId?: long(name='DagId'),
  requestId?: string(name='RequestId'),
}

model RunManualDagNodesResponse = {
  headers: map[string]string(name='headers'),
  body: RunManualDagNodesResponseBody(name='body'),
}

async function runManualDagNodes(request: RunManualDagNodesRequest): RunManualDagNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunManualDagNodes', 'POST', '/', 'json', true, 'form', request);
}

model RunSmokeTestRequest {
  regionId: string(name='RegionId', position='Host'),
  bizdate: string(name='Bizdate', position='Body'),
  name: string(name='Name', maxLength=128, position='Body'),
  nodeId: long(name='NodeId', position='Body'),
  nodeParams?: string(name='NodeParams', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model RunSmokeTestResponseBody = {
  data?: long(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RunSmokeTestResponse = {
  headers: map[string]string(name='headers'),
  body: RunSmokeTestResponseBody(name='body'),
}

async function runSmokeTest(request: RunSmokeTestRequest): RunSmokeTestResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunSmokeTest', 'POST', '/', 'json', true, 'form', request);
}

model RunTriggerNodeRequest {
  regionId: string(name='RegionId', position='Host'),
  appId: long(name='AppId', minimum=-9223372036854775808, maximum=9223372036854775807, position='Body'),
  bizDate: long(name='BizDate', minimum=-9223372036854775808, maximum=9223372036854775807, position='Body'),
  cycleTime: long(name='CycleTime', minimum=-9223372036854775808, maximum=9223372036854775807, position='Body'),
  nodeId: long(name='NodeId', minimum=-9223372036854775808, maximum=9223372036854775807, position='Body'),
}

model RunTriggerNodeResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RunTriggerNodeResponse = {
  headers: map[string]string(name='headers'),
  body: RunTriggerNodeResponseBody(name='body'),
}

async function runTriggerNode(request: RunTriggerNodeRequest): RunTriggerNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunTriggerNode', 'POST', '/', 'json', true, 'form', request);
}

model ScanSensitiveDataRequest {
  regionId: string(name='RegionId', position='Host'),
  data: string(name='Data', position='Query'),
}

model ScanSensitiveDataResponseBody = {
  requestId?: string(name='RequestId'),
  sensitives?: map[string]any(name='Sensitives'),
}

model ScanSensitiveDataResponse = {
  headers: map[string]string(name='headers'),
  body: ScanSensitiveDataResponseBody(name='body'),
}

async function scanSensitiveData(request: ScanSensitiveDataRequest): ScanSensitiveDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ScanSensitiveData', 'GET', '/', 'json', false, 'json', request);
}

model SearchMetaTablesRequest {
  regionId: string(name='RegionId', position='Host'),
  appGuid?: string(name='AppGuid', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  dataSourceType?: string(name='DataSourceType', position='Query'),
  entityType?: int32(name='EntityType', position='Query'),
  keyword: string(name='Keyword', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  schema?: string(name='Schema', position='Query'),
}

model SearchMetaTablesResponseBody = {
  data?: {
    dataEntityList?: [ 
      {
        clusterId?: string(name='ClusterId'),
        databaseName?: string(name='DatabaseName'),
        entityType?: int32(name='EntityType'),
        envType?: int32(name='EnvType'),
        ownerId?: string(name='OwnerId'),
        projectId?: long(name='ProjectId'),
        projectName?: string(name='ProjectName'),
        schema?: string(name='Schema'),
        tableGuid?: string(name='TableGuid'),
        tableName?: string(name='TableName'),
        tenantId?: long(name='TenantId'),
      }
    ](name='DataEntityList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SearchMetaTablesResponse = {
  headers: map[string]string(name='headers'),
  body: SearchMetaTablesResponseBody(name='body'),
}

async function searchMetaTables(request: SearchMetaTablesRequest): SearchMetaTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchMetaTables', 'POST', '/', 'json', false, 'json', request);
}

model SearchNodesByOutputRequest {
  regionId: string(name='RegionId', position='Host'),
  outputs: string(name='Outputs', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model SearchNodesByOutputResponseBody = {
  data?: map[string]any(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SearchNodesByOutputResponse = {
  headers: map[string]string(name='headers'),
  body: SearchNodesByOutputResponseBody(name='body'),
}

async function searchNodesByOutput(request: SearchNodesByOutputRequest): SearchNodesByOutputResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchNodesByOutput', 'POST', '/', 'json', true, 'form', request);
}

model SetDataSourceShareRequest {
  regionId: string(name='RegionId', position='Host'),
  datasourceName: string(name='DatasourceName', position='Query'),
  envType?: string(name='EnvType', position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  projectPermissions?: string(name='ProjectPermissions', position='Query'),
  userPermissions?: string(name='UserPermissions', position='Query'),
}

model SetDataSourceShareResponseBody = {
  data?: {
    message?: string(name='Message'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetDataSourceShareResponse = {
  headers: map[string]string(name='headers'),
  body: SetDataSourceShareResponseBody(name='body'),
}

async function setDataSourceShare(request: SetDataSourceShareRequest): SetDataSourceShareResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDataSourceShare', 'POST', '/', 'json', false, 'json', request);
}

model SetSuccessInstanceRequest {
  regionId: string(name='RegionId', position='Host'),
  instanceId: long(name='InstanceId', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model SetSuccessInstanceResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetSuccessInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: SetSuccessInstanceResponseBody(name='body'),
}

async function setSuccessInstance(request: SetSuccessInstanceRequest): SetSuccessInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetSuccessInstance', 'POST', '/', 'json', true, 'form', request);
}

model StartDISyncInstanceRequest {
  regionId: string(name='RegionId', position='Host'),
  fileId: long(name='FileId', minimum=1, maximum=9999999999999999, position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  startParam?: string(name='StartParam', position='Query'),
  taskType: string(name='TaskType', position='Query'),
}

model StartDISyncInstanceResponseBody = {
  data?: {
    message?: string(name='Message'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StartDISyncInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StartDISyncInstanceResponseBody(name='body'),
}

async function startDISyncInstance(request: StartDISyncInstanceRequest): StartDISyncInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartDISyncInstance', 'POST', '/', 'json', false, 'json', request);
}

model StartMigrationRequest {
  regionId: string(name='RegionId', position='Host'),
  migrationId: long(name='MigrationId', minimum=2, position='Body'),
  projectId: long(name='ProjectId', minimum=2, position='Body'),
}

model StartMigrationResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StartMigrationResponse = {
  headers: map[string]string(name='headers'),
  body: StartMigrationResponseBody(name='body'),
}

async function startMigration(request: StartMigrationRequest): StartMigrationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartMigration', 'POST', '/', 'json', true, 'form', request);
}

model StopDISyncInstanceRequest {
  regionId: string(name='RegionId', position='Host'),
  fileId: long(name='FileId', minimum=1, maximum=9999999999999999, position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  taskType: string(name='TaskType', position='Query'),
}

model StopDISyncInstanceResponseBody = {
  data?: {
    message?: string(name='Message'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StopDISyncInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopDISyncInstanceResponseBody(name='body'),
}

async function stopDISyncInstance(request: StopDISyncInstanceRequest): StopDISyncInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopDISyncInstance', 'POST', '/', 'json', false, 'json', request);
}

model StopInstanceRequest {
  regionId: string(name='RegionId', position='Host'),
  instanceId: long(name='InstanceId', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model StopInstanceResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StopInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopInstanceResponseBody(name='body'),
}

async function stopInstance(request: StopInstanceRequest): StopInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopInstance', 'POST', '/', 'json', true, 'form', request);
}

model SubmitFileRequest {
  regionId: string(name='RegionId', position='Host'),
  comment?: string(name='Comment', position='Body'),
  fileId: long(name='FileId', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
  skipAllDeployFileExtensions?: boolean(name='SkipAllDeployFileExtensions', position='Body'),
}

model SubmitFileResponseBody = {
  data?: long(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubmitFileResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFileResponseBody(name='body'),
}

async function submitFile(request: SubmitFileRequest): SubmitFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitFile', 'POST', '/', 'json', true, 'form', request);
}

model SuspendInstanceRequest {
  regionId: string(name='RegionId', position='Host'),
  instanceId: long(name='InstanceId', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
}

model SuspendInstanceResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SuspendInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: SuspendInstanceResponseBody(name='body'),
}

async function suspendInstance(request: SuspendInstanceRequest): SuspendInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SuspendInstance', 'POST', '/', 'json', true, 'form', request);
}

model TerminateDISyncInstanceRequest {
  regionId: string(name='RegionId', position='Host'),
  fileId: long(name='FileId', minimum=1, maximum=9999999999999999, position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  taskType: string(name='TaskType', position='Query'),
}

model TerminateDISyncInstanceResponseBody = {
  data?: {
    message?: string(name='Message'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model TerminateDISyncInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: TerminateDISyncInstanceResponseBody(name='body'),
}

async function terminateDISyncInstance(request: TerminateDISyncInstanceRequest): TerminateDISyncInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TerminateDISyncInstance', 'POST', '/', 'json', false, 'json', request);
}

model TestDataServiceApiRequest {
  regionId: string(name='RegionId', position='Host'),
  apiId: long(name='ApiId', position='Query'),
  bodyContent?: string(name='BodyContent', position='Body'),
  bodyParams?: [ 
    {
      paramKey?: string(name='ParamKey'),
      paramValue?: string(name='ParamValue'),
    }
  ](name='BodyParams', position='Body'),
  headParams?: [ 
    {
      paramKey?: string(name='ParamKey'),
      paramValue?: string(name='ParamValue'),
    }
  ](name='HeadParams', position='Body'),
  pathParams?: [ 
    {
      paramKey?: string(name='ParamKey'),
      paramValue?: string(name='ParamValue'),
    }
  ](name='PathParams', position='Body'),
  queryParam?: [ 
    {
      paramKey?: string(name='ParamKey'),
      paramValue?: string(name='ParamValue'),
    }
  ](name='QueryParam', position='Body'),
}

model TestDataServiceApiResponseBody = {
  data?: {
    testId?: string(name='TestId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model TestDataServiceApiResponse = {
  headers: map[string]string(name='headers'),
  body: TestDataServiceApiResponseBody(name='body'),
}

async function testDataServiceApi(request: TestDataServiceApiRequest): TestDataServiceApiResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TestDataServiceApi', 'POST', '/', 'json', true, 'form', request);
}

model TestNetworkConnectionRequest {
  regionId: string(name='RegionId', position='Host'),
  datasourceName: string(name='DatasourceName', position='Query'),
  envType: string(name='EnvType', position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  resourceGroup: string(name='ResourceGroup', position='Query'),
}

model TestNetworkConnectionResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskList?: {
    connectMessage?: string(name='ConnectMessage'),
    connectStatus?: boolean(name='ConnectStatus'),
  }(name='TaskList'),
}

model TestNetworkConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: TestNetworkConnectionResponseBody(name='body'),
}

async function testNetworkConnection(request: TestNetworkConnectionRequest): TestNetworkConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TestNetworkConnection', 'POST', '/', 'json', false, 'json', request);
}

model TopTenElapsedTimeInstanceRequest {
  regionId: string(name='RegionId', position='Host'),
  projectId: long(name='ProjectId', minimum=2, maximum=99999999999, position='Body'),
}

model TopTenElapsedTimeInstanceResponseBody = {
  instanceConsumeTimeRank?: {
    consumeTimeRank?: [ 
      {
        businessDate?: long(name='BusinessDate'),
        consumed?: long(name='Consumed'),
        instanceId?: long(name='InstanceId'),
        nodeId?: long(name='NodeId'),
        nodeName?: string(name='NodeName'),
        owner?: string(name='Owner'),
        programType?: int32(name='ProgramType'),
      }
    ](name='ConsumeTimeRank'),
    updateTime?: long(name='UpdateTime'),
  }(name='InstanceConsumeTimeRank'),
  requestId?: string(name='RequestId'),
}

model TopTenElapsedTimeInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: TopTenElapsedTimeInstanceResponseBody(name='body'),
}

async function topTenElapsedTimeInstance(request: TopTenElapsedTimeInstanceRequest): TopTenElapsedTimeInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TopTenElapsedTimeInstance', 'POST', '/', 'json', true, 'form', request);
}

model TopTenErrorTimesInstanceRequest {
  regionId: string(name='RegionId', position='Host'),
  projectId: long(name='ProjectId', minimum=2, maximum=99999999999, position='Body'),
}

model TopTenErrorTimesInstanceResponseBody = {
  instanceErrorRank?: {
    errorRank?: [ 
      {
        count?: int32(name='Count'),
        nodeId?: long(name='NodeId'),
        nodeName?: string(name='NodeName'),
        owner?: string(name='Owner'),
        programType?: int32(name='ProgramType'),
        projectId?: long(name='ProjectId'),
      }
    ](name='ErrorRank'),
    updateTime?: long(name='UpdateTime'),
  }(name='InstanceErrorRank'),
  requestId?: string(name='RequestId'),
}

model TopTenErrorTimesInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: TopTenErrorTimesInstanceResponseBody(name='body'),
}

async function topTenErrorTimesInstance(request: TopTenErrorTimesInstanceRequest): TopTenErrorTimesInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TopTenErrorTimesInstance', 'POST', '/', 'json', true, 'form', request);
}

model UpdateBaselineRequest {
  regionId?: string(name='RegionId', position='Host'),
  alertEnabled?: boolean(name='AlertEnabled', description='是否开启告警', position='Body'),
  alertMarginThreshold?: int32(name='AlertMarginThreshold', description='基线预警余量', position='Body'),
  alertSettings?: [ 
    {
      alertInterval: int32(name='AlertInterval', description='事件告警间隔'),
      alertMaximum: int32(name='AlertMaximum', description='事件告警最大次数'),
      alertMethods?: [ string ](name='AlertMethods', description='告警方式'),
      alertRecipient?: string(name='AlertRecipient', description='告警接收人详情'),
      alertRecipientType?: string(name='AlertRecipientType', description='告警接收人类型'),
      alertType?: string(name='AlertType', description='告警类型，BASELINE / TOPIC'),
      baselineAlertEnabled?: boolean(name='BaselineAlertEnabled', description='基线告警开关，基线特有配置'),
      dingRobots?: [ 
        {
          atAll?: boolean(name='AtAll'),
          webUrl?: string(name='WebUrl'),
        }
      ](name='DingRobots', description='钉钉机器人列表'),
      silenceEndTime?: string(name='SilenceEndTime', description='静默结束时间'),
      silenceStartTime?: string(name='SilenceStartTime', description='静默开始时间'),
      topicTypes?: [ string ](name='TopicTypes', description='事件告警类型，事件特有配置'),
      webhooks?: [ string ](name='Webhooks', description='webhook 列表'),
    }
  ](name='AlertSettings', description='告警配置', shrink='json', position='Body'),
  baselineId: long(name='BaselineId', position='Body'),
  baselineName?: string(name='BaselineName', description='基线名', position='Body'),
  baselineType?: string(name='BaselineType', description='基线类型 (DAILY, HOURLY)', position='Body'),
  enabled?: boolean(name='Enabled', description='是否开启基线', position='Body'),
  overtimeSettings?: [ 
    {
      cycle?: int32(name='Cycle', description='周期，取值范围 [1,24]'),
      time?: string(name='Time', description='承诺时间，hh:mm格式，hh的取值范围为[0,47]，mm的取值范围为[0,59]'),
    }
  ](name='OvertimeSettings', description='基线承诺时间', shrink='json', position='Body'),
  owner?: string(name='Owner', description='责任人', position='Body'),
  priority?: int32(name='Priority', description='基线优先级', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
  removeTaskIds?: string(name='RemoveTaskIds', position='Body'),
  taskIds?: string(name='TaskIds', position='Body'),
}

model UpdateBaselineResponseBody = {
  data?: boolean(name='Data'),
  dynamicErrorCode?: string(name='DynamicErrorCode'),
  dynamicErrorMessage?: string(name='DynamicErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateBaselineResponseBody(name='body'),
}

async function updateBaseline(request: UpdateBaselineRequest): UpdateBaselineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateBaseline', 'POST', '/', 'json', true, 'form', request);
}

model UpdateBusinessRequest {
  regionId: string(name='RegionId', position='Host'),
  businessId: long(name='BusinessId', position='Body'),
  businessName?: string(name='BusinessName', position='Body'),
  description?: string(name='Description', position='Body'),
  owner?: string(name='Owner', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
}

model UpdateBusinessResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateBusinessResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateBusinessResponseBody(name='body'),
}

async function updateBusiness(request: UpdateBusinessRequest): UpdateBusinessResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateBusiness', 'POST', '/', 'json', true, 'form', request);
}

model UpdateConnectionRequest {
  regionId: string(name='RegionId', position='Host'),
  connectionId: long(name='ConnectionId', position='Query'),
  content?: string(name='Content', position='Query'),
  description?: string(name='Description', position='Query'),
  envType?: int32(name='EnvType', position='Query'),
  status?: string(name='Status', position='Query'),
}

model UpdateConnectionResponseBody = {
  data?: boolean(name='Data'),
  httpStatusCode?: string(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateConnectionResponseBody(name='body'),
}

async function updateConnection(request: UpdateConnectionRequest): UpdateConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateConnection', 'PUT', '/', 'json', false, 'json', request);
}

model UpdateDIProjectConfigRequest {
  regionId: string(name='RegionId', position='Host'),
  destinationType: string(name='DestinationType', position='Query'),
  projectConfig: string(name='ProjectConfig', position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
}

model UpdateDIProjectConfigResponseBody = {
  data?: {
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDIProjectConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDIProjectConfigResponseBody(name='body'),
}

async function updateDIProjectConfig(request: UpdateDIProjectConfigRequest): UpdateDIProjectConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDIProjectConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDISyncTaskRequest {
  regionId: string(name='RegionId', position='Host'),
  fileId: long(name='FileId', minimum=1, maximum=9999999999999999, position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=10000000000, position='Query'),
  taskContent?: string(name='TaskContent', position='Query'),
  taskParam?: string(name='TaskParam', position='Query'),
  taskType: string(name='TaskType', position='Query'),
}

model UpdateDISyncTaskResponseBody = {
  data?: {
    message?: string(name='Message'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDISyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDISyncTaskResponseBody(name='body'),
}

async function updateDISyncTask(request: UpdateDISyncTaskRequest): UpdateDISyncTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDISyncTask', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDataServiceApiRequest {
  regionId: string(name='RegionId', position='Host'),
  apiDescription: string(name='ApiDescription', position='Body'),
  apiId: long(name='ApiId', position='Body'),
  apiPath: string(name='ApiPath', position='Body'),
  projectId: long(name='ProjectId', position='Body'),
  protocols: string(name='Protocols', position='Body'),
  registrationDetails?: string(name='RegistrationDetails', position='Body'),
  requestMethod: int32(name='RequestMethod', position='Body'),
  responseContentType: int32(name='ResponseContentType', position='Body'),
  scriptDetails?: string(name='ScriptDetails', position='Body'),
  tenantId: long(name='TenantId', position='Body'),
  timeout: int32(name='Timeout', position='Body'),
  visibleRange: int32(name='VisibleRange', position='Body'),
  wizardDetails?: string(name='WizardDetails', position='Body'),
}

model UpdateDataServiceApiResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDataServiceApiResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDataServiceApiResponseBody(name='body'),
}

async function updateDataServiceApi(request: UpdateDataServiceApiRequest): UpdateDataServiceApiResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDataServiceApi', 'POST', '/', 'json', true, 'form', request);
}

model UpdateDataSourceRequest {
  regionId: string(name='RegionId', position='Host'),
  content?: string(name='Content', position='Query'),
  dataSourceId: long(name='DataSourceId', position='Query'),
  description?: string(name='Description', position='Query'),
  envType?: int32(name='EnvType', position='Query'),
  status?: string(name='Status', position='Query'),
}

model UpdateDataSourceResponseBody = {
  data?: boolean(name='Data'),
  httpStatusCode?: string(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDataSourceResponseBody(name='body'),
}

async function updateDataSource(request: UpdateDataSourceRequest): UpdateDataSourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDataSource', 'PUT', '/', 'json', false, 'json', request);
}

model UpdateFileRequest {
  regionId: string(name='RegionId', position='Host'),
  advancedSettings?: string(name='AdvancedSettings', position='Body'),
  autoParsing?: boolean(name='AutoParsing', position='Body'),
  autoRerunIntervalMillis?: int32(name='AutoRerunIntervalMillis', position='Body'),
  autoRerunTimes?: int32(name='AutoRerunTimes', position='Body'),
  connectionName?: string(name='ConnectionName', position='Body'),
  content?: string(name='Content', position='Body'),
  cronExpress?: string(name='CronExpress', position='Body'),
  cycleType?: string(name='CycleType', position='Body'),
  dependentNodeIdList?: string(name='DependentNodeIdList', position='Body'),
  dependentType?: string(name='DependentType', position='Body'),
  endEffectDate?: long(name='EndEffectDate', minimum=0, position='Body'),
  fileDescription?: string(name='FileDescription', position='Body'),
  fileFolderPath?: string(name='FileFolderPath', position='Body'),
  fileId: long(name='FileId', position='Body'),
  fileName?: string(name='FileName', position='Body'),
  inputList?: string(name='InputList', position='Body'),
  inputParameters?: string(name='InputParameters', position='Body'),
  outputList?: string(name='OutputList', position='Body'),
  outputParameters?: string(name='OutputParameters', position='Body'),
  owner?: string(name='Owner', position='Body'),
  paraValue?: string(name='ParaValue', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
  rerunMode?: string(name='RerunMode', position='Body'),
  resourceGroupIdentifier?: string(name='ResourceGroupIdentifier', position='Body'),
  schedulerType?: string(name='SchedulerType', position='Body'),
  startEffectDate?: long(name='StartEffectDate', minimum=0, position='Body'),
  startImmediately?: boolean(name='StartImmediately', position='Body'),
  stop?: boolean(name='Stop', position='Body'),
}

model UpdateFileResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateFileResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFileResponseBody(name='body'),
}

async function updateFile(request: UpdateFileRequest): UpdateFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateFile', 'POST', '/', 'json', true, 'form', request);
}

model UpdateFolderRequest {
  regionId: string(name='RegionId', position='Host'),
  folderId: string(name='FolderId', position='Body'),
  folderName: string(name='FolderName', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
}

model UpdateFolderResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateFolderResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFolderResponseBody(name='body'),
}

async function updateFolder(request: UpdateFolderRequest): UpdateFolderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateFolder', 'POST', '/', 'json', true, 'form', request);
}

model UpdateIDEEventResultRequest {
  regionId?: string(name='RegionId', position='Host'),
  checkResult?: string(name='CheckResult', position='Body'),
  checkResultTip?: string(name='CheckResultTip', position='Body'),
  extensionCode?: string(name='ExtensionCode', position='Body'),
  messageId?: string(name='MessageId', description='扩展点消息UUID', position='Body'),
}

model UpdateIDEEventResultResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateIDEEventResultResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIDEEventResultResponseBody(name='body'),
}

async function updateIDEEventResult(request: UpdateIDEEventResultRequest): UpdateIDEEventResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateIDEEventResult', 'POST', '/', 'json', true, 'form', request);
}

model UpdateMetaCategoryRequest {
  regionId: string(name='RegionId', position='Host'),
  categoryId: long(name='CategoryId', position='Body'),
  comment?: string(name='Comment', position='Body'),
  name?: string(name='Name', position='Body'),
}

model UpdateMetaCategoryResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateMetaCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMetaCategoryResponseBody(name='body'),
}

async function updateMetaCategory(request: UpdateMetaCategoryRequest): UpdateMetaCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMetaCategory', 'POST', '/', 'json', true, 'form', request);
}

model UpdateMetaTableRequest {
  regionId: string(name='RegionId', position='Host'),
  addedLabels?: string(name='AddedLabels', position='Body'),
  caption?: string(name='Caption', position='Query'),
  categoryId?: long(name='CategoryId', minimum=0, maximum=9223372036854775807, position='Query'),
  envType?: int32(name='EnvType', position='Query'),
  newOwnerId?: string(name='NewOwnerId', position='Query'),
  projectId?: long(name='ProjectId', minimum=0, maximum=9223372036854775807, position='Query'),
  removedLabels?: string(name='RemovedLabels', position='Body'),
  schema?: string(name='Schema', position='Query'),
  tableGuid?: string(name='TableGuid', position='Query'),
  tableName?: string(name='TableName', position='Query'),
  visibility?: int32(name='Visibility', minimum=0, maximum=100, position='Query'),
}

model UpdateMetaTableResponseBody = {
  requestId?: string(name='RequestId'),
  updateResult?: boolean(name='UpdateResult'),
}

model UpdateMetaTableResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMetaTableResponseBody(name='body'),
}

async function updateMetaTable(request: UpdateMetaTableRequest): UpdateMetaTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMetaTable', 'POST', '/', 'json', true, 'form', request);
}

model UpdateMetaTableIntroWikiRequest {
  regionId: string(name='RegionId', position='Host'),
  content: string(name='Content', position='Body'),
  tableGuid: string(name='TableGuid', position='Query'),
}

model UpdateMetaTableIntroWikiResponseBody = {
  requestId?: string(name='RequestId'),
  updateResult?: boolean(name='UpdateResult'),
}

model UpdateMetaTableIntroWikiResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMetaTableIntroWikiResponseBody(name='body'),
}

async function updateMetaTableIntroWiki(request: UpdateMetaTableIntroWikiRequest): UpdateMetaTableIntroWikiResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMetaTableIntroWiki', 'POST', '/', 'json', true, 'form', request);
}

model UpdateNodeOwnerRequest {
  regionId: string(name='RegionId', position='Host'),
  nodeId: long(name='NodeId', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
  userId: string(name='UserId', maxLength=64, position='Body'),
}

model UpdateNodeOwnerResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateNodeOwnerResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNodeOwnerResponseBody(name='body'),
}

async function updateNodeOwner(request: UpdateNodeOwnerRequest): UpdateNodeOwnerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateNodeOwner', 'POST', '/', 'json', true, 'form', request);
}

model UpdateNodeRunModeRequest {
  regionId: string(name='RegionId', position='Host'),
  nodeId: long(name='NodeId', position='Body'),
  projectEnv: string(name='ProjectEnv', position='Body'),
  schedulerType: int32(name='SchedulerType', position='Body'),
}

model UpdateNodeRunModeResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateNodeRunModeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNodeRunModeResponseBody(name='body'),
}

async function updateNodeRunMode(request: UpdateNodeRunModeRequest): UpdateNodeRunModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateNodeRunMode', 'POST', '/', 'json', true, 'form', request);
}

model UpdateQualityFollowerRequest {
  regionId: string(name='RegionId', position='Host'),
  alarmMode: int32(name='AlarmMode', minimum=0, maximum=99, position='Body'),
  follower: string(name='Follower', position='Body'),
  followerId: long(name='FollowerId', position='Body'),
  projectName: string(name='ProjectName', position='Body'),
}

model UpdateQualityFollowerResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateQualityFollowerResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateQualityFollowerResponseBody(name='body'),
}

async function updateQualityFollower(request: UpdateQualityFollowerRequest): UpdateQualityFollowerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateQualityFollower', 'POST', '/', 'json', true, 'form', request);
}

model UpdateQualityRuleRequest {
  regionId?: string(name='RegionId', position='Host'),
  blockType?: int32(name='BlockType', minimum=0, maximum=1, position='Body'),
  checker: int32(name='Checker', position='Body'),
  comment?: string(name='Comment', maxLength=512, position='Body'),
  criticalThreshold?: string(name='CriticalThreshold', position='Body'),
  entityId?: long(name='EntityId', position='Body'),
  expectValue?: string(name='ExpectValue', maxLength=128, position='Body'),
  id: long(name='Id', position='Body'),
  methodName: string(name='MethodName', position='Body'),
  openSwitch?: boolean(name='OpenSwitch', position='Body'),
  operator?: string(name='Operator', maxLength=128, position='Body'),
  predictType?: int32(name='PredictType', minimum=0, maximum=99, position='Body'),
  projectName: string(name='ProjectName', position='Body'),
  property: string(name='Property', minLength=1, maxLength=128, position='Body'),
  propertyType?: string(name='PropertyType', maxLength=128, position='Body'),
  ruleName?: string(name='RuleName', minLength=1, maxLength=255, position='Body'),
  ruleType?: int32(name='RuleType', minimum=0, maximum=99, position='Body'),
  templateId?: int32(name='TemplateId', position='Body'),
  trend?: string(name='Trend', position='Body'),
  warningThreshold?: string(name='WarningThreshold', position='Body'),
  whereCondition?: string(name='WhereCondition', position='Body'),
}

model UpdateQualityRuleResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateQualityRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateQualityRuleResponseBody(name='body'),
}

async function updateQualityRule(request: UpdateQualityRuleRequest): UpdateQualityRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateQualityRule', 'POST', '/', 'json', true, 'form', request);
}

model UpdateRemindRequest {
  regionId: string(name='RegionId', position='Host'),
  alertInterval?: int32(name='AlertInterval', minimum=1200, maximum=1800, position='Body'),
  alertMethods?: string(name='AlertMethods', position='Body'),
  alertTargets?: string(name='AlertTargets', position='Body'),
  alertUnit?: string(name='AlertUnit', position='Body'),
  baselineIds?: string(name='BaselineIds', position='Body'),
  bizProcessIds?: string(name='BizProcessIds', position='Body'),
  detail?: string(name='Detail', position='Body'),
  dndEnd?: string(name='DndEnd', position='Body'),
  maxAlertTimes?: int32(name='MaxAlertTimes', minimum=1, maximum=10, position='Body'),
  nodeIds?: string(name='NodeIds', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  remindId: long(name='RemindId', position='Body'),
  remindName?: string(name='RemindName', position='Body'),
  remindType?: string(name='RemindType', position='Body'),
  remindUnit?: string(name='RemindUnit', position='Body'),
  robotUrls?: string(name='RobotUrls', position='Body'),
  useFlag?: boolean(name='UseFlag', position='Body'),
  webhooks?: string(name='Webhooks', position='Body'),
}

model UpdateRemindResponseBody = {
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateRemindResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRemindResponseBody(name='body'),
}

async function updateRemind(request: UpdateRemindRequest): UpdateRemindResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateRemind', 'POST', '/', 'json', true, 'form', request);
}

model UpdateTableRequest {
  regionId: string(name='RegionId', position='Host'),
  appGuid?: string(name='AppGuid', position='Query'),
  categoryId?: long(name='CategoryId', minimum=1, maximum=9223372036854775807, position='Query'),
  columns?: [ 
    {
      columnName: string(name='ColumnName'),
      columnNameCn?: string(name='ColumnNameCn'),
      columnType: string(name='ColumnType'),
      comment?: string(name='Comment'),
      isPartitionCol?: boolean(name='IsPartitionCol'),
      length?: int32(name='Length'),
      seqNumber?: int32(name='SeqNumber'),
    }
  ](name='Columns', position='Body'),
  comment?: string(name='Comment', position='Query'),
  createIfNotExists?: boolean(name='CreateIfNotExists', position='Query'),
  endpoint?: string(name='Endpoint', position='Body'),
  envType?: int32(name='EnvType', position='Body'),
  externalTableType?: string(name='ExternalTableType', position='Query'),
  hasPart?: int32(name='HasPart', position='Query'),
  isView?: int32(name='IsView', position='Query'),
  lifeCycle?: int32(name='LifeCycle', position='Query'),
  location?: string(name='Location', position='Query'),
  logicalLevelId?: long(name='LogicalLevelId', minimum=1, maximum=9223372036854775807, position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  physicsLevelId?: long(name='PhysicsLevelId', minimum=1, maximum=9223372036854775807, position='Query'),
  projectId?: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Query'),
  schema?: string(name='Schema', position='Query'),
  tableName: string(name='TableName', position='Query'),
  themes?: [ 
    {
      themeId?: long(name='ThemeId', minimum=1, maximum=9223372036854775807),
      themeLevel?: int32(name='ThemeLevel'),
    }
  ](name='Themes', position='Body'),
  visibility?: int32(name='Visibility', position='Query'),
}

model UpdateTableResponseBody = {
  requestId?: string(name='RequestId'),
  taskInfo?: {
    content?: string(name='Content'),
    nextTaskId?: string(name='NextTaskId'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
  }(name='TaskInfo'),
}

model UpdateTableResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTableResponseBody(name='body'),
}

async function updateTable(request: UpdateTableRequest): UpdateTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateTable', 'POST', '/', 'json', true, 'form', request);
}

model UpdateTableAddColumnRequest {
  regionId: string(name='RegionId', position='Host'),
  column: [ 
    {
      columnName: string(name='ColumnName'),
      columnNameCn?: string(name='ColumnNameCn'),
      columnType: string(name='ColumnType'),
      comment?: string(name='Comment'),
    }
  ](name='Column', position='Body'),
  tableGuid: string(name='TableGuid', position='Query'),
}

model UpdateTableAddColumnResponseBody = {
  requestId?: string(name='RequestId'),
  taskInfo?: {
    content?: string(name='Content'),
    nextTaskId?: string(name='NextTaskId'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
  }(name='TaskInfo'),
}

model UpdateTableAddColumnResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTableAddColumnResponseBody(name='body'),
}

async function updateTableAddColumn(request: UpdateTableAddColumnRequest): UpdateTableAddColumnResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateTableAddColumn', 'POST', '/', 'json', true, 'form', request);
}

model UpdateTableLevelRequest {
  regionId: string(name='RegionId', position='Host'),
  description?: string(name='Description', position='Query'),
  levelId: long(name='LevelId', minimum=1, maximum=9223372036854775807, position='Query'),
  levelType?: int32(name='LevelType', minimum=0, maximum=10, position='Query'),
  name?: string(name='Name', position='Query'),
  projectId: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Query'),
}

model UpdateTableLevelResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  updateResult?: boolean(name='UpdateResult'),
}

model UpdateTableLevelResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTableLevelResponseBody(name='body'),
}

async function updateTableLevel(request: UpdateTableLevelRequest): UpdateTableLevelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateTableLevel', 'POST', '/', 'json', false, 'json', request);
}

model UpdateTableModelInfoRequest {
  regionId: string(name='RegionId', position='Host'),
  firstLevelThemeId?: long(name='FirstLevelThemeId', minimum=0, maximum=9223372036854775807, position='Query'),
  levelId?: long(name='LevelId', minimum=0, maximum=9223372036854775807, position='Query'),
  levelType?: int32(name='LevelType', minimum=0, maximum=2147483647, position='Query'),
  secondLevelThemeId?: long(name='SecondLevelThemeId', minimum=0, maximum=9223372036854775807, position='Query'),
  tableGuid: string(name='TableGuid', position='Query'),
}

model UpdateTableModelInfoResponseBody = {
  requestId?: string(name='RequestId'),
  updateResult?: boolean(name='UpdateResult'),
}

model UpdateTableModelInfoResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTableModelInfoResponseBody(name='body'),
}

async function updateTableModelInfo(request: UpdateTableModelInfoRequest): UpdateTableModelInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateTableModelInfo', 'POST', '/', 'json', false, 'json', request);
}

model UpdateTableThemeRequest {
  regionId: string(name='RegionId', position='Host'),
  name: string(name='Name', position='Query'),
  projectId?: long(name='ProjectId', minimum=1, maximum=9223372036854775807, position='Query'),
  themeId: long(name='ThemeId', minimum=1, maximum=9223372036854775807, position='Query'),
}

model UpdateTableThemeResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  updateResult?: boolean(name='UpdateResult'),
}

model UpdateTableThemeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTableThemeResponseBody(name='body'),
}

async function updateTableTheme(request: UpdateTableThemeRequest): UpdateTableThemeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateTableTheme', 'POST', '/', 'json', false, 'json', request);
}

model UpdateUdfFileRequest {
  regionId: string(name='RegionId', position='Host'),
  className: string(name='ClassName', position='Body'),
  cmdDescription?: string(name='CmdDescription', position='Body'),
  example?: string(name='Example', position='Body'),
  fileFolderPath?: string(name='FileFolderPath', position='Body'),
  fileId: string(name='FileId', position='Body'),
  functionType: string(name='FunctionType', position='Body'),
  parameterDescription?: string(name='ParameterDescription', position='Body'),
  projectId?: long(name='ProjectId', position='Body'),
  projectIdentifier?: string(name='ProjectIdentifier', position='Body'),
  resources: string(name='Resources', position='Body'),
  returnValue?: string(name='ReturnValue', position='Body'),
  udfDescription?: string(name='UdfDescription', position='Body'),
}

model UpdateUdfFileResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateUdfFileResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUdfFileResponseBody(name='body'),
}

async function updateUdfFile(request: UpdateUdfFileRequest): UpdateUdfFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateUdfFile', 'POST', '/', 'json', true, 'form', request);
}

model UpdateWorkbenchEventResultRequest {
  regionId: string(name='RegionId', position='Host'),
  checkResult: string(name='CheckResult', position='Query'),
  checkResultTip?: string(name='CheckResultTip', position='Query'),
  extensionCode: string(name='ExtensionCode', position='Query'),
  messageId: string(name='MessageId', position='Query'),
}

model UpdateWorkbenchEventResultResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success', description='成功标识'),
}

model UpdateWorkbenchEventResultResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWorkbenchEventResultResponseBody(name='body'),
}

async function updateWorkbenchEventResult(request: UpdateWorkbenchEventResultRequest): UpdateWorkbenchEventResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateWorkbenchEventResult', 'POST', '/', 'json', false, 'json', request);
}

