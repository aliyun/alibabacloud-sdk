/**
 *
 */
import Util;
import OSS;
import RPC;
import OpenPlatform;
import OSSUtil;
import FileForm;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
@endpointMap = {
    ap-northeast-1 = 'dataworks.ap-northeast-1.aliyuncs.com',
    ap-south-1 = 'dataworks.ap-south-1.aliyuncs.com',
    ap-southeast-1 = 'dataworks.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'dataworks.ap-southeast-2.aliyuncs.com',
    ap-southeast-3 = 'dataworks.ap-southeast-3.aliyuncs.com',
    ap-southeast-5 = 'dataworks.ap-southeast-5.aliyuncs.com',
    cn-beijing = 'dataworks.cn-beijing.aliyuncs.com',
    cn-chengdu = 'dataworks.cn-chengdu.aliyuncs.com',
    cn-hangzhou = 'dataworks.cn-hangzhou.aliyuncs.com',
    cn-hongkong = 'dataworks.cn-hongkong.aliyuncs.com',
    cn-huhehaote = 'dataworks.aliyuncs.com',
    cn-qingdao = 'dataworks.aliyuncs.com',
    cn-shanghai = 'dataworks.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'dataworks.cn-shenzhen.aliyuncs.com',
    cn-zhangjiakou = 'dataworks.aliyuncs.com',
    eu-central-1 = 'dataworks.eu-central-1.aliyuncs.com',
    eu-west-1 = 'dataworks.eu-west-1.aliyuncs.com',
    me-east-1 = 'dataworks.me-east-1.aliyuncs.com',
    us-east-1 = 'dataworks.us-east-1.aliyuncs.com',
    us-west-1 = 'dataworks.us-west-1.aliyuncs.com',
    cn-hangzhou-finance = 'dataworks.aliyuncs.com',
    cn-shenzhen-finance-1 = 'dataworks.aliyuncs.com',
    cn-shanghai-finance-1 = 'dataworks.aliyuncs.com',
    cn-north-2-gov-1 = 'dataworks.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('dataworks-public', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AbolishDataServiceApiRequest {
  tenantId?: long(name='TenantId'),
  projectId?: long(name='ProjectId'),
  apiId?: long(name='ApiId'),
}

model AbolishDataServiceApiResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model AbolishDataServiceApiResponse = {
  headers: map[string]string(name='headers'),
  body: AbolishDataServiceApiResponseBody(name='body'),
}

async function abolishDataServiceApiWithOptions(request: AbolishDataServiceApiRequest, runtime: Util.RuntimeOptions): AbolishDataServiceApiResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AbolishDataServiceApi',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function abolishDataServiceApi(request: AbolishDataServiceApiRequest): AbolishDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return abolishDataServiceApiWithOptions(request, runtime);
}

model AddProjectMemberToRoleRequest {
  projectId?: long(name='ProjectId'),
  userId?: string(name='UserId'),
  roleCode?: string(name='RoleCode'),
  clientToken?: string(name='ClientToken'),
}

model AddProjectMemberToRoleResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddProjectMemberToRoleResponse = {
  headers: map[string]string(name='headers'),
  body: AddProjectMemberToRoleResponseBody(name='body'),
}

async function addProjectMemberToRoleWithOptions(request: AddProjectMemberToRoleRequest, runtime: Util.RuntimeOptions): AddProjectMemberToRoleResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["UserId"] = request.userId;
  query["RoleCode"] = request.roleCode;
  query["ClientToken"] = request.clientToken;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddProjectMemberToRole',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addProjectMemberToRole(request: AddProjectMemberToRoleRequest): AddProjectMemberToRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addProjectMemberToRoleWithOptions(request, runtime);
}

model AddToMetaCategoryRequest {
  categoryId?: long(name='CategoryId'),
  tableGuid?: string(name='TableGuid'),
}

model AddToMetaCategoryResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model AddToMetaCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: AddToMetaCategoryResponseBody(name='body'),
}

async function addToMetaCategoryWithOptions(request: AddToMetaCategoryRequest, runtime: Util.RuntimeOptions): AddToMetaCategoryResponse {
  Util.validateModel(request);
  var query = {};
  query["CategoryId"] = request.categoryId;
  query["TableGuid"] = request.tableGuid;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddToMetaCategory',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addToMetaCategory(request: AddToMetaCategoryRequest): AddToMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addToMetaCategoryWithOptions(request, runtime);
}

model ApprovePermissionApplyOrderRequest {
  flowId?: string(name='FlowId'),
  approveComment?: string(name='ApproveComment'),
  approveAction?: int32(name='ApproveAction'),
}

model ApprovePermissionApplyOrderResponseBody = {
  approveSuccess?: boolean(name='ApproveSuccess'),
  requestId?: string(name='RequestId'),
}

model ApprovePermissionApplyOrderResponse = {
  headers: map[string]string(name='headers'),
  body: ApprovePermissionApplyOrderResponseBody(name='body'),
}

async function approvePermissionApplyOrderWithOptions(request: ApprovePermissionApplyOrderRequest, runtime: Util.RuntimeOptions): ApprovePermissionApplyOrderResponse {
  Util.validateModel(request);
  var query = {};
  query["FlowId"] = request.flowId;
  query["ApproveComment"] = request.approveComment;
  query["ApproveAction"] = request.approveAction;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ApprovePermissionApplyOrder',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function approvePermissionApplyOrder(request: ApprovePermissionApplyOrderRequest): ApprovePermissionApplyOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return approvePermissionApplyOrderWithOptions(request, runtime);
}

model CheckEngineMetaPartitionRequest {
  tableGuid?: string(name='TableGuid'),
  partition?: string(name='Partition'),
  dataSourceType?: string(name='DataSourceType'),
}

model CheckEngineMetaPartitionResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model CheckEngineMetaPartitionResponse = {
  headers: map[string]string(name='headers'),
  body: CheckEngineMetaPartitionResponseBody(name='body'),
}

async function checkEngineMetaPartitionWithOptions(request: CheckEngineMetaPartitionRequest, runtime: Util.RuntimeOptions): CheckEngineMetaPartitionResponse {
  Util.validateModel(request);
  var query = {};
  query["TableGuid"] = request.tableGuid;
  query["Partition"] = request.partition;
  query["DataSourceType"] = request.dataSourceType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CheckEngineMetaPartition',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkEngineMetaPartition(request: CheckEngineMetaPartitionRequest): CheckEngineMetaPartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkEngineMetaPartitionWithOptions(request, runtime);
}

model CheckEngineMetaTableRequest {
  tableGuid?: string(name='TableGuid'),
  dataSourceType?: string(name='DataSourceType'),
}

model CheckEngineMetaTableResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model CheckEngineMetaTableResponse = {
  headers: map[string]string(name='headers'),
  body: CheckEngineMetaTableResponseBody(name='body'),
}

async function checkEngineMetaTableWithOptions(request: CheckEngineMetaTableRequest, runtime: Util.RuntimeOptions): CheckEngineMetaTableResponse {
  Util.validateModel(request);
  var query = {};
  query["TableGuid"] = request.tableGuid;
  query["DataSourceType"] = request.dataSourceType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CheckEngineMetaTable',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkEngineMetaTable(request: CheckEngineMetaTableRequest): CheckEngineMetaTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkEngineMetaTableWithOptions(request, runtime);
}

model CheckFileDeploymentRequest {
  checkerInstanceId?: string(name='CheckerInstanceId'),
  status?: string(name='Status'),
  checkDetailUrl?: string(name='CheckDetailUrl'),
}

model CheckFileDeploymentResponseBody = {
  requestId?: string(name='RequestId'),
}

model CheckFileDeploymentResponse = {
  headers: map[string]string(name='headers'),
  body: CheckFileDeploymentResponseBody(name='body'),
}

async function checkFileDeploymentWithOptions(request: CheckFileDeploymentRequest, runtime: Util.RuntimeOptions): CheckFileDeploymentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CheckFileDeployment',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkFileDeployment(request: CheckFileDeploymentRequest): CheckFileDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkFileDeploymentWithOptions(request, runtime);
}

model CheckMetaPartitionRequest {
  tableGuid?: string(name='TableGuid'),
  partition?: string(name='Partition'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  dataSourceType?: string(name='DataSourceType'),
}

model CheckMetaPartitionResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model CheckMetaPartitionResponse = {
  headers: map[string]string(name='headers'),
  body: CheckMetaPartitionResponseBody(name='body'),
}

async function checkMetaPartitionWithOptions(request: CheckMetaPartitionRequest, runtime: Util.RuntimeOptions): CheckMetaPartitionResponse {
  Util.validateModel(request);
  var query = {};
  query["TableGuid"] = request.tableGuid;
  query["Partition"] = request.partition;
  query["ClusterId"] = request.clusterId;
  query["DatabaseName"] = request.databaseName;
  query["TableName"] = request.tableName;
  query["DataSourceType"] = request.dataSourceType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CheckMetaPartition',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkMetaPartition(request: CheckMetaPartitionRequest): CheckMetaPartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkMetaPartitionWithOptions(request, runtime);
}

model CheckMetaTableRequest {
  tableGuid?: string(name='TableGuid'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  dataSourceType?: string(name='DataSourceType'),
}

model CheckMetaTableResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model CheckMetaTableResponse = {
  headers: map[string]string(name='headers'),
  body: CheckMetaTableResponseBody(name='body'),
}

async function checkMetaTableWithOptions(request: CheckMetaTableRequest, runtime: Util.RuntimeOptions): CheckMetaTableResponse {
  Util.validateModel(request);
  var query = {};
  query["TableGuid"] = request.tableGuid;
  query["ClusterId"] = request.clusterId;
  query["DatabaseName"] = request.databaseName;
  query["TableName"] = request.tableName;
  query["DataSourceType"] = request.dataSourceType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CheckMetaTable',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkMetaTable(request: CheckMetaTableRequest): CheckMetaTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkMetaTableWithOptions(request, runtime);
}

model CheckMetaTableTaskResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model CheckMetaTableTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CheckMetaTableTaskResponseBody(name='body'),
}

async function checkMetaTableTaskWithOptions(runtime: Util.RuntimeOptions): CheckMetaTableTaskResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'CheckMetaTableTask',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkMetaTableTask(): CheckMetaTableTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkMetaTableTaskWithOptions(runtime);
}

model CreateBusinessRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  businessName?: string(name='BusinessName'),
  description?: string(name='Description'),
  owner?: string(name='Owner'),
  useType?: string(name='UseType'),
}

model CreateBusinessResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  businessId?: long(name='BusinessId'),
}

model CreateBusinessResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBusinessResponseBody(name='body'),
}

async function createBusinessWithOptions(request: CreateBusinessRequest, runtime: Util.RuntimeOptions): CreateBusinessResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateBusiness',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBusiness(request: CreateBusinessRequest): CreateBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBusinessWithOptions(request, runtime);
}

model CreateConnectionRequest {
  projectId?: long(name='ProjectId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  connectionType?: string(name='ConnectionType'),
  subType?: string(name='SubType'),
  envType?: int32(name='EnvType'),
  content?: string(name='Content'),
}

model CreateConnectionResponseBody = {
  httpStatusCode?: string(name='HttpStatusCode'),
  data?: long(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateConnectionResponseBody(name='body'),
}

async function createConnectionWithOptions(request: CreateConnectionRequest, runtime: Util.RuntimeOptions): CreateConnectionResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["Name"] = request.name;
  query["Description"] = request.description;
  query["ConnectionType"] = request.connectionType;
  query["SubType"] = request.subType;
  query["EnvType"] = request.envType;
  query["Content"] = request.content;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateConnection',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createConnection(request: CreateConnectionRequest): CreateConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConnectionWithOptions(request, runtime);
}

model CreateDagComplementRequest {
  projectEnv?: string(name='ProjectEnv'),
  startBizDate?: string(name='StartBizDate'),
  name?: string(name='Name'),
  rootNodeId?: long(name='RootNodeId'),
  includeNodeIds?: string(name='IncludeNodeIds'),
  excludeNodeIds?: string(name='ExcludeNodeIds'),
  bizBeginTime?: string(name='BizBeginTime'),
  bizEndTime?: string(name='BizEndTime'),
  parallelism?: boolean(name='Parallelism'),
  endBizDate?: string(name='EndBizDate'),
  nodeParams?: string(name='NodeParams'),
}

model CreateDagComplementResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: [ long ](name='Data'),
}

model CreateDagComplementResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDagComplementResponseBody(name='body'),
}

async function createDagComplementWithOptions(request: CreateDagComplementRequest, runtime: Util.RuntimeOptions): CreateDagComplementResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateDagComplement',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDagComplement(request: CreateDagComplementRequest): CreateDagComplementResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDagComplementWithOptions(request, runtime);
}

model CreateDagTestRequest {
  projectEnv?: string(name='ProjectEnv'),
  bizdate?: string(name='Bizdate'),
  name?: string(name='Name'),
  nodeId?: long(name='NodeId'),
  nodeParams?: string(name='NodeParams'),
}

model CreateDagTestResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: long(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model CreateDagTestResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDagTestResponseBody(name='body'),
}

async function createDagTestWithOptions(request: CreateDagTestRequest, runtime: Util.RuntimeOptions): CreateDagTestResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateDagTest',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDagTest(request: CreateDagTestRequest): CreateDagTestResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDagTestWithOptions(request, runtime);
}

model CreateDataServiceApiRequest {
  tenantId?: long(name='TenantId'),
  projectId?: long(name='ProjectId'),
  apiName?: string(name='ApiName'),
  groupId?: string(name='GroupId'),
  apiMode?: int32(name='ApiMode'),
  requestMethod?: int32(name='RequestMethod'),
  responseContentType?: int32(name='ResponseContentType'),
  timeout?: int32(name='Timeout'),
  visibleRange?: int32(name='VisibleRange'),
  protocols?: string(name='Protocols'),
  wizardDetails?: string(name='WizardDetails'),
  scriptDetails?: string(name='ScriptDetails'),
  registrationDetails?: string(name='RegistrationDetails'),
  apiPath?: string(name='ApiPath'),
  apiDescription?: string(name='ApiDescription'),
  folderId?: long(name='FolderId'),
}

model CreateDataServiceApiResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: long(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model CreateDataServiceApiResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataServiceApiResponseBody(name='body'),
}

async function createDataServiceApiWithOptions(request: CreateDataServiceApiRequest, runtime: Util.RuntimeOptions): CreateDataServiceApiResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataServiceApi',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDataServiceApi(request: CreateDataServiceApiRequest): CreateDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataServiceApiWithOptions(request, runtime);
}

model CreateDataServiceApiAuthorityRequest {
  tenantId?: long(name='TenantId'),
  projectId?: long(name='ProjectId'),
  apiId?: long(name='ApiId'),
  authorizedProjectId?: long(name='AuthorizedProjectId'),
  endTime?: long(name='EndTime'),
}

model CreateDataServiceApiAuthorityResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
}

model CreateDataServiceApiAuthorityResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataServiceApiAuthorityResponseBody(name='body'),
}

async function createDataServiceApiAuthorityWithOptions(request: CreateDataServiceApiAuthorityRequest, runtime: Util.RuntimeOptions): CreateDataServiceApiAuthorityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataServiceApiAuthority',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDataServiceApiAuthority(request: CreateDataServiceApiAuthorityRequest): CreateDataServiceApiAuthorityResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataServiceApiAuthorityWithOptions(request, runtime);
}

model CreateDataServiceFolderRequest {
  tenantId?: long(name='TenantId'),
  projectId?: long(name='ProjectId'),
  folderName?: string(name='FolderName'),
  parentId?: long(name='ParentId'),
  groupId?: string(name='GroupId'),
}

model CreateDataServiceFolderResponseBody = {
  folderId?: long(name='FolderId'),
  requestId?: string(name='RequestId'),
}

model CreateDataServiceFolderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataServiceFolderResponseBody(name='body'),
}

async function createDataServiceFolderWithOptions(request: CreateDataServiceFolderRequest, runtime: Util.RuntimeOptions): CreateDataServiceFolderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataServiceFolder',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDataServiceFolder(request: CreateDataServiceFolderRequest): CreateDataServiceFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataServiceFolderWithOptions(request, runtime);
}

model CreateDataServiceGroupRequest {
  tenantId?: long(name='TenantId'),
  projectId?: long(name='ProjectId'),
  apiGatewayGroupId?: string(name='ApiGatewayGroupId'),
  groupName?: string(name='GroupName'),
  description?: string(name='Description'),
}

model CreateDataServiceGroupResponseBody = {
  groupId?: string(name='GroupId'),
  requestId?: string(name='RequestId'),
}

model CreateDataServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataServiceGroupResponseBody(name='body'),
}

async function createDataServiceGroupWithOptions(request: CreateDataServiceGroupRequest, runtime: Util.RuntimeOptions): CreateDataServiceGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataServiceGroup',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDataServiceGroup(request: CreateDataServiceGroupRequest): CreateDataServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataServiceGroupWithOptions(request, runtime);
}

model CreateDataSourceRequest {
  projectId?: long(name='ProjectId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  dataSourceType?: string(name='DataSourceType'),
  subType?: string(name='SubType'),
  envType?: int32(name='EnvType'),
  content?: string(name='Content'),
}

model CreateDataSourceResponseBody = {
  httpStatusCode?: string(name='HttpStatusCode'),
  data?: long(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataSourceResponseBody(name='body'),
}

async function createDataSourceWithOptions(request: CreateDataSourceRequest, runtime: Util.RuntimeOptions): CreateDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["Name"] = request.name;
  query["Description"] = request.description;
  query["DataSourceType"] = request.dataSourceType;
  query["SubType"] = request.subType;
  query["EnvType"] = request.envType;
  query["Content"] = request.content;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataSource',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDataSource(request: CreateDataSourceRequest): CreateDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataSourceWithOptions(request, runtime);
}

model CreateDISyncTaskRequest {
  projectId?: long(name='ProjectId'),
  taskType?: string(name='TaskType'),
  taskContent?: string(name='TaskContent'),
  taskParam?: string(name='TaskParam'),
  taskName?: string(name='TaskName'),
  clientToken?: string(name='ClientToken'),
}

model CreateDISyncTaskResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    message?: string(name='Message'),
    fileId?: long(name='FileId'),
  }(name='Data'),
}

model CreateDISyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDISyncTaskResponseBody(name='body'),
}

async function createDISyncTaskWithOptions(request: CreateDISyncTaskRequest, runtime: Util.RuntimeOptions): CreateDISyncTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["TaskType"] = request.taskType;
  query["TaskContent"] = request.taskContent;
  query["TaskParam"] = request.taskParam;
  query["TaskName"] = request.taskName;
  query["ClientToken"] = request.clientToken;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateDISyncTask',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDISyncTask(request: CreateDISyncTaskRequest): CreateDISyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDISyncTaskWithOptions(request, runtime);
}

model CreateFileRequest {
  fileFolderPath?: string(name='FileFolderPath'),
  projectId?: long(name='ProjectId'),
  fileName?: string(name='FileName'),
  fileDescription?: string(name='FileDescription'),
  fileType?: int32(name='FileType'),
  owner?: string(name='Owner'),
  content?: string(name='Content'),
  autoRerunTimes?: int32(name='AutoRerunTimes'),
  autoRerunIntervalMillis?: int32(name='AutoRerunIntervalMillis'),
  rerunMode?: string(name='RerunMode'),
  stop?: boolean(name='Stop'),
  paraValue?: string(name='ParaValue'),
  startEffectDate?: long(name='StartEffectDate'),
  endEffectDate?: long(name='EndEffectDate'),
  cronExpress?: string(name='CronExpress'),
  cycleType?: string(name='CycleType'),
  dependentType?: string(name='DependentType'),
  dependentNodeIdList?: string(name='DependentNodeIdList'),
  inputList?: string(name='InputList'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  resourceGroupIdentifier?: string(name='ResourceGroupIdentifier'),
  resourceGroupId?: long(name='ResourceGroupId'),
  connectionName?: string(name='ConnectionName'),
  autoParsing?: boolean(name='AutoParsing'),
  schedulerType?: string(name='SchedulerType'),
}

model CreateFileResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: long(name='Data'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model CreateFileResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFileResponseBody(name='body'),
}

async function createFileWithOptions(request: CreateFileRequest, runtime: Util.RuntimeOptions): CreateFileResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateFile',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFile(request: CreateFileRequest): CreateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFileWithOptions(request, runtime);
}

model CreateFolderRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  folderPath?: string(name='FolderPath'),
}

model CreateFolderResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model CreateFolderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFolderResponseBody(name='body'),
}

async function createFolderWithOptions(request: CreateFolderRequest, runtime: Util.RuntimeOptions): CreateFolderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateFolder',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFolder(request: CreateFolderRequest): CreateFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFolderWithOptions(request, runtime);
}

model CreateImportMigrationRequest {
  projectId?: long(name='ProjectId'),
  name?: string(name='Name'),
  packageType?: string(name='PackageType'),
  packageFile?: string(name='PackageFile'),
  resourceGroupMap?: string(name='ResourceGroupMap'),
  workspaceMap?: string(name='WorkspaceMap'),
  calculateEngineMap?: string(name='CalculateEngineMap'),
  commitRule?: string(name='CommitRule'),
  description?: string(name='Description'),
}

model CreateImportMigrationAdvanceRequest {
  packageFileObject: readable(name='PackageFileObject'),
  projectId?: long(name='ProjectId'),
  name?: string(name='Name'),
  packageType?: string(name='PackageType'),
  resourceGroupMap?: string(name='ResourceGroupMap'),
  workspaceMap?: string(name='WorkspaceMap'),
  calculateEngineMap?: string(name='CalculateEngineMap'),
  commitRule?: string(name='CommitRule'),
  description?: string(name='Description'),
}

model CreateImportMigrationResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: long(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model CreateImportMigrationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateImportMigrationResponseBody(name='body'),
}

async function createImportMigrationWithOptions(request: CreateImportMigrationRequest, runtime: Util.RuntimeOptions): CreateImportMigrationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateImportMigration',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createImportMigration(request: CreateImportMigrationRequest): CreateImportMigrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createImportMigrationWithOptions(request, runtime);
}

async function createImportMigrationAdvance(request: CreateImportMigrationAdvanceRequest, runtime: Util.RuntimeOptions): CreateImportMigrationResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'dataworks-public',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var createImportMigrationReq = new CreateImportMigrationRequest{};
  OpenApiUtil.convert(request, createImportMigrationReq);

  if(!Util.isUnset(request.packageFileObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.packageFileObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    createImportMigrationReq.packageFile =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var createImportMigrationResp = createImportMigrationWithOptions(createImportMigrationReq, runtime);
  return createImportMigrationResp;
}

model CreateManualDagRequest {
  projectEnv?: string(name='ProjectEnv'),
  projectName?: string(name='ProjectName'),
  flowName?: string(name='FlowName'),
  bizDate?: string(name='BizDate'),
  nodeParameters?: string(name='NodeParameters'),
  dagParameters?: string(name='DagParameters'),
  includeNodeIds?: string(name='IncludeNodeIds'),
  excludeNodeIds?: string(name='ExcludeNodeIds'),
}

model CreateManualDagResponseBody = {
  dagId?: long(name='DagId'),
  requestId?: string(name='RequestId'),
}

model CreateManualDagResponse = {
  headers: map[string]string(name='headers'),
  body: CreateManualDagResponseBody(name='body'),
}

async function createManualDagWithOptions(request: CreateManualDagRequest, runtime: Util.RuntimeOptions): CreateManualDagResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateManualDag',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createManualDag(request: CreateManualDagRequest): CreateManualDagResponse {
  var runtime = new Util.RuntimeOptions{};
  return createManualDagWithOptions(request, runtime);
}

model CreateMetaCategoryRequest {
  name?: string(name='Name'),
  comment?: string(name='Comment'),
  parentId?: long(name='ParentId'),
}

model CreateMetaCategoryResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    categoryId?: long(name='CategoryId'),
  }(name='Data'),
}

model CreateMetaCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMetaCategoryResponseBody(name='body'),
}

async function createMetaCategoryWithOptions(request: CreateMetaCategoryRequest, runtime: Util.RuntimeOptions): CreateMetaCategoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateMetaCategory',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMetaCategory(request: CreateMetaCategoryRequest): CreateMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMetaCategoryWithOptions(request, runtime);
}

model CreatePermissionApplyOrderRequest {
  applyUserIds?: string(name='ApplyUserIds'),
  deadline?: long(name='Deadline'),
  applyReason?: string(name='ApplyReason'),
  maxComputeProjectName?: string(name='MaxComputeProjectName'),
  workspaceId?: int32(name='WorkspaceId'),
  orderType?: int32(name='OrderType'),
  engineType?: string(name='EngineType'),
  applyObject?: [ 
    {
      actions?: string(name='Actions'),
      columnMetaList?: [ 
        {
          name?: string(name='Name'),
        }
      ](name='ColumnMetaList'),
      name?: string(name='Name'),
    }
  ](name='ApplyObject'),
}

model CreatePermissionApplyOrderResponseBody = {
  requestId?: string(name='RequestId'),
  flowId?: [ string ](name='FlowId'),
}

model CreatePermissionApplyOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePermissionApplyOrderResponseBody(name='body'),
}

async function createPermissionApplyOrderWithOptions(request: CreatePermissionApplyOrderRequest, runtime: Util.RuntimeOptions): CreatePermissionApplyOrderResponse {
  Util.validateModel(request);
  var query = {};
  query["ApplyUserIds"] = request.applyUserIds;
  query["Deadline"] = request.deadline;
  query["ApplyReason"] = request.applyReason;
  query["MaxComputeProjectName"] = request.maxComputeProjectName;
  query["WorkspaceId"] = request.workspaceId;
  query["OrderType"] = request.orderType;
  query["EngineType"] = request.engineType;
  query["ApplyObject"] = request.applyObject;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreatePermissionApplyOrder',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPermissionApplyOrder(request: CreatePermissionApplyOrderRequest): CreatePermissionApplyOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPermissionApplyOrderWithOptions(request, runtime);
}

model CreateProjectMemberRequest {
  projectId?: long(name='ProjectId'),
  userId?: string(name='UserId'),
  clientToken?: string(name='ClientToken'),
  roleCode?: string(name='RoleCode'),
}

model CreateProjectMemberResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateProjectMemberResponse = {
  headers: map[string]string(name='headers'),
  body: CreateProjectMemberResponseBody(name='body'),
}

async function createProjectMemberWithOptions(request: CreateProjectMemberRequest, runtime: Util.RuntimeOptions): CreateProjectMemberResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["UserId"] = request.userId;
  query["ClientToken"] = request.clientToken;
  query["RoleCode"] = request.roleCode;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateProjectMember',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createProjectMember(request: CreateProjectMemberRequest): CreateProjectMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProjectMemberWithOptions(request, runtime);
}

model CreateQualityEntityRequest {
  projectName?: string(name='ProjectName'),
  tableName?: string(name='TableName'),
  envType?: string(name='EnvType'),
  matchExpression?: string(name='MatchExpression'),
  entityLevel?: int32(name='EntityLevel'),
}

model CreateQualityEntityResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: int32(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model CreateQualityEntityResponse = {
  headers: map[string]string(name='headers'),
  body: CreateQualityEntityResponseBody(name='body'),
}

async function createQualityEntityWithOptions(request: CreateQualityEntityRequest, runtime: Util.RuntimeOptions): CreateQualityEntityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateQualityEntity',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createQualityEntity(request: CreateQualityEntityRequest): CreateQualityEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQualityEntityWithOptions(request, runtime);
}

model CreateQualityFollowerRequest {
  projectName?: string(name='ProjectName'),
  follower?: string(name='Follower'),
  alarmMode?: int32(name='AlarmMode'),
  entityId?: long(name='EntityId'),
}

model CreateQualityFollowerResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: int32(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model CreateQualityFollowerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateQualityFollowerResponseBody(name='body'),
}

async function createQualityFollowerWithOptions(request: CreateQualityFollowerRequest, runtime: Util.RuntimeOptions): CreateQualityFollowerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateQualityFollower',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createQualityFollower(request: CreateQualityFollowerRequest): CreateQualityFollowerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQualityFollowerWithOptions(request, runtime);
}

model CreateQualityRelativeNodeRequest {
  envType?: string(name='EnvType'),
  matchExpression?: string(name='MatchExpression'),
  nodeId?: long(name='NodeId'),
  projectId?: long(name='ProjectId'),
  targetNodeProjectName?: string(name='TargetNodeProjectName'),
  projectName?: string(name='ProjectName'),
  tableName?: string(name='TableName'),
  targetNodeProjectId?: long(name='TargetNodeProjectId'),
}

model CreateQualityRelativeNodeResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model CreateQualityRelativeNodeResponse = {
  headers: map[string]string(name='headers'),
  body: CreateQualityRelativeNodeResponseBody(name='body'),
}

async function createQualityRelativeNodeWithOptions(request: CreateQualityRelativeNodeRequest, runtime: Util.RuntimeOptions): CreateQualityRelativeNodeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateQualityRelativeNode',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createQualityRelativeNode(request: CreateQualityRelativeNodeRequest): CreateQualityRelativeNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQualityRelativeNodeWithOptions(request, runtime);
}

model CreateQualityRuleRequest {
  blockType?: int32(name='BlockType'),
  entityId?: long(name='EntityId'),
  comment?: string(name='Comment'),
  checker?: int32(name='Checker'),
  expectValue?: string(name='ExpectValue'),
  trend?: string(name='Trend'),
  methodName?: string(name='MethodName'),
  operator?: string(name='Operator'),
  projectName?: string(name='ProjectName'),
  property?: string(name='Property'),
  propertyType?: string(name='PropertyType'),
  ruleType?: int32(name='RuleType'),
  whereCondition?: string(name='WhereCondition'),
  criticalThreshold?: string(name='CriticalThreshold'),
  warningThreshold?: string(name='WarningThreshold'),
  templateId?: int32(name='TemplateId'),
  ruleName?: string(name='RuleName'),
  predictType?: int32(name='PredictType'),
}

model CreateQualityRuleResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model CreateQualityRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateQualityRuleResponseBody(name='body'),
}

async function createQualityRuleWithOptions(request: CreateQualityRuleRequest, runtime: Util.RuntimeOptions): CreateQualityRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateQualityRule',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createQualityRule(request: CreateQualityRuleRequest): CreateQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQualityRuleWithOptions(request, runtime);
}

model CreateRemindRequest {
  remindName?: string(name='RemindName'),
  dndEnd?: string(name='DndEnd'),
  remindUnit?: string(name='RemindUnit'),
  nodeIds?: string(name='NodeIds'),
  baselineIds?: string(name='BaselineIds'),
  projectId?: long(name='ProjectId'),
  bizProcessIds?: string(name='BizProcessIds'),
  remindType?: string(name='RemindType'),
  maxAlertTimes?: int32(name='MaxAlertTimes'),
  alertInterval?: int32(name='AlertInterval'),
  detail?: string(name='Detail'),
  alertUnit?: string(name='AlertUnit'),
  alertMethods?: string(name='AlertMethods'),
  alertTargets?: string(name='AlertTargets'),
  robotUrls?: string(name='RobotUrls'),
}

model CreateRemindResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: long(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model CreateRemindResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRemindResponseBody(name='body'),
}

async function createRemindWithOptions(request: CreateRemindRequest, runtime: Util.RuntimeOptions): CreateRemindResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateRemind',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRemind(request: CreateRemindRequest): CreateRemindResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRemindWithOptions(request, runtime);
}

model CreateTableRequest {
  isView?: int32(name='IsView'),
  visibility?: int32(name='Visibility'),
  lifeCycle?: int32(name='LifeCycle'),
  categoryId?: long(name='CategoryId'),
  logicalLevelId?: long(name='LogicalLevelId'),
  physicsLevelId?: long(name='PhysicsLevelId'),
  externalTableType?: string(name='ExternalTableType'),
  location?: string(name='Location'),
  projectId?: long(name='ProjectId'),
  tableName?: string(name='TableName'),
  endpoint?: string(name='Endpoint'),
  envType?: int32(name='EnvType'),
  appGuid?: string(name='AppGuid'),
  comment?: string(name='Comment'),
  ownerId?: string(name='OwnerId'),
  hasPart?: int32(name='HasPart'),
  clientToken?: string(name='ClientToken'),
  columns?: [ 
    {
      columnNameCn?: string(name='ColumnNameCn'),
      columnName?: string(name='ColumnName'),
      comment?: string(name='Comment'),
      columnType?: string(name='ColumnType'),
      seqNumber?: int32(name='SeqNumber'),
      length?: int32(name='Length'),
      isPartitionCol?: boolean(name='IsPartitionCol'),
    }
  ](name='Columns'),
  themes?: [ 
    {
      themeId?: long(name='ThemeId'),
      themeLevel?: int32(name='ThemeLevel'),
    }
  ](name='Themes'),
}

model CreateTableResponseBody = {
  requestId?: string(name='RequestId'),
  taskInfo?: {
    status?: string(name='Status'),
    nextTaskId?: string(name='NextTaskId'),
    taskId?: string(name='TaskId'),
    content?: string(name='Content'),
  }(name='TaskInfo'),
}

model CreateTableResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTableResponseBody(name='body'),
}

async function createTableWithOptions(request: CreateTableRequest, runtime: Util.RuntimeOptions): CreateTableResponse {
  Util.validateModel(request);
  var query = {};
  query["IsView"] = request.isView;
  query["Visibility"] = request.visibility;
  query["LifeCycle"] = request.lifeCycle;
  query["CategoryId"] = request.categoryId;
  query["LogicalLevelId"] = request.logicalLevelId;
  query["PhysicsLevelId"] = request.physicsLevelId;
  query["ExternalTableType"] = request.externalTableType;
  query["Location"] = request.location;
  query["ProjectId"] = request.projectId;
  query["TableName"] = request.tableName;
  query["AppGuid"] = request.appGuid;
  query["Comment"] = request.comment;
  query["OwnerId"] = request.ownerId;
  query["HasPart"] = request.hasPart;
  query["ClientToken"] = request.clientToken;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateTable',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTable(request: CreateTableRequest): CreateTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTableWithOptions(request, runtime);
}

model CreateTableLevelRequest {
  projectId?: long(name='ProjectId'),
  levelType?: int32(name='LevelType'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model CreateTableLevelResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  levelId?: long(name='LevelId'),
}

model CreateTableLevelResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTableLevelResponseBody(name='body'),
}

async function createTableLevelWithOptions(request: CreateTableLevelRequest, runtime: Util.RuntimeOptions): CreateTableLevelResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["LevelType"] = request.levelType;
  query["Name"] = request.name;
  query["Description"] = request.description;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateTableLevel',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTableLevel(request: CreateTableLevelRequest): CreateTableLevelResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTableLevelWithOptions(request, runtime);
}

model CreateTableThemeRequest {
  projectId?: long(name='ProjectId'),
  level?: int32(name='Level'),
  name?: string(name='Name'),
  parentId?: long(name='ParentId'),
}

model CreateTableThemeResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  themeId?: long(name='ThemeId'),
}

model CreateTableThemeResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTableThemeResponseBody(name='body'),
}

async function createTableThemeWithOptions(request: CreateTableThemeRequest, runtime: Util.RuntimeOptions): CreateTableThemeResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["Level"] = request.level;
  query["Name"] = request.name;
  query["ParentId"] = request.parentId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateTableTheme',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTableTheme(request: CreateTableThemeRequest): CreateTableThemeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTableThemeWithOptions(request, runtime);
}

model CreateUdfFileRequest {
  fileFolderPath?: string(name='FileFolderPath'),
  projectId?: long(name='ProjectId'),
  fileName?: string(name='FileName'),
  functionType?: string(name='FunctionType'),
  className?: string(name='ClassName'),
  resources?: string(name='Resources'),
  udfDescription?: string(name='UdfDescription'),
  cmdDescription?: string(name='CmdDescription'),
  parameterDescription?: string(name='ParameterDescription'),
  returnValue?: string(name='ReturnValue'),
  example?: string(name='Example'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model CreateUdfFileResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: long(name='Data'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model CreateUdfFileResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUdfFileResponseBody(name='body'),
}

async function createUdfFileWithOptions(request: CreateUdfFileRequest, runtime: Util.RuntimeOptions): CreateUdfFileResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateUdfFile',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUdfFile(request: CreateUdfFileRequest): CreateUdfFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUdfFileWithOptions(request, runtime);
}

model CreateViewRequest {
  viewName?: string(name='ViewName'),
  selectColumn?: string(name='SelectColumn'),
  selectTableName?: string(name='SelectTableName'),
  selectWhere?: string(name='SelectWhere'),
  selectSQL?: string(name='SelectSQL'),
  appGuid?: string(name='AppGuid'),
  comment?: string(name='Comment'),
  clientToken?: string(name='ClientToken'),
  viewColumn?: [ 
    {
      columnName?: string(name='ColumnName'),
      comment?: string(name='Comment'),
    }
  ](name='ViewColumn'),
}

model CreateViewResponseBody = {
  requestId?: string(name='RequestId'),
  taskInfo?: {
    status?: string(name='Status'),
    nextTaskId?: string(name='NextTaskId'),
    taskId?: string(name='TaskId'),
    content?: string(name='Content'),
  }(name='TaskInfo'),
}

model CreateViewResponse = {
  headers: map[string]string(name='headers'),
  body: CreateViewResponseBody(name='body'),
}

async function createViewWithOptions(request: CreateViewRequest, runtime: Util.RuntimeOptions): CreateViewResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateView',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createView(request: CreateViewRequest): CreateViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return createViewWithOptions(request, runtime);
}

model DeleteBusinessRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  businessId?: long(name='BusinessId'),
}

model DeleteBusinessResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model DeleteBusinessResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBusinessResponseBody(name='body'),
}

async function deleteBusinessWithOptions(request: DeleteBusinessRequest, runtime: Util.RuntimeOptions): DeleteBusinessResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBusiness',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBusiness(request: DeleteBusinessRequest): DeleteBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBusinessWithOptions(request, runtime);
}

model DeleteConnectionRequest {
  connectionId?: long(name='ConnectionId'),
}

model DeleteConnectionResponseBody = {
  httpStatusCode?: string(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteConnectionResponseBody(name='body'),
}

async function deleteConnectionWithOptions(request: DeleteConnectionRequest, runtime: Util.RuntimeOptions): DeleteConnectionResponse {
  Util.validateModel(request);
  var query = {};
  query["ConnectionId"] = request.connectionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteConnection',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteConnection(request: DeleteConnectionRequest): DeleteConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteConnectionWithOptions(request, runtime);
}

model DeleteDataServiceApiRequest {
  tenantId?: long(name='TenantId'),
  projectId?: long(name='ProjectId'),
  apiId?: long(name='ApiId'),
}

model DeleteDataServiceApiResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model DeleteDataServiceApiResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataServiceApiResponseBody(name='body'),
}

async function deleteDataServiceApiWithOptions(request: DeleteDataServiceApiRequest, runtime: Util.RuntimeOptions): DeleteDataServiceApiResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataServiceApi',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDataServiceApi(request: DeleteDataServiceApiRequest): DeleteDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDataServiceApiWithOptions(request, runtime);
}

model DeleteDataServiceApiAuthorityRequest {
  tenantId?: long(name='TenantId'),
  projectId?: long(name='ProjectId'),
  apiId?: long(name='ApiId'),
  authorizedProjectId?: long(name='AuthorizedProjectId'),
}

model DeleteDataServiceApiAuthorityResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
}

model DeleteDataServiceApiAuthorityResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataServiceApiAuthorityResponseBody(name='body'),
}

async function deleteDataServiceApiAuthorityWithOptions(request: DeleteDataServiceApiAuthorityRequest, runtime: Util.RuntimeOptions): DeleteDataServiceApiAuthorityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataServiceApiAuthority',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDataServiceApiAuthority(request: DeleteDataServiceApiAuthorityRequest): DeleteDataServiceApiAuthorityResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDataServiceApiAuthorityWithOptions(request, runtime);
}

model DeleteDataSourceRequest {
  dataSourceId?: long(name='DataSourceId'),
}

model DeleteDataSourceResponseBody = {
  httpStatusCode?: string(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataSourceResponseBody(name='body'),
}

async function deleteDataSourceWithOptions(request: DeleteDataSourceRequest, runtime: Util.RuntimeOptions): DeleteDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  query["DataSourceId"] = request.dataSourceId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataSource',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDataSource(request: DeleteDataSourceRequest): DeleteDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDataSourceWithOptions(request, runtime);
}

model DeleteDISyncTaskRequest {
  projectId?: long(name='ProjectId'),
  taskType?: string(name='TaskType'),
  fileId?: long(name='FileId'),
}

model DeleteDISyncTaskResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    message?: string(name='Message'),
  }(name='Data'),
}

model DeleteDISyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDISyncTaskResponseBody(name='body'),
}

async function deleteDISyncTaskWithOptions(request: DeleteDISyncTaskRequest, runtime: Util.RuntimeOptions): DeleteDISyncTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["TaskType"] = request.taskType;
  query["FileId"] = request.fileId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDISyncTask',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDISyncTask(request: DeleteDISyncTaskRequest): DeleteDISyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDISyncTaskWithOptions(request, runtime);
}

model DeleteFileRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  fileId?: long(name='FileId'),
}

model DeleteFileResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  deploymentId?: long(name='DeploymentId'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model DeleteFileResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFileResponseBody(name='body'),
}

async function deleteFileWithOptions(request: DeleteFileRequest, runtime: Util.RuntimeOptions): DeleteFileResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFile',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFile(request: DeleteFileRequest): DeleteFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFileWithOptions(request, runtime);
}

model DeleteFolderRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  folderId?: string(name='FolderId'),
}

model DeleteFolderResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model DeleteFolderResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFolderResponseBody(name='body'),
}

async function deleteFolderWithOptions(request: DeleteFolderRequest, runtime: Util.RuntimeOptions): DeleteFolderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFolder',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFolder(request: DeleteFolderRequest): DeleteFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFolderWithOptions(request, runtime);
}

model DeleteFromMetaCategoryRequest {
  categoryId?: long(name='CategoryId'),
  tableGuid?: string(name='TableGuid'),
}

model DeleteFromMetaCategoryResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model DeleteFromMetaCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFromMetaCategoryResponseBody(name='body'),
}

async function deleteFromMetaCategoryWithOptions(request: DeleteFromMetaCategoryRequest, runtime: Util.RuntimeOptions): DeleteFromMetaCategoryResponse {
  Util.validateModel(request);
  var query = {};
  query["CategoryId"] = request.categoryId;
  query["TableGuid"] = request.tableGuid;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFromMetaCategory',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFromMetaCategory(request: DeleteFromMetaCategoryRequest): DeleteFromMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFromMetaCategoryWithOptions(request, runtime);
}

model DeleteMetaCategoryRequest {
  categoryId?: long(name='CategoryId'),
}

model DeleteMetaCategoryResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model DeleteMetaCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMetaCategoryResponseBody(name='body'),
}

async function deleteMetaCategoryWithOptions(request: DeleteMetaCategoryRequest, runtime: Util.RuntimeOptions): DeleteMetaCategoryResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMetaCategory',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMetaCategory(request: DeleteMetaCategoryRequest): DeleteMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetaCategoryWithOptions(request, runtime);
}

model DeleteProjectMemberRequest {
  projectId?: long(name='ProjectId'),
  userId?: string(name='UserId'),
}

model DeleteProjectMemberResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteProjectMemberResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProjectMemberResponseBody(name='body'),
}

async function deleteProjectMemberWithOptions(request: DeleteProjectMemberRequest, runtime: Util.RuntimeOptions): DeleteProjectMemberResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["UserId"] = request.userId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProjectMember',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProjectMember(request: DeleteProjectMemberRequest): DeleteProjectMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProjectMemberWithOptions(request, runtime);
}

model DeleteQualityEntityRequest {
  entityId?: long(name='EntityId'),
  projectName?: string(name='ProjectName'),
  envType?: string(name='EnvType'),
}

model DeleteQualityEntityResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model DeleteQualityEntityResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteQualityEntityResponseBody(name='body'),
}

async function deleteQualityEntityWithOptions(request: DeleteQualityEntityRequest, runtime: Util.RuntimeOptions): DeleteQualityEntityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteQualityEntity',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteQualityEntity(request: DeleteQualityEntityRequest): DeleteQualityEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQualityEntityWithOptions(request, runtime);
}

model DeleteQualityFollowerRequest {
  projectName?: string(name='ProjectName'),
  followerId?: long(name='FollowerId'),
}

model DeleteQualityFollowerResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model DeleteQualityFollowerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteQualityFollowerResponseBody(name='body'),
}

async function deleteQualityFollowerWithOptions(request: DeleteQualityFollowerRequest, runtime: Util.RuntimeOptions): DeleteQualityFollowerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteQualityFollower',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteQualityFollower(request: DeleteQualityFollowerRequest): DeleteQualityFollowerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQualityFollowerWithOptions(request, runtime);
}

model DeleteQualityRelativeNodeRequest {
  envType?: string(name='EnvType'),
  matchExpression?: string(name='MatchExpression'),
  nodeId?: long(name='NodeId'),
  projectId?: long(name='ProjectId'),
  targetNodeProjectName?: string(name='TargetNodeProjectName'),
  projectName?: string(name='ProjectName'),
  tableName?: string(name='TableName'),
  targetNodeProjectId?: long(name='TargetNodeProjectId'),
}

model DeleteQualityRelativeNodeResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model DeleteQualityRelativeNodeResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteQualityRelativeNodeResponseBody(name='body'),
}

async function deleteQualityRelativeNodeWithOptions(request: DeleteQualityRelativeNodeRequest, runtime: Util.RuntimeOptions): DeleteQualityRelativeNodeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteQualityRelativeNode',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteQualityRelativeNode(request: DeleteQualityRelativeNodeRequest): DeleteQualityRelativeNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQualityRelativeNodeWithOptions(request, runtime);
}

model DeleteQualityRuleRequest {
  projectName?: string(name='ProjectName'),
  ruleId?: long(name='RuleId'),
}

model DeleteQualityRuleResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model DeleteQualityRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteQualityRuleResponseBody(name='body'),
}

async function deleteQualityRuleWithOptions(request: DeleteQualityRuleRequest, runtime: Util.RuntimeOptions): DeleteQualityRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteQualityRule',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteQualityRule(request: DeleteQualityRuleRequest): DeleteQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQualityRuleWithOptions(request, runtime);
}

model DeleteRemindRequest {
  remindId?: long(name='RemindId'),
}

model DeleteRemindResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model DeleteRemindResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRemindResponseBody(name='body'),
}

async function deleteRemindWithOptions(request: DeleteRemindRequest, runtime: Util.RuntimeOptions): DeleteRemindResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRemind',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRemind(request: DeleteRemindRequest): DeleteRemindResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRemindWithOptions(request, runtime);
}

model DeleteTableRequest {
  projectId?: long(name='ProjectId'),
  tableName?: string(name='TableName'),
  envType?: int32(name='EnvType'),
  appGuid?: string(name='AppGuid'),
}

model DeleteTableResponseBody = {
  requestId?: string(name='RequestId'),
  taskInfo?: {
    status?: string(name='Status'),
    nextTaskId?: string(name='NextTaskId'),
    taskId?: string(name='TaskId'),
    content?: string(name='Content'),
  }(name='TaskInfo'),
}

model DeleteTableResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTableResponseBody(name='body'),
}

async function deleteTableWithOptions(request: DeleteTableRequest, runtime: Util.RuntimeOptions): DeleteTableResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["TableName"] = request.tableName;
  query["EnvType"] = request.envType;
  query["AppGuid"] = request.appGuid;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTable',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTable(request: DeleteTableRequest): DeleteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTableWithOptions(request, runtime);
}

model DeleteTableLevelRequest {
  levelId?: long(name='LevelId'),
  projectId?: long(name='ProjectId'),
}

model DeleteTableLevelResponseBody = {
  deleteResult?: boolean(name='DeleteResult'),
  requestId?: string(name='RequestId'),
}

model DeleteTableLevelResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTableLevelResponseBody(name='body'),
}

async function deleteTableLevelWithOptions(request: DeleteTableLevelRequest, runtime: Util.RuntimeOptions): DeleteTableLevelResponse {
  Util.validateModel(request);
  var query = {};
  query["LevelId"] = request.levelId;
  query["ProjectId"] = request.projectId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTableLevel',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTableLevel(request: DeleteTableLevelRequest): DeleteTableLevelResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTableLevelWithOptions(request, runtime);
}

model DeleteTableThemeRequest {
  themeId?: long(name='ThemeId'),
  projectId?: long(name='ProjectId'),
}

model DeleteTableThemeResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  deleteResult?: boolean(name='DeleteResult'),
}

model DeleteTableThemeResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTableThemeResponseBody(name='body'),
}

async function deleteTableThemeWithOptions(request: DeleteTableThemeRequest, runtime: Util.RuntimeOptions): DeleteTableThemeResponse {
  Util.validateModel(request);
  var query = {};
  query["ThemeId"] = request.themeId;
  query["ProjectId"] = request.projectId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTableTheme',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTableTheme(request: DeleteTableThemeRequest): DeleteTableThemeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTableThemeWithOptions(request, runtime);
}

model DeleteViewRequest {
  viewName?: string(name='ViewName'),
  appGuid?: string(name='AppGuid'),
}

model DeleteViewResponseBody = {
  requestId?: string(name='RequestId'),
  taskInfo?: {
    status?: string(name='Status'),
    nextTaskId?: string(name='NextTaskId'),
    taskId?: string(name='TaskId'),
    content?: string(name='Content'),
  }(name='TaskInfo'),
}

model DeleteViewResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteViewResponseBody(name='body'),
}

async function deleteViewWithOptions(request: DeleteViewRequest, runtime: Util.RuntimeOptions): DeleteViewResponse {
  Util.validateModel(request);
  var query = {};
  query["ViewName"] = request.viewName;
  query["AppGuid"] = request.appGuid;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteView',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteView(request: DeleteViewRequest): DeleteViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteViewWithOptions(request, runtime);
}

model DeployDISyncTaskRequest {
  projectId?: long(name='ProjectId'),
  taskType?: string(name='TaskType'),
  fileId?: long(name='FileId'),
}

model DeployDISyncTaskResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    message?: string(name='Message'),
  }(name='Data'),
}

model DeployDISyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeployDISyncTaskResponseBody(name='body'),
}

async function deployDISyncTaskWithOptions(request: DeployDISyncTaskRequest, runtime: Util.RuntimeOptions): DeployDISyncTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["TaskType"] = request.taskType;
  query["FileId"] = request.fileId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeployDISyncTask',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deployDISyncTask(request: DeployDISyncTaskRequest): DeployDISyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deployDISyncTaskWithOptions(request, runtime);
}

model DeployFileRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  fileId?: long(name='FileId'),
  comment?: string(name='Comment'),
  nodeId?: long(name='NodeId'),
}

model DeployFileResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: long(name='Data'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model DeployFileResponse = {
  headers: map[string]string(name='headers'),
  body: DeployFileResponseBody(name='body'),
}

async function deployFileWithOptions(request: DeployFileRequest, runtime: Util.RuntimeOptions): DeployFileResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeployFile',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deployFile(request: DeployFileRequest): DeployFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deployFileWithOptions(request, runtime);
}

model DesensitizeDataRequest {
  data?: string(name='Data'),
  sceneCode?: string(name='SceneCode'),
}

model DesensitizeDataResponseBody = {
  desensitizeData?: string(name='DesensitizeData'),
  requestId?: string(name='RequestId'),
}

model DesensitizeDataResponse = {
  headers: map[string]string(name='headers'),
  body: DesensitizeDataResponseBody(name='body'),
}

async function desensitizeDataWithOptions(request: DesensitizeDataRequest, runtime: Util.RuntimeOptions): DesensitizeDataResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DesensitizeData',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function desensitizeData(request: DesensitizeDataRequest): DesensitizeDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return desensitizeDataWithOptions(request, runtime);
}

model EstablishRelationTableToBusinessRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  businessId?: string(name='BusinessId'),
  tableGuid?: string(name='TableGuid'),
  folderId?: string(name='FolderId'),
}

model EstablishRelationTableToBusinessResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model EstablishRelationTableToBusinessResponse = {
  headers: map[string]string(name='headers'),
  body: EstablishRelationTableToBusinessResponseBody(name='body'),
}

async function establishRelationTableToBusinessWithOptions(request: EstablishRelationTableToBusinessRequest, runtime: Util.RuntimeOptions): EstablishRelationTableToBusinessResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'EstablishRelationTableToBusiness',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function establishRelationTableToBusiness(request: EstablishRelationTableToBusinessRequest): EstablishRelationTableToBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return establishRelationTableToBusinessWithOptions(request, runtime);
}

model ExportConnectionsRequest {
  projectId?: long(name='ProjectId'),
  name?: string(name='Name'),
  dataSourceType?: string(name='DataSourceType'),
  subType?: string(name='SubType'),
  envType?: int32(name='EnvType'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
}

model ExportConnectionsResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    dataSources?: [ 
      {
        status?: int32(name='Status'),
        projectId?: int32(name='ProjectId'),
        subType?: string(name='SubType'),
        gmtModified?: string(name='GmtModified'),
        envType?: int32(name='EnvType'),
        connectStatus?: int32(name='ConnectStatus'),
        sequence?: int32(name='Sequence'),
        description?: string(name='Description'),
        dataSourceType?: string(name='DataSourceType'),
        gmtCreate?: string(name='GmtCreate'),
        defaultEngine?: boolean(name='DefaultEngine'),
        shared?: boolean(name='Shared'),
        operator?: string(name='Operator'),
        name?: string(name='Name'),
        content?: string(name='Content'),
        id?: int32(name='Id'),
        bindingCalcEngineId?: int32(name='BindingCalcEngineId'),
        tenantId?: long(name='TenantId'),
      }
    ](name='DataSources'),
  }(name='Data'),
}

model ExportConnectionsResponse = {
  headers: map[string]string(name='headers'),
  body: ExportConnectionsResponseBody(name='body'),
}

async function exportConnectionsWithOptions(request: ExportConnectionsRequest, runtime: Util.RuntimeOptions): ExportConnectionsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportConnections',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportConnections(request: ExportConnectionsRequest): ExportConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportConnectionsWithOptions(request, runtime);
}

model ExportDataSourcesRequest {
  projectId?: long(name='ProjectId'),
  name?: string(name='Name'),
  dataSourceType?: string(name='DataSourceType'),
  subType?: string(name='SubType'),
  envType?: int32(name='EnvType'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
}

model ExportDataSourcesResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    dataSources?: [ 
      {
        status?: int32(name='Status'),
        projectId?: int32(name='ProjectId'),
        subType?: string(name='SubType'),
        gmtModified?: string(name='GmtModified'),
        envType?: int32(name='EnvType'),
        connectStatus?: int32(name='ConnectStatus'),
        sequence?: int32(name='Sequence'),
        description?: string(name='Description'),
        dataSourceType?: string(name='DataSourceType'),
        gmtCreate?: string(name='GmtCreate'),
        defaultEngine?: boolean(name='DefaultEngine'),
        shared?: boolean(name='Shared'),
        operator?: string(name='Operator'),
        name?: string(name='Name'),
        content?: string(name='Content'),
        id?: int32(name='Id'),
        bindingCalcEngineId?: int32(name='BindingCalcEngineId'),
        tenantId?: long(name='TenantId'),
      }
    ](name='DataSources'),
  }(name='Data'),
}

model ExportDataSourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ExportDataSourcesResponseBody(name='body'),
}

async function exportDataSourcesWithOptions(request: ExportDataSourcesRequest, runtime: Util.RuntimeOptions): ExportDataSourcesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportDataSources',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportDataSources(request: ExportDataSourcesRequest): ExportDataSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportDataSourcesWithOptions(request, runtime);
}

model ExportDISyncTasksRequest {
  projectId?: long(name='ProjectId'),
  taskType?: string(name='TaskType'),
  taskParam?: string(name='TaskParam'),
}

model ExportDISyncTasksResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  taskDetail?: {
    realTimeSolution?: string(name='RealTimeSolution'),
  }(name='TaskDetail'),
}

model ExportDISyncTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ExportDISyncTasksResponseBody(name='body'),
}

async function exportDISyncTasksWithOptions(request: ExportDISyncTasksRequest, runtime: Util.RuntimeOptions): ExportDISyncTasksResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["TaskType"] = request.taskType;
  query["TaskParam"] = request.taskParam;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ExportDISyncTasks',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportDISyncTasks(request: ExportDISyncTasksRequest): ExportDISyncTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportDISyncTasksWithOptions(request, runtime);
}

model GenerateDISyncTaskConfigForCreatingRequest {
  projectId?: long(name='ProjectId'),
  taskType?: string(name='TaskType'),
  taskParam?: string(name='TaskParam'),
  clientToken?: string(name='ClientToken'),
}

model GenerateDISyncTaskConfigForCreatingResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    processId?: long(name='ProcessId'),
    message?: string(name='Message'),
  }(name='Data'),
}

model GenerateDISyncTaskConfigForCreatingResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateDISyncTaskConfigForCreatingResponseBody(name='body'),
}

async function generateDISyncTaskConfigForCreatingWithOptions(request: GenerateDISyncTaskConfigForCreatingRequest, runtime: Util.RuntimeOptions): GenerateDISyncTaskConfigForCreatingResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["TaskType"] = request.taskType;
  query["TaskParam"] = request.taskParam;
  query["ClientToken"] = request.clientToken;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GenerateDISyncTaskConfigForCreating',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateDISyncTaskConfigForCreating(request: GenerateDISyncTaskConfigForCreatingRequest): GenerateDISyncTaskConfigForCreatingResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateDISyncTaskConfigForCreatingWithOptions(request, runtime);
}

model GenerateDISyncTaskConfigForUpdatingRequest {
  projectId?: long(name='ProjectId'),
  taskType?: string(name='TaskType'),
  taskParam?: string(name='TaskParam'),
  clientToken?: string(name='ClientToken'),
  taskId?: long(name='TaskId'),
}

model GenerateDISyncTaskConfigForUpdatingResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    processId?: long(name='ProcessId'),
    message?: string(name='Message'),
  }(name='Data'),
}

model GenerateDISyncTaskConfigForUpdatingResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateDISyncTaskConfigForUpdatingResponseBody(name='body'),
}

async function generateDISyncTaskConfigForUpdatingWithOptions(request: GenerateDISyncTaskConfigForUpdatingRequest, runtime: Util.RuntimeOptions): GenerateDISyncTaskConfigForUpdatingResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["TaskType"] = request.taskType;
  query["TaskParam"] = request.taskParam;
  query["ClientToken"] = request.clientToken;
  query["TaskId"] = request.taskId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GenerateDISyncTaskConfigForUpdating',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateDISyncTaskConfigForUpdating(request: GenerateDISyncTaskConfigForUpdatingRequest): GenerateDISyncTaskConfigForUpdatingResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateDISyncTaskConfigForUpdatingWithOptions(request, runtime);
}

model GetBaselineConfigRequest {
  baselineId?: long(name='BaselineId'),
}

model GetBaselineConfigResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    hourSlaDetail?: string(name='HourSlaDetail'),
    isDefault?: boolean(name='IsDefault'),
    owner?: string(name='Owner'),
    projectId?: long(name='ProjectId'),
    priority?: int32(name='Priority'),
    slaMinu?: int32(name='SlaMinu'),
    slaHour?: int32(name='SlaHour'),
    baselineId?: long(name='BaselineId'),
    baselineName?: string(name='BaselineName'),
    hourExpDetail?: string(name='HourExpDetail'),
    useFlag?: boolean(name='UseFlag'),
    expHour?: int32(name='ExpHour'),
    baselineType?: string(name='BaselineType'),
    expMinu?: int32(name='ExpMinu'),
  }(name='Data'),
}

model GetBaselineConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetBaselineConfigResponseBody(name='body'),
}

async function getBaselineConfigWithOptions(request: GetBaselineConfigRequest, runtime: Util.RuntimeOptions): GetBaselineConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetBaselineConfig',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBaselineConfig(request: GetBaselineConfigRequest): GetBaselineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBaselineConfigWithOptions(request, runtime);
}

model GetBaselineKeyPathRequest {
  baselineId?: long(name='BaselineId'),
  bizdate?: string(name='Bizdate'),
  inGroupId?: int32(name='InGroupId'),
}

model GetBaselineKeyPathResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: [ 
    {
      owner?: string(name='Owner'),
      nodeName?: string(name='NodeName'),
      bizdate?: long(name='Bizdate'),
      projectId?: long(name='ProjectId'),
      instanceId?: long(name='InstanceId'),
      prgType?: int32(name='PrgType'),
      nodeId?: long(name='NodeId'),
      inGroupId?: int32(name='InGroupId'),
      runs?: [ 
        {
          status?: string(name='Status'),
          absTime?: long(name='AbsTime'),
          beginRunningTime?: long(name='BeginRunningTime'),
          cycTime?: long(name='CycTime'),
          owner?: string(name='Owner'),
          finishTime?: long(name='FinishTime'),
          projectId?: long(name='ProjectId'),
          beginCast?: long(name='BeginCast'),
          instanceId?: long(name='InstanceId'),
          endCast?: long(name='EndCast'),
          beginWaitResTime?: long(name='BeginWaitResTime'),
          inGroupId?: int32(name='InGroupId'),
          nodeName?: string(name='NodeName'),
          bizdate?: long(name='Bizdate'),
          beginWaitTimeTime?: long(name='BeginWaitTimeTime'),
          nodeId?: long(name='NodeId'),
        }
      ](name='Runs'),
      topics?: [ 
        {
          topicName?: long(name='TopicName'),
          instanceId?: long(name='InstanceId'),
          topicId?: long(name='TopicId'),
          addTime?: long(name='AddTime'),
        }
      ](name='Topics'),
    }
  ](name='Data'),
}

model GetBaselineKeyPathResponse = {
  headers: map[string]string(name='headers'),
  body: GetBaselineKeyPathResponseBody(name='body'),
}

async function getBaselineKeyPathWithOptions(request: GetBaselineKeyPathRequest, runtime: Util.RuntimeOptions): GetBaselineKeyPathResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetBaselineKeyPath',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBaselineKeyPath(request: GetBaselineKeyPathRequest): GetBaselineKeyPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBaselineKeyPathWithOptions(request, runtime);
}

model GetBaselineStatusRequest {
  baselineId?: long(name='BaselineId'),
  bizdate?: string(name='Bizdate'),
  inGroupId?: int32(name='InGroupId'),
}

model GetBaselineStatusResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    status?: string(name='Status'),
    owner?: string(name='Owner'),
    finishTime?: long(name='FinishTime'),
    projectId?: long(name='ProjectId'),
    priority?: int32(name='Priority'),
    endCast?: long(name='EndCast'),
    inGroupId?: int32(name='InGroupId'),
    baselineName?: string(name='BaselineName'),
    baselineId?: long(name='BaselineId'),
    finishStatus?: string(name='FinishStatus'),
    bizdate?: long(name='Bizdate'),
    buffer?: float(name='Buffer'),
    slaTime?: long(name='SlaTime'),
    expTime?: long(name='ExpTime'),
    lastInstance?: {
      status?: string(name='Status'),
      owner?: string(name='Owner'),
      finishTime?: long(name='FinishTime'),
      nodeName?: string(name='NodeName'),
      projectId?: long(name='ProjectId'),
      instanceId?: long(name='InstanceId'),
      endCast?: long(name='EndCast'),
      nodeId?: long(name='NodeId'),
    }(name='LastInstance'),
    blockInstance?: {
      status?: string(name='Status'),
      owner?: string(name='Owner'),
      finishTime?: long(name='FinishTime'),
      nodeName?: string(name='NodeName'),
      projectId?: long(name='ProjectId'),
      instanceId?: long(name='InstanceId'),
      endCast?: long(name='EndCast'),
      nodeId?: long(name='NodeId'),
    }(name='BlockInstance'),
  }(name='Data'),
}

model GetBaselineStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetBaselineStatusResponseBody(name='body'),
}

async function getBaselineStatusWithOptions(request: GetBaselineStatusRequest, runtime: Util.RuntimeOptions): GetBaselineStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetBaselineStatus',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBaselineStatus(request: GetBaselineStatusRequest): GetBaselineStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBaselineStatusWithOptions(request, runtime);
}

model GetBusinessRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  businessId?: long(name='BusinessId'),
}

model GetBusinessResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    owner?: string(name='Owner'),
    description?: string(name='Description'),
    projectId?: string(name='ProjectId'),
    businessId?: long(name='BusinessId'),
    businessName?: string(name='BusinessName'),
    useType?: string(name='UseType'),
  }(name='Data'),
}

model GetBusinessResponse = {
  headers: map[string]string(name='headers'),
  body: GetBusinessResponseBody(name='body'),
}

async function getBusinessWithOptions(request: GetBusinessRequest, runtime: Util.RuntimeOptions): GetBusinessResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetBusiness',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBusiness(request: GetBusinessRequest): GetBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBusinessWithOptions(request, runtime);
}

model GetConnectionMetaRequest {
  projectId?: long(name='ProjectId'),
  datasourceName?: string(name='DatasourceName'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  envType?: string(name='EnvType'),
}

model GetConnectionMetaResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    meta?: string(name='Meta'),
  }(name='Data'),
}

model GetConnectionMetaResponse = {
  headers: map[string]string(name='headers'),
  body: GetConnectionMetaResponseBody(name='body'),
}

async function getConnectionMetaWithOptions(request: GetConnectionMetaRequest, runtime: Util.RuntimeOptions): GetConnectionMetaResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["DatasourceName"] = request.datasourceName;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["EnvType"] = request.envType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetConnectionMeta',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConnectionMeta(request: GetConnectionMetaRequest): GetConnectionMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConnectionMetaWithOptions(request, runtime);
}

model GetDagRequest {
  dagId?: long(name='DagId'),
  projectEnv?: string(name='ProjectEnv'),
}

model GetDagResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    type?: string(name='Type'),
    status?: string(name='Status'),
    finishTime?: long(name='FinishTime'),
    createTime?: long(name='CreateTime'),
    projectId?: long(name='ProjectId'),
    dagId?: long(name='DagId'),
    gmtdate?: long(name='Gmtdate'),
    startTime?: long(name='StartTime'),
    createUser?: string(name='CreateUser'),
    bizdate?: long(name='Bizdate'),
    name?: string(name='Name'),
    modifyTime?: long(name='ModifyTime'),
  }(name='Data'),
}

model GetDagResponse = {
  headers: map[string]string(name='headers'),
  body: GetDagResponseBody(name='body'),
}

async function getDagWithOptions(request: GetDagRequest, runtime: Util.RuntimeOptions): GetDagResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetDag',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDag(request: GetDagRequest): GetDagResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDagWithOptions(request, runtime);
}

model GetDataServiceApiRequest {
  tenantId?: long(name='TenantId'),
  projectId?: long(name='ProjectId'),
  apiId?: long(name='ApiId'),
}

model GetDataServiceApiResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    timeout?: int32(name='Timeout'),
    status?: int32(name='Status'),
    apiId?: long(name='ApiId'),
    apiMode?: int32(name='ApiMode'),
    projectId?: long(name='ProjectId'),
    responseContentType?: int32(name='ResponseContentType'),
    creatorId?: string(name='CreatorId'),
    visibleRange?: int32(name='VisibleRange'),
    modifiedTime?: string(name='ModifiedTime'),
    operatorId?: string(name='OperatorId'),
    groupId?: string(name='GroupId'),
    description?: string(name='Description'),
    folderId?: long(name='FolderId'),
    requestMethod?: int32(name='RequestMethod'),
    createdTime?: string(name='CreatedTime'),
    apiName?: string(name='ApiName'),
    tenantId?: long(name='TenantId'),
    apiPath?: string(name='ApiPath'),
    protocols?: [ int32 ](name='Protocols'),
    registrationDetails?: {
      serviceHost?: string(name='ServiceHost'),
      serviceContentType?: int32(name='ServiceContentType'),
      servicePath?: string(name='ServicePath'),
      successfulResultSample?: string(name='SuccessfulResultSample'),
      failedResultSample?: string(name='FailedResultSample'),
      serviceRequestBodyDescription?: string(name='ServiceRequestBodyDescription'),
      registrationErrorCodes?: [ 
        {
          errorMessage?: string(name='ErrorMessage'),
          errorCode?: string(name='ErrorCode'),
          errorSolution?: string(name='ErrorSolution'),
        }
      ](name='RegistrationErrorCodes'),
      registrationRequestParameters?: [ 
        {
          columnName?: string(name='ColumnName'),
          parameterName?: string(name='ParameterName'),
          parameterPosition?: int32(name='ParameterPosition'),
          parameterDescription?: string(name='ParameterDescription'),
          defaultValue?: string(name='DefaultValue'),
          parameterOperator?: int32(name='ParameterOperator'),
          parameterDataType?: int32(name='ParameterDataType'),
          exampleValue?: string(name='ExampleValue'),
          isRequiredParameter?: boolean(name='IsRequiredParameter'),
        }
      ](name='RegistrationRequestParameters'),
    }(name='RegistrationDetails'),
    scriptDetails?: {
      script?: string(name='Script'),
      isPagedResponse?: boolean(name='IsPagedResponse'),
      scriptRequestParameters?: [ 
        {
          columnName?: string(name='ColumnName'),
          parameterName?: string(name='ParameterName'),
          parameterPosition?: int32(name='ParameterPosition'),
          parameterDescription?: string(name='ParameterDescription'),
          defaultValue?: string(name='DefaultValue'),
          parameterOperator?: int32(name='ParameterOperator'),
          parameterDataType?: int32(name='ParameterDataType'),
          exampleValue?: string(name='ExampleValue'),
          isRequiredParameter?: boolean(name='IsRequiredParameter'),
        }
      ](name='ScriptRequestParameters'),
      scriptResponseParameters?: [ 
        {
          parameterDescription?: string(name='ParameterDescription'),
          columnName?: string(name='ColumnName'),
          parameterName?: string(name='ParameterName'),
          parameterDataType?: int32(name='ParameterDataType'),
          exampleValue?: string(name='ExampleValue'),
        }
      ](name='ScriptResponseParameters'),
      scriptConnection?: {
        tableName?: string(name='TableName'),
        connectionId?: long(name='ConnectionId'),
      }(name='ScriptConnection'),
    }(name='ScriptDetails'),
    wizardDetails?: {
      isPagedResponse?: boolean(name='IsPagedResponse'),
      wizardRequestParameters?: [ 
        {
          columnName?: string(name='ColumnName'),
          parameterName?: string(name='ParameterName'),
          parameterPosition?: int32(name='ParameterPosition'),
          parameterDescription?: string(name='ParameterDescription'),
          defaultValue?: string(name='DefaultValue'),
          parameterOperator?: int32(name='ParameterOperator'),
          parameterDataType?: int32(name='ParameterDataType'),
          exampleValue?: string(name='ExampleValue'),
          isRequiredParameter?: boolean(name='IsRequiredParameter'),
        }
      ](name='WizardRequestParameters'),
      wizardResponseParameters?: [ 
        {
          parameterDescription?: string(name='ParameterDescription'),
          columnName?: string(name='ColumnName'),
          parameterName?: string(name='ParameterName'),
          parameterDataType?: int32(name='ParameterDataType'),
          exampleValue?: string(name='ExampleValue'),
        }
      ](name='WizardResponseParameters'),
      wizardConnection?: {
        tableName?: string(name='TableName'),
        connectionId?: long(name='ConnectionId'),
      }(name='WizardConnection'),
    }(name='WizardDetails'),
  }(name='Data'),
}

model GetDataServiceApiResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataServiceApiResponseBody(name='body'),
}

async function getDataServiceApiWithOptions(request: GetDataServiceApiRequest, runtime: Util.RuntimeOptions): GetDataServiceApiResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetDataServiceApi',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDataServiceApi(request: GetDataServiceApiRequest): GetDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataServiceApiWithOptions(request, runtime);
}

model GetDataServiceApplicationRequest {
  tenantId?: long(name='TenantId'),
  projectId?: long(name='ProjectId'),
  applicationId?: long(name='ApplicationId'),
}

model GetDataServiceApplicationResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    applicationCode?: string(name='ApplicationCode'),
    applicationKey?: string(name='ApplicationKey'),
    applicationSecret?: string(name='ApplicationSecret'),
    projectId?: long(name='ProjectId'),
    applicationName?: string(name='ApplicationName'),
    applicationId?: long(name='ApplicationId'),
  }(name='Data'),
}

model GetDataServiceApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataServiceApplicationResponseBody(name='body'),
}

async function getDataServiceApplicationWithOptions(request: GetDataServiceApplicationRequest, runtime: Util.RuntimeOptions): GetDataServiceApplicationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetDataServiceApplication',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDataServiceApplication(request: GetDataServiceApplicationRequest): GetDataServiceApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataServiceApplicationWithOptions(request, runtime);
}

model GetDataServiceFolderRequest {
  tenantId?: long(name='TenantId'),
  projectId?: long(name='ProjectId'),
  folderId?: long(name='FolderId'),
}

model GetDataServiceFolderResponseBody = {
  requestId?: string(name='RequestId'),
  folder?: {
    parentId?: long(name='ParentId'),
    modifiedTime?: string(name='ModifiedTime'),
    groupId?: string(name='GroupId'),
    folderId?: long(name='FolderId'),
    projectId?: long(name='ProjectId'),
    folderName?: string(name='FolderName'),
    createdTime?: string(name='CreatedTime'),
    tenantId?: long(name='TenantId'),
  }(name='Folder'),
}

model GetDataServiceFolderResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataServiceFolderResponseBody(name='body'),
}

async function getDataServiceFolderWithOptions(request: GetDataServiceFolderRequest, runtime: Util.RuntimeOptions): GetDataServiceFolderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetDataServiceFolder',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDataServiceFolder(request: GetDataServiceFolderRequest): GetDataServiceFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataServiceFolderWithOptions(request, runtime);
}

model GetDataServiceGroupRequest {
  tenantId?: long(name='TenantId'),
  projectId?: long(name='ProjectId'),
  groupId?: string(name='GroupId'),
}

model GetDataServiceGroupResponseBody = {
  requestId?: string(name='RequestId'),
  group?: {
    modifiedTime?: string(name='ModifiedTime'),
    description?: string(name='Description'),
    groupName?: string(name='GroupName'),
    groupId?: string(name='GroupId'),
    projectId?: long(name='ProjectId'),
    apiGatewayGroupId?: string(name='ApiGatewayGroupId'),
    creatorId?: string(name='CreatorId'),
    createdTime?: string(name='CreatedTime'),
    tenantId?: long(name='TenantId'),
  }(name='Group'),
}

model GetDataServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataServiceGroupResponseBody(name='body'),
}

async function getDataServiceGroupWithOptions(request: GetDataServiceGroupRequest, runtime: Util.RuntimeOptions): GetDataServiceGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetDataServiceGroup',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDataServiceGroup(request: GetDataServiceGroupRequest): GetDataServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataServiceGroupWithOptions(request, runtime);
}

model GetDataServicePublishedApiRequest {
  projectId?: long(name='ProjectId'),
  tenantId?: long(name='TenantId'),
  apiId?: long(name='ApiId'),
}

model GetDataServicePublishedApiResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    timeout?: int32(name='Timeout'),
    status?: int32(name='Status'),
    apiId?: long(name='ApiId'),
    apiMode?: int32(name='ApiMode'),
    projectId?: long(name='ProjectId'),
    responseContentType?: int32(name='ResponseContentType'),
    creatorId?: string(name='CreatorId'),
    visibleRange?: int32(name='VisibleRange'),
    modifiedTime?: string(name='ModifiedTime'),
    operatorId?: string(name='OperatorId'),
    groupId?: string(name='GroupId'),
    description?: string(name='Description'),
    requestMethod?: int32(name='RequestMethod'),
    createdTime?: string(name='CreatedTime'),
    apiName?: string(name='ApiName'),
    tenantId?: long(name='TenantId'),
    apiPath?: string(name='ApiPath'),
    protocols?: [ int32 ](name='Protocols'),
    registrationDetails?: {
      serviceHost?: string(name='ServiceHost'),
      serviceContentType?: int32(name='ServiceContentType'),
      servicePath?: string(name='ServicePath'),
      successfulResultSample?: string(name='SuccessfulResultSample'),
      failedResultSample?: string(name='FailedResultSample'),
      serviceRequestBodyDescription?: string(name='ServiceRequestBodyDescription'),
      registrationErrorCodes?: [ 
        {
          errorMessage?: string(name='ErrorMessage'),
          errorCode?: string(name='ErrorCode'),
          errorSolution?: string(name='ErrorSolution'),
        }
      ](name='RegistrationErrorCodes'),
      registrationRequestParameters?: [ 
        {
          parameterName?: string(name='ParameterName'),
          parameterPosition?: int32(name='ParameterPosition'),
          parameterDescription?: string(name='ParameterDescription'),
          defaultValue?: string(name='DefaultValue'),
          parameterOperator?: int32(name='ParameterOperator'),
          exampleValue?: string(name='ExampleValue'),
          parameterDataType?: int32(name='ParameterDataType'),
          isRequiredParameter?: boolean(name='IsRequiredParameter'),
        }
      ](name='RegistrationRequestParameters'),
    }(name='RegistrationDetails'),
    scriptDetails?: {
      isPagedResponse?: boolean(name='IsPagedResponse'),
      successfulResultSample?: string(name='SuccessfulResultSample'),
      failedResultSample?: string(name='FailedResultSample'),
      script?: string(name='Script'),
      scriptErrorCodes?: [ 
        {
          errorMessage?: string(name='ErrorMessage'),
          errorCode?: string(name='ErrorCode'),
          errorSolution?: string(name='ErrorSolution'),
        }
      ](name='ScriptErrorCodes'),
      scriptRequestParameters?: [ 
        {
          parameterName?: string(name='ParameterName'),
          parameterPosition?: int32(name='ParameterPosition'),
          parameterDescription?: string(name='ParameterDescription'),
          defaultValue?: string(name='DefaultValue'),
          parameterOperator?: int32(name='ParameterOperator'),
          exampleValue?: string(name='ExampleValue'),
          parameterDataType?: int32(name='ParameterDataType'),
          isRequiredParameter?: boolean(name='IsRequiredParameter'),
        }
      ](name='ScriptRequestParameters'),
      scriptResponseParameters?: [ 
        {
          parameterDescription?: string(name='ParameterDescription'),
          parameterName?: string(name='ParameterName'),
          exampleValue?: string(name='ExampleValue'),
          parameterDataType?: int32(name='ParameterDataType'),
        }
      ](name='ScriptResponseParameters'),
      scriptConnection?: {
        tableName?: string(name='TableName'),
        connectionId?: long(name='ConnectionId'),
      }(name='ScriptConnection'),
    }(name='ScriptDetails'),
    wizardDetails?: {
      isPagedResponse?: boolean(name='IsPagedResponse'),
      successfulResultSample?: string(name='SuccessfulResultSample'),
      failedResultSample?: string(name='FailedResultSample'),
      wizardErrorCodes?: [ 
        {
          errorMessage?: string(name='ErrorMessage'),
          errorCode?: string(name='ErrorCode'),
          errorSolution?: string(name='ErrorSolution'),
        }
      ](name='WizardErrorCodes'),
      wizardRequestParameters?: [ 
        {
          parameterName?: string(name='ParameterName'),
          parameterPosition?: int32(name='ParameterPosition'),
          parameterDescription?: string(name='ParameterDescription'),
          defaultValue?: string(name='DefaultValue'),
          parameterOperator?: int32(name='ParameterOperator'),
          exampleValue?: string(name='ExampleValue'),
          parameterDataType?: int32(name='ParameterDataType'),
          isRequiredParameter?: boolean(name='IsRequiredParameter'),
        }
      ](name='WizardRequestParameters'),
      wizardResponseParameters?: [ 
        {
          parameterDescription?: string(name='ParameterDescription'),
          parameterName?: string(name='ParameterName'),
          exampleValue?: string(name='ExampleValue'),
          parameterDataType?: int32(name='ParameterDataType'),
        }
      ](name='WizardResponseParameters'),
      wizardConnection?: {
        tableName?: string(name='TableName'),
        connectionId?: long(name='ConnectionId'),
      }(name='WizardConnection'),
    }(name='WizardDetails'),
  }(name='Data'),
}

model GetDataServicePublishedApiResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataServicePublishedApiResponseBody(name='body'),
}

async function getDataServicePublishedApiWithOptions(request: GetDataServicePublishedApiRequest, runtime: Util.RuntimeOptions): GetDataServicePublishedApiResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetDataServicePublishedApi',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDataServicePublishedApi(request: GetDataServicePublishedApiRequest): GetDataServicePublishedApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataServicePublishedApiWithOptions(request, runtime);
}

model GetDataSourceMetaRequest {
  projectId?: long(name='ProjectId'),
  datasourceName?: string(name='DatasourceName'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  envType?: string(name='EnvType'),
}

model GetDataSourceMetaResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    message?: string(name='Message'),
    meta?: string(name='Meta'),
  }(name='Data'),
}

model GetDataSourceMetaResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataSourceMetaResponseBody(name='body'),
}

async function getDataSourceMetaWithOptions(request: GetDataSourceMetaRequest, runtime: Util.RuntimeOptions): GetDataSourceMetaResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["DatasourceName"] = request.datasourceName;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["EnvType"] = request.envType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetDataSourceMeta',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDataSourceMeta(request: GetDataSourceMetaRequest): GetDataSourceMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataSourceMetaWithOptions(request, runtime);
}

model GetDDLJobStatusRequest {
  taskId?: string(name='TaskId'),
}

model GetDDLJobStatusResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    nextTaskId?: string(name='NextTaskId'),
    taskId?: string(name='TaskId'),
    content?: string(name='Content'),
  }(name='Data'),
}

model GetDDLJobStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetDDLJobStatusResponseBody(name='body'),
}

async function getDDLJobStatusWithOptions(request: GetDDLJobStatusRequest, runtime: Util.RuntimeOptions): GetDDLJobStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDDLJobStatus',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDDLJobStatus(request: GetDDLJobStatusRequest): GetDDLJobStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDDLJobStatusWithOptions(request, runtime);
}

model GetDeploymentRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  deploymentId?: long(name='DeploymentId'),
}

model GetDeploymentResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    deployment?: {
      status?: int32(name='Status'),
      errorMessage?: string(name='ErrorMessage'),
      fromEnvironment?: int32(name='FromEnvironment'),
      toEnvironment?: int32(name='ToEnvironment'),
      checkingStatus?: int32(name='CheckingStatus'),
      createTime?: long(name='CreateTime'),
      handlerId?: string(name='HandlerId'),
      creatorId?: string(name='CreatorId'),
      executeTime?: long(name='ExecuteTime'),
      name?: string(name='Name'),
    }(name='Deployment'),
  }(name='Data'),
}

model GetDeploymentResponse = {
  headers: map[string]string(name='headers'),
  body: GetDeploymentResponseBody(name='body'),
}

async function getDeploymentWithOptions(request: GetDeploymentRequest, runtime: Util.RuntimeOptions): GetDeploymentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetDeployment',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeployment(request: GetDeploymentRequest): GetDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeploymentWithOptions(request, runtime);
}

model GetDISyncInstanceInfoRequest {
  projectId?: long(name='ProjectId'),
  taskType?: string(name='TaskType'),
  fileId?: long(name='FileId'),
}

model GetDISyncInstanceInfoResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    message?: string(name='Message'),
    name?: string(name='Name'),
    solutionInfo?: {
      status?: string(name='Status'),
      id?: long(name='Id'),
      creatorName?: string(name='CreatorName'),
      stepDetail?: [ 
        {
          status?: string(name='Status'),
          stepId?: long(name='StepId'),
          stepName?: string(name='StepName'),
        }
      ](name='StepDetail'),
    }(name='SolutionInfo'),
  }(name='Data'),
}

model GetDISyncInstanceInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetDISyncInstanceInfoResponseBody(name='body'),
}

async function getDISyncInstanceInfoWithOptions(request: GetDISyncInstanceInfoRequest, runtime: Util.RuntimeOptions): GetDISyncInstanceInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["TaskType"] = request.taskType;
  query["FileId"] = request.fileId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetDISyncInstanceInfo',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDISyncInstanceInfo(request: GetDISyncInstanceInfoRequest): GetDISyncInstanceInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDISyncInstanceInfoWithOptions(request, runtime);
}

model GetDISyncTaskRequest {
  projectId?: long(name='ProjectId'),
  taskType?: string(name='TaskType'),
  fileId?: long(name='FileId'),
}

model GetDISyncTaskResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    code?: string(name='Code'),
    status?: string(name='Status'),
    message?: string(name='Message'),
    solutionDetail?: {
      status?: string(name='Status'),
      type?: string(name='Type'),
      startTime?: string(name='StartTime'),
      creatorName?: string(name='CreatorName'),
      projectId?: long(name='ProjectId'),
      sourceType?: string(name='SourceType'),
      processContent?: string(name='ProcessContent'),
      name?: string(name='Name'),
      processExtra?: string(name='ProcessExtra'),
      submitTime?: string(name='SubmitTime'),
      id?: long(name='Id'),
    }(name='SolutionDetail'),
  }(name='Data'),
}

model GetDISyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetDISyncTaskResponseBody(name='body'),
}

async function getDISyncTaskWithOptions(request: GetDISyncTaskRequest, runtime: Util.RuntimeOptions): GetDISyncTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["TaskType"] = request.taskType;
  query["FileId"] = request.fileId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetDISyncTask',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDISyncTask(request: GetDISyncTaskRequest): GetDISyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDISyncTaskWithOptions(request, runtime);
}

model GetFileRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  fileId?: long(name='FileId'),
  nodeId?: long(name='NodeId'),
}

model GetFileResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    file?: {
      commitStatus?: int32(name='CommitStatus'),
      autoParsing?: boolean(name='AutoParsing'),
      owner?: string(name='Owner'),
      createTime?: long(name='CreateTime'),
      fileType?: int32(name='FileType'),
      currentVersion?: int32(name='CurrentVersion'),
      bizId?: long(name='BizId'),
      lastEditUser?: string(name='LastEditUser'),
      fileName?: string(name='FileName'),
      connectionName?: string(name='ConnectionName'),
      useType?: string(name='UseType'),
      fileFolderId?: string(name='FileFolderId'),
      parentId?: long(name='ParentId'),
      createUser?: string(name='CreateUser'),
      isMaxCompute?: boolean(name='IsMaxCompute'),
      businessId?: long(name='BusinessId'),
      fileDescription?: string(name='FileDescription'),
      deletedStatus?: string(name='DeletedStatus'),
      lastEditTime?: long(name='LastEditTime'),
      content?: string(name='Content'),
      nodeId?: long(name='NodeId'),
    }(name='File'),
    nodeConfiguration?: {
      rerunMode?: string(name='RerunMode'),
      schedulerType?: string(name='SchedulerType'),
      stop?: boolean(name='Stop'),
      paraValue?: string(name='ParaValue'),
      startEffectDate?: long(name='StartEffectDate'),
      endEffectDate?: long(name='EndEffectDate'),
      cycleType?: string(name='CycleType'),
      dependentNodeIdList?: string(name='DependentNodeIdList'),
      resourceGroupId?: long(name='ResourceGroupId'),
      dependentType?: string(name='DependentType'),
      autoRerunTimes?: int32(name='AutoRerunTimes'),
      autoRerunIntervalMillis?: int32(name='AutoRerunIntervalMillis'),
      cronExpress?: string(name='CronExpress'),
      inputList?: [ 
        {
          input?: string(name='Input'),
          parseType?: string(name='ParseType'),
        }
      ](name='InputList'),
      outputList?: [ 
        {
          refTableName?: string(name='RefTableName'),
          output?: string(name='Output'),
        }
      ](name='OutputList'),
    }(name='NodeConfiguration'),
  }(name='Data'),
}

model GetFileResponse = {
  headers: map[string]string(name='headers'),
  body: GetFileResponseBody(name='body'),
}

async function getFileWithOptions(request: GetFileRequest, runtime: Util.RuntimeOptions): GetFileResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetFile',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFile(request: GetFileRequest): GetFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileWithOptions(request, runtime);
}

model GetFileTypeStatisticRequest {
  projectId?: long(name='ProjectId'),
  projectEnv?: string(name='ProjectEnv'),
}

model GetFileTypeStatisticResponseBody = {
  requestId?: string(name='RequestId'),
  programTypeAndCounts?: [ 
    {
      count?: int32(name='Count'),
      programType?: string(name='ProgramType'),
    }
  ](name='ProgramTypeAndCounts'),
}

model GetFileTypeStatisticResponse = {
  headers: map[string]string(name='headers'),
  body: GetFileTypeStatisticResponseBody(name='body'),
}

async function getFileTypeStatisticWithOptions(request: GetFileTypeStatisticRequest, runtime: Util.RuntimeOptions): GetFileTypeStatisticResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetFileTypeStatistic',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFileTypeStatistic(request: GetFileTypeStatisticRequest): GetFileTypeStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileTypeStatisticWithOptions(request, runtime);
}

model GetFileVersionRequest {
  fileId?: long(name='FileId'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  fileVersion?: int32(name='FileVersion'),
}

model GetFileVersionResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    fileContent?: string(name='FileContent'),
    isCurrentProd?: boolean(name='IsCurrentProd'),
    status?: string(name='Status'),
    nodeContent?: string(name='NodeContent'),
    commitUser?: string(name='CommitUser'),
    comment?: string(name='Comment'),
    filePropertyContent?: string(name='FilePropertyContent'),
    fileName?: string(name='FileName'),
    useType?: string(name='UseType'),
    changeType?: string(name='ChangeType'),
    fileVersion?: int32(name='FileVersion'),
    commitTime?: long(name='CommitTime'),
    nodeId?: long(name='NodeId'),
  }(name='Data'),
}

model GetFileVersionResponse = {
  headers: map[string]string(name='headers'),
  body: GetFileVersionResponseBody(name='body'),
}

async function getFileVersionWithOptions(request: GetFileVersionRequest, runtime: Util.RuntimeOptions): GetFileVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetFileVersion',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFileVersion(request: GetFileVersionRequest): GetFileVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileVersionWithOptions(request, runtime);
}

model GetFolderRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  folderId?: string(name='FolderId'),
  folderPath?: string(name='FolderPath'),
}

model GetFolderResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    folderPath?: string(name='FolderPath'),
    folderId?: string(name='FolderId'),
  }(name='Data'),
}

model GetFolderResponse = {
  headers: map[string]string(name='headers'),
  body: GetFolderResponseBody(name='body'),
}

async function getFolderWithOptions(request: GetFolderRequest, runtime: Util.RuntimeOptions): GetFolderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetFolder',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFolder(request: GetFolderRequest): GetFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFolderWithOptions(request, runtime);
}

model GetInstanceRequest {
  instanceId?: long(name='InstanceId'),
  projectEnv?: string(name='ProjectEnv'),
}

model GetInstanceResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    status?: string(name='Status'),
    cycTime?: long(name='CycTime'),
    beginRunningTime?: long(name='BeginRunningTime'),
    finishTime?: long(name='FinishTime'),
    createTime?: long(name='CreateTime'),
    dagId?: long(name='DagId'),
    priority?: int32(name='Priority'),
    taskType?: string(name='TaskType'),
    paramValues?: string(name='ParamValues'),
    connection?: string(name='Connection'),
    baselineId?: long(name='BaselineId'),
    dqcType?: int32(name='DqcType'),
    dagType?: string(name='DagType'),
    businessId?: long(name='BusinessId'),
    taskRerunTime?: int32(name='TaskRerunTime'),
    modifyTime?: long(name='ModifyTime'),
    repeatability?: boolean(name='Repeatability'),
    repeatInterval?: long(name='RepeatInterval'),
    instanceId?: long(name='InstanceId'),
    beginWaitResTime?: long(name='BeginWaitResTime'),
    relatedFlowId?: long(name='RelatedFlowId'),
    bizdate?: long(name='Bizdate'),
    nodeName?: string(name='NodeName'),
    beginWaitTimeTime?: long(name='BeginWaitTimeTime'),
    dqcDescription?: string(name='DqcDescription'),
    nodeId?: long(name='NodeId'),
  }(name='Data'),
}

model GetInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceResponseBody(name='body'),
}

async function getInstanceWithOptions(request: GetInstanceRequest, runtime: Util.RuntimeOptions): GetInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetInstance',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstance(request: GetInstanceRequest): GetInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceWithOptions(request, runtime);
}

model GetInstanceConsumeTimeRankRequest {
  projectId?: long(name='ProjectId'),
  bizdate?: string(name='Bizdate'),
}

model GetInstanceConsumeTimeRankResponseBody = {
  requestId?: string(name='RequestId'),
  instanceConsumeTimeRank?: {
    updateTime?: long(name='UpdateTime'),
    consumeTimeRank?: [ 
      {
        owner?: string(name='Owner'),
        nodeName?: string(name='NodeName'),
        bizdate?: long(name='Bizdate'),
        instanceId?: long(name='InstanceId'),
        prgType?: int32(name='PrgType'),
        nodeId?: long(name='NodeId'),
        consumed?: long(name='Consumed'),
      }
    ](name='ConsumeTimeRank'),
  }(name='InstanceConsumeTimeRank'),
}

model GetInstanceConsumeTimeRankResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceConsumeTimeRankResponseBody(name='body'),
}

async function getInstanceConsumeTimeRankWithOptions(request: GetInstanceConsumeTimeRankRequest, runtime: Util.RuntimeOptions): GetInstanceConsumeTimeRankResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceConsumeTimeRank',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceConsumeTimeRank(request: GetInstanceConsumeTimeRankRequest): GetInstanceConsumeTimeRankResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceConsumeTimeRankWithOptions(request, runtime);
}

model GetInstanceCountTrendRequest {
  projectId?: long(name='ProjectId'),
  beginDate?: string(name='BeginDate'),
  endDate?: string(name='EndDate'),
}

model GetInstanceCountTrendResponseBody = {
  requestId?: string(name='RequestId'),
  instanceCounts?: [ 
    {
      date?: long(name='Date'),
      count?: int32(name='Count'),
    }
  ](name='InstanceCounts'),
}

model GetInstanceCountTrendResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceCountTrendResponseBody(name='body'),
}

async function getInstanceCountTrendWithOptions(request: GetInstanceCountTrendRequest, runtime: Util.RuntimeOptions): GetInstanceCountTrendResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceCountTrend',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceCountTrend(request: GetInstanceCountTrendRequest): GetInstanceCountTrendResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceCountTrendWithOptions(request, runtime);
}

model GetInstanceErrorRankRequest {
  projectId?: long(name='ProjectId'),
}

model GetInstanceErrorRankResponseBody = {
  requestId?: string(name='RequestId'),
  instanceErrorRank?: {
    updateTime?: long(name='UpdateTime'),
    errorRank?: [ 
      {
        owner?: string(name='Owner'),
        nodeName?: string(name='NodeName'),
        projectId?: long(name='ProjectId'),
        nodeId?: long(name='NodeId'),
        count?: int32(name='Count'),
        prgType?: int32(name='PrgType'),
      }
    ](name='ErrorRank'),
  }(name='InstanceErrorRank'),
}

model GetInstanceErrorRankResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceErrorRankResponseBody(name='body'),
}

async function getInstanceErrorRankWithOptions(request: GetInstanceErrorRankRequest, runtime: Util.RuntimeOptions): GetInstanceErrorRankResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceErrorRank',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceErrorRank(request: GetInstanceErrorRankRequest): GetInstanceErrorRankResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceErrorRankWithOptions(request, runtime);
}

model GetInstanceLogRequest {
  instanceId?: long(name='InstanceId'),
  projectEnv?: string(name='ProjectEnv'),
}

model GetInstanceLogResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model GetInstanceLogResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceLogResponseBody(name='body'),
}

async function getInstanceLogWithOptions(request: GetInstanceLogRequest, runtime: Util.RuntimeOptions): GetInstanceLogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceLog',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceLog(request: GetInstanceLogRequest): GetInstanceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceLogWithOptions(request, runtime);
}

model GetInstanceStatusCountRequest {
  projectId?: long(name='ProjectId'),
  projectEnv?: string(name='ProjectEnv'),
  bizDate?: string(name='BizDate'),
}

model GetInstanceStatusCountResponseBody = {
  requestId?: string(name='RequestId'),
  statusCount?: {
    failureCount?: int32(name='FailureCount'),
    waitTimeCount?: int32(name='WaitTimeCount'),
    runningCount?: int32(name='RunningCount'),
    successCount?: int32(name='SuccessCount'),
    totalCount?: int32(name='TotalCount'),
    notRunCount?: int32(name='NotRunCount'),
    waitResCount?: int32(name='WaitResCount'),
  }(name='StatusCount'),
}

model GetInstanceStatusCountResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceStatusCountResponseBody(name='body'),
}

async function getInstanceStatusCountWithOptions(request: GetInstanceStatusCountRequest, runtime: Util.RuntimeOptions): GetInstanceStatusCountResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceStatusCount',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceStatusCount(request: GetInstanceStatusCountRequest): GetInstanceStatusCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceStatusCountWithOptions(request, runtime);
}

model GetInstanceStatusStatisticRequest {
  projectId?: long(name='ProjectId'),
  projectEnv?: string(name='ProjectEnv'),
  bizDate?: string(name='BizDate'),
}

model GetInstanceStatusStatisticResponseBody = {
  requestId?: string(name='RequestId'),
  statusCount?: {
    failureCount?: int32(name='FailureCount'),
    waitTimeCount?: int32(name='WaitTimeCount'),
    runningCount?: int32(name='RunningCount'),
    successCount?: int32(name='SuccessCount'),
    totalCount?: int32(name='TotalCount'),
    notRunCount?: int32(name='NotRunCount'),
    waitResCount?: int32(name='WaitResCount'),
  }(name='StatusCount'),
}

model GetInstanceStatusStatisticResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceStatusStatisticResponseBody(name='body'),
}

async function getInstanceStatusStatisticWithOptions(request: GetInstanceStatusStatisticRequest, runtime: Util.RuntimeOptions): GetInstanceStatusStatisticResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceStatusStatistic',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceStatusStatistic(request: GetInstanceStatusStatisticRequest): GetInstanceStatusStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceStatusStatisticWithOptions(request, runtime);
}

model GetManualDagInstancesRequest {
  projectEnv?: string(name='ProjectEnv'),
  projectName?: string(name='ProjectName'),
  dagId?: string(name='DagId'),
}

model GetManualDagInstancesResponseBody = {
  requestId?: string(name='RequestId'),
  instances?: [ 
    {
      status?: string(name='Status'),
      beginRunningTime?: long(name='BeginRunningTime'),
      bizDate?: long(name='BizDate'),
      cycTime?: long(name='CycTime'),
      finishTime?: long(name='FinishTime'),
      createTime?: long(name='CreateTime'),
      dagId?: long(name='DagId'),
      instanceId?: long(name='InstanceId'),
      beginWaitResTime?: long(name='BeginWaitResTime'),
      taskType?: string(name='TaskType'),
      paramValues?: string(name='ParamValues'),
      dagType?: string(name='DagType'),
      nodeName?: string(name='NodeName'),
      beginWaitTimeTime?: long(name='BeginWaitTimeTime'),
      nodeId?: long(name='NodeId'),
      modifyTime?: long(name='ModifyTime'),
    }
  ](name='Instances'),
}

model GetManualDagInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: GetManualDagInstancesResponseBody(name='body'),
}

async function getManualDagInstancesWithOptions(request: GetManualDagInstancesRequest, runtime: Util.RuntimeOptions): GetManualDagInstancesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetManualDagInstances',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getManualDagInstances(request: GetManualDagInstancesRequest): GetManualDagInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getManualDagInstancesWithOptions(request, runtime);
}

model GetMetaCategoryRequest {
  parentCategoryId?: long(name='ParentCategoryId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model GetMetaCategoryResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    dataEntityList?: [ 
      {
        depth?: int32(name='Depth'),
        comment?: string(name='Comment'),
        modifiedTime?: long(name='ModifiedTime'),
        createTime?: long(name='CreateTime'),
        categoryId?: long(name='CategoryId'),
        lastOperatorId?: string(name='LastOperatorId'),
        name?: string(name='Name'),
        parentCategoryId?: long(name='ParentCategoryId'),
        ownerId?: string(name='OwnerId'),
      }
    ](name='DataEntityList'),
  }(name='Data'),
}

model GetMetaCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaCategoryResponseBody(name='body'),
}

async function getMetaCategoryWithOptions(request: GetMetaCategoryRequest, runtime: Util.RuntimeOptions): GetMetaCategoryResponse {
  Util.validateModel(request);
  var query = {};
  query["ParentCategoryId"] = request.parentCategoryId;
  query["PageNum"] = request.pageNum;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaCategory',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMetaCategory(request: GetMetaCategoryRequest): GetMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaCategoryWithOptions(request, runtime);
}

model GetMetaColumnLineageRequest {
  columnGuid?: string(name='ColumnGuid'),
  direction?: string(name='Direction'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  columnName?: string(name='ColumnName'),
  dataSourceType?: string(name='DataSourceType'),
}

model GetMetaColumnLineageResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    dataEntityList?: [ 
      {
        columnGuid?: string(name='ColumnGuid'),
        columnName?: string(name='ColumnName'),
        tableName?: string(name='TableName'),
        databaseName?: string(name='DatabaseName'),
        clusterId?: string(name='ClusterId'),
      }
    ](name='DataEntityList'),
  }(name='Data'),
}

model GetMetaColumnLineageResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaColumnLineageResponseBody(name='body'),
}

async function getMetaColumnLineageWithOptions(request: GetMetaColumnLineageRequest, runtime: Util.RuntimeOptions): GetMetaColumnLineageResponse {
  Util.validateModel(request);
  var query = {};
  query["ColumnGuid"] = request.columnGuid;
  query["Direction"] = request.direction;
  query["PageNum"] = request.pageNum;
  query["PageSize"] = request.pageSize;
  query["ClusterId"] = request.clusterId;
  query["DatabaseName"] = request.databaseName;
  query["TableName"] = request.tableName;
  query["ColumnName"] = request.columnName;
  query["DataSourceType"] = request.dataSourceType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaColumnLineage',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMetaColumnLineage(request: GetMetaColumnLineageRequest): GetMetaColumnLineageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaColumnLineageWithOptions(request, runtime);
}

model GetMetaDBInfoRequest {
  appGuid?: string(name='AppGuid'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  dataSourceType?: string(name='DataSourceType'),
}

model GetMetaDBInfoResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    type?: string(name='Type'),
    comment?: string(name='Comment'),
    createTime?: long(name='CreateTime'),
    projectId?: long(name='ProjectId'),
    projectName?: string(name='ProjectName'),
    appGuid?: string(name='AppGuid'),
    ownerName?: string(name='OwnerName'),
    ownerId?: string(name='OwnerId'),
    envType?: int32(name='EnvType'),
    projectNameCn?: string(name='ProjectNameCn'),
    endpoint?: string(name='Endpoint'),
    clusterBizId?: string(name='ClusterBizId'),
    name?: string(name='Name'),
    location?: string(name='Location'),
    tenantId?: long(name='TenantId'),
    modifyTime?: long(name='ModifyTime'),
  }(name='Data'),
}

model GetMetaDBInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaDBInfoResponseBody(name='body'),
}

async function getMetaDBInfoWithOptions(request: GetMetaDBInfoRequest, runtime: Util.RuntimeOptions): GetMetaDBInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaDBInfo',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMetaDBInfo(request: GetMetaDBInfoRequest): GetMetaDBInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaDBInfoWithOptions(request, runtime);
}

model GetMetaDBTableListRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  appGuid?: string(name='AppGuid'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  dataSourceType?: string(name='DataSourceType'),
}

model GetMetaDBTableListResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    tableEntityList?: [ 
      {
        tableName?: string(name='TableName'),
        tableGuid?: string(name='TableGuid'),
        databaseName?: string(name='DatabaseName'),
      }
    ](name='TableEntityList'),
  }(name='Data'),
}

model GetMetaDBTableListResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaDBTableListResponseBody(name='body'),
}

async function getMetaDBTableListWithOptions(request: GetMetaDBTableListRequest, runtime: Util.RuntimeOptions): GetMetaDBTableListResponse {
  Util.validateModel(request);
  var query = {};
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["AppGuid"] = request.appGuid;
  query["ClusterId"] = request.clusterId;
  query["DatabaseName"] = request.databaseName;
  query["DataSourceType"] = request.dataSourceType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaDBTableList',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMetaDBTableList(request: GetMetaDBTableListRequest): GetMetaDBTableListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaDBTableListWithOptions(request, runtime);
}

model GetMetaTableBasicInfoRequest {
  tableGuid?: string(name='TableGuid'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  dataSourceType?: string(name='DataSourceType'),
  extension?: boolean(name='Extension'),
}

model GetMetaTableBasicInfoResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    tableName?: string(name='TableName'),
    favoriteCount?: long(name='FavoriteCount'),
    comment?: string(name='Comment'),
    columnCount?: int32(name='ColumnCount'),
    createTime?: long(name='CreateTime'),
    projectId?: long(name='ProjectId'),
    ownerId?: string(name='OwnerId'),
    envType?: int32(name='EnvType'),
    databaseName?: string(name='DatabaseName'),
    isVisible?: int32(name='IsVisible'),
    tableGuid?: string(name='TableGuid'),
    readCount?: long(name='ReadCount'),
    clusterId?: string(name='ClusterId'),
    isPartitionTable?: boolean(name='IsPartitionTable'),
    isView?: boolean(name='IsView'),
    lifeCycle?: int32(name='LifeCycle'),
    projectName?: string(name='ProjectName'),
    viewCount?: long(name='ViewCount'),
    lastAccessTime?: long(name='LastAccessTime'),
    dataSize?: long(name='DataSize'),
    lastModifyTime?: long(name='LastModifyTime'),
    lastDdlTime?: long(name='LastDdlTime'),
    partitionKeys?: string(name='PartitionKeys'),
    location?: string(name='Location'),
    caption?: string(name='Caption'),
    tenantId?: long(name='TenantId'),
  }(name='Data'),
}

model GetMetaTableBasicInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableBasicInfoResponseBody(name='body'),
}

async function getMetaTableBasicInfoWithOptions(request: GetMetaTableBasicInfoRequest, runtime: Util.RuntimeOptions): GetMetaTableBasicInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableBasicInfo',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMetaTableBasicInfo(request: GetMetaTableBasicInfoRequest): GetMetaTableBasicInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableBasicInfoWithOptions(request, runtime);
}

model GetMetaTableChangeLogRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  tableGuid?: string(name='TableGuid'),
  changeType?: string(name='ChangeType'),
  objectType?: string(name='ObjectType'),
  startDate?: string(name='StartDate'),
  endDate?: string(name='EndDate'),
}

model GetMetaTableChangeLogResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    dataEntityList?: [ 
      {
        objectType?: string(name='ObjectType'),
        modifiedTime?: long(name='ModifiedTime'),
        createTime?: long(name='CreateTime'),
        changeContent?: string(name='ChangeContent'),
        operator?: string(name='Operator'),
        changeType?: string(name='ChangeType'),
      }
    ](name='DataEntityList'),
  }(name='Data'),
}

model GetMetaTableChangeLogResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableChangeLogResponseBody(name='body'),
}

async function getMetaTableChangeLogWithOptions(request: GetMetaTableChangeLogRequest, runtime: Util.RuntimeOptions): GetMetaTableChangeLogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableChangeLog',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMetaTableChangeLog(request: GetMetaTableChangeLogRequest): GetMetaTableChangeLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableChangeLogWithOptions(request, runtime);
}

model GetMetaTableColumnRequest {
  tableGuid?: string(name='TableGuid'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  dataSourceType?: string(name='DataSourceType'),
}

model GetMetaTableColumnResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    columnList?: [ 
      {
        columnGuid?: string(name='ColumnGuid'),
        columnName?: string(name='ColumnName'),
        isPartitionColumn?: boolean(name='IsPartitionColumn'),
        comment?: string(name='Comment'),
        columnType?: string(name='ColumnType'),
        isPrimaryKey?: boolean(name='IsPrimaryKey'),
        position?: int32(name='Position'),
        caption?: string(name='Caption'),
        isForeignKey?: boolean(name='IsForeignKey'),
      }
    ](name='ColumnList'),
  }(name='Data'),
}

model GetMetaTableColumnResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableColumnResponseBody(name='body'),
}

async function getMetaTableColumnWithOptions(request: GetMetaTableColumnRequest, runtime: Util.RuntimeOptions): GetMetaTableColumnResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableColumn',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMetaTableColumn(request: GetMetaTableColumnRequest): GetMetaTableColumnResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableColumnWithOptions(request, runtime);
}

model GetMetaTableFullInfoRequest {
  tableGuid?: string(name='TableGuid'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  dataSourceType?: string(name='DataSourceType'),
}

model GetMetaTableFullInfoResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    tableName?: string(name='TableName'),
    comment?: string(name='Comment'),
    lifeCycle?: int32(name='LifeCycle'),
    createTime?: long(name='CreateTime'),
    projectName?: string(name='ProjectName'),
    projectId?: long(name='ProjectId'),
    ownerId?: string(name='OwnerId'),
    envType?: int32(name='EnvType'),
    lastAccessTime?: long(name='LastAccessTime'),
    dataSize?: long(name='DataSize'),
    lastModifyTime?: long(name='LastModifyTime'),
    databaseName?: string(name='DatabaseName'),
    isVisible?: int32(name='IsVisible'),
    totalColumnCount?: long(name='TotalColumnCount'),
    tableGuid?: string(name='TableGuid'),
    partitionKeys?: string(name='PartitionKeys'),
    lastDdlTime?: long(name='LastDdlTime'),
    location?: string(name='Location'),
    clusterId?: string(name='ClusterId'),
    tenantId?: long(name='TenantId'),
    columnList?: [ 
      {
        columnName?: string(name='ColumnName'),
        columnGuid?: string(name='ColumnGuid'),
        isPartitionColumn?: boolean(name='IsPartitionColumn'),
        comment?: string(name='Comment'),
        columnType?: string(name='ColumnType'),
        isPrimaryKey?: boolean(name='IsPrimaryKey'),
        position?: int32(name='Position'),
        caption?: string(name='Caption'),
        isForeignKey?: boolean(name='IsForeignKey'),
      }
    ](name='ColumnList'),
  }(name='Data'),
}

model GetMetaTableFullInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableFullInfoResponseBody(name='body'),
}

async function getMetaTableFullInfoWithOptions(request: GetMetaTableFullInfoRequest, runtime: Util.RuntimeOptions): GetMetaTableFullInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableFullInfo',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMetaTableFullInfo(request: GetMetaTableFullInfoRequest): GetMetaTableFullInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableFullInfoWithOptions(request, runtime);
}

model GetMetaTableIntroWikiRequest {
  tableGuid?: string(name='TableGuid'),
  wikiVersion?: long(name='WikiVersion'),
}

model GetMetaTableIntroWikiResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    modifiedTime?: long(name='ModifiedTime'),
    version?: long(name='Version'),
    createTime?: long(name='CreateTime'),
    creatorName?: string(name='CreatorName'),
    content?: string(name='Content'),
    creator?: string(name='Creator'),
  }(name='Data'),
}

model GetMetaTableIntroWikiResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableIntroWikiResponseBody(name='body'),
}

async function getMetaTableIntroWikiWithOptions(request: GetMetaTableIntroWikiRequest, runtime: Util.RuntimeOptions): GetMetaTableIntroWikiResponse {
  Util.validateModel(request);
  var query = {};
  query["TableGuid"] = request.tableGuid;
  query["WikiVersion"] = request.wikiVersion;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableIntroWiki',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMetaTableIntroWiki(request: GetMetaTableIntroWikiRequest): GetMetaTableIntroWikiResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableIntroWikiWithOptions(request, runtime);
}

model GetMetaTableLineageRequest {
  tableGuid?: string(name='TableGuid'),
  direction?: string(name='Direction'),
  nextPrimaryKey?: string(name='NextPrimaryKey'),
  pageSize?: int32(name='PageSize'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  dataSourceType?: string(name='DataSourceType'),
}

model GetMetaTableLineageResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    nextPrimaryKey?: string(name='NextPrimaryKey'),
    hasNext?: boolean(name='HasNext'),
    dataEntityList?: [ 
      {
        tableName?: string(name='TableName'),
        tableGuid?: string(name='TableGuid'),
      }
    ](name='DataEntityList'),
  }(name='Data'),
}

model GetMetaTableLineageResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableLineageResponseBody(name='body'),
}

async function getMetaTableLineageWithOptions(request: GetMetaTableLineageRequest, runtime: Util.RuntimeOptions): GetMetaTableLineageResponse {
  Util.validateModel(request);
  var query = {};
  query["TableGuid"] = request.tableGuid;
  query["Direction"] = request.direction;
  query["NextPrimaryKey"] = request.nextPrimaryKey;
  query["PageSize"] = request.pageSize;
  query["ClusterId"] = request.clusterId;
  query["DatabaseName"] = request.databaseName;
  query["TableName"] = request.tableName;
  query["DataSourceType"] = request.dataSourceType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableLineage',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMetaTableLineage(request: GetMetaTableLineageRequest): GetMetaTableLineageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableLineageWithOptions(request, runtime);
}

model GetMetaTableListByCategoryRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  categoryId?: long(name='CategoryId'),
}

model GetMetaTableListByCategoryResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    tableGuidList?: [ string ](name='TableGuidList'),
  }(name='Data'),
}

model GetMetaTableListByCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableListByCategoryResponseBody(name='body'),
}

async function getMetaTableListByCategoryWithOptions(request: GetMetaTableListByCategoryRequest, runtime: Util.RuntimeOptions): GetMetaTableListByCategoryResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableListByCategory',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMetaTableListByCategory(request: GetMetaTableListByCategoryRequest): GetMetaTableListByCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableListByCategoryWithOptions(request, runtime);
}

model GetMetaTableOutputRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  tableGuid?: string(name='TableGuid'),
  startDate?: string(name='StartDate'),
  endDate?: string(name='EndDate'),
}

model GetMetaTableOutputResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    dataEntityList?: [ 
      {
        endTime?: string(name='EndTime'),
        taskInstanceId?: long(name='TaskInstanceId'),
        startTime?: string(name='StartTime'),
        projectId?: long(name='ProjectId'),
        waitTime?: string(name='WaitTime'),
        tableGuid?: string(name='TableGuid'),
        taskId?: string(name='TaskId'),
      }
    ](name='DataEntityList'),
  }(name='Data'),
}

model GetMetaTableOutputResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableOutputResponseBody(name='body'),
}

async function getMetaTableOutputWithOptions(request: GetMetaTableOutputRequest, runtime: Util.RuntimeOptions): GetMetaTableOutputResponse {
  Util.validateModel(request);
  var query = {};
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["TableGuid"] = request.tableGuid;
  query["StartDate"] = request.startDate;
  query["EndDate"] = request.endDate;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableOutput',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMetaTableOutput(request: GetMetaTableOutputRequest): GetMetaTableOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableOutputWithOptions(request, runtime);
}

model GetMetaTablePartitionRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  tableGuid?: string(name='TableGuid'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  dataSourceType?: string(name='DataSourceType'),
}

model GetMetaTablePartitionResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    dataEntityList?: [ 
      {
        partitionPath?: string(name='PartitionPath'),
        dataSize?: long(name='DataSize'),
        partitionName?: string(name='PartitionName'),
        comment?: string(name='Comment'),
        modifiedTime?: long(name='ModifiedTime'),
        createTime?: long(name='CreateTime'),
        recordCount?: long(name='RecordCount'),
        partitionType?: string(name='PartitionType'),
        partitionGuid?: string(name='PartitionGuid'),
        partitionLocation?: string(name='PartitionLocation'),
        tableGuid?: string(name='TableGuid'),
      }
    ](name='DataEntityList'),
  }(name='Data'),
}

model GetMetaTablePartitionResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTablePartitionResponseBody(name='body'),
}

async function getMetaTablePartitionWithOptions(request: GetMetaTablePartitionRequest, runtime: Util.RuntimeOptions): GetMetaTablePartitionResponse {
  Util.validateModel(request);
  var query = {};
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["TableGuid"] = request.tableGuid;
  query["ClusterId"] = request.clusterId;
  query["DatabaseName"] = request.databaseName;
  query["TableName"] = request.tableName;
  query["DataSourceType"] = request.dataSourceType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTablePartition',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMetaTablePartition(request: GetMetaTablePartitionRequest): GetMetaTablePartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTablePartitionWithOptions(request, runtime);
}

model GetMetaTableThemeLevelRequest {
  tableGuid?: string(name='TableGuid'),
  dataSourceType?: string(name='DataSourceType'),
}

model GetMetaTableThemeLevelResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  entity?: {
    theme?: [ 
      {
        parentId?: long(name='ParentId'),
        name?: string(name='Name'),
        themeId?: long(name='ThemeId'),
        level?: int32(name='Level'),
      }
    ](name='Theme'),
    level?: [ 
      {
        type?: int32(name='Type'),
        description?: string(name='Description'),
        name?: string(name='Name'),
        levelId?: long(name='LevelId'),
      }
    ](name='Level'),
  }(name='Entity'),
}

model GetMetaTableThemeLevelResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaTableThemeLevelResponseBody(name='body'),
}

async function getMetaTableThemeLevelWithOptions(request: GetMetaTableThemeLevelRequest, runtime: Util.RuntimeOptions): GetMetaTableThemeLevelResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableThemeLevel',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMetaTableThemeLevel(request: GetMetaTableThemeLevelRequest): GetMetaTableThemeLevelResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableThemeLevelWithOptions(request, runtime);
}

model GetMigrationProcessRequest {
  projectId?: long(name='ProjectId'),
  migrationId?: long(name='MigrationId'),
}

model GetMigrationProcessResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: [ 
    {
      taskStatus?: string(name='TaskStatus'),
      taskName?: string(name='TaskName'),
    }
  ](name='Data'),
}

model GetMigrationProcessResponse = {
  headers: map[string]string(name='headers'),
  body: GetMigrationProcessResponseBody(name='body'),
}

async function getMigrationProcessWithOptions(request: GetMigrationProcessRequest, runtime: Util.RuntimeOptions): GetMigrationProcessResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetMigrationProcess',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMigrationProcess(request: GetMigrationProcessRequest): GetMigrationProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMigrationProcessWithOptions(request, runtime);
}

model GetNodeRequest {
  nodeId?: long(name='NodeId'),
  projectEnv?: string(name='ProjectEnv'),
}

model GetNodeResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    schedulerType?: string(name='SchedulerType'),
    repeatInterval?: long(name='RepeatInterval'),
    repeatability?: string(name='Repeatability'),
    projectId?: long(name='ProjectId'),
    programType?: string(name='ProgramType'),
    priority?: int32(name='Priority'),
    ownerId?: string(name='OwnerId'),
    connection?: string(name='Connection'),
    paramValues?: string(name='ParamValues'),
    relatedFlowId?: long(name='RelatedFlowId'),
    dqcType?: int32(name='DqcType'),
    baselineId?: long(name='BaselineId'),
    description?: string(name='Description'),
    nodeName?: string(name='NodeName'),
    resGroupName?: string(name='ResGroupName'),
    businessId?: long(name='BusinessId'),
    dqcDescription?: string(name='DqcDescription'),
    cronExpress?: string(name='CronExpress'),
    nodeId?: long(name='NodeId'),
  }(name='Data'),
}

model GetNodeResponse = {
  headers: map[string]string(name='headers'),
  body: GetNodeResponseBody(name='body'),
}

async function getNodeWithOptions(request: GetNodeRequest, runtime: Util.RuntimeOptions): GetNodeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetNode',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNode(request: GetNodeRequest): GetNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeWithOptions(request, runtime);
}

model GetNodeChildrenRequest {
  projectEnv?: string(name='ProjectEnv'),
  nodeId?: long(name='NodeId'),
}

model GetNodeChildrenResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    nodes?: [ 
      {
        schedulerType?: string(name='SchedulerType'),
        baselineId?: long(name='BaselineId'),
        repeatability?: boolean(name='Repeatability'),
        nodeName?: string(name='NodeName'),
        projectId?: long(name='ProjectId'),
        programType?: string(name='ProgramType'),
        priority?: int32(name='Priority'),
        ownerId?: string(name='OwnerId'),
        cronExpress?: string(name='CronExpress'),
        nodeId?: long(name='NodeId'),
      }
    ](name='Nodes'),
  }(name='Data'),
}

model GetNodeChildrenResponse = {
  headers: map[string]string(name='headers'),
  body: GetNodeChildrenResponseBody(name='body'),
}

async function getNodeChildrenWithOptions(request: GetNodeChildrenRequest, runtime: Util.RuntimeOptions): GetNodeChildrenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeChildren',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNodeChildren(request: GetNodeChildrenRequest): GetNodeChildrenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeChildrenWithOptions(request, runtime);
}

model GetNodeCodeRequest {
  nodeId?: long(name='NodeId'),
  projectEnv?: string(name='ProjectEnv'),
}

model GetNodeCodeResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model GetNodeCodeResponse = {
  headers: map[string]string(name='headers'),
  body: GetNodeCodeResponseBody(name='body'),
}

async function getNodeCodeWithOptions(request: GetNodeCodeRequest, runtime: Util.RuntimeOptions): GetNodeCodeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeCode',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNodeCode(request: GetNodeCodeRequest): GetNodeCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeCodeWithOptions(request, runtime);
}

model GetNodeOnBaselineRequest {
  baselineId?: long(name='BaselineId'),
}

model GetNodeOnBaselineResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: string(name='Success'),
  data?: [ 
    {
      owner?: string(name='Owner'),
      nodeName?: string(name='NodeName'),
      nodeId?: long(name='NodeId'),
      projectId?: long(name='ProjectId'),
    }
  ](name='Data'),
}

model GetNodeOnBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: GetNodeOnBaselineResponseBody(name='body'),
}

async function getNodeOnBaselineWithOptions(request: GetNodeOnBaselineRequest, runtime: Util.RuntimeOptions): GetNodeOnBaselineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeOnBaseline',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNodeOnBaseline(request: GetNodeOnBaselineRequest): GetNodeOnBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeOnBaselineWithOptions(request, runtime);
}

model GetNodeParentsRequest {
  projectEnv?: string(name='ProjectEnv'),
  nodeId?: long(name='NodeId'),
}

model GetNodeParentsResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    nodes?: [ 
      {
        schedulerType?: string(name='SchedulerType'),
        baselineId?: long(name='BaselineId'),
        repeatability?: boolean(name='Repeatability'),
        nodeName?: string(name='NodeName'),
        projectId?: long(name='ProjectId'),
        programType?: string(name='ProgramType'),
        priority?: int32(name='Priority'),
        ownerId?: string(name='OwnerId'),
        cronExpress?: string(name='CronExpress'),
        nodeId?: long(name='NodeId'),
      }
    ](name='Nodes'),
  }(name='Data'),
}

model GetNodeParentsResponse = {
  headers: map[string]string(name='headers'),
  body: GetNodeParentsResponseBody(name='body'),
}

async function getNodeParentsWithOptions(request: GetNodeParentsRequest, runtime: Util.RuntimeOptions): GetNodeParentsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeParents',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNodeParents(request: GetNodeParentsRequest): GetNodeParentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeParentsWithOptions(request, runtime);
}

model GetNodeTypeListInfoRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  keyword?: string(name='Keyword'),
  locale?: string(name='Locale'),
}

model GetNodeTypeListInfoResponseBody = {
  requestId?: string(name='RequestId'),
  nodeTypeInfoList?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    nodeTypeInfo?: [ 
      {
        nodeTypeName?: string(name='NodeTypeName'),
        nodeType?: int32(name='NodeType'),
      }
    ](name='NodeTypeInfo'),
  }(name='NodeTypeInfoList'),
}

model GetNodeTypeListInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetNodeTypeListInfoResponseBody(name='body'),
}

async function getNodeTypeListInfoWithOptions(request: GetNodeTypeListInfoRequest, runtime: Util.RuntimeOptions): GetNodeTypeListInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeTypeListInfo',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNodeTypeListInfo(request: GetNodeTypeListInfoRequest): GetNodeTypeListInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeTypeListInfoWithOptions(request, runtime);
}

model GetOpRiskDataRequest {
  pageSize?: int32(name='PageSize'),
  pageNo?: int32(name='PageNo'),
  name?: string(name='Name'),
  date?: string(name='Date'),
  riskType?: string(name='RiskType'),
}

model GetOpRiskDataResponseBody = {
  riskData?: string(name='RiskData'),
  requestId?: string(name='RequestId'),
}

model GetOpRiskDataResponse = {
  headers: map[string]string(name='headers'),
  body: GetOpRiskDataResponseBody(name='body'),
}

async function getOpRiskDataWithOptions(request: GetOpRiskDataRequest, runtime: Util.RuntimeOptions): GetOpRiskDataResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOpRiskData',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOpRiskData(request: GetOpRiskDataRequest): GetOpRiskDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOpRiskDataWithOptions(request, runtime);
}

model GetOpSensitiveDataRequest {
  name?: string(name='Name'),
  pageSize?: int32(name='PageSize'),
  pageNo?: int32(name='PageNo'),
  date?: string(name='Date'),
  opType?: string(name='OpType'),
}

model GetOpSensitiveDataResponseBody = {
  opSensitiveData?: string(name='OpSensitiveData'),
  requestId?: string(name='RequestId'),
}

model GetOpSensitiveDataResponse = {
  headers: map[string]string(name='headers'),
  body: GetOpSensitiveDataResponseBody(name='body'),
}

async function getOpSensitiveDataWithOptions(request: GetOpSensitiveDataRequest, runtime: Util.RuntimeOptions): GetOpSensitiveDataResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOpSensitiveData',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOpSensitiveData(request: GetOpSensitiveDataRequest): GetOpSensitiveDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOpSensitiveDataWithOptions(request, runtime);
}

model GetPermissionApplyOrderDetailRequest {
  flowId?: string(name='FlowId'),
}

model GetPermissionApplyOrderDetailResponseBody = {
  requestId?: string(name='RequestId'),
  applyOrderDetail?: {
    applyBaseId?: string(name='ApplyBaseId'),
    applyTimestamp?: long(name='ApplyTimestamp'),
    flowId?: string(name='FlowId'),
    flowStatus?: int32(name='FlowStatus'),
    approveAccountList?: [ 
      {
        baseId?: string(name='BaseId'),
      }
    ](name='ApproveAccountList'),
    granteeObjectList?: [ 
      {
        granteeType?: int32(name='GranteeType'),
        granteeTypeSub?: int32(name='GranteeTypeSub'),
        granteeName?: string(name='GranteeName'),
        granteeId?: string(name='GranteeId'),
      }
    ](name='GranteeObjectList'),
    approveContent?: {
      applyReason?: string(name='ApplyReason'),
      deadline?: long(name='Deadline'),
      orderType?: int32(name='OrderType'),
      projectMeta?: {
        maxComputeProjectName?: string(name='MaxComputeProjectName'),
        workspaceId?: int32(name='WorkspaceId'),
        objectMetaList?: [ 
          {
            objectName?: string(name='ObjectName'),
            columnMetaList?: [ 
              {
                columnName?: string(name='ColumnName'),
                columnComment?: string(name='ColumnComment'),
              }
            ](name='ColumnMetaList'),
          }
        ](name='ObjectMetaList'),
      }(name='ProjectMeta'),
    }(name='ApproveContent'),
  }(name='ApplyOrderDetail'),
}

model GetPermissionApplyOrderDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetPermissionApplyOrderDetailResponseBody(name='body'),
}

async function getPermissionApplyOrderDetailWithOptions(request: GetPermissionApplyOrderDetailRequest, runtime: Util.RuntimeOptions): GetPermissionApplyOrderDetailResponse {
  Util.validateModel(request);
  var query = {};
  query["FlowId"] = request.flowId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetPermissionApplyOrderDetail',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPermissionApplyOrderDetail(request: GetPermissionApplyOrderDetailRequest): GetPermissionApplyOrderDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPermissionApplyOrderDetailWithOptions(request, runtime);
}

model GetProjectRequest {
  projectId?: long(name='ProjectId'),
}

model GetProjectResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  data?: {
    status?: int32(name='Status'),
    maxFlowNode?: int32(name='MaxFlowNode'),
    projectId?: int32(name='ProjectId'),
    isAllowDownload?: int32(name='IsAllowDownload'),
    projectMode?: int32(name='ProjectMode'),
    gmtModified?: string(name='GmtModified'),
    prodStorageQuota?: string(name='ProdStorageQuota'),
    projectDescription?: string(name='ProjectDescription'),
    developmentType?: int32(name='DevelopmentType'),
    tablePrivacyMode?: int32(name='TablePrivacyMode'),
    defaultDiResourceGroupIdentifier?: string(name='DefaultDiResourceGroupIdentifier'),
    schedulerMaxRetryTimes?: int32(name='SchedulerMaxRetryTimes'),
    protectedMode?: int32(name='ProtectedMode'),
    schedulerRetryInterval?: int32(name='SchedulerRetryInterval'),
    appkey?: string(name='Appkey'),
    devStorageQuota?: string(name='DevStorageQuota'),
    residentArea?: string(name='ResidentArea'),
    isDefault?: int32(name='IsDefault'),
    destination?: int32(name='Destination'),
    projectName?: string(name='ProjectName'),
    projectIdentifier?: string(name='ProjectIdentifier'),
    disableDevelopment?: boolean(name='DisableDevelopment'),
    projectOwnerBaseId?: string(name='ProjectOwnerBaseId'),
    baseProject?: boolean(name='BaseProject'),
    useProxyOdpsAccount?: boolean(name='UseProxyOdpsAccount'),
    gmtCreate?: string(name='GmtCreate'),
    tenantId?: long(name='TenantId'),
    envTypes?: [ string ](name='EnvTypes'),
  }(name='Data'),
}

model GetProjectResponse = {
  headers: map[string]string(name='headers'),
  body: GetProjectResponseBody(name='body'),
}

async function getProjectWithOptions(request: GetProjectRequest, runtime: Util.RuntimeOptions): GetProjectResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetProject',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProject(request: GetProjectRequest): GetProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProjectWithOptions(request, runtime);
}

model GetProjectDetailRequest {
  projectId?: long(name='ProjectId'),
}

model GetProjectDetailResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  data?: {
    status?: int32(name='Status'),
    residentArea?: string(name='ResidentArea'),
    projectId?: int32(name='ProjectId'),
    projectIdentifier?: string(name='ProjectIdentifier'),
    projectName?: string(name='ProjectName'),
    isAllowDownload?: int32(name='IsAllowDownload'),
    projectMode?: int32(name='ProjectMode'),
    projectDescription?: string(name='ProjectDescription'),
    gmtModified?: string(name='GmtModified'),
    projectOwnerBaseId?: string(name='ProjectOwnerBaseId'),
    developmentType?: int32(name='DevelopmentType'),
    defaultDiResourceGroupIdentifier?: string(name='DefaultDiResourceGroupIdentifier'),
    gmtCreate?: string(name='GmtCreate'),
    schedulerMaxRetryTimes?: int32(name='SchedulerMaxRetryTimes'),
    protectedMode?: int32(name='ProtectedMode'),
    tenantId?: long(name='TenantId'),
    schedulerRetryInterval?: int32(name='SchedulerRetryInterval'),
    envTypes?: [ string ](name='EnvTypes'),
  }(name='Data'),
}

model GetProjectDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetProjectDetailResponseBody(name='body'),
}

async function getProjectDetailWithOptions(request: GetProjectDetailRequest, runtime: Util.RuntimeOptions): GetProjectDetailResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetProjectDetail',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProjectDetail(request: GetProjectDetailRequest): GetProjectDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProjectDetailWithOptions(request, runtime);
}

model GetQualityEntityRequest {
  projectName?: string(name='ProjectName'),
  tableName?: string(name='TableName'),
  envType?: string(name='EnvType'),
  matchExpression?: string(name='MatchExpression'),
}

model GetQualityEntityResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: [ 
    {
      relativeNode?: string(name='RelativeNode'),
      onDutyAccountName?: string(name='OnDutyAccountName'),
      task?: int32(name='Task'),
      tableName?: string(name='TableName'),
      followers?: string(name='Followers'),
      onDuty?: string(name='OnDuty'),
      matchExpression?: string(name='MatchExpression'),
      createTime?: long(name='CreateTime'),
      projectName?: string(name='ProjectName'),
      hasRelativeNode?: boolean(name='HasRelativeNode'),
      envType?: string(name='EnvType'),
      entityLevel?: int32(name='EntityLevel'),
      modifyUser?: string(name='ModifyUser'),
      sql?: int32(name='Sql'),
      id?: long(name='Id'),
      modifyTime?: long(name='ModifyTime'),
    }
  ](name='Data'),
}

model GetQualityEntityResponse = {
  headers: map[string]string(name='headers'),
  body: GetQualityEntityResponseBody(name='body'),
}

async function getQualityEntityWithOptions(request: GetQualityEntityRequest, runtime: Util.RuntimeOptions): GetQualityEntityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetQualityEntity',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getQualityEntity(request: GetQualityEntityRequest): GetQualityEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQualityEntityWithOptions(request, runtime);
}

model GetQualityFollowerRequest {
  projectName?: string(name='ProjectName'),
  entityId?: long(name='EntityId'),
}

model GetQualityFollowerResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: [ 
    {
      followerAccountName?: string(name='FollowerAccountName'),
      tableName?: string(name='TableName'),
      alarmMode?: int32(name='AlarmMode'),
      entityId?: string(name='EntityId'),
      projectName?: string(name='ProjectName'),
      id?: long(name='Id'),
      follower?: string(name='Follower'),
    }
  ](name='Data'),
}

model GetQualityFollowerResponse = {
  headers: map[string]string(name='headers'),
  body: GetQualityFollowerResponseBody(name='body'),
}

async function getQualityFollowerWithOptions(request: GetQualityFollowerRequest, runtime: Util.RuntimeOptions): GetQualityFollowerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetQualityFollower',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getQualityFollower(request: GetQualityFollowerRequest): GetQualityFollowerResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQualityFollowerWithOptions(request, runtime);
}

model GetQualityRuleRequest {
  ruleId?: long(name='RuleId'),
  projectName?: string(name='ProjectName'),
}

model GetQualityRuleResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    blockType?: int32(name='BlockType'),
    onDutyAccountName?: string(name='OnDutyAccountName'),
    warningThreshold?: string(name='WarningThreshold'),
    property?: string(name='Property'),
    ruleType?: int32(name='RuleType'),
    comment?: string(name='Comment'),
    onDuty?: string(name='OnDuty'),
    checker?: int32(name='Checker'),
    fixCheck?: boolean(name='FixCheck'),
    methodId?: int32(name='MethodId'),
    criticalThreshold?: string(name='CriticalThreshold'),
    predictType?: int32(name='PredictType'),
    templateName?: string(name='TemplateName'),
    checkerName?: string(name='CheckerName'),
    ruleName?: string(name='RuleName'),
    methodName?: string(name='MethodName'),
    entityId?: long(name='EntityId'),
    whereCondition?: string(name='WhereCondition'),
    operator?: string(name='Operator'),
    expectValue?: string(name='ExpectValue'),
    trend?: string(name='Trend'),
    templateId?: int32(name='TemplateId'),
    id?: long(name='Id'),
  }(name='Data'),
}

model GetQualityRuleResponse = {
  headers: map[string]string(name='headers'),
  body: GetQualityRuleResponseBody(name='body'),
}

async function getQualityRuleWithOptions(request: GetQualityRuleRequest, runtime: Util.RuntimeOptions): GetQualityRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetQualityRule',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getQualityRule(request: GetQualityRuleRequest): GetQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQualityRuleWithOptions(request, runtime);
}

model GetRemindRequest {
  remindId?: long(name='RemindId'),
}

model GetRemindResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    maxAlertTimes?: int32(name='MaxAlertTimes'),
    remindUnit?: string(name='RemindUnit'),
    alertInterval?: int32(name='AlertInterval'),
    useflag?: boolean(name='Useflag'),
    founder?: string(name='Founder'),
    remindId?: long(name='RemindId'),
    dndEnd?: string(name='DndEnd'),
    remindType?: string(name='RemindType'),
    alertUnit?: string(name='AlertUnit'),
    dndStart?: string(name='DndStart'),
    remindName?: string(name='RemindName'),
    detail?: string(name='Detail'),
    robots?: [ 
      {
        webUrl?: string(name='WebUrl'),
        atAll?: boolean(name='AtAll'),
      }
    ](name='Robots'),
    nodes?: [ 
      {
        owner?: string(name='Owner'),
        nodeName?: string(name='NodeName'),
        nodeId?: long(name='NodeId'),
        projectId?: long(name='ProjectId'),
      }
    ](name='Nodes'),
    baselines?: [ 
      {
        baselineName?: string(name='BaselineName'),
        baselineId?: long(name='BaselineId'),
      }
    ](name='Baselines'),
    projects?: [ 
      {
        projectId?: long(name='ProjectId'),
      }
    ](name='Projects'),
    bizProcesses?: [ 
      {
        bizProcessName?: string(name='BizProcessName'),
        bizId?: long(name='BizId'),
      }
    ](name='BizProcesses'),
    alertTargets?: [ string ](name='AlertTargets'),
    alertMethods?: [ string ](name='AlertMethods'),
  }(name='Data'),
}

model GetRemindResponse = {
  headers: map[string]string(name='headers'),
  body: GetRemindResponseBody(name='body'),
}

async function getRemindWithOptions(request: GetRemindRequest, runtime: Util.RuntimeOptions): GetRemindResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetRemind',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRemind(request: GetRemindRequest): GetRemindResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRemindWithOptions(request, runtime);
}

model GetSensitiveDataRequest {
  pageSize?: int32(name='PageSize'),
  pageNo?: int32(name='PageNo'),
  name?: string(name='Name'),
}

model GetSensitiveDataResponseBody = {
  sensitiveData?: map[string]any(name='SensitiveData'),
  requestId?: string(name='RequestId'),
}

model GetSensitiveDataResponse = {
  headers: map[string]string(name='headers'),
  body: GetSensitiveDataResponseBody(name='body'),
}

async function getSensitiveDataWithOptions(request: GetSensitiveDataRequest, runtime: Util.RuntimeOptions): GetSensitiveDataResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSensitiveData',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSensitiveData(request: GetSensitiveDataRequest): GetSensitiveDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSensitiveDataWithOptions(request, runtime);
}

model GetSuccessInstanceTrendRequest {
  projectId?: long(name='ProjectId'),
}

model GetSuccessInstanceTrendResponseBody = {
  requestId?: string(name='RequestId'),
  instanceStatusTrend?: {
    todayTrend?: [ 
      {
        timePoint?: string(name='TimePoint'),
        count?: int32(name='Count'),
      }
    ](name='TodayTrend'),
    yesterdayTrend?: [ 
      {
        timePoint?: string(name='TimePoint'),
        count?: int32(name='Count'),
      }
    ](name='YesterdayTrend'),
    avgTrend?: [ 
      {
        timePoint?: string(name='TimePoint'),
        count?: int32(name='Count'),
      }
    ](name='AvgTrend'),
  }(name='InstanceStatusTrend'),
}

model GetSuccessInstanceTrendResponse = {
  headers: map[string]string(name='headers'),
  body: GetSuccessInstanceTrendResponseBody(name='body'),
}

async function getSuccessInstanceTrendWithOptions(request: GetSuccessInstanceTrendRequest, runtime: Util.RuntimeOptions): GetSuccessInstanceTrendResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetSuccessInstanceTrend',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSuccessInstanceTrend(request: GetSuccessInstanceTrendRequest): GetSuccessInstanceTrendResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSuccessInstanceTrendWithOptions(request, runtime);
}

model GetTopicRequest {
  topicId?: long(name='TopicId'),
}

model GetTopicResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    owner?: string(name='Owner'),
    topicName?: string(name='TopicName'),
    baselineStatus?: string(name='BaselineStatus'),
    projectId?: long(name='ProjectId'),
    nextAlertTime?: long(name='NextAlertTime'),
    instanceId?: long(name='InstanceId'),
    fixTime?: long(name='FixTime'),
    baselineInGroupId?: int32(name='BaselineInGroupId'),
    baselineBuffer?: long(name='BaselineBuffer'),
    topicType?: string(name='TopicType'),
    topicStatus?: string(name='TopicStatus'),
    happenTime?: long(name='HappenTime'),
    dealTime?: long(name='DealTime'),
    dealUser?: string(name='DealUser'),
    baselineName?: string(name='BaselineName'),
    baselineId?: long(name='BaselineId'),
    nodeName?: string(name='NodeName'),
    alertTime?: long(name='AlertTime'),
    buffer?: long(name='Buffer'),
    assigner?: string(name='Assigner'),
    topicId?: long(name='TopicId'),
    addTime?: long(name='AddTime'),
    nodeId?: long(name='NodeId'),
  }(name='Data'),
}

model GetTopicResponse = {
  headers: map[string]string(name='headers'),
  body: GetTopicResponseBody(name='body'),
}

async function getTopicWithOptions(request: GetTopicRequest, runtime: Util.RuntimeOptions): GetTopicResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetTopic',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTopic(request: GetTopicRequest): GetTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTopicWithOptions(request, runtime);
}

model GetTopicInfluenceRequest {
  topicId?: long(name='TopicId'),
}

model GetTopicInfluenceResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    topicId?: long(name='TopicId'),
    influences?: [ 
      {
        status?: string(name='Status'),
        owner?: string(name='Owner'),
        baselineName?: string(name='BaselineName'),
        baselineId?: long(name='BaselineId'),
        bizdate?: long(name='Bizdate'),
        buffer?: long(name='Buffer'),
        projectId?: long(name='ProjectId'),
        priority?: int32(name='Priority'),
        inGroupId?: int32(name='InGroupId'),
      }
    ](name='Influences'),
  }(name='Data'),
}

model GetTopicInfluenceResponse = {
  headers: map[string]string(name='headers'),
  body: GetTopicInfluenceResponseBody(name='body'),
}

async function getTopicInfluenceWithOptions(request: GetTopicInfluenceRequest, runtime: Util.RuntimeOptions): GetTopicInfluenceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetTopicInfluence',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTopicInfluence(request: GetTopicInfluenceRequest): GetTopicInfluenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTopicInfluenceWithOptions(request, runtime);
}

model ImportConnectionsRequest {
  projectId?: long(name='ProjectId'),
  connections?: string(name='Connections'),
}

model ImportConnectionsResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: boolean(name='Status'),
    message?: string(name='Message'),
  }(name='Data'),
}

model ImportConnectionsResponse = {
  headers: map[string]string(name='headers'),
  body: ImportConnectionsResponseBody(name='body'),
}

async function importConnectionsWithOptions(request: ImportConnectionsRequest, runtime: Util.RuntimeOptions): ImportConnectionsResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["Connections"] = request.connections;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ImportConnections',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importConnections(request: ImportConnectionsRequest): ImportConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return importConnectionsWithOptions(request, runtime);
}

model ImportDataSourcesRequest {
  projectId?: long(name='ProjectId'),
  dataSources?: string(name='DataSources'),
}

model ImportDataSourcesResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: boolean(name='Status'),
    message?: string(name='Message'),
  }(name='Data'),
}

model ImportDataSourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ImportDataSourcesResponseBody(name='body'),
}

async function importDataSourcesWithOptions(request: ImportDataSourcesRequest, runtime: Util.RuntimeOptions): ImportDataSourcesResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["DataSources"] = request.dataSources;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ImportDataSources',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importDataSources(request: ImportDataSourcesRequest): ImportDataSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return importDataSourcesWithOptions(request, runtime);
}

model ImportDISyncTasksRequest {
  projectId?: long(name='ProjectId'),
  taskType?: string(name='TaskType'),
  taskContent?: string(name='TaskContent'),
  taskParam?: string(name='TaskParam'),
}

model ImportDISyncTasksResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  taskInfo?: {
    taskId?: long(name='TaskId'),
  }(name='TaskInfo'),
}

model ImportDISyncTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ImportDISyncTasksResponseBody(name='body'),
}

async function importDISyncTasksWithOptions(request: ImportDISyncTasksRequest, runtime: Util.RuntimeOptions): ImportDISyncTasksResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["TaskType"] = request.taskType;
  query["TaskContent"] = request.taskContent;
  query["TaskParam"] = request.taskParam;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ImportDISyncTasks',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importDISyncTasks(request: ImportDISyncTasksRequest): ImportDISyncTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return importDISyncTasksWithOptions(request, runtime);
}

model ListAlertMessagesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  beginTime?: string(name='BeginTime'),
  endTime?: string(name='EndTime'),
  remindId?: long(name='RemindId'),
  alertMethods?: string(name='AlertMethods'),
  alertUser?: string(name='AlertUser'),
  alertRuleTypes?: string(name='AlertRuleTypes'),
}

model ListAlertMessagesResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    pageNumber?: string(name='PageNumber'),
    pageSize?: string(name='PageSize'),
    totalCount?: string(name='TotalCount'),
    alertMessages?: [ 
      {
        remindId?: long(name='RemindId'),
        alertMessageStatus?: string(name='AlertMessageStatus'),
        alertUser?: string(name='AlertUser'),
        alertTime?: long(name='AlertTime'),
        alertMethod?: string(name='AlertMethod'),
        source?: string(name='Source'),
        content?: string(name='Content'),
        remindName?: string(name='RemindName'),
        alertId?: long(name='AlertId'),
        instances?: [ 
          {
            status?: string(name='Status'),
            instanceId?: long(name='InstanceId'),
            nodeName?: string(name='NodeName'),
            nodeId?: long(name='NodeId'),
            projectId?: long(name='ProjectId'),
          }
        ](name='Instances'),
        topics?: [ 
          {
            topicName?: string(name='TopicName'),
            instanceId?: long(name='InstanceId'),
            topicId?: long(name='TopicId'),
            topicOwner?: string(name='TopicOwner'),
            nodeId?: long(name='NodeId'),
            topicStatus?: string(name='TopicStatus'),
          }
        ](name='Topics'),
        nodes?: [ 
          {
            owner?: string(name='Owner'),
            nodeName?: string(name='NodeName'),
            nodeId?: long(name='NodeId'),
            projectId?: long(name='ProjectId'),
          }
        ](name='Nodes'),
        slaAlert?: {
          status?: string(name='Status'),
          baselineOwner?: string(name='BaselineOwner'),
          baselineId?: long(name='BaselineId'),
          baselineName?: string(name='BaselineName'),
          bizdate?: long(name='Bizdate'),
          projectId?: long(name='ProjectId'),
          inGroupId?: int32(name='InGroupId'),
        }(name='SlaAlert'),
      }
    ](name='AlertMessages'),
  }(name='Data'),
}

model ListAlertMessagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlertMessagesResponseBody(name='body'),
}

async function listAlertMessagesWithOptions(request: ListAlertMessagesRequest, runtime: Util.RuntimeOptions): ListAlertMessagesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListAlertMessages',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlertMessages(request: ListAlertMessagesRequest): ListAlertMessagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlertMessagesWithOptions(request, runtime);
}

model ListBaselineConfigsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  owner?: string(name='Owner'),
  projectId?: long(name='ProjectId'),
  priority?: string(name='Priority'),
  useflag?: boolean(name='Useflag'),
  baselineTypes?: string(name='BaselineTypes'),
  searchText?: string(name='SearchText'),
}

model ListBaselineConfigsResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    baselines?: [ 
      {
        hourSlaDetail?: string(name='HourSlaDetail'),
        isDefault?: boolean(name='IsDefault'),
        owner?: string(name='Owner'),
        projectId?: long(name='ProjectId'),
        priority?: int32(name='Priority'),
        slaMinu?: int32(name='SlaMinu'),
        slaHour?: int32(name='SlaHour'),
        baselineId?: long(name='BaselineId'),
        baselineName?: string(name='BaselineName'),
        hourExpDetail?: string(name='HourExpDetail'),
        useFlag?: boolean(name='UseFlag'),
        expHour?: int32(name='ExpHour'),
        baselineType?: string(name='BaselineType'),
        expMinu?: int32(name='ExpMinu'),
      }
    ](name='Baselines'),
  }(name='Data'),
}

model ListBaselineConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListBaselineConfigsResponseBody(name='body'),
}

async function listBaselineConfigsWithOptions(request: ListBaselineConfigsRequest, runtime: Util.RuntimeOptions): ListBaselineConfigsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListBaselineConfigs',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBaselineConfigs(request: ListBaselineConfigsRequest): ListBaselineConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBaselineConfigsWithOptions(request, runtime);
}

model ListBaselineStatusesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  bizdate?: string(name='Bizdate'),
  priority?: string(name='Priority'),
  searchText?: string(name='SearchText'),
  owner?: string(name='Owner'),
  topicId?: long(name='TopicId'),
  finishStatus?: string(name='FinishStatus'),
  status?: string(name='Status'),
  baselineTypes?: string(name='BaselineTypes'),
}

model ListBaselineStatusesResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    baselineStatuses?: [ 
      {
        status?: string(name='Status'),
        owner?: string(name='Owner'),
        finishTime?: long(name='FinishTime'),
        projectId?: long(name='ProjectId'),
        priority?: int32(name='Priority'),
        endCast?: long(name='EndCast'),
        inGroupId?: int32(name='InGroupId'),
        baselineName?: string(name='BaselineName'),
        baselineId?: long(name='BaselineId'),
        finishStatus?: string(name='FinishStatus'),
        bizdate?: long(name='Bizdate'),
        buffer?: long(name='Buffer'),
        slaTime?: long(name='SlaTime'),
        expTime?: long(name='ExpTime'),
      }
    ](name='BaselineStatuses'),
  }(name='Data'),
}

model ListBaselineStatusesResponse = {
  headers: map[string]string(name='headers'),
  body: ListBaselineStatusesResponseBody(name='body'),
}

async function listBaselineStatusesWithOptions(request: ListBaselineStatusesRequest, runtime: Util.RuntimeOptions): ListBaselineStatusesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListBaselineStatuses',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBaselineStatuses(request: ListBaselineStatusesRequest): ListBaselineStatusesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBaselineStatusesWithOptions(request, runtime);
}

model ListBusinessRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  keyword?: string(name='Keyword'),
}

model ListBusinessResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    business?: [ 
      {
        owner?: string(name='Owner'),
        description?: string(name='Description'),
        projectId?: long(name='ProjectId'),
        businessId?: long(name='BusinessId'),
        businessName?: string(name='BusinessName'),
        useType?: string(name='UseType'),
      }
    ](name='Business'),
  }(name='Data'),
}

model ListBusinessResponse = {
  headers: map[string]string(name='headers'),
  body: ListBusinessResponseBody(name='body'),
}

async function listBusinessWithOptions(request: ListBusinessRequest, runtime: Util.RuntimeOptions): ListBusinessResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListBusiness',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBusiness(request: ListBusinessRequest): ListBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBusinessWithOptions(request, runtime);
}

model ListCalcEnginesRequest {
  projectId?: long(name='ProjectId'),
  name?: string(name='Name'),
  calcEngineType?: string(name='CalcEngineType'),
  envType?: string(name='EnvType'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
}

model ListCalcEnginesResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    calcEngines?: [ 
      {
        bindingProjectName?: string(name='BindingProjectName'),
        isDefault?: boolean(name='IsDefault'),
        engineId?: int32(name='EngineId'),
        dwRegion?: string(name='DwRegion'),
        taskAuthType?: string(name='TaskAuthType'),
        calcEngineType?: string(name='CalcEngineType'),
        engineInfo?: map[string]any(name='EngineInfo'),
        envType?: string(name='EnvType'),
        region?: string(name='Region'),
        gmtCreate?: string(name='GmtCreate'),
        bindingProjectId?: int32(name='BindingProjectId'),
        name?: string(name='Name'),
        tenantId?: long(name='TenantId'),
      }
    ](name='CalcEngines'),
  }(name='Data'),
}

model ListCalcEnginesResponse = {
  headers: map[string]string(name='headers'),
  body: ListCalcEnginesResponseBody(name='body'),
}

async function listCalcEnginesWithOptions(request: ListCalcEnginesRequest, runtime: Util.RuntimeOptions): ListCalcEnginesResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["Name"] = request.name;
  query["CalcEngineType"] = request.calcEngineType;
  query["EnvType"] = request.envType;
  query["PageSize"] = request.pageSize;
  query["PageNumber"] = request.pageNumber;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListCalcEngines',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCalcEngines(request: ListCalcEnginesRequest): ListCalcEnginesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCalcEnginesWithOptions(request, runtime);
}

model ListConnectionsRequest {
  projectId?: long(name='ProjectId'),
  name?: string(name='Name'),
  connectionType?: string(name='ConnectionType'),
  subType?: string(name='SubType'),
  status?: string(name='Status'),
  envType?: int32(name='EnvType'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
}

model ListConnectionsResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    connections?: [ 
      {
        status?: int32(name='Status'),
        connectionType?: string(name='ConnectionType'),
        projectId?: int32(name='ProjectId'),
        subType?: string(name='SubType'),
        gmtModified?: string(name='GmtModified'),
        envType?: int32(name='EnvType'),
        connectStatus?: int32(name='ConnectStatus'),
        sequence?: int32(name='Sequence'),
        description?: string(name='Description'),
        gmtCreate?: string(name='GmtCreate'),
        defaultEngine?: boolean(name='DefaultEngine'),
        shared?: boolean(name='Shared'),
        operator?: string(name='Operator'),
        name?: string(name='Name'),
        content?: string(name='Content'),
        id?: int32(name='Id'),
        bindingCalcEngineId?: int32(name='BindingCalcEngineId'),
        tenantId?: long(name='TenantId'),
      }
    ](name='Connections'),
  }(name='Data'),
}

model ListConnectionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListConnectionsResponseBody(name='body'),
}

async function listConnectionsWithOptions(request: ListConnectionsRequest, runtime: Util.RuntimeOptions): ListConnectionsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConnections',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listConnections(request: ListConnectionsRequest): ListConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConnectionsWithOptions(request, runtime);
}

model ListDataServiceApiAuthoritiesRequest {
  projectId?: long(name='ProjectId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  tenantId?: long(name='TenantId'),
  apiNameKeyword?: string(name='ApiNameKeyword'),
}

model ListDataServiceApiAuthoritiesResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    apiAuthorizationList?: [ 
      {
        apiStatus?: int32(name='ApiStatus'),
        apiId?: long(name='ApiId'),
        modifiedTime?: string(name='ModifiedTime'),
        groupId?: string(name='GroupId'),
        projectId?: long(name='ProjectId'),
        creatorId?: string(name='CreatorId'),
        createdTime?: string(name='CreatedTime'),
        apiName?: string(name='ApiName'),
        tenantId?: long(name='TenantId'),
        apiPath?: string(name='ApiPath'),
        authorizationRecords?: [ 
          {
            endTime?: string(name='EndTime'),
            creatorId?: string(name='CreatorId'),
            createdTime?: string(name='CreatedTime'),
            projectId?: long(name='ProjectId'),
          }
        ](name='AuthorizationRecords'),
      }
    ](name='ApiAuthorizationList'),
  }(name='Data'),
}

model ListDataServiceApiAuthoritiesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataServiceApiAuthoritiesResponseBody(name='body'),
}

async function listDataServiceApiAuthoritiesWithOptions(request: ListDataServiceApiAuthoritiesRequest, runtime: Util.RuntimeOptions): ListDataServiceApiAuthoritiesResponse {
  Util.validateModel(request);
  var query = {};
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListDataServiceApiAuthorities',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDataServiceApiAuthorities(request: ListDataServiceApiAuthoritiesRequest): ListDataServiceApiAuthoritiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServiceApiAuthoritiesWithOptions(request, runtime);
}

model ListDataServiceApisRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId'),
  tenantId?: long(name='TenantId'),
  apiNameKeyword?: string(name='ApiNameKeyword'),
  apiPathKeyword?: string(name='ApiPathKeyword'),
  creatorId?: string(name='CreatorId'),
}

model ListDataServiceApisResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    apis?: [ 
      {
        timeout?: int32(name='Timeout'),
        status?: int32(name='Status'),
        apiId?: long(name='ApiId'),
        apiMode?: int32(name='ApiMode'),
        projectId?: long(name='ProjectId'),
        responseContentType?: int32(name='ResponseContentType'),
        creatorId?: string(name='CreatorId'),
        visibleRange?: int32(name='VisibleRange'),
        modifiedTime?: string(name='ModifiedTime'),
        operatorId?: string(name='OperatorId'),
        groupId?: string(name='GroupId'),
        description?: string(name='Description'),
        folderId?: long(name='FolderId'),
        requestMethod?: int32(name='RequestMethod'),
        createdTime?: string(name='CreatedTime'),
        apiName?: string(name='ApiName'),
        tenantId?: long(name='TenantId'),
        apiPath?: string(name='ApiPath'),
        protocols?: [ int32 ](name='Protocols'),
        registrationDetails?: {
          serviceHost?: string(name='ServiceHost'),
          serviceContentType?: int32(name='ServiceContentType'),
          servicePath?: string(name='ServicePath'),
          successfulResultSample?: string(name='SuccessfulResultSample'),
          failedResultSample?: string(name='FailedResultSample'),
          serviceRequestBodyDescription?: string(name='ServiceRequestBodyDescription'),
          registrationErrorCodes?: [ 
            {
              errorMessage?: string(name='ErrorMessage'),
              errorCode?: string(name='ErrorCode'),
              errorSolution?: string(name='ErrorSolution'),
            }
          ](name='RegistrationErrorCodes'),
          registrationRequestParameters?: [ 
            {
              columnName?: string(name='ColumnName'),
              parameterName?: string(name='ParameterName'),
              parameterPosition?: int32(name='ParameterPosition'),
              parameterDescription?: string(name='ParameterDescription'),
              defaultValue?: string(name='DefaultValue'),
              parameterOperator?: int32(name='ParameterOperator'),
              parameterDataType?: int32(name='ParameterDataType'),
              exampleValue?: string(name='ExampleValue'),
              isRequiredParameter?: boolean(name='IsRequiredParameter'),
            }
          ](name='RegistrationRequestParameters'),
        }(name='RegistrationDetails'),
        scriptDetails?: {
          script?: string(name='Script'),
          isPagedResponse?: boolean(name='IsPagedResponse'),
          scriptRequestParameters?: [ 
            {
              columnName?: string(name='ColumnName'),
              parameterName?: string(name='ParameterName'),
              parameterPosition?: int32(name='ParameterPosition'),
              parameterDescription?: string(name='ParameterDescription'),
              defaultValue?: string(name='DefaultValue'),
              parameterOperator?: int32(name='ParameterOperator'),
              parameterDataType?: int32(name='ParameterDataType'),
              exampleValue?: string(name='ExampleValue'),
              isRequiredParameter?: boolean(name='IsRequiredParameter'),
            }
          ](name='ScriptRequestParameters'),
          scriptResponseParameters?: [ 
            {
              parameterDescription?: string(name='ParameterDescription'),
              columnName?: string(name='ColumnName'),
              parameterName?: string(name='ParameterName'),
              parameterDataType?: int32(name='ParameterDataType'),
              exampleValue?: string(name='ExampleValue'),
            }
          ](name='ScriptResponseParameters'),
          scriptConnection?: {
            tableName?: string(name='TableName'),
            connectionId?: long(name='ConnectionId'),
          }(name='ScriptConnection'),
        }(name='ScriptDetails'),
        wizardDetails?: {
          isPagedResponse?: boolean(name='IsPagedResponse'),
          wizardRequestParameters?: [ 
            {
              columnName?: string(name='ColumnName'),
              parameterName?: string(name='ParameterName'),
              parameterPosition?: int32(name='ParameterPosition'),
              parameterDescription?: string(name='ParameterDescription'),
              defaultValue?: string(name='DefaultValue'),
              parameterOperator?: int32(name='ParameterOperator'),
              parameterDataType?: int32(name='ParameterDataType'),
              exampleValue?: string(name='ExampleValue'),
              isRequiredParameter?: boolean(name='IsRequiredParameter'),
            }
          ](name='WizardRequestParameters'),
          wizardResponseParameters?: [ 
            {
              parameterDescription?: string(name='ParameterDescription'),
              columnName?: string(name='ColumnName'),
              parameterName?: string(name='ParameterName'),
              parameterDataType?: int32(name='ParameterDataType'),
              exampleValue?: string(name='ExampleValue'),
            }
          ](name='WizardResponseParameters'),
          wizardConnection?: {
            tableName?: string(name='TableName'),
            connectionId?: long(name='ConnectionId'),
          }(name='WizardConnection'),
        }(name='WizardDetails'),
      }
    ](name='Apis'),
  }(name='Data'),
}

model ListDataServiceApisResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataServiceApisResponseBody(name='body'),
}

async function listDataServiceApisWithOptions(request: ListDataServiceApisRequest, runtime: Util.RuntimeOptions): ListDataServiceApisResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListDataServiceApis',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDataServiceApis(request: ListDataServiceApisRequest): ListDataServiceApisResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServiceApisWithOptions(request, runtime);
}

model ListDataServiceApplicationsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectIdList?: string(name='ProjectIdList'),
  tenantId?: long(name='TenantId'),
}

model ListDataServiceApplicationsResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    applications?: [ 
      {
        applicationName?: string(name='ApplicationName'),
        applicationId?: long(name='ApplicationId'),
        projectId?: long(name='ProjectId'),
      }
    ](name='Applications'),
  }(name='Data'),
}

model ListDataServiceApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataServiceApplicationsResponseBody(name='body'),
}

async function listDataServiceApplicationsWithOptions(request: ListDataServiceApplicationsRequest, runtime: Util.RuntimeOptions): ListDataServiceApplicationsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListDataServiceApplications',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDataServiceApplications(request: ListDataServiceApplicationsRequest): ListDataServiceApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServiceApplicationsWithOptions(request, runtime);
}

model ListDataServiceAuthorizedApisRequest {
  projectId?: long(name='ProjectId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  tenantId?: long(name='TenantId'),
  apiNameKeyword?: string(name='ApiNameKeyword'),
}

model ListDataServiceAuthorizedApisResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    apiAuthorizedList?: [ 
      {
        apiId?: long(name='ApiId'),
        apiStatus?: int32(name='ApiStatus'),
        grantOperatorId?: string(name='GrantOperatorId'),
        projectId?: long(name='ProjectId'),
        creatorId?: string(name='CreatorId'),
        grantEndTime?: string(name='GrantEndTime'),
        modifiedTime?: string(name='ModifiedTime'),
        groupId?: string(name='GroupId'),
        grantCreatedTime?: string(name='GrantCreatedTime'),
        createdTime?: string(name='CreatedTime'),
        apiName?: string(name='ApiName'),
        tenantId?: long(name='TenantId'),
        apiPath?: string(name='ApiPath'),
      }
    ](name='ApiAuthorizedList'),
  }(name='Data'),
}

model ListDataServiceAuthorizedApisResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataServiceAuthorizedApisResponseBody(name='body'),
}

async function listDataServiceAuthorizedApisWithOptions(request: ListDataServiceAuthorizedApisRequest, runtime: Util.RuntimeOptions): ListDataServiceAuthorizedApisResponse {
  Util.validateModel(request);
  var query = {};
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListDataServiceAuthorizedApis',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDataServiceAuthorizedApis(request: ListDataServiceAuthorizedApisRequest): ListDataServiceAuthorizedApisResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServiceAuthorizedApisWithOptions(request, runtime);
}

model ListDataServiceFoldersRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId'),
  tenantId?: long(name='TenantId'),
  groupId?: string(name='GroupId'),
  folderNameKeyword?: string(name='FolderNameKeyword'),
}

model ListDataServiceFoldersResponseBody = {
  requestId?: string(name='RequestId'),
  folderPagingResult?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    folders?: [ 
      {
        parentId?: long(name='ParentId'),
        modifiedTime?: string(name='ModifiedTime'),
        groupId?: string(name='GroupId'),
        folderId?: long(name='FolderId'),
        folderName?: string(name='FolderName'),
        projectId?: long(name='ProjectId'),
        createdTime?: string(name='CreatedTime'),
        tenantId?: long(name='TenantId'),
      }
    ](name='Folders'),
  }(name='FolderPagingResult'),
}

model ListDataServiceFoldersResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataServiceFoldersResponseBody(name='body'),
}

async function listDataServiceFoldersWithOptions(request: ListDataServiceFoldersRequest, runtime: Util.RuntimeOptions): ListDataServiceFoldersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListDataServiceFolders',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDataServiceFolders(request: ListDataServiceFoldersRequest): ListDataServiceFoldersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServiceFoldersWithOptions(request, runtime);
}

model ListDataServiceGroupsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId'),
  tenantId?: long(name='TenantId'),
  groupNameKeyword?: string(name='GroupNameKeyword'),
}

model ListDataServiceGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  groupPagingResult?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    groups?: [ 
      {
        modifiedTime?: string(name='ModifiedTime'),
        description?: string(name='Description'),
        groupName?: string(name='GroupName'),
        groupId?: string(name='GroupId'),
        projectId?: long(name='ProjectId'),
        apiGatewayGroupId?: string(name='ApiGatewayGroupId'),
        creatorId?: string(name='CreatorId'),
        createdTime?: string(name='CreatedTime'),
        tenantId?: long(name='TenantId'),
      }
    ](name='Groups'),
  }(name='GroupPagingResult'),
}

model ListDataServiceGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataServiceGroupsResponseBody(name='body'),
}

async function listDataServiceGroupsWithOptions(request: ListDataServiceGroupsRequest, runtime: Util.RuntimeOptions): ListDataServiceGroupsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListDataServiceGroups',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDataServiceGroups(request: ListDataServiceGroupsRequest): ListDataServiceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServiceGroupsWithOptions(request, runtime);
}

model ListDataServicePublishedApisRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId'),
  tenantId?: long(name='TenantId'),
  apiNameKeyword?: string(name='ApiNameKeyword'),
  apiPathKeyword?: string(name='ApiPathKeyword'),
  creatorId?: string(name='CreatorId'),
}

model ListDataServicePublishedApisResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    apis?: [ 
      {
        timeout?: int32(name='Timeout'),
        status?: int32(name='Status'),
        apiId?: long(name='ApiId'),
        apiMode?: int32(name='ApiMode'),
        projectId?: long(name='ProjectId'),
        responseContentType?: int32(name='ResponseContentType'),
        creatorId?: string(name='CreatorId'),
        visibleRange?: int32(name='VisibleRange'),
        modifiedTime?: string(name='ModifiedTime'),
        operatorId?: string(name='OperatorId'),
        groupId?: string(name='GroupId'),
        description?: string(name='Description'),
        requestMethod?: int32(name='RequestMethod'),
        createdTime?: string(name='CreatedTime'),
        apiName?: string(name='ApiName'),
        tenantId?: long(name='TenantId'),
        apiPath?: string(name='ApiPath'),
        protocols?: [ int32 ](name='Protocols'),
        registrationDetails?: {
          serviceHost?: string(name='ServiceHost'),
          serviceContentType?: int32(name='ServiceContentType'),
          servicePath?: string(name='ServicePath'),
          successfulResultSample?: string(name='SuccessfulResultSample'),
          failedResultSample?: string(name='FailedResultSample'),
          serviceRequestBodyDescription?: string(name='ServiceRequestBodyDescription'),
          registrationErrorCodes?: [ 
            {
              errorMessage?: string(name='ErrorMessage'),
              errorCode?: string(name='ErrorCode'),
              errorSolution?: string(name='ErrorSolution'),
            }
          ](name='RegistrationErrorCodes'),
          registrationRequestParameters?: [ 
            {
              parameterName?: string(name='ParameterName'),
              parameterPosition?: int32(name='ParameterPosition'),
              parameterDescription?: string(name='ParameterDescription'),
              defaultValue?: string(name='DefaultValue'),
              parameterOperator?: int32(name='ParameterOperator'),
              exampleValue?: string(name='ExampleValue'),
              parameterDataType?: int32(name='ParameterDataType'),
              isRequiredParameter?: boolean(name='IsRequiredParameter'),
            }
          ](name='RegistrationRequestParameters'),
        }(name='RegistrationDetails'),
        scriptDetails?: {
          isPagedResponse?: boolean(name='IsPagedResponse'),
          successfulResultSample?: string(name='SuccessfulResultSample'),
          failedResultSample?: string(name='FailedResultSample'),
          script?: string(name='Script'),
          scriptErrorCodes?: [ 
            {
              errorMessage?: string(name='ErrorMessage'),
              errorCode?: string(name='ErrorCode'),
              errorSolution?: string(name='ErrorSolution'),
            }
          ](name='ScriptErrorCodes'),
          scriptRequestParameters?: [ 
            {
              parameterName?: string(name='ParameterName'),
              parameterPosition?: int32(name='ParameterPosition'),
              parameterDescription?: string(name='ParameterDescription'),
              defaultValue?: string(name='DefaultValue'),
              parameterOperator?: int32(name='ParameterOperator'),
              exampleValue?: string(name='ExampleValue'),
              parameterDataType?: int32(name='ParameterDataType'),
              isRequiredParameter?: boolean(name='IsRequiredParameter'),
            }
          ](name='ScriptRequestParameters'),
          scriptResponseParameters?: [ 
            {
              parameterDescription?: string(name='ParameterDescription'),
              parameterName?: string(name='ParameterName'),
              exampleValue?: string(name='ExampleValue'),
              parameterDataType?: int32(name='ParameterDataType'),
            }
          ](name='ScriptResponseParameters'),
          scriptConnection?: {
            tableName?: string(name='TableName'),
            connectionId?: long(name='ConnectionId'),
          }(name='ScriptConnection'),
        }(name='ScriptDetails'),
        wizardDetails?: {
          isPagedResponse?: boolean(name='IsPagedResponse'),
          successfulResultSample?: string(name='SuccessfulResultSample'),
          failedResultSample?: string(name='FailedResultSample'),
          wizardErrorCodes?: [ 
            {
              errorMessage?: string(name='ErrorMessage'),
              errorCode?: string(name='ErrorCode'),
              errorSolution?: string(name='ErrorSolution'),
            }
          ](name='WizardErrorCodes'),
          wizardRequestParameters?: [ 
            {
              parameterName?: string(name='ParameterName'),
              parameterPosition?: int32(name='ParameterPosition'),
              parameterDescription?: string(name='ParameterDescription'),
              defaultValue?: string(name='DefaultValue'),
              parameterOperator?: int32(name='ParameterOperator'),
              exampleValue?: string(name='ExampleValue'),
              parameterDataType?: int32(name='ParameterDataType'),
              isRequiredParameter?: boolean(name='IsRequiredParameter'),
            }
          ](name='WizardRequestParameters'),
          wizardResponseParameters?: [ 
            {
              parameterDescription?: string(name='ParameterDescription'),
              parameterName?: string(name='ParameterName'),
              exampleValue?: string(name='ExampleValue'),
              parameterDataType?: int32(name='ParameterDataType'),
            }
          ](name='WizardResponseParameters'),
          wizardConnection?: {
            tableName?: string(name='TableName'),
            connectionId?: long(name='ConnectionId'),
          }(name='WizardConnection'),
        }(name='WizardDetails'),
      }
    ](name='Apis'),
  }(name='Data'),
}

model ListDataServicePublishedApisResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataServicePublishedApisResponseBody(name='body'),
}

async function listDataServicePublishedApisWithOptions(request: ListDataServicePublishedApisRequest, runtime: Util.RuntimeOptions): ListDataServicePublishedApisResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListDataServicePublishedApis',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDataServicePublishedApis(request: ListDataServicePublishedApisRequest): ListDataServicePublishedApisResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServicePublishedApisWithOptions(request, runtime);
}

model ListDataSourcesRequest {
  projectId?: long(name='ProjectId'),
  name?: string(name='Name'),
  dataSourceType?: string(name='DataSourceType'),
  subType?: string(name='SubType'),
  status?: string(name='Status'),
  envType?: int32(name='EnvType'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
}

model ListDataSourcesResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    dataSources?: [ 
      {
        status?: int32(name='Status'),
        projectId?: int32(name='ProjectId'),
        subType?: string(name='SubType'),
        gmtModified?: string(name='GmtModified'),
        envType?: int32(name='EnvType'),
        connectStatus?: int32(name='ConnectStatus'),
        sequence?: int32(name='Sequence'),
        description?: string(name='Description'),
        dataSourceType?: string(name='DataSourceType'),
        gmtCreate?: string(name='GmtCreate'),
        defaultEngine?: boolean(name='DefaultEngine'),
        shared?: boolean(name='Shared'),
        operator?: string(name='Operator'),
        name?: string(name='Name'),
        content?: string(name='Content'),
        id?: int32(name='Id'),
        bindingCalcEngineId?: int32(name='BindingCalcEngineId'),
        tenantId?: long(name='TenantId'),
      }
    ](name='DataSources'),
  }(name='Data'),
}

model ListDataSourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataSourcesResponseBody(name='body'),
}

async function listDataSourcesWithOptions(request: ListDataSourcesRequest, runtime: Util.RuntimeOptions): ListDataSourcesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDataSources',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDataSources(request: ListDataSourcesRequest): ListDataSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataSourcesWithOptions(request, runtime);
}

model ListDIProjectConfigRequest {
  projectId?: long(name='ProjectId'),
  destinationType?: string(name='DestinationType'),
  sourceType?: string(name='SourceType'),
}

model ListDIProjectConfigResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    config?: string(name='Config'),
  }(name='Data'),
}

model ListDIProjectConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ListDIProjectConfigResponseBody(name='body'),
}

async function listDIProjectConfigWithOptions(request: ListDIProjectConfigRequest, runtime: Util.RuntimeOptions): ListDIProjectConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["DestinationType"] = request.destinationType;
  query["SourceType"] = request.sourceType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListDIProjectConfig',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDIProjectConfig(request: ListDIProjectConfigRequest): ListDIProjectConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDIProjectConfigWithOptions(request, runtime);
}

model ListDISyncTasksRequest {
  projectId?: long(name='ProjectId'),
  taskType?: string(name='TaskType'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
}

model ListDISyncTasksResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  taskList?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    realTimeSolutionList?: [ 
      {
        processName?: string(name='ProcessName'),
        taskType?: string(name='TaskType'),
        processId?: long(name='ProcessId'),
        taskStatus?: string(name='TaskStatus'),
        createTime?: long(name='CreateTime'),
      }
    ](name='RealTimeSolutionList'),
  }(name='TaskList'),
}

model ListDISyncTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListDISyncTasksResponseBody(name='body'),
}

async function listDISyncTasksWithOptions(request: ListDISyncTasksRequest, runtime: Util.RuntimeOptions): ListDISyncTasksResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["TaskType"] = request.taskType;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListDISyncTasks',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDISyncTasks(request: ListDISyncTasksRequest): ListDISyncTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDISyncTasksWithOptions(request, runtime);
}

model ListFilesRequest {
  fileFolderPath?: string(name='FileFolderPath'),
  projectId?: long(name='ProjectId'),
  keyword?: string(name='Keyword'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  useType?: string(name='UseType'),
  fileTypes?: string(name='FileTypes'),
  owner?: string(name='Owner'),
  nodeId?: long(name='NodeId'),
}

model ListFilesResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    files?: [ 
      {
        commitStatus?: int32(name='CommitStatus'),
        autoParsing?: boolean(name='AutoParsing'),
        owner?: string(name='Owner'),
        createTime?: long(name='CreateTime'),
        fileType?: int32(name='FileType'),
        currentVersion?: int32(name='CurrentVersion'),
        bizId?: long(name='BizId'),
        lastEditUser?: string(name='LastEditUser'),
        fileName?: string(name='FileName'),
        connectionName?: string(name='ConnectionName'),
        useType?: string(name='UseType'),
        fileFolderId?: string(name='FileFolderId'),
        fileId?: long(name='FileId'),
        parentId?: long(name='ParentId'),
        createUser?: string(name='CreateUser'),
        isMaxCompute?: boolean(name='IsMaxCompute'),
        businessId?: long(name='BusinessId'),
        fileDescription?: string(name='FileDescription'),
        lastEditTime?: long(name='LastEditTime'),
        content?: string(name='Content'),
        nodeId?: long(name='NodeId'),
      }
    ](name='Files'),
  }(name='Data'),
}

model ListFilesResponse = {
  headers: map[string]string(name='headers'),
  body: ListFilesResponseBody(name='body'),
}

async function listFilesWithOptions(request: ListFilesRequest, runtime: Util.RuntimeOptions): ListFilesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFiles',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFiles(request: ListFilesRequest): ListFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFilesWithOptions(request, runtime);
}

model ListFileTypeRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  keyword?: string(name='Keyword'),
  locale?: string(name='Locale'),
}

model ListFileTypeResponseBody = {
  requestId?: string(name='RequestId'),
  nodeTypeInfoList?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    nodeTypeInfo?: [ 
      {
        nodeTypeName?: string(name='NodeTypeName'),
        nodeType?: int32(name='NodeType'),
      }
    ](name='NodeTypeInfo'),
  }(name='NodeTypeInfoList'),
}

model ListFileTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ListFileTypeResponseBody(name='body'),
}

async function listFileTypeWithOptions(request: ListFileTypeRequest, runtime: Util.RuntimeOptions): ListFileTypeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFileType',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFileType(request: ListFileTypeRequest): ListFileTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFileTypeWithOptions(request, runtime);
}

model ListFileVersionsRequest {
  fileId?: long(name='FileId'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListFileVersionsResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    fileVersions?: [ 
      {
        fileContent?: string(name='FileContent'),
        status?: string(name='Status'),
        isCurrentProd?: boolean(name='IsCurrentProd'),
        commitUser?: string(name='CommitUser'),
        nodeContent?: string(name='NodeContent'),
        comment?: string(name='Comment'),
        filePropertyContent?: string(name='FilePropertyContent'),
        fileName?: string(name='FileName'),
        useType?: string(name='UseType'),
        changeType?: string(name='ChangeType'),
        fileVersion?: int32(name='FileVersion'),
        commitTime?: long(name='CommitTime'),
        nodeId?: long(name='NodeId'),
      }
    ](name='FileVersions'),
  }(name='Data'),
}

model ListFileVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFileVersionsResponseBody(name='body'),
}

async function listFileVersionsWithOptions(request: ListFileVersionsRequest, runtime: Util.RuntimeOptions): ListFileVersionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFileVersions',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFileVersions(request: ListFileVersionsRequest): ListFileVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFileVersionsWithOptions(request, runtime);
}

model ListFoldersRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  parentFolderPath?: string(name='ParentFolderPath'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListFoldersResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    folders?: [ 
      {
        folderPath?: string(name='FolderPath'),
        folderId?: string(name='FolderId'),
      }
    ](name='Folders'),
  }(name='Data'),
}

model ListFoldersResponse = {
  headers: map[string]string(name='headers'),
  body: ListFoldersResponseBody(name='body'),
}

async function listFoldersWithOptions(request: ListFoldersRequest, runtime: Util.RuntimeOptions): ListFoldersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFolders',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFolders(request: ListFoldersRequest): ListFoldersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFoldersWithOptions(request, runtime);
}

model ListInstanceAmountRequest {
  projectId?: long(name='ProjectId'),
  beginDate?: string(name='BeginDate'),
  endDate?: string(name='EndDate'),
}

model ListInstanceAmountResponseBody = {
  requestId?: string(name='RequestId'),
  instanceCounts?: [ 
    {
      date?: long(name='Date'),
      count?: int32(name='Count'),
    }
  ](name='InstanceCounts'),
}

model ListInstanceAmountResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceAmountResponseBody(name='body'),
}

async function listInstanceAmountWithOptions(request: ListInstanceAmountRequest, runtime: Util.RuntimeOptions): ListInstanceAmountResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceAmount',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstanceAmount(request: ListInstanceAmountRequest): ListInstanceAmountResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceAmountWithOptions(request, runtime);
}

model ListInstancesRequest {
  projectEnv?: string(name='ProjectEnv'),
  nodeId?: long(name='NodeId'),
  nodeName?: string(name='NodeName'),
  owner?: string(name='Owner'),
  projectId?: long(name='ProjectId'),
  bizName?: string(name='BizName'),
  programType?: string(name='ProgramType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  dagId?: long(name='DagId'),
  bizdate?: string(name='Bizdate'),
  beginBizdate?: string(name='BeginBizdate'),
  endBizdate?: string(name='EndBizdate'),
}

model ListInstancesResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    instances?: [ 
      {
        status?: string(name='Status'),
        cycTime?: long(name='CycTime'),
        beginRunningTime?: long(name='BeginRunningTime'),
        finishTime?: long(name='FinishTime'),
        errorMessage?: string(name='ErrorMessage'),
        createTime?: long(name='CreateTime'),
        dagId?: long(name='DagId'),
        priority?: int32(name='Priority'),
        taskType?: string(name='TaskType'),
        paramValues?: string(name='ParamValues'),
        connection?: string(name='Connection'),
        baselineId?: long(name='BaselineId'),
        dqcType?: int32(name='DqcType'),
        dagType?: string(name='DagType'),
        businessId?: long(name='BusinessId'),
        taskRerunTime?: int32(name='TaskRerunTime'),
        modifyTime?: long(name='ModifyTime'),
        repeatability?: boolean(name='Repeatability'),
        repeatInterval?: long(name='RepeatInterval'),
        instanceId?: long(name='InstanceId'),
        beginWaitResTime?: long(name='BeginWaitResTime'),
        relatedFlowId?: long(name='RelatedFlowId'),
        bizdate?: long(name='Bizdate'),
        nodeName?: string(name='NodeName'),
        beginWaitTimeTime?: long(name='BeginWaitTimeTime'),
        dqcDescription?: string(name='DqcDescription'),
        nodeId?: long(name='NodeId'),
      }
    ](name='Instances'),
  }(name='Data'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstancesWithOptions(request: ListInstancesRequest, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstancesWithOptions(request, runtime);
}

model ListManualDagInstancesRequest {
  projectEnv?: string(name='ProjectEnv'),
  projectName?: string(name='ProjectName'),
  dagId?: string(name='DagId'),
}

model ListManualDagInstancesResponseBody = {
  requestId?: string(name='RequestId'),
  instances?: [ 
    {
      status?: string(name='Status'),
      beginRunningTime?: long(name='BeginRunningTime'),
      bizDate?: long(name='BizDate'),
      cycTime?: long(name='CycTime'),
      finishTime?: long(name='FinishTime'),
      createTime?: long(name='CreateTime'),
      dagId?: long(name='DagId'),
      instanceId?: long(name='InstanceId'),
      beginWaitResTime?: long(name='BeginWaitResTime'),
      taskType?: string(name='TaskType'),
      paramValues?: string(name='ParamValues'),
      dagType?: string(name='DagType'),
      nodeName?: string(name='NodeName'),
      beginWaitTimeTime?: long(name='BeginWaitTimeTime'),
      nodeId?: long(name='NodeId'),
      modifyTime?: long(name='ModifyTime'),
    }
  ](name='Instances'),
}

model ListManualDagInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListManualDagInstancesResponseBody(name='body'),
}

async function listManualDagInstancesWithOptions(request: ListManualDagInstancesRequest, runtime: Util.RuntimeOptions): ListManualDagInstancesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListManualDagInstances',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listManualDagInstances(request: ListManualDagInstancesRequest): ListManualDagInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listManualDagInstancesWithOptions(request, runtime);
}

model ListMetaDBRequest {
  projectId?: long(name='ProjectId'),
  dataSourceType?: string(name='DataSourceType'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model ListMetaDBResponseBody = {
  requestId?: string(name='RequestId'),
  databaseInfo?: {
    totalCount?: long(name='TotalCount'),
    dbList?: [ 
      {
        type?: string(name='Type'),
        createTimeStamp?: long(name='CreateTimeStamp'),
        UUID?: string(name='UUID'),
        modifiedTimeStamp?: long(name='ModifiedTimeStamp'),
        name?: string(name='Name'),
        ownerId?: string(name='OwnerId'),
        location?: string(name='Location'),
      }
    ](name='DbList'),
  }(name='DatabaseInfo'),
}

model ListMetaDBResponse = {
  headers: map[string]string(name='headers'),
  body: ListMetaDBResponseBody(name='body'),
}

async function listMetaDBWithOptions(request: ListMetaDBRequest, runtime: Util.RuntimeOptions): ListMetaDBResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMetaDB',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMetaDB(request: ListMetaDBRequest): ListMetaDBResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMetaDBWithOptions(request, runtime);
}

model ListNodeInputOrOutputRequest {
  nodeId?: long(name='NodeId'),
  projectEnv?: string(name='ProjectEnv'),
  ioType?: string(name='IoType'),
}

model ListNodeInputOrOutputResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: [ 
    {
      tableName?: string(name='TableName'),
      data?: string(name='Data'),
      nodeId?: long(name='NodeId'),
    }
  ](name='Data'),
}

model ListNodeInputOrOutputResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodeInputOrOutputResponseBody(name='body'),
}

async function listNodeInputOrOutputWithOptions(request: ListNodeInputOrOutputRequest, runtime: Util.RuntimeOptions): ListNodeInputOrOutputResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListNodeInputOrOutput',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNodeInputOrOutput(request: ListNodeInputOrOutputRequest): ListNodeInputOrOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodeInputOrOutputWithOptions(request, runtime);
}

model ListNodeIORequest {
  nodeId?: long(name='NodeId'),
  projectEnv?: string(name='ProjectEnv'),
  ioType?: string(name='IoType'),
}

model ListNodeIOResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: [ 
    {
      tableName?: string(name='TableName'),
      data?: string(name='Data'),
      nodeId?: long(name='NodeId'),
    }
  ](name='Data'),
}

model ListNodeIOResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodeIOResponseBody(name='body'),
}

async function listNodeIOWithOptions(request: ListNodeIORequest, runtime: Util.RuntimeOptions): ListNodeIOResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListNodeIO',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNodeIO(request: ListNodeIORequest): ListNodeIOResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodeIOWithOptions(request, runtime);
}

model ListNodesRequest {
  owner?: string(name='Owner'),
  bizName?: string(name='BizName'),
  programType?: string(name='ProgramType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId'),
  projectEnv?: string(name='ProjectEnv'),
  nodeName?: string(name='NodeName'),
}

model ListNodesResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    nodes?: [ 
      {
        schedulerType?: string(name='SchedulerType'),
        repeatInterval?: long(name='RepeatInterval'),
        repeatability?: boolean(name='Repeatability'),
        projectId?: long(name='ProjectId'),
        programType?: string(name='ProgramType'),
        priority?: int32(name='Priority'),
        ownerId?: string(name='OwnerId'),
        connection?: string(name='Connection'),
        paramValues?: string(name='ParamValues'),
        relatedFlowId?: long(name='RelatedFlowId'),
        dqcType?: int32(name='DqcType'),
        baselineId?: long(name='BaselineId'),
        description?: string(name='Description'),
        nodeName?: string(name='NodeName'),
        resGroupName?: string(name='ResGroupName'),
        businessId?: long(name='BusinessId'),
        dqcDescription?: string(name='DqcDescription'),
        cronExpress?: string(name='CronExpress'),
        nodeId?: long(name='NodeId'),
      }
    ](name='Nodes'),
  }(name='Data'),
}

model ListNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesResponseBody(name='body'),
}

async function listNodesWithOptions(request: ListNodesRequest, runtime: Util.RuntimeOptions): ListNodesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListNodes',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNodes(request: ListNodesRequest): ListNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodesWithOptions(request, runtime);
}

model ListNodesByBaselineRequest {
  baselineId?: long(name='BaselineId'),
}

model ListNodesByBaselineResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: string(name='Success'),
  data?: [ 
    {
      owner?: string(name='Owner'),
      nodeName?: string(name='NodeName'),
      nodeId?: long(name='NodeId'),
      projectId?: long(name='ProjectId'),
    }
  ](name='Data'),
}

model ListNodesByBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesByBaselineResponseBody(name='body'),
}

async function listNodesByBaselineWithOptions(request: ListNodesByBaselineRequest, runtime: Util.RuntimeOptions): ListNodesByBaselineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListNodesByBaseline',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNodesByBaseline(request: ListNodesByBaselineRequest): ListNodesByBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodesByBaselineWithOptions(request, runtime);
}

model ListNodesByOutputRequest {
  projectEnv?: string(name='ProjectEnv'),
  outputs?: string(name='Outputs'),
}

model ListNodesByOutputResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: [ 
    {
      output?: string(name='Output'),
      nodeList?: [ 
        {
          schedulerType?: string(name='SchedulerType'),
          repeatInterval?: int32(name='RepeatInterval'),
          repeatability?: boolean(name='Repeatability'),
          fileType?: string(name='FileType'),
          projectId?: long(name='ProjectId'),
          programType?: string(name='ProgramType'),
          priority?: int32(name='Priority'),
          ownerId?: string(name='OwnerId'),
          connection?: string(name='Connection'),
          paramValues?: string(name='ParamValues'),
          relatedFlowId?: long(name='RelatedFlowId'),
          dqcType?: int32(name='DqcType'),
          baselineId?: long(name='BaselineId'),
          description?: string(name='Description'),
          nodeName?: string(name='NodeName'),
          resGroupName?: string(name='ResGroupName'),
          dqcDescription?: string(name='DqcDescription'),
          cronExpress?: string(name='CronExpress'),
          nodeId?: long(name='NodeId'),
        }
      ](name='NodeList'),
    }
  ](name='Data'),
}

model ListNodesByOutputResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesByOutputResponseBody(name='body'),
}

async function listNodesByOutputWithOptions(request: ListNodesByOutputRequest, runtime: Util.RuntimeOptions): ListNodesByOutputResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListNodesByOutput',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNodesByOutput(request: ListNodesByOutputRequest): ListNodesByOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodesByOutputWithOptions(request, runtime);
}

model ListPermissionApplyOrdersRequest {
  flowStatus?: int32(name='FlowStatus'),
  workspaceId?: int32(name='WorkspaceId'),
  orderType?: int32(name='OrderType'),
  maxComputeProjectName?: string(name='MaxComputeProjectName'),
  tableName?: string(name='TableName'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  engineType?: string(name='EngineType'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  queryType?: int32(name='QueryType'),
}

model ListPermissionApplyOrdersResponseBody = {
  requestId?: string(name='RequestId'),
  applyOrders?: {
    pageSize?: int32(name='PageSize'),
    pageNumber?: int32(name='PageNumber'),
    totalCount?: int32(name='TotalCount'),
    applyOrder?: [ 
      {
        applyBaseId?: string(name='ApplyBaseId'),
        applyTimestamp?: long(name='ApplyTimestamp'),
        flowId?: string(name='FlowId'),
        flowStatus?: int32(name='FlowStatus'),
        approveContent?: {
          applyReason?: string(name='ApplyReason'),
          orderType?: int32(name='OrderType'),
          projectMeta?: {
            workspaceName?: string(name='WorkspaceName'),
            objectMetaList?: [ 
              {
                objectName?: string(name='ObjectName'),
                actions?: [ string ](name='Actions'),
              }
            ](name='ObjectMetaList'),
          }(name='ProjectMeta'),
        }(name='ApproveContent'),
      }
    ](name='ApplyOrder'),
  }(name='ApplyOrders'),
}

model ListPermissionApplyOrdersResponse = {
  headers: map[string]string(name='headers'),
  body: ListPermissionApplyOrdersResponseBody(name='body'),
}

async function listPermissionApplyOrdersWithOptions(request: ListPermissionApplyOrdersRequest, runtime: Util.RuntimeOptions): ListPermissionApplyOrdersResponse {
  Util.validateModel(request);
  var query = {};
  query["FlowStatus"] = request.flowStatus;
  query["WorkspaceId"] = request.workspaceId;
  query["OrderType"] = request.orderType;
  query["MaxComputeProjectName"] = request.maxComputeProjectName;
  query["TableName"] = request.tableName;
  query["StartTime"] = request.startTime;
  query["EndTime"] = request.endTime;
  query["EngineType"] = request.engineType;
  query["PageNum"] = request.pageNum;
  query["PageSize"] = request.pageSize;
  query["QueryType"] = request.queryType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListPermissionApplyOrders',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPermissionApplyOrders(request: ListPermissionApplyOrdersRequest): ListPermissionApplyOrdersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPermissionApplyOrdersWithOptions(request, runtime);
}

model ListProgramTypeCountRequest {
  projectId?: long(name='ProjectId'),
  projectEnv?: string(name='ProjectEnv'),
}

model ListProgramTypeCountResponseBody = {
  requestId?: string(name='RequestId'),
  programTypeAndCounts?: [ 
    {
      count?: int32(name='Count'),
      programType?: string(name='ProgramType'),
    }
  ](name='ProgramTypeAndCounts'),
}

model ListProgramTypeCountResponse = {
  headers: map[string]string(name='headers'),
  body: ListProgramTypeCountResponseBody(name='body'),
}

async function listProgramTypeCountWithOptions(request: ListProgramTypeCountRequest, runtime: Util.RuntimeOptions): ListProgramTypeCountResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListProgramTypeCount',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProgramTypeCount(request: ListProgramTypeCountRequest): ListProgramTypeCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProgramTypeCountWithOptions(request, runtime);
}

model ListProjectIdsRequest {
  userId?: string(name='UserId'),
}

model ListProjectIdsResponseBody = {
  requestId?: string(name='RequestId'),
  projectIds?: [ long ](name='ProjectIds'),
}

model ListProjectIdsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectIdsResponseBody(name='body'),
}

async function listProjectIdsWithOptions(request: ListProjectIdsRequest, runtime: Util.RuntimeOptions): ListProjectIdsResponse {
  Util.validateModel(request);
  var query = {};
  query["UserId"] = request.userId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListProjectIds',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProjectIds(request: ListProjectIdsRequest): ListProjectIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectIdsWithOptions(request, runtime);
}

model ListProjectMembersRequest {
  projectId?: long(name='ProjectId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListProjectMembersResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    projectMemberList?: [ 
      {
        status?: string(name='Status'),
        projectMemberId?: string(name='ProjectMemberId'),
        nick?: string(name='Nick'),
        projectMemberName?: string(name='ProjectMemberName'),
        projectMemberType?: string(name='ProjectMemberType'),
        projectRoleList?: [ 
          {
            projectRoleId?: int32(name='ProjectRoleId'),
            projectRoleType?: string(name='ProjectRoleType'),
            projectRoleName?: string(name='ProjectRoleName'),
            projectRoleCode?: string(name='ProjectRoleCode'),
          }
        ](name='ProjectRoleList'),
      }
    ](name='ProjectMemberList'),
  }(name='Data'),
}

model ListProjectMembersResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectMembersResponseBody(name='body'),
}

async function listProjectMembersWithOptions(request: ListProjectMembersRequest, runtime: Util.RuntimeOptions): ListProjectMembersResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListProjectMembers',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProjectMembers(request: ListProjectMembersRequest): ListProjectMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectMembersWithOptions(request, runtime);
}

model ListProjectRolesRequest {
  projectId?: long(name='ProjectId'),
}

model ListProjectRolesResponseBody = {
  requestId?: string(name='RequestId'),
  projectRoleList?: [ 
    {
      projectRoleId?: int32(name='ProjectRoleId'),
      projectRoleType?: string(name='ProjectRoleType'),
      projectRoleName?: string(name='ProjectRoleName'),
      projectRoleCode?: string(name='ProjectRoleCode'),
    }
  ](name='ProjectRoleList'),
}

model ListProjectRolesResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectRolesResponseBody(name='body'),
}

async function listProjectRolesWithOptions(request: ListProjectRolesRequest, runtime: Util.RuntimeOptions): ListProjectRolesResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListProjectRoles',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProjectRoles(request: ListProjectRolesRequest): ListProjectRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectRolesWithOptions(request, runtime);
}

model ListProjectsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListProjectsResponseBody = {
  requestId?: string(name='RequestId'),
  pageResult?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    projectList?: [ 
      {
        projectStatusCode?: string(name='ProjectStatusCode'),
        projectStatus?: int32(name='ProjectStatus'),
        projectName?: string(name='ProjectName'),
        projectIdentifier?: string(name='ProjectIdentifier'),
        projectId?: long(name='ProjectId'),
        projectDescription?: string(name='ProjectDescription'),
        projectOwnerBaseId?: string(name='ProjectOwnerBaseId'),
      }
    ](name='ProjectList'),
  }(name='PageResult'),
}

model ListProjectsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectsResponseBody(name='body'),
}

async function listProjectsWithOptions(request: ListProjectsRequest, runtime: Util.RuntimeOptions): ListProjectsResponse {
  Util.validateModel(request);
  var query = {};
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListProjects',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProjects(request: ListProjectsRequest): ListProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectsWithOptions(request, runtime);
}

model ListQualityResultsByEntityRequest {
  entityId?: int32(name='EntityId'),
  startDate?: string(name='StartDate'),
  endDate?: string(name='EndDate'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  projectName?: string(name='ProjectName'),
}

model ListQualityResultsByEntityResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    ruleChecks?: [ 
      {
        blockType?: int32(name='BlockType'),
        warningThreshold?: float(name='WarningThreshold'),
        property?: string(name='Property'),
        tableName?: string(name='TableName'),
        comment?: string(name='Comment'),
        checkResultStatus?: int32(name='CheckResultStatus'),
        templateName?: string(name='TemplateName'),
        checkerName?: string(name='CheckerName'),
        ruleId?: int32(name='RuleId'),
        fixedCheck?: boolean(name='FixedCheck'),
        op?: string(name='Op'),
        upperValue?: float(name='UpperValue'),
        actualExpression?: string(name='ActualExpression'),
        externalId?: string(name='ExternalId'),
        timeCost?: string(name='TimeCost'),
        trend?: string(name='Trend'),
        externalType?: string(name='ExternalType'),
        bizDate?: long(name='BizDate'),
        checkResult?: int32(name='CheckResult'),
        resultString?: string(name='ResultString'),
        matchExpression?: string(name='MatchExpression'),
        checkerType?: int32(name='CheckerType'),
        projectName?: string(name='ProjectName'),
        beginTime?: long(name='BeginTime'),
        dateType?: string(name='DateType'),
        criticalThreshold?: float(name='CriticalThreshold'),
        isPrediction?: boolean(name='IsPrediction'),
        ruleName?: string(name='RuleName'),
        checkerId?: int32(name='CheckerId'),
        discreteCheck?: boolean(name='DiscreteCheck'),
        endTime?: long(name='EndTime'),
        methodName?: string(name='MethodName'),
        lowerValue?: float(name='LowerValue'),
        entityId?: int32(name='EntityId'),
        whereCondition?: string(name='WhereCondition'),
        expectValue?: float(name='ExpectValue'),
        templateId?: int32(name='TemplateId'),
        taskId?: string(name='TaskId'),
        id?: int32(name='Id'),
        referenceValue?: [ 
          {
            discreteProperty?: string(name='DiscreteProperty'),
            value?: float(name='Value'),
            bizDate?: string(name='BizDate'),
            singleCheckResult?: int32(name='SingleCheckResult'),
            threshold?: float(name='Threshold'),
          }
        ](name='ReferenceValue'),
        sampleValue?: [ 
          {
            discreteProperty?: string(name='DiscreteProperty'),
            bizDate?: string(name='BizDate'),
            value?: float(name='Value'),
          }
        ](name='SampleValue'),
      }
    ](name='RuleChecks'),
  }(name='Data'),
}

model ListQualityResultsByEntityResponse = {
  headers: map[string]string(name='headers'),
  body: ListQualityResultsByEntityResponseBody(name='body'),
}

async function listQualityResultsByEntityWithOptions(request: ListQualityResultsByEntityRequest, runtime: Util.RuntimeOptions): ListQualityResultsByEntityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListQualityResultsByEntity',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listQualityResultsByEntity(request: ListQualityResultsByEntityRequest): ListQualityResultsByEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQualityResultsByEntityWithOptions(request, runtime);
}

model ListQualityResultsByRuleRequest {
  ruleId?: int32(name='RuleId'),
  startDate?: string(name='StartDate'),
  endDate?: string(name='EndDate'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  projectName?: string(name='ProjectName'),
}

model ListQualityResultsByRuleResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    ruleChecks?: [ 
      {
        blockType?: int32(name='BlockType'),
        warningThreshold?: float(name='WarningThreshold'),
        property?: string(name='Property'),
        tableName?: string(name='TableName'),
        comment?: string(name='Comment'),
        checkResultStatus?: int32(name='CheckResultStatus'),
        templateName?: string(name='TemplateName'),
        checkerName?: string(name='CheckerName'),
        ruleId?: int32(name='RuleId'),
        fixedCheck?: boolean(name='FixedCheck'),
        op?: string(name='Op'),
        upperValue?: float(name='UpperValue'),
        actualExpression?: string(name='ActualExpression'),
        externalId?: string(name='ExternalId'),
        timeCost?: string(name='TimeCost'),
        trend?: string(name='Trend'),
        externalType?: string(name='ExternalType'),
        bizDate?: long(name='BizDate'),
        checkResult?: int32(name='CheckResult'),
        resultString?: string(name='ResultString'),
        matchExpression?: string(name='MatchExpression'),
        checkerType?: int32(name='CheckerType'),
        projectName?: string(name='ProjectName'),
        beginTime?: long(name='BeginTime'),
        dateType?: string(name='DateType'),
        criticalThreshold?: float(name='CriticalThreshold'),
        isPrediction?: boolean(name='IsPrediction'),
        ruleName?: string(name='RuleName'),
        checkerId?: int32(name='CheckerId'),
        discreteCheck?: boolean(name='DiscreteCheck'),
        endTime?: long(name='EndTime'),
        methodName?: string(name='MethodName'),
        lowerValue?: float(name='LowerValue'),
        entityId?: int32(name='EntityId'),
        whereCondition?: string(name='WhereCondition'),
        expectValue?: float(name='ExpectValue'),
        templateId?: int32(name='TemplateId'),
        taskId?: string(name='TaskId'),
        id?: int32(name='Id'),
        referenceValue?: [ 
          {
            discreteProperty?: string(name='DiscreteProperty'),
            value?: float(name='Value'),
            bizDate?: string(name='BizDate'),
            singleCheckResult?: int32(name='SingleCheckResult'),
            threshold?: float(name='Threshold'),
          }
        ](name='ReferenceValue'),
        sampleValue?: [ 
          {
            discreteProperty?: string(name='DiscreteProperty'),
            bizDate?: string(name='BizDate'),
            value?: float(name='Value'),
          }
        ](name='SampleValue'),
      }
    ](name='RuleChecks'),
  }(name='Data'),
}

model ListQualityResultsByRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ListQualityResultsByRuleResponseBody(name='body'),
}

async function listQualityResultsByRuleWithOptions(request: ListQualityResultsByRuleRequest, runtime: Util.RuntimeOptions): ListQualityResultsByRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListQualityResultsByRule',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listQualityResultsByRule(request: ListQualityResultsByRuleRequest): ListQualityResultsByRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQualityResultsByRuleWithOptions(request, runtime);
}

model ListQualityRulesRequest {
  projectName?: string(name='ProjectName'),
  entityId?: long(name='EntityId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListQualityRulesResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    rules?: [ 
      {
        blockType?: int32(name='BlockType'),
        onDutyAccountName?: string(name='OnDutyAccountName'),
        property?: string(name='Property'),
        warningThreshold?: string(name='WarningThreshold'),
        tableName?: string(name='TableName'),
        onDuty?: string(name='OnDuty'),
        comment?: string(name='Comment'),
        ruleCheckerRelationId?: int32(name='RuleCheckerRelationId'),
        fixCheck?: boolean(name='FixCheck'),
        methodId?: int32(name='MethodId'),
        templateName?: string(name='TemplateName'),
        trend?: string(name='Trend'),
        historyWarningThreshold?: string(name='HistoryWarningThreshold'),
        ruleType?: int32(name='RuleType'),
        matchExpression?: string(name='MatchExpression'),
        projectName?: string(name='ProjectName'),
        propertyKey?: string(name='PropertyKey'),
        criticalThreshold?: string(name='CriticalThreshold'),
        historyCriticalThreshold?: string(name='HistoryCriticalThreshold'),
        methodName?: string(name='MethodName'),
        checkerId?: int32(name='CheckerId'),
        entityId?: int32(name='EntityId'),
        expectValue?: string(name='ExpectValue'),
        templateId?: int32(name='TemplateId'),
        id?: int32(name='Id'),
      }
    ](name='Rules'),
  }(name='Data'),
}

model ListQualityRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListQualityRulesResponseBody(name='body'),
}

async function listQualityRulesWithOptions(request: ListQualityRulesRequest, runtime: Util.RuntimeOptions): ListQualityRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListQualityRules',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listQualityRules(request: ListQualityRulesRequest): ListQualityRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQualityRulesWithOptions(request, runtime);
}

model ListRefDISyncTasksRequest {
  projectId?: long(name='ProjectId'),
  datasourceName?: string(name='DatasourceName'),
  taskType?: string(name='TaskType'),
  refType?: string(name='RefType'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
}

model ListRefDISyncTasksResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    DISyncTasks?: [ 
      {
        diSourceDatasource?: string(name='DiSourceDatasource'),
        taskType?: string(name='TaskType'),
        diDestinationDatasource?: string(name='DiDestinationDatasource'),
        nodeName?: string(name='NodeName'),
        nodeId?: long(name='NodeId'),
      }
    ](name='DISyncTasks'),
  }(name='Data'),
}

model ListRefDISyncTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListRefDISyncTasksResponseBody(name='body'),
}

async function listRefDISyncTasksWithOptions(request: ListRefDISyncTasksRequest, runtime: Util.RuntimeOptions): ListRefDISyncTasksResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["DatasourceName"] = request.datasourceName;
  query["TaskType"] = request.taskType;
  query["RefType"] = request.refType;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListRefDISyncTasks',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRefDISyncTasks(request: ListRefDISyncTasksRequest): ListRefDISyncTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRefDISyncTasksWithOptions(request, runtime);
}

model ListRemindsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  founder?: string(name='Founder'),
  nodeId?: long(name='NodeId'),
  remindTypes?: string(name='RemindTypes'),
  alertTarget?: string(name='AlertTarget'),
  searchText?: string(name='SearchText'),
}

model ListRemindsResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    reminds?: [ 
      {
        founder?: string(name='Founder'),
        remindId?: long(name='RemindId'),
        alertUnit?: string(name='AlertUnit'),
        remindType?: string(name='RemindType'),
        dndEnd?: string(name='DndEnd'),
        dndStart?: string(name='DndStart'),
        remindUnit?: string(name='RemindUnit'),
        useflag?: boolean(name='Useflag'),
        remindName?: string(name='RemindName'),
        alertTargets?: [ string ](name='AlertTargets'),
        nodeIds?: [ long ](name='NodeIds'),
        bizProcessIds?: [ long ](name='BizProcessIds'),
        projectIds?: [ long ](name='ProjectIds'),
        baselineIds?: [ long ](name='BaselineIds'),
        alertMethods?: [ string ](name='AlertMethods'),
      }
    ](name='Reminds'),
  }(name='Data'),
}

model ListRemindsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRemindsResponseBody(name='body'),
}

async function listRemindsWithOptions(request: ListRemindsRequest, runtime: Util.RuntimeOptions): ListRemindsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListReminds',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listReminds(request: ListRemindsRequest): ListRemindsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRemindsWithOptions(request, runtime);
}

model ListResourceGroupsRequest {
  resourceGroupType?: int32(name='ResourceGroupType'),
  keyword?: string(name='Keyword'),
  bizExtKey?: string(name='BizExtKey'),
}

model ListResourceGroupsResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  data?: [ 
    {
      status?: int32(name='Status'),
      updateTime?: string(name='UpdateTime'),
      isDefault?: boolean(name='IsDefault'),
      cluster?: string(name='Cluster'),
      enableKp?: boolean(name='EnableKp'),
      resourceGroupType?: string(name='ResourceGroupType'),
      createTime?: string(name='CreateTime'),
      identifier?: string(name='Identifier'),
      mode?: string(name='Mode'),
      bizExtKey?: string(name='BizExtKey'),
      sequence?: int32(name='Sequence'),
      specs?: map[string]any(name='Specs'),
      name?: string(name='Name'),
      id?: long(name='Id'),
      tenantId?: long(name='TenantId'),
    }
  ](name='Data'),
}

model ListResourceGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListResourceGroupsResponseBody(name='body'),
}

async function listResourceGroupsWithOptions(request: ListResourceGroupsRequest, runtime: Util.RuntimeOptions): ListResourceGroupsResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceGroupType"] = request.resourceGroupType;
  query["Keyword"] = request.keyword;
  query["BizExtKey"] = request.bizExtKey;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceGroups',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceGroups(request: ListResourceGroupsRequest): ListResourceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceGroupsWithOptions(request, runtime);
}

model ListSuccessInstanceAmountRequest {
  projectId?: long(name='ProjectId'),
}

model ListSuccessInstanceAmountResponseBody = {
  requestId?: string(name='RequestId'),
  instanceStatusTrend?: {
    todayTrend?: [ 
      {
        timePoint?: string(name='TimePoint'),
        count?: int32(name='Count'),
      }
    ](name='TodayTrend'),
    yesterdayTrend?: [ 
      {
        timePoint?: string(name='TimePoint'),
        count?: int32(name='Count'),
      }
    ](name='YesterdayTrend'),
    avgTrend?: [ 
      {
        timePoint?: string(name='TimePoint'),
        count?: int32(name='Count'),
      }
    ](name='AvgTrend'),
  }(name='InstanceStatusTrend'),
}

model ListSuccessInstanceAmountResponse = {
  headers: map[string]string(name='headers'),
  body: ListSuccessInstanceAmountResponseBody(name='body'),
}

async function listSuccessInstanceAmountWithOptions(request: ListSuccessInstanceAmountRequest, runtime: Util.RuntimeOptions): ListSuccessInstanceAmountResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListSuccessInstanceAmount',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSuccessInstanceAmount(request: ListSuccessInstanceAmountRequest): ListSuccessInstanceAmountResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSuccessInstanceAmountWithOptions(request, runtime);
}

model ListTableLevelRequest {
  projectId?: long(name='ProjectId'),
  levelType?: int32(name='LevelType'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model ListTableLevelResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  tableLevelInfo?: {
    totalCount?: long(name='TotalCount'),
    levelList?: [ 
      {
        levelType?: int32(name='LevelType'),
        description?: string(name='Description'),
        name?: string(name='Name'),
        projectId?: long(name='ProjectId'),
        levelId?: long(name='LevelId'),
      }
    ](name='LevelList'),
  }(name='TableLevelInfo'),
}

model ListTableLevelResponse = {
  headers: map[string]string(name='headers'),
  body: ListTableLevelResponseBody(name='body'),
}

async function listTableLevelWithOptions(request: ListTableLevelRequest, runtime: Util.RuntimeOptions): ListTableLevelResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTableLevel',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTableLevel(request: ListTableLevelRequest): ListTableLevelResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTableLevelWithOptions(request, runtime);
}

model ListTableThemeRequest {
  projectId?: long(name='ProjectId'),
  parentId?: long(name='ParentId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model ListTableThemeResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    totalCount?: long(name='TotalCount'),
    themeList?: [ 
      {
        createTimeStamp?: long(name='CreateTimeStamp'),
        parentId?: long(name='ParentId'),
        themeId?: long(name='ThemeId'),
        projectId?: long(name='ProjectId'),
        name?: string(name='Name'),
        level?: int32(name='Level'),
        creator?: string(name='Creator'),
      }
    ](name='ThemeList'),
  }(name='Data'),
}

model ListTableThemeResponse = {
  headers: map[string]string(name='headers'),
  body: ListTableThemeResponseBody(name='body'),
}

async function listTableThemeWithOptions(request: ListTableThemeRequest, runtime: Util.RuntimeOptions): ListTableThemeResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTableTheme',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTableTheme(request: ListTableThemeRequest): ListTableThemeResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTableThemeWithOptions(request, runtime);
}

model ListTopicsRequest {
  beginTime?: string(name='BeginTime'),
  endTime?: string(name='EndTime'),
  topicTypes?: string(name='TopicTypes'),
  topicStatuses?: string(name='TopicStatuses'),
  nodeId?: long(name='NodeId'),
  instanceId?: long(name='InstanceId'),
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListTopicsResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    topics?: [ 
      {
        topicName?: string(name='TopicName'),
        projectId?: long(name='ProjectId'),
        nodeOwner?: string(name='NodeOwner'),
        instanceId?: long(name='InstanceId'),
        fixTime?: long(name='FixTime'),
        topicType?: string(name='TopicType'),
        topicStatus?: string(name='TopicStatus'),
        happenTime?: long(name='HappenTime'),
        nodeName?: string(name='NodeName'),
        topicId?: long(name='TopicId'),
        addTime?: long(name='AddTime'),
        nodeId?: long(name='NodeId'),
      }
    ](name='Topics'),
  }(name='Data'),
}

model ListTopicsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTopicsResponseBody(name='body'),
}

async function listTopicsWithOptions(request: ListTopicsRequest, runtime: Util.RuntimeOptions): ListTopicsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListTopics',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTopics(request: ListTopicsRequest): ListTopicsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTopicsWithOptions(request, runtime);
}

model PublishDataServiceApiRequest {
  tenantId?: long(name='TenantId'),
  projectId?: long(name='ProjectId'),
  apiId?: long(name='ApiId'),
}

model PublishDataServiceApiResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model PublishDataServiceApiResponse = {
  headers: map[string]string(name='headers'),
  body: PublishDataServiceApiResponseBody(name='body'),
}

async function publishDataServiceApiWithOptions(request: PublishDataServiceApiRequest, runtime: Util.RuntimeOptions): PublishDataServiceApiResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'PublishDataServiceApi',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function publishDataServiceApi(request: PublishDataServiceApiRequest): PublishDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishDataServiceApiWithOptions(request, runtime);
}

model QueryDISyncTaskConfigProcessResultRequest {
  projectId?: long(name='ProjectId'),
  taskType?: string(name='TaskType'),
  asyncProcessId?: long(name='AsyncProcessId'),
}

model QueryDISyncTaskConfigProcessResultResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    message?: string(name='Message'),
    taskContent?: string(name='TaskContent'),
  }(name='Data'),
}

model QueryDISyncTaskConfigProcessResultResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDISyncTaskConfigProcessResultResponseBody(name='body'),
}

async function queryDISyncTaskConfigProcessResultWithOptions(request: QueryDISyncTaskConfigProcessResultRequest, runtime: Util.RuntimeOptions): QueryDISyncTaskConfigProcessResultResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["TaskType"] = request.taskType;
  query["AsyncProcessId"] = request.asyncProcessId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryDISyncTaskConfigProcessResult',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDISyncTaskConfigProcessResult(request: QueryDISyncTaskConfigProcessResultRequest): QueryDISyncTaskConfigProcessResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDISyncTaskConfigProcessResultWithOptions(request, runtime);
}

model QueryPublicModelEngineRequest {
  text?: string(name='Text'),
  projectId?: string(name='ProjectId'),
}

model QueryPublicModelEngineResponseBody = {
  requestId?: string(name='RequestId'),
  returnValue?: [  map[string]any ](name='ReturnValue'),
}

model QueryPublicModelEngineResponse = {
  headers: map[string]string(name='headers'),
  body: QueryPublicModelEngineResponseBody(name='body'),
}

async function queryPublicModelEngineWithOptions(request: QueryPublicModelEngineRequest, runtime: Util.RuntimeOptions): QueryPublicModelEngineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryPublicModelEngine',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryPublicModelEngine(request: QueryPublicModelEngineRequest): QueryPublicModelEngineResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPublicModelEngineWithOptions(request, runtime);
}

model RemoveProjectMemberFromRoleRequest {
  projectId?: long(name='ProjectId'),
  userId?: string(name='UserId'),
  roleCode?: string(name='RoleCode'),
}

model RemoveProjectMemberFromRoleResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveProjectMemberFromRoleResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveProjectMemberFromRoleResponseBody(name='body'),
}

async function removeProjectMemberFromRoleWithOptions(request: RemoveProjectMemberFromRoleRequest, runtime: Util.RuntimeOptions): RemoveProjectMemberFromRoleResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["UserId"] = request.userId;
  query["RoleCode"] = request.roleCode;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RemoveProjectMemberFromRole',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeProjectMemberFromRole(request: RemoveProjectMemberFromRoleRequest): RemoveProjectMemberFromRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeProjectMemberFromRoleWithOptions(request, runtime);
}

model RestartInstanceRequest {
  instanceId?: long(name='InstanceId'),
  projectEnv?: string(name='ProjectEnv'),
}

model RestartInstanceResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model RestartInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RestartInstanceResponseBody(name='body'),
}

async function restartInstanceWithOptions(request: RestartInstanceRequest, runtime: Util.RuntimeOptions): RestartInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RestartInstance',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restartInstance(request: RestartInstanceRequest): RestartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartInstanceWithOptions(request, runtime);
}

model ResumeInstanceRequest {
  instanceId?: long(name='InstanceId'),
  projectEnv?: string(name='ProjectEnv'),
}

model ResumeInstanceResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ResumeInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ResumeInstanceResponseBody(name='body'),
}

async function resumeInstanceWithOptions(request: ResumeInstanceRequest, runtime: Util.RuntimeOptions): ResumeInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ResumeInstance',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resumeInstance(request: ResumeInstanceRequest): ResumeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumeInstanceWithOptions(request, runtime);
}

model RevokeColumnPermissionRequest {
  workspaceId?: long(name='WorkspaceId'),
  maxComputeProjectName?: string(name='MaxComputeProjectName'),
  tableName?: string(name='TableName'),
  columns?: string(name='Columns'),
  revokeUserName?: string(name='RevokeUserName'),
  revokeUserId?: string(name='RevokeUserId'),
}

model RevokeColumnPermissionResponseBody = {
  revokeSuccess?: boolean(name='RevokeSuccess'),
  requestId?: string(name='RequestId'),
}

model RevokeColumnPermissionResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeColumnPermissionResponseBody(name='body'),
}

async function revokeColumnPermissionWithOptions(request: RevokeColumnPermissionRequest, runtime: Util.RuntimeOptions): RevokeColumnPermissionResponse {
  Util.validateModel(request);
  var query = {};
  query["WorkspaceId"] = request.workspaceId;
  query["MaxComputeProjectName"] = request.maxComputeProjectName;
  query["TableName"] = request.tableName;
  query["Columns"] = request.columns;
  query["RevokeUserName"] = request.revokeUserName;
  query["RevokeUserId"] = request.revokeUserId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RevokeColumnPermission',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokeColumnPermission(request: RevokeColumnPermissionRequest): RevokeColumnPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeColumnPermissionWithOptions(request, runtime);
}

model RevokeTablePermissionRequest {
  workspaceId?: long(name='WorkspaceId'),
  maxComputeProjectName?: string(name='MaxComputeProjectName'),
  tableName?: string(name='TableName'),
  actions?: string(name='Actions'),
  revokeUserName?: string(name='RevokeUserName'),
  revokeUserId?: string(name='RevokeUserId'),
}

model RevokeTablePermissionResponseBody = {
  revokeSuccess?: boolean(name='RevokeSuccess'),
  requestId?: string(name='RequestId'),
}

model RevokeTablePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeTablePermissionResponseBody(name='body'),
}

async function revokeTablePermissionWithOptions(request: RevokeTablePermissionRequest, runtime: Util.RuntimeOptions): RevokeTablePermissionResponse {
  Util.validateModel(request);
  var query = {};
  query["WorkspaceId"] = request.workspaceId;
  query["MaxComputeProjectName"] = request.maxComputeProjectName;
  query["TableName"] = request.tableName;
  query["Actions"] = request.actions;
  query["RevokeUserName"] = request.revokeUserName;
  query["RevokeUserId"] = request.revokeUserId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RevokeTablePermission',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokeTablePermission(request: RevokeTablePermissionRequest): RevokeTablePermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeTablePermissionWithOptions(request, runtime);
}

model RunCycleDagNodesRequest {
  projectEnv?: string(name='ProjectEnv'),
  startBizDate?: string(name='StartBizDate'),
  name?: string(name='Name'),
  rootNodeId?: long(name='RootNodeId'),
  excludeNodeIds?: string(name='ExcludeNodeIds'),
  bizBeginTime?: string(name='BizBeginTime'),
  bizEndTime?: string(name='BizEndTime'),
  parallelism?: boolean(name='Parallelism'),
  endBizDate?: string(name='EndBizDate'),
  nodeParams?: string(name='NodeParams'),
  includeNodeIds?: string(name='IncludeNodeIds'),
}

model RunCycleDagNodesResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: [ long ](name='Data'),
}

model RunCycleDagNodesResponse = {
  headers: map[string]string(name='headers'),
  body: RunCycleDagNodesResponseBody(name='body'),
}

async function runCycleDagNodesWithOptions(request: RunCycleDagNodesRequest, runtime: Util.RuntimeOptions): RunCycleDagNodesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RunCycleDagNodes',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runCycleDagNodes(request: RunCycleDagNodesRequest): RunCycleDagNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return runCycleDagNodesWithOptions(request, runtime);
}

model RunManualDagNodesRequest {
  projectEnv?: string(name='ProjectEnv'),
  projectName?: string(name='ProjectName'),
  flowName?: string(name='FlowName'),
  bizDate?: string(name='BizDate'),
  nodeParameters?: string(name='NodeParameters'),
  dagParameters?: string(name='DagParameters'),
  includeNodeIds?: string(name='IncludeNodeIds'),
  excludeNodeIds?: string(name='ExcludeNodeIds'),
  projectId?: long(name='ProjectId'),
}

model RunManualDagNodesResponseBody = {
  dagId?: long(name='DagId'),
  requestId?: string(name='RequestId'),
}

model RunManualDagNodesResponse = {
  headers: map[string]string(name='headers'),
  body: RunManualDagNodesResponseBody(name='body'),
}

async function runManualDagNodesWithOptions(request: RunManualDagNodesRequest, runtime: Util.RuntimeOptions): RunManualDagNodesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RunManualDagNodes',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runManualDagNodes(request: RunManualDagNodesRequest): RunManualDagNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return runManualDagNodesWithOptions(request, runtime);
}

model RunSmokeTestRequest {
  projectEnv?: string(name='ProjectEnv'),
  bizdate?: string(name='Bizdate'),
  name?: string(name='Name'),
  nodeId?: long(name='NodeId'),
  nodeParams?: string(name='NodeParams'),
}

model RunSmokeTestResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: long(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model RunSmokeTestResponse = {
  headers: map[string]string(name='headers'),
  body: RunSmokeTestResponseBody(name='body'),
}

async function runSmokeTestWithOptions(request: RunSmokeTestRequest, runtime: Util.RuntimeOptions): RunSmokeTestResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RunSmokeTest',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runSmokeTest(request: RunSmokeTestRequest): RunSmokeTestResponse {
  var runtime = new Util.RuntimeOptions{};
  return runSmokeTestWithOptions(request, runtime);
}

model RunTriggerNodeRequest {
  nodeId?: long(name='NodeId'),
  cycleTime?: long(name='CycleTime'),
  bizDate?: long(name='BizDate'),
  appId?: long(name='AppId'),
}

model RunTriggerNodeResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
}

model RunTriggerNodeResponse = {
  headers: map[string]string(name='headers'),
  body: RunTriggerNodeResponseBody(name='body'),
}

async function runTriggerNodeWithOptions(request: RunTriggerNodeRequest, runtime: Util.RuntimeOptions): RunTriggerNodeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RunTriggerNode',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runTriggerNode(request: RunTriggerNodeRequest): RunTriggerNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return runTriggerNodeWithOptions(request, runtime);
}

model ScanSensitiveDataRequest {
  data?: string(name='Data'),
}

model ScanSensitiveDataResponseBody = {
  sensitives?: map[string]any(name='Sensitives'),
  requestId?: string(name='RequestId'),
}

model ScanSensitiveDataResponse = {
  headers: map[string]string(name='headers'),
  body: ScanSensitiveDataResponseBody(name='body'),
}

async function scanSensitiveDataWithOptions(request: ScanSensitiveDataRequest, runtime: Util.RuntimeOptions): ScanSensitiveDataResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ScanSensitiveData',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function scanSensitiveData(request: ScanSensitiveDataRequest): ScanSensitiveDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return scanSensitiveDataWithOptions(request, runtime);
}

model SearchMetaTablesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  appGuid?: string(name='AppGuid'),
  keyword?: string(name='Keyword'),
  entityType?: int32(name='EntityType'),
  clusterId?: string(name='ClusterId'),
  dataSourceType?: string(name='DataSourceType'),
}

model SearchMetaTablesResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    dataEntityList?: [ 
      {
        tableName?: string(name='TableName'),
        databaseName?: string(name='DatabaseName'),
        entityType?: int32(name='EntityType'),
        projectName?: string(name='ProjectName'),
        projectId?: long(name='ProjectId'),
        tableGuid?: string(name='TableGuid'),
        ownerId?: string(name='OwnerId'),
        clusterId?: string(name='ClusterId'),
        envType?: int32(name='EnvType'),
        tenantId?: long(name='TenantId'),
      }
    ](name='DataEntityList'),
  }(name='Data'),
}

model SearchMetaTablesResponse = {
  headers: map[string]string(name='headers'),
  body: SearchMetaTablesResponseBody(name='body'),
}

async function searchMetaTablesWithOptions(request: SearchMetaTablesRequest, runtime: Util.RuntimeOptions): SearchMetaTablesResponse {
  Util.validateModel(request);
  var query = {};
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["AppGuid"] = request.appGuid;
  query["Keyword"] = request.keyword;
  query["EntityType"] = request.entityType;
  query["ClusterId"] = request.clusterId;
  query["DataSourceType"] = request.dataSourceType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SearchMetaTables',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchMetaTables(request: SearchMetaTablesRequest): SearchMetaTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchMetaTablesWithOptions(request, runtime);
}

model SearchNodesByOutputRequest {
  projectEnv?: string(name='ProjectEnv'),
  outputs?: string(name='Outputs'),
}

model SearchNodesByOutputResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: map[string]any(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model SearchNodesByOutputResponse = {
  headers: map[string]string(name='headers'),
  body: SearchNodesByOutputResponseBody(name='body'),
}

async function searchNodesByOutputWithOptions(request: SearchNodesByOutputRequest, runtime: Util.RuntimeOptions): SearchNodesByOutputResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SearchNodesByOutput',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchNodesByOutput(request: SearchNodesByOutputRequest): SearchNodesByOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchNodesByOutputWithOptions(request, runtime);
}

model SetConnectionShareRequest {
  projectId?: long(name='ProjectId'),
  datasourceName?: string(name='DatasourceName'),
  envType?: string(name='EnvType'),
  projectPermissions?: string(name='ProjectPermissions'),
  userPermissions?: string(name='UserPermissions'),
}

model SetConnectionShareResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
  }(name='Data'),
}

model SetConnectionShareResponse = {
  headers: map[string]string(name='headers'),
  body: SetConnectionShareResponseBody(name='body'),
}

async function setConnectionShareWithOptions(request: SetConnectionShareRequest, runtime: Util.RuntimeOptions): SetConnectionShareResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["DatasourceName"] = request.datasourceName;
  query["EnvType"] = request.envType;
  query["ProjectPermissions"] = request.projectPermissions;
  query["UserPermissions"] = request.userPermissions;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SetConnectionShare',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setConnectionShare(request: SetConnectionShareRequest): SetConnectionShareResponse {
  var runtime = new Util.RuntimeOptions{};
  return setConnectionShareWithOptions(request, runtime);
}

model SetDataSourceShareRequest {
  projectId?: long(name='ProjectId'),
  datasourceName?: string(name='DatasourceName'),
  envType?: string(name='EnvType'),
  projectPermissions?: string(name='ProjectPermissions'),
  userPermissions?: string(name='UserPermissions'),
}

model SetDataSourceShareResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    message?: string(name='Message'),
  }(name='Data'),
}

model SetDataSourceShareResponse = {
  headers: map[string]string(name='headers'),
  body: SetDataSourceShareResponseBody(name='body'),
}

async function setDataSourceShareWithOptions(request: SetDataSourceShareRequest, runtime: Util.RuntimeOptions): SetDataSourceShareResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["DatasourceName"] = request.datasourceName;
  query["EnvType"] = request.envType;
  query["ProjectPermissions"] = request.projectPermissions;
  query["UserPermissions"] = request.userPermissions;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SetDataSourceShare',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDataSourceShare(request: SetDataSourceShareRequest): SetDataSourceShareResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDataSourceShareWithOptions(request, runtime);
}

model SetSuccessInstanceRequest {
  instanceId?: long(name='InstanceId'),
  projectEnv?: string(name='ProjectEnv'),
}

model SetSuccessInstanceResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model SetSuccessInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: SetSuccessInstanceResponseBody(name='body'),
}

async function setSuccessInstanceWithOptions(request: SetSuccessInstanceRequest, runtime: Util.RuntimeOptions): SetSuccessInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SetSuccessInstance',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setSuccessInstance(request: SetSuccessInstanceRequest): SetSuccessInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return setSuccessInstanceWithOptions(request, runtime);
}

model StartDISyncInstanceRequest {
  projectId?: long(name='ProjectId'),
  taskType?: string(name='TaskType'),
  fileId?: long(name='FileId'),
  startParam?: string(name='StartParam'),
}

model StartDISyncInstanceResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    message?: string(name='Message'),
  }(name='Data'),
}

model StartDISyncInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StartDISyncInstanceResponseBody(name='body'),
}

async function startDISyncInstanceWithOptions(request: StartDISyncInstanceRequest, runtime: Util.RuntimeOptions): StartDISyncInstanceResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["TaskType"] = request.taskType;
  query["FileId"] = request.fileId;
  query["StartParam"] = request.startParam;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'StartDISyncInstance',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startDISyncInstance(request: StartDISyncInstanceRequest): StartDISyncInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startDISyncInstanceWithOptions(request, runtime);
}

model StartMigrationRequest {
  projectId?: long(name='ProjectId'),
  migrationId?: long(name='MigrationId'),
}

model StartMigrationResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model StartMigrationResponse = {
  headers: map[string]string(name='headers'),
  body: StartMigrationResponseBody(name='body'),
}

async function startMigrationWithOptions(request: StartMigrationRequest, runtime: Util.RuntimeOptions): StartMigrationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'StartMigration',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startMigration(request: StartMigrationRequest): StartMigrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return startMigrationWithOptions(request, runtime);
}

model StopDISyncInstanceRequest {
  projectId?: long(name='ProjectId'),
  taskType?: string(name='TaskType'),
  fileId?: long(name='FileId'),
}

model StopDISyncInstanceResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    message?: string(name='Message'),
  }(name='Data'),
}

model StopDISyncInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopDISyncInstanceResponseBody(name='body'),
}

async function stopDISyncInstanceWithOptions(request: StopDISyncInstanceRequest, runtime: Util.RuntimeOptions): StopDISyncInstanceResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["TaskType"] = request.taskType;
  query["FileId"] = request.fileId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'StopDISyncInstance',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopDISyncInstance(request: StopDISyncInstanceRequest): StopDISyncInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopDISyncInstanceWithOptions(request, runtime);
}

model StopInstanceRequest {
  instanceId?: long(name='InstanceId'),
  projectEnv?: string(name='ProjectEnv'),
}

model StopInstanceResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model StopInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopInstanceResponseBody(name='body'),
}

async function stopInstanceWithOptions(request: StopInstanceRequest, runtime: Util.RuntimeOptions): StopInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'StopInstance',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopInstance(request: StopInstanceRequest): StopInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopInstanceWithOptions(request, runtime);
}

model SubmitFileRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  fileId?: long(name='FileId'),
  comment?: string(name='Comment'),
}

model SubmitFileResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: long(name='Data'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model SubmitFileResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFileResponseBody(name='body'),
}

async function submitFileWithOptions(request: SubmitFileRequest, runtime: Util.RuntimeOptions): SubmitFileResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitFile',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitFile(request: SubmitFileRequest): SubmitFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFileWithOptions(request, runtime);
}

model SuspendInstanceRequest {
  instanceId?: long(name='InstanceId'),
  projectEnv?: string(name='ProjectEnv'),
}

model SuspendInstanceResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model SuspendInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: SuspendInstanceResponseBody(name='body'),
}

async function suspendInstanceWithOptions(request: SuspendInstanceRequest, runtime: Util.RuntimeOptions): SuspendInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SuspendInstance',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function suspendInstance(request: SuspendInstanceRequest): SuspendInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return suspendInstanceWithOptions(request, runtime);
}

model TerminateDISyncInstanceRequest {
  projectId?: long(name='ProjectId'),
  taskType?: string(name='TaskType'),
  fileId?: long(name='FileId'),
}

model TerminateDISyncInstanceResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    message?: string(name='Message'),
  }(name='Data'),
}

model TerminateDISyncInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: TerminateDISyncInstanceResponseBody(name='body'),
}

async function terminateDISyncInstanceWithOptions(request: TerminateDISyncInstanceRequest, runtime: Util.RuntimeOptions): TerminateDISyncInstanceResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["TaskType"] = request.taskType;
  query["FileId"] = request.fileId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'TerminateDISyncInstance',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function terminateDISyncInstance(request: TerminateDISyncInstanceRequest): TerminateDISyncInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return terminateDISyncInstanceWithOptions(request, runtime);
}

model TestNetworkConnectionRequest {
  projectId?: long(name='ProjectId'),
  datasourceName?: string(name='DatasourceName'),
  envType?: string(name='EnvType'),
  resourceGroup?: string(name='ResourceGroup'),
}

model TestNetworkConnectionResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  taskList?: {
    connectMessage?: string(name='ConnectMessage'),
    connectStatus?: boolean(name='ConnectStatus'),
  }(name='TaskList'),
}

model TestNetworkConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: TestNetworkConnectionResponseBody(name='body'),
}

async function testNetworkConnectionWithOptions(request: TestNetworkConnectionRequest, runtime: Util.RuntimeOptions): TestNetworkConnectionResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["DatasourceName"] = request.datasourceName;
  query["EnvType"] = request.envType;
  query["ResourceGroup"] = request.resourceGroup;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'TestNetworkConnection',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function testNetworkConnection(request: TestNetworkConnectionRequest): TestNetworkConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return testNetworkConnectionWithOptions(request, runtime);
}

model TopTenElapsedTimeInstanceRequest {
  projectId?: long(name='ProjectId'),
}

model TopTenElapsedTimeInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  instanceConsumeTimeRank?: {
    updateTime?: long(name='UpdateTime'),
    consumeTimeRank?: [ 
      {
        owner?: string(name='Owner'),
        nodeName?: string(name='NodeName'),
        businessDate?: long(name='BusinessDate'),
        programType?: int32(name='ProgramType'),
        instanceId?: long(name='InstanceId'),
        nodeId?: long(name='NodeId'),
        consumed?: long(name='Consumed'),
      }
    ](name='ConsumeTimeRank'),
  }(name='InstanceConsumeTimeRank'),
}

model TopTenElapsedTimeInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: TopTenElapsedTimeInstanceResponseBody(name='body'),
}

async function topTenElapsedTimeInstanceWithOptions(request: TopTenElapsedTimeInstanceRequest, runtime: Util.RuntimeOptions): TopTenElapsedTimeInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'TopTenElapsedTimeInstance',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function topTenElapsedTimeInstance(request: TopTenElapsedTimeInstanceRequest): TopTenElapsedTimeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return topTenElapsedTimeInstanceWithOptions(request, runtime);
}

model TopTenErrorTimesInstanceRequest {
  projectId?: long(name='ProjectId'),
}

model TopTenErrorTimesInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  instanceErrorRank?: {
    updateTime?: long(name='UpdateTime'),
    errorRank?: [ 
      {
        owner?: string(name='Owner'),
        nodeName?: string(name='NodeName'),
        projectId?: long(name='ProjectId'),
        programType?: int32(name='ProgramType'),
        nodeId?: long(name='NodeId'),
        count?: int32(name='Count'),
      }
    ](name='ErrorRank'),
  }(name='InstanceErrorRank'),
}

model TopTenErrorTimesInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: TopTenErrorTimesInstanceResponseBody(name='body'),
}

async function topTenErrorTimesInstanceWithOptions(request: TopTenErrorTimesInstanceRequest, runtime: Util.RuntimeOptions): TopTenErrorTimesInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'TopTenErrorTimesInstance',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function topTenErrorTimesInstance(request: TopTenErrorTimesInstanceRequest): TopTenErrorTimesInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return topTenErrorTimesInstanceWithOptions(request, runtime);
}

model UpdateBusinessRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  businessName?: string(name='BusinessName'),
  description?: string(name='Description'),
  owner?: string(name='Owner'),
  businessId?: long(name='BusinessId'),
}

model UpdateBusinessResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model UpdateBusinessResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateBusinessResponseBody(name='body'),
}

async function updateBusinessWithOptions(request: UpdateBusinessRequest, runtime: Util.RuntimeOptions): UpdateBusinessResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBusiness',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateBusiness(request: UpdateBusinessRequest): UpdateBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBusinessWithOptions(request, runtime);
}

model UpdateConnectionRequest {
  description?: string(name='Description'),
  envType?: int32(name='EnvType'),
  content?: string(name='Content'),
  status?: string(name='Status'),
  connectionId?: long(name='ConnectionId'),
}

model UpdateConnectionResponseBody = {
  httpStatusCode?: string(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateConnectionResponseBody(name='body'),
}

async function updateConnectionWithOptions(request: UpdateConnectionRequest, runtime: Util.RuntimeOptions): UpdateConnectionResponse {
  Util.validateModel(request);
  var query = {};
  query["Description"] = request.description;
  query["EnvType"] = request.envType;
  query["Content"] = request.content;
  query["Status"] = request.status;
  query["ConnectionId"] = request.connectionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConnection',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'PUT',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateConnection(request: UpdateConnectionRequest): UpdateConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConnectionWithOptions(request, runtime);
}

model UpdateDataServiceApiRequest {
  tenantId?: long(name='TenantId'),
  projectId?: long(name='ProjectId'),
  apiId?: long(name='ApiId'),
  requestMethod?: int32(name='RequestMethod'),
  responseContentType?: int32(name='ResponseContentType'),
  timeout?: int32(name='Timeout'),
  visibleRange?: int32(name='VisibleRange'),
  protocols?: string(name='Protocols'),
  wizardDetails?: string(name='WizardDetails'),
  scriptDetails?: string(name='ScriptDetails'),
  registrationDetails?: string(name='RegistrationDetails'),
  apiPath?: string(name='ApiPath'),
  apiDescription?: string(name='ApiDescription'),
}

model UpdateDataServiceApiResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model UpdateDataServiceApiResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDataServiceApiResponseBody(name='body'),
}

async function updateDataServiceApiWithOptions(request: UpdateDataServiceApiRequest, runtime: Util.RuntimeOptions): UpdateDataServiceApiResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDataServiceApi',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDataServiceApi(request: UpdateDataServiceApiRequest): UpdateDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDataServiceApiWithOptions(request, runtime);
}

model UpdateDataSourceRequest {
  description?: string(name='Description'),
  envType?: int32(name='EnvType'),
  content?: string(name='Content'),
  status?: string(name='Status'),
  dataSourceId?: long(name='DataSourceId'),
}

model UpdateDataSourceResponseBody = {
  httpStatusCode?: string(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDataSourceResponseBody(name='body'),
}

async function updateDataSourceWithOptions(request: UpdateDataSourceRequest, runtime: Util.RuntimeOptions): UpdateDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  query["Description"] = request.description;
  query["EnvType"] = request.envType;
  query["Content"] = request.content;
  query["Status"] = request.status;
  query["DataSourceId"] = request.dataSourceId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDataSource',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'PUT',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDataSource(request: UpdateDataSourceRequest): UpdateDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDataSourceWithOptions(request, runtime);
}

model UpdateDIProjectConfigRequest {
  projectId?: long(name='ProjectId'),
  destinationType?: string(name='DestinationType'),
  sourceType?: string(name='SourceType'),
  projectConfig?: string(name='ProjectConfig'),
}

model UpdateDIProjectConfigResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
  }(name='Data'),
}

model UpdateDIProjectConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDIProjectConfigResponseBody(name='body'),
}

async function updateDIProjectConfigWithOptions(request: UpdateDIProjectConfigRequest, runtime: Util.RuntimeOptions): UpdateDIProjectConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["DestinationType"] = request.destinationType;
  query["SourceType"] = request.sourceType;
  query["ProjectConfig"] = request.projectConfig;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDIProjectConfig',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDIProjectConfig(request: UpdateDIProjectConfigRequest): UpdateDIProjectConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDIProjectConfigWithOptions(request, runtime);
}

model UpdateDISyncTaskRequest {
  projectId?: long(name='ProjectId'),
  taskType?: string(name='TaskType'),
  taskContent?: string(name='TaskContent'),
  taskParam?: string(name='TaskParam'),
  fileId?: long(name='FileId'),
}

model UpdateDISyncTaskResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    message?: string(name='Message'),
  }(name='Data'),
}

model UpdateDISyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDISyncTaskResponseBody(name='body'),
}

async function updateDISyncTaskWithOptions(request: UpdateDISyncTaskRequest, runtime: Util.RuntimeOptions): UpdateDISyncTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["TaskType"] = request.taskType;
  query["TaskContent"] = request.taskContent;
  query["TaskParam"] = request.taskParam;
  query["FileId"] = request.fileId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDISyncTask',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDISyncTask(request: UpdateDISyncTaskRequest): UpdateDISyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDISyncTaskWithOptions(request, runtime);
}

model UpdateFileRequest {
  fileFolderPath?: string(name='FileFolderPath'),
  projectId?: long(name='ProjectId'),
  fileName?: string(name='FileName'),
  fileDescription?: string(name='FileDescription'),
  content?: string(name='Content'),
  autoRerunTimes?: int32(name='AutoRerunTimes'),
  autoRerunIntervalMillis?: int32(name='AutoRerunIntervalMillis'),
  rerunMode?: string(name='RerunMode'),
  stop?: boolean(name='Stop'),
  paraValue?: string(name='ParaValue'),
  startEffectDate?: long(name='StartEffectDate'),
  endEffectDate?: long(name='EndEffectDate'),
  cronExpress?: string(name='CronExpress'),
  cycleType?: string(name='CycleType'),
  dependentType?: string(name='DependentType'),
  dependentNodeIdList?: string(name='DependentNodeIdList'),
  inputList?: string(name='InputList'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  fileId?: long(name='FileId'),
  outputList?: string(name='OutputList'),
  resourceGroupIdentifier?: string(name='ResourceGroupIdentifier'),
  connectionName?: string(name='ConnectionName'),
  owner?: string(name='Owner'),
  autoParsing?: boolean(name='AutoParsing'),
  schedulerType?: string(name='SchedulerType'),
}

model UpdateFileResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model UpdateFileResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFileResponseBody(name='body'),
}

async function updateFileWithOptions(request: UpdateFileRequest, runtime: Util.RuntimeOptions): UpdateFileResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFile',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateFile(request: UpdateFileRequest): UpdateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFileWithOptions(request, runtime);
}

model UpdateFolderRequest {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  folderId?: string(name='FolderId'),
  folderName?: string(name='FolderName'),
}

model UpdateFolderResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model UpdateFolderResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFolderResponseBody(name='body'),
}

async function updateFolderWithOptions(request: UpdateFolderRequest, runtime: Util.RuntimeOptions): UpdateFolderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFolder',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateFolder(request: UpdateFolderRequest): UpdateFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFolderWithOptions(request, runtime);
}

model UpdateMetaCategoryRequest {
  name?: string(name='Name'),
  comment?: string(name='Comment'),
  categoryId?: long(name='CategoryId'),
}

model UpdateMetaCategoryResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model UpdateMetaCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMetaCategoryResponseBody(name='body'),
}

async function updateMetaCategoryWithOptions(request: UpdateMetaCategoryRequest, runtime: Util.RuntimeOptions): UpdateMetaCategoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMetaCategory',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMetaCategory(request: UpdateMetaCategoryRequest): UpdateMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMetaCategoryWithOptions(request, runtime);
}

model UpdateMetaTableRequest {
  projectId?: long(name='ProjectId'),
  tableName?: string(name='TableName'),
  envType?: int32(name='EnvType'),
  tableGuid?: string(name='TableGuid'),
  newOwnerId?: string(name='NewOwnerId'),
  addedLabels?: string(name='AddedLabels'),
  removedLabels?: string(name='RemovedLabels'),
  categoryId?: long(name='CategoryId'),
  visibility?: int32(name='Visibility'),
  caption?: string(name='Caption'),
}

model UpdateMetaTableResponseBody = {
  updateResult?: boolean(name='UpdateResult'),
  requestId?: string(name='RequestId'),
}

model UpdateMetaTableResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMetaTableResponseBody(name='body'),
}

async function updateMetaTableWithOptions(request: UpdateMetaTableRequest, runtime: Util.RuntimeOptions): UpdateMetaTableResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["TableName"] = request.tableName;
  query["EnvType"] = request.envType;
  query["TableGuid"] = request.tableGuid;
  query["NewOwnerId"] = request.newOwnerId;
  query["CategoryId"] = request.categoryId;
  query["Visibility"] = request.visibility;
  query["Caption"] = request.caption;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMetaTable',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMetaTable(request: UpdateMetaTableRequest): UpdateMetaTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMetaTableWithOptions(request, runtime);
}

model UpdateMetaTableIntroWikiRequest {
  tableGuid?: string(name='TableGuid'),
  content?: string(name='Content'),
}

model UpdateMetaTableIntroWikiResponseBody = {
  updateResult?: boolean(name='UpdateResult'),
  requestId?: string(name='RequestId'),
}

model UpdateMetaTableIntroWikiResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMetaTableIntroWikiResponseBody(name='body'),
}

async function updateMetaTableIntroWikiWithOptions(request: UpdateMetaTableIntroWikiRequest, runtime: Util.RuntimeOptions): UpdateMetaTableIntroWikiResponse {
  Util.validateModel(request);
  var query = {};
  query["TableGuid"] = request.tableGuid;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMetaTableIntroWiki',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMetaTableIntroWiki(request: UpdateMetaTableIntroWikiRequest): UpdateMetaTableIntroWikiResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMetaTableIntroWikiWithOptions(request, runtime);
}

model UpdateNodeOwnerRequest {
  projectEnv?: string(name='ProjectEnv'),
  nodeId?: long(name='NodeId'),
  userId?: string(name='UserId'),
}

model UpdateNodeOwnerResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
}

model UpdateNodeOwnerResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNodeOwnerResponseBody(name='body'),
}

async function updateNodeOwnerWithOptions(request: UpdateNodeOwnerRequest, runtime: Util.RuntimeOptions): UpdateNodeOwnerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNodeOwner',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateNodeOwner(request: UpdateNodeOwnerRequest): UpdateNodeOwnerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNodeOwnerWithOptions(request, runtime);
}

model UpdateNodeRunModeRequest {
  projectEnv?: string(name='ProjectEnv'),
  nodeId?: long(name='NodeId'),
  schedulerType?: int32(name='SchedulerType'),
}

model UpdateNodeRunModeResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
}

model UpdateNodeRunModeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNodeRunModeResponseBody(name='body'),
}

async function updateNodeRunModeWithOptions(request: UpdateNodeRunModeRequest, runtime: Util.RuntimeOptions): UpdateNodeRunModeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNodeRunMode',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateNodeRunMode(request: UpdateNodeRunModeRequest): UpdateNodeRunModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNodeRunModeWithOptions(request, runtime);
}

model UpdateQualityFollowerRequest {
  projectName?: string(name='ProjectName'),
  followerId?: long(name='FollowerId'),
  follower?: string(name='Follower'),
  alarmMode?: int32(name='AlarmMode'),
}

model UpdateQualityFollowerResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model UpdateQualityFollowerResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateQualityFollowerResponseBody(name='body'),
}

async function updateQualityFollowerWithOptions(request: UpdateQualityFollowerRequest, runtime: Util.RuntimeOptions): UpdateQualityFollowerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateQualityFollower',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateQualityFollower(request: UpdateQualityFollowerRequest): UpdateQualityFollowerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateQualityFollowerWithOptions(request, runtime);
}

model UpdateQualityRuleRequest {
  blockType?: int32(name='BlockType'),
  entityId?: long(name='EntityId'),
  comment?: string(name='Comment'),
  checker?: int32(name='Checker'),
  expectValue?: string(name='ExpectValue'),
  id?: long(name='Id'),
  trend?: string(name='Trend'),
  methodName?: string(name='MethodName'),
  operator?: string(name='Operator'),
  projectName?: string(name='ProjectName'),
  property?: string(name='Property'),
  propertyType?: string(name='PropertyType'),
  ruleType?: int32(name='RuleType'),
  whereCondition?: string(name='WhereCondition'),
  criticalThreshold?: string(name='CriticalThreshold'),
  warningThreshold?: string(name='WarningThreshold'),
  templateId?: int32(name='TemplateId'),
  ruleName?: string(name='RuleName'),
  predictType?: int32(name='PredictType'),
}

model UpdateQualityRuleResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model UpdateQualityRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateQualityRuleResponseBody(name='body'),
}

async function updateQualityRuleWithOptions(request: UpdateQualityRuleRequest, runtime: Util.RuntimeOptions): UpdateQualityRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateQualityRule',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateQualityRule(request: UpdateQualityRuleRequest): UpdateQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateQualityRuleWithOptions(request, runtime);
}

model UpdateRemindRequest {
  remindId?: long(name='RemindId'),
  remindName?: string(name='RemindName'),
  dndEnd?: string(name='DndEnd'),
  remindUnit?: string(name='RemindUnit'),
  nodeIds?: string(name='NodeIds'),
  baselineIds?: string(name='BaselineIds'),
  projectId?: long(name='ProjectId'),
  bizProcessIds?: string(name='BizProcessIds'),
  remindType?: string(name='RemindType'),
  maxAlertTimes?: int32(name='MaxAlertTimes'),
  alertInterval?: int32(name='AlertInterval'),
  detail?: string(name='Detail'),
  alertUnit?: string(name='AlertUnit'),
  alertMethods?: string(name='AlertMethods'),
  alertTargets?: string(name='AlertTargets'),
  useFlag?: boolean(name='UseFlag'),
  robotUrls?: string(name='RobotUrls'),
}

model UpdateRemindResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model UpdateRemindResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRemindResponseBody(name='body'),
}

async function updateRemindWithOptions(request: UpdateRemindRequest, runtime: Util.RuntimeOptions): UpdateRemindResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRemind',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRemind(request: UpdateRemindRequest): UpdateRemindResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRemindWithOptions(request, runtime);
}

model UpdateTableRequest {
  isView?: int32(name='IsView'),
  visibility?: int32(name='Visibility'),
  lifeCycle?: int32(name='LifeCycle'),
  categoryId?: long(name='CategoryId'),
  logicalLevelId?: long(name='LogicalLevelId'),
  physicsLevelId?: long(name='PhysicsLevelId'),
  externalTableType?: string(name='ExternalTableType'),
  location?: string(name='Location'),
  projectId?: long(name='ProjectId'),
  tableName?: string(name='TableName'),
  endpoint?: string(name='Endpoint'),
  envType?: int32(name='EnvType'),
  appGuid?: string(name='AppGuid'),
  createIfNotExists?: boolean(name='CreateIfNotExists'),
  ownerId?: string(name='OwnerId'),
  hasPart?: int32(name='HasPart'),
  comment?: string(name='Comment'),
  columns?: [ 
    {
      columnNameCn?: string(name='ColumnNameCn'),
      columnName?: string(name='ColumnName'),
      comment?: string(name='Comment'),
      columnType?: string(name='ColumnType'),
      seqNumber?: int32(name='SeqNumber'),
      length?: int32(name='Length'),
      isPartitionCol?: boolean(name='IsPartitionCol'),
    }
  ](name='Columns'),
  themes?: [ 
    {
      themeId?: long(name='ThemeId'),
      themeLevel?: int32(name='ThemeLevel'),
    }
  ](name='Themes'),
}

model UpdateTableResponseBody = {
  requestId?: string(name='RequestId'),
  taskInfo?: {
    status?: string(name='Status'),
    nextTaskId?: string(name='NextTaskId'),
    taskId?: string(name='TaskId'),
    content?: string(name='Content'),
  }(name='TaskInfo'),
}

model UpdateTableResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTableResponseBody(name='body'),
}

async function updateTableWithOptions(request: UpdateTableRequest, runtime: Util.RuntimeOptions): UpdateTableResponse {
  Util.validateModel(request);
  var query = {};
  query["IsView"] = request.isView;
  query["Visibility"] = request.visibility;
  query["LifeCycle"] = request.lifeCycle;
  query["CategoryId"] = request.categoryId;
  query["LogicalLevelId"] = request.logicalLevelId;
  query["PhysicsLevelId"] = request.physicsLevelId;
  query["ExternalTableType"] = request.externalTableType;
  query["Location"] = request.location;
  query["ProjectId"] = request.projectId;
  query["TableName"] = request.tableName;
  query["AppGuid"] = request.appGuid;
  query["CreateIfNotExists"] = request.createIfNotExists;
  query["OwnerId"] = request.ownerId;
  query["HasPart"] = request.hasPart;
  query["Comment"] = request.comment;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTable',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTable(request: UpdateTableRequest): UpdateTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTableWithOptions(request, runtime);
}

model UpdateTableAddColumnRequest {
  tableGuid?: string(name='TableGuid'),
  column?: [ 
    {
      columnNameCn?: string(name='ColumnNameCn'),
      columnName?: string(name='ColumnName'),
      comment?: string(name='Comment'),
      columnType?: string(name='ColumnType'),
    }
  ](name='Column'),
}

model UpdateTableAddColumnResponseBody = {
  requestId?: string(name='RequestId'),
  taskInfo?: {
    status?: string(name='Status'),
    nextTaskId?: string(name='NextTaskId'),
    taskId?: string(name='TaskId'),
    content?: string(name='Content'),
  }(name='TaskInfo'),
}

model UpdateTableAddColumnResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTableAddColumnResponseBody(name='body'),
}

async function updateTableAddColumnWithOptions(request: UpdateTableAddColumnRequest, runtime: Util.RuntimeOptions): UpdateTableAddColumnResponse {
  Util.validateModel(request);
  var query = {};
  query["TableGuid"] = request.tableGuid;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTableAddColumn',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTableAddColumn(request: UpdateTableAddColumnRequest): UpdateTableAddColumnResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTableAddColumnWithOptions(request, runtime);
}

model UpdateTableLevelRequest {
  projectId?: long(name='ProjectId'),
  levelType?: int32(name='LevelType'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  levelId?: long(name='LevelId'),
}

model UpdateTableLevelResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  updateResult?: boolean(name='UpdateResult'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model UpdateTableLevelResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTableLevelResponseBody(name='body'),
}

async function updateTableLevelWithOptions(request: UpdateTableLevelRequest, runtime: Util.RuntimeOptions): UpdateTableLevelResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["LevelType"] = request.levelType;
  query["Name"] = request.name;
  query["Description"] = request.description;
  query["LevelId"] = request.levelId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTableLevel',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTableLevel(request: UpdateTableLevelRequest): UpdateTableLevelResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTableLevelWithOptions(request, runtime);
}

model UpdateTableModelInfoRequest {
  firstLevelThemeId?: long(name='FirstLevelThemeId'),
  secondLevelThemeId?: long(name='SecondLevelThemeId'),
  levelId?: long(name='LevelId'),
  tableGuid?: string(name='TableGuid'),
  levelType?: int32(name='LevelType'),
}

model UpdateTableModelInfoResponseBody = {
  updateResult?: boolean(name='UpdateResult'),
  requestId?: string(name='RequestId'),
}

model UpdateTableModelInfoResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTableModelInfoResponseBody(name='body'),
}

async function updateTableModelInfoWithOptions(request: UpdateTableModelInfoRequest, runtime: Util.RuntimeOptions): UpdateTableModelInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["FirstLevelThemeId"] = request.firstLevelThemeId;
  query["SecondLevelThemeId"] = request.secondLevelThemeId;
  query["LevelId"] = request.levelId;
  query["TableGuid"] = request.tableGuid;
  query["LevelType"] = request.levelType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTableModelInfo',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTableModelInfo(request: UpdateTableModelInfoRequest): UpdateTableModelInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTableModelInfoWithOptions(request, runtime);
}

model UpdateTableThemeRequest {
  projectId?: long(name='ProjectId'),
  name?: string(name='Name'),
  themeId?: long(name='ThemeId'),
}

model UpdateTableThemeResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  updateResult?: boolean(name='UpdateResult'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model UpdateTableThemeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTableThemeResponseBody(name='body'),
}

async function updateTableThemeWithOptions(request: UpdateTableThemeRequest, runtime: Util.RuntimeOptions): UpdateTableThemeResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["Name"] = request.name;
  query["ThemeId"] = request.themeId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTableTheme',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTableTheme(request: UpdateTableThemeRequest): UpdateTableThemeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTableThemeWithOptions(request, runtime);
}

model UpdateUdfFileRequest {
  fileFolderPath?: string(name='FileFolderPath'),
  projectId?: long(name='ProjectId'),
  functionType?: string(name='FunctionType'),
  className?: string(name='ClassName'),
  resources?: string(name='Resources'),
  udfDescription?: string(name='UdfDescription'),
  cmdDescription?: string(name='CmdDescription'),
  parameterDescription?: string(name='ParameterDescription'),
  returnValue?: string(name='ReturnValue'),
  example?: string(name='Example'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  fileId?: string(name='FileId'),
}

model UpdateUdfFileResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model UpdateUdfFileResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUdfFileResponseBody(name='body'),
}

async function updateUdfFileWithOptions(request: UpdateUdfFileRequest, runtime: Util.RuntimeOptions): UpdateUdfFileResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUdfFile',
    version = '2020-05-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUdfFile(request: UpdateUdfFileRequest): UpdateUdfFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUdfFileWithOptions(request, runtime);
}

