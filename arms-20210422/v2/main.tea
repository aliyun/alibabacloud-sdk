/**
 *
 */
import OpenApi;
import OpenApi.OpenApiUtil;

extends OpenApi;


init(config: OpenApiUtil.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    'ap-northeast-2-pop' = 'arms.aliyuncs.com',
    'cn-beijing-finance-1' = 'arms.aliyuncs.com',
    'cn-beijing-finance-pop' = 'arms.aliyuncs.com',
    'cn-beijing-gov-1' = 'arms.aliyuncs.com',
    'cn-beijing-nu16-b01' = 'arms.aliyuncs.com',
    'cn-edge-1' = 'arms.aliyuncs.com',
    'cn-fujian' = 'arms.aliyuncs.com',
    'cn-haidian-cm12-c01' = 'arms.aliyuncs.com',
    'cn-hangzhou-bj-b01' = 'arms.aliyuncs.com',
    'cn-hangzhou-internal-prod-1' = 'arms.aliyuncs.com',
    'cn-hangzhou-internal-test-1' = 'arms.aliyuncs.com',
    'cn-hangzhou-internal-test-2' = 'arms.aliyuncs.com',
    'cn-hangzhou-internal-test-3' = 'arms.aliyuncs.com',
    'cn-hangzhou-test-306' = 'arms.aliyuncs.com',
    'cn-hongkong-finance-pop' = 'arms.aliyuncs.com',
    'cn-huhehaote-nebula-1' = 'arms.aliyuncs.com',
    'cn-qingdao-nebula' = 'arms.aliyuncs.com',
    'cn-shanghai-et15-b01' = 'arms.aliyuncs.com',
    'cn-shanghai-et2-b01' = 'arms.aliyuncs.com',
    'cn-shanghai-inner' = 'arms.aliyuncs.com',
    'cn-shanghai-internal-test-1' = 'arms.aliyuncs.com',
    'cn-shenzhen-inner' = 'arms.aliyuncs.com',
    'cn-shenzhen-st4-d01' = 'arms.aliyuncs.com',
    'cn-shenzhen-su18-b01' = 'arms.aliyuncs.com',
    'cn-wuhan' = 'arms.aliyuncs.com',
    'cn-yushanfang' = 'arms.aliyuncs.com',
    'cn-zhangbei' = 'arms.aliyuncs.com',
    'cn-zhangbei-na61-b01' = 'arms.aliyuncs.com',
    'cn-zhangjiakou-na62-a01' = 'arms.aliyuncs.com',
    'cn-zhengzhou-nebula-1' = 'arms.aliyuncs.com',
    'eu-west-1-oxs' = 'arms.aliyuncs.com',
    'me-east-1' = 'arms.aliyuncs.com',
    'rus-west-1-pop' = 'arms.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('arms', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!$isNull(endpoint)) {
    return endpoint;
  }
  
  if (!$isNull(endpointMap) && !$isNull(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddGrafanaRequest {
  clusterId?: string(name='ClusterId', description='This parameter is required.'),
  integration?: string(name='Integration', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model AddGrafanaResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddGrafanaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddGrafanaResponseBody(name='body'),
}

/**
 * @param request AddGrafanaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddGrafanaResponse
 */
@context("addGrafanaWithContext")
async function addGrafanaWithOptions(request: AddGrafanaRequest, runtime: $RuntimeOptions): AddGrafanaResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.integration)) {
    query['Integration'] = request.integration;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'AddGrafana',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddGrafanaRequest
 * @return AddGrafanaResponse
 */
async function addGrafana(request: AddGrafanaRequest): AddGrafanaResponse {
  var runtime = new $RuntimeOptions{};
  return addGrafanaWithOptions(request, runtime);
}

model AddIntegrationRequest {
  clusterId?: string(name='ClusterId', description='This parameter is required.'),
  integration?: string(name='Integration', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model AddIntegrationResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddIntegrationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddIntegrationResponseBody(name='body'),
}

/**
 * @param request AddIntegrationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddIntegrationResponse
 */
@context("addIntegrationWithContext")
async function addIntegrationWithOptions(request: AddIntegrationRequest, runtime: $RuntimeOptions): AddIntegrationResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.integration)) {
    query['Integration'] = request.integration;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'AddIntegration',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddIntegrationRequest
 * @return AddIntegrationResponse
 */
async function addIntegration(request: AddIntegrationRequest): AddIntegrationResponse {
  var runtime = new $RuntimeOptions{};
  return addIntegrationWithOptions(request, runtime);
}

model ApplyScenarioRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  config?: map[string]any(name='Config', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  regionId?: string(name='RegionId'),
  scenario?: string(name='Scenario'),
  sign?: string(name='Sign'),
  snDump?: boolean(name='SnDump'),
  snForce?: boolean(name='SnForce'),
  snStat?: boolean(name='SnStat'),
  snTransfer?: boolean(name='SnTransfer'),
  updateOption?: boolean(name='UpdateOption', description='This parameter is required.'),
}

model ApplyScenarioShrinkRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  configShrink?: string(name='Config', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  regionId?: string(name='RegionId'),
  scenario?: string(name='Scenario'),
  sign?: string(name='Sign'),
  snDump?: boolean(name='SnDump'),
  snForce?: boolean(name='SnForce'),
  snStat?: boolean(name='SnStat'),
  snTransfer?: boolean(name='SnTransfer'),
  updateOption?: boolean(name='UpdateOption', description='This parameter is required.'),
}

model ApplyScenarioResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model ApplyScenarioResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ApplyScenarioResponseBody(name='body'),
}

/**
 * @param tmpReq ApplyScenarioRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApplyScenarioResponse
 */
@context("applyScenarioWithContext")
async function applyScenarioWithOptions(tmpReq: ApplyScenarioRequest, runtime: $RuntimeOptions): ApplyScenarioResponse {
  tmpReq.validate();
  var request = new ApplyScenarioShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.config)) {
    request.configShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.config, 'Config', 'json');
  }
  var query = {};
  if (!$isNull(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!$isNull(request.configShrink)) {
    query['Config'] = request.configShrink;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.scenario)) {
    query['Scenario'] = request.scenario;
  }
  if (!$isNull(request.sign)) {
    query['Sign'] = request.sign;
  }
  if (!$isNull(request.snDump)) {
    query['SnDump'] = request.snDump;
  }
  if (!$isNull(request.snForce)) {
    query['SnForce'] = request.snForce;
  }
  if (!$isNull(request.snStat)) {
    query['SnStat'] = request.snStat;
  }
  if (!$isNull(request.snTransfer)) {
    query['SnTransfer'] = request.snTransfer;
  }
  if (!$isNull(request.updateOption)) {
    query['UpdateOption'] = request.updateOption;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ApplyScenario',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ApplyScenarioRequest
 * @return ApplyScenarioResponse
 */
async function applyScenario(request: ApplyScenarioRequest): ApplyScenarioResponse {
  var runtime = new $RuntimeOptions{};
  return applyScenarioWithOptions(request, runtime);
}

model CheckDataConsistencyRequest {
  appType?: string(name='AppType', description='This parameter is required.'),
  currentTimestamp?: long(name='CurrentTimestamp'),
  pid?: string(name='Pid', description='This parameter is required.'),
  proxyUserId?: string(name='ProxyUserId'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model CheckDataConsistencyResponseBody = {
  isDataConsistency?: boolean(name='IsDataConsistency'),
  requestId?: string(name='RequestId'),
}

model CheckDataConsistencyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckDataConsistencyResponseBody(name='body'),
}

/**
 * @param request CheckDataConsistencyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckDataConsistencyResponse
 */
@context("checkDataConsistencyWithContext")
async function checkDataConsistencyWithOptions(request: CheckDataConsistencyRequest, runtime: $RuntimeOptions): CheckDataConsistencyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.appType)) {
    query['AppType'] = request.appType;
  }
  if (!$isNull(request.currentTimestamp)) {
    query['CurrentTimestamp'] = request.currentTimestamp;
  }
  if (!$isNull(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!$isNull(request.proxyUserId)) {
    query['ProxyUserId'] = request.proxyUserId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CheckDataConsistency',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CheckDataConsistencyRequest
 * @return CheckDataConsistencyResponse
 */
async function checkDataConsistency(request: CheckDataConsistencyRequest): CheckDataConsistencyResponse {
  var runtime = new $RuntimeOptions{};
  return checkDataConsistencyWithOptions(request, runtime);
}

model CheckServiceLinkedRoleForDeletingRequest {
  deletionTaskId?: string(name='DeletionTaskId', description='This parameter is required.'),
  regionId?: string(name='RegionId'),
  roleArn?: string(name='RoleArn', description='This parameter is required.'),
  SPIRegionId?: string(name='SPIRegionId', description='This parameter is required.'),
  serviceName?: string(name='ServiceName', description='This parameter is required.'),
}

model CheckServiceLinkedRoleForDeletingResponseBody = {
  deletable?: boolean(name='Deletable'),
  requestId?: string(name='RequestId'),
  roleUsages?: [ 
    {
      region?: string(name='Region'),
      resources?: [ string ](name='Resources'),
    }
  ](name='RoleUsages'),
}

model CheckServiceLinkedRoleForDeletingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckServiceLinkedRoleForDeletingResponseBody(name='body'),
}

/**
 * @param request CheckServiceLinkedRoleForDeletingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckServiceLinkedRoleForDeletingResponse
 */
@context("checkServiceLinkedRoleForDeletingWithContext")
async function checkServiceLinkedRoleForDeletingWithOptions(request: CheckServiceLinkedRoleForDeletingRequest, runtime: $RuntimeOptions): CheckServiceLinkedRoleForDeletingResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.deletionTaskId)) {
    query['DeletionTaskId'] = request.deletionTaskId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.roleArn)) {
    query['RoleArn'] = request.roleArn;
  }
  if (!$isNull(request.SPIRegionId)) {
    query['SPIRegionId'] = request.SPIRegionId;
  }
  if (!$isNull(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CheckServiceLinkedRoleForDeleting',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CheckServiceLinkedRoleForDeletingRequest
 * @return CheckServiceLinkedRoleForDeletingResponse
 */
async function checkServiceLinkedRoleForDeleting(request: CheckServiceLinkedRoleForDeletingRequest): CheckServiceLinkedRoleForDeletingResponse {
  var runtime = new $RuntimeOptions{};
  return checkServiceLinkedRoleForDeletingWithOptions(request, runtime);
}

model CheckServiceStatusRequest {
  regionId?: string(name='RegionId'),
  svcCode?: string(name='SvcCode', description='This parameter is required.'),
}

model CheckServiceStatusResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model CheckServiceStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckServiceStatusResponseBody(name='body'),
}

/**
 * @param request CheckServiceStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckServiceStatusResponse
 */
@context("checkServiceStatusWithContext")
async function checkServiceStatusWithOptions(request: CheckServiceStatusRequest, runtime: $RuntimeOptions): CheckServiceStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.svcCode)) {
    query['SvcCode'] = request.svcCode;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CheckServiceStatus',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CheckServiceStatusRequest
 * @return CheckServiceStatusResponse
 */
async function checkServiceStatus(request: CheckServiceStatusRequest): CheckServiceStatusResponse {
  var runtime = new $RuntimeOptions{};
  return checkServiceStatusWithOptions(request, runtime);
}

model ConfigAppRequest {
  appIds?: string(name='AppIds', description='This parameter is required.'),
  enable?: string(name='Enable'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model ConfigAppResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ConfigAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfigAppResponseBody(name='body'),
}

/**
 * @param request ConfigAppRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigAppResponse
 */
@context("configAppWithContext")
async function configAppWithOptions(request: ConfigAppRequest, runtime: $RuntimeOptions): ConfigAppResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.appIds)) {
    query['AppIds'] = request.appIds;
  }
  if (!$isNull(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ConfigApp',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ConfigAppRequest
 * @return ConfigAppResponse
 */
async function configApp(request: ConfigAppRequest): ConfigAppResponse {
  var runtime = new $RuntimeOptions{};
  return configAppWithOptions(request, runtime);
}

model CreateAlertContactRequest {
  contactName?: string(name='ContactName'),
  dingRobotWebhookUrl?: string(name='DingRobotWebhookUrl'),
  email?: string(name='Email'),
  phoneNum?: string(name='PhoneNum'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  systemNoc?: boolean(name='SystemNoc'),
}

model CreateAlertContactResponseBody = {
  contactId?: string(name='ContactId'),
  requestId?: string(name='RequestId'),
}

model CreateAlertContactResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAlertContactResponseBody(name='body'),
}

/**
 * @param request CreateAlertContactRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAlertContactResponse
 */
@context("createAlertContactWithContext")
async function createAlertContactWithOptions(request: CreateAlertContactRequest, runtime: $RuntimeOptions): CreateAlertContactResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!$isNull(request.dingRobotWebhookUrl)) {
    query['DingRobotWebhookUrl'] = request.dingRobotWebhookUrl;
  }
  if (!$isNull(request.email)) {
    query['Email'] = request.email;
  }
  if (!$isNull(request.phoneNum)) {
    query['PhoneNum'] = request.phoneNum;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.systemNoc)) {
    query['SystemNoc'] = request.systemNoc;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateAlertContact',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateAlertContactRequest
 * @return CreateAlertContactResponse
 */
async function createAlertContact(request: CreateAlertContactRequest): CreateAlertContactResponse {
  var runtime = new $RuntimeOptions{};
  return createAlertContactWithOptions(request, runtime);
}

model CreateAlertContactGroupRequest {
  contactGroupName?: string(name='ContactGroupName', description='This parameter is required.'),
  contactIds?: string(name='ContactIds'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model CreateAlertContactGroupResponseBody = {
  contactGroupId?: string(name='ContactGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateAlertContactGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAlertContactGroupResponseBody(name='body'),
}

/**
 * @param request CreateAlertContactGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAlertContactGroupResponse
 */
@context("createAlertContactGroupWithContext")
async function createAlertContactGroupWithOptions(request: CreateAlertContactGroupRequest, runtime: $RuntimeOptions): CreateAlertContactGroupResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.contactGroupName)) {
    query['ContactGroupName'] = request.contactGroupName;
  }
  if (!$isNull(request.contactIds)) {
    query['ContactIds'] = request.contactIds;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateAlertContactGroup',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateAlertContactGroupRequest
 * @return CreateAlertContactGroupResponse
 */
async function createAlertContactGroup(request: CreateAlertContactGroupRequest): CreateAlertContactGroupResponse {
  var runtime = new $RuntimeOptions{};
  return createAlertContactGroupWithOptions(request, runtime);
}

model CreateAlertTemplateRequest {
  annotations?: string(name='Annotations'),
  labels?: string(name='Labels'),
  matchExpressions?: string(name='MatchExpressions'),
  message?: string(name='Message', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  parentId?: string(name='ParentId'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  rule?: string(name='Rule', description='This parameter is required.'),
  templateProvider?: string(name='TemplateProvider'),
  type?: string(name='Type', description='This parameter is required.'),
}

model CreateAlertTemplateResponseBody = {
  alertTemplate?: {
    alertProvider?: string(name='AlertProvider'),
    annotations?: map[string]any(name='Annotations'),
    id?: int32(name='Id'),
    labelMatchExpressionGrid?: {
      labelMatchExpressionGroups?: [ 
        {
          labelMatchExpressions?: [ 
            {
              key?: string(name='Key'),
              operator?: string(name='Operator'),
              value?: string(name='Value'),
            }
          ](name='LabelMatchExpressions'),
        }
      ](name='LabelMatchExpressionGroups'),
    }(name='LabelMatchExpressionGrid'),
    labels?: map[string]any(name='Labels'),
    message?: string(name='Message'),
    name?: string(name='Name'),
    parentId?: int32(name='ParentId'),
    public?: boolean(name='Public'),
    rule?: string(name='Rule'),
    status?: boolean(name='Status'),
    templateProvider?: string(name='TemplateProvider'),
    type?: string(name='Type'),
    userId?: string(name='UserId'),
  }(name='AlertTemplate'),
  requestId?: string(name='RequestId'),
}

model CreateAlertTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAlertTemplateResponseBody(name='body'),
}

/**
 * @param request CreateAlertTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAlertTemplateResponse
 */
@context("createAlertTemplateWithContext")
async function createAlertTemplateWithOptions(request: CreateAlertTemplateRequest, runtime: $RuntimeOptions): CreateAlertTemplateResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.annotations)) {
    query['Annotations'] = request.annotations;
  }
  if (!$isNull(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!$isNull(request.matchExpressions)) {
    query['MatchExpressions'] = request.matchExpressions;
  }
  if (!$isNull(request.message)) {
    query['Message'] = request.message;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.parentId)) {
    query['ParentId'] = request.parentId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.rule)) {
    query['Rule'] = request.rule;
  }
  if (!$isNull(request.templateProvider)) {
    query['TemplateProvider'] = request.templateProvider;
  }
  if (!$isNull(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateAlertTemplate',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateAlertTemplateRequest
 * @return CreateAlertTemplateResponse
 */
async function createAlertTemplate(request: CreateAlertTemplateRequest): CreateAlertTemplateResponse {
  var runtime = new $RuntimeOptions{};
  return createAlertTemplateWithOptions(request, runtime);
}

model CreateDispatchRuleRequest {
  dispatchRule?: string(name='DispatchRule', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model CreateDispatchRuleResponseBody = {
  dispatchRuleId?: long(name='DispatchRuleId'),
  requestId?: string(name='RequestId'),
}

model CreateDispatchRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDispatchRuleResponseBody(name='body'),
}

/**
 * @param request CreateDispatchRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDispatchRuleResponse
 */
@context("createDispatchRuleWithContext")
async function createDispatchRuleWithOptions(request: CreateDispatchRuleRequest, runtime: $RuntimeOptions): CreateDispatchRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.dispatchRule)) {
    query['DispatchRule'] = request.dispatchRule;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateDispatchRule',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateDispatchRuleRequest
 * @return CreateDispatchRuleResponse
 */
async function createDispatchRule(request: CreateDispatchRuleRequest): CreateDispatchRuleResponse {
  var runtime = new $RuntimeOptions{};
  return createDispatchRuleWithOptions(request, runtime);
}

model CreatePrometheusAlertRuleRequest {
  alertName?: string(name='AlertName', description='This parameter is required.'),
  annotations?: string(name='Annotations'),
  clusterId?: string(name='ClusterId', description='This parameter is required.'),
  dispatchRuleId?: long(name='DispatchRuleId'),
  duration?: string(name='Duration', description='This parameter is required.'),
  expression?: string(name='Expression', description='This parameter is required.'),
  labels?: string(name='Labels'),
  message?: string(name='Message', description='This parameter is required.'),
  notifyType?: string(name='NotifyType'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  type?: string(name='Type'),
}

model CreatePrometheusAlertRuleResponseBody = {
  prometheusAlertRule?: {
    alertId?: long(name='AlertId'),
    alertName?: string(name='AlertName'),
    annotations?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Annotations'),
    clusterId?: string(name='ClusterId'),
    dispatchRuleId?: long(name='DispatchRuleId'),
    duration?: string(name='Duration'),
    expression?: string(name='Expression'),
    labels?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Labels'),
    message?: string(name='Message'),
    notifyType?: string(name='NotifyType'),
    status?: int32(name='Status'),
    type?: string(name='Type'),
  }(name='PrometheusAlertRule'),
  requestId?: string(name='RequestId'),
}

model CreatePrometheusAlertRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePrometheusAlertRuleResponseBody(name='body'),
}

/**
 * @param request CreatePrometheusAlertRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePrometheusAlertRuleResponse
 */
@context("createPrometheusAlertRuleWithContext")
async function createPrometheusAlertRuleWithOptions(request: CreatePrometheusAlertRuleRequest, runtime: $RuntimeOptions): CreatePrometheusAlertRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.alertName)) {
    query['AlertName'] = request.alertName;
  }
  if (!$isNull(request.annotations)) {
    query['Annotations'] = request.annotations;
  }
  if (!$isNull(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.dispatchRuleId)) {
    query['DispatchRuleId'] = request.dispatchRuleId;
  }
  if (!$isNull(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!$isNull(request.expression)) {
    query['Expression'] = request.expression;
  }
  if (!$isNull(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!$isNull(request.message)) {
    query['Message'] = request.message;
  }
  if (!$isNull(request.notifyType)) {
    query['NotifyType'] = request.notifyType;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreatePrometheusAlertRule',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreatePrometheusAlertRuleRequest
 * @return CreatePrometheusAlertRuleResponse
 */
async function createPrometheusAlertRule(request: CreatePrometheusAlertRuleRequest): CreatePrometheusAlertRuleResponse {
  var runtime = new $RuntimeOptions{};
  return createPrometheusAlertRuleWithOptions(request, runtime);
}

model CreateRetcodeAppRequest {
  regionId?: string(name='RegionId', description='This parameter is required.'),
  retcodeAppName?: string(name='RetcodeAppName', description='This parameter is required.'),
  retcodeAppType?: string(name='RetcodeAppType', description='This parameter is required.'),
}

model CreateRetcodeAppResponseBody = {
  requestId?: string(name='RequestId'),
  retcodeAppDataBean?: {
    appId?: long(name='AppId'),
    pid?: string(name='Pid'),
  }(name='RetcodeAppDataBean'),
}

model CreateRetcodeAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRetcodeAppResponseBody(name='body'),
}

/**
 * @param request CreateRetcodeAppRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRetcodeAppResponse
 */
@context("createRetcodeAppWithContext")
async function createRetcodeAppWithOptions(request: CreateRetcodeAppRequest, runtime: $RuntimeOptions): CreateRetcodeAppResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.retcodeAppName)) {
    query['RetcodeAppName'] = request.retcodeAppName;
  }
  if (!$isNull(request.retcodeAppType)) {
    query['RetcodeAppType'] = request.retcodeAppType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateRetcodeApp',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateRetcodeAppRequest
 * @return CreateRetcodeAppResponse
 */
async function createRetcodeApp(request: CreateRetcodeAppRequest): CreateRetcodeAppResponse {
  var runtime = new $RuntimeOptions{};
  return createRetcodeAppWithOptions(request, runtime);
}

model CreateWehookRequest {
  body?: string(name='Body'),
  contactName?: string(name='ContactName', description='This parameter is required.'),
  httpHeaders?: string(name='HttpHeaders'),
  httpParams?: string(name='HttpParams'),
  method?: string(name='Method'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  url?: string(name='Url', description='This parameter is required.'),
}

model CreateWehookResponseBody = {
  contactId?: string(name='ContactId'),
  requestId?: string(name='RequestId'),
}

model CreateWehookResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateWehookResponseBody(name='body'),
}

/**
 * @param request CreateWehookRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateWehookResponse
 */
@context("createWehookWithContext")
async function createWehookWithOptions(request: CreateWehookRequest, runtime: $RuntimeOptions): CreateWehookResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.body)) {
    query['Body'] = request.body;
  }
  if (!$isNull(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!$isNull(request.httpHeaders)) {
    query['HttpHeaders'] = request.httpHeaders;
  }
  if (!$isNull(request.httpParams)) {
    query['HttpParams'] = request.httpParams;
  }
  if (!$isNull(request.method)) {
    query['Method'] = request.method;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.url)) {
    query['Url'] = request.url;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateWehook',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateWehookRequest
 * @return CreateWehookResponse
 */
async function createWehook(request: CreateWehookRequest): CreateWehookResponse {
  var runtime = new $RuntimeOptions{};
  return createWehookWithOptions(request, runtime);
}

model DeleteAlertContactRequest {
  contactId?: long(name='ContactId', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model DeleteAlertContactResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteAlertContactResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAlertContactResponseBody(name='body'),
}

/**
 * @param request DeleteAlertContactRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAlertContactResponse
 */
@context("deleteAlertContactWithContext")
async function deleteAlertContactWithOptions(request: DeleteAlertContactRequest, runtime: $RuntimeOptions): DeleteAlertContactResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.contactId)) {
    query['ContactId'] = request.contactId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteAlertContact',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteAlertContactRequest
 * @return DeleteAlertContactResponse
 */
async function deleteAlertContact(request: DeleteAlertContactRequest): DeleteAlertContactResponse {
  var runtime = new $RuntimeOptions{};
  return deleteAlertContactWithOptions(request, runtime);
}

model DeleteAlertContactGroupRequest {
  contactGroupId?: long(name='ContactGroupId', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model DeleteAlertContactGroupResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteAlertContactGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAlertContactGroupResponseBody(name='body'),
}

/**
 * @param request DeleteAlertContactGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAlertContactGroupResponse
 */
@context("deleteAlertContactGroupWithContext")
async function deleteAlertContactGroupWithOptions(request: DeleteAlertContactGroupRequest, runtime: $RuntimeOptions): DeleteAlertContactGroupResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.contactGroupId)) {
    query['ContactGroupId'] = request.contactGroupId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteAlertContactGroup',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteAlertContactGroupRequest
 * @return DeleteAlertContactGroupResponse
 */
async function deleteAlertContactGroup(request: DeleteAlertContactGroupRequest): DeleteAlertContactGroupResponse {
  var runtime = new $RuntimeOptions{};
  return deleteAlertContactGroupWithOptions(request, runtime);
}

model DeleteAlertRulesRequest {
  alertIds?: string(name='AlertIds', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model DeleteAlertRulesResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteAlertRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAlertRulesResponseBody(name='body'),
}

/**
 * @param request DeleteAlertRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAlertRulesResponse
 */
@context("deleteAlertRulesWithContext")
async function deleteAlertRulesWithOptions(request: DeleteAlertRulesRequest, runtime: $RuntimeOptions): DeleteAlertRulesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.alertIds)) {
    query['AlertIds'] = request.alertIds;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteAlertRules',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteAlertRulesRequest
 * @return DeleteAlertRulesResponse
 */
async function deleteAlertRules(request: DeleteAlertRulesRequest): DeleteAlertRulesResponse {
  var runtime = new $RuntimeOptions{};
  return deleteAlertRulesWithOptions(request, runtime);
}

model DeleteAlertTemplateRequest {
  id?: long(name='Id', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model DeleteAlertTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteAlertTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAlertTemplateResponseBody(name='body'),
}

/**
 * @param request DeleteAlertTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAlertTemplateResponse
 */
@context("deleteAlertTemplateWithContext")
async function deleteAlertTemplateWithOptions(request: DeleteAlertTemplateRequest, runtime: $RuntimeOptions): DeleteAlertTemplateResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.id)) {
    query['Id'] = request.id;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteAlertTemplate',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteAlertTemplateRequest
 * @return DeleteAlertTemplateResponse
 */
async function deleteAlertTemplate(request: DeleteAlertTemplateRequest): DeleteAlertTemplateResponse {
  var runtime = new $RuntimeOptions{};
  return deleteAlertTemplateWithOptions(request, runtime);
}

model DeleteDispatchRuleRequest {
  id?: string(name='Id', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model DeleteDispatchRuleResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDispatchRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDispatchRuleResponseBody(name='body'),
}

/**
 * @param request DeleteDispatchRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDispatchRuleResponse
 */
@context("deleteDispatchRuleWithContext")
async function deleteDispatchRuleWithOptions(request: DeleteDispatchRuleRequest, runtime: $RuntimeOptions): DeleteDispatchRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.id)) {
    query['Id'] = request.id;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteDispatchRule',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteDispatchRuleRequest
 * @return DeleteDispatchRuleResponse
 */
async function deleteDispatchRule(request: DeleteDispatchRuleRequest): DeleteDispatchRuleResponse {
  var runtime = new $RuntimeOptions{};
  return deleteDispatchRuleWithOptions(request, runtime);
}

model DeleteGrafanaResourceRequest {
  clusterId?: string(name='ClusterId', description='This parameter is required.'),
  clusterName?: string(name='ClusterName', description='This parameter is required.'),
  userId?: string(name='UserId', description='This parameter is required.'),
}

model DeleteGrafanaResourceResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteGrafanaResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGrafanaResourceResponseBody(name='body'),
}

/**
 * @param request DeleteGrafanaResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGrafanaResourceResponse
 */
@context("deleteGrafanaResourceWithContext")
async function deleteGrafanaResourceWithOptions(request: DeleteGrafanaResourceRequest, runtime: $RuntimeOptions): DeleteGrafanaResourceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.clusterName)) {
    body['ClusterName'] = request.clusterName;
  }
  if (!$isNull(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteGrafanaResource',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteGrafanaResourceRequest
 * @return DeleteGrafanaResourceResponse
 */
async function deleteGrafanaResource(request: DeleteGrafanaResourceRequest): DeleteGrafanaResourceResponse {
  var runtime = new $RuntimeOptions{};
  return deleteGrafanaResourceWithOptions(request, runtime);
}

model DeletePrometheusAlertRuleRequest {
  alertId?: long(name='AlertId', description='This parameter is required.'),
}

model DeletePrometheusAlertRuleResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeletePrometheusAlertRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePrometheusAlertRuleResponseBody(name='body'),
}

/**
 * @param request DeletePrometheusAlertRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePrometheusAlertRuleResponse
 */
@context("deletePrometheusAlertRuleWithContext")
async function deletePrometheusAlertRuleWithOptions(request: DeletePrometheusAlertRuleRequest, runtime: $RuntimeOptions): DeletePrometheusAlertRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeletePrometheusAlertRule',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeletePrometheusAlertRuleRequest
 * @return DeletePrometheusAlertRuleResponse
 */
async function deletePrometheusAlertRule(request: DeletePrometheusAlertRuleRequest): DeletePrometheusAlertRuleResponse {
  var runtime = new $RuntimeOptions{};
  return deletePrometheusAlertRuleWithOptions(request, runtime);
}

model DeleteRetcodeAppRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model DeleteRetcodeAppResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteRetcodeAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRetcodeAppResponseBody(name='body'),
}

/**
 * @param request DeleteRetcodeAppRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRetcodeAppResponse
 */
@context("deleteRetcodeAppWithContext")
async function deleteRetcodeAppWithOptions(request: DeleteRetcodeAppRequest, runtime: $RuntimeOptions): DeleteRetcodeAppResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteRetcodeApp',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteRetcodeAppRequest
 * @return DeleteRetcodeAppResponse
 */
async function deleteRetcodeApp(request: DeleteRetcodeAppRequest): DeleteRetcodeAppResponse {
  var runtime = new $RuntimeOptions{};
  return deleteRetcodeAppWithOptions(request, runtime);
}

model DeleteScenarioRequest {
  regionId?: string(name='RegionId'),
  scenarioId?: long(name='ScenarioId', description='This parameter is required.'),
}

model DeleteScenarioResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteScenarioResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteScenarioResponseBody(name='body'),
}

/**
 * @param request DeleteScenarioRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteScenarioResponse
 */
@context("deleteScenarioWithContext")
async function deleteScenarioWithOptions(request: DeleteScenarioRequest, runtime: $RuntimeOptions): DeleteScenarioResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.scenarioId)) {
    query['ScenarioId'] = request.scenarioId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteScenario',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteScenarioRequest
 * @return DeleteScenarioResponse
 */
async function deleteScenario(request: DeleteScenarioRequest): DeleteScenarioResponse {
  var runtime = new $RuntimeOptions{};
  return deleteScenarioWithOptions(request, runtime);
}

model DeleteTraceAppRequest {
  appId?: string(name='AppId'),
  pid?: string(name='Pid', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  type?: string(name='Type', description='This parameter is required.'),
}

model DeleteTraceAppResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteTraceAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTraceAppResponseBody(name='body'),
}

/**
 * @param request DeleteTraceAppRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTraceAppResponse
 */
@context("deleteTraceAppWithContext")
async function deleteTraceAppWithOptions(request: DeleteTraceAppRequest, runtime: $RuntimeOptions): DeleteTraceAppResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!$isNull(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteTraceApp',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteTraceAppRequest
 * @return DeleteTraceAppResponse
 */
async function deleteTraceApp(request: DeleteTraceAppRequest): DeleteTraceAppResponse {
  var runtime = new $RuntimeOptions{};
  return deleteTraceAppWithOptions(request, runtime);
}

model DescribeDispatchRuleRequest {
  id?: string(name='Id'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model DescribeDispatchRuleResponseBody = {
  dispatchRule?: {
    groupRules?: [ 
      {
        groupId?: long(name='GroupId'),
        groupInterval?: long(name='GroupInterval'),
        groupWaitTime?: long(name='GroupWaitTime'),
        groupingFields?: [ string ](name='GroupingFields'),
      }
    ](name='GroupRules'),
    labelMatchExpressionGrid?: {
      labelMatchExpressionGroups?: [ 
        {
          labelMatchExpressions?: [ 
            {
              key?: string(name='Key'),
              operator?: string(name='Operator'),
              value?: string(name='Value'),
            }
          ](name='LabelMatchExpressions'),
        }
      ](name='LabelMatchExpressionGroups'),
    }(name='LabelMatchExpressionGrid'),
    name?: string(name='Name'),
    notifyRules?: [ 
      {
        notifyChannels?: [ string ](name='NotifyChannels'),
        notifyObjects?: [ 
          {
            name?: string(name='Name'),
            notifyObjectId?: string(name='NotifyObjectId'),
            notifyType?: string(name='NotifyType'),
          }
        ](name='NotifyObjects'),
      }
    ](name='NotifyRules'),
    ruleId?: long(name='RuleId'),
    state?: string(name='State'),
  }(name='DispatchRule'),
  requestId?: string(name='RequestId'),
}

model DescribeDispatchRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDispatchRuleResponseBody(name='body'),
}

/**
 * @param request DescribeDispatchRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDispatchRuleResponse
 */
@context("describeDispatchRuleWithContext")
async function describeDispatchRuleWithOptions(request: DescribeDispatchRuleRequest, runtime: $RuntimeOptions): DescribeDispatchRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.id)) {
    query['Id'] = request.id;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDispatchRule',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeDispatchRuleRequest
 * @return DescribeDispatchRuleResponse
 */
async function describeDispatchRule(request: DescribeDispatchRuleRequest): DescribeDispatchRuleResponse {
  var runtime = new $RuntimeOptions{};
  return describeDispatchRuleWithOptions(request, runtime);
}

model DescribePrometheusAlertRuleRequest {
  alertId?: long(name='AlertId', description='This parameter is required.'),
}

model DescribePrometheusAlertRuleResponseBody = {
  prometheusAlertRule?: {
    alertId?: long(name='AlertId'),
    alertName?: string(name='AlertName'),
    annotations?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Annotations'),
    clusterId?: string(name='ClusterId'),
    dispatchRuleId?: long(name='DispatchRuleId'),
    duration?: string(name='Duration'),
    expression?: string(name='Expression'),
    labels?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Labels'),
    message?: string(name='Message'),
    notifyType?: string(name='NotifyType'),
    status?: int32(name='Status'),
    type?: string(name='Type'),
  }(name='PrometheusAlertRule'),
  requestId?: string(name='RequestId'),
}

model DescribePrometheusAlertRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePrometheusAlertRuleResponseBody(name='body'),
}

/**
 * @param request DescribePrometheusAlertRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePrometheusAlertRuleResponse
 */
@context("describePrometheusAlertRuleWithContext")
async function describePrometheusAlertRuleWithOptions(request: DescribePrometheusAlertRuleRequest, runtime: $RuntimeOptions): DescribePrometheusAlertRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribePrometheusAlertRule',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribePrometheusAlertRuleRequest
 * @return DescribePrometheusAlertRuleResponse
 */
async function describePrometheusAlertRule(request: DescribePrometheusAlertRuleRequest): DescribePrometheusAlertRuleResponse {
  var runtime = new $RuntimeOptions{};
  return describePrometheusAlertRuleWithOptions(request, runtime);
}

model DescribeTraceLicenseKeyRequest {
  regionId?: string(name='RegionId'),
}

model DescribeTraceLicenseKeyResponseBody = {
  licenseKey?: string(name='LicenseKey'),
  requestId?: string(name='RequestId'),
}

model DescribeTraceLicenseKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTraceLicenseKeyResponseBody(name='body'),
}

/**
 * @param request DescribeTraceLicenseKeyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTraceLicenseKeyResponse
 */
@context("describeTraceLicenseKeyWithContext")
async function describeTraceLicenseKeyWithOptions(request: DescribeTraceLicenseKeyRequest, runtime: $RuntimeOptions): DescribeTraceLicenseKeyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeTraceLicenseKey',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeTraceLicenseKeyRequest
 * @return DescribeTraceLicenseKeyResponse
 */
async function describeTraceLicenseKey(request: DescribeTraceLicenseKeyRequest): DescribeTraceLicenseKeyResponse {
  var runtime = new $RuntimeOptions{};
  return describeTraceLicenseKeyWithOptions(request, runtime);
}

model DescribeTraceLocationRequest {
  regionId?: string(name='RegionId'),
}

model DescribeTraceLocationResponseBody = {
  regionConfigs?: [ 
    {
      regionNo?: string(name='RegionNo'),
      url?: string(name='Url'),
    }
  ](name='RegionConfigs'),
  requestId?: string(name='RequestId'),
}

model DescribeTraceLocationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTraceLocationResponseBody(name='body'),
}

/**
 * @param request DescribeTraceLocationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTraceLocationResponse
 */
@context("describeTraceLocationWithContext")
async function describeTraceLocationWithOptions(request: DescribeTraceLocationRequest, runtime: $RuntimeOptions): DescribeTraceLocationResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeTraceLocation',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeTraceLocationRequest
 * @return DescribeTraceLocationResponse
 */
async function describeTraceLocation(request: DescribeTraceLocationRequest): DescribeTraceLocationResponse {
  var runtime = new $RuntimeOptions{};
  return describeTraceLocationWithOptions(request, runtime);
}

model DisableAlertTemplateRequest {
  id?: long(name='Id', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model DisableAlertTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableAlertTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableAlertTemplateResponseBody(name='body'),
}

/**
 * @param request DisableAlertTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableAlertTemplateResponse
 */
@context("disableAlertTemplateWithContext")
async function disableAlertTemplateWithOptions(request: DisableAlertTemplateRequest, runtime: $RuntimeOptions): DisableAlertTemplateResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.id)) {
    query['Id'] = request.id;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DisableAlertTemplate',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DisableAlertTemplateRequest
 * @return DisableAlertTemplateResponse
 */
async function disableAlertTemplate(request: DisableAlertTemplateRequest): DisableAlertTemplateResponse {
  var runtime = new $RuntimeOptions{};
  return disableAlertTemplateWithOptions(request, runtime);
}

model EnableAlertTemplateRequest {
  id?: long(name='Id', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model EnableAlertTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableAlertTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableAlertTemplateResponseBody(name='body'),
}

/**
 * @param request EnableAlertTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableAlertTemplateResponse
 */
@context("enableAlertTemplateWithContext")
async function enableAlertTemplateWithOptions(request: EnableAlertTemplateRequest, runtime: $RuntimeOptions): EnableAlertTemplateResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.id)) {
    query['Id'] = request.id;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'EnableAlertTemplate',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request EnableAlertTemplateRequest
 * @return EnableAlertTemplateResponse
 */
async function enableAlertTemplate(request: EnableAlertTemplateRequest): EnableAlertTemplateResponse {
  var runtime = new $RuntimeOptions{};
  return enableAlertTemplateWithOptions(request, runtime);
}

model ExportPrometheusRulesRequest {
  clusterId?: string(name='ClusterId', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  nameSpace?: string(name='NameSpace', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model ExportPrometheusRulesResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ExportPrometheusRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExportPrometheusRulesResponseBody(name='body'),
}

/**
 * @param request ExportPrometheusRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportPrometheusRulesResponse
 */
@context("exportPrometheusRulesWithContext")
async function exportPrometheusRulesWithOptions(request: ExportPrometheusRulesRequest, runtime: $RuntimeOptions): ExportPrometheusRulesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.nameSpace)) {
    query['NameSpace'] = request.nameSpace;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ExportPrometheusRules',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ExportPrometheusRulesRequest
 * @return ExportPrometheusRulesResponse
 */
async function exportPrometheusRules(request: ExportPrometheusRulesRequest): ExportPrometheusRulesResponse {
  var runtime = new $RuntimeOptions{};
  return exportPrometheusRulesWithOptions(request, runtime);
}

model GetAgentDownloadUrlRequest {
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model GetAgentDownloadUrlResponseBody = {
  armsAgentDownloadUrl?: string(name='ArmsAgentDownloadUrl'),
  requestId?: string(name='RequestId'),
}

model GetAgentDownloadUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAgentDownloadUrlResponseBody(name='body'),
}

/**
 * @param request GetAgentDownloadUrlRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAgentDownloadUrlResponse
 */
@context("getAgentDownloadUrlWithContext")
async function getAgentDownloadUrlWithOptions(request: GetAgentDownloadUrlRequest, runtime: $RuntimeOptions): GetAgentDownloadUrlResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetAgentDownloadUrl',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetAgentDownloadUrlRequest
 * @return GetAgentDownloadUrlResponse
 */
async function getAgentDownloadUrl(request: GetAgentDownloadUrlRequest): GetAgentDownloadUrlResponse {
  var runtime = new $RuntimeOptions{};
  return getAgentDownloadUrlWithOptions(request, runtime);
}

model GetAppApiByPageRequest {
  currentPage?: int32(name='CurrentPage'),
  endTime?: long(name='EndTime'),
  intervalMills?: int32(name='IntervalMills'),
  PId?: string(name='PId', description='This parameter is required.'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  startTime?: long(name='StartTime'),
}

model GetAppApiByPageResponseBody = {
  code?: int32(name='Code'),
  data?: {
    items?: [  map[string]any ](name='Items'),
    page?: int32(name='Page'),
    pageSize?: int32(name='PageSize'),
    total?: string(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAppApiByPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAppApiByPageResponseBody(name='body'),
}

/**
 * @param request GetAppApiByPageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAppApiByPageResponse
 */
@context("getAppApiByPageWithContext")
async function getAppApiByPageWithOptions(request: GetAppApiByPageRequest, runtime: $RuntimeOptions): GetAppApiByPageResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.intervalMills)) {
    query['IntervalMills'] = request.intervalMills;
  }
  if (!$isNull(request.PId)) {
    query['PId'] = request.PId;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetAppApiByPage',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetAppApiByPageRequest
 * @return GetAppApiByPageResponse
 */
async function getAppApiByPage(request: GetAppApiByPageRequest): GetAppApiByPageResponse {
  var runtime = new $RuntimeOptions{};
  return getAppApiByPageWithOptions(request, runtime);
}

model GetConsistencySnapshotRequest {
  appType?: string(name='AppType', description='This parameter is required.'),
  currentTimestamp?: long(name='CurrentTimestamp'),
  pid?: string(name='Pid', description='This parameter is required.'),
  proxyUserId?: string(name='ProxyUserId'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model GetConsistencySnapshotResponseBody = {
  consistencyResultJsonStr?: string(name='ConsistencyResultJsonStr'),
  requestId?: string(name='RequestId'),
}

model GetConsistencySnapshotResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetConsistencySnapshotResponseBody(name='body'),
}

/**
 * @param request GetConsistencySnapshotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetConsistencySnapshotResponse
 */
@context("getConsistencySnapshotWithContext")
async function getConsistencySnapshotWithOptions(request: GetConsistencySnapshotRequest, runtime: $RuntimeOptions): GetConsistencySnapshotResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.appType)) {
    query['AppType'] = request.appType;
  }
  if (!$isNull(request.currentTimestamp)) {
    query['CurrentTimestamp'] = request.currentTimestamp;
  }
  if (!$isNull(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!$isNull(request.proxyUserId)) {
    query['ProxyUserId'] = request.proxyUserId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetConsistencySnapshot',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetConsistencySnapshotRequest
 * @return GetConsistencySnapshotResponse
 */
async function getConsistencySnapshot(request: GetConsistencySnapshotRequest): GetConsistencySnapshotResponse {
  var runtime = new $RuntimeOptions{};
  return getConsistencySnapshotWithOptions(request, runtime);
}

model GetIntegrationTokenRequest {
  productType?: string(name='ProductType', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model GetIntegrationTokenResponseBody = {
  requestId?: string(name='RequestId'),
  token?: string(name='Token'),
}

model GetIntegrationTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetIntegrationTokenResponseBody(name='body'),
}

/**
 * @param request GetIntegrationTokenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetIntegrationTokenResponse
 */
@context("getIntegrationTokenWithContext")
async function getIntegrationTokenWithOptions(request: GetIntegrationTokenRequest, runtime: $RuntimeOptions): GetIntegrationTokenResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetIntegrationToken',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetIntegrationTokenRequest
 * @return GetIntegrationTokenResponse
 */
async function getIntegrationToken(request: GetIntegrationTokenRequest): GetIntegrationTokenResponse {
  var runtime = new $RuntimeOptions{};
  return getIntegrationTokenWithOptions(request, runtime);
}

model GetMultipleTraceRequest {
  regionId?: string(name='RegionId', description='This parameter is required.'),
  traceIDs?: [ string ](name='TraceIDs'),
}

model GetMultipleTraceResponseBody = {
  multiCallChainInfos?: [ 
    {
      spans?: [ 
        {
          duration?: long(name='Duration'),
          haveStack?: boolean(name='HaveStack'),
          logEventList?: [ 
            {
              tagEntryList?: [ 
                {
                  key?: string(name='Key'),
                  value?: string(name='Value'),
                }
              ](name='TagEntryList'),
              timestamp?: long(name='Timestamp'),
            }
          ](name='LogEventList'),
          operationName?: string(name='OperationName'),
          parentSpanId?: string(name='ParentSpanId'),
          resultCode?: string(name='ResultCode'),
          rpcId?: string(name='RpcId'),
          rpcType?: int32(name='RpcType'),
          serviceIp?: string(name='ServiceIp'),
          serviceName?: string(name='ServiceName'),
          spanId?: string(name='SpanId'),
          tagEntryList?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
            }
          ](name='TagEntryList'),
          timestamp?: long(name='Timestamp'),
          traceID?: string(name='TraceID'),
        }
      ](name='Spans'),
      traceID?: string(name='TraceID'),
    }
  ](name='MultiCallChainInfos'),
  requestId?: string(name='RequestId'),
}

model GetMultipleTraceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMultipleTraceResponseBody(name='body'),
}

/**
 * @param request GetMultipleTraceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMultipleTraceResponse
 */
@context("getMultipleTraceWithContext")
async function getMultipleTraceWithOptions(request: GetMultipleTraceRequest, runtime: $RuntimeOptions): GetMultipleTraceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.traceIDs)) {
    query['TraceIDs'] = request.traceIDs;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetMultipleTrace',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMultipleTraceRequest
 * @return GetMultipleTraceResponse
 */
async function getMultipleTrace(request: GetMultipleTraceRequest): GetMultipleTraceResponse {
  var runtime = new $RuntimeOptions{};
  return getMultipleTraceWithOptions(request, runtime);
}

model GetPrometheusApiTokenRequest {
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model GetPrometheusApiTokenResponseBody = {
  requestId?: string(name='RequestId'),
  token?: string(name='Token'),
}

model GetPrometheusApiTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPrometheusApiTokenResponseBody(name='body'),
}

/**
 * @param request GetPrometheusApiTokenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPrometheusApiTokenResponse
 */
@context("getPrometheusApiTokenWithContext")
async function getPrometheusApiTokenWithOptions(request: GetPrometheusApiTokenRequest, runtime: $RuntimeOptions): GetPrometheusApiTokenResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetPrometheusApiToken',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetPrometheusApiTokenRequest
 * @return GetPrometheusApiTokenResponse
 */
async function getPrometheusApiToken(request: GetPrometheusApiTokenRequest): GetPrometheusApiTokenResponse {
  var runtime = new $RuntimeOptions{};
  return getPrometheusApiTokenWithOptions(request, runtime);
}

model GetRetcodeShareUrlRequest {
  pid?: string(name='Pid', description='This parameter is required.'),
}

model GetRetcodeShareUrlResponseBody = {
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model GetRetcodeShareUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRetcodeShareUrlResponseBody(name='body'),
}

/**
 * @param request GetRetcodeShareUrlRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRetcodeShareUrlResponse
 */
@context("getRetcodeShareUrlWithContext")
async function getRetcodeShareUrlWithOptions(request: GetRetcodeShareUrlRequest, runtime: $RuntimeOptions): GetRetcodeShareUrlResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.pid)) {
    query['Pid'] = request.pid;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetRetcodeShareUrl',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetRetcodeShareUrlRequest
 * @return GetRetcodeShareUrlResponse
 */
async function getRetcodeShareUrl(request: GetRetcodeShareUrlRequest): GetRetcodeShareUrlResponse {
  var runtime = new $RuntimeOptions{};
  return getRetcodeShareUrlWithOptions(request, runtime);
}

model GetStackRequest {
  endTime?: long(name='EndTime'),
  pid?: string(name='Pid'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  rpcID?: string(name='RpcID', description='This parameter is required.'),
  startTime?: long(name='StartTime'),
  traceID?: string(name='TraceID', description='This parameter is required.'),
}

model GetStackResponseBody = {
  requestId?: string(name='RequestId'),
  stackInfo?: [ 
    {
      api?: string(name='Api'),
      duration?: long(name='Duration'),
      exception?: string(name='Exception'),
      extInfo?: {
        info?: string(name='Info'),
        type?: string(name='Type'),
      }(name='ExtInfo'),
      line?: string(name='Line'),
      rpcId?: string(name='RpcId'),
      serviceName?: string(name='ServiceName'),
      startTime?: long(name='StartTime'),
    }
  ](name='StackInfo'),
}

model GetStackResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetStackResponseBody(name='body'),
}

/**
 * @param request GetStackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetStackResponse
 */
@context("getStackWithContext")
async function getStackWithOptions(request: GetStackRequest, runtime: $RuntimeOptions): GetStackResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.rpcID)) {
    query['RpcID'] = request.rpcID;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!$isNull(request.traceID)) {
    query['TraceID'] = request.traceID;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetStack',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetStackRequest
 * @return GetStackResponse
 */
async function getStack(request: GetStackRequest): GetStackResponse {
  var runtime = new $RuntimeOptions{};
  return getStackWithOptions(request, runtime);
}

model GetTraceRequest {
  regionId?: string(name='RegionId', description='This parameter is required.'),
  traceID?: string(name='TraceID', description='This parameter is required.'),
}

model GetTraceResponseBody = {
  requestId?: string(name='RequestId'),
  spans?: [ 
    {
      duration?: long(name='Duration'),
      haveStack?: boolean(name='HaveStack'),
      logEventList?: [ 
        {
          tagEntryList?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
            }
          ](name='TagEntryList'),
          timestamp?: long(name='Timestamp'),
        }
      ](name='LogEventList'),
      operationName?: string(name='OperationName'),
      parentSpanId?: string(name='ParentSpanId'),
      resultCode?: string(name='ResultCode'),
      rpcId?: string(name='RpcId'),
      rpcType?: int32(name='RpcType'),
      serviceIp?: string(name='ServiceIp'),
      serviceName?: string(name='ServiceName'),
      spanId?: string(name='SpanId'),
      tagEntryList?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='TagEntryList'),
      timestamp?: long(name='Timestamp'),
      traceID?: string(name='TraceID'),
    }
  ](name='Spans'),
}

model GetTraceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTraceResponseBody(name='body'),
}

/**
 * @param request GetTraceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTraceResponse
 */
@context("getTraceWithContext")
async function getTraceWithOptions(request: GetTraceRequest, runtime: $RuntimeOptions): GetTraceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.traceID)) {
    query['TraceID'] = request.traceID;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetTrace',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetTraceRequest
 * @return GetTraceResponse
 */
async function getTrace(request: GetTraceRequest): GetTraceResponse {
  var runtime = new $RuntimeOptions{};
  return getTraceWithOptions(request, runtime);
}

model GetTraceAppRequest {
  pid?: string(name='Pid', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model GetTraceAppResponseBody = {
  requestId?: string(name='RequestId'),
  traceApp?: {
    appId?: long(name='AppId'),
    appName?: string(name='AppName'),
    createTime?: long(name='CreateTime'),
    labels?: [ string ](name='Labels'),
    pid?: string(name='Pid'),
    regionId?: string(name='RegionId'),
    show?: boolean(name='Show'),
    type?: string(name='Type'),
    updateTime?: long(name='UpdateTime'),
    userId?: string(name='UserId'),
  }(name='TraceApp'),
}

model GetTraceAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTraceAppResponseBody(name='body'),
}

/**
 * @param request GetTraceAppRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTraceAppResponse
 */
@context("getTraceAppWithContext")
async function getTraceAppWithOptions(request: GetTraceAppRequest, runtime: $RuntimeOptions): GetTraceAppResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetTraceApp',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetTraceAppRequest
 * @return GetTraceAppResponse
 */
async function getTraceApp(request: GetTraceAppRequest): GetTraceAppResponse {
  var runtime = new $RuntimeOptions{};
  return getTraceAppWithOptions(request, runtime);
}

model ImportAppAlertRulesRequest {
  contactGroupIds?: string(name='ContactGroupIds'),
  isAutoStart?: boolean(name='IsAutoStart'),
  pids?: string(name='Pids', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  templageAlertConfig?: string(name='TemplageAlertConfig'),
  templateAlertId?: string(name='TemplateAlertId'),
}

model ImportAppAlertRulesResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ImportAppAlertRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ImportAppAlertRulesResponseBody(name='body'),
}

/**
 * @param request ImportAppAlertRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportAppAlertRulesResponse
 */
@context("importAppAlertRulesWithContext")
async function importAppAlertRulesWithOptions(request: ImportAppAlertRulesRequest, runtime: $RuntimeOptions): ImportAppAlertRulesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.contactGroupIds)) {
    query['ContactGroupIds'] = request.contactGroupIds;
  }
  if (!$isNull(request.isAutoStart)) {
    query['IsAutoStart'] = request.isAutoStart;
  }
  if (!$isNull(request.pids)) {
    query['Pids'] = request.pids;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.templageAlertConfig)) {
    query['TemplageAlertConfig'] = request.templageAlertConfig;
  }
  if (!$isNull(request.templateAlertId)) {
    query['TemplateAlertId'] = request.templateAlertId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ImportAppAlertRules',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ImportAppAlertRulesRequest
 * @return ImportAppAlertRulesResponse
 */
async function importAppAlertRules(request: ImportAppAlertRulesRequest): ImportAppAlertRulesResponse {
  var runtime = new $RuntimeOptions{};
  return importAppAlertRulesWithOptions(request, runtime);
}

model ImportCustomAlertRulesRequest {
  contactGroupIds?: string(name='ContactGroupIds'),
  isAutoStart?: boolean(name='IsAutoStart'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  templageAlertConfig?: string(name='TemplageAlertConfig'),
  templateAlertConfig?: string(name='TemplateAlertConfig'),
}

model ImportCustomAlertRulesResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ImportCustomAlertRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ImportCustomAlertRulesResponseBody(name='body'),
}

/**
 * @param request ImportCustomAlertRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportCustomAlertRulesResponse
 */
@context("importCustomAlertRulesWithContext")
async function importCustomAlertRulesWithOptions(request: ImportCustomAlertRulesRequest, runtime: $RuntimeOptions): ImportCustomAlertRulesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.contactGroupIds)) {
    query['ContactGroupIds'] = request.contactGroupIds;
  }
  if (!$isNull(request.isAutoStart)) {
    query['IsAutoStart'] = request.isAutoStart;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.templageAlertConfig)) {
    query['TemplageAlertConfig'] = request.templageAlertConfig;
  }
  if (!$isNull(request.templateAlertConfig)) {
    query['TemplateAlertConfig'] = request.templateAlertConfig;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ImportCustomAlertRules',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ImportCustomAlertRulesRequest
 * @return ImportCustomAlertRulesResponse
 */
async function importCustomAlertRules(request: ImportCustomAlertRulesRequest): ImportCustomAlertRulesResponse {
  var runtime = new $RuntimeOptions{};
  return importCustomAlertRulesWithOptions(request, runtime);
}

model ImportPrometheusRulesRequest {
  clusterId?: string(name='ClusterId', description='This parameter is required.'),
  content?: string(name='Content', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  nameSpace?: string(name='NameSpace', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model ImportPrometheusRulesResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ImportPrometheusRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ImportPrometheusRulesResponseBody(name='body'),
}

/**
 * @param request ImportPrometheusRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportPrometheusRulesResponse
 */
@context("importPrometheusRulesWithContext")
async function importPrometheusRulesWithOptions(request: ImportPrometheusRulesRequest, runtime: $RuntimeOptions): ImportPrometheusRulesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.content)) {
    query['Content'] = request.content;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.nameSpace)) {
    query['NameSpace'] = request.nameSpace;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ImportPrometheusRules',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ImportPrometheusRulesRequest
 * @return ImportPrometheusRulesResponse
 */
async function importPrometheusRules(request: ImportPrometheusRulesRequest): ImportPrometheusRulesResponse {
  var runtime = new $RuntimeOptions{};
  return importPrometheusRulesWithOptions(request, runtime);
}

model ListActivatedAlertsRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  filter?: string(name='Filter'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model ListActivatedAlertsResponseBody = {
  page?: {
    alerts?: [ 
      {
        alertId?: string(name='AlertId'),
        alertName?: string(name='AlertName'),
        alertType?: string(name='AlertType'),
        count?: int32(name='Count'),
        createTime?: long(name='CreateTime'),
        dispatchRules?: [ 
          {
            ruleId?: int32(name='RuleId'),
            ruleName?: string(name='RuleName'),
          }
        ](name='DispatchRules'),
        endsAt?: long(name='EndsAt'),
        expandFields?: map[string]any(name='ExpandFields'),
        integrationName?: string(name='IntegrationName'),
        integrationType?: string(name='IntegrationType'),
        involvedObjectKind?: string(name='InvolvedObjectKind'),
        involvedObjectName?: string(name='InvolvedObjectName'),
        message?: string(name='Message'),
        severity?: string(name='Severity'),
        startsAt?: long(name='StartsAt'),
        status?: string(name='Status'),
      }
    ](name='Alerts'),
    page?: int32(name='Page'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Page'),
  requestId?: string(name='RequestId'),
}

model ListActivatedAlertsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListActivatedAlertsResponseBody(name='body'),
}

/**
 * @param request ListActivatedAlertsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListActivatedAlertsResponse
 */
@context("listActivatedAlertsWithContext")
async function listActivatedAlertsWithOptions(request: ListActivatedAlertsRequest, runtime: $RuntimeOptions): ListActivatedAlertsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!$isNull(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListActivatedAlerts',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListActivatedAlertsRequest
 * @return ListActivatedAlertsResponse
 */
async function listActivatedAlerts(request: ListActivatedAlertsRequest): ListActivatedAlertsResponse {
  var runtime = new $RuntimeOptions{};
  return listActivatedAlertsWithOptions(request, runtime);
}

model ListAlertTemplatesRequest {
  alertProvider?: string(name='AlertProvider'),
  labels?: string(name='Labels'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  status?: boolean(name='Status'),
  templateProvider?: string(name='TemplateProvider'),
  type?: string(name='Type'),
}

model ListAlertTemplatesResponseBody = {
  alertTemplates?: [ 
    {
      alertProvider?: string(name='AlertProvider'),
      annotations?: map[string]any(name='Annotations'),
      id?: int32(name='Id'),
      labelMatchExpressionGrid?: {
        labelMatchExpressionGroups?: [ 
          {
            labelMatchExpressions?: [ 
              {
                key?: string(name='Key'),
                operator?: string(name='Operator'),
                value?: string(name='Value'),
              }
            ](name='LabelMatchExpressions'),
          }
        ](name='LabelMatchExpressionGroups'),
      }(name='LabelMatchExpressionGrid'),
      labels?: map[string]any(name='Labels'),
      message?: string(name='Message'),
      name?: string(name='Name'),
      parentId?: int32(name='ParentId'),
      public?: boolean(name='Public'),
      rule?: string(name='Rule'),
      status?: boolean(name='Status'),
      templateProvider?: string(name='TemplateProvider'),
      type?: string(name='Type'),
      userId?: string(name='UserId'),
    }
  ](name='AlertTemplates'),
  requestId?: string(name='RequestId'),
}

model ListAlertTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAlertTemplatesResponseBody(name='body'),
}

/**
 * @param request ListAlertTemplatesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAlertTemplatesResponse
 */
@context("listAlertTemplatesWithContext")
async function listAlertTemplatesWithOptions(request: ListAlertTemplatesRequest, runtime: $RuntimeOptions): ListAlertTemplatesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.alertProvider)) {
    query['AlertProvider'] = request.alertProvider;
  }
  if (!$isNull(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.status)) {
    query['Status'] = request.status;
  }
  if (!$isNull(request.templateProvider)) {
    query['TemplateProvider'] = request.templateProvider;
  }
  if (!$isNull(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListAlertTemplates',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListAlertTemplatesRequest
 * @return ListAlertTemplatesResponse
 */
async function listAlertTemplates(request: ListAlertTemplatesRequest): ListAlertTemplatesResponse {
  var runtime = new $RuntimeOptions{};
  return listAlertTemplatesWithOptions(request, runtime);
}

model ListClusterFromGrafanaRequest {
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model ListClusterFromGrafanaResponseBody = {
  promClusterList?: [ 
    {
      agentStatus?: string(name='AgentStatus'),
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      controllerId?: string(name='ControllerId'),
      createTime?: long(name='CreateTime'),
      extra?: string(name='Extra'),
      id?: long(name='Id'),
      installTime?: long(name='InstallTime'),
      isControllerInstalled?: boolean(name='IsControllerInstalled'),
      lastHeartBeatTime?: long(name='LastHeartBeatTime'),
      nodeNum?: int32(name='NodeNum'),
      options?: string(name='Options'),
      pluginsJsonArray?: string(name='PluginsJsonArray'),
      regionId?: string(name='RegionId'),
      stateJson?: string(name='StateJson'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='PromClusterList'),
  requestId?: string(name='RequestId'),
}

model ListClusterFromGrafanaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClusterFromGrafanaResponseBody(name='body'),
}

/**
 * @param request ListClusterFromGrafanaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClusterFromGrafanaResponse
 */
@context("listClusterFromGrafanaWithContext")
async function listClusterFromGrafanaWithOptions(request: ListClusterFromGrafanaRequest, runtime: $RuntimeOptions): ListClusterFromGrafanaResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListClusterFromGrafana',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListClusterFromGrafanaRequest
 * @return ListClusterFromGrafanaResponse
 */
async function listClusterFromGrafana(request: ListClusterFromGrafanaRequest): ListClusterFromGrafanaResponse {
  var runtime = new $RuntimeOptions{};
  return listClusterFromGrafanaWithOptions(request, runtime);
}

model ListDashboardsRequest {
  clusterId?: string(name='ClusterId'),
  clusterType?: string(name='ClusterType'),
  product?: string(name='Product'),
  recreateSwitch?: boolean(name='RecreateSwitch'),
  regionId?: string(name='RegionId'),
  title?: string(name='Title'),
}

model ListDashboardsResponseBody = {
  dashboardVos?: [ 
    {
      dashboardType?: string(name='DashboardType'),
      exporter?: string(name='Exporter'),
      id?: string(name='Id'),
      isArmsExporter?: boolean(name='IsArmsExporter'),
      kind?: string(name='Kind'),
      name?: string(name='Name'),
      needUpdate?: boolean(name='NeedUpdate'),
      tags?: [ string ](name='Tags'),
      time?: string(name='Time'),
      title?: string(name='Title'),
      type?: string(name='Type'),
      uid?: string(name='Uid'),
      url?: string(name='Url'),
      version?: string(name='Version'),
    }
  ](name='DashboardVos'),
  requestId?: string(name='RequestId'),
}

model ListDashboardsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDashboardsResponseBody(name='body'),
}

/**
 * @param request ListDashboardsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDashboardsResponse
 */
@context("listDashboardsWithContext")
async function listDashboardsWithOptions(request: ListDashboardsRequest, runtime: $RuntimeOptions): ListDashboardsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!$isNull(request.product)) {
    query['Product'] = request.product;
  }
  if (!$isNull(request.recreateSwitch)) {
    query['RecreateSwitch'] = request.recreateSwitch;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.title)) {
    query['Title'] = request.title;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListDashboards',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListDashboardsRequest
 * @return ListDashboardsResponse
 */
async function listDashboards(request: ListDashboardsRequest): ListDashboardsResponse {
  var runtime = new $RuntimeOptions{};
  return listDashboardsWithOptions(request, runtime);
}

model ListDispatchRuleRequest {
  name?: string(name='Name'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  system?: boolean(name='System'),
}

model ListDispatchRuleResponseBody = {
  dispatchRules?: [ 
    {
      name?: string(name='Name'),
      ruleId?: long(name='RuleId'),
      state?: string(name='State'),
    }
  ](name='DispatchRules'),
  requestId?: string(name='RequestId'),
}

model ListDispatchRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDispatchRuleResponseBody(name='body'),
}

/**
 * @param request ListDispatchRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDispatchRuleResponse
 */
@context("listDispatchRuleWithContext")
async function listDispatchRuleWithOptions(request: ListDispatchRuleRequest, runtime: $RuntimeOptions): ListDispatchRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.system)) {
    query['System'] = request.system;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListDispatchRule',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListDispatchRuleRequest
 * @return ListDispatchRuleResponse
 */
async function listDispatchRule(request: ListDispatchRuleRequest): ListDispatchRuleResponse {
  var runtime = new $RuntimeOptions{};
  return listDispatchRuleWithOptions(request, runtime);
}

model ListPromClustersRequest {
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model ListPromClustersResponseBody = {
  promClusterList?: [ 
    {
      agentStatus?: string(name='AgentStatus'),
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      controllerId?: string(name='ControllerId'),
      createTime?: long(name='CreateTime'),
      extra?: string(name='Extra'),
      id?: long(name='Id'),
      installTime?: long(name='InstallTime'),
      isControllerInstalled?: boolean(name='IsControllerInstalled'),
      lastHeartBeatTime?: long(name='LastHeartBeatTime'),
      nodeNum?: int32(name='NodeNum'),
      options?: string(name='Options'),
      pluginsJsonArray?: string(name='PluginsJsonArray'),
      regionId?: string(name='RegionId'),
      stateJson?: string(name='StateJson'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='PromClusterList'),
  requestId?: string(name='RequestId'),
}

model ListPromClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPromClustersResponseBody(name='body'),
}

/**
 * @param request ListPromClustersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPromClustersResponse
 */
@context("listPromClustersWithContext")
async function listPromClustersWithOptions(request: ListPromClustersRequest, runtime: $RuntimeOptions): ListPromClustersResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListPromClusters',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListPromClustersRequest
 * @return ListPromClustersResponse
 */
async function listPromClusters(request: ListPromClustersRequest): ListPromClustersResponse {
  var runtime = new $RuntimeOptions{};
  return listPromClustersWithOptions(request, runtime);
}

model ListPrometheusAlertRulesRequest {
  clusterId?: string(name='ClusterId', description='This parameter is required.'),
  matchExpressions?: string(name='MatchExpressions'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  status?: int32(name='Status'),
  type?: string(name='Type'),
}

model ListPrometheusAlertRulesResponseBody = {
  prometheusAlertRules?: [ 
    {
      alertId?: long(name='AlertId'),
      alertName?: string(name='AlertName'),
      annotations?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='Annotations'),
      clusterId?: string(name='ClusterId'),
      dispatchRuleId?: long(name='DispatchRuleId'),
      duration?: string(name='Duration'),
      expression?: string(name='Expression'),
      labels?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='Labels'),
      message?: string(name='Message'),
      notifyType?: string(name='NotifyType'),
      status?: int32(name='Status'),
      type?: string(name='Type'),
    }
  ](name='PrometheusAlertRules'),
  requestId?: string(name='RequestId'),
}

model ListPrometheusAlertRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPrometheusAlertRulesResponseBody(name='body'),
}

/**
 * @param request ListPrometheusAlertRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPrometheusAlertRulesResponse
 */
@context("listPrometheusAlertRulesWithContext")
async function listPrometheusAlertRulesWithOptions(request: ListPrometheusAlertRulesRequest, runtime: $RuntimeOptions): ListPrometheusAlertRulesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.matchExpressions)) {
    query['MatchExpressions'] = request.matchExpressions;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.status)) {
    query['Status'] = request.status;
  }
  if (!$isNull(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListPrometheusAlertRules',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListPrometheusAlertRulesRequest
 * @return ListPrometheusAlertRulesResponse
 */
async function listPrometheusAlertRules(request: ListPrometheusAlertRulesRequest): ListPrometheusAlertRulesResponse {
  var runtime = new $RuntimeOptions{};
  return listPrometheusAlertRulesWithOptions(request, runtime);
}

model ListPrometheusAlertTemplatesRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model ListPrometheusAlertTemplatesResponseBody = {
  prometheusAlertTemplates?: [ 
    {
      alertName?: string(name='AlertName'),
      annotations?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='Annotations'),
      description?: string(name='Description'),
      duration?: string(name='Duration'),
      expression?: string(name='Expression'),
      labels?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='Labels'),
      type?: string(name='Type'),
      version?: string(name='Version'),
    }
  ](name='PrometheusAlertTemplates'),
  requestId?: string(name='RequestId'),
}

model ListPrometheusAlertTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPrometheusAlertTemplatesResponseBody(name='body'),
}

/**
 * @param request ListPrometheusAlertTemplatesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPrometheusAlertTemplatesResponse
 */
@context("listPrometheusAlertTemplatesWithContext")
async function listPrometheusAlertTemplatesWithOptions(request: ListPrometheusAlertTemplatesRequest, runtime: $RuntimeOptions): ListPrometheusAlertTemplatesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListPrometheusAlertTemplates',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListPrometheusAlertTemplatesRequest
 * @return ListPrometheusAlertTemplatesResponse
 */
async function listPrometheusAlertTemplates(request: ListPrometheusAlertTemplatesRequest): ListPrometheusAlertTemplatesResponse {
  var runtime = new $RuntimeOptions{};
  return listPrometheusAlertTemplatesWithOptions(request, runtime);
}

model ListRetcodeAppsRequest {
  regionId?: string(name='RegionId', description='This parameter is required.'),
  securityToken?: string(name='SecurityToken'),
}

model ListRetcodeAppsResponseBody = {
  requestId?: string(name='RequestId'),
  retcodeApps?: [ 
    {
      appId?: long(name='AppId'),
      appName?: string(name='AppName'),
      pid?: string(name='Pid'),
    }
  ](name='RetcodeApps'),
}

model ListRetcodeAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRetcodeAppsResponseBody(name='body'),
}

/**
 * @param request ListRetcodeAppsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRetcodeAppsResponse
 */
@context("listRetcodeAppsWithContext")
async function listRetcodeAppsWithOptions(request: ListRetcodeAppsRequest, runtime: $RuntimeOptions): ListRetcodeAppsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListRetcodeApps',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListRetcodeAppsRequest
 * @return ListRetcodeAppsResponse
 */
async function listRetcodeApps(request: ListRetcodeAppsRequest): ListRetcodeAppsResponse {
  var runtime = new $RuntimeOptions{};
  return listRetcodeAppsWithOptions(request, runtime);
}

model ListScenarioRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  regionId?: string(name='RegionId'),
  scenario?: string(name='Scenario'),
  sign?: string(name='Sign'),
}

model ListScenarioResponseBody = {
  armsScenarios?: [ 
    {
      appId?: string(name='AppId'),
      createTime?: string(name='CreateTime'),
      extensions?: string(name='Extensions'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      sign?: string(name='Sign'),
      updateTime?: string(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='ArmsScenarios'),
  requestId?: string(name='RequestId'),
}

model ListScenarioResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListScenarioResponseBody(name='body'),
}

/**
 * @param request ListScenarioRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListScenarioResponse
 */
@context("listScenarioWithContext")
async function listScenarioWithOptions(request: ListScenarioRequest, runtime: $RuntimeOptions): ListScenarioResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.scenario)) {
    query['Scenario'] = request.scenario;
  }
  if (!$isNull(request.sign)) {
    query['Sign'] = request.sign;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListScenario',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListScenarioRequest
 * @return ListScenarioResponse
 */
async function listScenario(request: ListScenarioRequest): ListScenarioResponse {
  var runtime = new $RuntimeOptions{};
  return listScenarioWithOptions(request, runtime);
}

model ListServerlessTopNAppsRequest {
  endTime?: long(name='EndTime', description='This parameter is required.'),
  limit?: int32(name='Limit'),
  orderBy?: string(name='OrderBy'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
}

model ListServerlessTopNAppsResponseBody = {
  data?: [ 
    {
      count?: int32(name='Count'),
      error?: int32(name='Error'),
      name?: string(name='Name'),
      pid?: string(name='Pid'),
      region?: string(name='Region'),
      rt?: float(name='Rt'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model ListServerlessTopNAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListServerlessTopNAppsResponseBody(name='body'),
}

/**
 * @param request ListServerlessTopNAppsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListServerlessTopNAppsResponse
 */
@context("listServerlessTopNAppsWithContext")
async function listServerlessTopNAppsWithOptions(request: ListServerlessTopNAppsRequest, runtime: $RuntimeOptions): ListServerlessTopNAppsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!$isNull(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListServerlessTopNApps',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListServerlessTopNAppsRequest
 * @return ListServerlessTopNAppsResponse
 */
async function listServerlessTopNApps(request: ListServerlessTopNAppsRequest): ListServerlessTopNAppsResponse {
  var runtime = new $RuntimeOptions{};
  return listServerlessTopNAppsWithOptions(request, runtime);
}

model ListTraceAppsRequest {
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model ListTraceAppsResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceApps?: [ 
    {
      appId?: long(name='AppId'),
      appName?: string(name='AppName'),
      createTime?: long(name='CreateTime'),
      labels?: [ string ](name='Labels'),
      pid?: string(name='Pid'),
      regionId?: string(name='RegionId'),
      show?: boolean(name='Show'),
      type?: string(name='Type'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='TraceApps'),
}

model ListTraceAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTraceAppsResponseBody(name='body'),
}

/**
 * @param request ListTraceAppsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTraceAppsResponse
 */
@context("listTraceAppsWithContext")
async function listTraceAppsWithOptions(request: ListTraceAppsRequest, runtime: $RuntimeOptions): ListTraceAppsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListTraceApps',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListTraceAppsRequest
 * @return ListTraceAppsResponse
 */
async function listTraceApps(request: ListTraceAppsRequest): ListTraceAppsResponse {
  var runtime = new $RuntimeOptions{};
  return listTraceAppsWithOptions(request, runtime);
}

model OpenArmsDefaultSLRRequest {
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model OpenArmsDefaultSLRResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model OpenArmsDefaultSLRResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenArmsDefaultSLRResponseBody(name='body'),
}

/**
 * @param request OpenArmsDefaultSLRRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenArmsDefaultSLRResponse
 */
@context("openArmsDefaultSLRWithContext")
async function openArmsDefaultSLRWithOptions(request: OpenArmsDefaultSLRRequest, runtime: $RuntimeOptions): OpenArmsDefaultSLRResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'OpenArmsDefaultSLR',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request OpenArmsDefaultSLRRequest
 * @return OpenArmsDefaultSLRResponse
 */
async function openArmsDefaultSLR(request: OpenArmsDefaultSLRRequest): OpenArmsDefaultSLRResponse {
  var runtime = new $RuntimeOptions{};
  return openArmsDefaultSLRWithOptions(request, runtime);
}

model OpenArmsServiceRequest {
  ownerId?: long(name='OwnerId'),
  type?: string(name='Type', description='This parameter is required.'),
}

model OpenArmsServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenArmsServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenArmsServiceResponseBody(name='body'),
}

/**
 * @param request OpenArmsServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenArmsServiceResponse
 */
@context("openArmsServiceWithContext")
async function openArmsServiceWithOptions(request: OpenArmsServiceRequest, runtime: $RuntimeOptions): OpenArmsServiceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!$isNull(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'OpenArmsService',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request OpenArmsServiceRequest
 * @return OpenArmsServiceResponse
 */
async function openArmsService(request: OpenArmsServiceRequest): OpenArmsServiceResponse {
  var runtime = new $RuntimeOptions{};
  return openArmsServiceWithOptions(request, runtime);
}

model OpenVClusterRequest {
  clusterType?: string(name='ClusterType', description='This parameter is required.'),
  length?: int32(name='Length'),
  product?: string(name='Product'),
  recreateSwitch?: boolean(name='RecreateSwitch'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model OpenVClusterResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model OpenVClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenVClusterResponseBody(name='body'),
}

/**
 * @param request OpenVClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenVClusterResponse
 */
@context("openVClusterWithContext")
async function openVClusterWithOptions(request: OpenVClusterRequest, runtime: $RuntimeOptions): OpenVClusterResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!$isNull(request.length)) {
    query['Length'] = request.length;
  }
  if (!$isNull(request.product)) {
    query['Product'] = request.product;
  }
  if (!$isNull(request.recreateSwitch)) {
    query['RecreateSwitch'] = request.recreateSwitch;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'OpenVCluster',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request OpenVClusterRequest
 * @return OpenVClusterResponse
 */
async function openVCluster(request: OpenVClusterRequest): OpenVClusterResponse {
  var runtime = new $RuntimeOptions{};
  return openVClusterWithOptions(request, runtime);
}

model OpenXtraceDefaultSLRRequest {
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model OpenXtraceDefaultSLRResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model OpenXtraceDefaultSLRResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenXtraceDefaultSLRResponseBody(name='body'),
}

/**
 * @param request OpenXtraceDefaultSLRRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenXtraceDefaultSLRResponse
 */
@context("openXtraceDefaultSLRWithContext")
async function openXtraceDefaultSLRWithOptions(request: OpenXtraceDefaultSLRRequest, runtime: $RuntimeOptions): OpenXtraceDefaultSLRResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'OpenXtraceDefaultSLR',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request OpenXtraceDefaultSLRRequest
 * @return OpenXtraceDefaultSLRResponse
 */
async function openXtraceDefaultSLR(request: OpenXtraceDefaultSLRRequest): OpenXtraceDefaultSLRResponse {
  var runtime = new $RuntimeOptions{};
  return openXtraceDefaultSLRWithOptions(request, runtime);
}

model QueryDatasetRequest {
  datasetId?: long(name='DatasetId', description='This parameter is required.'),
  dateStr?: string(name='DateStr'),
  dimensions?: [ 
    {
      key?: string(name='Key'),
      type?: string(name='Type'),
      value?: string(name='Value'),
    }
  ](name='Dimensions'),
  hungryMode?: boolean(name='HungryMode'),
  intervalInSec?: int32(name='IntervalInSec', description='This parameter is required.'),
  isDrillDown?: boolean(name='IsDrillDown'),
  limit?: int32(name='Limit'),
  maxTime?: long(name='MaxTime', description='This parameter is required.'),
  measures?: [ string ](name='Measures'),
  minTime?: long(name='MinTime', description='This parameter is required.'),
  optionalDims?: [ 
    {
      key?: string(name='Key'),
      type?: string(name='Type'),
      value?: string(name='Value'),
    }
  ](name='OptionalDims'),
  orderByKey?: string(name='OrderByKey'),
  proxyUserId?: string(name='ProxyUserId'),
  reduceTail?: boolean(name='ReduceTail'),
  requiredDims?: [ 
    {
      key?: string(name='Key'),
      type?: string(name='Type'),
      value?: string(name='Value'),
    }
  ](name='RequiredDims'),
}

model QueryDatasetResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryDatasetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDatasetResponseBody(name='body'),
}

/**
 * @param request QueryDatasetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDatasetResponse
 */
@context("queryDatasetWithContext")
async function queryDatasetWithOptions(request: QueryDatasetRequest, runtime: $RuntimeOptions): QueryDatasetResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.datasetId)) {
    query['DatasetId'] = request.datasetId;
  }
  if (!$isNull(request.dateStr)) {
    query['DateStr'] = request.dateStr;
  }
  if (!$isNull(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!$isNull(request.hungryMode)) {
    query['HungryMode'] = request.hungryMode;
  }
  if (!$isNull(request.intervalInSec)) {
    query['IntervalInSec'] = request.intervalInSec;
  }
  if (!$isNull(request.isDrillDown)) {
    query['IsDrillDown'] = request.isDrillDown;
  }
  if (!$isNull(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!$isNull(request.maxTime)) {
    query['MaxTime'] = request.maxTime;
  }
  if (!$isNull(request.measures)) {
    query['Measures'] = request.measures;
  }
  if (!$isNull(request.minTime)) {
    query['MinTime'] = request.minTime;
  }
  if (!$isNull(request.optionalDims)) {
    query['OptionalDims'] = request.optionalDims;
  }
  if (!$isNull(request.orderByKey)) {
    query['OrderByKey'] = request.orderByKey;
  }
  if (!$isNull(request.proxyUserId)) {
    query['ProxyUserId'] = request.proxyUserId;
  }
  if (!$isNull(request.reduceTail)) {
    query['ReduceTail'] = request.reduceTail;
  }
  if (!$isNull(request.requiredDims)) {
    query['RequiredDims'] = request.requiredDims;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryDataset',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDatasetRequest
 * @return QueryDatasetResponse
 */
async function queryDataset(request: QueryDatasetRequest): QueryDatasetResponse {
  var runtime = new $RuntimeOptions{};
  return queryDatasetWithOptions(request, runtime);
}

model QueryMetricRequest {
  consistencyDataKey?: string(name='ConsistencyDataKey'),
  consistencyQueryStrategy?: string(name='ConsistencyQueryStrategy'),
  dimensions?: [ string ](name='Dimensions'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  filters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filters'),
  intervalInSec?: int32(name='IntervalInSec'),
  limit?: int32(name='Limit'),
  measures?: [ string ](name='Measures', description='This parameter is required.'),
  metric?: string(name='Metric', description='This parameter is required.'),
  order?: string(name='Order'),
  orderBy?: string(name='OrderBy'),
  proxyUserId?: string(name='ProxyUserId'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
}

model QueryMetricResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryMetricResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMetricResponseBody(name='body'),
}

/**
 * @param request QueryMetricRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMetricResponse
 */
@context("queryMetricWithContext")
async function queryMetricWithOptions(request: QueryMetricRequest, runtime: $RuntimeOptions): QueryMetricResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.consistencyDataKey)) {
    query['ConsistencyDataKey'] = request.consistencyDataKey;
  }
  if (!$isNull(request.consistencyQueryStrategy)) {
    query['ConsistencyQueryStrategy'] = request.consistencyQueryStrategy;
  }
  if (!$isNull(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!$isNull(request.intervalInSec)) {
    query['IntervalInSec'] = request.intervalInSec;
  }
  if (!$isNull(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!$isNull(request.measures)) {
    query['Measures'] = request.measures;
  }
  if (!$isNull(request.metric)) {
    query['Metric'] = request.metric;
  }
  if (!$isNull(request.order)) {
    query['Order'] = request.order;
  }
  if (!$isNull(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!$isNull(request.proxyUserId)) {
    query['ProxyUserId'] = request.proxyUserId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMetric',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMetricRequest
 * @return QueryMetricResponse
 */
async function queryMetric(request: QueryMetricRequest): QueryMetricResponse {
  var runtime = new $RuntimeOptions{};
  return queryMetricWithOptions(request, runtime);
}

model QueryMetricByPageRequest {
  currentPage?: int32(name='CurrentPage'),
  customFilters?: [ string ](name='CustomFilters'),
  dimensions?: [ string ](name='Dimensions'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  filters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filters'),
  intervalInSec?: int32(name='IntervalInSec'),
  measures?: [ string ](name='Measures', description='This parameter is required.'),
  metric?: string(name='Metric', description='This parameter is required.'),
  order?: string(name='Order'),
  orderBy?: string(name='OrderBy'),
  pageSize?: int32(name='PageSize'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
}

model QueryMetricByPageResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [  map[string]any ](name='Items'),
    page?: int32(name='Page'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryMetricByPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMetricByPageResponseBody(name='body'),
}

/**
 * @param request QueryMetricByPageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMetricByPageResponse
 */
@context("queryMetricByPageWithContext")
async function queryMetricByPageWithOptions(request: QueryMetricByPageRequest, runtime: $RuntimeOptions): QueryMetricByPageResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!$isNull(request.customFilters)) {
    query['CustomFilters'] = request.customFilters;
  }
  if (!$isNull(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!$isNull(request.intervalInSec)) {
    query['IntervalInSec'] = request.intervalInSec;
  }
  if (!$isNull(request.measures)) {
    query['Measures'] = request.measures;
  }
  if (!$isNull(request.metric)) {
    query['Metric'] = request.metric;
  }
  if (!$isNull(request.order)) {
    query['Order'] = request.order;
  }
  if (!$isNull(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMetricByPage',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMetricByPageRequest
 * @return QueryMetricByPageResponse
 */
async function queryMetricByPage(request: QueryMetricByPageRequest): QueryMetricByPageResponse {
  var runtime = new $RuntimeOptions{};
  return queryMetricByPageWithOptions(request, runtime);
}

model SaveTraceAppConfigRequest {
  pid?: string(name='Pid', description='This parameter is required.'),
  settings?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Settings'),
}

model SaveTraceAppConfigResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model SaveTraceAppConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SaveTraceAppConfigResponseBody(name='body'),
}

/**
 * @param request SaveTraceAppConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveTraceAppConfigResponse
 */
@context("saveTraceAppConfigWithContext")
async function saveTraceAppConfigWithOptions(request: SaveTraceAppConfigRequest, runtime: $RuntimeOptions): SaveTraceAppConfigResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!$isNull(request.settings)) {
    query['Settings'] = request.settings;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SaveTraceAppConfig',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SaveTraceAppConfigRequest
 * @return SaveTraceAppConfigResponse
 */
async function saveTraceAppConfig(request: SaveTraceAppConfigRequest): SaveTraceAppConfigResponse {
  var runtime = new $RuntimeOptions{};
  return saveTraceAppConfigWithOptions(request, runtime);
}

model SearchAlertContactRequest {
  contactIds?: string(name='ContactIds'),
  contactName?: string(name='ContactName'),
  currentPage?: string(name='CurrentPage'),
  email?: string(name='Email'),
  pageSize?: string(name='PageSize'),
  phone?: string(name='Phone'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model SearchAlertContactResponseBody = {
  pageBean?: {
    contacts?: [ 
      {
        contactId?: long(name='ContactId'),
        contactName?: string(name='ContactName'),
        createTime?: long(name='CreateTime'),
        dingRobot?: string(name='DingRobot'),
        email?: string(name='Email'),
        phone?: string(name='Phone'),
        systemNoc?: boolean(name='SystemNoc'),
        updateTime?: long(name='UpdateTime'),
        userId?: string(name='UserId'),
        webhook?: string(name='Webhook'),
      }
    ](name='Contacts'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchAlertContactResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchAlertContactResponseBody(name='body'),
}

/**
 * @param request SearchAlertContactRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchAlertContactResponse
 */
@context("searchAlertContactWithContext")
async function searchAlertContactWithOptions(request: SearchAlertContactRequest, runtime: $RuntimeOptions): SearchAlertContactResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.contactIds)) {
    query['ContactIds'] = request.contactIds;
  }
  if (!$isNull(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!$isNull(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!$isNull(request.email)) {
    query['Email'] = request.email;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.phone)) {
    query['Phone'] = request.phone;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SearchAlertContact',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SearchAlertContactRequest
 * @return SearchAlertContactResponse
 */
async function searchAlertContact(request: SearchAlertContactRequest): SearchAlertContactResponse {
  var runtime = new $RuntimeOptions{};
  return searchAlertContactWithOptions(request, runtime);
}

model SearchAlertContactGroupRequest {
  contactGroupIds?: string(name='ContactGroupIds'),
  contactGroupName?: string(name='ContactGroupName'),
  contactId?: long(name='ContactId'),
  contactName?: string(name='ContactName'),
  isDetail?: boolean(name='IsDetail'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model SearchAlertContactGroupResponseBody = {
  contactGroups?: [ 
    {
      contactGroupId?: long(name='ContactGroupId'),
      contactGroupName?: string(name='ContactGroupName'),
      contacts?: [ 
        {
          contactId?: long(name='ContactId'),
          contactName?: string(name='ContactName'),
          createTime?: long(name='CreateTime'),
          dingRobot?: string(name='DingRobot'),
          email?: string(name='Email'),
          phone?: string(name='Phone'),
          systemNoc?: boolean(name='SystemNoc'),
          updateTime?: long(name='UpdateTime'),
          userId?: string(name='UserId'),
        }
      ](name='Contacts'),
      createTime?: long(name='CreateTime'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='ContactGroups'),
  requestId?: string(name='RequestId'),
}

model SearchAlertContactGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchAlertContactGroupResponseBody(name='body'),
}

/**
 * @param request SearchAlertContactGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchAlertContactGroupResponse
 */
@context("searchAlertContactGroupWithContext")
async function searchAlertContactGroupWithOptions(request: SearchAlertContactGroupRequest, runtime: $RuntimeOptions): SearchAlertContactGroupResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.contactGroupIds)) {
    query['ContactGroupIds'] = request.contactGroupIds;
  }
  if (!$isNull(request.contactGroupName)) {
    query['ContactGroupName'] = request.contactGroupName;
  }
  if (!$isNull(request.contactId)) {
    query['ContactId'] = request.contactId;
  }
  if (!$isNull(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!$isNull(request.isDetail)) {
    query['IsDetail'] = request.isDetail;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SearchAlertContactGroup',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SearchAlertContactGroupRequest
 * @return SearchAlertContactGroupResponse
 */
async function searchAlertContactGroup(request: SearchAlertContactGroupRequest): SearchAlertContactGroupResponse {
  var runtime = new $RuntimeOptions{};
  return searchAlertContactGroupWithOptions(request, runtime);
}

model SearchAlertHistoriesRequest {
  alertId?: long(name='AlertId'),
  alertType?: int32(name='AlertType'),
  currentPage?: int32(name='CurrentPage'),
  endTime?: long(name='EndTime'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  startTime?: long(name='StartTime'),
}

model SearchAlertHistoriesResponseBody = {
  pageBean?: {
    alarmHistories?: [ 
      {
        alarmContent?: string(name='AlarmContent'),
        alarmResponseCode?: int32(name='AlarmResponseCode'),
        alarmSources?: string(name='AlarmSources'),
        alarmTime?: long(name='AlarmTime'),
        alarmType?: int32(name='AlarmType'),
        emails?: string(name='Emails'),
        id?: long(name='Id'),
        phones?: string(name='Phones'),
        strategyId?: string(name='StrategyId'),
        target?: string(name='Target'),
        userId?: string(name='UserId'),
      }
    ](name='AlarmHistories'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchAlertHistoriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchAlertHistoriesResponseBody(name='body'),
}

/**
 * @param request SearchAlertHistoriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchAlertHistoriesResponse
 */
@context("searchAlertHistoriesWithContext")
async function searchAlertHistoriesWithOptions(request: SearchAlertHistoriesRequest, runtime: $RuntimeOptions): SearchAlertHistoriesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!$isNull(request.alertType)) {
    query['AlertType'] = request.alertType;
  }
  if (!$isNull(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SearchAlertHistories',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SearchAlertHistoriesRequest
 * @return SearchAlertHistoriesResponse
 */
async function searchAlertHistories(request: SearchAlertHistoriesRequest): SearchAlertHistoriesResponse {
  var runtime = new $RuntimeOptions{};
  return searchAlertHistoriesWithOptions(request, runtime);
}

model SearchAlertRulesRequest {
  appType?: string(name='AppType'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  pid?: string(name='Pid'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  title?: string(name='Title'),
  type?: string(name='Type'),
}

model SearchAlertRulesResponseBody = {
  pageBean?: {
    alertRules?: [ 
      {
        alarmContext?: {
          alarmContentSubTitle?: string(name='AlarmContentSubTitle'),
          alarmContentTemplate?: string(name='AlarmContentTemplate'),
          content?: string(name='Content'),
          subTitle?: string(name='SubTitle'),
        }(name='AlarmContext'),
        alertLevel?: string(name='AlertLevel'),
        alertRule?: {
          operator?: string(name='Operator'),
          rules?: [ 
            {
              aggregates?: string(name='Aggregates'),
              alias?: string(name='Alias'),
              measure?: string(name='Measure'),
              NValue?: int32(name='NValue'),
              operator?: string(name='Operator'),
              value?: float(name='Value'),
            }
          ](name='Rules'),
        }(name='AlertRule'),
        alertTitle?: string(name='AlertTitle'),
        alertType?: int32(name='AlertType'),
        alertVersion?: int32(name='AlertVersion'),
        alertWay?: [ string ](name='AlertWay'),
        alertWays?: [ string ](name='AlertWays'),
        config?: string(name='Config'),
        contactGroupIdList?: string(name='ContactGroupIdList'),
        contactGroupIds?: string(name='ContactGroupIds'),
        createTime?: long(name='CreateTime'),
        id?: long(name='Id'),
        metricParam?: {
          appGroupId?: string(name='AppGroupId'),
          appId?: string(name='AppId'),
          dimensions?: [ 
            {
              key?: string(name='Key'),
              type?: string(name='Type'),
              value?: string(name='Value'),
            }
          ](name='Dimensions'),
          pid?: string(name='Pid'),
          type?: string(name='Type'),
        }(name='MetricParam'),
        notice?: {
          endTime?: long(name='EndTime'),
          noticeEndTime?: long(name='NoticeEndTime'),
          noticeStartTime?: long(name='NoticeStartTime'),
          startTime?: long(name='StartTime'),
        }(name='Notice'),
        regionId?: string(name='RegionId'),
        status?: string(name='Status'),
        taskId?: long(name='TaskId'),
        taskStatus?: string(name='TaskStatus'),
        title?: string(name='Title'),
        updateTime?: long(name='UpdateTime'),
        userId?: string(name='UserId'),
      }
    ](name='AlertRules'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchAlertRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchAlertRulesResponseBody(name='body'),
}

/**
 * @param request SearchAlertRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchAlertRulesResponse
 */
@context("searchAlertRulesWithContext")
async function searchAlertRulesWithOptions(request: SearchAlertRulesRequest, runtime: $RuntimeOptions): SearchAlertRulesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.appType)) {
    query['AppType'] = request.appType;
  }
  if (!$isNull(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.title)) {
    query['Title'] = request.title;
  }
  if (!$isNull(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SearchAlertRules',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SearchAlertRulesRequest
 * @return SearchAlertRulesResponse
 */
async function searchAlertRules(request: SearchAlertRulesRequest): SearchAlertRulesResponse {
  var runtime = new $RuntimeOptions{};
  return searchAlertRulesWithOptions(request, runtime);
}

model SearchEventsRequest {
  alertId?: long(name='AlertId'),
  alertType?: int32(name='AlertType'),
  appType?: string(name='AppType'),
  currentPage?: int32(name='CurrentPage'),
  endTime?: long(name='EndTime'),
  isTrigger?: int32(name='IsTrigger'),
  pageSize?: int32(name='PageSize'),
  pid?: string(name='Pid'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  startTime?: long(name='StartTime'),
}

model SearchEventsResponseBody = {
  isTrigger?: int32(name='IsTrigger'),
  pageBean?: {
    event?: [ 
      {
        alertId?: long(name='AlertId'),
        alertName?: string(name='AlertName'),
        alertRule?: string(name='AlertRule'),
        alertType?: int32(name='AlertType'),
        eventLevel?: string(name='EventLevel'),
        eventTime?: long(name='EventTime'),
        id?: long(name='Id'),
        links?: [ string ](name='Links'),
        message?: string(name='Message'),
      }
    ](name='Event'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchEventsResponseBody(name='body'),
}

/**
 * @param request SearchEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchEventsResponse
 */
@context("searchEventsWithContext")
async function searchEventsWithOptions(request: SearchEventsRequest, runtime: $RuntimeOptions): SearchEventsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!$isNull(request.alertType)) {
    query['AlertType'] = request.alertType;
  }
  if (!$isNull(request.appType)) {
    query['AppType'] = request.appType;
  }
  if (!$isNull(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.isTrigger)) {
    query['IsTrigger'] = request.isTrigger;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SearchEvents',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SearchEventsRequest
 * @return SearchEventsResponse
 */
async function searchEvents(request: SearchEventsRequest): SearchEventsResponse {
  var runtime = new $RuntimeOptions{};
  return searchEventsWithOptions(request, runtime);
}

model SearchRetcodeAppByPageRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  retcodeAppName?: string(name='RetcodeAppName'),
}

model SearchRetcodeAppByPageResponseBody = {
  pageBean?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    retcodeApps?: [ 
      {
        appId?: long(name='AppId'),
        appName?: string(name='AppName'),
        createTime?: long(name='CreateTime'),
        pid?: string(name='Pid'),
        regionId?: string(name='RegionId'),
        type?: string(name='Type'),
        updateTime?: long(name='UpdateTime'),
        userId?: string(name='UserId'),
      }
    ](name='RetcodeApps'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchRetcodeAppByPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchRetcodeAppByPageResponseBody(name='body'),
}

/**
 * @param request SearchRetcodeAppByPageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchRetcodeAppByPageResponse
 */
@context("searchRetcodeAppByPageWithContext")
async function searchRetcodeAppByPageWithOptions(request: SearchRetcodeAppByPageRequest, runtime: $RuntimeOptions): SearchRetcodeAppByPageResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.retcodeAppName)) {
    query['RetcodeAppName'] = request.retcodeAppName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SearchRetcodeAppByPage',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SearchRetcodeAppByPageRequest
 * @return SearchRetcodeAppByPageResponse
 */
async function searchRetcodeAppByPage(request: SearchRetcodeAppByPageRequest): SearchRetcodeAppByPageResponse {
  var runtime = new $RuntimeOptions{};
  return searchRetcodeAppByPageWithOptions(request, runtime);
}

model SearchTraceAppByNameRequest {
  regionId?: string(name='RegionId', description='This parameter is required.'),
  traceAppName?: string(name='TraceAppName'),
}

model SearchTraceAppByNameResponseBody = {
  requestId?: string(name='RequestId'),
  traceApps?: [ 
    {
      appId?: long(name='AppId'),
      appName?: string(name='AppName'),
      createTime?: long(name='CreateTime'),
      labels?: [ string ](name='Labels'),
      pid?: string(name='Pid'),
      regionId?: string(name='RegionId'),
      show?: boolean(name='Show'),
      type?: string(name='Type'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='TraceApps'),
}

model SearchTraceAppByNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchTraceAppByNameResponseBody(name='body'),
}

/**
 * @param request SearchTraceAppByNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchTraceAppByNameResponse
 */
@context("searchTraceAppByNameWithContext")
async function searchTraceAppByNameWithOptions(request: SearchTraceAppByNameRequest, runtime: $RuntimeOptions): SearchTraceAppByNameResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.traceAppName)) {
    query['TraceAppName'] = request.traceAppName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SearchTraceAppByName',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SearchTraceAppByNameRequest
 * @return SearchTraceAppByNameResponse
 */
async function searchTraceAppByName(request: SearchTraceAppByNameRequest): SearchTraceAppByNameResponse {
  var runtime = new $RuntimeOptions{};
  return searchTraceAppByNameWithOptions(request, runtime);
}

model SearchTraceAppByPageRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  traceAppName?: string(name='TraceAppName'),
}

model SearchTraceAppByPageResponseBody = {
  pageBean?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    traceApps?: [ 
      {
        appId?: long(name='AppId'),
        appName?: string(name='AppName'),
        createTime?: long(name='CreateTime'),
        labels?: [ string ](name='Labels'),
        pid?: string(name='Pid'),
        regionId?: string(name='RegionId'),
        show?: boolean(name='Show'),
        type?: string(name='Type'),
        updateTime?: long(name='UpdateTime'),
        userId?: string(name='UserId'),
      }
    ](name='TraceApps'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchTraceAppByPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchTraceAppByPageResponseBody(name='body'),
}

/**
 * @param request SearchTraceAppByPageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchTraceAppByPageResponse
 */
@context("searchTraceAppByPageWithContext")
async function searchTraceAppByPageWithOptions(request: SearchTraceAppByPageRequest, runtime: $RuntimeOptions): SearchTraceAppByPageResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.traceAppName)) {
    query['TraceAppName'] = request.traceAppName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SearchTraceAppByPage',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SearchTraceAppByPageRequest
 * @return SearchTraceAppByPageResponse
 */
async function searchTraceAppByPage(request: SearchTraceAppByPageRequest): SearchTraceAppByPageResponse {
  var runtime = new $RuntimeOptions{};
  return searchTraceAppByPageWithOptions(request, runtime);
}

model SearchTracesRequest {
  endTime?: long(name='EndTime', description='This parameter is required.'),
  exclusionFilters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='ExclusionFilters'),
  minDuration?: long(name='MinDuration'),
  operationName?: string(name='OperationName'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  reverse?: boolean(name='Reverse'),
  serviceIp?: string(name='ServiceIp'),
  serviceName?: string(name='ServiceName'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model SearchTracesResponseBody = {
  requestId?: string(name='RequestId'),
  traceInfos?: [ 
    {
      duration?: long(name='Duration'),
      operationName?: string(name='OperationName'),
      serviceIp?: string(name='ServiceIp'),
      serviceName?: string(name='ServiceName'),
      timestamp?: long(name='Timestamp'),
      traceID?: string(name='TraceID'),
    }
  ](name='TraceInfos'),
}

model SearchTracesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchTracesResponseBody(name='body'),
}

/**
 * @param request SearchTracesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchTracesResponse
 */
@context("searchTracesWithContext")
async function searchTracesWithOptions(request: SearchTracesRequest, runtime: $RuntimeOptions): SearchTracesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.exclusionFilters)) {
    query['ExclusionFilters'] = request.exclusionFilters;
  }
  if (!$isNull(request.minDuration)) {
    query['MinDuration'] = request.minDuration;
  }
  if (!$isNull(request.operationName)) {
    query['OperationName'] = request.operationName;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.reverse)) {
    query['Reverse'] = request.reverse;
  }
  if (!$isNull(request.serviceIp)) {
    query['ServiceIp'] = request.serviceIp;
  }
  if (!$isNull(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SearchTraces',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SearchTracesRequest
 * @return SearchTracesResponse
 */
async function searchTraces(request: SearchTracesRequest): SearchTracesResponse {
  var runtime = new $RuntimeOptions{};
  return searchTracesWithOptions(request, runtime);
}

model SearchTracesByPageRequest {
  endTime?: long(name='EndTime', description='This parameter is required.'),
  exclusionFilters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='ExclusionFilters'),
  minDuration?: long(name='MinDuration'),
  operationName?: string(name='OperationName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  reverse?: boolean(name='Reverse'),
  serviceIp?: string(name='ServiceIp'),
  serviceName?: string(name='ServiceName'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
}

model SearchTracesByPageResponseBody = {
  pageBean?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
    traceInfos?: [ 
      {
        duration?: long(name='Duration'),
        operationName?: string(name='OperationName'),
        serviceIp?: string(name='ServiceIp'),
        serviceName?: string(name='ServiceName'),
        timestamp?: long(name='Timestamp'),
        traceID?: string(name='TraceID'),
      }
    ](name='TraceInfos'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchTracesByPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchTracesByPageResponseBody(name='body'),
}

/**
 * @param request SearchTracesByPageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchTracesByPageResponse
 */
@context("searchTracesByPageWithContext")
async function searchTracesByPageWithOptions(request: SearchTracesByPageRequest, runtime: $RuntimeOptions): SearchTracesByPageResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.exclusionFilters)) {
    query['ExclusionFilters'] = request.exclusionFilters;
  }
  if (!$isNull(request.minDuration)) {
    query['MinDuration'] = request.minDuration;
  }
  if (!$isNull(request.operationName)) {
    query['OperationName'] = request.operationName;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.reverse)) {
    query['Reverse'] = request.reverse;
  }
  if (!$isNull(request.serviceIp)) {
    query['ServiceIp'] = request.serviceIp;
  }
  if (!$isNull(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SearchTracesByPage',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SearchTracesByPageRequest
 * @return SearchTracesByPageResponse
 */
async function searchTracesByPage(request: SearchTracesByPageRequest): SearchTracesByPageResponse {
  var runtime = new $RuntimeOptions{};
  return searchTracesByPageWithOptions(request, runtime);
}

model SendCustomIncidentsRequest {
  incidents?: string(name='Incidents', description='This parameter is required.'),
  productType?: string(name='ProductType', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model SendCustomIncidentsResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SendCustomIncidentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SendCustomIncidentsResponseBody(name='body'),
}

/**
 * @param request SendCustomIncidentsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SendCustomIncidentsResponse
 */
@context("sendCustomIncidentsWithContext")
async function sendCustomIncidentsWithOptions(request: SendCustomIncidentsRequest, runtime: $RuntimeOptions): SendCustomIncidentsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.incidents)) {
    query['Incidents'] = request.incidents;
  }
  if (!$isNull(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SendCustomIncidents',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SendCustomIncidentsRequest
 * @return SendCustomIncidentsResponse
 */
async function sendCustomIncidents(request: SendCustomIncidentsRequest): SendCustomIncidentsResponse {
  var runtime = new $RuntimeOptions{};
  return sendCustomIncidentsWithOptions(request, runtime);
}

model SendMseIncidentRequest {
  incidents?: string(name='Incidents', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model SendMseIncidentResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SendMseIncidentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SendMseIncidentResponseBody(name='body'),
}

/**
 * @param request SendMseIncidentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SendMseIncidentResponse
 */
@context("sendMseIncidentWithContext")
async function sendMseIncidentWithOptions(request: SendMseIncidentRequest, runtime: $RuntimeOptions): SendMseIncidentResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.incidents)) {
    query['Incidents'] = request.incidents;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SendMseIncident',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SendMseIncidentRequest
 * @return SendMseIncidentResponse
 */
async function sendMseIncident(request: SendMseIncidentRequest): SendMseIncidentResponse {
  var runtime = new $RuntimeOptions{};
  return sendMseIncidentWithOptions(request, runtime);
}

model SetRetcodeShareStatusRequest {
  pid?: string(name='Pid', description='This parameter is required.'),
  regionId?: string(name='RegionId'),
  status?: boolean(name='Status', description='This parameter is required.'),
}

model SetRetcodeShareStatusResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model SetRetcodeShareStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetRetcodeShareStatusResponseBody(name='body'),
}

/**
 * @param request SetRetcodeShareStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetRetcodeShareStatusResponse
 */
@context("setRetcodeShareStatusWithContext")
async function setRetcodeShareStatusWithOptions(request: SetRetcodeShareStatusRequest, runtime: $RuntimeOptions): SetRetcodeShareStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.pid)) {
    query['Pid'] = request.pid;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SetRetcodeShareStatus',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SetRetcodeShareStatusRequest
 * @return SetRetcodeShareStatusResponse
 */
async function setRetcodeShareStatus(request: SetRetcodeShareStatusRequest): SetRetcodeShareStatusResponse {
  var runtime = new $RuntimeOptions{};
  return setRetcodeShareStatusWithOptions(request, runtime);
}

model StartAlertRequest {
  alertId?: string(name='AlertId', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model StartAlertResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model StartAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartAlertResponseBody(name='body'),
}

/**
 * @param request StartAlertRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartAlertResponse
 */
@context("startAlertWithContext")
async function startAlertWithOptions(request: StartAlertRequest, runtime: $RuntimeOptions): StartAlertResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'StartAlert',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request StartAlertRequest
 * @return StartAlertResponse
 */
async function startAlert(request: StartAlertRequest): StartAlertResponse {
  var runtime = new $RuntimeOptions{};
  return startAlertWithOptions(request, runtime);
}

model StopAlertRequest {
  alertId?: string(name='AlertId', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model StopAlertResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model StopAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopAlertResponseBody(name='body'),
}

/**
 * @param request StopAlertRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopAlertResponse
 */
@context("stopAlertWithContext")
async function stopAlertWithOptions(request: StopAlertRequest, runtime: $RuntimeOptions): StopAlertResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'StopAlert',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request StopAlertRequest
 * @return StopAlertResponse
 */
async function stopAlert(request: StopAlertRequest): StopAlertResponse {
  var runtime = new $RuntimeOptions{};
  return stopAlertWithOptions(request, runtime);
}

model UpdateAlertContactRequest {
  contactId?: long(name='ContactId', description='This parameter is required.'),
  contactName?: string(name='ContactName'),
  dingRobotWebhookUrl?: string(name='DingRobotWebhookUrl'),
  email?: string(name='Email'),
  phoneNum?: string(name='PhoneNum'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  systemNoc?: boolean(name='SystemNoc'),
}

model UpdateAlertContactResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateAlertContactResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAlertContactResponseBody(name='body'),
}

/**
 * @param request UpdateAlertContactRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAlertContactResponse
 */
@context("updateAlertContactWithContext")
async function updateAlertContactWithOptions(request: UpdateAlertContactRequest, runtime: $RuntimeOptions): UpdateAlertContactResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.contactId)) {
    query['ContactId'] = request.contactId;
  }
  if (!$isNull(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!$isNull(request.dingRobotWebhookUrl)) {
    query['DingRobotWebhookUrl'] = request.dingRobotWebhookUrl;
  }
  if (!$isNull(request.email)) {
    query['Email'] = request.email;
  }
  if (!$isNull(request.phoneNum)) {
    query['PhoneNum'] = request.phoneNum;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.systemNoc)) {
    query['SystemNoc'] = request.systemNoc;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateAlertContact',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateAlertContactRequest
 * @return UpdateAlertContactResponse
 */
async function updateAlertContact(request: UpdateAlertContactRequest): UpdateAlertContactResponse {
  var runtime = new $RuntimeOptions{};
  return updateAlertContactWithOptions(request, runtime);
}

model UpdateAlertContactGroupRequest {
  contactGroupId?: long(name='ContactGroupId', description='This parameter is required.'),
  contactGroupName?: string(name='ContactGroupName', description='This parameter is required.'),
  contactIds?: string(name='ContactIds'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model UpdateAlertContactGroupResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateAlertContactGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAlertContactGroupResponseBody(name='body'),
}

/**
 * @param request UpdateAlertContactGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAlertContactGroupResponse
 */
@context("updateAlertContactGroupWithContext")
async function updateAlertContactGroupWithOptions(request: UpdateAlertContactGroupRequest, runtime: $RuntimeOptions): UpdateAlertContactGroupResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.contactGroupId)) {
    query['ContactGroupId'] = request.contactGroupId;
  }
  if (!$isNull(request.contactGroupName)) {
    query['ContactGroupName'] = request.contactGroupName;
  }
  if (!$isNull(request.contactIds)) {
    query['ContactIds'] = request.contactIds;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateAlertContactGroup',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateAlertContactGroupRequest
 * @return UpdateAlertContactGroupResponse
 */
async function updateAlertContactGroup(request: UpdateAlertContactGroupRequest): UpdateAlertContactGroupResponse {
  var runtime = new $RuntimeOptions{};
  return updateAlertContactGroupWithOptions(request, runtime);
}

model UpdateAlertRuleRequest {
  alertId?: long(name='AlertId', description='This parameter is required.'),
  contactGroupIds?: string(name='ContactGroupIds'),
  isAutoStart?: boolean(name='IsAutoStart'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  templageAlertConfig?: string(name='TemplageAlertConfig', description='This parameter is required.'),
}

model UpdateAlertRuleResponseBody = {
  alertId?: long(name='AlertId'),
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateAlertRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAlertRuleResponseBody(name='body'),
}

/**
 * @param request UpdateAlertRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAlertRuleResponse
 */
@context("updateAlertRuleWithContext")
async function updateAlertRuleWithOptions(request: UpdateAlertRuleRequest, runtime: $RuntimeOptions): UpdateAlertRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!$isNull(request.contactGroupIds)) {
    query['ContactGroupIds'] = request.contactGroupIds;
  }
  if (!$isNull(request.isAutoStart)) {
    query['IsAutoStart'] = request.isAutoStart;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.templageAlertConfig)) {
    query['TemplageAlertConfig'] = request.templageAlertConfig;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateAlertRule',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateAlertRuleRequest
 * @return UpdateAlertRuleResponse
 */
async function updateAlertRule(request: UpdateAlertRuleRequest): UpdateAlertRuleResponse {
  var runtime = new $RuntimeOptions{};
  return updateAlertRuleWithOptions(request, runtime);
}

model UpdateAlertTemplateRequest {
  annotations?: string(name='Annotations'),
  id?: long(name='Id', description='This parameter is required.'),
  labels?: string(name='Labels'),
  matchExpressions?: string(name='MatchExpressions'),
  message?: string(name='Message', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  rule?: string(name='Rule', description='This parameter is required.'),
  status?: boolean(name='Status', description='This parameter is required.'),
  type?: string(name='Type', description='This parameter is required.'),
}

model UpdateAlertTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateAlertTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAlertTemplateResponseBody(name='body'),
}

/**
 * @param request UpdateAlertTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAlertTemplateResponse
 */
@context("updateAlertTemplateWithContext")
async function updateAlertTemplateWithOptions(request: UpdateAlertTemplateRequest, runtime: $RuntimeOptions): UpdateAlertTemplateResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.annotations)) {
    query['Annotations'] = request.annotations;
  }
  if (!$isNull(request.id)) {
    query['Id'] = request.id;
  }
  if (!$isNull(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!$isNull(request.matchExpressions)) {
    query['MatchExpressions'] = request.matchExpressions;
  }
  if (!$isNull(request.message)) {
    query['Message'] = request.message;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.rule)) {
    query['Rule'] = request.rule;
  }
  if (!$isNull(request.status)) {
    query['Status'] = request.status;
  }
  if (!$isNull(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateAlertTemplate',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateAlertTemplateRequest
 * @return UpdateAlertTemplateResponse
 */
async function updateAlertTemplate(request: UpdateAlertTemplateRequest): UpdateAlertTemplateResponse {
  var runtime = new $RuntimeOptions{};
  return updateAlertTemplateWithOptions(request, runtime);
}

model UpdateDispatchRuleRequest {
  dispatchRule?: string(name='DispatchRule', description='This parameter is required.'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model UpdateDispatchRuleResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDispatchRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDispatchRuleResponseBody(name='body'),
}

/**
 * @param request UpdateDispatchRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDispatchRuleResponse
 */
@context("updateDispatchRuleWithContext")
async function updateDispatchRuleWithOptions(request: UpdateDispatchRuleRequest, runtime: $RuntimeOptions): UpdateDispatchRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.dispatchRule)) {
    query['DispatchRule'] = request.dispatchRule;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateDispatchRule',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateDispatchRuleRequest
 * @return UpdateDispatchRuleResponse
 */
async function updateDispatchRule(request: UpdateDispatchRuleRequest): UpdateDispatchRuleResponse {
  var runtime = new $RuntimeOptions{};
  return updateDispatchRuleWithOptions(request, runtime);
}

model UpdatePrometheusAlertRuleRequest {
  alertId?: long(name='AlertId', description='This parameter is required.'),
  alertName?: string(name='AlertName', description='This parameter is required.'),
  annotations?: string(name='Annotations'),
  clusterId?: string(name='ClusterId', description='This parameter is required.'),
  dispatchRuleId?: long(name='DispatchRuleId'),
  duration?: string(name='Duration', description='This parameter is required.'),
  expression?: string(name='Expression', description='This parameter is required.'),
  labels?: string(name='Labels'),
  message?: string(name='Message', description='This parameter is required.'),
  notifyType?: string(name='NotifyType'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  type?: string(name='Type'),
}

model UpdatePrometheusAlertRuleResponseBody = {
  prometheusAlertRule?: {
    alertId?: long(name='AlertId'),
    alertName?: string(name='AlertName'),
    annotations?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Annotations'),
    clusterId?: string(name='ClusterId'),
    dispatchRuleId?: long(name='DispatchRuleId'),
    duration?: string(name='Duration'),
    expression?: string(name='Expression'),
    labels?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Labels'),
    message?: string(name='Message'),
    notifyType?: string(name='NotifyType'),
    status?: int32(name='Status'),
    type?: string(name='Type'),
  }(name='PrometheusAlertRule'),
  requestId?: string(name='RequestId'),
}

model UpdatePrometheusAlertRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePrometheusAlertRuleResponseBody(name='body'),
}

/**
 * @param request UpdatePrometheusAlertRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePrometheusAlertRuleResponse
 */
@context("updatePrometheusAlertRuleWithContext")
async function updatePrometheusAlertRuleWithOptions(request: UpdatePrometheusAlertRuleRequest, runtime: $RuntimeOptions): UpdatePrometheusAlertRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.alertId)) {
    query['AlertId'] = request.alertId;
  }
  if (!$isNull(request.alertName)) {
    query['AlertName'] = request.alertName;
  }
  if (!$isNull(request.annotations)) {
    query['Annotations'] = request.annotations;
  }
  if (!$isNull(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.dispatchRuleId)) {
    query['DispatchRuleId'] = request.dispatchRuleId;
  }
  if (!$isNull(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!$isNull(request.expression)) {
    query['Expression'] = request.expression;
  }
  if (!$isNull(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!$isNull(request.message)) {
    query['Message'] = request.message;
  }
  if (!$isNull(request.notifyType)) {
    query['NotifyType'] = request.notifyType;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdatePrometheusAlertRule',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdatePrometheusAlertRuleRequest
 * @return UpdatePrometheusAlertRuleResponse
 */
async function updatePrometheusAlertRule(request: UpdatePrometheusAlertRuleRequest): UpdatePrometheusAlertRuleResponse {
  var runtime = new $RuntimeOptions{};
  return updatePrometheusAlertRuleWithOptions(request, runtime);
}

model UpdateWebhookRequest {
  body?: string(name='Body'),
  contactId?: long(name='ContactId', description='This parameter is required.'),
  contactName?: string(name='ContactName'),
  httpHeaders?: string(name='HttpHeaders'),
  httpParams?: string(name='HttpParams'),
  method?: string(name='Method'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  url?: string(name='Url'),
}

model UpdateWebhookResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateWebhookResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateWebhookResponseBody(name='body'),
}

/**
 * @param request UpdateWebhookRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateWebhookResponse
 */
@context("updateWebhookWithContext")
async function updateWebhookWithOptions(request: UpdateWebhookRequest, runtime: $RuntimeOptions): UpdateWebhookResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.body)) {
    query['Body'] = request.body;
  }
  if (!$isNull(request.contactId)) {
    query['ContactId'] = request.contactId;
  }
  if (!$isNull(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!$isNull(request.httpHeaders)) {
    query['HttpHeaders'] = request.httpHeaders;
  }
  if (!$isNull(request.httpParams)) {
    query['HttpParams'] = request.httpParams;
  }
  if (!$isNull(request.method)) {
    query['Method'] = request.method;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.url)) {
    query['Url'] = request.url;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateWebhook',
    version = '2021-04-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateWebhookRequest
 * @return UpdateWebhookResponse
 */
async function updateWebhook(request: UpdateWebhookRequest): UpdateWebhookResponse {
  var runtime = new $RuntimeOptions{};
  return updateWebhookWithOptions(request, runtime);
}

