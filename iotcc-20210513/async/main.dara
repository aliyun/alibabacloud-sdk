/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'IoTCC';
  @version = '2021-05-13';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AddCidrToConnectionPoolRequest {
  cidrs?: [ string ](name='Cidrs', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  connectionPoolId: string(name='ConnectionPoolId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model AddCidrToConnectionPoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddCidrToConnectionPoolResponse = {
  headers: map[string]string(name='headers'),
  body: AddCidrToConnectionPoolResponseBody(name='body'),
}

async function addCidrToConnectionPool(request: AddCidrToConnectionPoolRequest): AddCidrToConnectionPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddCidrToConnectionPool', 'POST', '/', 'json', false, 'json', request);
}

model AddIoTCloudConnectorToGroupRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorGroupId: string(name='IoTCloudConnectorGroupId', position='Query'),
  ioTCloudConnectorId: [ string ](name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model AddIoTCloudConnectorToGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddIoTCloudConnectorToGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AddIoTCloudConnectorToGroupResponseBody(name='body'),
}

async function addIoTCloudConnectorToGroup(request: AddIoTCloudConnectorToGroupRequest): AddIoTCloudConnectorToGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddIoTCloudConnectorToGroup', 'POST', '/', 'json', false, 'json', request);
}

model AssociateIpWithConnectionPoolRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  connectionPoolId: string(name='ConnectionPoolId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  ips?: [ string ](name='Ips', position='Query'),
  ipsFilePath?: string(name='IpsFilePath', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model AssociateIpWithConnectionPoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateIpWithConnectionPoolResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateIpWithConnectionPoolResponseBody(name='body'),
}

async function associateIpWithConnectionPool(request: AssociateIpWithConnectionPoolRequest): AssociateIpWithConnectionPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateIpWithConnectionPool', 'POST', '/', 'json', false, 'json', request);
}

model AssociateVSwitchWithIoTCloudConnectorRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  vSwitchList: [ string ](name='VSwitchList', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model AssociateVSwitchWithIoTCloudConnectorResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateVSwitchWithIoTCloudConnectorResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateVSwitchWithIoTCloudConnectorResponseBody(name='body'),
}

async function associateVSwitchWithIoTCloudConnector(request: AssociateVSwitchWithIoTCloudConnectorRequest): AssociateVSwitchWithIoTCloudConnectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateVSwitchWithIoTCloudConnector', 'POST', '/', 'json', false, 'json', request);
}

model ConfirmIoTCloudConnectorRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  confirmStatus: string(name='ConfirmStatus', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ConfirmIoTCloudConnectorResponseBody = {
  requestId?: string(name='RequestId'),
  resourceId?: string(name='ResourceId'),
}

model ConfirmIoTCloudConnectorResponse = {
  headers: map[string]string(name='headers'),
  body: ConfirmIoTCloudConnectorResponseBody(name='body'),
}

async function confirmIoTCloudConnector(request: ConfirmIoTCloudConnectorRequest): ConfirmIoTCloudConnectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfirmIoTCloudConnector', 'POST', '/', 'json', false, 'json', request);
}

model CreateAuthorizationRuleRequest {
  authorizationRuleDescription?: string(name='AuthorizationRuleDescription', position='Query'),
  authorizationRuleName?: string(name='AuthorizationRuleName', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  destination: string(name='Destination', position='Query'),
  destinationPort?: string(name='DestinationPort', position='Query'),
  destinationType: string(name='DestinationType', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  policy: string(name='Policy', position='Query'),
  protocol?: string(name='Protocol', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  sourceCidrs: [ string ](name='SourceCidrs', position='Query'),
}

model CreateAuthorizationRuleResponseBody = {
  authorizationRuleId?: string(name='AuthorizationRuleId'),
  requestId?: string(name='RequestId'),
}

model CreateAuthorizationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAuthorizationRuleResponseBody(name='body'),
}

async function createAuthorizationRule(request: CreateAuthorizationRuleRequest): CreateAuthorizationRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAuthorizationRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateAuthorizationRulesRequest {
  authorizationRules: [ 
    {
      description?: string(name='Description'),
      destination: string(name='Destination'),
      destinationPort?: string(name='DestinationPort'),
      destinationType: string(name='DestinationType'),
      name?: string(name='Name'),
      policy: string(name='Policy'),
      protocol?: string(name='Protocol'),
      sourceCidr: string(name='SourceCidr'),
    }
  ](name='AuthorizationRules', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CreateAuthorizationRulesResponseBody = {
  authorizationRuleIds?: [ string ](name='AuthorizationRuleIds'),
  requestId?: string(name='RequestId'),
}

model CreateAuthorizationRulesResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAuthorizationRulesResponseBody(name='body'),
}

async function createAuthorizationRules(request: CreateAuthorizationRulesRequest): CreateAuthorizationRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAuthorizationRules', 'POST', '/', 'json', false, 'json', request);
}

model CreateConnectionPoolRequest {
  cidrs?: [ string ](name='Cidrs', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  connectionPoolDescription?: string(name='ConnectionPoolDescription', position='Query'),
  connectionPoolName?: string(name='ConnectionPoolName', position='Query'),
  count?: long(name='Count', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model CreateConnectionPoolResponseBody = {
  connectionPoolId?: string(name='ConnectionPoolId'),
  requestId?: string(name='RequestId'),
}

model CreateConnectionPoolResponse = {
  headers: map[string]string(name='headers'),
  body: CreateConnectionPoolResponseBody(name='body'),
}

async function createConnectionPool(request: CreateConnectionPoolRequest): CreateConnectionPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateConnectionPool', 'POST', '/', 'json', false, 'json', request);
}

model CreateDNSServiceRuleRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DNSServiceRuleDescription?: string(name='DNSServiceRuleDescription', position='Query'),
  DNSServiceRuleName?: string(name='DNSServiceRuleName', position='Query'),
  destination?: string(name='Destination', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceType: string(name='ServiceType', position='Query'),
  source: string(name='Source', position='Query'),
}

model CreateDNSServiceRuleResponseBody = {
  DNSServiceRuleId?: string(name='DNSServiceRuleId'),
  requestId?: string(name='RequestId'),
}

model CreateDNSServiceRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDNSServiceRuleResponseBody(name='body'),
}

async function createDNSServiceRule(request: CreateDNSServiceRuleRequest): CreateDNSServiceRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDNSServiceRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateGroupAuthorizationRuleRequest {
  authorizationRuleDescription?: string(name='AuthorizationRuleDescription', position='Query'),
  authorizationRuleName?: string(name='AuthorizationRuleName', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  destination: string(name='Destination', position='Query'),
  destinationPort?: string(name='DestinationPort', position='Query'),
  destinationType: string(name='DestinationType', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorGroupId: string(name='IoTCloudConnectorGroupId', position='Query'),
  policy: string(name='Policy', position='Query'),
  protocol?: string(name='Protocol', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  sourceCidrs: [ string ](name='SourceCidrs', position='Query'),
  type?: string(name='Type', position='Query'),
}

model CreateGroupAuthorizationRuleResponseBody = {
  authorizationRuleId?: string(name='AuthorizationRuleId'),
  ioTCloudConnectorGroupId?: string(name='IoTCloudConnectorGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateGroupAuthorizationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGroupAuthorizationRuleResponseBody(name='body'),
}

async function createGroupAuthorizationRule(request: CreateGroupAuthorizationRuleRequest): CreateGroupAuthorizationRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGroupAuthorizationRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateGroupDNSServiceRuleRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DNSServiceRuleDescription?: string(name='DNSServiceRuleDescription', position='Query'),
  DNSServiceRuleName?: string(name='DNSServiceRuleName', position='Query'),
  destination?: string(name='Destination', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorGroupId: string(name='IoTCloudConnectorGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceType: string(name='ServiceType', position='Query'),
  source: string(name='Source', position='Query'),
}

model CreateGroupDNSServiceRuleResponseBody = {
  DNSServiceRuleId?: string(name='DNSServiceRuleId'),
  ioTCloudConnectorGroupId?: string(name='IoTCloudConnectorGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateGroupDNSServiceRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGroupDNSServiceRuleResponseBody(name='body'),
}

async function createGroupDNSServiceRule(request: CreateGroupDNSServiceRuleRequest): CreateGroupDNSServiceRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGroupDNSServiceRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateGroupIpMappingRuleRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  destinationIp: string(name='DestinationIp', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorGroupId: string(name='IoTCloudConnectorGroupId', position='Query'),
  ipMappingRuleDescription?: string(name='IpMappingRuleDescription', position='Query'),
  ipMappingRuleName?: string(name='IpMappingRuleName', position='Query'),
  mappingIp: string(name='MappingIp', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CreateGroupIpMappingRuleResponseBody = {
  groupIpMappingRuleId?: string(name='GroupIpMappingRuleId'),
  requestId?: string(name='RequestId'),
}

model CreateGroupIpMappingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGroupIpMappingRuleResponseBody(name='body'),
}

async function createGroupIpMappingRule(request: CreateGroupIpMappingRuleRequest): CreateGroupIpMappingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGroupIpMappingRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateIoTCloudConnectorRequest {
  APN?: string(name='APN', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ISP: string(name='ISP', position='Query'),
  ioTCloudConnectorDescription?: string(name='IoTCloudConnectorDescription', position='Query'),
  ioTCloudConnectorName?: string(name='IoTCloudConnectorName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceUid?: long(name='ResourceUid', position='Query'),
  type?: string(name='Type', position='Query'),
  wildcardDomainEnabled?: boolean(name='WildcardDomainEnabled', position='Query'),
}

model CreateIoTCloudConnectorResponseBody = {
  ioTCloudConnectorId?: string(name='IoTCloudConnectorId'),
  requestId?: string(name='RequestId'),
}

model CreateIoTCloudConnectorResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIoTCloudConnectorResponseBody(name='body'),
}

async function createIoTCloudConnector(request: CreateIoTCloudConnectorRequest): CreateIoTCloudConnectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateIoTCloudConnector', 'POST', '/', 'json', false, 'json', request);
}

model CreateIoTCloudConnectorBackhaulRouteRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CreateIoTCloudConnectorBackhaulRouteResponseBody = {
  ioTCloudConnectorId?: string(name='IoTCloudConnectorId'),
  requestId?: string(name='RequestId'),
}

model CreateIoTCloudConnectorBackhaulRouteResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIoTCloudConnectorBackhaulRouteResponseBody(name='body'),
}

async function createIoTCloudConnectorBackhaulRoute(request: CreateIoTCloudConnectorBackhaulRouteRequest): CreateIoTCloudConnectorBackhaulRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateIoTCloudConnectorBackhaulRoute', 'POST', '/', 'json', false, 'json', request);
}

model CreateIoTCloudConnectorGroupRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  name?: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type?: string(name='Type', position='Query'),
}

model CreateIoTCloudConnectorGroupResponseBody = {
  ioTCloudConnectorGroupId?: string(name='IoTCloudConnectorGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateIoTCloudConnectorGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIoTCloudConnectorGroupResponseBody(name='body'),
}

async function createIoTCloudConnectorGroup(request: CreateIoTCloudConnectorGroupRequest): CreateIoTCloudConnectorGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateIoTCloudConnectorGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateIpMappingRuleRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  destinationIp: string(name='DestinationIp', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  ipMappingRuleDescription?: string(name='IpMappingRuleDescription', position='Query'),
  ipMappingRuleName?: string(name='IpMappingRuleName', position='Query'),
  mappingIp: string(name='MappingIp', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CreateIpMappingRuleResponseBody = {
  ipMappingRuleId?: string(name='IpMappingRuleId'),
  requestId?: string(name='RequestId'),
}

model CreateIpMappingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIpMappingRuleResponseBody(name='body'),
}

async function createIpMappingRule(request: CreateIpMappingRuleRequest): CreateIpMappingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateIpMappingRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateServiceRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceDescription?: string(name='ServiceDescription', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
}

model CreateServiceResponseBody = {
  requestId?: string(name='RequestId'),
  serviceId?: string(name='ServiceId'),
}

model CreateServiceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServiceResponseBody(name='body'),
}

async function createService(request: CreateServiceRequest): CreateServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateService', 'POST', '/', 'json', false, 'json', request);
}

model CreateServiceEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceEntryDescription?: string(name='ServiceEntryDescription', position='Query'),
  serviceEntryName?: string(name='ServiceEntryName', position='Query'),
  serviceId: string(name='ServiceId', position='Query'),
  target: string(name='Target', position='Query'),
  targetType: string(name='TargetType', position='Query'),
}

model CreateServiceEntryResponseBody = {
  requestId?: string(name='RequestId'),
  serviceEntryId?: string(name='ServiceEntryId'),
}

model CreateServiceEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServiceEntryResponseBody(name='body'),
}

async function createServiceEntry(request: CreateServiceEntryRequest): CreateServiceEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateServiceEntry', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAuthorizationRuleRequest {
  authorizationRuleId: string(name='AuthorizationRuleId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteAuthorizationRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAuthorizationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAuthorizationRuleResponseBody(name='body'),
}

async function deleteAuthorizationRule(request: DeleteAuthorizationRuleRequest): DeleteAuthorizationRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAuthorizationRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteConnectionPoolRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  connectionPoolId: string(name='ConnectionPoolId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteConnectionPoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteConnectionPoolResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteConnectionPoolResponseBody(name='body'),
}

async function deleteConnectionPool(request: DeleteConnectionPoolRequest): DeleteConnectionPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteConnectionPool', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDNSServiceRuleRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DNSServiceRuleId: string(name='DNSServiceRuleId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteDNSServiceRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDNSServiceRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDNSServiceRuleResponseBody(name='body'),
}

async function deleteDNSServiceRule(request: DeleteDNSServiceRuleRequest): DeleteDNSServiceRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDNSServiceRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGroupAuthorizationRuleRequest {
  authorizationRuleId: string(name='AuthorizationRuleId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorGroupId: string(name='IoTCloudConnectorGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteGroupAuthorizationRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGroupAuthorizationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGroupAuthorizationRuleResponseBody(name='body'),
}

async function deleteGroupAuthorizationRule(request: DeleteGroupAuthorizationRuleRequest): DeleteGroupAuthorizationRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGroupAuthorizationRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGroupDNSServiceRuleRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DNSServiceRuleId: string(name='DNSServiceRuleId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorGroupId: string(name='IoTCloudConnectorGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteGroupDNSServiceRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGroupDNSServiceRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGroupDNSServiceRuleResponseBody(name='body'),
}

async function deleteGroupDNSServiceRule(request: DeleteGroupDNSServiceRuleRequest): DeleteGroupDNSServiceRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGroupDNSServiceRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGroupIpMappingRuleRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  groupIpMappingRuleId: string(name='GroupIpMappingRuleId', position='Query'),
  ioTCloudConnectorGroupId: string(name='IoTCloudConnectorGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteGroupIpMappingRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGroupIpMappingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGroupIpMappingRuleResponseBody(name='body'),
}

async function deleteGroupIpMappingRule(request: DeleteGroupIpMappingRuleRequest): DeleteGroupIpMappingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGroupIpMappingRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIoTCloudConnectorRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteIoTCloudConnectorResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIoTCloudConnectorResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIoTCloudConnectorResponseBody(name='body'),
}

async function deleteIoTCloudConnector(request: DeleteIoTCloudConnectorRequest): DeleteIoTCloudConnectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIoTCloudConnector', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIoTCloudConnectorGroupRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorGroupId: string(name='IoTCloudConnectorGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteIoTCloudConnectorGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIoTCloudConnectorGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIoTCloudConnectorGroupResponseBody(name='body'),
}

async function deleteIoTCloudConnectorGroup(request: DeleteIoTCloudConnectorGroupRequest): DeleteIoTCloudConnectorGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIoTCloudConnectorGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIoTCloudConnetorBackhaulRouteRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteIoTCloudConnetorBackhaulRouteResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIoTCloudConnetorBackhaulRouteResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIoTCloudConnetorBackhaulRouteResponseBody(name='body'),
}

async function deleteIoTCloudConnetorBackhaulRoute(request: DeleteIoTCloudConnetorBackhaulRouteRequest): DeleteIoTCloudConnetorBackhaulRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIoTCloudConnetorBackhaulRoute', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIpMappingRuleRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  ipMappingRuleId: string(name='IpMappingRuleId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteIpMappingRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpMappingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpMappingRuleResponseBody(name='body'),
}

async function deleteIpMappingRule(request: DeleteIpMappingRuleRequest): DeleteIpMappingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIpMappingRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteServiceRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceId: string(name='ServiceId', position='Query'),
}

model DeleteServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteServiceResponseBody(name='body'),
}

async function deleteService(request: DeleteServiceRequest): DeleteServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteService', 'POST', '/', 'json', false, 'json', request);
}

model DeleteServiceEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceEntryId: string(name='ServiceEntryId', position='Query'),
  serviceId: string(name='ServiceId', position='Query'),
}

model DeleteServiceEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteServiceEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteServiceEntryResponseBody(name='body'),
}

async function deleteServiceEntry(request: DeleteServiceEntryRequest): DeleteServiceEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteServiceEntry', 'POST', '/', 'json', false, 'json', request);
}

model DisableIoTCloudConnectorAccessLogRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DisableIoTCloudConnectorAccessLogResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableIoTCloudConnectorAccessLogResponse = {
  headers: map[string]string(name='headers'),
  body: DisableIoTCloudConnectorAccessLogResponseBody(name='body'),
}

async function disableIoTCloudConnectorAccessLog(request: DisableIoTCloudConnectorAccessLogRequest): DisableIoTCloudConnectorAccessLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableIoTCloudConnectorAccessLog', 'POST', '/', 'json', false, 'json', request);
}

model DissociateIpFromConnectionPoolRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  connectionPoolId: string(name='ConnectionPoolId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  ips?: [ string ](name='Ips', position='Query'),
  ipsFilePath?: string(name='IpsFilePath', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DissociateIpFromConnectionPoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model DissociateIpFromConnectionPoolResponse = {
  headers: map[string]string(name='headers'),
  body: DissociateIpFromConnectionPoolResponseBody(name='body'),
}

async function dissociateIpFromConnectionPool(request: DissociateIpFromConnectionPoolRequest): DissociateIpFromConnectionPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DissociateIpFromConnectionPool', 'POST', '/', 'json', false, 'json', request);
}

model DissociateVSwitchFromIoTCloudConnectorRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DissociateVSwitchFromIoTCloudConnectorResponseBody = {
  requestId?: string(name='RequestId'),
}

model DissociateVSwitchFromIoTCloudConnectorResponse = {
  headers: map[string]string(name='headers'),
  body: DissociateVSwitchFromIoTCloudConnectorResponseBody(name='body'),
}

async function dissociateVSwitchFromIoTCloudConnector(request: DissociateVSwitchFromIoTCloudConnectorRequest): DissociateVSwitchFromIoTCloudConnectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DissociateVSwitchFromIoTCloudConnector', 'POST', '/', 'json', false, 'json', request);
}

model EnableIoTCloudConnectorAccessLogRequest {
  accessLogSlsLogStore: string(name='AccessLogSlsLogStore', position='Query'),
  accessLogSlsProject: string(name='AccessLogSlsProject', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model EnableIoTCloudConnectorAccessLogResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableIoTCloudConnectorAccessLogResponse = {
  headers: map[string]string(name='headers'),
  body: EnableIoTCloudConnectorAccessLogResponseBody(name='body'),
}

async function enableIoTCloudConnectorAccessLog(request: EnableIoTCloudConnectorAccessLogRequest): EnableIoTCloudConnectorAccessLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableIoTCloudConnectorAccessLog', 'POST', '/', 'json', false, 'json', request);
}

model GetConnectionPoolIpOperationResultRequest {
  connectionPoolId: string(name='ConnectionPoolId', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  queryRequestId: string(name='QueryRequestId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetConnectionPoolIpOperationResultResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  resultFilePaths?: [ string ](name='ResultFilePaths', description='OssPath'),
}

model GetConnectionPoolIpOperationResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetConnectionPoolIpOperationResultResponseBody(name='body'),
}

async function getConnectionPoolIpOperationResult(request: GetConnectionPoolIpOperationResultRequest): GetConnectionPoolIpOperationResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetConnectionPoolIpOperationResult', 'POST', '/', 'json', false, 'json', request);
}

model GetDiagnoseResultForSingleCardRequest {
  diagnoseTaskId: string(name='DiagnoseTaskId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model GetDiagnoseResultForSingleCardResponseBody = {
  beginTime?: long(name='BeginTime'),
  cardIp?: string(name='CardIp'),
  destination?: string(name='Destination'),
  diagnoseItem?: [ 
    {
      part?: string(name='Part'),
      status?: string(name='Status'),
    }
  ](name='DiagnoseItem'),
  endTime?: long(name='EndTime'),
  errorResult?: [ 
    {
      errorDesc?: string(name='ErrorDesc'),
      errorLevel?: string(name='ErrorLevel'),
      errorPart?: string(name='ErrorPart'),
      errorSuggestion?: string(name='ErrorSuggestion'),
    }
  ](name='ErrorResult'),
  iccId?: string(name='IccId'),
  ioTCloudConnectorId?: string(name='IoTCloudConnectorId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model GetDiagnoseResultForSingleCardResponse = {
  headers: map[string]string(name='headers'),
  body: GetDiagnoseResultForSingleCardResponseBody(name='body'),
}

async function getDiagnoseResultForSingleCard(request: GetDiagnoseResultForSingleCardRequest): GetDiagnoseResultForSingleCardResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDiagnoseResultForSingleCard', 'POST', '/', 'json', false, 'json', request);
}

model GetIoTCloudConnectorAccessLogRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetIoTCloudConnectorAccessLogResponseBody = {
  accessLogSlsLogStore?: string(name='AccessLogSlsLogStore'),
  accessLogSlsProject?: string(name='AccessLogSlsProject'),
  accessLogStatus?: string(name='AccessLogStatus'),
  requestId?: string(name='RequestId'),
}

model GetIoTCloudConnectorAccessLogResponse = {
  headers: map[string]string(name='headers'),
  body: GetIoTCloudConnectorAccessLogResponseBody(name='body'),
}

async function getIoTCloudConnectorAccessLog(request: GetIoTCloudConnectorAccessLogRequest): GetIoTCloudConnectorAccessLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetIoTCloudConnectorAccessLog', 'POST', '/', 'json', false, 'json', request);
}

model GetStsInfoAndOssPathRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  connectionPoolId: string(name='ConnectionPoolId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fileName?: string(name='FileName', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetStsInfoAndOssPathResponseBody = {
  accessKeyId?: string(name='AccessKeyId', description='Sts info of accessKeyId'),
  accessKeySecret?: string(name='AccessKeySecret', description='Sts info of accessKeySecret'),
  expiration?: string(name='Expiration', description='Sts info expiration time'),
  ossPath?: string(name='OssPath', description='OssPath'),
  requestId?: string(name='RequestId', description='Id of the request'),
  securityToken?: string(name='SecurityToken', description='Sts info of securityToken'),
}

model GetStsInfoAndOssPathResponse = {
  headers: map[string]string(name='headers'),
  body: GetStsInfoAndOssPathResponseBody(name='body'),
}

async function getStsInfoAndOssPath(request: GetStsInfoAndOssPathRequest): GetStsInfoAndOssPathResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetStsInfoAndOssPath', 'POST', '/', 'json', false, 'json', request);
}

model GrantVirtualBorderRouterRequest {
  regionId?: string(name='RegionId', position='Query'),
  virtualBorderRouterId?: string(name='VirtualBorderRouterId', position='Query'),
}

model GrantVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GrantVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: GrantVirtualBorderRouterResponseBody(name='body'),
}

async function grantVirtualBorderRouter(request: GrantVirtualBorderRouterRequest): GrantVirtualBorderRouterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GrantVirtualBorderRouter', 'POST', '/', 'json', false, 'json', request);
}

model ListAPNsRequest {
  APN?: string(name='APN', position='Query'),
  ISP?: string(name='ISP', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type?: string(name='Type', position='Query'),
}

model ListAPNsResponseBody = {
  APNs?: [ 
    {
      APN?: string(name='APN'),
      description?: string(name='Description'),
      featureList?: [ string ](name='FeatureList'),
      ISP?: string(name='ISP'),
      name?: string(name='Name'),
      zoneList?: [ string ](name='ZoneList'),
    }
  ](name='APNs'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAPNsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAPNsResponseBody(name='body'),
}

async function listAPNs(request: ListAPNsRequest): ListAPNsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAPNs', 'POST', '/', 'json', false, 'json', request);
}

model ListAuthorizationRulesRequest {
  authorizationRuleIds?: [ string ](name='AuthorizationRuleIds', position='Query'),
  authorizationRuleName?: [ string ](name='AuthorizationRuleName', position='Query'),
  authorizationRuleStatus?: [ string ](name='AuthorizationRuleStatus', position='Query'),
  authorizationRuleType?: string(name='AuthorizationRuleType', position='Query'),
  destination?: [ string ](name='Destination', position='Query'),
  destinationPort?: [ string ](name='DestinationPort', position='Query'),
  destinationType?: [ string ](name='DestinationType', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  policy?: [ string ](name='Policy', position='Query'),
  protocol?: [ string ](name='Protocol', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListAuthorizationRulesResponseBody = {
  authorizationRules?: [ 
    {
      authorizationRuleDescription?: string(name='AuthorizationRuleDescription'),
      authorizationRuleId?: string(name='AuthorizationRuleId'),
      authorizationRuleName?: string(name='AuthorizationRuleName'),
      authorizationRuleStatus?: string(name='AuthorizationRuleStatus'),
      authorizationRuleType?: string(name='AuthorizationRuleType'),
      destination?: string(name='Destination'),
      destinationPort?: string(name='DestinationPort'),
      destinationType?: string(name='DestinationType'),
      ioTCloudConnectorId?: string(name='IoTCloudConnectorId'),
      policy?: string(name='Policy'),
      protocol?: string(name='Protocol'),
      sourceCidrs?: [ string ](name='SourceCidrs'),
    }
  ](name='AuthorizationRules'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAuthorizationRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAuthorizationRulesResponseBody(name='body'),
}

async function listAuthorizationRules(request: ListAuthorizationRulesRequest): ListAuthorizationRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAuthorizationRules', 'POST', '/', 'json', false, 'json', request);
}

model ListConnectionPoolAllIpsRequest {
  connectionPoolId: string(name='ConnectionPoolId', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  ip?: string(name='Ip', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=2000, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type?: string(name='Type', position='Query'),
}

model ListConnectionPoolAllIpsResponseBody = {
  connectionPoolIps?: [ 
    {
      connectionPoolId?: string(name='ConnectionPoolId'),
      ip?: string(name='Ip'),
      ipNum?: long(name='IpNum'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='ConnectionPoolIps'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalIpsCount?: int32(name='TotalIpsCount'),
}

model ListConnectionPoolAllIpsResponse = {
  headers: map[string]string(name='headers'),
  body: ListConnectionPoolAllIpsResponseBody(name='body'),
}

async function listConnectionPoolAllIps(request: ListConnectionPoolAllIpsRequest): ListConnectionPoolAllIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListConnectionPoolAllIps', 'POST', '/', 'json', false, 'json', request);
}

model ListConnectionPoolIpsRequest {
  connectionPoolId?: string(name='ConnectionPoolId', position='Query'),
  ioTCloudConnectorId?: string(name='IoTCloudConnectorId', position='Query'),
  ip?: string(name='Ip', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=2000, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListConnectionPoolIpsResponseBody = {
  connectionPoolIps?: [ 
    {
      connectionPoolId?: string(name='ConnectionPoolId'),
      ip?: string(name='Ip'),
      status?: string(name='Status'),
    }
  ](name='ConnectionPoolIps'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListConnectionPoolIpsResponse = {
  headers: map[string]string(name='headers'),
  body: ListConnectionPoolIpsResponseBody(name='body'),
}

async function listConnectionPoolIps(request: ListConnectionPoolIpsRequest): ListConnectionPoolIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListConnectionPoolIps', 'POST', '/', 'json', false, 'json', request);
}

model ListConnectionPoolsRequest {
  connectionPoolIds?: [ string ](name='ConnectionPoolIds', position='Query'),
  connectionPoolName?: [ string ](name='ConnectionPoolName', position='Query'),
  connectionPoolStatus?: [ string ](name='ConnectionPoolStatus', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListConnectionPoolsResponseBody = {
  connectionPools?: [ 
    {
      cidrs?: [ string ](name='Cidrs'),
      connectionPoolDescription?: string(name='ConnectionPoolDescription'),
      connectionPoolId?: string(name='ConnectionPoolId'),
      connectionPoolName?: string(name='ConnectionPoolName'),
      connectionPoolStatus?: string(name='ConnectionPoolStatus'),
      operateResultRequestID?: string(name='OperateResultRequestID'),
    }
  ](name='ConnectionPools'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListConnectionPoolsResponse = {
  headers: map[string]string(name='headers'),
  body: ListConnectionPoolsResponseBody(name='body'),
}

async function listConnectionPools(request: ListConnectionPoolsRequest): ListConnectionPoolsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListConnectionPools', 'POST', '/', 'json', false, 'json', request);
}

model ListDNSServiceRulesRequest {
  DNSServiceRuleIds?: [ string ](name='DNSServiceRuleIds', position='Query'),
  DNSServiceRuleName?: [ string ](name='DNSServiceRuleName', position='Query'),
  DNSServiceRuleStatus?: [ string ](name='DNSServiceRuleStatus', position='Query'),
  destination?: [ string ](name='Destination', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceType?: string(name='ServiceType', position='Query'),
  source?: [ string ](name='Source', position='Query'),
}

model ListDNSServiceRulesResponseBody = {
  DNSServiceRules?: [ 
    {
      DNSServiceRuleDescription?: string(name='DNSServiceRuleDescription'),
      DNSServiceRuleId?: string(name='DNSServiceRuleId'),
      DNSServiceRuleName?: string(name='DNSServiceRuleName'),
      DNSServiceRuleStatus?: string(name='DNSServiceRuleStatus'),
      destination?: string(name='Destination'),
      ioTCloudConnectorId?: string(name='IoTCloudConnectorId'),
      serviceType?: string(name='ServiceType'),
      source?: string(name='Source'),
    }
  ](name='DNSServiceRules'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListDNSServiceRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDNSServiceRulesResponseBody(name='body'),
}

async function listDNSServiceRules(request: ListDNSServiceRulesRequest): ListDNSServiceRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDNSServiceRules', 'POST', '/', 'json', false, 'json', request);
}

model ListDiagnoseInfoForSingleCardRequest {
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  source?: string(name='Source', position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
}

model ListDiagnoseInfoForSingleCardResponseBody = {
  diagnoseInfo?: [ 
    {
      beginTime?: long(name='BeginTime'),
      cardIp?: string(name='CardIp'),
      destination?: string(name='Destination'),
      destinationType?: string(name='DestinationType'),
      diagnoseTime?: long(name='DiagnoseTime'),
      endTime?: long(name='EndTime'),
      iccId?: string(name='IccId'),
      ioTCloudConnectorId?: string(name='IoTCloudConnectorId'),
      source?: string(name='Source'),
      sourceType?: string(name='SourceType'),
      status?: string(name='Status'),
      taskId?: string(name='TaskId'),
    }
  ](name='DiagnoseInfo'),
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListDiagnoseInfoForSingleCardResponse = {
  headers: map[string]string(name='headers'),
  body: ListDiagnoseInfoForSingleCardResponseBody(name='body'),
}

async function listDiagnoseInfoForSingleCard(request: ListDiagnoseInfoForSingleCardRequest): ListDiagnoseInfoForSingleCardResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDiagnoseInfoForSingleCard', 'POST', '/', 'json', false, 'json', request);
}

model ListGroupAuthorizationRulesRequest {
  authorizationRuleIds?: [ string ](name='AuthorizationRuleIds', position='Query'),
  authorizationRuleName?: [ string ](name='AuthorizationRuleName', position='Query'),
  authorizationRuleStatus?: [ string ](name='AuthorizationRuleStatus', position='Query'),
  destination?: [ string ](name='Destination', position='Query'),
  destinationPort?: [ string ](name='DestinationPort', position='Query'),
  destinationType?: [ string ](name='DestinationType', position='Query'),
  ioTCloudConnectorGroupId: string(name='IoTCloudConnectorGroupId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  policy?: [ string ](name='Policy', position='Query'),
  protocol?: [ string ](name='Protocol', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type?: string(name='Type', position='Query'),
}

model ListGroupAuthorizationRulesResponseBody = {
  groupAuthorizationRules?: [ 
    {
      authorizationRuleDescription?: string(name='AuthorizationRuleDescription'),
      authorizationRuleId?: string(name='AuthorizationRuleId'),
      authorizationRuleName?: string(name='AuthorizationRuleName'),
      authorizationRuleStatus?: string(name='AuthorizationRuleStatus'),
      destination?: string(name='Destination'),
      destinationPort?: string(name='DestinationPort'),
      destinationType?: string(name='DestinationType'),
      ioTCloudConnectorGroupId?: string(name='IoTCloudConnectorGroupId'),
      policy?: string(name='Policy'),
      protocol?: string(name='Protocol'),
      sourceCidrs?: [ string ](name='SourceCidrs'),
      type?: string(name='Type'),
    }
  ](name='GroupAuthorizationRules'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListGroupAuthorizationRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupAuthorizationRulesResponseBody(name='body'),
}

async function listGroupAuthorizationRules(request: ListGroupAuthorizationRulesRequest): ListGroupAuthorizationRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListGroupAuthorizationRules', 'POST', '/', 'json', false, 'json', request);
}

model ListGroupDNSServiceRulesRequest {
  DNSServiceRuleIds?: [ string ](name='DNSServiceRuleIds', position='Query'),
  DNSServiceRuleName?: [ string ](name='DNSServiceRuleName', position='Query'),
  DNSServiceRuleStatus?: [ string ](name='DNSServiceRuleStatus', position='Query'),
  destination?: [ string ](name='Destination', position='Query'),
  ioTCloudConnectorGroupId: string(name='IoTCloudConnectorGroupId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceType?: string(name='ServiceType', position='Query'),
  source?: [ string ](name='Source', position='Query'),
}

model ListGroupDNSServiceRulesResponseBody = {
  DNSServiceRules?: [ 
    {
      DNSServiceRuleDescription?: string(name='DNSServiceRuleDescription'),
      DNSServiceRuleId?: string(name='DNSServiceRuleId'),
      DNSServiceRuleName?: string(name='DNSServiceRuleName'),
      DNSServiceRuleStatus?: string(name='DNSServiceRuleStatus'),
      destination?: string(name='Destination'),
      ioTCloudConnectorGroupId?: string(name='IoTCloudConnectorGroupId'),
      serviceType?: string(name='ServiceType'),
      source?: string(name='Source'),
    }
  ](name='DNSServiceRules'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListGroupDNSServiceRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupDNSServiceRulesResponseBody(name='body'),
}

async function listGroupDNSServiceRules(request: ListGroupDNSServiceRulesRequest): ListGroupDNSServiceRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListGroupDNSServiceRules', 'POST', '/', 'json', false, 'json', request);
}

model ListGroupIpMappingRulesRequest {
  destinationIps?: [ string ](name='DestinationIps', position='Query'),
  ioTCloudConnectorGroupId: string(name='IoTCloudConnectorGroupId', position='Query'),
  ipMappingRuleIds?: [ string ](name='IpMappingRuleIds', position='Query'),
  ipMappingRuleNames?: [ string ](name='IpMappingRuleNames', position='Query'),
  ipMappingRuleStatuses?: [ string ](name='IpMappingRuleStatuses', position='Query'),
  mappingIps?: [ string ](name='MappingIps', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListGroupIpMappingRulesResponseBody = {
  ipMappingRules?: [ 
    {
      destinationIp?: string(name='DestinationIp'),
      ioTCloudConnectorGroupId?: string(name='IoTCloudConnectorGroupId'),
      ipMappingRuleDescription?: string(name='IpMappingRuleDescription'),
      ipMappingRuleId?: string(name='IpMappingRuleId'),
      ipMappingRuleName?: string(name='IpMappingRuleName'),
      ipMappingRuleStatus?: string(name='IpMappingRuleStatus'),
      mappingIp?: string(name='MappingIp'),
    }
  ](name='IpMappingRules'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListGroupIpMappingRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupIpMappingRulesResponseBody(name='body'),
}

async function listGroupIpMappingRules(request: ListGroupIpMappingRulesRequest): ListGroupIpMappingRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListGroupIpMappingRules', 'POST', '/', 'json', false, 'json', request);
}

model ListIoTCloudConnectorAccessSessionLogsRequest {
  destinations?: [ string ](name='Destinations', position='Query'),
  endTime: long(name='EndTime', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  sourceIps?: [ string ](name='SourceIps', position='Query'),
  startTime: long(name='StartTime', position='Query'),
}

model ListIoTCloudConnectorAccessSessionLogsResponseBody = {
  accessSessionLogs?: [ 
    {
      clientToServiceFlow?: string(name='ClientToServiceFlow'),
      destinationIp?: string(name='DestinationIp'),
      destinationPort?: string(name='DestinationPort'),
      destinations?: [ string ](name='Destinations'),
      serviceToClientFlow?: string(name='ServiceToClientFlow'),
      sourceIp?: string(name='SourceIp'),
      time?: string(name='Time'),
      type?: string(name='Type'),
    }
  ](name='AccessSessionLogs'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListIoTCloudConnectorAccessSessionLogsResponse = {
  headers: map[string]string(name='headers'),
  body: ListIoTCloudConnectorAccessSessionLogsResponseBody(name='body'),
}

async function listIoTCloudConnectorAccessSessionLogs(request: ListIoTCloudConnectorAccessSessionLogsRequest): ListIoTCloudConnectorAccessSessionLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListIoTCloudConnectorAccessSessionLogs', 'POST', '/', 'json', false, 'json', request);
}

model ListIoTCloudConnectorAvailableZonesRequest {
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListIoTCloudConnectorAvailableZonesResponseBody = {
  availableZoneList?: [ string ](name='AvailableZoneList'),
  ioTCloudConnectorId?: string(name='IoTCloudConnectorId'),
  requestId?: string(name='RequestId'),
}

model ListIoTCloudConnectorAvailableZonesResponse = {
  headers: map[string]string(name='headers'),
  body: ListIoTCloudConnectorAvailableZonesResponseBody(name='body'),
}

async function listIoTCloudConnectorAvailableZones(request: ListIoTCloudConnectorAvailableZonesRequest): ListIoTCloudConnectorAvailableZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListIoTCloudConnectorAvailableZones', 'POST', '/', 'json', false, 'json', request);
}

model ListIoTCloudConnectorEIPsRequest {
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListIoTCloudConnectorEIPsResponseBody = {
  EIPs?: [ string ](name='EIPs'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListIoTCloudConnectorEIPsResponse = {
  headers: map[string]string(name='headers'),
  body: ListIoTCloudConnectorEIPsResponseBody(name='body'),
}

async function listIoTCloudConnectorEIPs(request: ListIoTCloudConnectorEIPsRequest): ListIoTCloudConnectorEIPsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListIoTCloudConnectorEIPs', 'POST', '/', 'json', false, 'json', request);
}

model ListIoTCloudConnectorGroupsRequest {
  ioTCloudConnectorGroupIds?: [ string ](name='IoTCloudConnectorGroupIds', position='Query'),
  ioTCloudConnectorGroupName?: [ string ](name='IoTCloudConnectorGroupName', position='Query'),
  ioTCloudConnectorGroupStatus?: [ string ](name='IoTCloudConnectorGroupStatus', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type?: string(name='Type', position='Query'),
}

model ListIoTCloudConnectorGroupsResponseBody = {
  ioTCloudConnectorGroups?: [ 
    {
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      ioTCloudConnectorGroupId?: string(name='IoTCloudConnectorGroupId'),
      ioTCloudConnectorGroupStatus?: string(name='IoTCloudConnectorGroupStatus'),
      ioTCloudConnectors?: [ 
        {
          APN?: string(name='APN'),
          createTime?: long(name='CreateTime'),
          ISP?: string(name='ISP'),
          ioTCloudConnectorDescription?: string(name='IoTCloudConnectorDescription'),
          ioTCloudConnectorId?: string(name='IoTCloudConnectorId'),
          ioTCloudConnectorName?: string(name='IoTCloudConnectorName'),
          ioTCloudConnectorStatus?: string(name='IoTCloudConnectorStatus'),
          serviceType?: string(name='ServiceType'),
        }
      ](name='IoTCloudConnectors'),
      name?: string(name='Name'),
      serviceType?: string(name='ServiceType'),
      type?: string(name='Type'),
    }
  ](name='IoTCloudConnectorGroups'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListIoTCloudConnectorGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListIoTCloudConnectorGroupsResponseBody(name='body'),
}

async function listIoTCloudConnectorGroups(request: ListIoTCloudConnectorGroupsRequest): ListIoTCloudConnectorGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListIoTCloudConnectorGroups', 'POST', '/', 'json', false, 'json', request);
}

model ListIoTCloudConnectorsRequest {
  APN?: [ string ](name='APN', position='Query'),
  ISP?: [ string ](name='ISP', position='Query'),
  ioTCloudConnectorGroupId?: string(name='IoTCloudConnectorGroupId', position='Query'),
  ioTCloudConnectorIds?: [ string ](name='IoTCloudConnectorIds', position='Query'),
  ioTCloudConnectorName?: [ string ](name='IoTCloudConnectorName', position='Query'),
  ioTCloudConnectorStatus?: [ string ](name='IoTCloudConnectorStatus', position='Query'),
  isInGroup?: boolean(name='IsInGroup', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  vpcId?: [ string ](name='VpcId', position='Query'),
}

model ListIoTCloudConnectorsResponseBody = {
  ioTCloudConnectors?: [ 
    {
      APN?: string(name='APN'),
      createTime?: long(name='CreateTime'),
      grantAliUid?: string(name='GrantAliUid'),
      ISP?: string(name='ISP'),
      ioTCloudConnectorBusinessStatus?: string(name='IoTCloudConnectorBusinessStatus'),
      ioTCloudConnectorDescription?: string(name='IoTCloudConnectorDescription'),
      ioTCloudConnectorGroupId?: string(name='IoTCloudConnectorGroupId'),
      ioTCloudConnectorId?: string(name='IoTCloudConnectorId'),
      ioTCloudConnectorName?: string(name='IoTCloudConnectorName'),
      ioTCloudConnectorStatus?: string(name='IoTCloudConnectorStatus'),
      ipFeature?: string(name='IpFeature'),
      mode?: string(name='Mode'),
      modifyTime?: long(name='ModifyTime'),
      rateLimit?: long(name='RateLimit'),
      serviceType?: string(name='ServiceType'),
      type?: string(name='Type'),
      vSwitchList?: [ string ](name='VSwitchList'),
      vpcId?: string(name='VpcId'),
      wildcardDomainEnabled?: boolean(name='WildcardDomainEnabled'),
    }
  ](name='IoTCloudConnectors'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListIoTCloudConnectorsResponse = {
  headers: map[string]string(name='headers'),
  body: ListIoTCloudConnectorsResponseBody(name='body'),
}

async function listIoTCloudConnectors(request: ListIoTCloudConnectorsRequest): ListIoTCloudConnectorsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListIoTCloudConnectors', 'POST', '/', 'json', false, 'json', request);
}

model ListIoTCoudConnectorBackhaulRouteRequest {
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListIoTCoudConnectorBackhaulRouteResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  routes?: [ 
    {
      description?: string(name='Description'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      nextHopId?: string(name='NextHopId'),
      nextHopType?: string(name='NextHopType'),
      status?: string(name='Status'),
    }
  ](name='Routes'),
  totalCount?: int32(name='TotalCount'),
}

model ListIoTCoudConnectorBackhaulRouteResponse = {
  headers: map[string]string(name='headers'),
  body: ListIoTCoudConnectorBackhaulRouteResponseBody(name='body'),
}

async function listIoTCoudConnectorBackhaulRoute(request: ListIoTCoudConnectorBackhaulRouteRequest): ListIoTCoudConnectorBackhaulRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListIoTCoudConnectorBackhaulRoute', 'POST', '/', 'json', false, 'json', request);
}

model ListIpMappingRulesRequest {
  destinationIps?: [ string ](name='DestinationIps', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  ipMappingRuleIds?: [ string ](name='IpMappingRuleIds', position='Query'),
  ipMappingRuleNames?: [ string ](name='IpMappingRuleNames', position='Query'),
  ipMappingRuleStatuses?: [ string ](name='IpMappingRuleStatuses', position='Query'),
  mappingIps?: [ string ](name='MappingIps', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListIpMappingRulesResponseBody = {
  ipMappingRules?: [ 
    {
      destinationIp?: string(name='DestinationIp'),
      ioTCloudConnectorId?: string(name='IoTCloudConnectorId'),
      ipMappingRuleDescription?: string(name='IpMappingRuleDescription'),
      ipMappingRuleId?: string(name='IpMappingRuleId'),
      ipMappingRuleName?: string(name='IpMappingRuleName'),
      ipMappingRuleStatus?: string(name='IpMappingRuleStatus'),
      mappingIp?: string(name='MappingIp'),
    }
  ](name='IpMappingRules'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListIpMappingRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListIpMappingRulesResponseBody(name='body'),
}

async function listIpMappingRules(request: ListIpMappingRulesRequest): ListIpMappingRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListIpMappingRules', 'POST', '/', 'json', false, 'json', request);
}

model ListRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model ListRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRegionsResponseBody(name='body'),
}

async function listRegions(request: ListRegionsRequest): ListRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListRegions', 'POST', '/', 'json', false, 'json', request);
}

model ListServiceRequest {
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceStatuses?: [ string ](name='ResourceStatuses', position='Query'),
  serviceIds?: [ string ](name='ServiceIds', position='Query'),
  serviceNames?: [ string ](name='ServiceNames', position='Query'),
}

model ListServiceResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  services?: [ 
    {
      ioTCloudConnectorId?: string(name='IoTCloudConnectorId'),
      serviceDescription?: string(name='ServiceDescription'),
      serviceId?: string(name='ServiceId'),
      serviceName?: string(name='ServiceName'),
      serviceStatus?: string(name='ServiceStatus'),
    }
  ](name='Services'),
  totalCount?: int32(name='TotalCount'),
}

model ListServiceResponse = {
  headers: map[string]string(name='headers'),
  body: ListServiceResponseBody(name='body'),
}

async function listService(request: ListServiceRequest): ListServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListService', 'POST', '/', 'json', false, 'json', request);
}

model ListServiceEntriesRequest {
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceEntryIds?: [ string ](name='ServiceEntryIds', position='Query'),
  serviceEntryName?: [ string ](name='ServiceEntryName', position='Query'),
  serviceEntryStatus?: [ string ](name='ServiceEntryStatus', position='Query'),
  serviceId: string(name='ServiceId', position='Query'),
  target?: [ string ](name='Target', position='Query'),
  targetType?: [ string ](name='TargetType', position='Query'),
}

model ListServiceEntriesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  serviceEntries?: [ 
    {
      serviceEntryDescription?: string(name='ServiceEntryDescription'),
      serviceEntryId?: string(name='ServiceEntryId'),
      serviceEntryName?: string(name='ServiceEntryName'),
      serviceEntryStatus?: string(name='ServiceEntryStatus'),
      serviceId?: string(name='ServiceId'),
      target?: string(name='Target'),
      targetType?: string(name='TargetType'),
    }
  ](name='ServiceEntries'),
  totalCount?: int32(name='TotalCount'),
}

model ListServiceEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListServiceEntriesResponseBody(name='body'),
}

async function listServiceEntries(request: ListServiceEntriesRequest): ListServiceEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListServiceEntries', 'POST', '/', 'json', false, 'json', request);
}

model MoveAuthorizationRuleToDNSServiceRequest {
  authorizationRuleId: string(name='AuthorizationRuleId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model MoveAuthorizationRuleToDNSServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model MoveAuthorizationRuleToDNSServiceResponse = {
  headers: map[string]string(name='headers'),
  body: MoveAuthorizationRuleToDNSServiceResponseBody(name='body'),
}

async function moveAuthorizationRuleToDNSService(request: MoveAuthorizationRuleToDNSServiceRequest): MoveAuthorizationRuleToDNSServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MoveAuthorizationRuleToDNSService', 'POST', '/', 'json', false, 'json', request);
}

model MoveGroupAuthorizationRuleToDNSServiceRequest {
  authorizationRuleId: string(name='AuthorizationRuleId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorGroupId: string(name='IoTCloudConnectorGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model MoveGroupAuthorizationRuleToDNSServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model MoveGroupAuthorizationRuleToDNSServiceResponse = {
  headers: map[string]string(name='headers'),
  body: MoveGroupAuthorizationRuleToDNSServiceResponseBody(name='body'),
}

async function moveGroupAuthorizationRuleToDNSService(request: MoveGroupAuthorizationRuleToDNSServiceRequest): MoveGroupAuthorizationRuleToDNSServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MoveGroupAuthorizationRuleToDNSService', 'POST', '/', 'json', false, 'json', request);
}

model OpenIoTCloudConnectorServiceRequest {
  regionId: string(name='RegionId', position='Query'),
}

model OpenIoTCloudConnectorServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model OpenIoTCloudConnectorServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenIoTCloudConnectorServiceResponseBody(name='body'),
}

async function openIoTCloudConnectorService(request: OpenIoTCloudConnectorServiceRequest): OpenIoTCloudConnectorServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenIoTCloudConnectorService', 'POST', '/', 'json', false, 'json', request);
}

model RemoveIoTCloudConnectorFromGroupRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorGroupId: string(name='IoTCloudConnectorGroupId', position='Query'),
  ioTCloudConnectorId: [ string ](name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RemoveIoTCloudConnectorFromGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveIoTCloudConnectorFromGroupResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveIoTCloudConnectorFromGroupResponseBody(name='body'),
}

async function removeIoTCloudConnectorFromGroup(request: RemoveIoTCloudConnectorFromGroupRequest): RemoveIoTCloudConnectorFromGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveIoTCloudConnectorFromGroup', 'POST', '/', 'json', false, 'json', request);
}

model RevertIoTCloudConnectorRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RevertIoTCloudConnectorResponseBody = {
  requestId?: string(name='RequestId'),
  resourceId?: string(name='ResourceId'),
}

model RevertIoTCloudConnectorResponse = {
  headers: map[string]string(name='headers'),
  body: RevertIoTCloudConnectorResponseBody(name='body'),
}

async function revertIoTCloudConnector(request: RevertIoTCloudConnectorRequest): RevertIoTCloudConnectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevertIoTCloudConnector', 'POST', '/', 'json', false, 'json', request);
}

model SubmitDiagnoseTaskForSingleCardRequest {
  beginTime: long(name='BeginTime', position='Query'),
  destination?: string(name='Destination', position='Query'),
  destinationType?: string(name='DestinationType', position='Query'),
  endTime: long(name='EndTime', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceUid?: long(name='ResourceUid', position='Query'),
  source: string(name='Source', position='Query'),
  sourceType: string(name='SourceType', position='Query'),
}

model SubmitDiagnoseTaskForSingleCardResponseBody = {
  diagnoseTaskId?: string(name='DiagnoseTaskId'),
  requestId?: string(name='RequestId'),
}

model SubmitDiagnoseTaskForSingleCardResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitDiagnoseTaskForSingleCardResponseBody(name='body'),
}

async function submitDiagnoseTaskForSingleCard(request: SubmitDiagnoseTaskForSingleCardRequest): SubmitDiagnoseTaskForSingleCardResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitDiagnoseTaskForSingleCard', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAuthorizationRuleAttributeRequest {
  authorizationRuleDescription?: string(name='AuthorizationRuleDescription', position='Query'),
  authorizationRuleId: string(name='AuthorizationRuleId', position='Query'),
  authorizationRuleName?: string(name='AuthorizationRuleName', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  destination?: string(name='Destination', position='Query'),
  destinationPort?: string(name='DestinationPort', position='Query'),
  destinationType?: string(name='DestinationType', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  policy?: string(name='Policy', position='Query'),
  protocol?: string(name='Protocol', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  sourceCidrs?: [ string ](name='SourceCidrs', position='Query'),
}

model UpdateAuthorizationRuleAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAuthorizationRuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAuthorizationRuleAttributeResponseBody(name='body'),
}

async function updateAuthorizationRuleAttribute(request: UpdateAuthorizationRuleAttributeRequest): UpdateAuthorizationRuleAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAuthorizationRuleAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateConnectionPoolAttributeRequest {
  cidrs?: [ string ](name='Cidrs', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  connectionPoolDescription?: string(name='ConnectionPoolDescription', position='Query'),
  connectionPoolId: string(name='ConnectionPoolId', position='Query'),
  connectionPoolName?: string(name='ConnectionPoolName', position='Query'),
  count?: long(name='Count', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UpdateConnectionPoolAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateConnectionPoolAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateConnectionPoolAttributeResponseBody(name='body'),
}

async function updateConnectionPoolAttribute(request: UpdateConnectionPoolAttributeRequest): UpdateConnectionPoolAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateConnectionPoolAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDNSServiceRuleAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DNSServiceRuleDescription?: string(name='DNSServiceRuleDescription', position='Query'),
  DNSServiceRuleId: string(name='DNSServiceRuleId', position='Query'),
  DNSServiceRuleName?: string(name='DNSServiceRuleName', position='Query'),
  destination?: string(name='Destination', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceType?: string(name='ServiceType', position='Query'),
  source?: string(name='Source', position='Query'),
}

model UpdateDNSServiceRuleAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDNSServiceRuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDNSServiceRuleAttributeResponseBody(name='body'),
}

async function updateDNSServiceRuleAttribute(request: UpdateDNSServiceRuleAttributeRequest): UpdateDNSServiceRuleAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDNSServiceRuleAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGroupAuthorizationRuleAttributeRequest {
  authorizationRuleDescription?: string(name='AuthorizationRuleDescription', position='Query'),
  authorizationRuleId: string(name='AuthorizationRuleId', position='Query'),
  authorizationRuleName?: string(name='AuthorizationRuleName', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  destination?: string(name='Destination', position='Query'),
  destinationPort?: string(name='DestinationPort', position='Query'),
  destinationType?: string(name='DestinationType', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorGroupId: string(name='IoTCloudConnectorGroupId', position='Query'),
  policy?: string(name='Policy', position='Query'),
  protocol?: string(name='Protocol', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  sourceCidrs?: [ string ](name='SourceCidrs', position='Query'),
}

model UpdateGroupAuthorizationRuleAttributeResponseBody = {
  authorizationRuleId?: string(name='AuthorizationRuleId'),
  ioTCloudConnectorGroupId?: string(name='IoTCloudConnectorGroupId'),
  requestId?: string(name='RequestId'),
}

model UpdateGroupAuthorizationRuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGroupAuthorizationRuleAttributeResponseBody(name='body'),
}

async function updateGroupAuthorizationRuleAttribute(request: UpdateGroupAuthorizationRuleAttributeRequest): UpdateGroupAuthorizationRuleAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGroupAuthorizationRuleAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGroupDNSServiceRuleAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DNSServiceRuleDescription?: string(name='DNSServiceRuleDescription', position='Query'),
  DNSServiceRuleId: string(name='DNSServiceRuleId', position='Query'),
  DNSServiceRuleName?: string(name='DNSServiceRuleName', position='Query'),
  destination?: string(name='Destination', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorGroupId: string(name='IoTCloudConnectorGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceType?: string(name='ServiceType', position='Query'),
  source?: string(name='Source', position='Query'),
}

model UpdateGroupDNSServiceRuleAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateGroupDNSServiceRuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGroupDNSServiceRuleAttributeResponseBody(name='body'),
}

async function updateGroupDNSServiceRuleAttribute(request: UpdateGroupDNSServiceRuleAttributeRequest): UpdateGroupDNSServiceRuleAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGroupDNSServiceRuleAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGroupIpMappingRuleRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  destinationIp?: string(name='DestinationIp', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  groupIpMappingRuleId: string(name='GroupIpMappingRuleId', position='Query'),
  ioTCloudConnectorGroupId: string(name='IoTCloudConnectorGroupId', position='Query'),
  ipMappingRuleDescription?: string(name='IpMappingRuleDescription', position='Query'),
  ipMappingRuleName?: string(name='IpMappingRuleName', position='Query'),
  mappingIp?: string(name='MappingIp', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UpdateGroupIpMappingRuleResponseBody = {
  authorizationRuleId?: string(name='AuthorizationRuleId'),
  ioTCloudConnectorGroupId?: string(name='IoTCloudConnectorGroupId'),
  requestId?: string(name='RequestId'),
}

model UpdateGroupIpMappingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGroupIpMappingRuleResponseBody(name='body'),
}

async function updateGroupIpMappingRule(request: UpdateGroupIpMappingRuleRequest): UpdateGroupIpMappingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGroupIpMappingRule', 'POST', '/', 'json', false, 'json', request);
}

model UpdateIoTCloudConnectorAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorDescription?: string(name='IoTCloudConnectorDescription', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  ioTCloudConnectorName?: string(name='IoTCloudConnectorName', position='Query'),
  mode?: string(name='Mode', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  wildcardDomainEnabled?: boolean(name='WildcardDomainEnabled', position='Query'),
}

model UpdateIoTCloudConnectorAttributeResponseBody = {
  requestId?: string(name='RequestId'),
  resourceId?: string(name='ResourceId'),
}

model UpdateIoTCloudConnectorAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIoTCloudConnectorAttributeResponseBody(name='body'),
}

async function updateIoTCloudConnectorAttribute(request: UpdateIoTCloudConnectorAttributeRequest): UpdateIoTCloudConnectorAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateIoTCloudConnectorAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateIoTCloudConnectorGroupAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorGroupId: string(name='IoTCloudConnectorGroupId', position='Query'),
  name?: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UpdateIoTCloudConnectorGroupAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIoTCloudConnectorGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIoTCloudConnectorGroupAttributeResponseBody(name='body'),
}

async function updateIoTCloudConnectorGroupAttribute(request: UpdateIoTCloudConnectorGroupAttributeRequest): UpdateIoTCloudConnectorGroupAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateIoTCloudConnectorGroupAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateIpMappingRuleRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  destinationIp?: string(name='DestinationIp', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  ipMappingRuleDescription?: string(name='IpMappingRuleDescription', position='Query'),
  ipMappingRuleId: string(name='IpMappingRuleId', position='Query'),
  ipMappingRuleName?: string(name='IpMappingRuleName', position='Query'),
  mappingIp?: string(name='MappingIp', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UpdateIpMappingRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIpMappingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIpMappingRuleResponseBody(name='body'),
}

async function updateIpMappingRule(request: UpdateIpMappingRuleRequest): UpdateIpMappingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateIpMappingRule', 'POST', '/', 'json', false, 'json', request);
}

model UpdateServiceAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceDescription?: string(name='ServiceDescription', position='Query'),
  serviceId: string(name='ServiceId', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
}

model UpdateServiceAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateServiceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateServiceAttributeResponseBody(name='body'),
}

async function updateServiceAttribute(request: UpdateServiceAttributeRequest): UpdateServiceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateServiceAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateServiceEntryAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ioTCloudConnectorId: string(name='IoTCloudConnectorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceEntryDescription?: string(name='ServiceEntryDescription', position='Query'),
  serviceEntryId: string(name='ServiceEntryId', position='Query'),
  serviceEntryName?: string(name='ServiceEntryName', position='Query'),
  serviceId: string(name='ServiceId', position='Query'),
}

model UpdateServiceEntryAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateServiceEntryAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateServiceEntryAttributeResponseBody(name='body'),
}

async function updateServiceEntryAttribute(request: UpdateServiceEntryAttributeRequest): UpdateServiceEntryAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateServiceEntryAttribute', 'POST', '/', 'json', false, 'json', request);
}

