/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('searchengine', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ErrorResponse {
  code?: string(name='code'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
}

model BuildIndexRequest {
  buildMode?: string(name='buildMode'),
  dataSourceName?: string(name='dataSourceName'),
  dataSourceType?: string(name='dataSourceType'),
  dataTimeSec?: int32(name='dataTimeSec'),
  domain?: string(name='domain'),
  generation?: long(name='generation'),
  partition?: string(name='partition'),
}

model BuildIndexResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model BuildIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BuildIndexResponseBody(name='body'),
}

async function buildIndex(instanceId: string, request: BuildIndexRequest): BuildIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return buildIndexWithOptions(instanceId, request, headers, runtime);
}

async function buildIndexWithOptions(instanceId: string, request: BuildIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BuildIndexResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.buildMode)) {
    body['buildMode'] = request.buildMode;
  }
  if (!Util.isUnset(request.dataSourceName)) {
    body['dataSourceName'] = request.dataSourceName;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    body['dataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.dataTimeSec)) {
    body['dataTimeSec'] = request.dataTimeSec;
  }
  if (!Util.isUnset(request.domain)) {
    body['domain'] = request.domain;
  }
  if (!Util.isUnset(request.generation)) {
    body['generation'] = request.generation;
  }
  if (!Util.isUnset(request.partition)) {
    body['partition'] = request.partition;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BuildIndex',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/actions/build-index`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateClusterRequest {
  autoLoad?: boolean(name='autoLoad'),
  dataNode?: {
    number?: int32(name='number'),
  }(name='dataNode'),
  description?: string(name='description'),
  name?: string(name='name'),
  queryNode?: {
    number?: int32(name='number'),
  }(name='queryNode'),
}

model CreateClusterResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateClusterResponseBody(name='body'),
}

async function createCluster(instanceId: string, request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createClusterWithOptions(instanceId, request, headers, runtime);
}

async function createClusterWithOptions(instanceId: string, request: CreateClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoLoad)) {
    body['autoLoad'] = request.autoLoad;
  }
  if (!Util.isUnset(request.dataNode)) {
    body['dataNode'] = request.dataNode;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.queryNode)) {
    body['queryNode'] = request.queryNode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCluster',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/clusters`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateDataSourceRequest {
  body?: map[string]any(name='body'),
  dryRun?: boolean(name='dryRun'),
}

model CreateDataSourceResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model CreateDataSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDataSourceResponseBody(name='body'),
}

async function createDataSource(instanceId: string, request: CreateDataSourceRequest): CreateDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDataSourceWithOptions(instanceId, request, headers, runtime);
}

async function createDataSourceWithOptions(instanceId: string, request: CreateDataSourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDataSourceResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataSource',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/data-sources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateIndexRequest {
  content?: string(name='content'),
  dataSource?: string(name='dataSource'),
  domain?: string(name='domain'),
  name?: string(name='name'),
  partition?: int32(name='partition'),
}

model CreateIndexResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model CreateIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIndexResponseBody(name='body'),
}

async function createIndex(instanceId: string, request: CreateIndexRequest): CreateIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIndexWithOptions(instanceId, request, headers, runtime);
}

async function createIndexWithOptions(instanceId: string, request: CreateIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIndexResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }
  if (!Util.isUnset(request.dataSource)) {
    body['dataSource'] = request.dataSource;
  }
  if (!Util.isUnset(request.domain)) {
    body['domain'] = request.domain;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.partition)) {
    body['partition'] = request.partition;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIndex',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/indexes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateInstanceRequest {
  chargeType?: string(name='chargeType'),
  components?: [ 
    {
      code?: string(name='code'),
      value?: string(name='value'),
    }
  ](name='components'),
  order?: {
    autoRenew?: boolean(name='autoRenew'),
    duration?: long(name='duration'),
    pricingCycle?: string(name='pricingCycle'),
  }(name='order'),
}

model CreateInstanceResponseBody = {
  requestId?: string(name='requestId'),
  result?: {
    instanceId?: string(name='instanceId'),
  }(name='result'),
}

model CreateInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateInstanceResponseBody(name='body'),
}

async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createInstanceWithOptions(request, headers, runtime);
}

async function createInstanceWithOptions(request: CreateInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chargeType)) {
    body['chargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.components)) {
    body['components'] = request.components;
  }
  if (!Util.isUnset(request.order)) {
    body['order'] = request.order;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateInstance',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteAdvanceConfigResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model DeleteAdvanceConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAdvanceConfigResponseBody(name='body'),
}

async function deleteAdvanceConfig(instanceId: string, configName: string): DeleteAdvanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAdvanceConfigWithOptions(instanceId, configName, headers, runtime);
}

async function deleteAdvanceConfigWithOptions(instanceId: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAdvanceConfigResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  configName = OpenApiUtil.getEncodeParam(configName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAdvanceConfig',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/advanced-configs/${configName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteDataSourceResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model DeleteDataSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDataSourceResponseBody(name='body'),
}

async function deleteDataSource(instanceId: string, dataSourceName: string): DeleteDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDataSourceWithOptions(instanceId, dataSourceName, headers, runtime);
}

async function deleteDataSourceWithOptions(instanceId: string, dataSourceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDataSourceResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  dataSourceName = OpenApiUtil.getEncodeParam(dataSourceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataSource',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/data-sources/${dataSourceName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteIndexRequest {
  dataSource?: string(name='dataSource'),
}

model DeleteIndexResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model DeleteIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIndexResponseBody(name='body'),
}

async function deleteIndex(instanceId: string, indexName: string, request: DeleteIndexRequest): DeleteIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteIndexWithOptions(instanceId, indexName, request, headers, runtime);
}

async function deleteIndexWithOptions(instanceId: string, indexName: string, request: DeleteIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteIndexResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  indexName = OpenApiUtil.getEncodeParam(indexName);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dataSource)) {
    query['dataSource'] = request.dataSource;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIndex',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/indexes/${indexName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteIndexVersionResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model DeleteIndexVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIndexVersionResponseBody(name='body'),
}

async function deleteIndexVersion(instanceId: string, indexName: string, versionName: string): DeleteIndexVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteIndexVersionWithOptions(instanceId, indexName, versionName, headers, runtime);
}

async function deleteIndexVersionWithOptions(instanceId: string, indexName: string, versionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteIndexVersionResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  indexName = OpenApiUtil.getEncodeParam(indexName);
  versionName = OpenApiUtil.getEncodeParam(versionName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteIndexVersion',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/indexes/${indexName}/versions/${versionName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteInstanceResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstance(instanceId: string): DeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteInstanceWithOptions(instanceId, headers, runtime);
}

async function deleteInstanceWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteInstanceResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstance',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ForceSwitchResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model ForceSwitchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ForceSwitchResponseBody(name='body'),
}

async function forceSwitch(instanceId: string, fsmId: string): ForceSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return forceSwitchWithOptions(instanceId, fsmId, headers, runtime);
}

async function forceSwitchWithOptions(instanceId: string, fsmId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ForceSwitchResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  fsmId = OpenApiUtil.getEncodeParam(fsmId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ForceSwitch',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/force-switch/${fsmId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetAdvanceConfigResponseBody = {
  requestId?: string(name='requestId'),
  result?: {
    desc?: string(name='desc'),
    files?: [ 
      {
        fullPathName?: string(name='fullPathName'),
        isDir?: boolean(name='isDir'),
        isTemplate?: boolean(name='isTemplate'),
        name?: string(name='name'),
      }
    ](name='files'),
    name?: string(name='name'),
    status?: string(name='status'),
    updateTime?: long(name='updateTime'),
  }(name='result'),
}

model GetAdvanceConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAdvanceConfigResponseBody(name='body'),
}

async function getAdvanceConfig(instanceId: string, configName: string): GetAdvanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAdvanceConfigWithOptions(instanceId, configName, headers, runtime);
}

async function getAdvanceConfigWithOptions(instanceId: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAdvanceConfigResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  configName = OpenApiUtil.getEncodeParam(configName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetAdvanceConfig',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/advanced-configs/${configName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetAdvanceConfigFileRequest {
  fileName?: string(name='fileName'),
}

model GetAdvanceConfigFileResponseBody = {
  requestId?: string(name='requestId'),
  result?: {
    content?: string(name='content'),
  }(name='result'),
}

model GetAdvanceConfigFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAdvanceConfigFileResponseBody(name='body'),
}

async function getAdvanceConfigFile(instanceId: string, configName: string, request: GetAdvanceConfigFileRequest): GetAdvanceConfigFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAdvanceConfigFileWithOptions(instanceId, configName, request, headers, runtime);
}

async function getAdvanceConfigFileWithOptions(instanceId: string, configName: string, request: GetAdvanceConfigFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAdvanceConfigFileResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  configName = OpenApiUtil.getEncodeParam(configName);
  var query : map[string]any = {};
  if (!Util.isUnset(request.fileName)) {
    query['fileName'] = request.fileName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAdvanceConfigFile',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/advanced-configs/${configName}/file`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetClusterResponseBody = {
  requestId?: string(name='requestId'),
  result?: {
    configUpdateTime?: string(name='configUpdateTime'),
    currentAdvanceConfigVersion?: string(name='currentAdvanceConfigVersion'),
    currentOnlineConfigVersion?: string(name='currentOnlineConfigVersion'),
    dataNode?: {
      name?: string(name='name'),
      number?: int32(name='number'),
      partition?: int32(name='partition'),
    }(name='dataNode'),
    description?: string(name='description'),
    latestAdvanceConfigVersion?: string(name='latestAdvanceConfigVersion'),
    latestOnlineConfigVersion?: string(name='latestOnlineConfigVersion'),
    name?: string(name='name'),
    queryNode?: {
      name?: string(name='name'),
      number?: int32(name='number'),
      partition?: int32(name='partition'),
    }(name='queryNode'),
    status?: string(name='status'),
  }(name='result'),
}

model GetClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClusterResponseBody(name='body'),
}

async function getCluster(instanceId: string, clusterName: string): GetClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getClusterWithOptions(instanceId, clusterName, headers, runtime);
}

async function getClusterWithOptions(instanceId: string, clusterName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetClusterResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  clusterName = OpenApiUtil.getEncodeParam(clusterName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetCluster',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/clusters/${clusterName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetClusterRunTimeInfoResponseBody = {
  requestId?: string(name='requestId'),
  result?: [ 
    {
      clusterName?: string(name='clusterName'),
      dataNodes?: {
        configStatus?: {
          configUpdateTime?: string(name='configUpdateTime'),
          donePercent?: long(name='donePercent'),
          doneSize?: long(name='doneSize'),
          name?: string(name='name'),
          totalSize?: long(name='totalSize'),
        }(name='configStatus'),
        dataStatus?: {
          donePercent?: long(name='donePercent'),
          doneSize?: long(name='doneSize'),
          errorMsg?: string(name='errorMsg'),
          fullSwitchTime?: string(name='fullSwitchTime'),
          incSwitchTime?: string(name='incSwitchTime'),
          name?: string(name='name'),
          partition?: long(name='partition'),
          totalSize?: long(name='totalSize'),
          version?: long(name='version'),
        }(name='dataStatus'),
        serviceStatus?: {
          donePercent?: long(name='donePercent'),
          doneSize?: long(name='doneSize'),
          totalSize?: long(name='totalSize'),
        }(name='serviceStatus'),
      }(name='dataNodes'),
      queryNode?: {
        configStatus?: {
          configUpdateTime?: string(name='configUpdateTime'),
          donePercent?: long(name='donePercent'),
          doneSize?: long(name='doneSize'),
          name?: string(name='name'),
          totalSize?: long(name='totalSize'),
        }(name='configStatus'),
        serviceStatus?: {
          donePercent?: long(name='donePercent'),
          doneSize?: long(name='doneSize'),
          totalSize?: long(name='totalSize'),
        }(name='serviceStatus'),
      }(name='queryNode'),
    }
  ](name='result'),
}

model GetClusterRunTimeInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClusterRunTimeInfoResponseBody(name='body'),
}

async function getClusterRunTimeInfo(instanceId: string): GetClusterRunTimeInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getClusterRunTimeInfoWithOptions(instanceId, headers, runtime);
}

async function getClusterRunTimeInfoWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetClusterRunTimeInfoResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetClusterRunTimeInfo',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/cluster-run-time-info`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetDataSourceResponseBody = {
  requestId?: string(name='requestId'),
  result?: {
    autoBuildIndex?: boolean(name='autoBuildIndex'),
    config?: {
      accessKey?: string(name='accessKey'),
      accessSecret?: string(name='accessSecret'),
      partition?: string(name='partition'),
      project?: string(name='project'),
      table?: string(name='table'),
    }(name='config'),
    domain?: string(name='domain'),
    indexes?: [ string ](name='indexes'),
    lastFulTime?: long(name='lastFulTime'),
    name?: string(name='name'),
    partitions?: [ string ](name='partitions'),
    status?: string(name='status'),
    type?: string(name='type'),
  }(name='result'),
}

model GetDataSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDataSourceResponseBody(name='body'),
}

async function getDataSource(instanceId: string, dataSourceName: string): GetDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDataSourceWithOptions(instanceId, dataSourceName, headers, runtime);
}

async function getDataSourceWithOptions(instanceId: string, dataSourceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDataSourceResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  dataSourceName = OpenApiUtil.getEncodeParam(dataSourceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDataSource',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/data-sources/${dataSourceName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetDeployGraphResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model GetDeployGraphResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeployGraphResponseBody(name='body'),
}

async function getDeployGraph(instanceId: string): GetDeployGraphResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDeployGraphWithOptions(instanceId, headers, runtime);
}

async function getDeployGraphWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDeployGraphResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDeployGraph',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/deploy-graph`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFileRequest {
  fileName?: string(name='fileName'),
}

model GetFileResponseBody = {
  requestId?: string(name='requestId'),
  result?: {
    content?: string(name='content'),
    dataSource?: string(name='dataSource'),
    fullPathName?: string(name='fullPathName'),
    isDir?: boolean(name='isDir'),
    name?: string(name='name'),
    partition?: long(name='partition'),
  }(name='result'),
}

model GetFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFileResponseBody(name='body'),
}

async function getFile(instanceId: string, indexName: string, versionName: string, request: GetFileRequest): GetFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFileWithOptions(instanceId, indexName, versionName, request, headers, runtime);
}

async function getFileWithOptions(instanceId: string, indexName: string, versionName: string, request: GetFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFileResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  indexName = OpenApiUtil.getEncodeParam(indexName);
  versionName = OpenApiUtil.getEncodeParam(versionName);
  var query : map[string]any = {};
  if (!Util.isUnset(request.fileName)) {
    query['fileName'] = request.fileName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFile',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/indexes/${indexName}/versions/${versionName}/file`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetIndexRequest {
  dataSource?: string(name='dataSource'),
}

model GetIndexResponseBody = {
  requestId?: string(name='requestId'),
  result?: {
    dataSource?: string(name='dataSource'),
    domain?: string(name='domain'),
    indexStatus?: string(name='indexStatus'),
    name?: string(name='name'),
    versions?: [ 
      {
        desc?: string(name='desc'),
        files?: [ 
          {
            fullPathName?: string(name='fullPathName'),
            isDir?: boolean(name='isDir'),
            isTemplate?: boolean(name='isTemplate'),
            name?: string(name='name'),
          }
        ](name='files'),
        name?: string(name='name'),
        status?: string(name='status'),
        updateTime?: long(name='updateTime'),
        versionId?: int32(name='versionId'),
      }
    ](name='versions'),
  }(name='result'),
}

model GetIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIndexResponseBody(name='body'),
}

async function getIndex(instanceId: string, indexName: string, request: GetIndexRequest): GetIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIndexWithOptions(instanceId, indexName, request, headers, runtime);
}

async function getIndexWithOptions(instanceId: string, indexName: string, request: GetIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetIndexResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  indexName = OpenApiUtil.getEncodeParam(indexName);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dataSource)) {
    query['dataSource'] = request.dataSource;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetIndex',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/indexes/${indexName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetIndexVersionResponseBody = {
  requestId?: string(name='requestId'),
  result?: {
    cluster?: string(name='cluster'),
    indexVersions?: [ 
      {
        buildDeployId?: string(name='buildDeployId'),
        currentVersion?: long(name='currentVersion'),
        indexName?: string(name='indexName'),
        versions?: [ long ](name='versions'),
      }
    ](name='indexVersions'),
  }(name='result'),
}

model GetIndexVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIndexVersionResponseBody(name='body'),
}

async function getIndexVersion(instanceId: string, clusterName: string): GetIndexVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIndexVersionWithOptions(instanceId, clusterName, headers, runtime);
}

async function getIndexVersionWithOptions(instanceId: string, clusterName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetIndexVersionResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  clusterName = OpenApiUtil.getEncodeParam(clusterName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetIndexVersion',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/clusters/${clusterName}/index-version`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetInstanceResponseBody = {
  requestId?: string(name='requestId'),
  result?: {
    chargeType?: string(name='chargeType'),
    commodityCode?: string(name='commodityCode'),
    createTime?: string(name='createTime'),
    description?: string(name='description'),
    expiredTime?: string(name='expiredTime'),
    inDebt?: boolean(name='inDebt'),
    instanceId?: string(name='instanceId'),
    lockMode?: string(name='lockMode'),
    resourceGroupId?: string(name='resourceGroupId'),
    status?: string(name='status'),
    updateTime?: string(name='updateTime'),
  }(name='result'),
}

model GetInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInstanceResponseBody(name='body'),
}

async function getInstance(instanceId: string): GetInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getInstanceWithOptions(instanceId, headers, runtime);
}

async function getInstanceWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetInstanceResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetInstance',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetNodeConfigRequest {
  clusterName?: string(name='clusterName'),
  dataSourceName?: string(name='dataSourceName'),
  name?: string(name='name'),
  tableDeployId?: string(name='tableDeployId'),
  type?: string(name='type'),
}

model GetNodeConfigResponseBody = {
  requestId?: string(name='requestId'),
  result?: [ 
    {
      dataDuplicateNumber?: long(name='dataDuplicateNumber'),
      dataFragmentNumber?: long(name='dataFragmentNumber'),
      minServicePercent?: long(name='minServicePercent'),
      published?: boolean(name='published'),
    }
  ](name='result'),
}

model GetNodeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNodeConfigResponseBody(name='body'),
}

async function getNodeConfig(instanceId: string, request: GetNodeConfigRequest): GetNodeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getNodeConfigWithOptions(instanceId, request, headers, runtime);
}

async function getNodeConfigWithOptions(instanceId: string, request: GetNodeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetNodeConfigResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterName)) {
    query['clusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.dataSourceName)) {
    query['dataSourceName'] = request.dataSourceName;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.tableDeployId)) {
    query['tableDeployId'] = request.tableDeployId;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeConfig',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/node-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAdvanceConfigDirRequest {
  dirName?: string(name='dirName'),
}

model ListAdvanceConfigDirResponseBody = {
  requestId?: string(name='requestId'),
  result?: [ 
    {
      fullPathName?: string(name='fullPathName'),
      isDir?: boolean(name='isDir'),
      isTemplate?: boolean(name='isTemplate'),
      name?: string(name='name'),
    }
  ](name='result'),
}

model ListAdvanceConfigDirResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAdvanceConfigDirResponseBody(name='body'),
}

async function listAdvanceConfigDir(instanceId: string, configName: string, request: ListAdvanceConfigDirRequest): ListAdvanceConfigDirResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAdvanceConfigDirWithOptions(instanceId, configName, request, headers, runtime);
}

async function listAdvanceConfigDirWithOptions(instanceId: string, configName: string, request: ListAdvanceConfigDirRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAdvanceConfigDirResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  configName = OpenApiUtil.getEncodeParam(configName);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dirName)) {
    query['dirName'] = request.dirName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAdvanceConfigDir',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/advanced-configs/${configName}/dir`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAdvanceConfigsRequest {
  type?: string(name='type'),
}

model ListAdvanceConfigsResponseBody = {
  requestId?: string(name='requestId'),
  result?: [ 
    {
      desc?: string(name='desc'),
      files?: [ 
        {
          fullPathName?: string(name='fullPathName'),
          isDir?: boolean(name='isDir'),
          isTemplate?: boolean(name='isTemplate'),
          name?: string(name='name'),
        }
      ](name='files'),
      name?: string(name='name'),
      status?: string(name='status'),
      updateTime?: long(name='updateTime'),
    }
  ](name='result'),
}

model ListAdvanceConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAdvanceConfigsResponseBody(name='body'),
}

async function listAdvanceConfigs(instanceId: string, request: ListAdvanceConfigsRequest): ListAdvanceConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAdvanceConfigsWithOptions(instanceId, request, headers, runtime);
}

async function listAdvanceConfigsWithOptions(instanceId: string, request: ListAdvanceConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAdvanceConfigsResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAdvanceConfigs',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/advanced-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListClusterNamesResponseBody = {
  requestId?: string(name='requestId'),
  result?: {
    description?: string(name='description'),
    id?: long(name='id'),
    name?: string(name='name'),
  }(name='result'),
}

model ListClusterNamesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClusterNamesResponseBody(name='body'),
}

async function listClusterNames(instanceId: string): ListClusterNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listClusterNamesWithOptions(instanceId, headers, runtime);
}

async function listClusterNamesWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListClusterNamesResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListClusterNames',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/cluster-names`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListClusterTasksResponseBody = {
  requestId?: string(name='requestId'),
  result?: [ 
    {
      extraAttribute?: string(name='extraAttribute'),
      field3?: string(name='field3'),
      fsmId?: string(name='fsmId'),
      groupType?: string(name='groupType'),
      name?: string(name='name'),
      status?: string(name='status'),
      tags?: [ 
        {
          msg?: string(name='msg'),
          tagLevel?: string(name='tagLevel'),
        }
      ](name='tags'),
      taskNodes?: [ 
        {
          finishDate?: string(name='finishDate'),
          index?: long(name='index'),
          name?: string(name='name'),
          status?: string(name='status'),
        }
      ](name='taskNodes'),
      time?: string(name='time'),
      type?: string(name='type'),
      user?: string(name='user'),
    }
  ](name='result'),
}

model ListClusterTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClusterTasksResponseBody(name='body'),
}

async function listClusterTasks(instanceId: string): ListClusterTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listClusterTasksWithOptions(instanceId, headers, runtime);
}

async function listClusterTasksWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListClusterTasksResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListClusterTasks',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/cluster-tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListClustersResponseBody = {
  requestId?: string(name='requestId'),
  result?: [ 
    {
      configUpdateTime?: string(name='configUpdateTime'),
      currentAdvanceConfigVersion?: string(name='currentAdvanceConfigVersion'),
      currentOnlineConfigVersion?: string(name='currentOnlineConfigVersion'),
      dataNode?: {
        name?: string(name='name'),
        number?: int32(name='number'),
        partition?: int32(name='partition'),
      }(name='dataNode'),
      description?: string(name='description'),
      latestAdvanceConfigVersion?: string(name='latestAdvanceConfigVersion'),
      latestOnlineConfigVersion?: string(name='latestOnlineConfigVersion'),
      name?: string(name='name'),
      queryNode?: {
        name?: string(name='name'),
        number?: int32(name='number'),
        partition?: int32(name='partition'),
      }(name='queryNode'),
      status?: string(name='status'),
    }
  ](name='result'),
}

model ListClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClustersResponseBody(name='body'),
}

async function listClusters(instanceId: string): ListClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listClustersWithOptions(instanceId, headers, runtime);
}

async function listClustersWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListClustersResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListClusters',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/clusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDataSourceSchemasResponseBody = {
  requestId?: string(name='requestId'),
  result?: [ 
    {
      addIndex?: boolean(name='addIndex'),
      attribute?: boolean(name='attribute'),
      custom?: boolean(name='custom'),
      name?: string(name='name'),
      primaryKey?: {
        hasPrimaryKeyAttribute?: boolean(name='hasPrimaryKeyAttribute'),
        isPrimaryKey?: boolean(name='isPrimaryKey'),
        isPrimaryKeySorted?: boolean(name='isPrimaryKeySorted'),
      }(name='primaryKey'),
      summary?: boolean(name='summary'),
      type?: string(name='type'),
    }
  ](name='result'),
}

model ListDataSourceSchemasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDataSourceSchemasResponseBody(name='body'),
}

async function listDataSourceSchemas(instanceId: string, dataSourceName: string): ListDataSourceSchemasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataSourceSchemasWithOptions(instanceId, dataSourceName, headers, runtime);
}

async function listDataSourceSchemasWithOptions(instanceId: string, dataSourceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataSourceSchemasResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  dataSourceName = OpenApiUtil.getEncodeParam(dataSourceName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDataSourceSchemas',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/data-sources/${dataSourceName}/schemas`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDataSourceTasksResponseBody = {
  requestId?: string(name='requestId'),
  result?: [ 
    {
      extraAttribute?: string(name='extraAttribute'),
      field3?: string(name='field3'),
      fsmId?: string(name='fsmId'),
      groupType?: string(name='groupType'),
      name?: string(name='name'),
      status?: string(name='status'),
      tags?: [ 
        {
          msg?: string(name='msg'),
          tagLevel?: string(name='tagLevel'),
        }
      ](name='tags'),
      taskNodes?: [ 
        {
          finishDate?: string(name='finishDate'),
          index?: long(name='index'),
          name?: string(name='name'),
          status?: string(name='status'),
        }
      ](name='taskNodes'),
      time?: string(name='time'),
      type?: string(name='type'),
      user?: string(name='user'),
    }
  ](name='result'),
}

model ListDataSourceTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDataSourceTasksResponseBody(name='body'),
}

async function listDataSourceTasks(instanceId: string): ListDataSourceTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataSourceTasksWithOptions(instanceId, headers, runtime);
}

async function listDataSourceTasksWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataSourceTasksResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDataSourceTasks',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/data-source-tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDataSourcesResponseBody = {
  requestId?: string(name='requestId'),
  result?: [ 
    {
      autoBuildIndex?: boolean(name='autoBuildIndex'),
      config?: {
        accessKey?: string(name='accessKey'),
        accessSecret?: string(name='accessSecret'),
        partition?: string(name='partition'),
        project?: string(name='project'),
        table?: string(name='table'),
      }(name='config'),
      domain?: string(name='domain'),
      indexes?: [ string ](name='indexes'),
      lastFulTime?: long(name='lastFulTime'),
      name?: string(name='name'),
      partitions?: [ string ](name='partitions'),
      status?: string(name='status'),
      type?: string(name='type'),
    }
  ](name='result'),
}

model ListDataSourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDataSourcesResponseBody(name='body'),
}

async function listDataSources(instanceId: string): ListDataSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataSourcesWithOptions(instanceId, headers, runtime);
}

async function listDataSourcesWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataSourcesResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDataSources',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/data-sources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDateSourceGenerationsRequest {
  domainName?: string(name='domainName'),
  validStatus?: boolean(name='validStatus'),
}

model ListDateSourceGenerationsResponseBody = {
  requestId?: string(name='requestId'),
  result?: [ 
    {
      buildDeployId?: int32(name='buildDeployId'),
      createTime?: long(name='createTime'),
      dataDumpRoot?: string(name='dataDumpRoot'),
      generation?: long(name='generation'),
      partition?: map[string]int32(name='partition'),
      status?: string(name='status'),
      timestamp?: long(name='timestamp'),
    }
  ](name='result'),
}

model ListDateSourceGenerationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDateSourceGenerationsResponseBody(name='body'),
}

async function listDateSourceGenerations(instanceId: string, dataSourceName: string, request: ListDateSourceGenerationsRequest): ListDateSourceGenerationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDateSourceGenerationsWithOptions(instanceId, dataSourceName, request, headers, runtime);
}

async function listDateSourceGenerationsWithOptions(instanceId: string, dataSourceName: string, request: ListDateSourceGenerationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDateSourceGenerationsResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  dataSourceName = OpenApiUtil.getEncodeParam(dataSourceName);
  var query : map[string]any = {};
  if (!Util.isUnset(request.domainName)) {
    query['domainName'] = request.domainName;
  }
  if (!Util.isUnset(request.validStatus)) {
    query['validStatus'] = request.validStatus;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDateSourceGenerations',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/data-sources/${dataSourceName}/generations`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListIndexesResponseBody = {
  requestId?: string(name='requestId'),
  result?: [ 
    {
      dataSource?: string(name='dataSource'),
      domain?: string(name='domain'),
      indexStatus?: string(name='indexStatus'),
      name?: string(name='name'),
      versions?: [ 
        {
          desc?: string(name='desc'),
          files?: [ 
            {
              fullPathName?: string(name='fullPathName'),
              isDir?: boolean(name='isDir'),
              isTemplate?: boolean(name='isTemplate'),
              name?: string(name='name'),
            }
          ](name='files'),
          name?: string(name='name'),
          status?: string(name='status'),
          updateTime?: long(name='updateTime'),
          versionId?: int32(name='versionId'),
        }
      ](name='versions'),
    }
  ](name='result'),
}

model ListIndexesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIndexesResponseBody(name='body'),
}

async function listIndexes(instanceId: string): ListIndexesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIndexesWithOptions(instanceId, headers, runtime);
}

async function listIndexesWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListIndexesResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListIndexes',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/indexes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListInstanceSpecsRequest {
  type?: string(name='type'),
}

model ListInstanceSpecsResponseBody = {
  requestId?: string(name='requestId'),
  result?: [ 
    {
      cpu?: int32(name='cpu'),
      disk?: int32(name='disk'),
      mem?: int32(name='mem'),
    }
  ](name='result'),
}

model ListInstanceSpecsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceSpecsResponseBody(name='body'),
}

async function listInstanceSpecs(instanceId: string, request: ListInstanceSpecsRequest): ListInstanceSpecsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstanceSpecsWithOptions(instanceId, request, headers, runtime);
}

async function listInstanceSpecsWithOptions(instanceId: string, request: ListInstanceSpecsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstanceSpecsResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceSpecs',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/specs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListInstancesRequest {
  description?: string(name='description'),
  instanceId?: string(name='instanceId'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  resourceGroupId?: string(name='resourceGroupId'),
}

model ListInstancesResponseBody = {
  requestId?: string(name='requestId'),
  result?: [ 
    {
      chargeType?: string(name='chargeType'),
      commodityCode?: string(name='commodityCode'),
      createTime?: string(name='createTime'),
      description?: string(name='description'),
      expiredTime?: string(name='expiredTime'),
      inDebt?: boolean(name='inDebt'),
      instanceId?: string(name='instanceId'),
      lockMode?: string(name='lockMode'),
      network?: {
        endpoint?: string(name='endpoint'),
        vSwitchId?: string(name='vSwitchId'),
        vpcId?: string(name='vpcId'),
      }(name='network'),
      resourceGroupId?: string(name='resourceGroupId'),
      status?: string(name='status'),
      updateTime?: string(name='updateTime'),
    }
  ](name='result'),
  totalCount?: int32(name='totalCount'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstancesWithOptions(request, headers, runtime);
}

async function listInstancesWithOptions(request: ListInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    query['description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListOnlineConfigsRequest {
  domain?: string(name='domain'),
}

model ListOnlineConfigsResponseBody = {
  requestId?: string(name='requestId'),
  result?: [ 
    {
      config?: string(name='config'),
      indexName?: string(name='indexName'),
    }
  ](name='result'),
}

model ListOnlineConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOnlineConfigsResponseBody(name='body'),
}

async function listOnlineConfigs(instanceId: string, nodeName: string, request: ListOnlineConfigsRequest): ListOnlineConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOnlineConfigsWithOptions(instanceId, nodeName, request, headers, runtime);
}

async function listOnlineConfigsWithOptions(instanceId: string, nodeName: string, request: ListOnlineConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOnlineConfigsResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  nodeName = OpenApiUtil.getEncodeParam(nodeName);
  var query : map[string]any = {};
  if (!Util.isUnset(request.domain)) {
    query['domain'] = request.domain;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOnlineConfigs',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/node/${nodeName}/online-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListQueryResultRequest {
  query?: string(name='query'),
  sql?: string(name='sql'),
}

model ListQueryResultResponseBody = {
  requestId?: string(name='requestId'),
}

model ListQueryResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListQueryResultResponseBody(name='body'),
}

async function listQueryResult(instanceId: string, request: ListQueryResultRequest): ListQueryResultResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listQueryResultWithOptions(instanceId, request, headers, runtime);
}

async function listQueryResultWithOptions(instanceId: string, request: ListQueryResultRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListQueryResultResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.sql)) {
    query['sql'] = request.sql;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListQueryResult',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/query`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyAdvanceConfigFileRequest {
  content?: string(name='content'),
  variables?: map[string]VariablesValue(name='variables'),
  fileName?: string(name='fileName'),
}

model ModifyAdvanceConfigFileResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model ModifyAdvanceConfigFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAdvanceConfigFileResponseBody(name='body'),
}

async function modifyAdvanceConfigFile(instanceId: string, configName: string, request: ModifyAdvanceConfigFileRequest): ModifyAdvanceConfigFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyAdvanceConfigFileWithOptions(instanceId, configName, request, headers, runtime);
}

async function modifyAdvanceConfigFileWithOptions(instanceId: string, configName: string, request: ModifyAdvanceConfigFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyAdvanceConfigFileResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  configName = OpenApiUtil.getEncodeParam(configName);
  var query : map[string]any = {};
  if (!Util.isUnset(request.fileName)) {
    query['fileName'] = request.fileName;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }
  if (!Util.isUnset(request.variables)) {
    body['variables'] = request.variables;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAdvanceConfigFile',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/advanced-configs/${configName}/file`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyClusterDescRequest {
  body?: map[string]any(name='body'),
}

model ModifyClusterDescResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model ModifyClusterDescResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyClusterDescResponseBody(name='body'),
}

async function modifyClusterDesc(instanceId: string, clusterName: string, request: ModifyClusterDescRequest): ModifyClusterDescResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyClusterDescWithOptions(instanceId, clusterName, request, headers, runtime);
}

async function modifyClusterDescWithOptions(instanceId: string, clusterName: string, request: ModifyClusterDescRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyClusterDescResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  clusterName = OpenApiUtil.getEncodeParam(clusterName);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterDesc',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/clusters/${clusterName}/desc`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyClusterOfflineConfigRequest {
  advancedConfigVersionId?: int32(name='advancedConfigVersionId'),
  buildMode?: string(name='buildMode'),
  dataSource?: string(name='dataSource'),
  dataSourceType?: string(name='dataSourceType'),
  dataTimeSec?: int32(name='dataTimeSec'),
  domain?: string(name='domain'),
  generation?: long(name='generation'),
  indexes?: [ 
    {
      name?: string(name='name'),
      versionId?: int32(name='versionId'),
    }
  ](name='indexes'),
  partition?: string(name='partition'),
  triggerBuild?: boolean(name='triggerBuild'),
}

model ModifyClusterOfflineConfigResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model ModifyClusterOfflineConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyClusterOfflineConfigResponseBody(name='body'),
}

async function modifyClusterOfflineConfig(instanceId: string, request: ModifyClusterOfflineConfigRequest): ModifyClusterOfflineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyClusterOfflineConfigWithOptions(instanceId, request, headers, runtime);
}

async function modifyClusterOfflineConfigWithOptions(instanceId: string, request: ModifyClusterOfflineConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyClusterOfflineConfigResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.advancedConfigVersionId)) {
    body['advancedConfigVersionId'] = request.advancedConfigVersionId;
  }
  if (!Util.isUnset(request.buildMode)) {
    body['buildMode'] = request.buildMode;
  }
  if (!Util.isUnset(request.dataSource)) {
    body['dataSource'] = request.dataSource;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    body['dataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.dataTimeSec)) {
    body['dataTimeSec'] = request.dataTimeSec;
  }
  if (!Util.isUnset(request.domain)) {
    body['domain'] = request.domain;
  }
  if (!Util.isUnset(request.generation)) {
    body['generation'] = request.generation;
  }
  if (!Util.isUnset(request.indexes)) {
    body['indexes'] = request.indexes;
  }
  if (!Util.isUnset(request.partition)) {
    body['partition'] = request.partition;
  }
  if (!Util.isUnset(request.triggerBuild)) {
    body['triggerBuild'] = request.triggerBuild;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterOfflineConfig',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/cluster-offline-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyClusterOnlineConfigRequest {
  advancedConfigVersionId?: int32(name='advancedConfigVersionId'),
  clusters?: [ string ](name='clusters'),
}

model ModifyClusterOnlineConfigResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model ModifyClusterOnlineConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyClusterOnlineConfigResponseBody(name='body'),
}

async function modifyClusterOnlineConfig(instanceId: string, request: ModifyClusterOnlineConfigRequest): ModifyClusterOnlineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyClusterOnlineConfigWithOptions(instanceId, request, headers, runtime);
}

async function modifyClusterOnlineConfigWithOptions(instanceId: string, request: ModifyClusterOnlineConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyClusterOnlineConfigResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.advancedConfigVersionId)) {
    body['advancedConfigVersionId'] = request.advancedConfigVersionId;
  }
  if (!Util.isUnset(request.clusters)) {
    body['clusters'] = request.clusters;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterOnlineConfig',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/cluster-online-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyDataSourceRequest {
  body?: map[string]any(name='body'),
  dryRun?: boolean(name='dryRun'),
}

model ModifyDataSourceResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model ModifyDataSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDataSourceResponseBody(name='body'),
}

async function modifyDataSource(instanceId: string, dataSourceName: string, request: ModifyDataSourceRequest): ModifyDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyDataSourceWithOptions(instanceId, dataSourceName, request, headers, runtime);
}

async function modifyDataSourceWithOptions(instanceId: string, dataSourceName: string, request: ModifyDataSourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyDataSourceResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  dataSourceName = OpenApiUtil.getEncodeParam(dataSourceName);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDataSource',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/data-sources/${dataSourceName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyFileRequest {
  content?: string(name='content'),
  partition?: int32(name='partition'),
  fileName?: string(name='fileName'),
}

model ModifyFileResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model ModifyFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyFileResponseBody(name='body'),
}

async function modifyFile(instanceId: string, indexName: string, versionName: string, request: ModifyFileRequest): ModifyFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyFileWithOptions(instanceId, indexName, versionName, request, headers, runtime);
}

async function modifyFileWithOptions(instanceId: string, indexName: string, versionName: string, request: ModifyFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyFileResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  indexName = OpenApiUtil.getEncodeParam(indexName);
  versionName = OpenApiUtil.getEncodeParam(versionName);
  var query : map[string]any = {};
  if (!Util.isUnset(request.fileName)) {
    query['fileName'] = request.fileName;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }
  if (!Util.isUnset(request.partition)) {
    body['partition'] = request.partition;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyFile',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/indexes/${indexName}/versions/${versionName}/file`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyIndexPartitionRequest {
  dataSourceName?: string(name='dataSourceName'),
  domainName?: string(name='domainName'),
  generation?: long(name='generation'),
  indexInfos?: [ 
    {
      indexName?: string(name='indexName'),
      parallelNum?: int32(name='parallelNum'),
      partitionCount?: int32(name='partitionCount'),
    }
  ](name='indexInfos'),
}

model ModifyIndexPartitionResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model ModifyIndexPartitionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyIndexPartitionResponseBody(name='body'),
}

async function modifyIndexPartition(instanceId: string, request: ModifyIndexPartitionRequest): ModifyIndexPartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyIndexPartitionWithOptions(instanceId, request, headers, runtime);
}

async function modifyIndexPartitionWithOptions(instanceId: string, request: ModifyIndexPartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyIndexPartitionResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataSourceName)) {
    body['dataSourceName'] = request.dataSourceName;
  }
  if (!Util.isUnset(request.domainName)) {
    body['domainName'] = request.domainName;
  }
  if (!Util.isUnset(request.generation)) {
    body['generation'] = request.generation;
  }
  if (!Util.isUnset(request.indexInfos)) {
    body['indexInfos'] = request.indexInfos;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIndexPartition',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/index-partition`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyIndexVersionRequest {
  body?: [ 
    {
      buildDeployId?: string(name='buildDeployId'),
      indexName?: string(name='indexName'),
      version?: string(name='version'),
    }
  ](name='body'),
}

model ModifyIndexVersionResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model ModifyIndexVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyIndexVersionResponseBody(name='body'),
}

async function modifyIndexVersion(instanceId: string, clusterName: string, request: ModifyIndexVersionRequest): ModifyIndexVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyIndexVersionWithOptions(instanceId, clusterName, request, headers, runtime);
}

async function modifyIndexVersionWithOptions(instanceId: string, clusterName: string, request: ModifyIndexVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyIndexVersionResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  clusterName = OpenApiUtil.getEncodeParam(clusterName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIndexVersion',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/clusters/${clusterName}/index-version`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyNodeConfigRequest {
  body?: map[string]any(name='body'),
  clusterName?: string(name='clusterName'),
  dataSourceName?: string(name='dataSourceName'),
  name?: string(name='name'),
  tableDeployId?: string(name='tableDeployId'),
  type?: string(name='type'),
}

model ModifyNodeConfigResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model ModifyNodeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyNodeConfigResponseBody(name='body'),
}

async function modifyNodeConfig(instanceId: string, request: ModifyNodeConfigRequest): ModifyNodeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyNodeConfigWithOptions(instanceId, request, headers, runtime);
}

async function modifyNodeConfigWithOptions(instanceId: string, request: ModifyNodeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyNodeConfigResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterName)) {
    query['clusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.dataSourceName)) {
    query['dataSourceName'] = request.dataSourceName;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.tableDeployId)) {
    query['tableDeployId'] = request.tableDeployId;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNodeConfig',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/node-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyOnlineConfigRequest {
  body?: map[string]string(name='body'),
}

model ModifyOnlineConfigResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model ModifyOnlineConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyOnlineConfigResponseBody(name='body'),
}

async function modifyOnlineConfig(instanceId: string, nodeName: string, indexName: string, request: ModifyOnlineConfigRequest): ModifyOnlineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyOnlineConfigWithOptions(instanceId, nodeName, indexName, request, headers, runtime);
}

async function modifyOnlineConfigWithOptions(instanceId: string, nodeName: string, indexName: string, request: ModifyOnlineConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyOnlineConfigResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  nodeName = OpenApiUtil.getEncodeParam(nodeName);
  indexName = OpenApiUtil.getEncodeParam(indexName);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyOnlineConfig',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/node/${nodeName}/online-configs/${indexName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyPasswordRequest {
  password?: string(name='password'),
  username?: string(name='username'),
}

model ModifyPasswordResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model ModifyPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyPasswordResponseBody(name='body'),
}

async function modifyPassword(instanceId: string, request: ModifyPasswordRequest): ModifyPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyPasswordWithOptions(instanceId, request, headers, runtime);
}

async function modifyPasswordWithOptions(instanceId: string, request: ModifyPasswordRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyPasswordResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.password)) {
    body['password'] = request.password;
  }
  if (!Util.isUnset(request.username)) {
    body['username'] = request.username;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPassword',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/password`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PublishAdvanceConfigRequest {
  body?: map[string]any(name='body'),
}

model PublishAdvanceConfigResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model PublishAdvanceConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishAdvanceConfigResponseBody(name='body'),
}

async function publishAdvanceConfig(instanceId: string, configName: string, request: PublishAdvanceConfigRequest): PublishAdvanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return publishAdvanceConfigWithOptions(instanceId, configName, request, headers, runtime);
}

async function publishAdvanceConfigWithOptions(instanceId: string, configName: string, request: PublishAdvanceConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PublishAdvanceConfigResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  configName = OpenApiUtil.getEncodeParam(configName);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PublishAdvanceConfig',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/advanced-configs/${configName}/actions/publish`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PublishIndexVersionRequest {
  body?: map[string]any(name='body'),
}

model PublishIndexVersionResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model PublishIndexVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishIndexVersionResponseBody(name='body'),
}

async function publishIndexVersion(instanceId: string, indexName: string, request: PublishIndexVersionRequest): PublishIndexVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return publishIndexVersionWithOptions(instanceId, indexName, request, headers, runtime);
}

async function publishIndexVersionWithOptions(instanceId: string, indexName: string, request: PublishIndexVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PublishIndexVersionResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  indexName = OpenApiUtil.getEncodeParam(indexName);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PublishIndexVersion',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/indexes/${indexName}/actions/publish`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RecoverIndexRequest {
  buildDeployId?: int32(name='buildDeployId'),
  dataSourceName?: string(name='dataSourceName'),
  generation?: string(name='generation'),
  indexName?: string(name='indexName'),
}

model RecoverIndexResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model RecoverIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecoverIndexResponseBody(name='body'),
}

async function recoverIndex(instanceId: string, request: RecoverIndexRequest): RecoverIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return recoverIndexWithOptions(instanceId, request, headers, runtime);
}

async function recoverIndexWithOptions(instanceId: string, request: RecoverIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RecoverIndexResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.buildDeployId)) {
    body['buildDeployId'] = request.buildDeployId;
  }
  if (!Util.isUnset(request.dataSourceName)) {
    body['dataSourceName'] = request.dataSourceName;
  }
  if (!Util.isUnset(request.generation)) {
    body['generation'] = request.generation;
  }
  if (!Util.isUnset(request.indexName)) {
    body['indexName'] = request.indexName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RecoverIndex',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/recover-index`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RemoveClusterResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model RemoveClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveClusterResponseBody(name='body'),
}

async function removeCluster(instanceId: string, clusterName: string): RemoveClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeClusterWithOptions(instanceId, clusterName, headers, runtime);
}

async function removeClusterWithOptions(instanceId: string, clusterName: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveClusterResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  clusterName = OpenApiUtil.getEncodeParam(clusterName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveCluster',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/clusters/${clusterName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopTaskResponseBody = {
  requestId?: string(name='requestId'),
  result?: map[string]any(name='result'),
}

model StopTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopTaskResponseBody(name='body'),
}

async function stopTask(instanceId: string, fsmId: string): StopTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopTaskWithOptions(instanceId, fsmId, headers, runtime);
}

async function stopTaskWithOptions(instanceId: string, fsmId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopTaskResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  fsmId = OpenApiUtil.getEncodeParam(fsmId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopTask',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}/stop-task/${fsmId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateInstanceRequest {
  components?: [ 
    {
      code?: string(name='code'),
      value?: string(name='value'),
    }
  ](name='components'),
  description?: string(name='description'),
  orderType?: string(name='orderType'),
}

model UpdateInstanceResponseBody = {
  requestId?: string(name='requestId'),
  result?: {
    chargeType?: string(name='chargeType'),
    commodityCode?: string(name='commodityCode'),
    createTime?: string(name='createTime'),
    description?: string(name='description'),
    expiredTime?: string(name='expiredTime'),
    inDebt?: boolean(name='inDebt'),
    instanceId?: string(name='instanceId'),
    lockMode?: string(name='lockMode'),
    resourceGroupId?: string(name='resourceGroupId'),
    status?: string(name='status'),
    updateTime?: string(name='updateTime'),
  }(name='result'),
}

model UpdateInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceResponseBody(name='body'),
}

async function updateInstance(instanceId: string, request: UpdateInstanceRequest): UpdateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateInstanceWithOptions(instanceId, request, headers, runtime);
}

async function updateInstanceWithOptions(instanceId: string, request: UpdateInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateInstanceResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.components)) {
    body['components'] = request.components;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.orderType)) {
    body['orderType'] = request.orderType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstance',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${instanceId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model VariablesValue = {
  disableModify?: boolean(name='disableModify'),
  isModify?: boolean(name='isModify'),
  value?: string(name='value'),
  description?: string(name='description'),
  templateValue?: string(name='templateValue'),
  type?: string(name='type'),
  funcValue?: {
    funcClassName?: string(name='funcClassName'),
    template?: string(name='template'),
  }(name='funcValue'),
}

