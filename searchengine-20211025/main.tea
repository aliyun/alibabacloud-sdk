/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('searchengine', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ErrorResponse {
  code?: string(name='code', example='InternalServerError'),
  message?: string(name='message', example='internal server error'),
  requestId?: string(name='requestId', example='90D6B8F5-FE97-4509-9AAB-367836C51818'),
}

model ResultClusterValue = {
  buildParallelNum?: int32(name='buildParallelNum', description='The maximum number of full indexes that can be concurrently built.', example='2'),
  mergeParallelNum?: int32(name='mergeParallelNum', description='The maximum number of full indexes that can be concurrently merged.', example='2'),
}

model ResultDatabasesFunctionsValue = {
  name?: string(name='name', example='test'),
  signatures?: string(name='signatures', example='gfasdds2****2wfrkv'),
}

model ResultValue = {
  pauseAll?: boolean(name='pauseAll', description='Indicates whether all pushes are suspended.', example='true'),
  pauseIndex?: boolean(name='pauseIndex', description='Indicates whether the push is suspended for the new full index version.', example='true'),
  pauseIndexBatch?: boolean(name='pauseIndexBatch', description='Indicates whether the push is suspended for the incremental indexes.', example='true'),
  pauseBiz?: boolean(name='pauseBiz', description='Indicates whether the push is suspended for the configuration.', example='true'),
  pauseRuntime?: boolean(name='pauseRuntime', description='Indicates whether the push is suspended for the real-time incremental indexes.', example='true'),
}

model VariablesValue = {
  disableModify?: boolean(name='disableModify', description='Specifies whether the variable is not allowed to be modified.', example='false'),
  isModify?: boolean(name='isModify', description='Specifies whether the variable is modified.', example='false'),
  value?: string(name='value', description='The variable value.', example='""'),
  description?: string(name='description', description='The description of the variable.', example='""'),
  templateValue?: string(name='templateValue', description='The template value of the variable.', example='""'),
  type?: string(name='type', description='The variable type. Valid values:

*   NORMAL: common variable
*   FUNCTION: function variable', example='NORMAL'),
  funcValue?: {
    funcClassName?: string(name='funcClassName', description='The class name of the function variable.', example='""'),
    template?: string(name='template', description='The template of the function variable.', example='""'),
  }(name='funcValue', description='The function variables.'),
}

model ConfigValue = {
  desc?: string(name='desc', description='The description of the offline configuration.', example='test'),
  files?: [ 
    {
      operateType?: string(name='operateType', description='The operation type. Valid values: UPDATE and DELETE. Default value: UPDATE.', example='UPDATE'),
      parentFullPath?: string(name='parentFullPath', description='The path of the parent directory.', example='/'),
      fileName?: string(name='fileName', description='The file name.', example='/intervene_dict/中文-通用分析器.dict'),
      config?: {
        content?: string(name='content', description='The file content.', example='$dictContent'),
        variables?: map[string]ConfigValueFilesConfigVariablesValue(name='variables', description='The variables.'),
      }(name='config', description='The configuration to be modified.'),
      dirName?: string(name='dirName', description='The directory name.', example='/test'),
    }
  ](name='files', description='The files to be modified.'),
}

model BodyValue = {
  pauseAll?: boolean(name='pauseAll', description='Specifies whether to suspend all pushes.', example='true'),
  pauseIndex?: boolean(name='pauseIndex', description='Specifies whether to suspend the push for the new full index version.', example='true'),
  pauseIndexBatch?: boolean(name='pauseIndexBatch', description='Specifies whether to suspend the push for the incremental indexes.', example='true'),
  pauseBiz?: boolean(name='pauseBiz', description='Specifies whether to suspend the push for the configuration.', example='true'),
  pauseRuntime?: boolean(name='pauseRuntime', description='Specifies whether to suspend the push for the real-time incremental indexes.', example='true'),
}

model FilesConfigVariablesValue = {
  description?: string(name='description', description='The description of the variable.', example='Custom variable'),
  disableModify?: boolean(name='disableModify', description='Specifies whether the variable is not allowed to be modified.', example='true'),
  isModify?: boolean(name='isModify', description='Specifies whether the variable is modified.', example='true'),
  type?: string(name='type', description='The variable type. Valid values: NORMAL: common variable. FUNCTION: function variable.', example='NORMAL'),
  value?: string(name='value', description='The variable value.', example='test'),
}

model ConfigValueFilesConfigVariablesValue = {
  description?: string(name='description', description='The description of the variable.', example='test'),
  disableModify?: boolean(name='disableModify', description='Specifies whether the variable is not allowed to be modified.', example='true'),
  isModify?: boolean(name='isModify', description='Specifies whether the variable is modified.', example='false'),
  type?: string(name='type', description='The variable type. Valid values: NORMAL: common variable. FUNCTION: function variable.', example='NORMAL'),
  value?: string(name='value', description='The variable value.', example='test'),
}

model BuildIndexRequest {
  buildMode?: string(name='buildMode', description='The reindexing method. Valid values: api: API data source. indexRecover: data recovery by using indexing.', example='indexRecover'),
  dataSourceName?: string(name='dataSourceName', description='The name of the data source.', example='my_data_source'),
  dataSourceType?: string(name='dataSourceType', description='The type of the data source.', example='swift'),
  dataTimeSec?: int32(name='dataTimeSec', description='The timestamp in seconds. The value must be of the INTEGER type. This parameter is required if you specify an API data source.', example='1640867288'),
  domain?: string(name='domain', description='The data center in which the data source is deployed.', example='test'),
  generation?: long(name='generation', description='The data restoration version.', example='160131146'),
  partition?: string(name='partition', description='The partition in the MaxCompute table. This parameter is required if type is set to odps.', example='20201010'),
  tag?: string(name='tag'),
}

model BuildIndexResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='407BFD91-DE7D-50BA-8F88-CDE52A3B5E46'),
  result?: map[string]any(name='result', description='The list of clusters', example='{}'),
}

model BuildIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BuildIndexResponseBody(name='body'),
}

/**
 * @summary Triggers reindexing.
 *
 * @description ## Method
 *     POST
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/actions/build-index
 *
 * @param request BuildIndexRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BuildIndexResponse
 */
async function buildIndexWithOptions(instanceId: string, request: BuildIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BuildIndexResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.buildMode)) {
    body['buildMode'] = request.buildMode;
  }
  if (!Util.isUnset(request.dataSourceName)) {
    body['dataSourceName'] = request.dataSourceName;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    body['dataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.dataTimeSec)) {
    body['dataTimeSec'] = request.dataTimeSec;
  }
  if (!Util.isUnset(request.domain)) {
    body['domain'] = request.domain;
  }
  if (!Util.isUnset(request.generation)) {
    body['generation'] = request.generation;
  }
  if (!Util.isUnset(request.partition)) {
    body['partition'] = request.partition;
  }
  if (!Util.isUnset(request.tag)) {
    body['tag'] = request.tag;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BuildIndex',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/actions/build-index`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Triggers reindexing.
 *
 * @description ## Method
 *     POST
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/actions/build-index
 *
 * @param request BuildIndexRequest
 * @return BuildIndexResponse
 */
async function buildIndex(instanceId: string, request: BuildIndexRequest): BuildIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return buildIndexWithOptions(instanceId, request, headers, runtime);
}

model ChangeResourceGroupRequest {
  newResourceGroupId?: string(name='newResourceGroupId', description='new resource group id', example='rg-acfmxr3gs*****'),
  resourceType?: string(name='resourceType', description='The resource type.', example='instance'),
}

model ChangeResourceGroupResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='10D5E615-69F7-5F49-B850-00169ADE513C'),
}

model ChangeResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeResourceGroupResponseBody(name='body'),
}

/**
 * @summary 更换实例资源组
 *
 * @param request ChangeResourceGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeResourceGroupResponse
 */
async function changeResourceGroupWithOptions(instanceId: string, request: ChangeResourceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ChangeResourceGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.newResourceGroupId)) {
    body['newResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['resourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ChangeResourceGroup',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/actions/change-resource-group`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 更换实例资源组
 *
 * @param request ChangeResourceGroupRequest
 * @return ChangeResourceGroupResponse
 */
async function changeResourceGroup(instanceId: string, request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return changeResourceGroupWithOptions(instanceId, request, headers, runtime);
}

model CloneSqlInstanceRequest {
  name?: string(name='name', description='This parameter is required.', example='test'),
  targetFolderId?: long(name='targetFolderId', description='This parameter is required.', example='1'),
}

model CloneSqlInstanceResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='10D5E615-69F7-5F49-B850-00169ADE513C'),
  result?: {
    gmtCreate?: string(name='gmtCreate', example='1719221186114'),
    gmtModified?: string(name='gmtModified', example='1719221186114'),
    id?: long(name='id', example='1'),
    instanceId?: long(name='instanceId', example='-cn-pl32rf0****'),
    isDir?: int32(name='isDir', example='True'),
    name?: string(name='name', example='general'),
    parent?: long(name='parent', example='1'),
    templateId?: long(name='templateId', example='1'),
    type?: string(name='type', description='table, instance, template, function', example='instance'),
  }(name='result', description='NodeVO'),
}

model CloneSqlInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloneSqlInstanceResponseBody(name='body'),
}

/**
 * @param request CloneSqlInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CloneSqlInstanceResponse
 */
async function cloneSqlInstanceWithOptions(instanceId: string, database: string, sqlInstanceId: string, request: CloneSqlInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CloneSqlInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.targetFolderId)) {
    body['targetFolderId'] = request.targetFolderId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CloneSqlInstance',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/sql-studio/databases/${OpenApiUtil.getEncodeParam(database)}/sql-instances/${OpenApiUtil.getEncodeParam(sqlInstanceId)}/actions/clone`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request CloneSqlInstanceRequest
 * @return CloneSqlInstanceResponse
 */
async function cloneSqlInstance(instanceId: string, database: string, sqlInstanceId: string, request: CloneSqlInstanceRequest): CloneSqlInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cloneSqlInstanceWithOptions(instanceId, database, sqlInstanceId, request, headers, runtime);
}

model CreateAliasRequest {
  alias?: string(name='alias', description='alias name', example='test'),
  index?: string(name='index', description='index name', example='index'),
  newMode?: boolean(name='newMode', description='Specifies whether the OpenSearch Vector Search Edition instance is of the new version.', example='true'),
}

model CreateAliasResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='10D5E615-69F7-5F49-B850-00169ADE513C'),
  result?: map[string]any(name='result', description='Map', example='{}'),
}

model CreateAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAliasResponseBody(name='body'),
}

/**
 * @param request CreateAliasRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAliasResponse
 */
async function createAliasWithOptions(instanceId: string, request: CreateAliasRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAliasResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.newMode)) {
    query['newMode'] = request.newMode;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.alias)) {
    body['alias'] = request.alias;
  }
  if (!Util.isUnset(request.index)) {
    body['index'] = request.index;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlias',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/aliases`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request CreateAliasRequest
 * @return CreateAliasResponse
 */
async function createAlias(instanceId: string, request: CreateAliasRequest): CreateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAliasWithOptions(instanceId, request, headers, runtime);
}

model CreateClusterRequest {
  autoLoad?: boolean(name='autoLoad', description='Specifies whether to enable automatic connection.', example='true'),
  dataNode?: {
    number?: int32(name='number', description='The number of Searcher workers.', example='2'),
    partition?: string(name='partition', description='The number of shards.', example='2'),
  }(name='dataNode', description='The details of the Searcher workers.'),
  description?: string(name='description', description='The description of the cluster.', example='"ha-tets"'),
  name?: string(name='name', description='The cluster name.', example='ha-cn-zvp2qr1sk01_qrs'),
  queryNode?: {
    number?: int32(name='number', description='The number of QRS workers.', example='2'),
  }(name='queryNode', description='The details of the Query Result Searcher (QRS) workers.'),
}

model CreateClusterResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='10D5E615-69F7-5F49-B850-00169ADE513C'),
  result?: map[string]any(name='result', description='The result.', example='{}'),
}

model CreateClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateClusterResponseBody(name='body'),
}

/**
 * @summary Creates a cluster.
 *
 * @description ### [](#method)Method
 * `POST`
 * ### [](#uri)URI
 * `/openapi/ha3/instances/{instanceId}/clusters`
 *
 * @param request CreateClusterRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateClusterResponse
 */
async function createClusterWithOptions(instanceId: string, request: CreateClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoLoad)) {
    body['autoLoad'] = request.autoLoad;
  }
  if (!Util.isUnset(request.dataNode)) {
    body['dataNode'] = request.dataNode;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.queryNode)) {
    body['queryNode'] = request.queryNode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCluster',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/clusters`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a cluster.
 *
 * @description ### [](#method)Method
 * `POST`
 * ### [](#uri)URI
 * `/openapi/ha3/instances/{instanceId}/clusters`
 *
 * @param request CreateClusterRequest
 * @return CreateClusterResponse
 */
async function createCluster(instanceId: string, request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createClusterWithOptions(instanceId, request, headers, runtime);
}

model CreateConfigDirRequest {
  dirName?: string(name='dirName', description='The directory name.', example='/clusters'),
  parentFullPath?: string(name='parentFullPath', description='The path of the parent directory.', example='/'),
}

model CreateConfigDirResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='E7B7D598-B080-5C8E-AA35-D43EC0D5F886'),
  result?: map[string]any(name='result', description='The result.', example='{}'),
}

model CreateConfigDirResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateConfigDirResponseBody(name='body'),
}

/**
 * @param request CreateConfigDirRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConfigDirResponse
 */
async function createConfigDirWithOptions(instanceId: string, configName: string, request: CreateConfigDirRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateConfigDirResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dirName)) {
    body['dirName'] = request.dirName;
  }
  if (!Util.isUnset(request.parentFullPath)) {
    body['parentFullPath'] = request.parentFullPath;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConfigDir',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/advanced-configs/${OpenApiUtil.getEncodeParam(configName)}/dir`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request CreateConfigDirRequest
 * @return CreateConfigDirResponse
 */
async function createConfigDir(instanceId: string, configName: string, request: CreateConfigDirRequest): CreateConfigDirResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createConfigDirWithOptions(instanceId, configName, request, headers, runtime);
}

model CreateConfigFileRequest {
  fileName?: string(name='fileName', description='The name of the directory.', example='/schemas/device_event_xt_schema.json'),
  ossPath?: string(name='ossPath', description='The Object Storage Service (OSS) URL of the file.', example='oss://xxx/xxxx/xxx'),
  parentFullPath?: string(name='parentFullPath', description='The path of the parent directory.', example='/'),
}

model CreateConfigFileResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='FE03180A-0E29-5474-8A86-33F0683294A4'),
  result?: map[string]any(name='result', description='The result.', example='{}'),
}

model CreateConfigFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateConfigFileResponseBody(name='body'),
}

/**
 * @param request CreateConfigFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConfigFileResponse
 */
async function createConfigFileWithOptions(instanceId: string, configName: string, request: CreateConfigFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateConfigFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fileName)) {
    body['fileName'] = request.fileName;
  }
  if (!Util.isUnset(request.ossPath)) {
    body['ossPath'] = request.ossPath;
  }
  if (!Util.isUnset(request.parentFullPath)) {
    body['parentFullPath'] = request.parentFullPath;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConfigFile',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/advanced-configs/${OpenApiUtil.getEncodeParam(configName)}/file`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request CreateConfigFileRequest
 * @return CreateConfigFileResponse
 */
async function createConfigFile(instanceId: string, configName: string, request: CreateConfigFileRequest): CreateConfigFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createConfigFileWithOptions(instanceId, configName, request, headers, runtime);
}

model CreateDataSourceRequest {
  autoBuildIndex?: boolean(name='autoBuildIndex', description='Specifies whether to automatically rebuild the index.', example='true'),
  config?: {
    accessKey?: string(name='accessKey', description='The AccessKey ID of the MaxCompute data source.', example='L***p'),
    accessSecret?: string(name='accessSecret', description='The AccessKey secret of the MaxCompute data source.', example='5**9a6'),
    bucket?: string(name='bucket', description='The name of the OSS bucket.', example='opensearch'),
    catalog?: string(name='catalog'),
    database?: string(name='database'),
    endpoint?: string(name='endpoint', description='The endpoint of the MaxCompute or Object Storage Service (OSS) data source.', example='http://service.cn-hangzhou.maxcompute.aliyun-inc.com/api'),
    namespace?: string(name='namespace', description='The namespace.', example='aegis-ops'),
    ossPath?: string(name='ossPath', description='The path of the OSS object.', example='/opensearch/search'),
    partition?: string(name='partition', description='The partition in the MaxCompute table.', example='ds=20220713'),
    path?: string(name='path', description='The file path in the Apsara File Storage for HDFS file system.', example='test-hdfs-path'),
    project?: string(name='project', description='The name of the MaxCompute project that is used as the data source.', example='kubenest'),
    table?: string(name='table', description='The name of the MaxCompute table that is used as the data source.', example='item'),
    tag?: string(name='tag'),
  }(name='config', description='The configuration information.'),
  domain?: string(name='domain', description='The data center in which the data source is deployed.', example='vpc_hz_domain_1'),
  name?: string(name='name', description='The name of the data source.', example='ha-cn-pl32rf0****_test_api'),
  saroConfig?: {
    namespace?: string(name='namespace', description='The namespace of the SARO data source.', example='igraph-cn-x0r3e3abe02'),
    tableName?: string(name='tableName', description='The name of the SARO table.', example='index_hdfs'),
  }(name='saroConfig', description='The configurations of the SARO data source.'),
  type?: string(name='type', description='The type of the data source. Valid values: odps, oss, and swift.', example='odps'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a dry run. This parameter is only used to check whether the data source is valid. Valid values: true and false.', example='true'),
}

model CreateDataSourceResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='10D5E615-69F7-5F49-B850-00169ADE513C'),
  result?: map[string]any(name='result', description='The returned results.', example='{}'),
}

model CreateDataSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDataSourceResponseBody(name='body'),
}

/**
 * @summary Creates data sources.
 *
 * @param request CreateDataSourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDataSourceResponse
 */
async function createDataSourceWithOptions(instanceId: string, request: CreateDataSourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDataSourceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.autoBuildIndex)) {
    body['autoBuildIndex'] = request.autoBuildIndex;
  }
  if (!Util.isUnset(request.config)) {
    body['config'] = request.config;
  }
  if (!Util.isUnset(request.domain)) {
    body['domain'] = request.domain;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.saroConfig)) {
    body['saroConfig'] = request.saroConfig;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataSource',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/data-sources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates data sources.
 *
 * @param request CreateDataSourceRequest
 * @return CreateDataSourceResponse
 */
async function createDataSource(instanceId: string, request: CreateDataSourceRequest): CreateDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDataSourceWithOptions(instanceId, request, headers, runtime);
}

model CreateFolderRequest {
  name?: string(name='name', description='This parameter is required.', example='gist_qc'),
  parent?: long(name='parent', description='This parameter is required.', example='1'),
  type?: string(name='type', description='table, instance, template, function

This parameter is required.', example='instance'),
}

model CreateFolderResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='E7B7D598-B080-5C8E-AA35-D43EC0D5F886'),
  result?: {
    gmtCreate?: string(name='gmtCreate', example='1719221186114'),
    gmtModified?: string(name='gmtModified', example='1719221186114'),
    id?: long(name='id', example='25030'),
    instanceId?: long(name='instanceId', example='ha-cn-pl32rf0****'),
    isDir?: int32(name='isDir', example='True'),
    name?: string(name='name', example='test'),
    parent?: long(name='parent', example='-1'),
    templateId?: long(name='templateId', example='1'),
    type?: string(name='type', description='table, instance, template, function', example='instance'),
  }(name='result', description='NodeVO'),
}

model CreateFolderResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFolderResponseBody(name='body'),
}

/**
 * @param request CreateFolderRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFolderResponse
 */
async function createFolderWithOptions(instanceId: string, database: string, request: CreateFolderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFolderResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.parent)) {
    body['parent'] = request.parent;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFolder',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/sql-studio/databases/${OpenApiUtil.getEncodeParam(database)}/folders`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request CreateFolderRequest
 * @return CreateFolderResponse
 */
async function createFolder(instanceId: string, database: string, request: CreateFolderRequest): CreateFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFolderWithOptions(instanceId, database, request, headers, runtime);
}

model CreateIndexRequest {
  buildParallelNum?: int32(name='buildParallelNum', description='The maximum number of full indexes that can be concurrently built.', example='2'),
  content?: string(name='content', description='The index schema.', example='{\\\\"summarys\\\\":{\\\\"summary_fields\\\\":[\\\\"id\\\\"]},\\\\"indexs\\\\":[{\\\\"index_name\\\\":\\\\"index_id\\\\",\\\\"index_type\\\\":\\\\"PRIMARYKEY64\\\\",\\\\"index_fields\\\\":\\\\"id\\\\",\\\\"has_primary_key_attribute\\\\":true,\\\\"is_primary_key_sorted\\\\":false}],\\\\"attributes\\\\":[\\\\"id\\\\"],\\\\"fields\\\\":[{\\\\"field_name\\\\":\\\\"id\\\\",\\\\"field_type\\\\":\\\\"UINT16\\\\"}],\\\\"table_name\\\\":\\\\"index_2\\\\"}'),
  dataSource?: string(name='dataSource', description='The name of the data source.', example='test1'),
  dataSourceInfo?: {
    autoBuildIndex?: boolean(name='autoBuildIndex', description='Specifies whether to enable automatic full indexing.', example='true'),
    config?: {
      accessKey?: string(name='accessKey', description='The AccessKey ID of the MaxCompute data source.', example='L***p'),
      accessSecret?: string(name='accessSecret', description='The AccessKey secret of the MaxCompute data source.', example='5**9a6'),
      bucket?: string(name='bucket', description='The name of the OSS bucket.', example='test-bucket'),
      catalog?: string(name='catalog'),
      database?: string(name='database'),
      endpoint?: string(name='endpoint', description='The endpoint of the MaxCompute or Object Storage Service (OSS) data source.', example='https://oss-cn-hangzhou.aliyuncs.com'),
      format?: string(name='format'),
      namespace?: string(name='namespace', description='The namespace name.', example='test-namespace'),
      ossPath?: string(name='ossPath', description='The path of the OSS object.', example='/opensearch/oss.json'),
      partition?: string(name='partition', description='The partition in the MaxCompute table. This parameter is required if type is set to odps.', example='ds=20230114'),
      path?: string(name='path', description='The path of the Apsara File Storage for HDFS data source.', example='test-hdfs-path'),
      project?: string(name='project', description='The name of the MaxCompute project that is used as the data source.', example='bbt_algo_pai'),
      table?: string(name='table', description='The table name.', example='bbt_rec_swing_u2i2i_score_be_v1'),
      tag?: string(name='tag'),
    }(name='config', description='The information about the MaxCompute data source.'),
    dataTimeSec?: int32(name='dataTimeSec', description='The start timestamp from which incremental data is retrieved.', example='1709715164'),
    domain?: string(name='domain', description='The data center in which the data source is deployed.', example='vpc_hz_domain_1'),
    name?: string(name='name', description='The name of the data source.', example='ha-cn-35t3n1yuj0d_index_1'),
    processParallelNum?: int32(name='processParallelNum', description='The maximum number of full indexes that can be concurrently processed.', example='2'),
    processPartitionCount?: int32(name='processPartitionCount', description='The number of resources used for data update.', example='4'),
    saroConfig?: {
      namespace?: string(name='namespace', description='The namespace of the SARO data source.', example='flink-test-fjx-default'),
      tableName?: string(name='tableName', description='The name of the SARO table.', example='device_event_shy_summary_'),
    }(name='saroConfig', description='The configurations of the SARO data source.'),
    type?: string(name='type', description='The type of the data source. Valid values:

*   odps
*   swift
*   saro
*   oss', example='odps'),
  }(name='dataSourceInfo', description='The information about the data source. This parameter is required for an OpenSearch Vector Search Edition instance of the new version.'),
  domain?: string(name='domain', description='The data center in which the data source is deployed.', example='vpc_hz_domain_1'),
  extend?: map[string]any(name='extend', description='The extended content of the field configuration. key specifies the vector field and the field that requires embedding.', example='{
        "vector":
        [
            "source_image_vector"
        ],
        "embeding":
        [
            "source_image"
        ],
        "description":
        []
    }'),
  mergeParallelNum?: int32(name='mergeParallelNum', description='The maximum number of full indexes that can be concurrently merged.', example='2'),
  name?: string(name='name', description='The index name.', example='ha-cn-zvp2qr1sk01_qrs'),
  partition?: int32(name='partition', description='The number of data shards.', example='20211202'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. The system only checks the validity of the data source. Valid values:

*   true
*   false', example='true'),
}

model CreateIndexResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='407BFD91-DE7D-50BA-8F88-CDE52A3B5E46'),
  result?: map[string]any(name='result', description='The results returned.', example='{}'),
}

model CreateIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateIndexResponseBody(name='body'),
}

/**
 * @summary Creates an index.
 *
 * @description ### Method
 * ```java
 * POST
 * ```
 * ### URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/indexes
 * ```
 *
 * @param request CreateIndexRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIndexResponse
 */
async function createIndexWithOptions(instanceId: string, request: CreateIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIndexResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.buildParallelNum)) {
    body['buildParallelNum'] = request.buildParallelNum;
  }
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }
  if (!Util.isUnset(request.dataSource)) {
    body['dataSource'] = request.dataSource;
  }
  if (!Util.isUnset(request.dataSourceInfo)) {
    body['dataSourceInfo'] = request.dataSourceInfo;
  }
  if (!Util.isUnset(request.domain)) {
    body['domain'] = request.domain;
  }
  if (!Util.isUnset(request.extend)) {
    body['extend'] = request.extend;
  }
  if (!Util.isUnset(request.mergeParallelNum)) {
    body['mergeParallelNum'] = request.mergeParallelNum;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.partition)) {
    body['partition'] = request.partition;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIndex',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/indexes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an index.
 *
 * @description ### Method
 * ```java
 * POST
 * ```
 * ### URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/indexes
 * ```
 *
 * @param request CreateIndexRequest
 * @return CreateIndexResponse
 */
async function createIndex(instanceId: string, request: CreateIndexRequest): CreateIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIndexWithOptions(instanceId, request, headers, runtime);
}

model CreateInstanceRequest {
  chargeType?: string(name='chargeType', description='The billing method of the instance. Valid values: PREPAY: subscription. If you set this parameter to PREPAY, make sure that your Alibaba Cloud account supports balance payment or credit card payment. Otherwise, the system returns the InvalidPayMethod error message. If you set this parameter to PREPAY, you must also specify paymentInfo. POSTPAY: pay-as-you-go. This billing method is not supported.', example='""'),
  components?: [ 
    {
      code?: string(name='code', description='The code of the specification, which must be consistent with the value that you specify on the buy page.', example='""'),
      value?: string(name='value', description='The value of the specification.', example='""'),
    }
  ](name='components', description='The information about the instance specification.'),
  order?: {
    autoRenew?: boolean(name='autoRenew', description='Specifies whether to enable auto-renewal. Valid values: true and false.', example='true'),
    duration?: long(name='duration', description='The billing duration. Valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, and 12.', example='29'),
    pricingCycle?: string(name='pricingCycle', description='The unit of the billing duration. Valid values: Month and Year.', example='""'),
  }(name='order', description='The billing information.'),
  resourceGroupId?: string(name='resourceGroupId'),
  tags?: [ 
    {
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='tags'),
}

model CreateInstanceResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request', example='D39EE0F1-D7EF-5F46-B781-6BF4185308B0'),
  result?: {
    instanceId?: string(name='instanceId', description='The instance ID.', example='ha-cn-2r42ppr7901'),
  }(name='result', description='The results returned.'),
}

model CreateInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateInstanceResponseBody(name='body'),
}

/**
 * @summary Creates a Havenask instance.
 *
 * @description ### [](#)Method
 * `POST`
 * ### [](#uri)URI
 * `/api/instances?dryRun=false`
 *
 * @param request CreateInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateInstanceResponse
 */
async function createInstanceWithOptions(request: CreateInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chargeType)) {
    body['chargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.components)) {
    body['components'] = request.components;
  }
  if (!Util.isUnset(request.order)) {
    body['order'] = request.order;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateInstance',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a Havenask instance.
 *
 * @description ### [](#)Method
 * `POST`
 * ### [](#uri)URI
 * `/api/instances?dryRun=false`
 *
 * @param request CreateInstanceRequest
 * @return CreateInstanceResponse
 */
async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createInstanceWithOptions(request, headers, runtime);
}

model CreateModelRequest {
  content?: {
    dimension?: int32(name='dimension', example='128'),
    method?: string(name='method', example='POST'),
    modelType?: string(name='modelType', example='text_embedding'),
    request?: {
      header?: {
        authorization?: string(name='Authorization', example='Bearer OS-v0********6vvs'),
        contentType?: string(name='Content-Type', example='application/json'),
      }(name='header'),
      parameters?: {
        build?: {
          inputType?: string(name='input_type', example='query'),
        }(name='build'),
        search?: {
          inputType?: string(name='input_type', example='document'),
        }(name='search'),
      }(name='parameters'),
      requestBody?: string(name='requestBody', example='{\\\\"input\\\\": [\\\\"%{input}\\\\"], \\\\"input_type\\\\": \\\\"%{input_type}\\\\"}'),
      urlParams?: {
        build?: map[string]any(name='build', example='key: value'),
        search?: map[string]any(name='search', example='key: value'),
      }(name='urlParams'),
    }(name='request'),
    response?: {
      embeddings?: string(name='embeddings', example='$.result.embeddings[*].embedding'),
    }(name='response'),
    url?: string(name='url', example='http://***.platform-cn-shanghai.opensearch.aliyuncs.com/v3/openapi/workspaces/default/text-embedding/ops-text-embedding-001'),
  }(name='content'),
  name?: string(name='name', description='This parameter is required.', example='test'),
  dryRun?: string(name='dryRun', example='true'),
}

model CreateModelResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='022F36C7-9FB4-5D67-BEBC-3D14B0984463'),
}

model CreateModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateModelResponseBody(name='body'),
}

/**
 * @summary 创建模型信息
 *
 * @param request CreateModelRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateModelResponse
 */
async function createModelWithOptions(instanceId: string, request: CreateModelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateModelResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateModel',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/models`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 创建模型信息
 *
 * @param request CreateModelRequest
 * @return CreateModelResponse
 */
async function createModel(instanceId: string, request: CreateModelRequest): CreateModelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createModelWithOptions(instanceId, request, headers, runtime);
}

model CreatePublicUrlResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='022F36C7-9FB4-5D67-BEBC-3D14B0984463'),
  result?: map[string]any(name='result', description='The result.', example='{}'),
}

model CreatePublicUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePublicUrlResponseBody(name='body'),
}

/**
 * @summary Creates a public endpoint.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePublicUrlResponse
 */
async function createPublicUrlWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePublicUrlResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CreatePublicUrl',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/public-url`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a public endpoint.
 *
 * @return CreatePublicUrlResponse
 */
async function createPublicUrl(instanceId: string): CreatePublicUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPublicUrlWithOptions(instanceId, headers, runtime);
}

model CreateSqlInstanceRequest {
  name?: string(name='name', description='This parameter is required.', example='test'),
  parent?: long(name='parent', description='This parameter is required.', example='-1'),
}

model CreateSqlInstanceResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='B43CD1BB-ABD7-59C5-B89A-6E5F6FE60A84'),
  result?: {
    gmtCreate?: string(name='gmtCreate', example='1719220182844'),
    gmtModified?: string(name='gmtModified', example='1719220182844'),
    id?: long(name='id', example='22'),
    instanceId?: long(name='instanceId', example='ha-cn-pl32rf0****'),
    isDir?: int32(name='isDir', example='true'),
    name?: string(name='name', example='test'),
    parent?: long(name='parent', example='-1'),
    templateId?: long(name='templateId', example='1'),
    type?: string(name='type', description='table, instance, template, function', example='instance'),
  }(name='result', description='NodeVO'),
}

model CreateSqlInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSqlInstanceResponseBody(name='body'),
}

/**
 * @param request CreateSqlInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSqlInstanceResponse
 */
async function createSqlInstanceWithOptions(instanceId: string, database: string, request: CreateSqlInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSqlInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.parent)) {
    body['parent'] = request.parent;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSqlInstance',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/sql-studio/databases/${OpenApiUtil.getEncodeParam(database)}/sql-instances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request CreateSqlInstanceRequest
 * @return CreateSqlInstanceResponse
 */
async function createSqlInstance(instanceId: string, database: string, request: CreateSqlInstanceRequest): CreateSqlInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSqlInstanceWithOptions(instanceId, database, request, headers, runtime);
}

model CreateTableRequest {
  dataProcessConfig?: [ 
    {
      dstField?: string(name='dstField', description='The destination field.', example='source_image_vector'),
      operator?: string(name='operator', description='The method used to process the field. Valid values: copy and vectorize. A value of copy specifies that the value of the source field is copied to the destination field. A value of vectorize specifies that the value of the source field is vectorized by a vectorization model and the output vector is stored in the destination field.', example='vectorize'),
      params?: {
        srcFieldConfig?: {
          ossBucket?: string(name='ossBucket', description='The OSS bucket.', example='test'),
          ossEndpoint?: string(name='ossEndpoint', description='The OSS endpoint.', example='oss-cn-hangzhou-internal.aliyuncs.com'),
          uid?: string(name='uid', description='The ID of the Alibaba Cloud account.', example='uid'),
        }(name='srcFieldConfig', description='The source of the data to be vectorized.'),
        vectorModal?: string(name='vectorModal', description='The data type.', example='image'),
        vectorModel?: string(name='vectorModel', description='The vectorization model.', example='clip'),
      }(name='params', description='The information about the model.'),
      srcField?: string(name='srcField', description='The source field.', example='source_image'),
    }
  ](name='dataProcessConfig', description='The configurations about field processing.'),
  dataProcessorCount?: int32(name='dataProcessorCount', description='The number of resources used for data update.', example='1'),
  dataSource?: {
    autoBuildIndex?: boolean(name='autoBuildIndex', description='Specifies whether to automatically rebuild the index.', example='true'),
    config?: {
      accessKey?: string(name='accessKey', description='The AccessKey ID of the MaxCompute data source.', example='ak'),
      accessSecret?: string(name='accessSecret', description='The AccessKey secret of the MaxCompute data source.', example='as'),
      bucket?: string(name='bucket', description='The OSS bucket.', example='antsys-flytest-ci'),
      catalog?: string(name='catalog'),
      database?: string(name='database'),
      endpoint?: string(name='endpoint', description='The endpoint of the MaxCompute data source.', example='http://service.cn-hangzhou.maxcompute.aliyun-inc.com/api'),
      ossPath?: string(name='ossPath', description='The Object Storage Service (OSS) path.', example='oss://opensearch'),
      partition?: string(name='partition', description='The partition in the MaxCompute table. This parameter is required if type is set to odps.', example='ds=20220713'),
      project?: string(name='project', description='The name of the MaxCompute project that is used as the data source.', example='project_20210220122847_3218'),
      table?: string(name='table', description='The name of the MaxCompute table that is used as the data source.', example='test56'),
      tag?: string(name='tag'),
    }(name='config', description='The configurations of the data source.'),
    dataTimeSec?: int32(name='dataTimeSec', description='The start timestamp from which incremental data is retrieved.', example='1715160176'),
    type?: string(name='type', description='The data source type. Valid values: odps, swift, and oss.', example='odps'),
  }(name='dataSource', description='The configurations of the data source.'),
  fieldSchema?: map[string]string(name='fieldSchema', description='The fields.'),
  name?: string(name='name', description='The index name.', example='index_1'),
  partitionCount?: int32(name='partitionCount', description='The number of data shards.', example='1'),
  primaryKey?: string(name='primaryKey', description='The primary key field.', example='id'),
  rawSchema?: string(name='rawSchema', description='The instance schema. If this parameter is specified, the parameters about the index are not required.', example='{}'),
  vectorIndex?: [ 
    {
      advanceParams?: {
        buildIndexParams?: string(name='buildIndexParams', description='The index building parameters.', example='{}'),
        linearBuildThreshold?: string(name='linearBuildThreshold', description='The threshold for linear building.', example='5000'),
        minScanDocCnt?: string(name='minScanDocCnt', description='The minimum number of retrieved candidate sets.', example='20000'),
        searchIndexParams?: string(name='searchIndexParams', description='The index retrieval parameters.', example='{}'),
      }(name='advanceParams', description='The configurations of the index schema.'),
      dimension?: string(name='dimension', description='The dimension of the vector.', example='128'),
      distanceType?: string(name='distanceType', description='The distance type.', example='SquaredEuclidean'),
      indexName?: string(name='indexName', description='The name of the index schema.', example='case_index'),
      namespace?: string(name='namespace', description='The namespace field.', example='namespace'),
      sparseIndexField?: string(name='sparseIndexField', description='The field that stores the indexes of the elements in sparse vectors.', example='sparse_indices'),
      sparseValueField?: string(name='sparseValueField', description='The field that stores the elements in sparse vectors.', example='sparse_values'),
      vectorField?: string(name='vectorField', description='The vector field.', example='source_image_vector'),
      vectorIndexType?: string(name='vectorIndexType', description='The vector retrieval algorithm.', example='Qc'),
    }
  ](name='vectorIndex', description='The index schema.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. The system only checks the validity of the data source. Valid values:

*   true
*   false', example='true'),
}

model CreateTableResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='2AE63638-5420-56DC-BF59-37D8174039A0'),
  result?: map[string]any(name='result', description='Map', example='{}'),
}

model CreateTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTableResponseBody(name='body'),
}

/**
 * @summary Creates an index table.
 *
 * @param request CreateTableRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTableResponse
 */
async function createTableWithOptions(instanceId: string, request: CreateTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTableResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.dataProcessConfig)) {
    body['dataProcessConfig'] = request.dataProcessConfig;
  }
  if (!Util.isUnset(request.dataProcessorCount)) {
    body['dataProcessorCount'] = request.dataProcessorCount;
  }
  if (!Util.isUnset(request.dataSource)) {
    body['dataSource'] = request.dataSource;
  }
  if (!Util.isUnset(request.fieldSchema)) {
    body['fieldSchema'] = request.fieldSchema;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.partitionCount)) {
    body['partitionCount'] = request.partitionCount;
  }
  if (!Util.isUnset(request.primaryKey)) {
    body['primaryKey'] = request.primaryKey;
  }
  if (!Util.isUnset(request.rawSchema)) {
    body['rawSchema'] = request.rawSchema;
  }
  if (!Util.isUnset(request.vectorIndex)) {
    body['vectorIndex'] = request.vectorIndex;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTable',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/tables`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an index table.
 *
 * @param request CreateTableRequest
 * @return CreateTableResponse
 */
async function createTable(instanceId: string, request: CreateTableRequest): CreateTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTableWithOptions(instanceId, request, headers, runtime);
}

model DebugModelRequest {
  input?: string(name='input'),
  isOnline?: string(name='isOnline', example='true'),
}

model DebugModelResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='E7B7D598-B080-5C8E-AA35-D43EC0D5F886'),
}

model DebugModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DebugModelResponseBody(name='body'),
}

/**
 * @summary 调试模型
 *
 * @param request DebugModelRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DebugModelResponse
 */
async function debugModelWithOptions(instanceId: string, modelName: string, request: DebugModelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DebugModelResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.isOnline)) {
    query['isOnline'] = request.isOnline;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.input)) {
    body['input'] = request.input;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DebugModel',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/models/${OpenApiUtil.getEncodeParam(modelName)}/actions/debug`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 调试模型
 *
 * @param request DebugModelRequest
 * @return DebugModelResponse
 */
async function debugModel(instanceId: string, modelName: string, request: DebugModelRequest): DebugModelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return debugModelWithOptions(instanceId, modelName, request, headers, runtime);
}

model DeleteAdvanceConfigResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='E7B7D598-B080-5C8E-AA35-D43EC0D5F886'),
  result?: map[string]any(name='result', description='The result.', example='{}'),
}

model DeleteAdvanceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAdvanceConfigResponseBody(name='body'),
}

/**
 * @summary Deletes the details about advanced configurations.
 *
 * @description ## Method
 *     DELETE
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/advanced-configs/{configName}
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAdvanceConfigResponse
 */
async function deleteAdvanceConfigWithOptions(instanceId: string, configName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAdvanceConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAdvanceConfig',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/advanced-configs/${OpenApiUtil.getEncodeParam(configName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes the details about advanced configurations.
 *
 * @description ## Method
 *     DELETE
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/advanced-configs/{configName}
 *
 * @return DeleteAdvanceConfigResponse
 */
async function deleteAdvanceConfig(instanceId: string, configName: string): DeleteAdvanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAdvanceConfigWithOptions(instanceId, configName, headers, runtime);
}

model DeleteAliasResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='FE03180A-0E29-5474-8A86-33F0683294A4'),
  result?: map[string]any(name='result', description='Map', example='{}'),
}

model DeleteAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAliasResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAliasResponse
 */
async function deleteAliasWithOptions(instanceId: string, alias: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAliasResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlias',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/aliases/${OpenApiUtil.getEncodeParam(alias)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @return DeleteAliasResponse
 */
async function deleteAlias(instanceId: string, alias: string): DeleteAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAliasWithOptions(instanceId, alias, headers, runtime);
}

model DeleteConfigDirRequest {
  dirName?: string(name='dirName', description='The directory name.

This parameter is required.', example='/clusters'),
  parentFullPath?: string(name='parentFullPath', description='The path of the parent directory.

This parameter is required.', example='/'),
}

model DeleteConfigDirResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='F43E8AB4-419C-5F4C-90D6-615590DFAA3C'),
  result?: map[string]any(name='result', description='The result.', example='{}'),
}

model DeleteConfigDirResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteConfigDirResponseBody(name='body'),
}

/**
 * @param request DeleteConfigDirRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConfigDirResponse
 */
async function deleteConfigDirWithOptions(instanceId: string, configName: string, request: DeleteConfigDirRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConfigDirResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dirName)) {
    query['dirName'] = request.dirName;
  }
  if (!Util.isUnset(request.parentFullPath)) {
    query['parentFullPath'] = request.parentFullPath;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteConfigDir',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/advanced-configs/${OpenApiUtil.getEncodeParam(configName)}/dir`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request DeleteConfigDirRequest
 * @return DeleteConfigDirResponse
 */
async function deleteConfigDir(instanceId: string, configName: string, request: DeleteConfigDirRequest): DeleteConfigDirResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConfigDirWithOptions(instanceId, configName, request, headers, runtime);
}

model DeleteConfigFileRequest {
  fileName?: string(name='fileName', description='The file name.

This parameter is required.', example='/schemas/automobile_vector_schema.json'),
  parentFullPath?: string(name='parentFullPath', description='The path of the parent directory.

This parameter is required.', example='/'),
}

model DeleteConfigFileResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='10D5E615-69F7-5F49-B850-00169ADE513C'),
  result?: map[string]any(name='result', description='The result.', example='{}'),
}

model DeleteConfigFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteConfigFileResponseBody(name='body'),
}

/**
 * @param request DeleteConfigFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConfigFileResponse
 */
async function deleteConfigFileWithOptions(instanceId: string, configName: string, request: DeleteConfigFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConfigFileResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.fileName)) {
    query['fileName'] = request.fileName;
  }
  if (!Util.isUnset(request.parentFullPath)) {
    query['parentFullPath'] = request.parentFullPath;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteConfigFile',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/advanced-configs/${OpenApiUtil.getEncodeParam(configName)}/file`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request DeleteConfigFileRequest
 * @return DeleteConfigFileResponse
 */
async function deleteConfigFile(instanceId: string, configName: string, request: DeleteConfigFileRequest): DeleteConfigFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConfigFileWithOptions(instanceId, configName, request, headers, runtime);
}

model DeleteDataSourceResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request', example='10D5E615-69F7-5F49-B850-00169ADE513C'),
  result?: map[string]any(name='result', description='The result returned', example='{}'),
}

model DeleteDataSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDataSourceResponseBody(name='body'),
}

/**
 * @summary Deletes a specified data source.
 *
 * @description ## Method
 * `DELETE`
 * ## URI
 * `/openapi/ha3/instances/{instanceId}/data-sources/{dataSourceName}`
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDataSourceResponse
 */
async function deleteDataSourceWithOptions(instanceId: string, dataSourceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDataSourceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataSource',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/data-sources/${OpenApiUtil.getEncodeParam(dataSourceName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a specified data source.
 *
 * @description ## Method
 * `DELETE`
 * ## URI
 * `/openapi/ha3/instances/{instanceId}/data-sources/{dataSourceName}`
 *
 * @return DeleteDataSourceResponse
 */
async function deleteDataSource(instanceId: string, dataSourceName: string): DeleteDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDataSourceWithOptions(instanceId, dataSourceName, headers, runtime);
}

model DeleteFolderResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='022F36C7-9FB4-5D67-BEBC-3D14B0984463'),
  result?: {
    requestId?: string(name='requestId', description='The request ID.', example='022F36C7-9FB4-5D67-BEBC-3D14B0984463'),
    result?: map[string]string(name='result', description='The result'),
  }(name='result', description='Response<Map<String, String>>'),
}

model DeleteFolderResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFolderResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFolderResponse
 */
async function deleteFolderWithOptions(instanceId: string, database: string, folderId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFolderResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFolder',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/sql-studio/databases/${OpenApiUtil.getEncodeParam(database)}/folders/${OpenApiUtil.getEncodeParam(folderId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @return DeleteFolderResponse
 */
async function deleteFolder(instanceId: string, database: string, folderId: string): DeleteFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFolderWithOptions(instanceId, database, folderId, headers, runtime);
}

model DeleteIndexRequest {
  dataSource?: string(name='dataSource', description='The data source.

This parameter is required.', example='ha-cn-pl32rf0js04_test'),
  deleteDataSource?: boolean(name='deleteDataSource', description='Specifies whether to delete the data source.', example='true'),
}

model DeleteIndexResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='022F36C7-9FB4-5D67-BEBC-3D14B0984463'),
  result?: map[string]any(name='result', description='The information about the index', example='{}'),
}

model DeleteIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteIndexResponseBody(name='body'),
}

/**
 * @summary Deletes an index.
 *
 * @description ## Method
 *     DELETE
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/indexes/{indexName}?dataSource=xxx
 *
 * @param request DeleteIndexRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIndexResponse
 */
async function deleteIndexWithOptions(instanceId: string, indexName: string, request: DeleteIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteIndexResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dataSource)) {
    query['dataSource'] = request.dataSource;
  }
  if (!Util.isUnset(request.deleteDataSource)) {
    query['deleteDataSource'] = request.deleteDataSource;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIndex',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/indexes/${OpenApiUtil.getEncodeParam(indexName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes an index.
 *
 * @description ## Method
 *     DELETE
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/indexes/{indexName}?dataSource=xxx
 *
 * @param request DeleteIndexRequest
 * @return DeleteIndexResponse
 */
async function deleteIndex(instanceId: string, indexName: string, request: DeleteIndexRequest): DeleteIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteIndexWithOptions(instanceId, indexName, request, headers, runtime);
}

model DeleteIndexVersionResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='022F36C7-9FB4-5D67-BEBC-3D14B0984463'),
  result?: map[string]any(name='result', description='The result', example='{}'),
}

model DeleteIndexVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteIndexVersionResponseBody(name='body'),
}

/**
 * @summary Deletes the version of an index.
 *
 * @description ## Method
 *     DELETE
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/indexes/{indexName}/versions/{versionName}
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIndexVersionResponse
 */
async function deleteIndexVersionWithOptions(instanceId: string, indexName: string, versionName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteIndexVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteIndexVersion',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/indexes/${OpenApiUtil.getEncodeParam(indexName)}/versions/${OpenApiUtil.getEncodeParam(versionName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes the version of an index.
 *
 * @description ## Method
 *     DELETE
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/indexes/{indexName}/versions/{versionName}
 *
 * @return DeleteIndexVersionResponse
 */
async function deleteIndexVersion(instanceId: string, indexName: string, versionName: string): DeleteIndexVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteIndexVersionWithOptions(instanceId, indexName, versionName, headers, runtime);
}

model DeleteInstanceResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request', example='E45380E8-994A-5402-9806-F114B3295FCF'),
  result?: map[string]any(name='result', description='The result returned', example='{}'),
}

model DeleteInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteInstanceResponseBody(name='body'),
}

/**
 * @summary Deletes a specified instance.
 *
 * @description ### Method
 * `DELETE`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}`
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteInstanceResponse
 */
async function deleteInstanceWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstance',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a specified instance.
 *
 * @description ### Method
 * `DELETE`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}`
 *
 * @return DeleteInstanceResponse
 */
async function deleteInstance(instanceId: string): DeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteInstanceWithOptions(instanceId, headers, runtime);
}

model DeleteModelResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='022F36C7-9FB4-5D67-BEBC-3D14B0984463'),
}

model DeleteModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteModelResponseBody(name='body'),
}

/**
 * @summary 删除模型
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteModelResponse
 */
async function deleteModelWithOptions(instanceId: string, modelName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteModelResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteModel',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/models/${OpenApiUtil.getEncodeParam(modelName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 删除模型
 *
 * @return DeleteModelResponse
 */
async function deleteModel(instanceId: string, modelName: string): DeleteModelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteModelWithOptions(instanceId, modelName, headers, runtime);
}

model DeletePublicUrlResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='F43E8AB4-419C-5F4C-90D6-615590DFAA3C'),
  result?: map[string]any(name='result', description='The result.', example='{}'),
}

model DeletePublicUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePublicUrlResponseBody(name='body'),
}

/**
 * @summary 删除公网域名
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePublicUrlResponse
 */
async function deletePublicUrlWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePublicUrlResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeletePublicUrl',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/public-url`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 删除公网域名
 *
 * @return DeletePublicUrlResponse
 */
async function deletePublicUrl(instanceId: string): DeletePublicUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePublicUrlWithOptions(instanceId, headers, runtime);
}

model DeleteSqlInstanceResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='2AE63638-5420-56DC-BF59-37D8174039A0'),
  result?: {
    requestId?: string(name='requestId', description='id of request', example='2AE63638-5420-56DC-BF59-37D8174039A0'),
    result?: map[string]string(name='result', description='The result.'),
  }(name='result', description='Response<Map<String, String>>'),
}

model DeleteSqlInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSqlInstanceResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSqlInstanceResponse
 */
async function deleteSqlInstanceWithOptions(instanceId: string, database: string, sqlInstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSqlInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteSqlInstance',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/sql-studio/databases/${OpenApiUtil.getEncodeParam(database)}/sql-instances/${OpenApiUtil.getEncodeParam(sqlInstanceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @return DeleteSqlInstanceResponse
 */
async function deleteSqlInstance(instanceId: string, database: string, sqlInstanceId: string): DeleteSqlInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSqlInstanceWithOptions(instanceId, database, sqlInstanceId, headers, runtime);
}

model DeleteTableResponseBody = {
  requestId?: string(name='requestId', description='requestId', example='E7B7D598-B080-5C8E-AA35-D43EC0D5F886'),
  result?: map[string]any(name='result', description='Map', example='{}'),
}

model DeleteTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTableResponseBody(name='body'),
}

/**
 * @summary Deletes an index table.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTableResponse
 */
async function deleteTableWithOptions(instanceId: string, tableName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTableResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteTable',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/tables/${OpenApiUtil.getEncodeParam(tableName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes an index table.
 *
 * @return DeleteTableResponse
 */
async function deleteTable(instanceId: string, tableName: string): DeleteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTableWithOptions(instanceId, tableName, headers, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='acceptLanguage', description='The language of the response. Default value: zh-cn.', example='zh-cn'),
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='E7B7D598-B080-5C8E-AA35-D43EC0D5F886'),
  result?: [ 
    {
      endpoint?: string(name='endpoint', description='The endpoint of the region.', example='endpoint'),
      localName?: string(name='localName', description='The name of the region.', example='China (Hangzhou)'),
      regionId?: string(name='regionId', description='The ID of the region. Valid values:

cn-hangzhou: China (Hangzhou)

cn-shanghai: China (Shanghai)

cn-qingdao: China (Qingdao)

cn-beijing: China (Beijing)

cn-zhangjiakou: China (Zhangjiakou)

cn-shenzhen: China (Shenzhen)

ap-southeast-1: Singapore (Singapore)

cn-internal: Internal Center

cn-zhangbei-in: Internal Center (Zhangjiakou)

us-west-1-in: Internal Center (US)

rus-west-1-in: Internal Center (Russia)

cn-daily: Daily Environment

cn-test: Joint Debugging

pre-hangzhou: China (Hangzhou)-Staging', example='cn-hangzhou'),
    }
  ](name='result', description='The result.'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @summary Queries available regions.
 *
 * @param request DescribeRegionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
async function describeRegionsWithOptions(request: DescribeRegionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['acceptLanguage'] = request.acceptLanguage;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/regions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries available regions.
 *
 * @param request DescribeRegionsRequest
 * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(request, headers, runtime);
}

model ExecuteSqlInstanceRequest {
  combineParam?: map[string]any(name='combineParam'),
  content?: string(name='content', description='This parameter is required.', example='select * from test'),
  domain?: string(name='domain', example='vpc_hz_domain_1'),
  dynamicParam?: map[string]any(name='dynamicParam'),
  kvpair?: map[string]any(name='kvpair'),
  params?: map[string]any(name='params'),
  staticParam?: map[string]any(name='staticParam'),
}

model ExecuteSqlInstanceResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='FE03180A-0E29-5474-8A86-33F0683294A4'),
  result?: {
    gmtCreate?: string(name='gmtCreate', example='1719221186114'),
    gmtModified?: string(name='gmtModified', example='1719220182844'),
    id?: long(name='id', example='22'),
    instanceId?: long(name='instanceId', example='ha-cn-pl32rf0****'),
    isDir?: int32(name='isDir', example='true'),
    name?: string(name='name', example='test'),
    parent?: long(name='parent', example='-1'),
    templateId?: long(name='templateId', example='1'),
    type?: string(name='type', description='table, instance, template, function', example='instance'),
  }(name='result', description='NodeVO'),
}

model ExecuteSqlInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExecuteSqlInstanceResponseBody(name='body'),
}

/**
 * @param request ExecuteSqlInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExecuteSqlInstanceResponse
 */
async function executeSqlInstanceWithOptions(instanceId: string, database: string, sqlInstanceId: string, request: ExecuteSqlInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ExecuteSqlInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.combineParam)) {
    body['combineParam'] = request.combineParam;
  }
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }
  if (!Util.isUnset(request.domain)) {
    body['domain'] = request.domain;
  }
  if (!Util.isUnset(request.dynamicParam)) {
    body['dynamicParam'] = request.dynamicParam;
  }
  if (!Util.isUnset(request.kvpair)) {
    body['kvpair'] = request.kvpair;
  }
  if (!Util.isUnset(request.params)) {
    body['params'] = request.params;
  }
  if (!Util.isUnset(request.staticParam)) {
    body['staticParam'] = request.staticParam;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteSqlInstance',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/sql-studio/databases/${OpenApiUtil.getEncodeParam(database)}/sql-instances/${OpenApiUtil.getEncodeParam(sqlInstanceId)}/actions/execution`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request ExecuteSqlInstanceRequest
 * @return ExecuteSqlInstanceResponse
 */
async function executeSqlInstance(instanceId: string, database: string, sqlInstanceId: string, request: ExecuteSqlInstanceRequest): ExecuteSqlInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return executeSqlInstanceWithOptions(instanceId, database, sqlInstanceId, request, headers, runtime);
}

model ForceSwitchResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0B1FF998-BB8D-5182-BFC0-E471AA77095A'),
  result?: map[string]any(name='result', description='The index information.', example='{}'),
}

model ForceSwitchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ForceSwitchResponseBody(name='body'),
}

/**
 * @summary Performs a forced switchover.
 *
 * @description ### [](#)Method
 * ```java
 * PUT
 * ```
 * ### [](#uri)URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/force-switch/{fsmId}
 * ```
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ForceSwitchResponse
 */
async function forceSwitchWithOptions(instanceId: string, fsmId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ForceSwitchResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ForceSwitch',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/force-switch/${OpenApiUtil.getEncodeParam(fsmId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Performs a forced switchover.
 *
 * @description ### [](#)Method
 * ```java
 * PUT
 * ```
 * ### [](#uri)URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/force-switch/{fsmId}
 * ```
 *
 * @return ForceSwitchResponse
 */
async function forceSwitch(instanceId: string, fsmId: string): ForceSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return forceSwitchWithOptions(instanceId, fsmId, headers, runtime);
}

model GetAdvanceConfigRequest {
  type?: string(name='type', description='*   The type of the advanced configuration. Valid values: -ONLINE: online configuration
*   \\\\-ONLINE_CAVA: online Cava configuration
*   \\\\-ONLINE_PLUGIN: online plug-in configuration
*   \\\\-ONLINE_QUERY: query configuration
*   \\\\-OFFLINE_DICT: offline dictionary configuration
*   \\\\-OFFLINE_TABLE: offline table configuration
*   \\\\-OFFLINE_COMMON: offline configuration
*   \\\\-OFFLINE_PLUGIN: offline plug-in configuration
*   \\\\-OFFLINE_INDEX: index configuration', example='ONLINE'),
}

model GetAdvanceConfigResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='E45380E8-994A-5402-9806-F114B3295FCF'),
  result?: {
    content?: string(name='content', description='The content of the advanced configuration that is returned.', example='{\\\\"url\\\\":\\\\"http://xxxxxx.aliyuncs.com/outnet_hz/packages/xxxxx/opensearch_offline_plugins_xxxxx.tar\\\\"}'),
    contentType?: string(name='contentType', description='The type of the configuration content. Valid values: FILE, GIT, HTTP, and ODPS.', example='FILE'),
    desc?: string(name='desc', description='The description of the advanced configuration.', example='close alarm, chiji id 37080'),
    files?: [ 
      {
        fullPathName?: string(name='fullPathName', description='The file path.', example='""'),
        isDir?: boolean(name='isDir', description='Indicates whether the file is a directory.', example='True'),
        isTemplate?: boolean(name='isTemplate', description='Indicates whether the file is a container.', example='True'),
        name?: string(name='name', description='The file name.', example='ha-cn-2r42ostoc01_qrs'),
      }
    ](name='files', description='The files.'),
    name?: string(name='name', description='The name of the advanced configuration.', example='ha-cn-0ju2s170b03_qrs'),
    status?: string(name='status', description='The status of the advanced configuration. Valid values: drafting: The advanced configuration is in the draft state. used: The advanced configuration is being used. unused: The advanced configuration is not used. trash: The advanced configuration is being deleted.', example='0,1,3,6,8'),
    updateTime?: long(name='updateTime', description='The time when the advanced configuration was updated.', example='""'),
  }(name='result', description='The result.'),
}

model GetAdvanceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAdvanceConfigResponseBody(name='body'),
}

/**
 * @summary Queries the information about an advanced configuration.
 *
 * @description ## Method
 *     GET
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/advanced-configs/{configName}
 *
 * @param request GetAdvanceConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAdvanceConfigResponse
 */
async function getAdvanceConfigWithOptions(instanceId: string, configName: string, request: GetAdvanceConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAdvanceConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAdvanceConfig',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/advanced-configs/${OpenApiUtil.getEncodeParam(configName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about an advanced configuration.
 *
 * @description ## Method
 *     GET
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/advanced-configs/{configName}
 *
 * @param request GetAdvanceConfigRequest
 * @return GetAdvanceConfigResponse
 */
async function getAdvanceConfig(instanceId: string, configName: string, request: GetAdvanceConfigRequest): GetAdvanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAdvanceConfigWithOptions(instanceId, configName, request, headers, runtime);
}

model GetAdvanceConfigFileRequest {
  fileName?: string(name='fileName', description='The name of the file

This parameter is required.', example='/intervene_dict/chn_ecommerce_general.dict'),
}

model GetAdvanceConfigFileResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='10D5E615-69F7-5F49-B850-00169ADE513C'),
  result?: {
    content?: string(name='content', description='The file content.', example='{"summarys":{"parameter":{"file_compressor":"zstd"},"summary_fields":["id"]},"file_compress":[{"name":"file_compressor","type":"zstd"},{"name":"no_compressor","type":""}],"indexs":[{"index_fields":"name","index_name":"ids","index_type":"STRING"},{"has_primary_key_attribute":true,"index_fields":"id","is_primary_key_sorted":false,"index_name":"id","index_type":"PRIMARYKEY64"}],"attributes":[{"file_compress":"no_compressor","field_name":"id"}],"fields":[{"user_defined_param":{},"compress_type":"uniq","field_type":"STRING","field_name":"id"},{"compress_type":"uniq","field_type":"STRING","field_name":"name"}],"table_name":"api"}'),
  }(name='result', description='The result.'),
}

model GetAdvanceConfigFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAdvanceConfigFileResponseBody(name='body'),
}

/**
 * @summary Queries the information about an advanced configuration file.
 *
 * @description ## Method
 *     GET
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/advanced-configs/{configName}/file?fileName={fileName}
 *
 * @param request GetAdvanceConfigFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAdvanceConfigFileResponse
 */
async function getAdvanceConfigFileWithOptions(instanceId: string, configName: string, request: GetAdvanceConfigFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAdvanceConfigFileResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.fileName)) {
    query['fileName'] = request.fileName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAdvanceConfigFile',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/advanced-configs/${OpenApiUtil.getEncodeParam(configName)}/file`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about an advanced configuration file.
 *
 * @description ## Method
 *     GET
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/advanced-configs/{configName}/file?fileName={fileName}
 *
 * @param request GetAdvanceConfigFileRequest
 * @return GetAdvanceConfigFileResponse
 */
async function getAdvanceConfigFile(instanceId: string, configName: string, request: GetAdvanceConfigFileRequest): GetAdvanceConfigFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAdvanceConfigFileWithOptions(instanceId, configName, request, headers, runtime);
}

model GetClusterResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='E7B7D598-B080-5C8E-AA35-D43EC0D5F886'),
  result?: {
    config?: map[string]object(name='config', description='The configuration information.'),
    configUpdateTime?: string(name='configUpdateTime', description='The time when the cluster was updated.', example='2021-08-09 00:01:02'),
    createTime?: string(name='createTime', description='The time when the cluster was created.', example='2024-05-21 16:05:26'),
    currentAdvanceConfigVersion?: string(name='currentAdvanceConfigVersion', description='The effective advanced configuration version.', example='test_yyds_data1'),
    currentOnlineConfigVersion?: string(name='currentOnlineConfigVersion', description='The effective online configuration version.', example='test_yyds_data1'),
    dataNode?: {
      name?: string(name='name', description='The name of the Searcher worker.', example='test'),
      number?: int32(name='number', description='The number of replicas.', example='1'),
      partition?: int32(name='partition', description='The number of partitions.', example='2'),
    }(name='dataNode', description='The specifications of Searcher workers.'),
    description?: string(name='description', description='The description of the cluster.', example='fzz_test'),
    latestAdvanceConfigVersion?: string(name='latestAdvanceConfigVersion', description='The latest advanced configuration version.', example='test_yyds_data1'),
    latestOnlineConfigVersion?: string(name='latestOnlineConfigVersion', description='The latest online configuration version.', example='test_yyds_data1'),
    name?: string(name='name', description='The cluster name.', example='general'),
    queryNode?: {
      name?: string(name='name', description='The name of the QRS worker.', example='test'),
      number?: int32(name='number', description='The number of nodes.', example='1'),
      partition?: int32(name='partition', description='The number of replicas.', example='2'),
    }(name='queryNode', description='The specifications of Query Result Searcher (QRS) workers.'),
    status?: string(name='status', description='The creation status of the cluster. Valid values: NEW and PUBLISH. NEW indicates that the cluster is being created. PUBLISH indicates that the cluster is created.', example='NEW'),
  }(name='result', description='The clusters.'),
}

model GetClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClusterResponseBody(name='body'),
}

/**
 * @summary Queries the details of a cluster.
 *
 * @description ### Method
 * `GET`
 * ### URI
 * `/openapi/ha3/instance/{instanceId}/clusters/{clusterName}`
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetClusterResponse
 */
async function getClusterWithOptions(instanceId: string, clusterName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetClusterResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetCluster',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/clusters/${OpenApiUtil.getEncodeParam(clusterName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of a cluster.
 *
 * @description ### Method
 * `GET`
 * ### URI
 * `/openapi/ha3/instance/{instanceId}/clusters/{clusterName}`
 *
 * @return GetClusterResponse
 */
async function getCluster(instanceId: string, clusterName: string): GetClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getClusterWithOptions(instanceId, clusterName, headers, runtime);
}

model GetClusterRunTimeInfoResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='E45380E8-994A-5402-9806-F114B3295FCF'),
  result?: [ 
    {
      clusterName?: string(name='clusterName', description='The cluster name.', example='vpc_hz_domain_1'),
      dataNodes?: [ 
        {
          configStatusList?: [ 
            {
              configUpdateTime?: string(name='configUpdateTime', description='The time when the configuration was last updated.', example='""'),
              donePercent?: int32(name='donePercent', description='The configuration progress. Unit: percentage.', example='100'),
              doneSize?: int32(name='doneSize', description='The number of processed Searcher workers in the cluster.', example='1'),
              name?: string(name='name', description='The cluster name.', example='test_0704'),
              totalSize?: int32(name='totalSize', description='The total number of Searcher workers in the cluster.', example='0'),
            }
          ](name='configStatusList', description='The configuration status.'),
          dataStatusList?: [ 
            {
              advanceConfigInfo?: {
                configMetaName?: string(name='configMetaName', description='The name of the index configuration.', example='index_meta_name'),
                version?: long(name='version', description='The version number.', example='1.0'),
              }(name='advanceConfigInfo', description='The information about the advanced configuration.'),
              deployFailedWorker?: [ string ](name='deployFailedWorker', description='The name of the worker that failed due to a deployment failure.'),
              docSize?: int32(name='docSize', description='The storage capacity. Unit: GB.', example='2'),
              donePercent?: int32(name='donePercent', description='The configuration progress. Unit: percentage.', example='100'),
              doneSize?: int32(name='doneSize', description='The number of processed QRS workers in the cluster.', example='100'),
              errorMsg?: string(name='errorMsg', description='The error message.', example='0A3B1C48006A6C0905F6375F4821EB50'),
              fullUpdateTime?: string(name='fullUpdateTime', description='The time when full data in the index was last updated.', example='" "'),
              fullVersion?: long(name='fullVersion', description='The time when the full index version was generated.', example='123423'),
              incUpdateTime?: string(name='incUpdateTime', description='The time when incremental data in the index was last updated.', example='""'),
              incVersion?: long(name='incVersion', description='The time when the incremental index version was generated.', example='123423'),
              indexConfigInfo?: {
                configMetaName?: string(name='configMetaName', description='The name of the index configuration.', example='index_meta_name'),
                version?: long(name='version', description='The version of the index template.', example='1.0.0'),
              }(name='indexConfigInfo', description='The information about the index configuration.'),
              indexSize?: long(name='indexSize', description='The index size.', example='100'),
              lackDiskWorker?: [ string ](name='lackDiskWorker', description='The name of the worker that failed due to insufficient disks.'),
              lackMemWorker?: [ string ](name='lackMemWorker', description='The name of the worker that failed due to insufficient memory.'),
              name?: string(name='name', description='The name of the QRS worker.', example='ha-cn-c4d2rq7nt04_qrs'),
              totalSize?: int32(name='totalSize', description='The total number of QRS workers in the cluster.', example='1'),
            }
          ](name='dataStatusList', description='The data of the Searcher worker.'),
          serviceStatus?: {
            donePercent?: int32(name='donePercent', description='The process progress of QRS workers in the cluster. Unit: percentage.', example='100'),
            doneSize?: int32(name='doneSize', description='The number of processed QRS workers in the cluster.', example='100'),
            name?: string(name='name', description='The name of the QRS worker.', example='ha-cn-0ju2s170b03_qrs'),
            totalSize?: int32(name='totalSize', description='The total number of QRS workers in the cluster.', example='100'),
          }(name='serviceStatus', description='The service status of the QRS worker.'),
        }
      ](name='dataNodes', description='The information about the Searcher workers.'),
      queryNode?: {
        configStatusList?: [ 
          {
            configUpdateTime?: string(name='configUpdateTime', description='The time when the configuration was last updated.', example='" "'),
            donePercent?: int32(name='donePercent', description='The process progress of QRS workers in the cluster. Unit: percentage.', example='100'),
            doneSize?: int32(name='doneSize', description='The number of processed QRS workers in the cluster.', example='100'),
            name?: string(name='name', description='The cluster name.', example='ha-cn-zvp2qr1sk01_qrs'),
            totalSize?: int32(name='totalSize', description='The total number of QRS workers in the cluster.', example='6'),
          }
        ](name='configStatusList', description='The configuration status.'),
        serviceStatus?: {
          donePercent?: int32(name='donePercent', description='The process progress of QRS workers in the cluster. Unit: percentage.', example='100'),
          doneSize?: int32(name='doneSize', description='The number of processed QRS workers in the cluster.', example='100'),
          name?: string(name='name', description='The cluster name.', example='ha-cn-c4d2rq7nt04_qrs'),
          totalSize?: int32(name='totalSize', description='The total number of QRS workers in the cluster.', example='100'),
        }(name='serviceStatus', description='The service status of the QRS worker.'),
      }(name='queryNode', description='The information about the Query Result Searcher (QRS) workers.'),
    }
  ](name='result', description='The result.'),
}

model GetClusterRunTimeInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClusterRunTimeInfoResponseBody(name='body'),
}

/**
 * @summary Queries the runtime information about a specified cluster.
 *
 * @description ### Method
 * GET
 * ### URI
 * /openapi/ha3/instances/{instanceId}/cluster-run-time-info
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetClusterRunTimeInfoResponse
 */
async function getClusterRunTimeInfoWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetClusterRunTimeInfoResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetClusterRunTimeInfo',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/cluster-run-time-info`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the runtime information about a specified cluster.
 *
 * @description ### Method
 * GET
 * ### URI
 * /openapi/ha3/instances/{instanceId}/cluster-run-time-info
 *
 * @return GetClusterRunTimeInfoResponse
 */
async function getClusterRunTimeInfo(instanceId: string): GetClusterRunTimeInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getClusterRunTimeInfoWithOptions(instanceId, headers, runtime);
}

model GetDataSourceResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='FE03180A-0E29-5474-8A86-33F0683294A4'),
  result?: {
    domain?: string(name='domain', description='The data center where the data source is deployed in offline mode', example='vpc_hz_domain_1'),
    indexes?: [ string ](name='indexes', description='The list of index information'),
    lastFulTime?: long(name='lastFulTime', description='The time when the full data of the data source was last queried.', example='1718787219'),
    name?: string(name='name', description='The name of the data source.', example='my_index'),
    status?: string(name='status', description='The status of the data source. Valid values: new: The data source is being created. publish: The data source is in the normal state. trash: The data source is being deleted.', example='NEW'),
    type?: string(name='type', description='The type of the data source', example='odps'),
  }(name='result', description='The information about the data source.'),
}

model GetDataSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDataSourceResponseBody(name='body'),
}

/**
 * @summary Obtains a data source.
 *
 * @description ### Method
 * `GET`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}/data-sources/{dataSourceName}`
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDataSourceResponse
 */
async function getDataSourceWithOptions(instanceId: string, dataSourceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDataSourceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDataSource',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/data-sources/${OpenApiUtil.getEncodeParam(dataSourceName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains a data source.
 *
 * @description ### Method
 * `GET`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}/data-sources/{dataSourceName}`
 *
 * @return GetDataSourceResponse
 */
async function getDataSource(instanceId: string, dataSourceName: string): GetDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDataSourceWithOptions(instanceId, dataSourceName, headers, runtime);
}

model GetDataSourceDeployResponseBody = {
  requestId?: string(name='requestId', description='requestId', example='2AE63638-5420-56DC-BF59-37D8174039A0'),
  result?: {
    autoBuildIndex?: boolean(name='autoBuildIndex', example='true'),
    extend?: {
      hdfs?: {
        path?: string(name='path', example='dist-dmj-job/src/main/java'),
      }(name='hdfs'),
      odps?: {
        partitions?: map[string]string(name='partitions'),
      }(name='odps'),
      oss?: {
        path?: string(name='path', example='oss://opensearch'),
      }(name='oss'),
      saro?: {
        path?: string(name='path', example='dist-dmj-job/src/main/java'),
        version?: string(name='version', example='0.6.0'),
      }(name='saro'),
    }(name='extend'),
    processor?: {
      args?: string(name='args', description='The startup parameters of the process.', example='{}'),
      resource?: string(name='resource', description='The resource information.', example='{}'),
    }(name='processor', description='The parameters of the process.'),
    storage?: {
      accessKey?: string(name='accessKey', description='The AccessKey ID of the MaxCompute data source.', example='ak'),
      accessSecret?: string(name='accessSecret', description='The AccessKey secret of the MaxCompute data source.', example='as'),
      bucket?: string(name='bucket', description='The name of the OSS bucket.', example='antsys-miniapp-chongwen-static'),
      catalog?: string(name='catalog'),
      database?: string(name='database'),
      endpoint?: string(name='endpoint', description='The endpoint of the MaxCompute data source.', example='http://service.cn-hangzhou.maxcompute.aliyun-inc.com/api'),
      namespace?: string(name='namespace', example='lazada-campaign-flink'),
      ossPath?: string(name='ossPath', description='The Object Storage Service (OSS) path.', example='oss://opensearch'),
      partition?: string(name='partition', description='The partition in the MaxCompute table. Example: ds=20180102.', example='ds=20220926'),
      path?: string(name='path', example='/beiming_xobject/dwd_xobjectsandbox__list_create_action_by_new/'),
      project?: string(name='project', example='wireless_1688_personal_rec'),
      table?: string(name='table', example='behavior'),
      tag?: string(name='tag'),
    }(name='storage', description='The information about the data source.'),
    swift?: {
      topic?: string(name='topic', description='The topic.', example='topic'),
      zk?: string(name='zk', description='zk', example='zk'),
    }(name='swift', description='The information about the incremental data source Swift.'),
  }(name='result', description='The result.'),
}

model GetDataSourceDeployResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDataSourceDeployResponseBody(name='body'),
}

/**
 * @summary 获取数据源部署信息
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDataSourceDeployResponse
 */
async function getDataSourceDeployWithOptions(instanceId: string, deployName: string, dataSourceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDataSourceDeployResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDataSourceDeploy',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/data-sources/${OpenApiUtil.getEncodeParam(dataSourceName)}/deploys/${OpenApiUtil.getEncodeParam(deployName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 获取数据源部署信息
 *
 * @return GetDataSourceDeployResponse
 */
async function getDataSourceDeploy(instanceId: string, deployName: string, dataSourceName: string): GetDataSourceDeployResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDataSourceDeployWithOptions(instanceId, deployName, dataSourceName, headers, runtime);
}

model GetDatabaseSchemaResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='022F36C7-9FB4-5D67-BEBC-3D14B0984463'),
  result?: [ 
    {
      fieldName?: string(name='fieldName', example='id'),
      fieldType?: string(name='fieldType', example='STRING'),
      fieldTypeDetail?: map[string]any(name='fieldTypeDetail', example='FT_UINT64'),
      indexName?: string(name='indexName', example='test_tusou_v2'),
      indexType?: string(name='indexType', example='NUMBER'),
    }
  ](name='result', description='List'),
}

model GetDatabaseSchemaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDatabaseSchemaResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDatabaseSchemaResponse
 */
async function getDatabaseSchemaWithOptions(instanceId: string, database: string, tableName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDatabaseSchemaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDatabaseSchema',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/sql-studio/databases/${OpenApiUtil.getEncodeParam(database)}/tables/${OpenApiUtil.getEncodeParam(tableName)}/schema`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @return GetDatabaseSchemaResponse
 */
async function getDatabaseSchema(instanceId: string, database: string, tableName: string): GetDatabaseSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDatabaseSchemaWithOptions(instanceId, database, tableName, headers, runtime);
}

model GetDeployGraphResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='E7B7D598-B080-5C8E-AA35-D43EC0D5F886'),
  result?: {
    graph?: {
      indexMetas?: [ 
        {
          domainName?: string(name='domainName', description='The name of the data center.', example='hz_pre_vpc_domain_1'),
          name?: string(name='name', description='The index name.', example='test_api'),
          tableDeployId?: long(name='tableDeployId', description='The deployment ID of the table.', example='2409'),
          tableName?: string(name='tableName', description='The name of the data source.', example='ha-cn-pl32rf0****_test_api'),
          tag?: string(name='tag', description='The tag.', example='test_api_hz_pre_vpc_domain_1'),
          zoneName?: string(name='zoneName', description='The name of the QRS worker.', example='ha-cn-pl32rf0****_qrs'),
        }
      ](name='indexMetas', description='The index metadata.'),
      onlineMaster?: [ 
        {
          domainName?: string(name='domainName', description='The name of the data center.', example='hz_pre_vpc_domain_1'),
          hippoId?: string(name='hippoId', description='The resource ID.', example='5377'),
          id?: long(name='id', description='The ID of the data center.', example='1'),
          name?: string(name='name', description='The name of the online cluster.', example='ha-cn-pl32rf0****_hz_pre_vpc_domain_1'),
        }
      ](name='onlineMaster', description='The metadata of online clusters.'),
      tableIndexRelation?: map[string][ string ](name='tableIndexRelation', description='The association relationships between data sources and indexes.'),
      tableMetas?: [ 
        {
          buildDeployId?: long(name='buildDeployId', description='The ID of the offline deployment.', example='1'),
          domainName?: string(name='domainName', description='The name of the data center.', example='hz_pre_vpc_domain_1'),
          name?: string(name='name', description='The name of the data source.', example='ha-cn-pl32rf0****_test_api'),
          tableDeployId?: long(name='tableDeployId', description='The deployment ID of the table.', example='2177'),
          tag?: string(name='tag', description='The tag.', example='ha-cn-pl32rf0****_test_api_hz_pre_vpc_domain_1'),
          type?: string(name='type', description='The type of the data source.', example='odps'),
        }
      ](name='tableMetas', description='The metadata of data sources.'),
      zoneIndexRelation?: map[string][ string ](name='zoneIndexRelation', description='The association relationships between zones and indexes.'),
      zoneMetas?: [ 
        {
          domainInfo?: string(name='domainInfo', description='The name of the data center.', example='hz_pre_vpc_domain_1'),
          name?: string(name='name', description='The name of the Query Result Searcher (QRS) worker.', example='ha-cn-pl32rf0****_qrs'),
          suezAdminName?: string(name='suezAdminName', description='The name of the service that is used to manage the relationships between online clusters and indexes.', example='ha-cn-pl32rf0****_hz_pre_vpc_domain_1'),
          tag?: string(name='tag', description='The tag.', example='ha-cn-pl32rf0****_qrs_hz_pre_vpc_domain_1'),
          type?: string(name='type', description='The node type.', example='qrs'),
        }
      ](name='zoneMetas', description='The zone metadata.'),
    }(name='graph', description='The deployment information.'),
  }(name='result', description='The results returned.', example='{}'),
}

model GetDeployGraphResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDeployGraphResponseBody(name='body'),
}

/**
 * @summary Displays the overview of the deployment.
 *
 * @description ## Method
 * GET
 * ## URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/deploy-graph
 * ```
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDeployGraphResponse
 */
async function getDeployGraphWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDeployGraphResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDeployGraph',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/deploy-graph`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Displays the overview of the deployment.
 *
 * @description ## Method
 * GET
 * ## URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/deploy-graph
 * ```
 *
 * @return GetDeployGraphResponse
 */
async function getDeployGraph(instanceId: string): GetDeployGraphResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDeployGraphWithOptions(instanceId, headers, runtime);
}

model GetFileRequest {
  fileName?: string(name='fileName', description='The name of the file in full path

This parameter is required.', example='/schemas/automobile_vector_schema.json'),
}

model GetFileResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='2AE63638-5420-56DC-BF59-37D8174039A0'),
  result?: {
    content?: string(name='content', description='The file content.', example='None'),
    dataSource?: string(name='dataSource', description='The data source.', example='ha-cn-2r42p5oi202_xijie_test'),
    extend?: map[string][ string ](name='extend', description='Extended information'),
    fullPathName?: string(name='fullPathName', description='The full path of the file.', example='""'),
    isDir?: boolean(name='isDir', description='Indicates whether the file is a directory.', example='True'),
    name?: string(name='name', description='The file name.', example='ha-cn-2r42ostoc01_qrs'),
    partition?: long(name='partition', description='The number of shards.', example='ds=20210828'),
  }(name='result', description='The index information.'),
}

model GetFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFileResponseBody(name='body'),
}

/**
 * @summary Queries the details of an index table version.
 *
 * @description ## [](#)Method
 *     GET
 * ## [](#uri)URI
 *     /openapi/ha3/instances/{instanceId}/indexes/{indexName}/versions/{versionName}/file
 *
 * @param request GetFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileResponse
 */
async function getFileWithOptions(instanceId: string, indexName: string, versionName: string, request: GetFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFileResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.fileName)) {
    query['fileName'] = request.fileName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFile',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/indexes/${OpenApiUtil.getEncodeParam(indexName)}/versions/${OpenApiUtil.getEncodeParam(versionName)}/file`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of an index table version.
 *
 * @description ## [](#)Method
 *     GET
 * ## [](#uri)URI
 *     /openapi/ha3/instances/{instanceId}/indexes/{indexName}/versions/{versionName}/file
 *
 * @param request GetFileRequest
 * @return GetFileResponse
 */
async function getFile(instanceId: string, indexName: string, versionName: string, request: GetFileRequest): GetFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFileWithOptions(instanceId, indexName, versionName, request, headers, runtime);
}

model GetIndexResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='4FB0325E-8C37-5525-96AC-0333523170A3'),
  result?: {
    cluster?: map[string]ResultClusterValue(name='cluster', description='The cluster information.'),
    config?: map[string]object(name='config', description='The configuration information.'),
    configWhenBuild?: map[string]object(name='configWhenBuild', description='The configuration that takes effect next time.'),
    content?: string(name='content', description='The file content.', example='{"summarys":{"parameter":{"file_compressor":"zstd"},"summary_fields":["id"]},"file_compress":[{"name":"file_compressor","type":"zstd"},{"name":"no_compressor","type":""}],"indexs":[{"index_fields":"name","index_name":"ids","index_type":"STRING"},{"has_primary_key_attribute":true,"index_fields":"id","is_primary_key_sorted":false,"index_name":"id","index_type":"PRIMARYKEY64"}],"attributes":[{"file_compress":"no_compressor","field_name":"id"}],"fields":[{"user_defined_param":{},"compress_type":"uniq","field_type":"STRING","field_name":"id"},{"compress_type":"uniq","field_type":"STRING","field_name":"name"}],"table_name":"api"}'),
    createTime?: string(name='createTime'),
    dataSource?: string(name='dataSource', description='The name of the data source.', example='ha-cn-tl32nd2nq01_00'),
    dataSourceInfo?: {
      autoBuildIndex?: boolean(name='autoBuildIndex', description='Indicates whether the automatic full indexing feature is enabled.', example='true'),
      config?: {
        accessKey?: string(name='accessKey', description='The AccessKey ID of the MaxCompute data source.', example='L***p'),
        accessSecret?: string(name='accessSecret', description='The AccessKey secret of the MaxCompute data source.', example='5**9a6'),
        bucket?: string(name='bucket', description='The name of the OSS bucket.', example='ha3test-oss'),
        catalog?: string(name='catalog'),
        database?: string(name='database'),
        endpoint?: string(name='endpoint', description='The endpoint of the MaxCompute data source.', example='http://service.cn-hangzhou.maxcompute.aliyun-inc.com/api'),
        format?: string(name='format'),
        namespace?: string(name='namespace', description='The namespace. This parameter is applicable to the SARO data source used in the intranet of Alibaba Group.', example='TEST_dump_demo_sj_na61hunbu2_share_holo'),
        ossPath?: string(name='ossPath', description='The Object Storage Service (OSS) path.', example='/test_opensearch/sift_oss_test.data'),
        partition?: string(name='partition', description='The partition in the MaxCompute table. Example: ds=20180102.', example='ds=20220713'),
        path?: string(name='path', description='The file path in the Apsara File Storage for HDFS file system.', example='http://test_opensearch/sift_oss_test.data'),
        project?: string(name='project', description='The name of the MaxCompute project that is used as the data source.', example='tisplus_dev'),
        table?: string(name='table', description='The name of the MaxCompute table that is used as the data source.', example='dump_odps_demo'),
        tag?: string(name='tag'),
      }(name='config', description='The configuration of MaxCompute data sources.'),
      domain?: string(name='domain', description='The data center in which the data source is deployed.', example='vpc_hz_domain_1'),
      name?: string(name='name', description='The name of the data source.', example='ha-cn-pl32rf0****_test_api'),
      processParallelNum?: int32(name='processParallelNum', description='The maximum number of full indexes that can be concurrently processed.', example='2'),
      processPartitionCount?: int32(name='processPartitionCount', description='The number of resources used for data update.', example='2'),
      saroConfig?: {
        namespace?: string(name='namespace', description='The namespace of the SARO data source.', example='TEST_dump_demo_sj_na61hunbu2_share_holo'),
        tableName?: string(name='tableName', description='The name of the SARO table.', example='llm'),
      }(name='saroConfig', description='The configurations of the SARO data source.'),
      type?: string(name='type', description='The type of the data source. Valid values: odps, swift, saro, oss, and unKnow.', example='odps'),
    }(name='dataSourceInfo', description='The information about the data source.'),
    description?: string(name='description', description='The description of the index version.', example='test index'),
    domain?: string(name='domain', description='The deployment name of the index.', example='sz_vpc_domain_1'),
    extend?: map[string][ string ](name='extend', description='Extended information'),
    fullUpdateTime?: string(name='fullUpdateTime', description='The time when full data in the index was last updated.', example='2024-06-20 08:52:54'),
    fullVersion?: long(name='fullVersion', description='The data version.', example='1688523414'),
    incUpdateTime?: string(name='incUpdateTime', description='The time when incremental data in the index was last updated.', example='2024-06-20 08:52:54'),
    indexSize?: long(name='indexSize', description='The index size.', example='4689'),
    indexStatus?: string(name='indexStatus', description='The status of the index version. Valid values:

*   NEW: The index version is created.
*   PUBLISH: The index version is normal.
*   IN_USE: The index version is in use.
*   NOT_USE: The index version is not used.
*   STOP_USE: The index version is being stopped.
*   RESTORE_USE: The index version is being restored.
*   FAIL: The index version failed to be created.', example='IN_USE'),
    name?: string(name='name', description='The index name.', example='general'),
    partition?: int32(name='partition', description='The number of shards.', example='2'),
    updateTime?: string(name='updateTime'),
    versions?: [ 
      {
        desc?: string(name='desc', description='The description of the version.', example='close alarm, by 3.9.2 hotfix workflow'),
        files?: [ 
          {
            fullPathName?: string(name='fullPathName', description='The full path of the file.', example='" "'),
            isDir?: boolean(name='isDir', description='Indicates whether the file is a directory.', example='True'),
            isTemplate?: boolean(name='isTemplate', description='Indicates whether the file is a template.', example='True'),
            name?: string(name='name', description='The file name.', example='qrs.json'),
          }
        ](name='files', description='The information about the files.'),
        name?: string(name='name', description='The version name.', example='ha-cn-7pp2ngv4s02_qrs'),
        status?: string(name='status', description='The status of the index version. Valid values:

*   NEW: The index version is created.
*   PUBLISH: The index version is normal.
*   IN_USE: The index version is in use.
*   NOT_USE: The index version is not used.
*   STOP_USE: The index version is being stopped.
*   RESTORE_USE: The index version is being restored.
*   FAIL: The index version failed to be created.', example='2'),
        updateTime?: long(name='updateTime', description='The time when the index version was updated.', example='" "'),
        versionId?: int32(name='versionId', description='The version ID.', example='1'),
      }
    ](name='versions', description='The information about the versions.'),
  }(name='result', description='The index information.'),
}

model GetIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetIndexResponseBody(name='body'),
}

/**
 * @summary Queries the information about an index version.
 *
 * @description ## [](#)Method
 *     GET
 * ## [](#uri)URI
 *     /openapi/ha3/instances/{instanceId}/indexes/{indexName}
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetIndexResponse
 */
async function getIndexWithOptions(instanceId: string, indexName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetIndexResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetIndex',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/indexes/${OpenApiUtil.getEncodeParam(indexName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about an index version.
 *
 * @description ## [](#)Method
 *     GET
 * ## [](#uri)URI
 *     /openapi/ha3/instances/{instanceId}/indexes/{indexName}
 *
 * @return GetIndexResponse
 */
async function getIndex(instanceId: string, indexName: string): GetIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIndexWithOptions(instanceId, indexName, headers, runtime);
}

model GetIndexOnlineStrategyResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='FE03180A-0E29-5474-8A86-33F0683294A4'),
  result?: {
    changeRate?: int32(name='changeRate', description='The index change rate.', example='20'),
  }(name='result', description='The result.'),
}

model GetIndexOnlineStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetIndexOnlineStrategyResponseBody(name='body'),
}

/**
 * @summary Queries the online effective policy of an index.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetIndexOnlineStrategyResponse
 */
async function getIndexOnlineStrategyWithOptions(instanceId: string, dataSourceName: string, deployName: string, indexName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetIndexOnlineStrategyResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetIndexOnlineStrategy',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/data-sources/${OpenApiUtil.getEncodeParam(dataSourceName)}/deploys/${OpenApiUtil.getEncodeParam(deployName)}/indexes/${OpenApiUtil.getEncodeParam(indexName)}/online-strategy`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the online effective policy of an index.
 *
 * @return GetIndexOnlineStrategyResponse
 */
async function getIndexOnlineStrategy(instanceId: string, dataSourceName: string, deployName: string, indexName: string): GetIndexOnlineStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIndexOnlineStrategyWithOptions(instanceId, dataSourceName, deployName, indexName, headers, runtime);
}

model GetIndexVersionResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='E7B7D598-B080-5C8E-AA35-D43EC0D5F886'),
  result?: {
    cluster?: string(name='cluster', description='The cluster name.', example='ayoss-cn-zhangjiakou-b'),
    indexVersions?: [ 
      {
        buildDeployId?: string(name='buildDeployId', description='The ID of the offline deployment.', example='" "'),
        currentVersion?: long(name='currentVersion', description='The current online version number.', example='1'),
        indexName?: string(name='indexName', description='The name of the index table.', example='table4'),
        versions?: [ long ](name='versions', description='The index versions.'),
      }
    ](name='indexVersions', description='The index versions.'),
  }(name='result', description='The clusters.'),
}

model GetIndexVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetIndexVersionResponseBody(name='body'),
}

/**
 * @summary Queries the information about index versions that the current index version can be rolled back to.
 *
 * @description ## Method
 *     GET
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/clusters/{clusterName}/index-version
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetIndexVersionResponse
 */
async function getIndexVersionWithOptions(instanceId: string, clusterName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetIndexVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetIndexVersion',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/clusters/${OpenApiUtil.getEncodeParam(clusterName)}/index-version`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about index versions that the current index version can be rolled back to.
 *
 * @description ## Method
 *     GET
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/clusters/{clusterName}/index-version
 *
 * @return GetIndexVersionResponse
 */
async function getIndexVersion(instanceId: string, clusterName: string): GetIndexVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIndexVersionWithOptions(instanceId, clusterName, headers, runtime);
}

model GetInstanceResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='E7B7D598-B080-5C8E-AA35-D43EC0D5F886'),
  result?: {
    bsVersion?: string(name='bsVersion'),
    chargeType?: string(name='chargeType', description='The billing method.', example='POSYPAY'),
    commodityCode?: string(name='commodityCode', description='The commodity code of the instance.', example='commodityCode'),
    createTime?: string(name='createTime', description='The time when the instance was created.', example='2022-06-17T02:01:26Z'),
    description?: string(name='description', description='The description of the instance.', example='ha3_test'),
    edition?: string(name='edition', description='The edition of the instance. Valid values: vector and engine.', example='vector'),
    expiredTime?: string(name='expiredTime', description='The time when the instance expires.', example='1634609702'),
    inDebt?: boolean(name='inDebt', description='Indicates whether an overdue payment is involved.', example='false'),
    instanceId?: string(name='instanceId', description='The instance ID.', example='ha-cn-7mz2qsgq301'),
    lockMode?: string(name='lockMode', description='The lock status.', example='Unlock'),
    network?: {
      allow?: string(name='allow', description='The public domain name whitelist.', example='127.0.0.1'),
      endpoint?: string(name='endpoint', description='The instance endpoint.', example='ha-cn-35t3r****.ha.aliyuncs.com'),
      publicEndpoint?: string(name='publicEndpoint', description='The public endpoint.', example='ha-cn-35t3ni****.public.ha.aliyuncs.com'),
      vSwitchId?: string(name='vSwitchId', description='The vSwitch ID.', example='vsw-bp11ldcf59q2n****'),
      vpcId?: string(name='vpcId', description='The VPC ID.', example='vpc-wz9axk41d9vff****'),
    }(name='network', description='The network information of the instance.'),
    newMode?: boolean(name='newMode', description='Specifies whether the instance is of the new version.', example='true'),
    noQrs?: boolean(name='noQrs', description='Specifies whether the instance has only one node.', example='false'),
    resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group.', example='rg-aekzjvw24el5lma'),
    spec?: {
      qrsResource?: {
        category?: string(name='category', description='The category. Valid values: local_ssd, SSD, and cloud.', example='local_ssd'),
        cpu?: int32(name='cpu', description='The number of vCPUs.', example='2'),
        disk?: int32(name='disk', description='The storage capacity. Unit: GB.', example='100'),
        mem?: int32(name='mem', description='The memory of the instance. Unit: GB.', example='10'),
        nodeCount?: int32(name='nodeCount', description='The number of nodes.', example='1'),
      }(name='qrsResource', description='The QRS worker specifications.'),
      searchResource?: {
        category?: string(name='category', description='The category. Valid values: local_ssd, SSD, and cloud.', example='local_ssd'),
        cpu?: int32(name='cpu', description='The number of vCPUs.', example='2'),
        disk?: int32(name='disk', description='The storage capacity. Unit: GB.', example='100'),
        mem?: int32(name='mem', description='The memory of the instance. Unit: GB.', example='10'),
        nodeCount?: int32(name='nodeCount', description='The number of nodes.', example='1'),
      }(name='searchResource', description='The searcher worker specifications.'),
    }(name='spec', description='The node specifications.'),
    status?: string(name='status', description='The status of the instance. Valid values:

*   INIT: being initialized
*   WAIT_CONFIG: to be configured
*   CONFIG_UPDATING: configuration taking effect
*   READY: normal', example='INIT'),
    tags?: [ 
      {
        key?: string(name='key', description='The tag key.', example='env'),
        value?: string(name='value', description='The tag value.', example='prod'),
      }
    ](name='tags', description='The tags of the instance.'),
    updateTime?: string(name='updateTime', description='The time when the instance was updated.', example='1634609702'),
    userName?: string(name='userName', description='The username.', example='admin'),
    version?: string(name='version', description='The version of the engine.', example='ha3_3.10.0'),
  }(name='result', description='Response parameters'),
}

model GetInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetInstanceResponseBody(name='body'),
}

/**
 * @summary Queries the details of an instance based on the instance ID.
 *
 * @description ### [](#)Method
 * ```java
 * GET
 * ```
 * ### [](#uri)URI
 * ```java
 * /openapi/ha3/instances/{instanceId}
 * ```
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceResponse
 */
async function getInstanceWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetInstance',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of an instance based on the instance ID.
 *
 * @description ### [](#)Method
 * ```java
 * GET
 * ```
 * ### [](#uri)URI
 * ```java
 * /openapi/ha3/instances/{instanceId}
 * ```
 *
 * @return GetInstanceResponse
 */
async function getInstance(instanceId: string): GetInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getInstanceWithOptions(instanceId, headers, runtime);
}

model GetModelResponseBody = {
  requestId?: string(name='requestId', example='38b079f1-7846-4226-8c90-3e2644b5c52b'),
  result?: {
    content?: {
      method?: string(name='method', example='POST'),
      modelName?: string(name='modelName', example='test'),
      modelType?: string(name='modelType', example='text_embedding'),
      request?: {
        header?: {
          authorization?: string(name='Authorization', example='Bearer OS-v0********6vvs'),
          contentType?: string(name='Content-Type', example='application/json'),
        }(name='header'),
        parameters?: {
          build?: {
            inputType?: string(name='input_type', example='query'),
          }(name='build'),
          search?: {
            inputType?: string(name='input_type', example='document'),
          }(name='search'),
        }(name='parameters'),
        requestBody?: string(name='requestBody', example='{\\\\"input\\\\": [\\\\"%{input}\\\\"], \\\\"input_type\\\\": \\\\"%{input_type}\\\\"}'),
        urlParams?: {
          build?: map[string]any(name='build', example='key: value'),
          search?: map[string]any(name='search', example='key: value'),
        }(name='urlParams'),
      }(name='request'),
      response?: {
        embeddings?: string(name='embeddings', example='$.result.embeddings[*].embedding'),
      }(name='response'),
      url?: string(name='url', example='http://***.platform-cn-shanghai.opensearch.aliyuncs.com/v3/openapi/workspaces/default/text-embedding/ops-text-embedding-001'),
    }(name='content'),
    createTime?: string(name='createTime', example='2024-05-21 16:05:26'),
    dimension?: int32(name='dimension', example='128'),
    name?: string(name='name', example='test'),
    status?: string(name='status', example='ok'),
    type?: string(name='type', example='text_embedding'),
    updateTime?: string(name='updateTime', example='2024-05-21 16:05:26'),
    url?: string(name='url', example='http://***.platform-cn-shanghai.opensearch.aliyuncs.com/v3/openapi/workspaces/default/text-embedding/ops-text-embedding-001'),
  }(name='result'),
}

model GetModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetModelResponseBody(name='body'),
}

/**
 * @summary 通过实例ID和模型名称查询特定模型的详细配置信息。
 *
 * @description ## 请求说明
 * - 该API用于获取指定实例下的特定模型的详细信息，包括模型类型、URL、状态等。
 * - 确保提供的`instanceId`和`modelName`是有效的，否则可能返回错误或找不到资源。
 * - 返回的数据结构中包含了模型的内容（如请求头、参数等）以及创建和更新时间，有助于了解模型的具体配置及其最新状态。
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetModelResponse
 */
async function getModelWithOptions(instanceId: string, modelName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetModelResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetModel',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/models/${OpenApiUtil.getEncodeParam(modelName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 通过实例ID和模型名称查询特定模型的详细配置信息。
 *
 * @description ## 请求说明
 * - 该API用于获取指定实例下的特定模型的详细信息，包括模型类型、URL、状态等。
 * - 确保提供的`instanceId`和`modelName`是有效的，否则可能返回错误或找不到资源。
 * - 返回的数据结构中包含了模型的内容（如请求头、参数等）以及创建和更新时间，有助于了解模型的具体配置及其最新状态。
 *
 * @return GetModelResponse
 */
async function getModel(instanceId: string, modelName: string): GetModelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getModelWithOptions(instanceId, modelName, headers, runtime);
}

model GetNodeConfigRequest {
  clusterName?: string(name='clusterName', description='The name of the cluster', example='vpc_sh_domain_2'),
  name?: string(name='name', description='The node name.', example='ha-cn-30174dhoz53_qrs'),
  type?: string(name='type', description='The node type. Valid values:

*   qrs: Query Result Searcher (QRS) worker
*   search: Search worker
*   index: index
*   cluster: cluster', example='index'),
}

model GetNodeConfigResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='2AE63638-5420-56DC-BF59-37D8174039A0'),
  result?: {
    active?: boolean(name='active', description='Indicates whether the index is effective online.', example='1'),
    dataDuplicateNumber?: int32(name='dataDuplicateNumber', description='The number of data replicas.', example='2'),
    dataFragmentNumber?: int32(name='dataFragmentNumber', description='The number of data shards.', example='2'),
    flowRatio?: int32(name='flowRatio', description='The traffic percentage.', example='0'),
    minServicePercent?: int32(name='minServicePercent', description='The minimum service ratio.', example='100'),
    published?: boolean(name='published', description='Indicates whether the cluster is mounted.', example='true'),
  }(name='result', description='The result set.'),
}

model GetNodeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetNodeConfigResponseBody(name='body'),
}

/**
 * @summary Gets the configuration information of a node.
 *
 * @param request GetNodeConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetNodeConfigResponse
 */
async function getNodeConfigWithOptions(instanceId: string, request: GetNodeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetNodeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterName)) {
    query['clusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeConfig',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/node-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Gets the configuration information of a node.
 *
 * @param request GetNodeConfigRequest
 * @return GetNodeConfigResponse
 */
async function getNodeConfig(instanceId: string, request: GetNodeConfigRequest): GetNodeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getNodeConfigWithOptions(instanceId, request, headers, runtime);
}

model GetSqlInstanceRequest {
  version?: long(name='version', example='1'),
}

model GetSqlInstanceResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='10D5E615-69F7-5F49-B850-00169ADE513C'),
  result?: {
    combineParams?: string(name='combineParams', example='{\\\\"trace\\\\":\\\\"INFO\\\\",\\\\"databaseName\\\\":\\\\"general\\\\",\\\\"iquan.plan.cache.enable\\\\":true,\\\\"iquan.plan.prepare.level\\\\":\\\\"jni.post.optimize\\\\",\\\\"urlencode_data\\\\":false,\\\\"formatType\\\\":\\\\"string\\\\",\\\\"timeout\\\\":1000}'),
    comment?: string(name='comment', example='init version'),
    content?: string(name='content', example='select * from test'),
    dynamicParams?: string(name='dynamicParams', example='{\\\\"trace\\\\":\\\\"INFO\\\\",\\\\"databaseName\\\\":\\\\"general\\\\",\\\\"iquan.plan.cache.enable\\\\":true,\\\\"iquan.plan.prepare.level\\\\":\\\\"jni.post.optimize\\\\",\\\\"urlencode_data\\\\":false,\\\\"formatType\\\\":\\\\"string\\\\",\\\\"timeout\\\\":1000}'),
    gmtCreate?: string(name='gmtCreate', example='1719220182844'),
    gmtModified?: string(name='gmtModified', example='1719221186114'),
    instanceId?: long(name='instanceId', example='ha-cn-pl32rf0****'),
    kvpairs?: string(name='kvpairs', example='{\\\\"trace\\\\":\\\\"INFO\\\\",\\\\"databaseName\\\\":\\\\"general\\\\",\\\\"iquan.plan.cache.enable\\\\":true,\\\\"iquan.plan.prepare.level\\\\":\\\\"jni.post.optimize\\\\",\\\\"urlencode_data\\\\":false,\\\\"formatType\\\\":\\\\"string\\\\",\\\\"timeout\\\\":1000}'),
    relatedTemplateId?: long(name='relatedTemplateId', example='1'),
    staticParams?: string(name='staticParams', example='{\\\\"trace\\\\":\\\\"INFO\\\\",\\\\"databaseName\\\\":\\\\"general\\\\",\\\\"iquan.plan.cache.enable\\\\":true,\\\\"iquan.plan.prepare.level\\\\":\\\\"jni.post.optimize\\\\",\\\\"urlencode_data\\\\":false,\\\\"formatType\\\\":\\\\"string\\\\",\\\\"timeout\\\\":1000}'),
    templateParams?: string(name='templateParams', example='{\\\\"trace\\\\":\\\\"INFO\\\\",\\\\"databaseName\\\\":\\\\"general\\\\",\\\\"iquan.plan.cache.enable\\\\":true,\\\\"iquan.plan.prepare.level\\\\":\\\\"jni.post.optimize\\\\",\\\\"urlencode_data\\\\":false,\\\\"formatType\\\\":\\\\"string\\\\",\\\\"timeout\\\\":1000}'),
    version?: long(name='version', example='1'),
  }(name='result', description='InstanceVersionVO'),
}

model GetSqlInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSqlInstanceResponseBody(name='body'),
}

/**
 * @param request GetSqlInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSqlInstanceResponse
 */
async function getSqlInstanceWithOptions(instanceId: string, database: string, sqlInstanceId: string, request: GetSqlInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetSqlInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.version)) {
    query['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSqlInstance',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/sql-studio/databases/${OpenApiUtil.getEncodeParam(database)}/sql-instances/${OpenApiUtil.getEncodeParam(sqlInstanceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetSqlInstanceRequest
 * @return GetSqlInstanceResponse
 */
async function getSqlInstance(instanceId: string, database: string, sqlInstanceId: string, request: GetSqlInstanceRequest): GetSqlInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSqlInstanceWithOptions(instanceId, database, sqlInstanceId, request, headers, runtime);
}

model GetTableResponseBody = {
  requestId?: string(name='requestId', description='requestId', example='2AE63638-5420-56DC-BF59-37D8174039A0'),
  result?: {
    dataProcessConfig?: [ 
      {
        dstField?: string(name='dstField', description='The destination field.', example='source_image_vector'),
        operator?: string(name='operator', description='The method used to process the field. Valid values: copy and vectorize. A value of copy indicates that the value of the source field is copied to the destination field. A value of vectorize indicates that the value of the source field is vectorized by a vectorization model and the output vector is stored in the destination field.', example='vectorize'),
        params?: {
          srcFieldConfig?: {
            ossBucket?: string(name='ossBucket', description='OSS Bucket', example='test'),
            ossEndpoint?: string(name='ossEndpoint', description='The Object Storage Service (OSS) endpoint.', example='oss-cn-hangzhou-internal.aliyuncs.com'),
            uid?: string(name='uid', description='The ID of the Alibaba Cloud account.', example='uid'),
          }(name='srcFieldConfig', description='The source of the data to be vectorized.'),
          vectorModal?: string(name='vectorModal', description='The data type.', example='image'),
          vectorModel?: string(name='vectorModel', description='The vectorization model.', example='clip'),
        }(name='params', description='The information about the model.'),
        srcField?: string(name='srcField', description='The source field.', example='source_image'),
      }
    ](name='dataProcessConfig', description='The configurations about field processing.'),
    dataProcessorCount?: int32(name='dataProcessorCount', example='1'),
    dataSource?: {
      autoBuildIndex?: boolean(name='autoBuildIndex', example='true'),
      config?: {
        accessKey?: string(name='accessKey', description='AK', example='ak'),
        accessSecret?: string(name='accessSecret', description='AS', example='as'),
        bucket?: string(name='bucket', example='heytea-ops-oss'),
        endpoint?: string(name='endpoint', example='http://service.cn-hangzhou.maxcompute.aliyun-inc.com/api'),
        namespace?: string(name='namespace', example='namespace'),
        ossPath?: string(name='ossPath', example='/opensearch_index_data/sift_oss_test.data'),
        partition?: string(name='partition', example='ds=20220808'),
        path?: string(name='path', example='vendor/sebastian/comparator/src/exceptions'),
        project?: string(name='project', example='dp_pdm_marketing_prod'),
        table?: string(name='table', example='test_add'),
      }(name='config'),
      dataTimeSec?: int32(name='dataTimeSec', example='1715160176'),
      type?: string(name='type', example='odps'),
    }(name='dataSource'),
    fieldSchema?: map[string]string(name='fieldSchema', description='The field. The value is a key-value pair in which the key indicates the field name and value indicates the field type.'),
    name?: string(name='name', example='test_oss'),
    partitionCount?: int32(name='partitionCount', example='1'),
    primaryKey?: string(name='primaryKey', example='id'),
    rawSchema?: string(name='rawSchema', example='{}'),
    status?: string(name='status', description='The state of the index table. Valid values: NEW, PUBLISH, IN_USE, NOT_USE, STOP_USE, RESTORE_USE, and FAIL. After an index is created in an OpenSearch Retrieval Engine Edition instance, the index enters the IN_USE state. If the first full index fails to be created in an OpenSearch Vector Search Edition instance of the new version, the index is in the FAIL state.', example='IN_USE'),
    vectorIndex?: [ 
      {
        advanceParams?: {
          buildIndexParams?: string(name='buildIndexParams', description='The index building parameters.', example='{}'),
          linearBuildThreshold?: string(name='linearBuildThreshold', description='The threshold for linear building.', example='5000'),
          minScanDocCnt?: string(name='minScanDocCnt', description='The minimum number of retrieved candidate sets.', example='20000'),
          searchIndexParams?: string(name='searchIndexParams', description='The index retrieval parameters.', example='{}'),
        }(name='advanceParams', description='The configurations of the index schema.'),
        dimension?: string(name='dimension', description='The dimension of the vector.', example='128'),
        distanceType?: string(name='distanceType', description='The distance type.', example='SquaredEuclidean'),
        indexName?: string(name='indexName', description='The name of the index schema.', example='test_odps'),
        namespace?: string(name='namespace', description='The namespace field.', example='namespace'),
        sparseIndexField?: string(name='sparseIndexField', description='The field that stores the indexes of the elements in sparse vectors.', example='sparse_indices'),
        sparseValueField?: string(name='sparseValueField', description='The field that stores the elements in sparse vectors.', example='sparse_values'),
        vectorField?: string(name='vectorField', description='The vector field.', example='source_image_vector'),
        vectorIndexType?: string(name='vectorIndexType', description='The vector retrieval algorithm.', example='Qc'),
      }
    ](name='vectorIndex', description='The index schema.'),
  }(name='result', description='The results returned.'),
}

model GetTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTableResponseBody(name='body'),
}

/**
 * @summary Queries the information about an index table.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTableResponse
 */
async function getTableWithOptions(instanceId: string, tableName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTable',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/tables/${OpenApiUtil.getEncodeParam(tableName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about an index table.
 *
 * @return GetTableResponse
 */
async function getTable(instanceId: string, tableName: string): GetTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableWithOptions(instanceId, tableName, headers, runtime);
}

model GetTableGenerationResponseBody = {
  requestId?: string(name='requestId', description='requestId', example='E7B7D598-B080-5C8E-AA35-D43EC0D5F886'),
  result?: {
    generationId?: long(name='generationId', description='generationId', example='1708674867'),
    status?: string(name='status', description='starting, building, ready, stopped, failed', example='ready'),
  }(name='result', description='The result returned.'),
}

model GetTableGenerationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTableGenerationResponseBody(name='body'),
}

/**
 * @summary Queries the status of an index version based on the ID of the full index version.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTableGenerationResponse
 */
async function getTableGenerationWithOptions(instanceId: string, tableName: string, generationId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableGenerationResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTableGeneration',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/tables/${OpenApiUtil.getEncodeParam(tableName)}/index_versions/${OpenApiUtil.getEncodeParam(generationId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the status of an index version based on the ID of the full index version.
 *
 * @return GetTableGenerationResponse
 */
async function getTableGeneration(instanceId: string, tableName: string, generationId: string): GetTableGenerationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableGenerationWithOptions(instanceId, tableName, generationId, headers, runtime);
}

model ListAdvanceConfigDirRequest {
  dirName?: string(name='dirName', description='The name of the directory

This parameter is required.', example='/zones/general'),
}

model ListAdvanceConfigDirResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='2AE63638-5420-56DC-BF59-37D8174039A0'),
  result?: [ 
    {
      fullPathName?: string(name='fullPathName', description='The absolute path in which the file is stored.', example='"/path/wpd/nae"'),
      isDir?: boolean(name='isDir', description='Indicates whether the file is a directory. Valid values: true and false.', example='true'),
      isTemplate?: boolean(name='isTemplate', description='Indicates whether the file is a template. Valid values: **true** and **false**.', example='true'),
      name?: string(name='name', description='The cluster name.', example='file_name_1'),
    }
  ](name='result', description='The advanced configuration files.'),
}

model ListAdvanceConfigDirResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAdvanceConfigDirResponseBody(name='body'),
}

/**
 * @summary Queries the files in an advanced configuration directory.
 *
 * @description ## Method
 * `GET`
 * ## URI
 * `/openapi/ha3/instances/{instanceId}/advanced-configs/{configName}/dir?dirName={dirName}`
 *
 * @param request ListAdvanceConfigDirRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAdvanceConfigDirResponse
 */
async function listAdvanceConfigDirWithOptions(instanceId: string, configName: string, request: ListAdvanceConfigDirRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAdvanceConfigDirResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dirName)) {
    query['dirName'] = request.dirName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAdvanceConfigDir',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/advanced-configs/${OpenApiUtil.getEncodeParam(configName)}/dir`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the files in an advanced configuration directory.
 *
 * @description ## Method
 * `GET`
 * ## URI
 * `/openapi/ha3/instances/{instanceId}/advanced-configs/{configName}/dir?dirName={dirName}`
 *
 * @param request ListAdvanceConfigDirRequest
 * @return ListAdvanceConfigDirResponse
 */
async function listAdvanceConfigDir(instanceId: string, configName: string, request: ListAdvanceConfigDirRequest): ListAdvanceConfigDirResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAdvanceConfigDirWithOptions(instanceId, configName, request, headers, runtime);
}

model ListAdvanceConfigsRequest {
  dataSourceName?: string(name='dataSourceName', description='The name of the data source.', example='ha-cn-pl32rf0****_test_api'),
  indexName?: string(name='indexName', description='The index name.', example='test_api'),
  newMode?: boolean(name='newMode', description='Specifies whether the OpenSearch Vector Search Edition instance is of the new version.', example='true'),
  pageNumber?: string(name='pageNumber'),
  pageSize?: string(name='pageSize'),
  type?: string(name='type', description='The type of advanced configurations that you want to query. Valid values: - online -offline (default)', example='online'),
}

model ListAdvanceConfigsResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='4FB0325E-8C37-5525-96AC-0333523170A3'),
  result?: [ 
    {
      advanceConfigType?: string(name='advanceConfigType', description='*   The type of the advanced configuration. Valid values: -ONLINE: online configuration
*   \\\\-ONLINE_CAVA: online Cava configuration
*   \\\\-ONLINE_PLUGIN: online plug-in configuration
*   \\\\-ONLINE_QUERY: query configuration
*   \\\\-OFFLINE_DICT: offline dictionary configuration
*   \\\\-OFFLINE_TABLE: offline table configuration
*   \\\\-OFFLINE_COMMON: offline configuration
*   \\\\-OFFLINE_PLUGIN: offline plug-in configuration
*   \\\\-OFFLINE_INDEX: index configuration', example='ONLINE'),
      content?: string(name='content', description='The content of the advanced configuration that is returned.', example='{\\\\"url\\\\":\\\\"http://xxxxxx.aliyuncs.com/outnet_hz/packages/xxxxx/opensearch_offline_plugins_xxxxx.tar\\\\"}'),
      contentType?: string(name='contentType', description='The type of the configuration content. Valid values: FILE, GIT, HTTP, and ODPS.', example='FILE'),
      creator?: string(name='creator', description='The Alibaba Cloud account ID of the user who created the advanced configuration.', example='123456'),
      desc?: string(name='desc', description='The description of the advanced configuration.', example='test'),
      files?: [ 
        {
          fullPathName?: string(name='fullPathName', description='The absolute path in which the file is stored.', example='/path/wpd/nae'),
          isDir?: boolean(name='isDir', description='Indicates whether the file is a directory. Valid values: true and false.', example='true'),
          isTemplate?: boolean(name='isTemplate', description='Indicates whether the file is a template. Valid values: true and false.', example='true'),
          name?: string(name='name', description='The file name.', example='file_name_1'),
        }
      ](name='files', description='The files.'),
      name?: string(name='name', description='The name of the advanced configuration.', example='my_index'),
      status?: string(name='status', description='The status of the advanced configuration. Valid values: drafting: The advanced configuration is in the draft state. used: The advanced configuration is being used. unused: The advanced configuration is not used. trash: The advanced configuration is being deleted.', example='drafting'),
      updateTime?: long(name='updateTime', description='The time when the advanced configuration was updated.', example='1631070464000'),
    }
  ](name='result', description='The advanced configurations.'),
}

model ListAdvanceConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAdvanceConfigsResponseBody(name='body'),
}

/**
 * @summary Obtains a list of advanced configurations.
 *
 * @description ## Sample requests
 * `GET /openapi/ha3/instances/ose-test1/advanced-configs`
 *
 * @param request ListAdvanceConfigsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAdvanceConfigsResponse
 */
async function listAdvanceConfigsWithOptions(instanceId: string, request: ListAdvanceConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAdvanceConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dataSourceName)) {
    query['dataSourceName'] = request.dataSourceName;
  }
  if (!Util.isUnset(request.indexName)) {
    query['indexName'] = request.indexName;
  }
  if (!Util.isUnset(request.newMode)) {
    query['newMode'] = request.newMode;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAdvanceConfigs',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/advanced-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains a list of advanced configurations.
 *
 * @description ## Sample requests
 * `GET /openapi/ha3/instances/ose-test1/advanced-configs`
 *
 * @param request ListAdvanceConfigsRequest
 * @return ListAdvanceConfigsResponse
 */
async function listAdvanceConfigs(instanceId: string, request: ListAdvanceConfigsRequest): ListAdvanceConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAdvanceConfigsWithOptions(instanceId, request, headers, runtime);
}

model ListAliasesResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='10D5E615-69F7-5F49-B850-00169ADE513C'),
  result?: [ 
    {
      alias?: string(name='alias', description='alias name', example='test'),
      index?: string(name='index', description='index name', example='index'),
    }
  ](name='result', description='List'),
}

model ListAliasesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAliasesResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAliasesResponse
 */
async function listAliasesWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListAliasesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListAliases',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/aliases`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @return ListAliasesResponse
 */
async function listAliases(instanceId: string): ListAliasesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAliasesWithOptions(instanceId, headers, runtime);
}

model ListClusterNamesResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='F6E3D968-529C-5C40-AFDD-133A8B8FD930'),
  result?: {
    description?: string(name='description', description='The description of the cluster.', example='ha3_test'),
    id?: long(name='id', description='The cluster ID.', example='25030'),
    name?: string(name='name', description='The cluster name.', example='my_index'),
  }(name='result', description='The result set.'),
}

model ListClusterNamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClusterNamesResponseBody(name='body'),
}

/**
 * @summary Queries cluster names.
 *
 * @description ### Method
 * GET
 * ### URI
 * /openapi/ha3/instances/{instanceId}/cluster-names
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClusterNamesResponse
 */
async function listClusterNamesWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListClusterNamesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListClusterNames',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/cluster-names`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries cluster names.
 *
 * @description ### Method
 * GET
 * ### URI
 * /openapi/ha3/instances/{instanceId}/cluster-names
 *
 * @return ListClusterNamesResponse
 */
async function listClusterNames(): ListClusterNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listClusterNamesWithOptions(headers, runtime);
}

model ListClusterTasksResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='CC5EC8FA-5C0D-56AF-BEF4-6FCCEABD0511'),
  result?: [ 
    {
      extraAttribute?: string(name='extraAttribute', description='The additional attributes of the card.', example='" "'),
      field3?: string(name='field3', description='The field3 field that was passed when the FSM was created.', example='" "'),
      fsmId?: string(name='fsmId', description='The ID of the finite state machine (FSM).', example='tisplus_opensearch@datasource_flow_fsm@1865410598556969-ha-cn-zvp2ljiwe01_api2@bj_vpc_domain_1@null@MANUAL-ha-cn-zvp2ljiwe01_api2@1649729867698@028315'),
      groupType?: string(name='groupType', description='The change group type.', example='" "'),
      name?: string(name='name', description='The card name.', example='ha-cn-pl32rf0js04_qrs'),
      status?: string(name='status', description='The FSM status.', example='onlyPublished'),
      tags?: [ 
        {
          msg?: string(name='msg', description='The tag content.', example='succeed in handling request'),
          tagLevel?: string(name='tagLevel', description='The tag level.', example='" "'),
        }
      ](name='tags', description='The tags of the progress bar.'),
      taskNodes?: [ 
        {
          finishDate?: string(name='finishDate', description='The time when the task was complete.', example='" "'),
          index?: long(name='index', description='The ordinal number of the task.', example='100'),
          name?: string(name='name', description='The task name.', example='general'),
          status?: string(name='status', description='The task status.', example='2'),
        }
      ](name='taskNodes', description='The task information.'),
      time?: string(name='time', description='The timestamp of the card.', example='1657610520'),
      type?: string(name='type', description='The card type.', example='qrs'),
      user?: string(name='user', description='The user who triggered the generation of the FSM process.', example='" "'),
    }
  ](name='result', description='The index information.'),
}

model ListClusterTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClusterTasksResponseBody(name='body'),
}

/**
 * @summary Queries cluster tasks.
 *
 * @description ### Method
 * ```java
 * GET
 * ```
 * ### URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/cluster-tasks
 * ```
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClusterTasksResponse
 */
async function listClusterTasksWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListClusterTasksResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListClusterTasks',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/cluster-tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries cluster tasks.
 *
 * @description ### Method
 * ```java
 * GET
 * ```
 * ### URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/cluster-tasks
 * ```
 *
 * @return ListClusterTasksResponse
 */
async function listClusterTasks(instanceId: string): ListClusterTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listClusterTasksWithOptions(instanceId, headers, runtime);
}

model ListClustersResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='F43E8AB4-419C-5F4C-90D6-615590DFAA3C'),
  result?: [ 
    {
      config?: map[string]object(name='config', description='The configuration information.'),
      configUpdateTime?: string(name='configUpdateTime', description='The time when the configuration was updated.', example='" "'),
      createTime?: string(name='createTime', description='The time when the cluster was created.', example='2024-05-21 16:05:26'),
      currentAdvanceConfigVersion?: string(name='currentAdvanceConfigVersion', description='The effective advanced configuration version.', example='" "'),
      currentOfflineDictConfigVersion?: string(name='currentOfflineDictConfigVersion', description='The effective dictionary configuration version.', example='ha-cn-pl32rf0****_offline_adv_v1'),
      currentOnlineConfigVersion?: string(name='currentOnlineConfigVersion', description='The effective online configuration version.', example='" "'),
      currentOnlineQueryConfigVersion?: string(name='currentOnlineQueryConfigVersion', description='The effective query configuration version.', example='ha-cn-pl32rf0****_offline_adv_v1'),
      dataNode?: {
        name?: string(name='name', description='The name of the Searcher worker.', example='ha-cn-8ed2k7brm05_qrs'),
        number?: int32(name='number', description='The number of Searcher workers.', example='1'),
        partition?: int32(name='partition', description='The ID of the partition that is stored on the Searcher worker.', example='dt=20220216'),
      }(name='dataNode', description='The information about Searcher workers.'),
      description?: string(name='description', description='The description of the cluster.', example='fzz_test'),
      latestAdvanceConfigVersion?: string(name='latestAdvanceConfigVersion', description='The latest advanced configuration version.', example='" "'),
      latestOfflineDictConfigVersion?: string(name='latestOfflineDictConfigVersion', description='The latest dictionary configuration version.', example='ha-cn-pl32rf0****_offline_adv_v1'),
      latestOnlineConfigVersion?: string(name='latestOnlineConfigVersion', description='The latest online configuration version.', example='" "'),
      latestOnlineQueryConfigVersion?: string(name='latestOnlineQueryConfigVersion', description='The latest query configuration version.', example='ha-cn-pl32rf0****_offline_adv_v1'),
      name?: string(name='name', description='The cluster name.', example='ha-cn-7pp2pcna701_qrs'),
      queryNode?: {
        name?: string(name='name', description='The name of the QRS worker.', example='test_0704'),
        number?: int32(name='number', description='The number of QRS workers.', example='1'),
        partition?: int32(name='partition', description='The ID of the partition that is stored on the QRS worker.', example='dt=20211216'),
      }(name='queryNode', description='The information about Query Result Searcher (QRS) workers.'),
      status?: string(name='status', description='The cluster status. Valid values: running: The cluster is running. starting: The cluster is being started. stopping: The cluster is being stopped. stopped: The cluster is stopped.', example='"starting"'),
    }
  ](name='result', description='The clusters.'),
}

model ListClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClustersResponseBody(name='body'),
}

/**
 * @summary Queries clusters.
 *
 * @description ### Method
 * ```java
 * GET
 * ```
 * ### URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/clusters
 * ```
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClustersResponse
 */
async function listClustersWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListClustersResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListClusters',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/clusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries clusters.
 *
 * @description ### Method
 * ```java
 * GET
 * ```
 * ### URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/clusters
 * ```
 *
 * @return ListClustersResponse
 */
async function listClusters(instanceId: string): ListClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listClustersWithOptions(instanceId, headers, runtime);
}

model ListDataSourceSchemasResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='022F36C7-9FB4-5D67-BEBC-3D14B0984463'),
  result?: [ 
    {
      addIndex?: boolean(name='addIndex', description='Indicates whether the field has the index attribute. Valid values: **true** and **false**.', example='false'),
      attribute?: boolean(name='attribute', description='Indicates whether the field is an attribute field. Valid values: **true** and **false**.', example='false'),
      custom?: boolean(name='custom', description='Indicates whether the field is a custom field. Valid values: **true** and **false**.', example='false'),
      name?: string(name='name', description='The field name.', example='test'),
      primaryKey?: {
        hasPrimaryKeyAttribute?: boolean(name='hasPrimaryKeyAttribute', description='Indicates whether the field has the primary key attribute. Valid values: **true** and **false**.', example='false'),
        isPrimaryKey?: boolean(name='isPrimaryKey', description='Indicates whether the field is the primary key. Valid values: **true** and **false**.', example='false'),
        isPrimaryKeySorted?: boolean(name='isPrimaryKeySorted', description='Indicates whether the field can be sorted. Valid values: **true** and **false**.', example='false'),
      }(name='primaryKey', description='The primary key field.'),
      summary?: boolean(name='summary', description='Indicates whether the field can be displayed. Valid values: **true** and **false**.', example='false'),
      type?: string(name='type', description='The field type.', example='STRING'),
    }
  ](name='result', description='The results returned.'),
}

model ListDataSourceSchemasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataSourceSchemasResponseBody(name='body'),
}

/**
 * @summary Queries the schema information about a data source.
 *
 * @description ## Method
 * `GET`
 * ## URI
 * `/openapi/ha3/instances/{instanceId}/data-sources/{dataSourceName}/schemas`
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataSourceSchemasResponse
 */
async function listDataSourceSchemasWithOptions(instanceId: string, dataSourceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataSourceSchemasResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDataSourceSchemas',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/data-sources/${OpenApiUtil.getEncodeParam(dataSourceName)}/schemas`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the schema information about a data source.
 *
 * @description ## Method
 * `GET`
 * ## URI
 * `/openapi/ha3/instances/{instanceId}/data-sources/{dataSourceName}/schemas`
 *
 * @return ListDataSourceSchemasResponse
 */
async function listDataSourceSchemas(instanceId: string, dataSourceName: string): ListDataSourceSchemasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataSourceSchemasWithOptions(instanceId, dataSourceName, headers, runtime);
}

model ListDataSourceTasksResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='CC5EC8FA-5C0D-56AF-BEF4-6FCCEABD0511'),
  result?: [ 
    {
      extraAttribute?: string(name='extraAttribute', description='The additional attributes of the card.', example='""'),
      field3?: string(name='field3', description='The field3 field that was passed when the FSM was created.', example='""'),
      fsmId?: string(name='fsmId', description='The ID of the finite state machine (FSM).', example='tisplus_opensearch@datasource_flow_fsm@1062017779051424-ha-cn-2r42ostoc01_ecom_table@vpc_hz_domain_1@null@MANUAL-ha-cn-2r42ostoc01_ecom_table@1655974525756@006754'),
      groupType?: string(name='groupType', description='The change group type.', example='" "'),
      name?: string(name='name', description='The card name.', example='general'),
      status?: string(name='status', description='The FSM status.', example='2'),
      tags?: [ 
        {
          msg?: string(name='msg', description='The tag content.', example='succeed in handling request'),
          tagLevel?: string(name='tagLevel', description='The tag level.', example='""'),
        }
      ](name='tags', description='The tags of the progress bar.'),
      taskNodes?: [ 
        {
          finishDate?: string(name='finishDate', description='The time when the task was complete.', example='""'),
          index?: long(name='index', description='The ordinal number of the task.', example='100'),
          name?: string(name='name', description='The task name.', example='ha-cn-7pp2ngv4s02_qrs'),
          status?: string(name='status', description='The task status.', example='onlyPublished'),
        }
      ](name='taskNodes', description='The task information.'),
      time?: string(name='time', description='The timestamp of the card.', example='1646279473'),
      type?: string(name='type', description='The card type.', example='search'),
      user?: string(name='user', description='The user who triggered the generation of the FSM process.', example='""'),
    }
  ](name='result', description='The index information.'),
}

model ListDataSourceTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataSourceTasksResponseBody(name='body'),
}

/**
 * @summary Displays data source tasks.
 *
 * @description ### [](#)Method
 * ```java
 * GET
 * ```
 * ### [](#uri)URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/data-source-tasks
 * ```
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataSourceTasksResponse
 */
async function listDataSourceTasksWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataSourceTasksResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDataSourceTasks',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/data-source-tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Displays data source tasks.
 *
 * @description ### [](#)Method
 * ```java
 * GET
 * ```
 * ### [](#uri)URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/data-source-tasks
 * ```
 *
 * @return ListDataSourceTasksResponse
 */
async function listDataSourceTasks(instanceId: string): ListDataSourceTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataSourceTasksWithOptions(instanceId, headers, runtime);
}

model ListDataSourcesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='93A9E542-8CF8-5BA6-99AB-94C0FE520429'),
  result?: [ 
    {
      domain?: string(name='domain', description='The data center in which the data source is deployed.', example='test'),
      indexes?: [ string ](name='indexes', description='The indexes.'),
      lastFulTime?: long(name='lastFulTime', description='The time when the full data of the data source was last queried.', example='1718787785'),
      name?: string(name='name', description='The name of the data source.', example='data_source_name'),
      status?: string(name='status', description='The status of the data source. Valid values: new: The data source is being created. publish: The data source is in the normal state. trash: The data source is being deleted.', example='new'),
      type?: string(name='type', description='The type of the data source.', example='odps'),
    }
  ](name='result', description='The results returned.'),
}

model ListDataSourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataSourcesResponseBody(name='body'),
}

/**
 * @summary Obtains the list of data sources.
 *
 * @description ## Method
 * `GET`
 * ## URI
 * `/openapi/ha3/instances/{instanceId}/data-sources`
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataSourcesResponse
 */
async function listDataSourcesWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataSourcesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDataSources',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/data-sources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains the list of data sources.
 *
 * @description ## Method
 * `GET`
 * ## URI
 * `/openapi/ha3/instances/{instanceId}/data-sources`
 *
 * @return ListDataSourcesResponse
 */
async function listDataSources(instanceId: string): ListDataSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataSourcesWithOptions(instanceId, headers, runtime);
}

model ListDatabasesResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='E45380E8-994A-5402-9806-F114B3295FCF'),
  result?: {
    databases?: [ 
      {
        database?: string(name='database', example='general'),
        functions?: map[string][ ResultDatabasesFunctionsValue         ](name='functions'),
        sqlInstances?: [ 
          {
            children?: [ any ](name='children'),
            id?: long(name='id', example='12190'),
            instanceId?: long(name='instanceId', example='1'),
            isDir?: int32(name='isDir', example='true'),
            name?: string(name='name', example='general'),
            parent?: long(name='parent', example='-1'),
            templateId?: long(name='templateId', example='1'),
            type?: string(name='type', description='table, instance, template, function', example='instance'),
          }
        ](name='sqlInstances'),
        tables?: [ 
          {
            children?: [ any ](name='children'),
            id?: long(name='id', example='56'),
            instanceId?: long(name='instanceId', example='1'),
            isDir?: int32(name='isDir', example='true'),
            name?: string(name='name', example='general'),
            parent?: long(name='parent', example='-1'),
            templateId?: long(name='templateId', example='1'),
            type?: string(name='type', description='table, instance, template, function', example='table'),
          }
        ](name='tables'),
        templates?: [ 
          {
            children?: [ any ](name='children'),
            id?: long(name='id', example='1'),
            instanceId?: long(name='instanceId', example='1'),
            isDir?: int32(name='isDir', example='true'),
            name?: string(name='name', example='c26_schema'),
            parent?: long(name='parent', example='-1'),
            templateId?: long(name='templateId', example='1'),
            type?: string(name='type', description='table, instance, template, function', example='template'),
          }
        ](name='templates'),
      }
    ](name='databases'),
  }(name='result', description='NodeTreeVO'),
}

model ListDatabasesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDatabasesResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDatabasesResponse
 */
async function listDatabasesWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDatabasesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDatabases',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/sql-studio/databases`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @return ListDatabasesResponse
 */
async function listDatabases(instanceId: string): ListDatabasesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDatabasesWithOptions(instanceId, headers, runtime);
}

model ListDateSourceGenerationsRequest {
  domainName?: string(name='domainName', description='The data center where the data source is deployed.

This parameter is required.', example='bj_vpc_domain_1'),
  validStatus?: boolean(name='validStatus', description='Specifies the index versions to be returned. Valid values:

1.  true (default): returns the index versions that are complete and not expired.
2.  false: returns all index versions.', example='true'),
}

model ListDateSourceGenerationsResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='022F36C7-9FB4-5D67-BEBC-3D14B0984463'),
  result?: [ 
    {
      buildDeployId?: int32(name='buildDeployId', description='The ID of the offline deployment.', example='122'),
      createTime?: long(name='createTime', description='The timestamp that was generated when the index building was started.', example='1626143673'),
      dataDumpRoot?: string(name='dataDumpRoot', description='The path of the dumped index in the Apsara File Storage for HDFS file system.', example='""'),
      generation?: long(name='generation', description='The ID of the full index version.', example='1626143930'),
      partition?: map[string]int32(name='partition', description='The shards of the index version. The value is a key-value pair in which the key indicates the index name and the value indicates the number of shards. The number of value shards.'),
      status?: string(name='status', description='The status of the index version.', example='STOPPED'),
      timestamp?: long(name='timestamp', description='The start timestamp from which incremental data is retrieved.', example='1626143673'),
    }
  ](name='result', description='List'),
}

model ListDateSourceGenerationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDateSourceGenerationsResponseBody(name='body'),
}

/**
 * @summary Queries the historical index versions of a data source.
 *
 * @description ### Method
 * `GET`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}/data-sources/{dataSourceName}/generations?domainName={domainName}`
 *
 * @param request ListDateSourceGenerationsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDateSourceGenerationsResponse
 */
async function listDateSourceGenerationsWithOptions(instanceId: string, dataSourceName: string, request: ListDateSourceGenerationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDateSourceGenerationsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.domainName)) {
    query['domainName'] = request.domainName;
  }
  if (!Util.isUnset(request.validStatus)) {
    query['validStatus'] = request.validStatus;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDateSourceGenerations',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/data-sources/${OpenApiUtil.getEncodeParam(dataSourceName)}/generations`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the historical index versions of a data source.
 *
 * @description ### Method
 * `GET`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}/data-sources/{dataSourceName}/generations?domainName={domainName}`
 *
 * @param request ListDateSourceGenerationsRequest
 * @return ListDateSourceGenerationsResponse
 */
async function listDateSourceGenerations(instanceId: string, dataSourceName: string, request: ListDateSourceGenerationsRequest): ListDateSourceGenerationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDateSourceGenerationsWithOptions(instanceId, dataSourceName, request, headers, runtime);
}

model ListIndexRecoverRecordsResponseBody = {
  desc?: string(name='desc', description='The description.', example='test'),
  finishedTime?: string(name='finishedTime', description='The time when the index version was published.', example='2024-06-07 16:43:00'),
  generationId?: string(name='generationId', description='The ID of the full index version.', example='1708674867'),
}

model ListIndexRecoverRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListIndexRecoverRecordsResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListIndexRecoverRecordsResponse
 */
async function listIndexRecoverRecordsWithOptions(indexName: string, instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListIndexRecoverRecordsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListIndexRecoverRecords',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/indexes/${OpenApiUtil.getEncodeParam(indexName)}/actions/list-recover-records`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @return ListIndexRecoverRecordsResponse
 */
async function listIndexRecoverRecords(indexName: string, instanceId: string): ListIndexRecoverRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIndexRecoverRecordsWithOptions(indexName, instanceId, headers, runtime);
}

model ListIndexesRequest {
  catalog?: string(name='catalog'),
  database?: string(name='database'),
  newMode?: boolean(name='newMode', description='Specifies whether the OpenSearch Vector Search Edition instance is of the new version.', example='true'),
  table?: string(name='table'),
}

model ListIndexesResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='4FB0325E-8C37-5525-96AC-0333523170A3'),
  result?: [ 
    {
      content?: string(name='content', description='The index schema, which is a JSON string.', example='{"summarys":{"parameter":{"file_compressor":"zstd"},"summary_fields":["id"]},"file_compress":[{"name":"file_compressor","type":"zstd"},{"name":"no_compressor","type":""}],"indexs":[{"index_fields":"name","index_name":"ids","index_type":"STRING"},{"has_primary_key_attribute":true,"index_fields":"id","is_primary_key_sorted":false,"index_name":"id","index_type":"PRIMARYKEY64"}],"attributes":[{"file_compress":"no_compressor","field_name":"id"}],"fields":[{"user_defined_param":{},"compress_type":"uniq","field_type":"STRING","field_name":"id"},{"compress_type":"uniq","field_type":"STRING","field_name":"name"}],"table_name":"api"}'),
      createTime?: string(name='createTime'),
      dataSource?: string(name='dataSource', description='The name of the data source.', example='ha-cn-7mz2kvu2c01_table4'),
      dataSourceInfo?: {
        autoBuildIndex?: boolean(name='autoBuildIndex', description='Indicates whether the automatic full indexing feature is enabled.', example='true'),
        config?: {
          accessKey?: string(name='accessKey', description='The AccessKey ID of the MaxCompute data source.', example='root'),
          accessSecret?: string(name='accessSecret', description='The AccessKey secret of the MaxCompute data source.', example='root123'),
          bucket?: string(name='bucket', description='The OSS bucket.', example='ha3test-oss'),
          catalog?: string(name='catalog'),
          database?: string(name='database'),
          endpoint?: string(name='endpoint', description='The endpoint of the MaxCompute data source.', example='http://service.cn-hangzhou.maxcompute.aliyun-inc.com/api'),
          format?: string(name='format'),
          namespace?: string(name='namespace', description='The namespace. This parameter is applicable to the SARO data source used in the intranet of Alibaba Group.', example='TEST_dump_demo_sj_na61hunbu2_share_holo'),
          ossPath?: string(name='ossPath', description='The Object Storage Service (OSS) path.', example='/test_opensearch/sift_oss_test.data'),
          partition?: string(name='partition', description='The shard name.', example='ds=12345'),
          path?: string(name='path', description='The file path in the Apsara File Storage for HDFS file system.', example='http://test_opensearch/sift_oss_test.data'),
          project?: string(name='project', description='The name of the MaxCompute project that is used as the data source.', example='tisplus_dev'),
          table?: string(name='table', description='The name of the MaxCompute table that is used as the data source.', example='dump_odps_demo'),
          tag?: string(name='tag'),
        }(name='config', description='The configuration of MaxCompute data sources.'),
        domain?: string(name='domain', description='The data center in which the data source is deployed.', example='test'),
        name?: string(name='name', description='The name of the data source.', example='index1'),
        processPartitionCount?: int32(name='processPartitionCount', description='The number of resources used for data update.', example='2'),
        saroConfig?: {
          namespace?: string(name='namespace', description='The namespace of the SARO data source.', example='TEST_dump_demo_sj_na61hunbu2_share_holo'),
          tableName?: string(name='tableName', description='The name of the SARO table.', example='dump_odps_demo'),
        }(name='saroConfig', description='The configurations of the SARO data source.'),
        type?: string(name='type', description='The type of the data source. Valid values: odps, swift, saro, oss, and unKnow.', example='odps'),
      }(name='dataSourceInfo', description='The information about the data source.'),
      description?: string(name='description', description='The description.', example='Description'),
      domain?: string(name='domain', description='The deployment name of the index.', example='test'),
      fullUpdateTime?: string(name='fullUpdateTime', description='The time when full data in the index was last updated.', example='2023-07-05 10:40:38'),
      fullVersion?: long(name='fullVersion', description='The full version of the index.', example='1688523414'),
      incUpdateTime?: string(name='incUpdateTime', description='The time when incremental data in the index was last updated.', example='2023-07-05 10:58:33'),
      indexSize?: long(name='indexSize', description='The index size.', example='4689'),
      indexStatus?: string(name='indexStatus', description='The index ststus. Valid values: NEW and PUBLISH.', example='" "'),
      name?: string(name='name', description='The index name.', example='general'),
      partition?: int32(name='partition', description='The number of shards.', example='2'),
      updateTime?: string(name='updateTime'),
      versions?: [ 
        {
          desc?: string(name='desc', description='The description of the index version.', example='close alarm, by 3.9.2 hotfix workflow'),
          files?: [ 
            {
              fullPathName?: string(name='fullPathName', description='The full path of the file.', example='" "'),
              isDir?: boolean(name='isDir', description='Indicates whether the file is a directory.', example='True'),
              isTemplate?: boolean(name='isTemplate', description='Indicates whether the file is a template.', example='True'),
              name?: string(name='name', description='The file name.', example='ha-cn-7mz2iv7sq01_qrs'),
            }
          ](name='files', description='The files.'),
          name?: string(name='name', description='The name of the index version.', example='ha-cn-7pp2ngv4s02_qrs'),
          status?: string(name='status', description='The status of the index version. Valid values:

*   NEW: The index version is created.
*   PUBLISH: The index version is normal.
*   IN_USE: The index version is in use.
*   NOT_USE: The index version is not used.
*   STOP_USE: The index version is being stopped.
*   RESTORE_USE: The index version is being restored.
*   FAIL: The index version failed to be created.', example='2'),
          updateTime?: long(name='updateTime', description='The time when the index version was updated.', example='" "'),
          versionId?: int32(name='versionId', description='The ID of the index version. If the index version is modified, the returned value is null.', example='1'),
        }
      ](name='versions', description='The index versions.'),
    }
  ](name='result', description='The details of indexes.'),
}

model ListIndexesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListIndexesResponseBody(name='body'),
}

/**
 * @summary Obtains the index list.
 *
 * @description ## Method
 *     GET
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/indexes
 *
 * @param request ListIndexesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListIndexesResponse
 */
async function listIndexesWithOptions(instanceId: string, request: ListIndexesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIndexesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalog)) {
    query['catalog'] = request.catalog;
  }
  if (!Util.isUnset(request.database)) {
    query['database'] = request.database;
  }
  if (!Util.isUnset(request.newMode)) {
    query['newMode'] = request.newMode;
  }
  if (!Util.isUnset(request.table)) {
    query['table'] = request.table;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIndexes',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/indexes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains the index list.
 *
 * @description ## Method
 *     GET
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/indexes
 *
 * @param request ListIndexesRequest
 * @return ListIndexesResponse
 */
async function listIndexes(instanceId: string, request: ListIndexesRequest): ListIndexesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIndexesWithOptions(instanceId, request, headers, runtime);
}

model ListInstanceSpecsRequest {
  type?: string(name='type', description='The node type. Valid values:

*   qrs: Query Result Searcher (QRS) Worker
*   search: Searcher Worker
*   index: index node
*   cluster: cluster

This parameter is required.', example='search'),
}

model ListInstanceSpecsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='10D5E615-69F7-5F49-B850-00169ADE513C'),
  result?: [ 
    {
      cpu?: int32(name='cpu', description='The number of vCPUs.', example='1'),
      maxDisk?: int32(name='maxDisk', description='The maximum storage of a single data node. Unit: GB.', example='600'),
      mem?: int32(name='mem', description='The memory of the instance. Unit: GB.', example='4'),
      minDisk?: int32(name='minDisk', description='The minimum storage of a single data node. Unit: GB.', example='100'),
    }
  ](name='result', description='The instance types.'),
}

model ListInstanceSpecsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstanceSpecsResponseBody(name='body'),
}

/**
 * @summary Queries the specifications of an instance.
 *
 * @description ### Method
 * `GET`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}/specs?type=qrs`
 *
 * @param request ListInstanceSpecsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstanceSpecsResponse
 */
async function listInstanceSpecsWithOptions(instanceId: string, request: ListInstanceSpecsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstanceSpecsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceSpecs',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/specs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the specifications of an instance.
 *
 * @description ### Method
 * `GET`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}/specs?type=qrs`
 *
 * @param request ListInstanceSpecsRequest
 * @return ListInstanceSpecsResponse
 */
async function listInstanceSpecs(instanceId: string, request: ListInstanceSpecsRequest): ListInstanceSpecsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstanceSpecsWithOptions(instanceId, request, headers, runtime);
}

model ListInstancesRequest {
  catalog?: string(name='catalog'),
  dataSourceType?: string(name='dataSourceType'),
  database?: string(name='database'),
  description?: string(name='description', description='The description of the instance. You can use this description to filter instances. Fuzzy match is supported.', example='Havenask instance'),
  edition?: string(name='edition', description='The instance type. Valid values: vector: OpenSearch Vector Search Edition instance. engine: OpenSearch Retrieval Engine Edition instance.', example='vector'),
  instanceId?: string(name='instanceId', description='The instance ID.', example='ha-cn-83570439y0n'),
  pageNumber?: int32(name='pageNumber', description='The number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries to return on each page. Valid values: 1 to 50. Default value: 10.', example='10'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-aekzgpiswzbksdi'),
  table?: string(name='table'),
  tags?: [ 
    {
      key?: string(name='key', description='The tag key.', example='backup'),
      value?: string(name='value', description='The tag value.', example='oboms-disk'),
    }
  ](name='tags', description='The tags of the instance.'),
}

model ListInstancesShrinkRequest {
  catalog?: string(name='catalog'),
  dataSourceType?: string(name='dataSourceType'),
  database?: string(name='database'),
  description?: string(name='description', description='The description of the instance. You can use this description to filter instances. Fuzzy match is supported.', example='Havenask instance'),
  edition?: string(name='edition', description='The instance type. Valid values: vector: OpenSearch Vector Search Edition instance. engine: OpenSearch Retrieval Engine Edition instance.', example='vector'),
  instanceId?: string(name='instanceId', description='The instance ID.', example='ha-cn-83570439y0n'),
  pageNumber?: int32(name='pageNumber', description='The number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries to return on each page. Valid values: 1 to 50. Default value: 10.', example='10'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-aekzgpiswzbksdi'),
  table?: string(name='table'),
  tagsShrink?: string(name='tags', description='The tags of the instance.'),
}

model ListInstancesResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request', example='89B968E6-1E41-58DF-BB25-5F98ECC759CE'),
  result?: [ 
    {
      chargeType?: string(name='chargeType', description='The billing method.', example='PrePaid'),
      commodityCode?: string(name='commodityCode', description='The commodity code of the instance.', example='""'),
      createTime?: string(name='createTime', description='The time when the instance was created.', example='2022-06-04T02:03:21Z'),
      dataSourceDetails?: [ 
        {
          config?: {
            accessKey?: string(name='accessKey'),
            bucket?: string(name='bucket'),
            catalog?: string(name='catalog'),
            database?: string(name='database'),
            endpoint?: string(name='endpoint'),
            namespace?: string(name='namespace'),
            ossPath?: string(name='ossPath'),
            partition?: string(name='partition'),
            path?: string(name='path'),
            project?: string(name='project'),
            table?: string(name='table'),
            tag?: string(name='tag'),
          }(name='config'),
          indexName?: string(name='indexName'),
          type?: string(name='type'),
        }
      ](name='dataSourceDetails'),
      description?: string(name='description', description='The description of the instance.', example='Emergency test'),
      edition?: string(name='edition'),
      expiredTime?: string(name='expiredTime', description='The time when the instance expires.', example='1634885083'),
      inDebt?: boolean(name='inDebt', description='Indicates whether an overdue payment is involved.', example='false'),
      instanceId?: string(name='instanceId', description='The instance ID.', example='ha-cn-2r42n8oh001'),
      lockMode?: string(name='lockMode', description='The lock state of the instance.', example='Unlock'),
      network?: {
        allow?: string(name='allow'),
        endpoint?: string(name='endpoint', description='The instance endpoint.', example='""'),
        publicEndpoint?: string(name='publicEndpoint'),
        vSwitchId?: string(name='vSwitchId', description='The vSwitch ID.', example='vsw-bp11ldcf59q2nbwkqgj6z'),
        vpcId?: string(name='vpcId', description='The ID of the virtual private cloud (VPC) in which the instance is deployed.', example='vpc-wz9axk41d9vffoc79x0oe'),
      }(name='network', description='The network information of the instance.'),
      noQrs?: boolean(name='noQrs'),
      resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group.', example='rg-aekzgpiswzbksdi'),
      spec?: {
        qrsResource?: {
          category?: string(name='category'),
          cpu?: int32(name='cpu'),
          disk?: int32(name='disk'),
          mem?: int32(name='mem'),
          nodeCount?: int32(name='nodeCount'),
        }(name='qrsResource'),
        searchResource?: {
          category?: string(name='category'),
          cpu?: int32(name='cpu'),
          disk?: int32(name='disk'),
          mem?: int32(name='mem'),
          nodeCount?: int32(name='nodeCount'),
        }(name='searchResource'),
      }(name='spec'),
      status?: string(name='status', description='The instance status.', example='2'),
      tags?: [ 
        {
          key?: string(name='key', description='The tag key.', example='env'),
          value?: string(name='value', description='The tag value.', example='oboms-disk'),
        }
      ](name='tags', description='The tags of the instance.'),
      updateTime?: string(name='updateTime', description='The time when the instance was updated.', example='2018-12-06T11:17:49.0'),
      userName?: string(name='userName'),
      version?: string(name='version'),
    }
  ](name='result', description='The results returned.'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned', example='5'),
}

model ListInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstancesResponseBody(name='body'),
}

/**
 * @summary Queries a list of instances.
 *
 * @description ### [](#)Method
 * `GET`
 * ### [](#uri)URI
 * `/openapi/ha3/instances`
 *
 * @param tmpReq ListInstancesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstancesResponse
 */
async function listInstancesWithOptions(tmpReq: ListInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(tmpReq);
  var request = new ListInstancesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'tags', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalog)) {
    query['catalog'] = request.catalog;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    query['dataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.database)) {
    query['database'] = request.database;
  }
  if (!Util.isUnset(request.description)) {
    query['description'] = request.description;
  }
  if (!Util.isUnset(request.edition)) {
    query['edition'] = request.edition;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.table)) {
    query['table'] = request.table;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['tags'] = request.tagsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of instances.
 *
 * @description ### [](#)Method
 * `GET`
 * ### [](#uri)URI
 * `/openapi/ha3/instances`
 *
 * @param request ListInstancesRequest
 * @return ListInstancesResponse
 */
async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstancesWithOptions(request, headers, runtime);
}

model ListLogsRequest {
  endTime?: string(name='endTime', description='The end tim. The value is a timestamp in seconds.', example='1710432000'),
  pageNum?: string(name='pageNum', description='The number of entries per num. Default value: 1.', example='1'),
  pageSize?: string(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
  query?: string(name='query', description='The query statement', example='status: 200 AND totalTime > 0.01'),
  startTime?: string(name='startTime', description='The start time. The value is a timestamp in seconds.', example='1706340600'),
  type?: string(name='type', description='-push   -select', example='push'),
}

model ListLogsResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='022F36C7-9FB4-5D67-BEBC-3D14B0984463'),
  result?: {
    result?: [ any ](name='result', description='The result.'),
    totalCount?: int32(name='totalCount', description='The total number of entries returned', example='5'),
  }(name='result', description='ListResult'),
}

model ListLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLogsResponseBody(name='body'),
}

/**
 * @param request ListLogsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListLogsResponse
 */
async function listLogsWithOptions(instanceId: string, request: ListLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['pageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogs',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/logs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request ListLogsRequest
 * @return ListLogsResponse
 */
async function listLogs(instanceId: string, request: ListLogsRequest): ListLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogsWithOptions(instanceId, request, headers, runtime);
}

model ListModelsRequest {
  name?: string(name='name', example='test1'),
  pageNumber?: int32(name='pageNumber', example='1'),
  pageSize?: int32(name='pageSize', example='10'),
  type?: string(name='type', example='text_embedding'),
}

model ListModelsResponseBody = {
  requestId?: string(name='requestId', example='38b079f1-7846-4226-8c90-3e2644b5c52b'),
  result?: [ 
    {
      content?: {
        method?: string(name='method', example='POST'),
        modelName?: string(name='modelName', example='test'),
        modelType?: string(name='modelType', example='text_embedding'),
        request?: {
          header?: {
            authorization?: string(name='Authorization', example='Bearer OS-v0********6vvs'),
            contentType?: string(name='Content-Type', example='application/json'),
          }(name='header'),
          parameters?: {
            build?: {
              inputType?: string(name='input_type', example='query'),
            }(name='build'),
            search?: {
              inputType?: string(name='input_type', example='document'),
            }(name='search'),
          }(name='parameters'),
          requestBody?: string(name='requestBody', example='{\\\\"input\\\\": [\\\\"%{input}\\\\"], \\\\"input_type\\\\": \\\\"%{input_type}\\\\"}'),
          urlParams?: {
            build?: map[string]any(name='build', example='key: value'),
            search?: map[string]any(name='search', example='key: value'),
          }(name='urlParams'),
        }(name='request'),
        response?: {
          embeddings?: string(name='embeddings', example='$.result.embeddings[*].embedding'),
        }(name='response'),
        url?: string(name='url', example='http://***.platform-cn-shanghai.opensearch.aliyuncs.com/v3/openapi/workspaces/default/text-embedding/ops-text-embedding-001'),
      }(name='content'),
      createTime?: string(name='createTime', example='2024-05-21 16:05:26'),
      dimension?: int32(name='dimension', example='128'),
      name?: string(name='name', example='test'),
      status?: string(name='status', example='ok'),
      type?: string(name='type', example='text_embedding'),
      updateTime?: string(name='updateTime', example='2024-05-21 16:05:26'),
      url?: string(name='url', example='http://***.platform-cn-shanghai.opensearch.aliyuncs.com/v3/openapi/workspaces/default/text-embedding/ops-text-embedding-001'),
    }
  ](name='result'),
  totalCount?: int32(name='totalCount', example='14'),
}

model ListModelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModelsResponseBody(name='body'),
}

/**
 * @summary 通过实例ID查询指定条件下的模型列表。
 *
 * @description ## 请求说明
 * 本API用于从指定实例中获取模型列表，支持通过模型名称、类型以及分页参数进行筛选。请求时需提供实例ID作为路径参数，其他筛选条件为可选的查询参数。
 *
 * @param request ListModelsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListModelsResponse
 */
async function listModelsWithOptions(instanceId: string, request: ListModelsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListModelsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListModels',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/models`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 通过实例ID查询指定条件下的模型列表。
 *
 * @description ## 请求说明
 * 本API用于从指定实例中获取模型列表，支持通过模型名称、类型以及分页参数进行筛选。请求时需提供实例ID作为路径参数，其他筛选条件为可选的查询参数。
 *
 * @param request ListModelsRequest
 * @return ListModelsResponse
 */
async function listModels(instanceId: string, request: ListModelsRequest): ListModelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listModelsWithOptions(instanceId, request, headers, runtime);
}

model ListOnlineConfigsRequest {
  domain?: string(name='domain', description='The name of the domain

This parameter is required.', example='sz_vpc_domain_1'),
}

model ListOnlineConfigsResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='E45380E8-994A-5402-9806-F114B3295FCF'),
  result?: [ 
    {
      config?: string(name='config', description='The configuration information', example='{\\\\"specItems\\\\":[{\\\\"specKey\\\\":\\\\"YQ_KEYWORD_NUMBER_PLUS\\\\",\\\\"value\\\\":\\\\"1\\\\"}]}'),
      indexName?: string(name='indexName', description='The name of the index', example='generation'),
    }
  ](name='result', description='List'),
}

model ListOnlineConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOnlineConfigsResponseBody(name='body'),
}

/**
 * @summary Queries the details of an online configuration.
 *
 * @description ### Method
 * ```java
 * GET
 * ```
 * ### URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/node/{nodeName}/online-configs?domain={domain}
 * ```
 *
 * @param request ListOnlineConfigsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOnlineConfigsResponse
 */
async function listOnlineConfigsWithOptions(instanceId: string, nodeName: string, request: ListOnlineConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOnlineConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.domain)) {
    query['domain'] = request.domain;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOnlineConfigs',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/node/${OpenApiUtil.getEncodeParam(nodeName)}/online-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of an online configuration.
 *
 * @description ### Method
 * ```java
 * GET
 * ```
 * ### URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/node/{nodeName}/online-configs?domain={domain}
 * ```
 *
 * @param request ListOnlineConfigsRequest
 * @return ListOnlineConfigsResponse
 */
async function listOnlineConfigs(instanceId: string, nodeName: string, request: ListOnlineConfigsRequest): ListOnlineConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOnlineConfigsWithOptions(instanceId, nodeName, request, headers, runtime);
}

model ListPausePolicysResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='2AE63638-5420-56DC-BF59-37D8174039A0'),
  result?: map[string]ResultValue(name='result', description='The result.'),
}

model ListPausePolicysResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPausePolicysResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPausePolicysResponse
 */
async function listPausePolicysWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListPausePolicysResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListPausePolicys',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/pause-policies`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @return ListPausePolicysResponse
 */
async function listPausePolicys(instanceId: string): ListPausePolicysResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPausePolicysWithOptions(instanceId, headers, runtime);
}

model ListPostQueryResultRequest {
  body?: map[string]any(name='body', description='The request body.', example='{}'),
  type?: string(name='type', description='The query type. Valid values: sql: SQL query. ha3: Havenask query.', example='ha3'),
}

model ListPostQueryResultResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='022F36C7-9FB4-5D67-BEBC-3D14B0984463'),
  result?: any(name='result', description='The result.', example='{}'),
}

model ListPostQueryResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPostQueryResultResponseBody(name='body'),
}

/**
 * @summary 召回引擎版使用POST请求获取搜索测试结果
 *
 * @param request ListPostQueryResultRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPostQueryResultResponse
 */
async function listPostQueryResultWithOptions(instanceId: string, request: ListPostQueryResultRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPostQueryResultResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPostQueryResult',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/query`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 召回引擎版使用POST请求获取搜索测试结果
 *
 * @param request ListPostQueryResultRequest
 * @return ListPostQueryResultResponse
 */
async function listPostQueryResult(instanceId: string, request: ListPostQueryResultRequest): ListPostQueryResultResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPostQueryResultWithOptions(instanceId, request, headers, runtime);
}

model ListQueryResultRequest {
  query?: string(name='query', description='The query statement', example='query%3D1%26%26config%3Dstart%3A0%2Chit%3A10%2Cformat%3Ajson%26%26cluster%3Dgeneral'),
  sql?: string(name='sql', description='The SQL statement that is executed in the query', example='query%3Dselect%20max(content_id)%20from%20generation'),
}

model ListQueryResultResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request', example='9E5BCFAA-98B3-51D0-9188-B1BC07589337'),
}

model ListQueryResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueryResultResponseBody(name='body'),
}

/**
 * @summary Queries the query result.
 *
 * @description ### [](#)Method
 * `GET`
 * ### [](#uri)URI
 * `/openapi/ha3/instances/{instanceId}/query?query=xxxx`
 *
 * @param request ListQueryResultRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQueryResultResponse
 */
async function listQueryResultWithOptions(instanceId: string, request: ListQueryResultRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListQueryResultResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.sql)) {
    query['sql'] = request.sql;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListQueryResult',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/query`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the query result.
 *
 * @description ### [](#)Method
 * `GET`
 * ### [](#uri)URI
 * `/openapi/ha3/instances/{instanceId}/query?query=xxxx`
 *
 * @param request ListQueryResultRequest
 * @return ListQueryResultResponse
 */
async function listQueryResult(instanceId: string, request: ListQueryResultRequest): ListQueryResultResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listQueryResultWithOptions(instanceId, request, headers, runtime);
}

model ListRestQueryResultRequest {
  indexName?: string(name='indexName', description='The name of the index table.', example='main_index'),
  query?: map[string]any(name='query', description='The rest query statement.', example='query%3Drelation_id%3A%221151274675_2%22%26%26cluster%3Dgeneral%26%26config%3Dstart%3A0%2Chit%3A10%2Cformat%3Ajson'),
}

model ListRestQueryResultResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='F43E8AB4-419C-5F4C-90D6-615590DFAA3C'),
  result?: any(name='result', description='The result.', example='{}'),
}

model ListRestQueryResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRestQueryResultResponseBody(name='body'),
}

/**
 * @summary 召回引擎版获取rest查询搜索测试结果
 *
 * @param request ListRestQueryResultRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRestQueryResultResponse
 */
async function listRestQueryResultWithOptions(instanceId: string, request: ListRestQueryResultRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRestQueryResultResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.indexName)) {
    body['indexName'] = request.indexName;
  }
  if (!Util.isUnset(request.query)) {
    body['query'] = request.query;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListRestQueryResult',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/rest-query`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 召回引擎版获取rest查询搜索测试结果
 *
 * @param request ListRestQueryResultRequest
 * @return ListRestQueryResultResponse
 */
async function listRestQueryResult(instanceId: string, request: ListRestQueryResultRequest): ListRestQueryResultResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRestQueryResultWithOptions(instanceId, request, headers, runtime);
}

model ListSchemasRequest {
  accessKey?: string(name='accessKey', description='The AccessKey ID of the MaxCompute data source.', example='ak'),
  accessSecret?: string(name='accessSecret', description='The AccessKey secret of the MaxCompute data source.', example='as'),
  endpoint?: string(name='endpoint', description='The endpoint of the MaxCompute data source.', example='http://service.cn-hangzhou.maxcompute.aliyun-inc.com/api'),
  namespace?: string(name='namespace', description='The namespace of the SARO data source.', example='igraph-cn-tl32wnrhi04'),
  partition?: string(name='partition', description='The shard name.', example='dt=20230520'),
  project?: string(name='project', description='The name of the MaxCompute project that is used as the data source.', example='start-flask-v3-obcc'),
  table?: string(name='table', description='The name of the MaxCompute table that is used as the data source.', example='item'),
  type?: string(name='type', description='The type of the data source. Valid values: odps, swift, saro, oss, and unKnow.

This parameter is required.', example='odps'),
}

model ListSchemasResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='FE03180A-0E29-5474-8A86-33F0683294A4'),
  result?: any(name='result', description='The result.', example='{}'),
}

model ListSchemasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSchemasResponseBody(name='body'),
}

/**
 * @summary 通过数据源配置获取schema信息
 *
 * @param request ListSchemasRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSchemasResponse
 */
async function listSchemasWithOptions(instanceId: string, request: ListSchemasRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSchemasResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessKey)) {
    query['accessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.accessSecret)) {
    query['accessSecret'] = request.accessSecret;
  }
  if (!Util.isUnset(request.endpoint)) {
    query['endpoint'] = request.endpoint;
  }
  if (!Util.isUnset(request.namespace)) {
    query['namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.partition)) {
    query['partition'] = request.partition;
  }
  if (!Util.isUnset(request.project)) {
    query['project'] = request.project;
  }
  if (!Util.isUnset(request.table)) {
    query['table'] = request.table;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSchemas',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/schemas`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 通过数据源配置获取schema信息
 *
 * @param request ListSchemasRequest
 * @return ListSchemasResponse
 */
async function listSchemas(instanceId: string, request: ListSchemasRequest): ListSchemasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSchemasWithOptions(instanceId, request, headers, runtime);
}

model ListTableGenerationsResponseBody = {
  requestId?: string(name='requestId', description='requestId', example='F6E3D968-529C-5C40-AFDD-133A8B8FD930'),
  result?: [ 
    {
      generationId?: long(name='generationId', description='The ID of the full index version.', example='1708674867'),
    }
  ](name='result', description='The result.'),
}

model ListTableGenerationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTableGenerationsResponseBody(name='body'),
}

/**
 * @summary Queries a list of index versions.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTableGenerationsResponse
 */
async function listTableGenerationsWithOptions(instanceId: string, tableName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListTableGenerationsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListTableGenerations',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/tables/${OpenApiUtil.getEncodeParam(tableName)}/index_versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of index versions.
 *
 * @return ListTableGenerationsResponse
 */
async function listTableGenerations(instanceId: string, tableName: string): ListTableGenerationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTableGenerationsWithOptions(instanceId, tableName, headers, runtime);
}

model ListTablesRequest {
  newMode?: boolean(name='newMode', description='Specifies whether the OpenSearch Vector Search Edition instance is of the new version.', example='true'),
}

model ListTablesResponseBody = {
  requestId?: string(name='requestId', description='requestId', example='10D5E615-69F7-5F49-B850-00169ADE513C'),
  result?: [ 
    {
      indexStatus?: string(name='indexStatus', description='The state of the index table. Valid values: NEW, PUBLISH, IN_USE, NOT_USE, STOP_USE, RESTORE_USE, and FAIL. After an index is created in an OpenSearch Retrieval Engine Edition instance, the index enters the IN_USE state. If the first full index fails to be created in an OpenSearch Vector Search Edition instance of the new version, the index is in the FAIL state.', example='IN_USE'),
      name?: string(name='name', description='The index name.', example='es_test_1b'),
      status?: string(name='status', description='The state of the index table. Valid values: NEW, PUBLISH, IN_USE, NOT_USE, STOP_USE, RESTORE_USE, and FAIL. After an index is created in an OpenSearch Retrieval Engine Edition instance, the index enters the IN_USE state. If the first full index fails to be created in an OpenSearch Vector Search Edition instance of the new version, the index is in the FAIL state.', example='IN_USE'),
    }
  ](name='result', description='The result.'),
}

model ListTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTablesResponseBody(name='body'),
}

/**
 * @summary Queries a list of index tables.
 *
 * @param request ListTablesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTablesResponse
 */
async function listTablesWithOptions(instanceId: string, request: ListTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTablesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.newMode)) {
    query['newMode'] = request.newMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTables',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/tables`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a list of index tables.
 *
 * @param request ListTablesRequest
 * @return ListTablesResponse
 */
async function listTables(instanceId: string, request: ListTablesRequest): ListTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTablesWithOptions(instanceId, request, headers, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='nextToken', example='600********33'),
  resourceId?: [ string ](name='resourceId'),
  resourceType?: string(name='resourceType', description='This parameter is required.', example='instance'),
  tag?: [ 
    {
      key?: string(name='key', example='opensearch'),
      value?: string(name='value', example='opensearch'),
    }
  ](name='tag'),
}

model ListTagResourcesShrinkRequest {
  nextToken?: string(name='nextToken', example='600********33'),
  resourceIdShrink?: string(name='resourceId'),
  resourceType?: string(name='resourceType', description='This parameter is required.', example='instance'),
  tagShrink?: string(name='tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='nextToken', example='b56*******de4a7eca'),
  requestId?: string(name='requestId', example='2AE63638-5420-56DC-BF59-37D8174039A0'),
  tagResources?: [ 
    {
      resourceId?: string(name='resourceId', example='rmq-cn-jeo3mn55j01'),
      resourceType?: string(name='resourceType', example='instance'),
      tagKey?: string(name='tagKey', example='opensearch'),
      tagValue?: string(name='tagValue', example='opensearch'),
    }
  ](name='tagResources'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
 * @summary 查标签接口
 *
 * @param tmpReq ListTagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
async function listTagResourcesWithOptions(tmpReq: ListTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceId)) {
    request.resourceIdShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceId, 'resourceId', 'json');
  }
  if (!Util.isUnset(tmpReq.tag)) {
    request.tagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tag, 'tag', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceIdShrink)) {
    query['resourceId'] = request.resourceIdShrink;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagShrink)) {
    query['tag'] = request.tagShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/resource-tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 查标签接口
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

model ListTasksRequest {
  end?: long(name='end', description='The timestamp that indicates the end of the time range to query.', example='1690423741577'),
  start?: long(name='start', description='The timestamp that indicates the beginning of the time range to query.', example='1687238865434'),
}

model ListTasksResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D39EE0F1-D7EF-5F46-B781-6BF4185308B0'),
  result?: any(name='result', description='The result.', example='{}'),
}

model ListTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTasksResponseBody(name='body'),
}

/**
 * @summary 获取集群任务列表（数据源+集群）
 *
 * @param request ListTasksRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTasksResponse
 */
async function listTasksWithOptions(instanceId: string, request: ListTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTasksResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.end)) {
    query['end'] = request.end;
  }
  if (!Util.isUnset(request.start)) {
    query['start'] = request.start;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTasks',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 获取集群任务列表（数据源+集群）
 *
 * @param request ListTasksRequest
 * @return ListTasksResponse
 */
async function listTasks(instanceId: string, request: ListTasksRequest): ListTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTasksWithOptions(instanceId, request, headers, runtime);
}

model ListVectorQueryResultRequest {
  body?: map[string]any(name='body', description='The request body.', example='{}'),
  path?: string(name='path'),
  queryType?: string(name='queryType', description='The query type. Valid values: vector, primary_key, and vector_text.', example='primary_key'),
  vectorQueryType?: string(name='vectorQueryType', description='The vector query type. Valid values: vector, image, and text.', example='image'),
}

model ListVectorQueryResultResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='022F36C7-9FB4-5D67-BEBC-3D14B0984463'),
  result?: any(name='result', description='The result.', example='{}'),
}

model ListVectorQueryResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVectorQueryResultResponseBody(name='body'),
}

/**
 * @summary 向量检索版获取向量查询搜索测试结果
 *
 * @param request ListVectorQueryResultRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVectorQueryResultResponse
 */
async function listVectorQueryResultWithOptions(instanceId: string, request: ListVectorQueryResultRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListVectorQueryResultResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.path)) {
    query['path'] = request.path;
  }
  if (!Util.isUnset(request.queryType)) {
    query['queryType'] = request.queryType;
  }
  if (!Util.isUnset(request.vectorQueryType)) {
    query['vectorQueryType'] = request.vectorQueryType;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListVectorQueryResult',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/vector-query`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 向量检索版获取向量查询搜索测试结果
 *
 * @param request ListVectorQueryResultRequest
 * @return ListVectorQueryResultResponse
 */
async function listVectorQueryResult(instanceId: string, request: ListVectorQueryResultRequest): ListVectorQueryResultResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVectorQueryResultWithOptions(instanceId, request, headers, runtime);
}

model ModifyAdvanceConfigRequest {
  content?: string(name='content', description='The content of the advanced configuration that is returned.', example='""'),
  contentType?: string(name='contentType', description='The type of the configuration content. Valid values: FILE, GIT, HTTP, and ODPS.', example='FILE'),
  desc?: string(name='desc', description='The description of the advanced configuration.', example='test'),
  files?: [ 
    {
      fullPathName?: string(name='fullPathName', description='The full path of the file.', example='/cluster.json'),
      isDir?: boolean(name='isDir', description='Specifies whether the file is a directory.', example='true'),
      isTemplate?: boolean(name='isTemplate', description='Specifies whether the file is a template.', example='true'),
      name?: string(name='name', description='The node name.', example='general'),
    }
  ](name='files', description='The files.'),
  name?: string(name='name', description='The name of the advanced configuration.', example='ha-cn-zvp2qr1sk01_qrs'),
  status?: string(name='status', description='The status of the advanced configuration. Valid values: drafting: The advanced configuration is in the draft state. used: The advanced configuration is being used. unused: The advanced configuration is not used. trash: The advanced configuration is being deleted.', example='used'),
  updateTime?: long(name='updateTime', description='The time when the advanced configuration was updated.', example='2024-02-27T07:50:55Z'),
}

model ModifyAdvanceConfigResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='2AE63638-5420-56DC-BF59-37D8174039A0'),
  result?: map[string]any(name='result', description='The result.', example='{}'),
}

model ModifyAdvanceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAdvanceConfigResponseBody(name='body'),
}

/**
 * @param request ModifyAdvanceConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAdvanceConfigResponse
 */
async function modifyAdvanceConfigWithOptions(instanceId: string, configName: string, request: ModifyAdvanceConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyAdvanceConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }
  if (!Util.isUnset(request.contentType)) {
    body['contentType'] = request.contentType;
  }
  if (!Util.isUnset(request.desc)) {
    body['desc'] = request.desc;
  }
  if (!Util.isUnset(request.files)) {
    body['files'] = request.files;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.updateTime)) {
    body['updateTime'] = request.updateTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAdvanceConfig',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/advanced-configs/${OpenApiUtil.getEncodeParam(configName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request ModifyAdvanceConfigRequest
 * @return ModifyAdvanceConfigResponse
 */
async function modifyAdvanceConfig(instanceId: string, configName: string, request: ModifyAdvanceConfigRequest): ModifyAdvanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyAdvanceConfigWithOptions(instanceId, configName, request, headers, runtime);
}

model ModifyAdvanceConfigFileRequest {
  content?: string(name='content', description='The file content.', example='"ha3"'),
  variables?: map[string]VariablesValue(name='variables', description='The variables.'),
  fileName?: string(name='fileName', description='The name of the file.

This parameter is required.', example='/qrs.json'),
}

model ModifyAdvanceConfigFileResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='93A9E542-8CF8-5BA6-99AB-94C0FE520429'),
  result?: map[string]any(name='result', description='The result.', example='{}'),
}

model ModifyAdvanceConfigFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAdvanceConfigFileResponseBody(name='body'),
}

/**
 * @summary Modifies the advanced configurations.
 *
 * @description ## Method
 *     put
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/advanced-configs/{configName}/file?fileName={fileName}
 *
 * @param request ModifyAdvanceConfigFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAdvanceConfigFileResponse
 */
async function modifyAdvanceConfigFileWithOptions(instanceId: string, configName: string, request: ModifyAdvanceConfigFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyAdvanceConfigFileResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.fileName)) {
    query['fileName'] = request.fileName;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }
  if (!Util.isUnset(request.variables)) {
    body['variables'] = request.variables;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAdvanceConfigFile',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/advanced-configs/${OpenApiUtil.getEncodeParam(configName)}/file`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the advanced configurations.
 *
 * @description ## Method
 *     put
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/advanced-configs/{configName}/file?fileName={fileName}
 *
 * @param request ModifyAdvanceConfigFileRequest
 * @return ModifyAdvanceConfigFileResponse
 */
async function modifyAdvanceConfigFile(instanceId: string, configName: string, request: ModifyAdvanceConfigFileRequest): ModifyAdvanceConfigFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyAdvanceConfigFileWithOptions(instanceId, configName, request, headers, runtime);
}

model ModifyAliasRequest {
  alias?: string(name='alias', description='alias name', example='test'),
  index?: string(name='index', description='index name', example='index'),
}

model ModifyAliasResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='F6E3D968-529C-5C40-AFDD-133A8B8FD930'),
  result?: map[string]any(name='result', description='Map', example='{}'),
}

model ModifyAliasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAliasResponseBody(name='body'),
}

/**
 * @param request ModifyAliasRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAliasResponse
 */
async function modifyAliasWithOptions(instanceId: string, alias: string, request: ModifyAliasRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyAliasResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alias)) {
    body['alias'] = request.alias;
  }
  if (!Util.isUnset(request.index)) {
    body['index'] = request.index;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAlias',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/aliases/${OpenApiUtil.getEncodeParam(alias)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request ModifyAliasRequest
 * @return ModifyAliasResponse
 */
async function modifyAlias(instanceId: string, alias: string, request: ModifyAliasRequest): ModifyAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyAliasWithOptions(instanceId, alias, request, headers, runtime);
}

model ModifyClusterDescRequest {
  body?: map[string]any(name='body', description='The request body.', example='{}'),
}

model ModifyClusterDescResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request', example='D39EE0F1-D7EF-5F46-B781-6BF4185308B0'),
  result?: map[string]any(name='result', description='The result.', example='{}'),
}

model ModifyClusterDescResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClusterDescResponseBody(name='body'),
}

/**
 * @summary Modifies the description of a specified cluster.
 *
 * @description ### [](#)Method
 * `PUT`
 * ### [](#uri)URI
 * `/openapi/ha3/instances/{instanceId}/clusters/{clusterName}/desc`
 *
 * @param request ModifyClusterDescRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyClusterDescResponse
 */
async function modifyClusterDescWithOptions(instanceId: string, clusterName: string, request: ModifyClusterDescRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyClusterDescResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterDesc',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/clusters/${OpenApiUtil.getEncodeParam(clusterName)}/desc`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the description of a specified cluster.
 *
 * @description ### [](#)Method
 * `PUT`
 * ### [](#uri)URI
 * `/openapi/ha3/instances/{instanceId}/clusters/{clusterName}/desc`
 *
 * @param request ModifyClusterDescRequest
 * @return ModifyClusterDescResponse
 */
async function modifyClusterDesc(instanceId: string, clusterName: string, request: ModifyClusterDescRequest): ModifyClusterDescResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyClusterDescWithOptions(instanceId, clusterName, request, headers, runtime);
}

model ModifyClusterOfflineConfigRequest {
  buildMode?: string(name='buildMode', description='The reindexing method. Valid values: api: API data source. indexRecover: data recovery by using indexing.', example='indexRecover'),
  config?: map[string]int32(name='config', description='The configuration name, which is stored as a key.'),
  dataSourceName?: string(name='dataSourceName', description='The name of the data source.', example='test1'),
  dataSourceType?: string(name='dataSourceType', description='The type of the data source. Valid values: odps: MaxCompute. swift: Swift. unKnow: unknown type.', example='maxComputer'),
  dataTimeSec?: int32(name='dataTimeSec', description='This parameter is required when index building by using API data sources is triggered.', example='1640867288'),
  domain?: string(name='domain', description='The data center in which the data source is deployed.', example='vpc_hz_domain_1'),
  generation?: long(name='generation', description='The ID of the full index version.', example='160142641'),
  partition?: string(name='partition', description='This parameter is required when index building for full data in a MaxCompute data source is triggered.', example='20211202'),
  pushMode?: string(name='pushMode', description='The push mode of the configuration. By default, only the configuration is pushed.', example='PUSH_ONLY'),
}

model ModifyClusterOfflineConfigResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request', example='E7B7D598-B080-5C8E-AA35-D43EC0D5F886'),
  result?: map[string]any(name='result', description='The result', example='{}'),
}

model ModifyClusterOfflineConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClusterOfflineConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the configuration information of a cluster.
 *
 * @description ## Request syntax
 *     PUT /openapi/ha3/instances/{instanceId}/cluster-offline-config
 *
 * @param request ModifyClusterOfflineConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyClusterOfflineConfigResponse
 */
async function modifyClusterOfflineConfigWithOptions(instanceId: string, request: ModifyClusterOfflineConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyClusterOfflineConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.buildMode)) {
    body['buildMode'] = request.buildMode;
  }
  if (!Util.isUnset(request.config)) {
    body['config'] = request.config;
  }
  if (!Util.isUnset(request.dataSourceName)) {
    body['dataSourceName'] = request.dataSourceName;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    body['dataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.dataTimeSec)) {
    body['dataTimeSec'] = request.dataTimeSec;
  }
  if (!Util.isUnset(request.domain)) {
    body['domain'] = request.domain;
  }
  if (!Util.isUnset(request.generation)) {
    body['generation'] = request.generation;
  }
  if (!Util.isUnset(request.partition)) {
    body['partition'] = request.partition;
  }
  if (!Util.isUnset(request.pushMode)) {
    body['pushMode'] = request.pushMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterOfflineConfig',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/cluster-offline-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the configuration information of a cluster.
 *
 * @description ## Request syntax
 *     PUT /openapi/ha3/instances/{instanceId}/cluster-offline-config
 *
 * @param request ModifyClusterOfflineConfigRequest
 * @return ModifyClusterOfflineConfigResponse
 */
async function modifyClusterOfflineConfig(instanceId: string, request: ModifyClusterOfflineConfigRequest): ModifyClusterOfflineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyClusterOfflineConfigWithOptions(instanceId, request, headers, runtime);
}

model ModifyClusterOnlineConfigRequest {
  clusters?: [ string ](name='clusters', description='The cluster information.'),
  config?: map[string]int32(name='config', description='The configuration information.'),
}

model ModifyClusterOnlineConfigResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request', example='E7B7D598-B080-5C8E-AA35-D43EC0D5F886'),
  result?: map[string]any(name='result', description='Map', example='{}'),
}

model ModifyClusterOnlineConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClusterOnlineConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the online configuration of a cluster.
 *
 * @description ### Method
 * `PUT`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}/cluster-online-config`
 *
 * @param request ModifyClusterOnlineConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyClusterOnlineConfigResponse
 */
async function modifyClusterOnlineConfigWithOptions(instanceId: string, request: ModifyClusterOnlineConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyClusterOnlineConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clusters)) {
    body['clusters'] = request.clusters;
  }
  if (!Util.isUnset(request.config)) {
    body['config'] = request.config;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterOnlineConfig',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/cluster-online-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the online configuration of a cluster.
 *
 * @description ### Method
 * `PUT`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}/cluster-online-config`
 *
 * @param request ModifyClusterOnlineConfigRequest
 * @return ModifyClusterOnlineConfigResponse
 */
async function modifyClusterOnlineConfig(instanceId: string, request: ModifyClusterOnlineConfigRequest): ModifyClusterOnlineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyClusterOnlineConfigWithOptions(instanceId, request, headers, runtime);
}

model ModifyDataSourceDeployRequest {
  autoBuildIndex?: boolean(name='autoBuildIndex', description='Specifies whether to enable the automatic full indexing feature.', example='true'),
  extend?: {
    hdfs?: {
      path?: string(name='path', description='The path of the Apsara File Storage for HDFS data source.', example='ymsh-service/src/main/java/cn/ymsh/util/jd'),
    }(name='hdfs', description='The information about the Apsara File Storage for HDFS data source.'),
    odps?: {
      partitions?: map[string]string(name='partitions', description='The partitions in the MaxCompute table.'),
    }(name='odps', description='The information about the MaxCompute data source.'),
    oss?: {
      path?: string(name='path', description='The path of the OSS data source.', example='oss://test'),
    }(name='oss', description='The information about the OSS data source.'),
    saro?: {
      path?: string(name='path', description='The path of the SARO data source.', example='/'),
      version?: string(name='version', description='The version number of the SARO data source.', example='1'),
    }(name='saro', description='The information about the SARO data source. This parameter is applicable to the SARO data source used in the intranet of Alibaba Group.'),
  }(name='extend', description='The extended information.'),
  processor?: {
    args?: string(name='args', description='The startup parameters of the process.', example='{}'),
    resource?: string(name='resource', description='The resource information.', example='{}'),
  }(name='processor', description='The parameters of the process.'),
  storage?: {
    accessKey?: string(name='accessKey', description='The AccessKey ID of the MaxCompute data source.', example='ak'),
    accessSecret?: string(name='accessSecret', description='The AccessKey secret of the MaxCompute data source.', example='as'),
    bucket?: string(name='bucket', description='The name of the OSS bucket.', example='test-bucket'),
    catalog?: string(name='catalog'),
    database?: string(name='database'),
    endpoint?: string(name='endpoint', description='The endpoint of the MaxCompute data source.', example='http://service.cn-hangzhou.maxcompute.aliyun-inc.com/api'),
    namespace?: string(name='namespace', description='The namespace. This parameter is applicable to the SARO data source used in the intranet of Alibaba Group.', example='dp-dev'),
    ossPath?: string(name='ossPath', description='The Object Storage Service (OSS) path.', example='/opensearch'),
    partition?: string(name='partition', description='The partition in the MaxCompute table.', example='ds=20220713'),
    path?: string(name='path', description='The file path in the Apsara File Storage for HDFS file system.', example='/ude_jobs/iflow_offline_data_access'),
    project?: string(name='project', description='The name of the MaxCompute project that is used as the data source.', example='kubenest'),
    table?: string(name='table', description='The name of the MaxCompute table that is used as the data source.', example='item'),
    tag?: string(name='tag'),
  }(name='storage', description='The information about the data source.'),
  swift?: {
    topic?: string(name='topic', description='The topic.', example='ha-cn-0ju2rps6c08_api'),
    zk?: string(name='zk', description='zk', example='zk'),
  }(name='swift', description='The information about the incremental data source Swift.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. The system only checks the validity of the data source. Valid values: true and false.', example='true'),
  generationId?: long(name='generationId', description='The ID of the full index version.', example='1708674867'),
}

model ModifyDataSourceDeployResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='93A9E542-8CF8-5BA6-99AB-94C0FE520429'),
  result?: map[string]any(name='result', description='The result.', example='{}'),
}

model ModifyDataSourceDeployResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDataSourceDeployResponseBody(name='body'),
}

/**
 * @summary 修改数据源部署信息
 *
 * @param request ModifyDataSourceDeployRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDataSourceDeployResponse
 */
async function modifyDataSourceDeployWithOptions(instanceId: string, deployName: string, dataSourceName: string, request: ModifyDataSourceDeployRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyDataSourceDeployResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.generationId)) {
    query['generationId'] = request.generationId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.autoBuildIndex)) {
    body['autoBuildIndex'] = request.autoBuildIndex;
  }
  if (!Util.isUnset(request.extend)) {
    body['extend'] = request.extend;
  }
  if (!Util.isUnset(request.processor)) {
    body['processor'] = request.processor;
  }
  if (!Util.isUnset(request.storage)) {
    body['storage'] = request.storage;
  }
  if (!Util.isUnset(request.swift)) {
    body['swift'] = request.swift;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDataSourceDeploy',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/data-sources/${OpenApiUtil.getEncodeParam(dataSourceName)}/deploys/${OpenApiUtil.getEncodeParam(deployName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 修改数据源部署信息
 *
 * @param request ModifyDataSourceDeployRequest
 * @return ModifyDataSourceDeployResponse
 */
async function modifyDataSourceDeploy(instanceId: string, deployName: string, dataSourceName: string, request: ModifyDataSourceDeployRequest): ModifyDataSourceDeployResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyDataSourceDeployWithOptions(instanceId, deployName, dataSourceName, request, headers, runtime);
}

model ModifyFileRequest {
  content?: string(name='content', description='The file content.', example='""'),
  partition?: int32(name='partition', description='The number of shards.', example='ds=20220713'),
  fileName?: string(name='fileName', description='The name of the file in the full path

This parameter is required.', example='/schemas/generation_schema.json'),
}

model ModifyFileResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='89B968E6-1E41-58DF-BB25-5F98ECC759CE'),
  result?: map[string]any(name='result', description='The information about the index', example='{}'),
}

model ModifyFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyFileResponseBody(name='body'),
}

/**
 * @summary Modifies a file.
 *
 * @description ## Method
 *     PUT
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/indexes/{indexName}/versions/{versionName}/file?fileName=/root/test.txt
 *
 * @param request ModifyFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyFileResponse
 */
async function modifyFileWithOptions(instanceId: string, indexName: string, versionName: string, request: ModifyFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyFileResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.fileName)) {
    query['fileName'] = request.fileName;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }
  if (!Util.isUnset(request.partition)) {
    body['partition'] = request.partition;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyFile',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/indexes/${OpenApiUtil.getEncodeParam(indexName)}/versions/${OpenApiUtil.getEncodeParam(versionName)}/file`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies a file.
 *
 * @description ## Method
 *     PUT
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/indexes/{indexName}/versions/{versionName}/file?fileName=/root/test.txt
 *
 * @param request ModifyFileRequest
 * @return ModifyFileResponse
 */
async function modifyFile(instanceId: string, indexName: string, versionName: string, request: ModifyFileRequest): ModifyFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyFileWithOptions(instanceId, indexName, versionName, request, headers, runtime);
}

model ModifyIndexRequest {
  buildParallelNum?: int32(name='buildParallelNum', description='The maximum number of full indexes that can be concurrently built.', example='2'),
  cluster?: map[string]object(name='cluster', description='The cluster information.'),
  clusterConfigName?: string(name='clusterConfigName', description='The name of the configuration file.', example='ha-cn-35t3r02iq03@ha-cn-35t3r02iq03_test_api@hz_pre_vpc_domain_1@test_api@index_config_v1'),
  config?: map[string]ConfigValue(name='config', description='The information about the offline configuration.'),
  content?: string(name='content', description='The file content.', example='{\\\\"summarys\\\\":{\\\\"summary_fields\\\\":[\\\\"id\\\\"]},\\\\"indexs\\\\":[{\\\\"index_name\\\\":\\\\"index_id\\\\",\\\\"index_type\\\\":\\\\"PRIMARYKEY64\\\\",\\\\"index_fields\\\\":\\\\"id\\\\",\\\\"has_primary_key_attribute\\\\":true,\\\\"is_primary_key_sorted\\\\":false}],\\\\"attributes\\\\":[\\\\"id\\\\"],\\\\"fields\\\\":[{\\\\"field_name\\\\":\\\\"id\\\\",\\\\"field_type\\\\":\\\\"UINT16\\\\"}],\\\\"table_name\\\\":\\\\"index_2\\\\"}'),
  dataSource?: string(name='dataSource', description='The name of the data source.', example='ha-cn-35t3n1yuj0d_index_1'),
  dataSourceInfo?: {
    autoBuildIndex?: boolean(name='autoBuildIndex', description='Specifies whether to enable the automatic full indexing feature.', example='true'),
    buildMode?: string(name='buildMode', description='The reindexing method. Valid values: api: API data source. indexRecover: data recovery by using indexing.', example='api'),
    config?: {
      accessKey?: string(name='accessKey', description='The AccessKey ID of the MaxCompute data source.', example='L***p'),
      accessSecret?: string(name='accessSecret', description='The AccessKey secret of the MaxCompute data source.', example='5**9a6'),
      bucket?: string(name='bucket', description='The name of the OSS bucket.', example='test-bucket'),
      catalog?: string(name='catalog'),
      database?: string(name='database'),
      endpoint?: string(name='endpoint', description='The endpoint of the MaxCompute data source.', example='http://service.cn-hangzhou.maxcompute.aliyun-inc.com/api'),
      format?: string(name='format'),
      namespace?: string(name='namespace', description='The namespace. This parameter is applicable to the SARO data source used in the intranet of Alibaba Group.', example='test-namespace'),
      ossPath?: string(name='ossPath', description='The Object Storage Service (OSS) path.', example='/opensearch/oss.json'),
      partition?: string(name='partition', description='The partition in the MaxCompute table. Example: ds=20180102.', example='ds=20230114'),
      path?: string(name='path', description='The file path in the Apsara File Storage for HDFS file system.', example='test-hdfs-path'),
      project?: string(name='project', description='The name of the MaxCompute project that is used as the data source.', example='bbt_algo_pai'),
      table?: string(name='table', description='The name of the MaxCompute table that is used as the data source.', example='item'),
      tag?: string(name='tag'),
    }(name='config', description='The configurations of the MaxCompute data source.'),
    dataTimeSec?: int32(name='dataTimeSec', description='The start timestamp from which incremental data is retrieved.', example='1709715164'),
    domain?: string(name='domain', description='The offline deployment name of the data source.', example='vpc_hz_domain_1'),
    generation?: long(name='generation', description='The ID of the index version from which data is restored.', example='4'),
    name?: string(name='name', description='The name of the data source.', example='ha-cn-35t3n1yuj0d_index_1'),
    ossDataPath?: string(name='ossDataPath'),
    partition?: string(name='partition'),
    processParallelNum?: int32(name='processParallelNum', description='The maximum number of full indexes that can be concurrently processed.', example='2'),
    processPartitionCount?: int32(name='processPartitionCount', description='The number of resources used for data update.', example='4'),
    saroConfig?: {
      namespace?: string(name='namespace', description='The namespace to which the SARO data source belongs.', example='flink-test-fjx-default'),
      tableName?: string(name='tableName', description='The name of the SARO table.', example='device_event_shy_summary_'),
    }(name='saroConfig', description='The configurations of the SARO data source.'),
    type?: string(name='type', description='The type of the data source. Valid values: odps, swift, saro, oss, and unKnow.', example='odps'),
  }(name='dataSourceInfo', description='The information about the data source, which is required for the new version of OpenSearch Vector Search Edition.'),
  description?: string(name='description', description='The description of the data source.', example='test'),
  domain?: string(name='domain', description='The name of the data center in which the data source is deployed.', example='vpc_hz_domain_1'),
  extend?: map[string]any(name='extend'),
  mergeParallelNum?: int32(name='mergeParallelNum', description='The maximum number of full indexes that can be concurrently merged.', example='2'),
  partition?: int32(name='partition', description='The number of shards.', example='2'),
  pushMode?: string(name='pushMode', description='The push mode of the configuration. By default, only the configuration is pushed.', example='PUSH_ONLY'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to check the validity of input parameters. Default value: false.

Valid values:

*   **true**: checks only the validity of input parameters.
*   **false**: checks the validity of input parameters and creates an attribution configuration.', example='true'),
}

model ModifyIndexResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='93A9E542-8CF8-5BA6-99AB-94C0FE520429'),
  result?: any(name='result', description='The result.', example='{}'),
}

model ModifyIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyIndexResponseBody(name='body'),
}

/**
 * @param request ModifyIndexRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIndexResponse
 */
async function modifyIndexWithOptions(instanceId: string, indexName: string, request: ModifyIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyIndexResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.buildParallelNum)) {
    body['buildParallelNum'] = request.buildParallelNum;
  }
  if (!Util.isUnset(request.cluster)) {
    body['cluster'] = request.cluster;
  }
  if (!Util.isUnset(request.clusterConfigName)) {
    body['clusterConfigName'] = request.clusterConfigName;
  }
  if (!Util.isUnset(request.config)) {
    body['config'] = request.config;
  }
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }
  if (!Util.isUnset(request.dataSource)) {
    body['dataSource'] = request.dataSource;
  }
  if (!Util.isUnset(request.dataSourceInfo)) {
    body['dataSourceInfo'] = request.dataSourceInfo;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.domain)) {
    body['domain'] = request.domain;
  }
  if (!Util.isUnset(request.extend)) {
    body['extend'] = request.extend;
  }
  if (!Util.isUnset(request.mergeParallelNum)) {
    body['mergeParallelNum'] = request.mergeParallelNum;
  }
  if (!Util.isUnset(request.partition)) {
    body['partition'] = request.partition;
  }
  if (!Util.isUnset(request.pushMode)) {
    body['pushMode'] = request.pushMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIndex',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/indexes/${OpenApiUtil.getEncodeParam(indexName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request ModifyIndexRequest
 * @return ModifyIndexResponse
 */
async function modifyIndex(instanceId: string, indexName: string, request: ModifyIndexRequest): ModifyIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyIndexWithOptions(instanceId, indexName, request, headers, runtime);
}

model ModifyIndexOnlineStrategyRequest {
  changeRate?: int32(name='changeRate', description='The index change rate.', example='20'),
}

model ModifyIndexOnlineStrategyResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='10D5E615-69F7-5F49-B850-00169ADE513C'),
  result?: map[string]any(name='result', description='The result.', example='{}'),
}

model ModifyIndexOnlineStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyIndexOnlineStrategyResponseBody(name='body'),
}

/**
 * @summary Modifies the online policy of an index.
 *
 * @param request ModifyIndexOnlineStrategyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIndexOnlineStrategyResponse
 */
async function modifyIndexOnlineStrategyWithOptions(instanceId: string, dataSourceName: string, deployName: string, indexName: string, request: ModifyIndexOnlineStrategyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyIndexOnlineStrategyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.changeRate)) {
    body['changeRate'] = request.changeRate;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIndexOnlineStrategy',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/data-sources/${OpenApiUtil.getEncodeParam(dataSourceName)}/deploys/${OpenApiUtil.getEncodeParam(deployName)}/indexes/${OpenApiUtil.getEncodeParam(indexName)}/online-strategy`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the online policy of an index.
 *
 * @param request ModifyIndexOnlineStrategyRequest
 * @return ModifyIndexOnlineStrategyResponse
 */
async function modifyIndexOnlineStrategy(instanceId: string, dataSourceName: string, deployName: string, indexName: string, request: ModifyIndexOnlineStrategyRequest): ModifyIndexOnlineStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyIndexOnlineStrategyWithOptions(instanceId, dataSourceName, deployName, indexName, request, headers, runtime);
}

model ModifyIndexPartitionRequest {
  dataSourceName?: string(name='dataSourceName', description='The name of the data source.', example='test1'),
  domainName?: string(name='domainName', description='The data center.', example='pre_domain_1'),
  generation?: long(name='generation', description='The primary key.', example='1633293829'),
  indexInfos?: [ 
    {
      indexName?: string(name='indexName', description='The index name.', example='atest2'),
      parallelNum?: int32(name='parallelNum', description='The concurrency. Default value: 1.', example='1'),
      partitionCount?: int32(name='partitionCount', description='The number of shards.', example='3'),
    }
  ](name='indexInfos', description='The index information.'),
}

model ModifyIndexPartitionResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='93A9E542-8CF8-5BA6-99AB-94C0FE520429'),
  result?: map[string]any(name='result', description='Map', example='[]'),
}

model ModifyIndexPartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyIndexPartitionResponseBody(name='body'),
}

/**
 * @summary Modifies the information about index partitions.
 *
 * @description ### Method
 * `PUT`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}/index-partition`
 *
 * @param request ModifyIndexPartitionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIndexPartitionResponse
 */
async function modifyIndexPartitionWithOptions(instanceId: string, request: ModifyIndexPartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyIndexPartitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataSourceName)) {
    body['dataSourceName'] = request.dataSourceName;
  }
  if (!Util.isUnset(request.domainName)) {
    body['domainName'] = request.domainName;
  }
  if (!Util.isUnset(request.generation)) {
    body['generation'] = request.generation;
  }
  if (!Util.isUnset(request.indexInfos)) {
    body['indexInfos'] = request.indexInfos;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIndexPartition',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/index-partition`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the information about index partitions.
 *
 * @description ### Method
 * `PUT`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}/index-partition`
 *
 * @param request ModifyIndexPartitionRequest
 * @return ModifyIndexPartitionResponse
 */
async function modifyIndexPartition(instanceId: string, request: ModifyIndexPartitionRequest): ModifyIndexPartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyIndexPartitionWithOptions(instanceId, request, headers, runtime);
}

model ModifyIndexVersionRequest {
  body?: [ 
    {
      buildDeployId?: string(name='buildDeployId', description='The deployment ID of the data source.', example='277'),
      indexName?: string(name='indexName', description='The index name.', example='main_index'),
      version?: string(name='version', description='The index version.', example='1'),
    }
  ](name='body', description='The request body.', example='{}'),
}

model ModifyIndexVersionResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='F43E8AB4-419C-5F4C-90D6-615590DFAA3C'),
  result?: map[string]any(name='result', description='result', example='{}'),
}

model ModifyIndexVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyIndexVersionResponseBody(name='body'),
}

/**
 * @summary Modifies the index version of a cluster (an index version rollback).
 *
 * @description ## [](#)Method
 *     PUT
 * ## [](#uri)URI
 *     /openapi/ha3/instances/{instanceId}/clusters/{clusterName}/index-version
 *
 * @param request ModifyIndexVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIndexVersionResponse
 */
async function modifyIndexVersionWithOptions(instanceId: string, clusterName: string, request: ModifyIndexVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyIndexVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIndexVersion',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/clusters/${OpenApiUtil.getEncodeParam(clusterName)}/index-version`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the index version of a cluster (an index version rollback).
 *
 * @description ## [](#)Method
 *     PUT
 * ## [](#uri)URI
 *     /openapi/ha3/instances/{instanceId}/clusters/{clusterName}/index-version
 *
 * @param request ModifyIndexVersionRequest
 * @return ModifyIndexVersionResponse
 */
async function modifyIndexVersion(instanceId: string, clusterName: string, request: ModifyIndexVersionRequest): ModifyIndexVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyIndexVersionWithOptions(instanceId, clusterName, request, headers, runtime);
}

model ModifyModelRequest {
  content?: {
    dimension?: int32(name='dimension', example='128'),
    method?: string(name='method', example='POST'),
    modelType?: string(name='modelType', example='text_embedding'),
    request?: {
      header?: {
        authorization?: string(name='Authorization', example='Bearer OS-v0********6vvs'),
        contentType?: string(name='Content-Type', example='application/json'),
      }(name='header'),
      parameters?: {
        build?: {
          inputType?: string(name='input_type', example='query'),
        }(name='build'),
        search?: {
          inputType?: string(name='input_type', example='document'),
        }(name='search'),
      }(name='parameters'),
      requestBody?: string(name='requestBody', example='{\\\\"input\\\\": [\\\\"%{input}\\\\"], \\\\"input_type\\\\": \\\\"%{input_type}\\\\"}'),
      urlParams?: {
        build?: map[string]any(name='build', example='key: value'),
        search?: map[string]any(name='search', example='key: value'),
      }(name='urlParams'),
    }(name='request'),
    response?: {
      embeddings?: string(name='embeddings', example='$.result.embeddings[*].embedding'),
    }(name='response'),
    url?: string(name='url', example='http://***.platform-cn-shanghai.opensearch.aliyuncs.com/v3/openapi/workspaces/default/text-embedding/ops-text-embedding-001'),
  }(name='content'),
  status?: string(name='status', example='ok'),
  dryRun?: string(name='dryRun', example='true'),
}

model ModifyModelResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='D39EE0F1-D7EF-5F46-B781-6BF4185308B0'),
}

model ModifyModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyModelResponseBody(name='body'),
}

/**
 * @summary 修改模型详情，修改模型状态
 *
 * @param request ModifyModelRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyModelResponse
 */
async function modifyModelWithOptions(instanceId: string, modelName: string, request: ModifyModelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyModelResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyModel',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/models/${OpenApiUtil.getEncodeParam(modelName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 修改模型详情，修改模型状态
 *
 * @param request ModifyModelRequest
 * @return ModifyModelResponse
 */
async function modifyModel(instanceId: string, modelName: string, request: ModifyModelRequest): ModifyModelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyModelWithOptions(instanceId, modelName, request, headers, runtime);
}

model ModifyNodeConfigRequest {
  active?: boolean(name='active', description='Specifies whether to enable the index.', example='true'),
  dataDuplicateNumber?: int32(name='dataDuplicateNumber', description='The number of data replicas.', example='1'),
  dataFragmentNumber?: int32(name='dataFragmentNumber', description='The number of data shards.', example='1'),
  flowRatio?: int32(name='flowRatio', description='The traffic percentage.', example='-100'),
  minServicePercent?: int32(name='minServicePercent', description='The minimum service ratio.', example='10'),
  published?: boolean(name='published', description='Specifies whether to mount the cluster.', example='true'),
  clusterName?: string(name='clusterName', description='The name of the cluster.', example='vpc_sh_domain_2'),
  dataSourceName?: string(name='dataSourceName', description='The name of the data source. Valid values: -search: search for data. -not_search: do not search for data.', example='ha-cn-2r42ostoc01_0704'),
  name?: string(name='name', description='The name of the configuration before the modification.

This parameter is required.', example='ha-cn-zvp2iv9a401_qrs'),
  type?: string(name='type', description='The type of the algorithm. Valid values:

*   pop: a popularity model.
*   cp: a category prediction model.
*   hot: a top search model.
*   hint: a hint model.
*   suggest: a drop-down suggestions model.

This parameter is required.', example='" "'),
}

model ModifyNodeConfigResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='D39EE0F1-D7EF-5F46-B781-6BF4185308B0'),
  result?: map[string]any(name='result', description='The information about the index', example='{}'),
}

model ModifyNodeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyNodeConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the configurations of a node.
 *
 * @description ### Method
 * ```java
 * PUT
 * ```
 * ### URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/node-config?type=qrs&name=test
 * ```
 *
 * @param request ModifyNodeConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyNodeConfigResponse
 */
async function modifyNodeConfigWithOptions(instanceId: string, request: ModifyNodeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyNodeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterName)) {
    query['clusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.dataSourceName)) {
    query['dataSourceName'] = request.dataSourceName;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.active)) {
    body['active'] = request.active;
  }
  if (!Util.isUnset(request.dataDuplicateNumber)) {
    body['dataDuplicateNumber'] = request.dataDuplicateNumber;
  }
  if (!Util.isUnset(request.dataFragmentNumber)) {
    body['dataFragmentNumber'] = request.dataFragmentNumber;
  }
  if (!Util.isUnset(request.flowRatio)) {
    body['flowRatio'] = request.flowRatio;
  }
  if (!Util.isUnset(request.minServicePercent)) {
    body['minServicePercent'] = request.minServicePercent;
  }
  if (!Util.isUnset(request.published)) {
    body['published'] = request.published;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNodeConfig',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/node-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the configurations of a node.
 *
 * @description ### Method
 * ```java
 * PUT
 * ```
 * ### URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/node-config?type=qrs&name=test
 * ```
 *
 * @param request ModifyNodeConfigRequest
 * @return ModifyNodeConfigResponse
 */
async function modifyNodeConfig(instanceId: string, request: ModifyNodeConfigRequest): ModifyNodeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyNodeConfigWithOptions(instanceId, request, headers, runtime);
}

model ModifyOnlineConfigRequest {
  body?: map[string]string(name='body', description='The request body.'),
}

model ModifyOnlineConfigResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='2AE63638-5420-56DC-BF59-37D8174039A0'),
  result?: map[string]any(name='result', description='Map', example='{}'),
}

model ModifyOnlineConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyOnlineConfigResponseBody(name='body'),
}

/**
 * @summary Modifies online configurations.
 *
 * @description ### Method
 * ```java
 * put
 * ```
 * ### URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/node/{nodeName}/online-configs/{indexName}
 * ```
 *
 * @param request ModifyOnlineConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyOnlineConfigResponse
 */
async function modifyOnlineConfigWithOptions(instanceId: string, nodeName: string, indexName: string, request: ModifyOnlineConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyOnlineConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyOnlineConfig',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/node/${OpenApiUtil.getEncodeParam(nodeName)}/online-configs/${OpenApiUtil.getEncodeParam(indexName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies online configurations.
 *
 * @description ### Method
 * ```java
 * put
 * ```
 * ### URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/node/{nodeName}/online-configs/{indexName}
 * ```
 *
 * @param request ModifyOnlineConfigRequest
 * @return ModifyOnlineConfigResponse
 */
async function modifyOnlineConfig(instanceId: string, nodeName: string, indexName: string, request: ModifyOnlineConfigRequest): ModifyOnlineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyOnlineConfigWithOptions(instanceId, nodeName, indexName, request, headers, runtime);
}

model ModifyPasswordRequest {
  password?: string(name='password', description='The password.', example='******************************'),
  username?: string(name='username', description='The username.', example='"username"'),
}

model ModifyPasswordResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request', example='407BFD91-DE7D-50BA-8F88-CDE52A3B5E46'),
  result?: map[string]any(name='result', description='The result', example='{}'),
}

model ModifyPasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyPasswordResponseBody(name='body'),
}

/**
 * @summary 修改实例的密码
 *
 * @description ### Method
 * `PUT`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}/password`
 *
 * @param request ModifyPasswordRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPasswordResponse
 */
async function modifyPasswordWithOptions(instanceId: string, request: ModifyPasswordRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyPasswordResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.password)) {
    body['password'] = request.password;
  }
  if (!Util.isUnset(request.username)) {
    body['username'] = request.username;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPassword',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/password`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 修改实例的密码
 *
 * @description ### Method
 * `PUT`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}/password`
 *
 * @param request ModifyPasswordRequest
 * @return ModifyPasswordResponse
 */
async function modifyPassword(instanceId: string, request: ModifyPasswordRequest): ModifyPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyPasswordWithOptions(instanceId, request, headers, runtime);
}

model ModifyPausePolicyRequest {
  body?: map[string]BodyValue(name='body', description='The request body.'),
}

model ModifyPausePolicyResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='0B1FF998-BB8D-5182-BFC0-E471AA77095A'),
  result?: map[string]any(name='result', description='The result.', example='{}'),
}

model ModifyPausePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyPausePolicyResponseBody(name='body'),
}

/**
 * @param request ModifyPausePolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPausePolicyResponse
 */
async function modifyPausePolicyWithOptions(instanceId: string, request: ModifyPausePolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyPausePolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPausePolicy',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/pause-policies`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request ModifyPausePolicyRequest
 * @return ModifyPausePolicyResponse
 */
async function modifyPausePolicy(instanceId: string, request: ModifyPausePolicyRequest): ModifyPausePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyPausePolicyWithOptions(instanceId, request, headers, runtime);
}

model ModifyPublicUrlIpListRequest {
  body?: map[string]string(name='body', description='The request body.'),
}

model ModifyPublicUrlIpListResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='E45380E8-994A-5402-9806-F114B3295FCF'),
  result?: map[string]any(name='result', description='The result.', example='{}'),
}

model ModifyPublicUrlIpListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyPublicUrlIpListResponseBody(name='body'),
}

/**
 * @summary 修改公网域名访问白名单
 *
 * @param request ModifyPublicUrlIpListRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPublicUrlIpListResponse
 */
async function modifyPublicUrlIpListWithOptions(instanceId: string, request: ModifyPublicUrlIpListRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyPublicUrlIpListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPublicUrlIpList',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/public-url-ip-list`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 修改公网域名访问白名单
 *
 * @param request ModifyPublicUrlIpListRequest
 * @return ModifyPublicUrlIpListResponse
 */
async function modifyPublicUrlIpList(instanceId: string, request: ModifyPublicUrlIpListRequest): ModifyPublicUrlIpListResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyPublicUrlIpListWithOptions(instanceId, request, headers, runtime);
}

model ModifyTableRequest {
  dataProcessConfig?: [ 
    {
      dstField?: string(name='dstField', description='The destination field.', example='source_image_vector'),
      operator?: string(name='operator', description='The method used to process the field. Valid values: copy and vectorize. A value of copy specifies that the value of the source field is copied to the destination field. A value of vectorize specifies that the value of the source field is vectorized by a vectorization model and the output vector is stored in the destination field.', example='vectorize'),
      params?: {
        srcFieldConfig?: {
          ossBucket?: string(name='ossBucket', description='The name of the OSS bucket.', example='test'),
          ossEndpoint?: string(name='ossEndpoint', description='The OSS endpoint.', example='oss-cn-hangzhou-internal.aliyuncs.com'),
          uid?: string(name='uid', description='The ID of the Alibaba Cloud account.', example='uid'),
        }(name='srcFieldConfig', description='The source of the data to be vectorized.'),
        vectorModal?: string(name='vectorModal', description='The data type.', example='image'),
        vectorModel?: string(name='vectorModel', description='The vectorization model.', example='clip'),
      }(name='params', description='The information about the model.'),
      srcField?: string(name='srcField', description='The source field.', example='source_image'),
    }
  ](name='dataProcessConfig', description='The configurations about field processing.'),
  dataSource?: {
    autoBuildIndex?: boolean(name='autoBuildIndex', description='Specifies whether to automatically rebuild the index.', example='true'),
    config?: {
      accessKey?: string(name='accessKey', description='The AccessKey ID of the MaxCompute data source.', example='AK'),
      accessSecret?: string(name='accessSecret', description='The AccessKey secret of the MaxCompute data source.', example='AS'),
      bucket?: string(name='bucket', description='The name of the OSS bucket.', example='antsys-shujiang-osstest'),
      catalog?: string(name='catalog'),
      database?: string(name='database'),
      endpoint?: string(name='endpoint', description='The endpoint of the MaxCompute data source.', example='http://service.cn-hangzhou.maxcompute.aliyun-inc.com/api'),
      ossPath?: string(name='ossPath', description='The path of the Object Storage Service (OSS) object.', example='oss://opensearch'),
      partition?: string(name='partition', description='The partition in the MaxCompute table.', example='ds=20231220'),
      project?: string(name='project', description='The name of the MaxCompute project that is used as the data source.', example='yw_dw_rpt'),
      table?: string(name='table', description='The name of the MaxCompute table that is used as the data source.', example='behavior'),
      tag?: string(name='tag'),
    }(name='config', description='The configurations of the data source.'),
    dataTimeSec?: int32(name='dataTimeSec', description='The start timestamp from which incremental data is retrieved.', example='1715160176'),
  }(name='dataSource', description='The configurations of the data source.'),
  fieldSchema?: map[string]string(name='fieldSchema', description='The fields.'),
  partitionCount?: int32(name='partitionCount', description='The number of data shards.', example='1'),
  primaryKey?: string(name='primaryKey', description='The primary key field.', example='id'),
  rawSchema?: string(name='rawSchema', description='The instance schema. If this parameter is specified, the parameters about the index are not required.', example='{}'),
  vectorIndex?: [ 
    {
      advanceParams?: {
        buildIndexParams?: string(name='buildIndexParams', description='The index building parameters.', example='{}'),
        linearBuildThreshold?: string(name='linearBuildThreshold', description='The threshold for linear building.', example='5000'),
        minScanDocCnt?: string(name='minScanDocCnt', description='The minimum number of retrieved candidate sets.', example='20000'),
        searchIndexParams?: string(name='searchIndexParams', description='The index retrieval parameters.', example='{}'),
      }(name='advanceParams', description='The configurations of the index schema.'),
      dimension?: string(name='dimension', description='The dimension of the vector.', example='128'),
      distanceType?: string(name='distanceType', description='The distance type.', example='SquaredEuclidean'),
      indexName?: string(name='indexName', description='The name of the index schema.', example='test_api'),
      namespace?: string(name='namespace', description='The namespace field.', example='namespace'),
      sparseIndexField?: string(name='sparseIndexField', description='The field that stores the indexes of the elements in sparse vectors.', example='sparse_indices'),
      sparseValueField?: string(name='sparseValueField', description='The field that stores the elements in sparse vectors.', example='sparse_values'),
      vectorField?: string(name='vectorField', description='The vector field.', example='source_image_vector'),
      vectorIndexType?: string(name='vectorIndexType', description='The vector retrieval algorithm.', example='Qc'),
    }
  ](name='vectorIndex', description='The index schema.'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform only a dry run, without performing the actual request. The system only checks the validity of the data source. Valid values:

*   true
*   false', example='true'),
}

model ModifyTableResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='FE03180A-0E29-5474-8A86-33F0683294A4'),
  result?: map[string]any(name='result', description='Map', example='{}'),
}

model ModifyTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyTableResponseBody(name='body'),
}

/**
 * @summary Modifies an index table.
 *
 * @param request ModifyTableRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyTableResponse
 */
async function modifyTableWithOptions(instanceId: string, tableName: string, request: ModifyTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyTableResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.dataProcessConfig)) {
    body['dataProcessConfig'] = request.dataProcessConfig;
  }
  if (!Util.isUnset(request.dataSource)) {
    body['dataSource'] = request.dataSource;
  }
  if (!Util.isUnset(request.fieldSchema)) {
    body['fieldSchema'] = request.fieldSchema;
  }
  if (!Util.isUnset(request.partitionCount)) {
    body['partitionCount'] = request.partitionCount;
  }
  if (!Util.isUnset(request.primaryKey)) {
    body['primaryKey'] = request.primaryKey;
  }
  if (!Util.isUnset(request.rawSchema)) {
    body['rawSchema'] = request.rawSchema;
  }
  if (!Util.isUnset(request.vectorIndex)) {
    body['vectorIndex'] = request.vectorIndex;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyTable',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/tables/${OpenApiUtil.getEncodeParam(tableName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies an index table.
 *
 * @param request ModifyTableRequest
 * @return ModifyTableResponse
 */
async function modifyTable(instanceId: string, tableName: string, request: ModifyTableRequest): ModifyTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyTableWithOptions(instanceId, tableName, request, headers, runtime);
}

model PublishAdvanceConfigRequest {
  desc?: string(name='desc', description='The description of the advanced configuration.', example='Custom configuration'),
  files?: [ 
    {
      config?: {
        content?: string(name='content', description='The file content.', example='{\\\\"url\\\\":\\\\"http://xxxxxx.aliyuncs.com/outnet_hz/packages/xxxxx/opensearch_offline_plugins_xxxxx.tar\\\\"}'),
        variables?: map[string]FilesConfigVariablesValue(name='variables', description='The variables.'),
      }(name='config', description='The information about the advanced configuration.'),
      dirName?: string(name='dirName', description='The directory name.', example='/clusters'),
      fileName?: string(name='fileName', description='The file name.', example='vector_question_schema.json'),
      operateType?: string(name='operateType', description='The operation type. Valid values: UPDATE and DELETE. Default value: UPDATE.', example='UPDATE'),
      ossPath?: string(name='ossPath', description='The path of the Object Storage Service (OSS) object.', example='oss://opensearch/test.json'),
      parentFullPath?: string(name='parentFullPath', description='The path of the parent directory.', example='/'),
    }
  ](name='files', description='The files.'),
}

model PublishAdvanceConfigResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request', example='10D5E615-69F7-5F49-B850-00169ADE513C'),
  result?: map[string]any(name='result', description='The result returned', example='{}'),
}

model PublishAdvanceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PublishAdvanceConfigResponseBody(name='body'),
}

/**
 * @summary Publishes a version of advanced configurations.
 *
 * @description ## Method
 * ~~~
 * POST
 * ~~~
 * ## URI
 * ~~~
 * /openapi/ha3/instances/{instanceId}/advanced-configs/{configName}/actions/publish
 * ~~~
 *
 * @param request PublishAdvanceConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishAdvanceConfigResponse
 */
async function publishAdvanceConfigWithOptions(instanceId: string, configName: string, request: PublishAdvanceConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PublishAdvanceConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.desc)) {
    body['desc'] = request.desc;
  }
  if (!Util.isUnset(request.files)) {
    body['files'] = request.files;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PublishAdvanceConfig',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/advanced-configs/${OpenApiUtil.getEncodeParam(configName)}/actions/publish`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Publishes a version of advanced configurations.
 *
 * @description ## Method
 * ~~~
 * POST
 * ~~~
 * ## URI
 * ~~~
 * /openapi/ha3/instances/{instanceId}/advanced-configs/{configName}/actions/publish
 * ~~~
 *
 * @param request PublishAdvanceConfigRequest
 * @return PublishAdvanceConfigResponse
 */
async function publishAdvanceConfig(instanceId: string, configName: string, request: PublishAdvanceConfigRequest): PublishAdvanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return publishAdvanceConfigWithOptions(instanceId, configName, request, headers, runtime);
}

model PublishIndexVersionRequest {
  body?: map[string]any(name='body', description='The request body.', example='{}'),
}

model PublishIndexVersionResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='E45380E8-994A-5402-9806-F114B3295FCF'),
  result?: map[string]any(name='result', description='The information about the index', example='{}'),
}

model PublishIndexVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PublishIndexVersionResponseBody(name='body'),
}

/**
 * @summary Publishes a specified index version.
 *
 * @description ## Method
 *     POST
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/indexes/{indexName}/actions/publish
 *
 * @param request PublishIndexVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishIndexVersionResponse
 */
async function publishIndexVersionWithOptions(instanceId: string, indexName: string, request: PublishIndexVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PublishIndexVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PublishIndexVersion',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/indexes/${OpenApiUtil.getEncodeParam(indexName)}/actions/publish`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Publishes a specified index version.
 *
 * @description ## Method
 *     POST
 * ## URI
 *     /openapi/ha3/instances/{instanceId}/indexes/{indexName}/actions/publish
 *
 * @param request PublishIndexVersionRequest
 * @return PublishIndexVersionResponse
 */
async function publishIndexVersion(instanceId: string, indexName: string, request: PublishIndexVersionRequest): PublishIndexVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return publishIndexVersionWithOptions(instanceId, indexName, request, headers, runtime);
}

model PushDocumentsRequest {
  body?: [ any ](name='body', description='The request body.'),
  pkField?: string(name='pkField', description='The primary key field.', example='id'),
}

model PushDocumentsResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='2AE63638-5420-56DC-BF59-37D8174039A0'),
  result?: map[string]any(name='result', description='The result.', example='{}'),
}

model PushDocumentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushDocumentsResponseBody(name='body'),
}

/**
 * @param request PushDocumentsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushDocumentsResponse
 */
async function pushDocumentsWithOptions(instanceId: string, dataSourceName: string, request: PushDocumentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PushDocumentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pkField)) {
    query['pkField'] = request.pkField;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'PushDocuments',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/data-sources/${OpenApiUtil.getEncodeParam(dataSourceName)}/actions/bulk`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request PushDocumentsRequest
 * @return PushDocumentsResponse
 */
async function pushDocuments(instanceId: string, dataSourceName: string, request: PushDocumentsRequest): PushDocumentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return pushDocumentsWithOptions(instanceId, dataSourceName, request, headers, runtime);
}

model RecoverIndexRequest {
  buildDeployId?: int32(name='buildDeployId', description='The deployment ID of the data source.', example='277'),
  dataSourceName?: string(name='dataSourceName', description='The name of the data source.', example='ha-cn-pl32rf0js04_odps_first'),
  generation?: string(name='generation', description='The ID of the full index version.', example='1653018575'),
  indexName?: string(name='indexName', description='The index name.', example='main_index'),
}

model RecoverIndexResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request.', example='10D5E615-69F7-5F49-B850-00169ADE513C'),
  result?: map[string]any(name='result', description='The result returned by data search.', example='{}'),
}

model RecoverIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RecoverIndexResponseBody(name='body'),
}

/**
 * @summary Restores data from an index.
 *
 * @description ### Method
 * `POST`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}/recover-index`
 *
 * @param request RecoverIndexRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RecoverIndexResponse
 */
async function recoverIndexWithOptions(instanceId: string, request: RecoverIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RecoverIndexResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.buildDeployId)) {
    body['buildDeployId'] = request.buildDeployId;
  }
  if (!Util.isUnset(request.dataSourceName)) {
    body['dataSourceName'] = request.dataSourceName;
  }
  if (!Util.isUnset(request.generation)) {
    body['generation'] = request.generation;
  }
  if (!Util.isUnset(request.indexName)) {
    body['indexName'] = request.indexName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RecoverIndex',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/recover-index`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Restores data from an index.
 *
 * @description ### Method
 * `POST`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}/recover-index`
 *
 * @param request RecoverIndexRequest
 * @return RecoverIndexResponse
 */
async function recoverIndex(instanceId: string, request: RecoverIndexRequest): RecoverIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return recoverIndexWithOptions(instanceId, request, headers, runtime);
}

model ReindexRequest {
  dataTimeSec?: int32(name='dataTimeSec', description='The timestamp in seconds. The value must be of the INTEGER type. This parameter is required if you specify an API data source.', example='1640867288'),
  ossDataPath?: string(name='ossDataPath', description='oss data path', example='oss://opensearch'),
  partition?: string(name='partition', description='The partition in the MaxCompute table. This parameter is required if type is set to odps.', example='ds=20220713'),
}

model ReindexResponseBody = {
  requestId?: string(name='requestId', description='requestId', example='10D5E615-69F7-5F49-B850-00169ADE513C'),
  result?: map[string]any(name='result', description='Map', example='{}'),
}

model ReindexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReindexResponseBody(name='body'),
}

/**
 * @summary Rebuilds an index.
 *
 * @param request ReindexRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReindexResponse
 */
async function reindexWithOptions(instanceId: string, tableName: string, request: ReindexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ReindexResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataTimeSec)) {
    body['dataTimeSec'] = request.dataTimeSec;
  }
  if (!Util.isUnset(request.ossDataPath)) {
    body['ossDataPath'] = request.ossDataPath;
  }
  if (!Util.isUnset(request.partition)) {
    body['partition'] = request.partition;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'Reindex',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/tables/${OpenApiUtil.getEncodeParam(tableName)}/reindex`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Rebuilds an index.
 *
 * @param request ReindexRequest
 * @return ReindexResponse
 */
async function reindex(instanceId: string, tableName: string, request: ReindexRequest): ReindexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return reindexWithOptions(instanceId, tableName, request, headers, runtime);
}

model RemoveClusterResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='E45380E8-994A-5402-9806-F114B3295FCF'),
  result?: map[string]any(name='result', description='The result', example='{}'),
}

model RemoveClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveClusterResponseBody(name='body'),
}

/**
 * @summary Deletes a cluster.
 *
 * @description ### Method
 * ```java
 * DELETE
 * ```
 * ### URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/clusters/{clusterName}
 * ```
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveClusterResponse
 */
async function removeClusterWithOptions(instanceId: string, clusterName: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveClusterResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveCluster',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/clusters/${OpenApiUtil.getEncodeParam(clusterName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a cluster.
 *
 * @description ### Method
 * ```java
 * DELETE
 * ```
 * ### URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/clusters/{clusterName}
 * ```
 *
 * @return RemoveClusterResponse
 */
async function removeCluster(instanceId: string, clusterName: string): RemoveClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeClusterWithOptions(instanceId, clusterName, headers, runtime);
}

model RenameFolderRequest {
  name?: string(name='name', description='This parameter is required.', example='test'),
}

model RenameFolderResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='10D5E615-69F7-5F49-B850-00169ADE513C'),
  result?: {
    gmtCreate?: string(name='gmtCreate', example='1719221186114'),
    gmtModified?: string(name='gmtModified', example='1719221186114'),
    id?: long(name='id', example='1'),
    instanceId?: long(name='instanceId', example='1'),
    isDir?: int32(name='isDir', example='True'),
    name?: string(name='name', example='test'),
    parent?: long(name='parent', example='-1'),
    templateId?: long(name='templateId', example='1'),
    type?: string(name='type', description='table, instance, template, function', example='template'),
  }(name='result', description='NodeVO'),
}

model RenameFolderResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenameFolderResponseBody(name='body'),
}

/**
 * @param request RenameFolderRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RenameFolderResponse
 */
async function renameFolderWithOptions(instanceId: string, database: string, folderId: string, request: RenameFolderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenameFolderResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RenameFolder',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/sql-studio/databases/${OpenApiUtil.getEncodeParam(database)}/folders/${OpenApiUtil.getEncodeParam(folderId)}/name`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request RenameFolderRequest
 * @return RenameFolderResponse
 */
async function renameFolder(instanceId: string, database: string, folderId: string, request: RenameFolderRequest): RenameFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renameFolderWithOptions(instanceId, database, folderId, request, headers, runtime);
}

model StartIndexResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='D39EE0F1-D7EF-5F46-B781-6BF4185308B0'),
  result?: map[string]any(name='result', description='The index map.', example='{}'),
}

model StartIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartIndexResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartIndexResponse
 */
async function startIndexWithOptions(instanceId: string, indexName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartIndexResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartIndex',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/indexes/${OpenApiUtil.getEncodeParam(indexName)}/startIndex`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @return StartIndexResponse
 */
async function startIndex(instanceId: string, indexName: string): StartIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startIndexWithOptions(instanceId, indexName, headers, runtime);
}

model StopIndexResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='E7B7D598-B080-5C8E-AA35-D43EC0D5F886'),
  result?: map[string]any(name='result', description='The index map.', example='{}'),
}

model StopIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopIndexResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopIndexResponse
 */
async function stopIndexWithOptions(instanceId: string, indexName: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopIndexResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopIndex',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/indexes/${OpenApiUtil.getEncodeParam(indexName)}/stopIndex`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @return StopIndexResponse
 */
async function stopIndex(instanceId: string, indexName: string): StopIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopIndexWithOptions(instanceId, indexName, headers, runtime);
}

model StopTaskResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='FE03180A-0E29-5474-8A86-33F0683294A4'),
  result?: map[string]any(name='result', description='The information about the index', example='{}'),
}

model StopTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopTaskResponseBody(name='body'),
}

/**
 * @summary Stops an FSM task.
 *
 * @description ### [](#)Method
 * ```java
 * PUT
 * ```
 * ### [](#uri)URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/stop-task/{fsmId}
 * ```
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopTaskResponse
 */
async function stopTaskWithOptions(instanceId: string, fsmId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopTask',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/stop-task/${OpenApiUtil.getEncodeParam(fsmId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Stops an FSM task.
 *
 * @description ### [](#)Method
 * ```java
 * PUT
 * ```
 * ### [](#uri)URI
 * ```java
 * /openapi/ha3/instances/{instanceId}/stop-task/{fsmId}
 * ```
 *
 * @return StopTaskResponse
 */
async function stopTask(instanceId: string, fsmId: string): StopTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopTaskWithOptions(instanceId, fsmId, headers, runtime);
}

model TagResourcesRequest {
  resourceId?: [ string ](name='resourceId', description='This parameter is required.'),
  resourceType?: string(name='resourceType', description='This parameter is required.', example='instance'),
  tag?: [ 
    {
      key?: string(name='key', example='opensearch'),
      value?: string(name='value', example='opensearch'),
    }
  ](name='tag', description='This parameter is required.'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='requestId', example='E7B7D598-B080-5C8E-AA35-D43EC0D5F886'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
 * @summary 打标签接口
 *
 * @param request TagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
async function tagResourcesWithOptions(request: TagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.resourceId)) {
    body['resourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    body['tag'] = request.tag;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/resource-tags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 打标签接口
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(request, headers, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='all', example='true'),
  resourceId?: [ string ](name='resourceId', description='This parameter is required.'),
  resourceType?: string(name='resourceType', description='This parameter is required.', example='instance'),
  tagKey?: [ string ](name='tagKey'),
}

model UntagResourcesShrinkRequest {
  all?: boolean(name='all', example='true'),
  resourceIdShrink?: string(name='resourceId', description='This parameter is required.'),
  resourceType?: string(name='resourceType', description='This parameter is required.', example='instance'),
  tagKeyShrink?: string(name='tagKey'),
}

model UntagResourcesResponseBody = {
  tequestId?: string(name='tequestId', example='E7B7D598-B080-5C8E-AA35-D43EC0D5F886'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
 * @summary 删标签接口
 *
 * @param tmpReq UntagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesResponse
 */
async function untagResourcesWithOptions(tmpReq: UntagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new UntagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceId)) {
    request.resourceIdShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceId, 'resourceId', 'json');
  }
  if (!Util.isUnset(tmpReq.tagKey)) {
    request.tagKeyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tagKey, 'tagKey', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    query['all'] = request.all;
  }
  if (!Util.isUnset(request.resourceIdShrink)) {
    query['resourceId'] = request.resourceIdShrink;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKeyShrink)) {
    query['tagKey'] = request.tagKeyShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/resource-tags`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 删标签接口
 *
 * @param request UntagResourcesRequest
 * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourcesWithOptions(request, headers, runtime);
}

model UpdateInstanceRequest {
  components?: [ 
    {
      code?: string(name='code', description='The code of the specification, which must be consistent with the value that you specify on the buy page.', example='200'),
      value?: string(name='value', description='The value of the specification.', example='""'),
    }
  ](name='components', description='The information about the instance specification.'),
  description?: string(name='description', description='The description of the instance.', example='""'),
  orderType?: string(name='orderType', description='The type of the order. Valid values: UPGRADE and DOWNGRADE. UPGRADE upgrades the instance specifications. DOWNGRADE: downgrades the instance specifications.', example='""'),
}

model UpdateInstanceResponseBody = {
  requestId?: string(name='requestId', description='The ID of the request', example='90D6B8F5-FE97-4509-9AAB-367836C51818'),
  result?: {
    chargeType?: string(name='chargeType', description='The billing method.', example='PrePaid'),
    commodityCode?: string(name='commodityCode', description='The commodity code of the instance.', example='ha3-code'),
    createTime?: string(name='createTime', description='The time when the instance was created', example='2018-12-06T11:17:49.0'),
    description?: string(name='description', description='The description of the instance', example='Test instance'),
    expiredTime?: string(name='expiredTime', description='The time when the instance expires', example='2019-01-06T16:00:00.0'),
    inDebt?: boolean(name='inDebt', description='Indicates whether an overdue payment is involved', example='false'),
    instanceId?: string(name='instanceId', description='The instance ID.', example='ha-cn-0ju2s170b03'),
    lockMode?: string(name='lockMode', description='The lock status', example='Unlock'),
    resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group.', example='rg-aeky6hthboewpuy'),
    status?: string(name='status', description='The instance status.', example='Running'),
    updateTime?: string(name='updateTime', description='The time when the instance was last updated', example='2018-12-06T11:17:49.0'),
  }(name='result', description='The results returned.'),
}

model UpdateInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateInstanceResponseBody(name='body'),
}

/**
 * @summary Modifies the configuration of a specified instance.
 *
 * @description ### Method
 * `PUT`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}`
 *
 * @param request UpdateInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateInstanceResponse
 */
async function updateInstanceWithOptions(instanceId: string, request: UpdateInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.components)) {
    body['components'] = request.components;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.orderType)) {
    body['orderType'] = request.orderType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstance',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the configuration of a specified instance.
 *
 * @description ### Method
 * `PUT`
 * ### URI
 * `/openapi/ha3/instances/{instanceId}`
 *
 * @param request UpdateInstanceRequest
 * @return UpdateInstanceResponse
 */
async function updateInstance(instanceId: string, request: UpdateInstanceRequest): UpdateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateInstanceWithOptions(instanceId, request, headers, runtime);
}

model UpdateSqlInstanceContentRequest {
  content?: string(name='content', description='This parameter is required.', example='select * from test'),
}

model UpdateSqlInstanceContentResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='E45380E8-994A-5402-9806-F114B3295FCF'),
  result?: {
    combineParams?: string(name='combineParams', example='{\\\\"trace\\\\":\\\\"INFO\\\\",\\\\"databaseName\\\\":\\\\"general\\\\",\\\\"iquan.plan.cache.enable\\\\":true,\\\\"iquan.plan.prepare.level\\\\":\\\\"jni.post.optimize\\\\",\\\\"urlencode_data\\\\":false,\\\\"formatType\\\\":\\\\"string\\\\",\\\\"timeout\\\\":1000}'),
    comment?: string(name='comment'),
    content?: string(name='content', example='select * from test'),
    dynamicParams?: string(name='dynamicParams', example='{\\\\"trace\\\\":\\\\"INFO\\\\",\\\\"databaseName\\\\":\\\\"general\\\\",\\\\"iquan.plan.cache.enable\\\\":true,\\\\"iquan.plan.prepare.level\\\\":\\\\"jni.post.optimize\\\\",\\\\"urlencode_data\\\\":false,\\\\"formatType\\\\":\\\\"string\\\\",\\\\"timeout\\\\":1000}'),
    gmtCreate?: string(name='gmtCreate', example='1719221186114'),
    gmtModified?: string(name='gmtModified', example='1719221186114'),
    instanceId?: long(name='instanceId', example='1'),
    kvpairs?: string(name='kvpairs', example='{\\\\"trace\\\\":\\\\"INFO\\\\",\\\\"databaseName\\\\":\\\\"general\\\\",\\\\"iquan.plan.cache.enable\\\\":true,\\\\"iquan.plan.prepare.level\\\\":\\\\"jni.post.optimize\\\\",\\\\"urlencode_data\\\\":false,\\\\"formatType\\\\":\\\\"string\\\\",\\\\"timeout\\\\":1000}'),
    relatedTemplateId?: long(name='relatedTemplateId', example='1'),
    staticParams?: string(name='staticParams', example='{\\\\"trace\\\\":\\\\"INFO\\\\",\\\\"databaseName\\\\":\\\\"general\\\\",\\\\"iquan.plan.cache.enable\\\\":true,\\\\"iquan.plan.prepare.level\\\\":\\\\"jni.post.optimize\\\\",\\\\"urlencode_data\\\\":false,\\\\"formatType\\\\":\\\\"string\\\\",\\\\"timeout\\\\":1000}'),
    templateParams?: string(name='templateParams', example='{\\\\"trace\\\\":\\\\"INFO\\\\",\\\\"databaseName\\\\":\\\\"general\\\\",\\\\"iquan.plan.cache.enable\\\\":true,\\\\"iquan.plan.prepare.level\\\\":\\\\"jni.post.optimize\\\\",\\\\"urlencode_data\\\\":false,\\\\"formatType\\\\":\\\\"string\\\\",\\\\"timeout\\\\":1000}'),
    version?: long(name='version', example='1'),
  }(name='result', description='InstanceVersionVO'),
}

model UpdateSqlInstanceContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSqlInstanceContentResponseBody(name='body'),
}

/**
 * @param request UpdateSqlInstanceContentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSqlInstanceContentResponse
 */
async function updateSqlInstanceContentWithOptions(instanceId: string, database: string, sqlInstanceId: string, request: UpdateSqlInstanceContentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSqlInstanceContentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSqlInstanceContent',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/sql-studio/databases/${OpenApiUtil.getEncodeParam(database)}/sql-instances/${OpenApiUtil.getEncodeParam(sqlInstanceId)}/content`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request UpdateSqlInstanceContentRequest
 * @return UpdateSqlInstanceContentResponse
 */
async function updateSqlInstanceContent(instanceId: string, database: string, sqlInstanceId: string, request: UpdateSqlInstanceContentRequest): UpdateSqlInstanceContentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSqlInstanceContentWithOptions(instanceId, database, sqlInstanceId, request, headers, runtime);
}

model UpdateSqlInstanceNameRequest {
  name?: string(name='name', description='This parameter is required.', example='test'),
}

model UpdateSqlInstanceNameResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='E7B7D598-B080-5C8E-AA35-D43EC0D5F886'),
  result?: {
    gmtCreate?: string(name='gmtCreate', example='1719220182844'),
    gmtModified?: string(name='gmtModified', example='1719221186114'),
    id?: long(name='id', example='22'),
    instanceId?: long(name='instanceId', example='1'),
    isDir?: int32(name='isDir', example='true'),
    name?: string(name='name', example='general'),
    parent?: long(name='parent', example='-1'),
    templateId?: long(name='templateId', example='1'),
    type?: string(name='type', description='table, instance, template, function', example='instance'),
  }(name='result', description='NodeVO'),
}

model UpdateSqlInstanceNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSqlInstanceNameResponseBody(name='body'),
}

/**
 * @param request UpdateSqlInstanceNameRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSqlInstanceNameResponse
 */
async function updateSqlInstanceNameWithOptions(instanceId: string, database: string, sqlInstanceId: string, request: UpdateSqlInstanceNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSqlInstanceNameResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSqlInstanceName',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/sql-studio/databases/${OpenApiUtil.getEncodeParam(database)}/sql-instances/${OpenApiUtil.getEncodeParam(sqlInstanceId)}/name`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request UpdateSqlInstanceNameRequest
 * @return UpdateSqlInstanceNameResponse
 */
async function updateSqlInstanceName(instanceId: string, database: string, sqlInstanceId: string, request: UpdateSqlInstanceNameRequest): UpdateSqlInstanceNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSqlInstanceNameWithOptions(instanceId, database, sqlInstanceId, request, headers, runtime);
}

model UpdateSqlInstanceParamsRequest {
  combineParam?: map[string]any(name='combineParam'),
  dynamicParam?: map[string]any(name='dynamicParam'),
  kvpair?: map[string]any(name='kvpair'),
  params?: map[string]any(name='params'),
  staticParam?: map[string]any(name='staticParam'),
}

model UpdateSqlInstanceParamsResponseBody = {
  requestId?: string(name='requestId', description='id of request', example='022F36C7-9FB4-5D67-BEBC-3D14B0984463'),
  result?: {
    combineParams?: string(name='combineParams', example='{\\\\"trace\\\\":\\\\"INFO\\\\",\\\\"databaseName\\\\":\\\\"general\\\\",\\\\"iquan.plan.cache.enable\\\\":true,\\\\"iquan.plan.prepare.level\\\\":\\\\"jni.post.optimize\\\\",\\\\"urlencode_data\\\\":false,\\\\"formatType\\\\":\\\\"string\\\\",\\\\"timeout\\\\":1000}'),
    comment?: string(name='comment'),
    content?: string(name='content', example='select * from test'),
    dynamicParams?: string(name='dynamicParams', example='{\\\\"trace\\\\":\\\\"INFO\\\\",\\\\"databaseName\\\\":\\\\"general\\\\",\\\\"iquan.plan.cache.enable\\\\":true,\\\\"iquan.plan.prepare.level\\\\":\\\\"jni.post.optimize\\\\",\\\\"urlencode_data\\\\":false,\\\\"formatType\\\\":\\\\"string\\\\",\\\\"timeout\\\\":1000}'),
    gmtCreate?: string(name='gmtCreate', example='1719221186114'),
    gmtModified?: string(name='gmtModified', example='1719220182844'),
    instanceId?: long(name='instanceId', example='1'),
    kvpairs?: string(name='kvpairs', example='{\\\\"trace\\\\":\\\\"INFO\\\\",\\\\"databaseName\\\\":\\\\"general\\\\",\\\\"iquan.plan.cache.enable\\\\":true,\\\\"iquan.plan.prepare.level\\\\":\\\\"jni.post.optimize\\\\",\\\\"urlencode_data\\\\":false,\\\\"formatType\\\\":\\\\"string\\\\",\\\\"timeout\\\\":1000}'),
    relatedTemplateId?: long(name='relatedTemplateId', example='1'),
    staticParams?: string(name='staticParams', example='{\\\\"trace\\\\":\\\\"INFO\\\\",\\\\"databaseName\\\\":\\\\"general\\\\",\\\\"iquan.plan.cache.enable\\\\":true,\\\\"iquan.plan.prepare.level\\\\":\\\\"jni.post.optimize\\\\",\\\\"urlencode_data\\\\":false,\\\\"formatType\\\\":\\\\"string\\\\",\\\\"timeout\\\\":1000}'),
    templateParams?: string(name='templateParams', example='{\\\\"trace\\\\":\\\\"INFO\\\\",\\\\"databaseName\\\\":\\\\"general\\\\",\\\\"iquan.plan.cache.enable\\\\":true,\\\\"iquan.plan.prepare.level\\\\":\\\\"jni.post.optimize\\\\",\\\\"urlencode_data\\\\":false,\\\\"formatType\\\\":\\\\"string\\\\",\\\\"timeout\\\\":1000}'),
    version?: long(name='version', example='1'),
  }(name='result', description='InstanceVersionVO'),
}

model UpdateSqlInstanceParamsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSqlInstanceParamsResponseBody(name='body'),
}

/**
 * @param request UpdateSqlInstanceParamsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSqlInstanceParamsResponse
 */
async function updateSqlInstanceParamsWithOptions(instanceId: string, database: string, sqlInstanceId: string, request: UpdateSqlInstanceParamsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSqlInstanceParamsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.combineParam)) {
    body['combineParam'] = request.combineParam;
  }
  if (!Util.isUnset(request.dynamicParam)) {
    body['dynamicParam'] = request.dynamicParam;
  }
  if (!Util.isUnset(request.kvpair)) {
    body['kvpair'] = request.kvpair;
  }
  if (!Util.isUnset(request.params)) {
    body['params'] = request.params;
  }
  if (!Util.isUnset(request.staticParam)) {
    body['staticParam'] = request.staticParam;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSqlInstanceParams',
    version = '2021-10-25',
    protocol = 'HTTPS',
    pathname = `/openapi/ha3/instances/${OpenApiUtil.getEncodeParam(instanceId)}/sql-studio/databases/${OpenApiUtil.getEncodeParam(database)}/sql-instances/${OpenApiUtil.getEncodeParam(sqlInstanceId)}/params`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request UpdateSqlInstanceParamsRequest
 * @return UpdateSqlInstanceParamsResponse
 */
async function updateSqlInstanceParams(instanceId: string, database: string, sqlInstanceId: string, request: UpdateSqlInstanceParamsRequest): UpdateSqlInstanceParamsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSqlInstanceParamsWithOptions(instanceId, database, sqlInstanceId, request, headers, runtime);
}

