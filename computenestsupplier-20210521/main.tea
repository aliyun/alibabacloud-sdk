/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('computenestsupplier', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ContinueDeployServiceInstanceRequest {
  clientToken?: string(name='ClientToken'),
  parameters?: string(name='Parameters'),
  regionId?: string(name='RegionId'),
  serviceInstanceId?: string(name='ServiceInstanceId'),
}

model ContinueDeployServiceInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ContinueDeployServiceInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ContinueDeployServiceInstanceResponseBody(name='body'),
}

async function continueDeployServiceInstanceWithOptions(request: ContinueDeployServiceInstanceRequest, runtime: Util.RuntimeOptions): ContinueDeployServiceInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serviceInstanceId)) {
    query['ServiceInstanceId'] = request.serviceInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ContinueDeployServiceInstance',
    version = '2021-05-21',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function continueDeployServiceInstance(request: ContinueDeployServiceInstanceRequest): ContinueDeployServiceInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return continueDeployServiceInstanceWithOptions(request, runtime);
}

model CreateServiceRequest {
  alarmMetadata?: string(name='AlarmMetadata'),
  clientToken?: string(name='ClientToken'),
  deployMetadata?: string(name='DeployMetadata'),
  deployType?: string(name='DeployType'),
  duration?: long(name='Duration'),
  isSupportOperated?: boolean(name='IsSupportOperated'),
  policyNames?: string(name='PolicyNames'),
  regionId?: string(name='RegionId'),
  requestTag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='RequestTag'),
  saleMetadata?: string(name='SaleMetadata'),
  serviceId?: string(name='ServiceId'),
  serviceInfo?: [ 
    {
      image?: string(name='Image'),
      locale?: string(name='Locale'),
      name?: string(name='Name'),
      shortDescription?: string(name='ShortDescription'),
    }
  ](name='ServiceInfo'),
  serviceType?: string(name='ServiceType'),
  shareType?: string(name='ShareType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  trialDuration?: long(name='TrialDuration'),
  upgradeMetadata?: string(name='UpgradeMetadata'),
  versionName?: string(name='VersionName'),
}

model CreateServiceResponseBody = {
  requestId?: string(name='RequestId'),
  serviceId?: string(name='ServiceId'),
  status?: string(name='Status'),
  version?: string(name='Version'),
}

model CreateServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceResponseBody(name='body'),
}

async function createServiceWithOptions(request: CreateServiceRequest, runtime: Util.RuntimeOptions): CreateServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alarmMetadata)) {
    query['AlarmMetadata'] = request.alarmMetadata;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.deployMetadata)) {
    query['DeployMetadata'] = request.deployMetadata;
  }
  if (!Util.isUnset(request.deployType)) {
    query['DeployType'] = request.deployType;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.isSupportOperated)) {
    query['IsSupportOperated'] = request.isSupportOperated;
  }
  if (!Util.isUnset(request.policyNames)) {
    query['PolicyNames'] = request.policyNames;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestTag)) {
    query['RequestTag'] = request.requestTag;
  }
  if (!Util.isUnset(request.saleMetadata)) {
    query['SaleMetadata'] = request.saleMetadata;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['ServiceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.serviceInfo)) {
    query['ServiceInfo'] = request.serviceInfo;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['ServiceType'] = request.serviceType;
  }
  if (!Util.isUnset(request.shareType)) {
    query['ShareType'] = request.shareType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.trialDuration)) {
    query['TrialDuration'] = request.trialDuration;
  }
  if (!Util.isUnset(request.upgradeMetadata)) {
    query['UpgradeMetadata'] = request.upgradeMetadata;
  }
  if (!Util.isUnset(request.versionName)) {
    query['VersionName'] = request.versionName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateService',
    version = '2021-05-21',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createService(request: CreateServiceRequest): CreateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceWithOptions(request, runtime);
}

model CreateServiceInstanceRequest {
  clientToken?: string(name='ClientToken'),
  parameters?: map[string]any(name='Parameters'),
  regionId?: string(name='RegionId'),
  requestTag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='RequestTag'),
  resourceGroupId?: string(name='ResourceGroupId'),
  serviceId?: string(name='ServiceId'),
  serviceVersion?: string(name='ServiceVersion'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  templateName?: string(name='TemplateName'),
  userId?: string(name='UserId', description='用户ID'),
}

model CreateServiceInstanceShrinkRequest {
  clientToken?: string(name='ClientToken'),
  parametersShrink?: string(name='Parameters'),
  regionId?: string(name='RegionId'),
  requestTag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='RequestTag'),
  resourceGroupId?: string(name='ResourceGroupId'),
  serviceId?: string(name='ServiceId'),
  serviceVersion?: string(name='ServiceVersion'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  templateName?: string(name='TemplateName'),
  userId?: string(name='UserId', description='用户ID'),
}

model CreateServiceInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  serviceInstanceId?: string(name='ServiceInstanceId'),
  status?: string(name='Status'),
}

model CreateServiceInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceInstanceResponseBody(name='body'),
}

async function createServiceInstanceWithOptions(tmpReq: CreateServiceInstanceRequest, runtime: Util.RuntimeOptions): CreateServiceInstanceResponse {
  Util.validateModel(tmpReq);
  var request = new CreateServiceInstanceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.parameters)) {
    request.parametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.parameters, 'Parameters', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.parametersShrink)) {
    query['Parameters'] = request.parametersShrink;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestTag)) {
    query['RequestTag'] = request.requestTag;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['ServiceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query['ServiceVersion'] = request.serviceVersion;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceInstance',
    version = '2021-05-21',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createServiceInstance(request: CreateServiceInstanceRequest): CreateServiceInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceInstanceWithOptions(request, runtime);
}

model DeleteServiceInstancesRequest {
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  serviceInstanceId?: [ string ](name='ServiceInstanceId'),
}

model DeleteServiceInstancesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteServiceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceInstancesResponseBody(name='body'),
}

async function deleteServiceInstancesWithOptions(request: DeleteServiceInstancesRequest, runtime: Util.RuntimeOptions): DeleteServiceInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serviceInstanceId)) {
    query['ServiceInstanceId'] = request.serviceInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceInstances',
    version = '2021-05-21',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteServiceInstances(request: DeleteServiceInstancesRequest): DeleteServiceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServiceInstancesWithOptions(request, runtime);
}

model ListServiceInstanceLogsRequest {
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  serviceInstanceId?: string(name='ServiceInstanceId'),
}

model ListServiceInstanceLogsResponseBody = {
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  serviceInstancesLogs?: [ 
    {
      content?: string(name='Content'),
      logType?: string(name='LogType'),
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      serviceInstanceId?: string(name='ServiceInstanceId'),
      source?: string(name='Source'),
      status?: string(name='Status'),
      timestamp?: string(name='Timestamp'),
    }
  ](name='ServiceInstancesLogs'),
}

model ListServiceInstanceLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceInstanceLogsResponseBody(name='body'),
}

async function listServiceInstanceLogsWithOptions(request: ListServiceInstanceLogsRequest, runtime: Util.RuntimeOptions): ListServiceInstanceLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serviceInstanceId)) {
    query['ServiceInstanceId'] = request.serviceInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceInstanceLogs',
    version = '2021-05-21',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServiceInstanceLogs(request: ListServiceInstanceLogsRequest): ListServiceInstanceLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServiceInstanceLogsWithOptions(request, runtime);
}

model ListServiceInstancesRequest {
  filter?: [ 
    {
      name?: string(name='Name'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListServiceInstancesResponseBody = {
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  serviceInstances?: [ 
    {
      createTime?: string(name='CreateTime'),
      enableInstanceOps?: boolean(name='EnableInstanceOps'),
      endTime?: string(name='EndTime'),
      operatedServiceInstanceId?: string(name='OperatedServiceInstanceId'),
      operationEndTime?: string(name='OperationEndTime'),
      operationStartTime?: string(name='OperationStartTime'),
      parameters?: string(name='Parameters'),
      progress?: long(name='Progress'),
      service?: {
        deployMetadata?: string(name='DeployMetadata'),
        deployType?: string(name='DeployType'),
        publishTime?: string(name='PublishTime'),
        serviceId?: string(name='ServiceId'),
        serviceInfos?: [ 
          {
            image?: string(name='Image'),
            locale?: string(name='Locale'),
            name?: string(name='Name'),
            shortDescription?: string(name='ShortDescription'),
          }
        ](name='ServiceInfos'),
        serviceType?: string(name='ServiceType'),
        status?: string(name='Status'),
        supplierName?: string(name='SupplierName'),
        supplierUrl?: string(name='SupplierUrl'),
        version?: string(name='Version'),
        versionName?: string(name='VersionName'),
      }(name='Service'),
      serviceInstanceId?: string(name='ServiceInstanceId'),
      serviceType?: string(name='ServiceType'),
      source?: string(name='Source'),
      status?: string(name='Status'),
      statusDetail?: string(name='StatusDetail'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      templateName?: string(name='TemplateName'),
      updateTime?: string(name='UpdateTime'),
      userId?: long(name='UserId'),
    }
  ](name='ServiceInstances'),
  totalCount?: int32(name='TotalCount'),
}

model ListServiceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceInstancesResponseBody(name='body'),
}

async function listServiceInstancesWithOptions(request: ListServiceInstancesRequest, runtime: Util.RuntimeOptions): ListServiceInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceInstances',
    version = '2021-05-21',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServiceInstances(request: ListServiceInstancesRequest): ListServiceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServiceInstancesWithOptions(request, runtime);
}

model ListServicesRequest {
  allVersions?: boolean(name='AllVersions'),
  filter?: [ 
    {
      name?: string(name='Name'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  requestTag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='RequestTag'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListServicesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  services?: [ 
    {
      artifactId?: string(name='ArtifactId'),
      artifactVersion?: string(name='ArtifactVersion'),
      commodityCode?: string(name='CommodityCode'),
      createTime?: string(name='CreateTime'),
      defaultVersion?: boolean(name='DefaultVersion'),
      deployType?: string(name='DeployType'),
      publishTime?: string(name='PublishTime'),
      relationType?: string(name='RelationType'),
      serviceId?: string(name='ServiceId'),
      serviceInfos?: [ 
        {
          image?: string(name='Image'),
          locale?: string(name='Locale'),
          name?: string(name='Name'),
          shortDescription?: string(name='ShortDescription'),
        }
      ](name='ServiceInfos'),
      serviceType?: string(name='ServiceType'),
      shareType?: string(name='ShareType'),
      sourceImage?: string(name='SourceImage'),
      status?: string(name='Status'),
      supplierName?: string(name='SupplierName'),
      supplierUrl?: string(name='SupplierUrl'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      tenantType?: string(name='TenantType'),
      trialType?: string(name='TrialType'),
      updateTime?: string(name='UpdateTime'),
      version?: string(name='Version'),
      versionName?: string(name='VersionName'),
    }
  ](name='Services'),
  totalCount?: string(name='TotalCount'),
}

model ListServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServicesResponseBody(name='body'),
}

async function listServicesWithOptions(request: ListServicesRequest, runtime: Util.RuntimeOptions): ListServicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allVersions)) {
    query['AllVersions'] = request.allVersions;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestTag)) {
    query['RequestTag'] = request.requestTag;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServices',
    version = '2021-05-21',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServices(request: ListServicesRequest): ListServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServicesWithOptions(request, runtime);
}

