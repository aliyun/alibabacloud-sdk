/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('openitag', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateTaskDetail {
  admins?: {
    users?: [
      SimpleUser
    ](name='Users'),
  }(name='Admins'),
  allowAppendData?: boolean(name='AllowAppendData'),
  assignConfig?: TaskAssginConfig(name='AssignConfig'),
  datasetProxyRelations?: [
    DatasetProxyConfig
  ](name='DatasetProxyRelations'),
  exif?: map[string]any(name='Exif'),
  tags?: [ string ](name='Tags'),
  taskName?: string(name='TaskName'),
  taskTemplateConfig?: TaskTemplateConfig(name='TaskTemplateConfig'),
  taskWorkflow?: [ 
    {
      nodeName?: string(name='NodeName'),
    }
  ](name='TaskWorkflow'),
  templateId?: string(name='TemplateId'),
  UUID?: string(name='UUID'),
}

model DatasetProxyConfig {
  datasetType?: string(name='DatasetType'),
  source?: string(name='Source'),
  sourceDatasetId?: string(name='SourceDatasetId'),
}

model FlowJobInfo {
  display?: boolean(name='Display'),
  jobId?: string(name='JobId'),
  jobType?: string(name='JobType'),
  messageId?: string(name='MessageId'),
  processType?: string(name='ProcessType'),
  taskId?: string(name='TaskId'),
}

model Job {
  creator?: SimpleUser(name='Creator'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  jobId?: string(name='JobId'),
  jobResult?: {
    resultLink?: string(name='ResultLink'),
  }(name='JobResult'),
  jobType?: string(name='JobType'),
  status?: string(name='Status'),
}

model MarkResult {
  isNeedVoteJudge?: boolean(name='IsNeedVoteJudge'),
  markResult?: string(name='MarkResult'),
  markResultId?: string(name='MarkResultId'),
  markTime?: string(name='MarkTime'),
  markTitle?: string(name='MarkTitle'),
  progress?: string(name='Progress'),
  questionId?: string(name='QuestionId'),
  resultType?: string(name='ResultType'),
  userMarkResultId?: string(name='UserMarkResultId'),
  version?: string(name='Version'),
}

model QuestionOption {
  children?: [
    QuestionOption
  ](name='Children'),
  color?: string(name='Color'),
  key?: string(name='Key'),
  label?: string(name='Label'),
  remark?: string(name='Remark'),
  shortcut?: string(name='Shortcut'),
}

model QuestionPlugin {
  canSelect?: boolean(name='CanSelect'),
  children?: [
    QuestionPlugin
  ](name='Children'),
  defaultResult?: string(name='DefaultResult'),
  display?: boolean(name='Display'),
  exif?: map[string]any(name='Exif'),
  hotKeyMap?: string(name='HotKeyMap'),
  markTitle?: string(name='MarkTitle'),
  markTitleAlias?: string(name='MarkTitleAlias'),
  mustFill?: boolean(name='MustFill'),
  options?: [
    QuestionOption
  ](name='Options'),
  preOptions?: [ string ](name='PreOptions'),
  questionId?: string(name='QuestionId'),
  rule?: string(name='Rule'),
  selectGroup?: string(name='SelectGroup'),
  selected?: boolean(name='Selected'),
  type?: string(name='Type'),
}

model SimpleSubtask {
  items?: [ 
    {
      abandonFlag?: boolean(name='AbandonFlag'),
      abandonRemark?: string(name='AbandonRemark'),
      dataId?: string(name='DataId'),
      feedbackFlag?: boolean(name='FeedbackFlag'),
      feedbackRemark?: string(name='FeedbackRemark'),
      fixedFlag?: boolean(name='FixedFlag'),
      itemId?: long(name='ItemId'),
      mine?: long(name='Mine'),
      rejectFlag?: boolean(name='RejectFlag'),
      state?: string(name='State'),
      weight?: long(name='Weight'),
    }
  ](name='Items'),
  status?: string(name='Status'),
  subtaskId?: long(name='SubtaskId'),
}

model SimpleTask {
  archived?: boolean(name='Archived'),
  archivedInfos?: string(name='ArchivedInfos'),
  creator?: SimpleUser(name='Creator'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  labelStyle?: string(name='LabelStyle'),
  modifier?: SimpleUser(name='Modifier'),
  refTaskId?: string(name='RefTaskId'),
  remark?: string(name='Remark'),
  stage?: string(name='Stage'),
  status?: string(name='Status'),
  tags?: [ string ](name='Tags'),
  taskId?: string(name='TaskId'),
  taskName?: string(name='TaskName'),
  taskType?: string(name='TaskType'),
  templateId?: string(name='TemplateId'),
  tenantId?: string(name='TenantId'),
  UUID?: string(name='UUID'),
  workflowNodes?: [ string ](name='WorkflowNodes'),
}

model SimpleTemplate {
  abandonReasons?: string(name='AbandonReasons'),
  description?: string(name='Description'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  sharedMode?: string(name='SharedMode'),
  status?: string(name='Status'),
  tags?: [ string ](name='Tags'),
  templateId?: string(name='TemplateId'),
  templateName?: string(name='TemplateName'),
  tenantId?: string(name='TenantId'),
  type?: string(name='Type'),
}

model SimpleTenant {
  creator?: SimpleUser(name='Creator'),
  description?: string(name='Description'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  modifier?: SimpleUser(name='Modifier'),
  role?: string(name='Role'),
  tenantId?: string(name='TenantId'),
  tenantName?: string(name='TenantName'),
  UUID?: string(name='UUID'),
}

model SimpleUser {
  accountNo?: string(name='AccountNo'),
  accountType?: string(name='AccountType'),
  role?: string(name='Role'),
  userId?: long(name='UserId'),
  userName?: string(name='UserName'),
}

model SimpleWorkforce {
  userIds?: [ long ](name='UserIds'),
  workNodeId?: int32(name='WorkNodeId'),
}

model SingleTenant {
  description?: string(name='Description'),
  status?: string(name='Status'),
  tenantId?: string(name='TenantId'),
  tenantName?: string(name='TenantName'),
  UUID?: string(name='UUID'),
}

model SubtaskDetail {
  canDiscard?: boolean(name='CanDiscard'),
  canReassign?: boolean(name='CanReassign'),
  canRelease?: boolean(name='CanRelease'),
  currentWorkNode?: string(name='CurrentWorkNode'),
  extConfigs?: string(name='ExtConfigs'),
  items?: [ 
    {
      abandonFlag?: boolean(name='AbandonFlag'),
      abandonRemark?: string(name='AbandonRemark'),
      dataId?: string(name='DataId'),
      feedbackFlag?: boolean(name='FeedbackFlag'),
      feedbackRemark?: string(name='FeedbackRemark'),
      fixedFlag?: boolean(name='FixedFlag'),
      mine?: long(name='Mine'),
      rejectFlag?: boolean(name='RejectFlag'),
      state?: string(name='State'),
      weight?: long(name='Weight'),
    }
  ](name='Items'),
  status?: string(name='Status'),
  subtaskId?: string(name='SubtaskId'),
  taskId?: string(name='TaskId'),
  weight?: long(name='Weight'),
  workNodeState?: string(name='WorkNodeState'),
  workforce?: [
    Workforce
  ](name='Workforce'),
}

model SubtaskItemDetail {
  annotations?: [ 
    {
      abandonFlag?: boolean(name='AbandonFlag'),
      abandonRemark?: string(name='AbandonRemark'),
      dataId?: string(name='DataId'),
      feedbackFlag?: boolean(name='FeedbackFlag'),
      feedbackRemark?: string(name='FeedbackRemark'),
      fixedFlag?: boolean(name='FixedFlag'),
      mine?: long(name='Mine'),
      rejectFlag?: boolean(name='RejectFlag'),
      state?: string(name='State'),
      weight?: long(name='Weight'),
    }
  ](name='Annotations'),
  dataSource?: map[string]any(name='DataSource'),
  itemId?: long(name='ItemId'),
}

model TaskAssginConfig {
  assignCount?: long(name='AssignCount'),
  assignField?: string(name='AssignField'),
  assignSubTaskCount?: string(name='AssignSubTaskCount'),
  assignType?: string(name='AssignType'),
}

model TaskDetail {
  admins?: [
    SimpleUser
  ](name='Admins'),
  alertTime?: long(name='AlertTime'),
  allowAppendData?: boolean(name='AllowAppendData'),
  archived?: boolean(name='Archived'),
  archivedInfos?: string(name='ArchivedInfos'),
  assignConfig?: map[string]any(name='AssignConfig'),
  creator?: SimpleUser(name='Creator'),
  datasetProxyRelations?: [ 
    {
      datasetId?: string(name='DatasetId'),
      datasetType?: string(name='DatasetType'),
      exif?: map[string]any(name='Exif'),
      source?: string(name='Source'),
      sourceBizId?: string(name='SourceBizId'),
      sourceDatasetId?: string(name='SourceDatasetId'),
    }
  ](name='DatasetProxyRelations'),
  exif?: map[string]any(name='Exif'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  labelStyle?: string(name='LabelStyle'),
  mineConfigs?: map[string]any(name='MineConfigs'),
  modifier?: SimpleUser(name='Modifier'),
  noticeConfig?: map[string]any(name='NoticeConfig'),
  periodConfig?: map[string]any(name='PeriodConfig'),
  refTaskId?: string(name='RefTaskId'),
  relateTaskConfig?: map[string]any(name='RelateTaskConfig'),
  remark?: string(name='Remark'),
  resultCallbackConfig?: map[string]any(name='ResultCallbackConfig'),
  stage?: string(name='Stage'),
  status?: string(name='Status'),
  tags?: [ string ](name='Tags'),
  taskId?: string(name='TaskId'),
  taskName?: string(name='TaskName'),
  taskTemplateConfig?: {
    exif?: map[string]any(name='Exif'),
    resourceKey?: string(name='ResourceKey'),
    robotConfig?: map[string]any(name='RobotConfig'),
    selectQuestions?: [ string ](name='SelectQuestions'),
    templateOptionMap?: map[string]any(name='TemplateOptionMap'),
    templateRelationId?: string(name='TemplateRelationId'),
  }(name='TaskTemplateConfig'),
  taskType?: string(name='TaskType'),
  taskWorkflow?: [ 
    {
      exif?: map[string]any(name='Exif'),
      groups?: [ string ](name='Groups'),
      nodeName?: string(name='NodeName'),
      users?: [
        SimpleUser
      ](name='Users'),
    }
  ](name='TaskWorkflow'),
  templateId?: string(name='TemplateId'),
  tenantId?: string(name='TenantId'),
  tenantName?: string(name='TenantName'),
  UUID?: string(name='UUID'),
  voteConfigs?: map[string]any(name='VoteConfigs'),
  workflowNodes?: [ string ](name='WorkflowNodes'),
  runMsg?: string(name='runMsg'),
}

model TaskStatistic {
  acceptItemCount?: float(name='AcceptItemCount'),
  checkAbandon?: float(name='CheckAbandon'),
  checkAccuracy?: float(name='CheckAccuracy'),
  checkEfficiency?: float(name='CheckEfficiency'),
  checkedAccuracy?: float(name='CheckedAccuracy'),
  checkedError?: float(name='CheckedError'),
  checkedRejectCount?: float(name='CheckedRejectCount'),
  finalAbandonCount?: float(name='FinalAbandonCount'),
  finishedItemCount?: long(name='FinishedItemCount'),
  finishedSubtaskCount?: long(name='FinishedSubtaskCount'),
  markEfficiency?: float(name='MarkEfficiency'),
  preMarkFixedCount?: float(name='PreMarkFixedCount'),
  sampledAccuracy?: float(name='SampledAccuracy'),
  sampledErrorCount?: float(name='SampledErrorCount'),
  sampledRejectCount?: float(name='SampledRejectCount'),
  samplingAccuracy?: float(name='SamplingAccuracy'),
  totalCheckCount?: float(name='TotalCheckCount'),
  totalCheckTime?: float(name='TotalCheckTime'),
  totalCheckedCount?: float(name='TotalCheckedCount'),
  totalItemCount?: long(name='TotalItemCount'),
  totalMarkTime?: float(name='TotalMarkTime'),
  totalSampledCount?: float(name='TotalSampledCount'),
  totalSamplingCount?: float(name='TotalSamplingCount'),
  totalSubtaskCount?: long(name='TotalSubtaskCount'),
  totalWorkTime?: float(name='TotalWorkTime'),
}

model TaskTemplateConfig {
  exif?: map[string]string(name='Exif'),
  resourceKey?: string(name='ResourceKey'),
  selectQuestions?: [ string ](name='SelectQuestions'),
  templateOptionMap?: map[string]string(name='TemplateOptionMap'),
  templateRelationId?: string(name='TemplateRelationId'),
}

model TemplateDTO {
  classify?: string(name='Classify'),
  description?: string(name='Description'),
  exif?: map[string]any(name='Exif'),
  questionConfigs?: [
    QuestionPlugin
  ](name='QuestionConfigs'),
  robotConfigs?: [  map[string]any ](name='RobotConfigs'),
  sharedMode?: string(name='SharedMode'),
  tags?: [ string ](name='Tags'),
  templateId?: string(name='TemplateId'),
  templateName?: string(name='TemplateName'),
  viewConfigs?: {
    viewPlugins?: [
      ViewPlugin
    ](name='ViewPlugins'),
  }(name='ViewConfigs'),
}

model TemplateDetail {
  abandonReasons?: [ string ](name='AbandonReasons'),
  classify?: string(name='Classify'),
  creator?: SimpleUser(name='Creator'),
  description?: string(name='Description'),
  exif?: map[string]any(name='Exif'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  modifier?: SimpleUser(name='Modifier'),
  questionConfigs?: [
    QuestionPlugin
  ](name='QuestionConfigs'),
  sharedMode?: string(name='SharedMode'),
  status?: string(name='Status'),
  tags?: [ string ](name='Tags'),
  templateId?: string(name='TemplateId'),
  templateName?: string(name='TemplateName'),
  tenantId?: string(name='TenantId'),
  type?: string(name='Type'),
  viewConfigs?: {
    viewPlugins?: [
      ViewPlugin
    ](name='ViewPlugins'),
  }(name='ViewConfigs'),
}

model TemplateQuestion {
  children?: [
    TemplateQuestion
  ](name='Children'),
  exif?: map[string]any(name='Exif'),
  markTitle?: string(name='MarkTitle'),
  options?: [
    QuestionOption
  ](name='Options'),
  preOptions?: [ string ](name='PreOptions'),
  questionId?: long(name='QuestionId'),
  type?: string(name='Type'),
}

model TemplateView {
  fields?: [ 
    {
      displayOriImg?: boolean(name='DisplayOriImg'),
      fieldName?: string(name='FieldName'),
      type?: string(name='Type'),
      visitInfo?: {
        aftsConf?: map[string]any(name='AftsConf'),
        ossConf?: map[string]any(name='OssConf'),
      }(name='VisitInfo'),
    }
  ](name='Fields'),
}

model UpdateTaskDTO {
  exif?: map[string]string(name='Exif'),
  remark?: string(name='Remark'),
  tags?: [ string ](name='Tags'),
  taskName?: string(name='TaskName'),
}

model UserStatistic {
  acceptedMarkItemsCount?: float(name='AcceptedMarkItemsCount'),
  checkCount?: float(name='CheckCount'),
  checkedAcceptedCount?: float(name='CheckedAcceptedCount'),
  checkedAccuracy?: float(name='CheckedAccuracy'),
  markEfficiency?: float(name='MarkEfficiency'),
  markTime?: float(name='MarkTime'),
  samplingAccuracy?: float(name='SamplingAccuracy'),
  samplingCount?: float(name='SamplingCount'),
  samplingErrorCount?: float(name='SamplingErrorCount'),
  totalMarkItemsCount?: float(name='TotalMarkItemsCount'),
  userId?: string(name='UserId'),
}

model ViewPlugin {
  bindField?: string(name='BindField'),
  convertor?: string(name='Convertor'),
  corsProxy?: boolean(name='CorsProxy'),
  displayOriImg?: boolean(name='DisplayOriImg'),
  exif?: map[string]any(name='Exif'),
  hide?: boolean(name='Hide'),
  plugins?: map[string]any(name='Plugins'),
  relationQuestionIds?: [ string ](name='RelationQuestionIds'),
  type?: string(name='Type'),
  visitInfo?: {
    aftsConf?: map[string]any(name='aftsConf'),
    ossConf?: map[string]any(name='ossConf'),
  }(name='VisitInfo'),
}

model Workforce {
  nodeType?: string(name='NodeType'),
  users?: [
    SimpleUser
  ](name='Users'),
  workNodeId?: int32(name='WorkNodeId'),
}

model AddWorkNodeWorkforceRequest {
  userIds?: [ long ](name='UserIds'),
}

model AddWorkNodeWorkforceResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddWorkNodeWorkforceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddWorkNodeWorkforceResponseBody(name='body'),
}

async function addWorkNodeWorkforce(TenantId: string, TaskId: string, WorkNodeId: string, request: AddWorkNodeWorkforceRequest): AddWorkNodeWorkforceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addWorkNodeWorkforceWithOptions(TenantId, TaskId, WorkNodeId, request, headers, runtime);
}

async function addWorkNodeWorkforceWithOptions(TenantId: string, TaskId: string, WorkNodeId: string, request: AddWorkNodeWorkforceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddWorkNodeWorkforceResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskId = OpenApiUtil.getEncodeParam(TaskId);
  WorkNodeId = OpenApiUtil.getEncodeParam(WorkNodeId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.userIds)) {
    body['UserIds'] = request.userIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddWorkNodeWorkforce',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskId}/worknodes/${WorkNodeId}/workforce`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateTaskRequest {
  body?: CreateTaskDetail(name='body'),
}

model CreateTaskResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model CreateTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTaskResponseBody(name='body'),
}

async function createTask(TenantId: string, request: CreateTaskRequest): CreateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTaskWithOptions(TenantId, request, headers, runtime);
}

async function createTaskWithOptions(TenantId: string, request: CreateTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTaskResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTask',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateTemplateRequest {
  body?: TemplateDTO(name='body'),
}

model CreateTemplateResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  templateId?: string(name='TemplateId'),
}

model CreateTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTemplateResponseBody(name='body'),
}

async function createTemplate(TenantId: string, request: CreateTemplateRequest): CreateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTemplateWithOptions(TenantId, request, headers, runtime);
}

async function createTemplateWithOptions(TenantId: string, request: CreateTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTemplateResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTemplate',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/templates`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateUserRequest {
  accountNo?: string(name='AccountNo'),
  accountType?: string(name='AccountType'),
  role?: string(name='Role'),
  userName?: string(name='UserName'),
}

model CreateUserResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  userId?: long(name='UserId'),
}

model CreateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUserResponseBody(name='body'),
}

async function createUser(TenantId: string, request: CreateUserRequest): CreateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createUserWithOptions(TenantId, request, headers, runtime);
}

async function createUserWithOptions(TenantId: string, request: CreateUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateUserResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accountNo)) {
    body['AccountNo'] = request.accountNo;
  }
  if (!Util.isUnset(request.accountType)) {
    body['AccountType'] = request.accountType;
  }
  if (!Util.isUnset(request.role)) {
    body['Role'] = request.role;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateUser',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/users`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteTaskResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTaskResponseBody(name='body'),
}

async function deleteTask(TenantId: string, TaskId: string): DeleteTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTaskWithOptions(TenantId, TaskId, headers, runtime);
}

async function deleteTaskWithOptions(TenantId: string, TaskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTaskResponse {
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskId = OpenApiUtil.getEncodeParam(TaskId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteTask',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteTemplateResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  templateId?: string(name='TemplateId'),
}

model DeleteTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTemplateResponseBody(name='body'),
}

async function deleteTemplate(TenantId: string, TemplateId: string): DeleteTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTemplateWithOptions(TenantId, TemplateId, headers, runtime);
}

async function deleteTemplateWithOptions(TenantId: string, TemplateId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTemplateResponse {
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TemplateId = OpenApiUtil.getEncodeParam(TemplateId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteTemplate',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/templates/${TemplateId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteUserResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUser(TenantId: string, UserId: string): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteUserWithOptions(TenantId, UserId, headers, runtime);
}

async function deleteUserWithOptions(TenantId: string, UserId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteUserResponse {
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  UserId = OpenApiUtil.getEncodeParam(UserId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteUser',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/users/${UserId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ExportAnnotationsRequest {
  ossPath?: string(name='OssPath'),
  registerDataset?: string(name='RegisterDataset'),
  target?: string(name='Target'),
}

model ExportAnnotationsResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  flowJob?: FlowJobInfo(name='FlowJob'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExportAnnotationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExportAnnotationsResponseBody(name='body'),
}

async function exportAnnotations(TenantId: string, TaskId: string, request: ExportAnnotationsRequest): ExportAnnotationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return exportAnnotationsWithOptions(TenantId, TaskId, request, headers, runtime);
}

async function exportAnnotationsWithOptions(TenantId: string, TaskId: string, request: ExportAnnotationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ExportAnnotationsResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskId = OpenApiUtil.getEncodeParam(TaskId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.ossPath)) {
    query['OssPath'] = request.ossPath;
  }
  if (!Util.isUnset(request.registerDataset)) {
    query['RegisterDataset'] = request.registerDataset;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportAnnotations',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskId}/annotations/export`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetJobRequest {
  jobType?: string(name='JobType'),
}

model GetJobResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  job?: Job(name='Job'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJobResponseBody(name='body'),
}

async function getJob(TenantId: string, JobId: string, request: GetJobRequest): GetJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getJobWithOptions(TenantId, JobId, request, headers, runtime);
}

async function getJobWithOptions(TenantId: string, JobId: string, request: GetJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetJobResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  JobId = OpenApiUtil.getEncodeParam(JobId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.jobType)) {
    query['JobType'] = request.jobType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJob',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/jobs/${JobId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetSubtaskResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  subtask?: SimpleSubtask(name='Subtask'),
  success?: boolean(name='Success'),
}

model GetSubtaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSubtaskResponseBody(name='body'),
}

async function getSubtask(TenantId: string, TaskID: string, SubtaskId: string): GetSubtaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSubtaskWithOptions(TenantId, TaskID, SubtaskId, headers, runtime);
}

async function getSubtaskWithOptions(TenantId: string, TaskID: string, SubtaskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetSubtaskResponse {
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskID = OpenApiUtil.getEncodeParam(TaskID);
  SubtaskId = OpenApiUtil.getEncodeParam(SubtaskId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetSubtask',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskID}/subtasks/${SubtaskId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetSubtaskItemResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  item?: SubtaskItemDetail(name='Item'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSubtaskItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSubtaskItemResponseBody(name='body'),
}

async function getSubtaskItem(TenantId: string, TaskId: string, SubtaskId: string, ItemId: string): GetSubtaskItemResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSubtaskItemWithOptions(TenantId, TaskId, SubtaskId, ItemId, headers, runtime);
}

async function getSubtaskItemWithOptions(TenantId: string, TaskId: string, SubtaskId: string, ItemId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetSubtaskItemResponse {
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskId = OpenApiUtil.getEncodeParam(TaskId);
  SubtaskId = OpenApiUtil.getEncodeParam(SubtaskId);
  ItemId = OpenApiUtil.getEncodeParam(ItemId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetSubtaskItem',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskId}/subtasks/${SubtaskId}/items/${ItemId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTaskResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  task?: TaskDetail(name='Task'),
}

model GetTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskResponseBody(name='body'),
}

async function getTask(TenantId: string, TaskId: string): GetTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTaskWithOptions(TenantId, TaskId, headers, runtime);
}

async function getTaskWithOptions(TenantId: string, TaskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTaskResponse {
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskId = OpenApiUtil.getEncodeParam(TaskId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTask',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTaskStatisticsRequest {
  statType?: string(name='StatType'),
}

model GetTaskStatisticsResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskStatistics?: TaskStatistic(name='TaskStatistics'),
}

model GetTaskStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskStatisticsResponseBody(name='body'),
}

async function getTaskStatistics(TenantId: string, TaskId: string, request: GetTaskStatisticsRequest): GetTaskStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTaskStatisticsWithOptions(TenantId, TaskId, request, headers, runtime);
}

async function getTaskStatisticsWithOptions(TenantId: string, TaskId: string, request: GetTaskStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTaskStatisticsResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskId = OpenApiUtil.getEncodeParam(TaskId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.statType)) {
    query['StatType'] = request.statType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskStatistics',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskId}/statistics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTaskStatusResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskStatus?: string(name='TaskStatus'),
}

model GetTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskStatusResponseBody(name='body'),
}

async function getTaskStatus(TenantId: string, TaskId: string): GetTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTaskStatusWithOptions(TenantId, TaskId, headers, runtime);
}

async function getTaskStatusWithOptions(TenantId: string, TaskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTaskStatusResponse {
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskId = OpenApiUtil.getEncodeParam(TaskId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTaskStatus',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskId}/status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTaskTemplateResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  template?: TemplateDetail(name='Template'),
}

model GetTaskTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskTemplateResponseBody(name='body'),
}

async function getTaskTemplate(TenantId: string, TaskId: string): GetTaskTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTaskTemplateWithOptions(TenantId, TaskId, headers, runtime);
}

async function getTaskTemplateWithOptions(TenantId: string, TaskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTaskTemplateResponse {
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskId = OpenApiUtil.getEncodeParam(TaskId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTaskTemplate',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskId}/template`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTaskTemplateQuestionsResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  questions?: [
    QuestionPlugin
  ](name='Questions'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTaskTemplateQuestionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskTemplateQuestionsResponseBody(name='body'),
}

async function getTaskTemplateQuestions(TenantId: string, TaskId: string): GetTaskTemplateQuestionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTaskTemplateQuestionsWithOptions(TenantId, TaskId, headers, runtime);
}

async function getTaskTemplateQuestionsWithOptions(TenantId: string, TaskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTaskTemplateQuestionsResponse {
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskId = OpenApiUtil.getEncodeParam(TaskId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTaskTemplateQuestions',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskId}/template/questions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTaskTemplateViewsResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  views?: {
    viewPlugins?: [
      ViewPlugin
    ](name='ViewPlugins'),
  }(name='Views'),
}

model GetTaskTemplateViewsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskTemplateViewsResponseBody(name='body'),
}

async function getTaskTemplateViews(TenantId: string, TaskId: string): GetTaskTemplateViewsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTaskTemplateViewsWithOptions(TenantId, TaskId, headers, runtime);
}

async function getTaskTemplateViewsWithOptions(TenantId: string, TaskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTaskTemplateViewsResponse {
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskId = OpenApiUtil.getEncodeParam(TaskId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTaskTemplateViews',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskId}/template/views`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTaskWorkforceResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  workforce?: [
    Workforce
  ](name='Workforce'),
}

model GetTaskWorkforceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskWorkforceResponseBody(name='body'),
}

async function getTaskWorkforce(TenantId: string, TaskId: string): GetTaskWorkforceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTaskWorkforceWithOptions(TenantId, TaskId, headers, runtime);
}

async function getTaskWorkforceWithOptions(TenantId: string, TaskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTaskWorkforceResponse {
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskId = OpenApiUtil.getEncodeParam(TaskId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTaskWorkforce',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskId}/workforce`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTaskWorkforceStatisticRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  statType?: string(name='StatType'),
}

model GetTaskWorkforceStatisticResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
  totalPage?: int32(name='TotalPage'),
  usersStatistic?: [
    UserStatistic
  ](name='UsersStatistic'),
}

model GetTaskWorkforceStatisticResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskWorkforceStatisticResponseBody(name='body'),
}

async function getTaskWorkforceStatistic(TenantId: string, TaskId: string, request: GetTaskWorkforceStatisticRequest): GetTaskWorkforceStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTaskWorkforceStatisticWithOptions(TenantId, TaskId, request, headers, runtime);
}

async function getTaskWorkforceStatisticWithOptions(TenantId: string, TaskId: string, request: GetTaskWorkforceStatisticRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTaskWorkforceStatisticResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskId = OpenApiUtil.getEncodeParam(TaskId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.statType)) {
    query['StatType'] = request.statType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskWorkforceStatistic',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskId}/workforce/statistic`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTemplateResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  template?: TemplateDetail(name='Template'),
}

model GetTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTemplateResponseBody(name='body'),
}

async function getTemplate(TenantId: string, TemplateId: string): GetTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTemplateWithOptions(TenantId, TemplateId, headers, runtime);
}

async function getTemplateWithOptions(TenantId: string, TemplateId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTemplateResponse {
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TemplateId = OpenApiUtil.getEncodeParam(TemplateId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTemplate',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/templates/${TemplateId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTemplateQuestionsResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  questionConfigs?: [
    QuestionPlugin
  ](name='QuestionConfigs'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTemplateQuestionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTemplateQuestionsResponseBody(name='body'),
}

async function getTemplateQuestions(TenantId: string, TemplateId: string): GetTemplateQuestionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTemplateQuestionsWithOptions(TenantId, TemplateId, headers, runtime);
}

async function getTemplateQuestionsWithOptions(TenantId: string, TemplateId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTemplateQuestionsResponse {
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TemplateId = OpenApiUtil.getEncodeParam(TemplateId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTemplateQuestions',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/templates/${TemplateId}/questions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTemplateViewResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  viewConfigs?: {
    viewPlugins?: [
      ViewPlugin
    ](name='ViewPlugins'),
  }(name='ViewConfigs'),
}

model GetTemplateViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTemplateViewResponseBody(name='body'),
}

async function getTemplateView(TenantId: string, TemplateId: string): GetTemplateViewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTemplateViewWithOptions(TenantId, TemplateId, headers, runtime);
}

async function getTemplateViewWithOptions(TenantId: string, TemplateId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTemplateViewResponse {
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TemplateId = OpenApiUtil.getEncodeParam(TemplateId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTemplateView',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/templates/${TemplateId}/views`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTenantResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tenant?: SingleTenant(name='Tenant'),
}

model GetTenantResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTenantResponseBody(name='body'),
}

async function getTenant(TenantId: string): GetTenantResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTenantWithOptions(TenantId, headers, runtime);
}

async function getTenantWithOptions(TenantId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTenantResponse {
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTenant',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetUserResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  user?: SimpleUser(name='User'),
}

model GetUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserResponseBody(name='body'),
}

async function getUser(TenantId: string, UserId: string): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUserWithOptions(TenantId, UserId, headers, runtime);
}

async function getUserWithOptions(TenantId: string, UserId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetUserResponse {
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  UserId = OpenApiUtil.getEncodeParam(UserId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetUser',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/users/${UserId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListJobsRequest {
  jobType?: string(name='JobType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListJobsResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  jobs?: [
    Job
  ](name='Jobs'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
  totalPage?: int32(name='TotalPage'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobs(TenantId: string, request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listJobsWithOptions(TenantId, request, headers, runtime);
}

async function listJobsWithOptions(TenantId: string, request: ListJobsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.jobType)) {
    query['JobType'] = request.jobType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobs',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/jobs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSubtaskItemsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListSubtaskItemsResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  items?: [
    SubtaskItemDetail
  ](name='Items'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
  totalPage?: int32(name='TotalPage'),
}

model ListSubtaskItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSubtaskItemsResponseBody(name='body'),
}

async function listSubtaskItems(TenantId: string, TaskID: string, SubtaskId: string, request: ListSubtaskItemsRequest): ListSubtaskItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSubtaskItemsWithOptions(TenantId, TaskID, SubtaskId, request, headers, runtime);
}

async function listSubtaskItemsWithOptions(TenantId: string, TaskID: string, SubtaskId: string, request: ListSubtaskItemsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSubtaskItemsResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskID = OpenApiUtil.getEncodeParam(TaskID);
  SubtaskId = OpenApiUtil.getEncodeParam(SubtaskId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSubtaskItems',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskID}/subtasks/${SubtaskId}/items`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSubtasksRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListSubtasksResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  subtasks?: [
    SubtaskDetail
  ](name='Subtasks'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
  totalPage?: int32(name='TotalPage'),
}

model ListSubtasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSubtasksResponseBody(name='body'),
}

async function listSubtasks(TenantId: string, TaskID: string, request: ListSubtasksRequest): ListSubtasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSubtasksWithOptions(TenantId, TaskID, request, headers, runtime);
}

async function listSubtasksWithOptions(TenantId: string, TaskID: string, request: ListSubtasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSubtasksResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskID = OpenApiUtil.getEncodeParam(TaskID);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSubtasks',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskID}/subtasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTasksRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListTasksResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tasks?: [
    SimpleTask
  ](name='Tasks'),
  totalCount?: int32(name='TotalCount'),
  totalPage?: int32(name='TotalPage'),
}

model ListTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTasksResponseBody(name='body'),
}

async function listTasks(TenantId: string, request: ListTasksRequest): ListTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTasksWithOptions(TenantId, request, headers, runtime);
}

async function listTasksWithOptions(TenantId: string, request: ListTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTasksResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTasks',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTemplatesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  searchKey?: string(name='SearchKey'),
}

model ListTemplatesResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  templates?: [
    SimpleTemplate
  ](name='Templates'),
  totalCount?: int32(name='TotalCount'),
  totalPage?: int32(name='TotalPage'),
}

model ListTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTemplatesResponseBody(name='body'),
}

async function listTemplates(TenantId: string, request: ListTemplatesRequest): ListTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTemplatesWithOptions(TenantId, request, headers, runtime);
}

async function listTemplatesWithOptions(TenantId: string, request: ListTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTemplatesResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchKey)) {
    query['SearchKey'] = request.searchKey;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTemplates',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/templates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTenantsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListTenantsResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tenants?: [
    SimpleTenant
  ](name='Tenants'),
  totalCount?: int32(name='TotalCount'),
  totalPage?: int32(name='TotalPage'),
}

model ListTenantsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTenantsResponseBody(name='body'),
}

async function listTenants(request: ListTenantsRequest): ListTenantsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTenantsWithOptions(request, headers, runtime);
}

async function listTenantsWithOptions(request: ListTenantsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTenantsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTenants',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListUsersRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListUsersResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
  totalPage?: int32(name='TotalPage'),
  users?: [
    SimpleUser
  ](name='Users'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsers(TenantId: string, request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUsersWithOptions(TenantId, request, headers, runtime);
}

async function listUsersWithOptions(TenantId: string, request: ListUsersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUsers',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/users`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RemoveWorkNodeWorkforceRequest {
  userIds?: [ long ](name='UserIds'),
}

model RemoveWorkNodeWorkforceResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RemoveWorkNodeWorkforceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveWorkNodeWorkforceResponseBody(name='body'),
}

async function removeWorkNodeWorkforce(TenantId: string, TaskId: string, WorkNodeId: string, request: RemoveWorkNodeWorkforceRequest): RemoveWorkNodeWorkforceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeWorkNodeWorkforceWithOptions(TenantId, TaskId, WorkNodeId, request, headers, runtime);
}

async function removeWorkNodeWorkforceWithOptions(TenantId: string, TaskId: string, WorkNodeId: string, request: RemoveWorkNodeWorkforceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveWorkNodeWorkforceResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskId = OpenApiUtil.getEncodeParam(TaskId);
  WorkNodeId = OpenApiUtil.getEncodeParam(WorkNodeId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.userIds)) {
    body['UserIds'] = request.userIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveWorkNodeWorkforce',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskId}/worknodes/${WorkNodeId}/workforce`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateTaskRequest {
  body?: UpdateTaskDTO(name='body'),
}

model UpdateTaskResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTaskResponseBody(name='body'),
}

async function updateTask(TenantId: string, TaskId: string, request: UpdateTaskRequest): UpdateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTaskWithOptions(TenantId, TaskId, request, headers, runtime);
}

async function updateTaskWithOptions(TenantId: string, TaskId: string, request: UpdateTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTaskResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskId = OpenApiUtil.getEncodeParam(TaskId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTask',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateTaskWorkforceRequest {
  workforce?: [
    SimpleWorkforce
  ](name='Workforce'),
}

model UpdateTaskWorkforceResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateTaskWorkforceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTaskWorkforceResponseBody(name='body'),
}

async function updateTaskWorkforce(TenantId: string, TaskId: string, request: UpdateTaskWorkforceRequest): UpdateTaskWorkforceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTaskWorkforceWithOptions(TenantId, TaskId, request, headers, runtime);
}

async function updateTaskWorkforceWithOptions(TenantId: string, TaskId: string, request: UpdateTaskWorkforceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTaskWorkforceResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TaskId = OpenApiUtil.getEncodeParam(TaskId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.workforce)) {
    body['Workforce'] = request.workforce;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTaskWorkforce',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/tasks/${TaskId}/workforce`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateTemplateRequest {
  body?: TemplateDTO(name='body'),
}

model UpdateTemplateResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  templateId?: string(name='TemplateId'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTemplateResponseBody(name='body'),
}

async function updateTemplate(TenantId: string, TemplateId: string, request: UpdateTemplateRequest): UpdateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTemplateWithOptions(TenantId, TemplateId, request, headers, runtime);
}

async function updateTemplateWithOptions(TenantId: string, TemplateId: string, request: UpdateTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTemplateResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  TemplateId = OpenApiUtil.getEncodeParam(TemplateId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTemplate',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/templates/${TemplateId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateTenantRequest {
  description?: string(name='Description'),
  tenantName?: string(name='TenantName'),
}

model UpdateTenantResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateTenantResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTenantResponseBody(name='body'),
}

async function updateTenant(TenantId: string, request: UpdateTenantRequest): UpdateTenantResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTenantWithOptions(TenantId, request, headers, runtime);
}

async function updateTenantWithOptions(TenantId: string, request: UpdateTenantRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTenantResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.tenantName)) {
    body['TenantName'] = request.tenantName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTenant',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateUserRequest {
  role?: string(name='Role'),
  userName?: string(name='UserName'),
}

model UpdateUserResponseBody = {
  code?: int32(name='Code'),
  details?: string(name='Details'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  userId?: string(name='UserId'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateUserResponseBody(name='body'),
}

async function updateUser(TenantId: string, UserId: string, request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateUserWithOptions(TenantId, UserId, request, headers, runtime);
}

async function updateUserWithOptions(TenantId: string, UserId: string, request: UpdateUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  TenantId = OpenApiUtil.getEncodeParam(TenantId);
  UserId = OpenApiUtil.getEncodeParam(UserId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.role)) {
    body['Role'] = request.role;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUser',
    version = '2022-06-16',
    protocol = 'HTTPS',
    pathname = `/openapi/api/v1/tenants/${TenantId}/users/${UserId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

