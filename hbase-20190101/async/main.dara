/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'HBase';
  @version = '2019-01-01';
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'hbase.aliyuncs.com',
    ap-southeast-1 = 'hbase.aliyuncs.com',
    cn-beijing = 'hbase.aliyuncs.com',
    cn-beijing-finance-1 = 'hbase.aliyuncs.com',
    cn-beijing-finance-pop = 'hbase.aliyuncs.com',
    cn-beijing-gov-1 = 'hbase.aliyuncs.com',
    cn-beijing-nu16-b01 = 'hbase.aliyuncs.com',
    cn-edge-1 = 'hbase.aliyuncs.com',
    cn-fujian = 'hbase.aliyuncs.com',
    cn-haidian-cm12-c01 = 'hbase.aliyuncs.com',
    cn-hangzhou = 'hbase.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'hbase.aliyuncs.com',
    cn-hangzhou-finance = 'hbase.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'hbase.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'hbase.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'hbase.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'hbase.aliyuncs.com',
    cn-hangzhou-test-306 = 'hbase.aliyuncs.com',
    cn-hongkong = 'hbase.aliyuncs.com',
    cn-hongkong-finance-pop = 'hbase.aliyuncs.com',
    cn-north-2-gov-1 = 'hbase.aliyuncs.com',
    cn-qingdao = 'hbase.aliyuncs.com',
    cn-qingdao-nebula = 'hbase.aliyuncs.com',
    cn-shanghai = 'hbase.aliyuncs.com',
    cn-shanghai-et15-b01 = 'hbase.aliyuncs.com',
    cn-shanghai-et2-b01 = 'hbase.aliyuncs.com',
    cn-shanghai-finance-1 = 'hbase.aliyuncs.com',
    cn-shanghai-inner = 'hbase.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'hbase.aliyuncs.com',
    cn-shenzhen = 'hbase.aliyuncs.com',
    cn-shenzhen-finance-1 = 'hbase.aliyuncs.com',
    cn-shenzhen-inner = 'hbase.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'hbase.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'hbase.aliyuncs.com',
    cn-wuhan = 'hbase.aliyuncs.com',
    cn-yushanfang = 'hbase.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'hbase.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'hbase.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'hbase.aliyuncs.com',
    eu-west-1-oxs = 'hbase.ap-northeast-1.aliyuncs.com',
    rus-west-1-pop = 'hbase.ap-northeast-1.aliyuncs.com',
    us-east-1 = 'hbase.aliyuncs.com',
    us-west-1 = 'hbase.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model AddUserHdfsInfoRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  extInfo: string(name='ExtInfo', position='Query'),
}

model AddUserHdfsInfoResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddUserHdfsInfoResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserHdfsInfoResponseBody(name='body'),
}

async function addUserHdfsInfo(request: AddUserHdfsInfoRequest): AddUserHdfsInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddUserHdfsInfo', 'POST', '/', 'json', false, 'json', request);
}

model AllocatePublicNetworkAddressRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
}

model AllocatePublicNetworkAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model AllocatePublicNetworkAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AllocatePublicNetworkAddressResponseBody(name='body'),
}

async function allocatePublicNetworkAddress(request: AllocatePublicNetworkAddressRequest): AllocatePublicNetworkAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocatePublicNetworkAddress', 'POST', '/', 'json', false, 'json', request);
}

model CheckComponentsVersionRequest {
  clusterId: string(name='ClusterId', position='Query'),
  components: string(name='Components', position='Query'),
}

model CheckComponentsVersionResponseBody = {
  components?: {
    component?: [ 
    {
      component?: string(name='Component'),
      isLatestVersion?: string(name='IsLatestVersion'),
    }
  ](name='Component')
  }(name='Components'),
  requestId?: string(name='RequestId'),
}

model CheckComponentsVersionResponse = {
  headers: map[string]string(name='headers'),
  body: CheckComponentsVersionResponseBody(name='body'),
}

async function checkComponentsVersion(request: CheckComponentsVersionRequest): CheckComponentsVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckComponentsVersion', 'POST', '/', 'json', false, 'json', request);
}

model CloseBackupRequest {
  clusterId: string(name='ClusterId', position='Query'),
}

model CloseBackupResponseBody = {
  requestId?: string(name='RequestId'),
}

model CloseBackupResponse = {
  headers: map[string]string(name='headers'),
  body: CloseBackupResponseBody(name='body'),
}

async function closeBackup(request: CloseBackupRequest): CloseBackupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CloseBackup', 'POST', '/', 'json', false, 'json', request);
}

model ConvertInstanceRequest {
  clusterId: string(name='ClusterId', position='Query'),
  duration?: int32(name='Duration', position='Query'),
  payType?: string(name='PayType', position='Query'),
  pricingCycle?: string(name='PricingCycle', position='Query'),
}

model ConvertInstanceResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ConvertInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ConvertInstanceResponseBody(name='body'),
}

async function convertInstance(request: ConvertInstanceRequest): ConvertInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConvertInstance', 'POST', '/', 'json', false, 'json', request);
}

model CreateBackupPlanRequest {
  clusterId: string(name='ClusterId', position='Query'),
}

model CreateBackupPlanResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBackupPlanResponseBody(name='body'),
}

async function createBackupPlan(request: CreateBackupPlanRequest): CreateBackupPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBackupPlan', 'POST', '/', 'json', false, 'json', request);
}

model CreateClusterRequest {
  autoRenewPeriod?: int32(name='AutoRenewPeriod', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  clusterName?: string(name='ClusterName', position='Query'),
  coldStorageSize?: int32(name='ColdStorageSize', position='Query'),
  coreInstanceType: string(name='CoreInstanceType', position='Query'),
  diskSize?: int32(name='DiskSize', position='Query'),
  diskType?: string(name='DiskType', position='Query'),
  encryptionKey?: string(name='EncryptionKey', position='Query'),
  engine: string(name='Engine', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  masterInstanceType?: string(name='MasterInstanceType', position='Query'),
  nodeCount: int32(name='NodeCount', position='Query'),
  payType: string(name='PayType', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  securityIPList?: string(name='SecurityIPList', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model CreateClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterResponseBody(name='body'),
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCluster', 'POST', '/', 'json', false, 'json', request);
}

model CreateGlobalResourceRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  resourceName: string(name='ResourceName', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
}

model CreateGlobalResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateGlobalResourceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGlobalResourceResponseBody(name='body'),
}

async function createGlobalResource(request: CreateGlobalResourceRequest): CreateGlobalResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGlobalResource', 'POST', '/', 'json', false, 'json', request);
}

model CreateHBaseSlbServerRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  slbServer: string(name='SlbServer', position='Query'),
}

model CreateHBaseSlbServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateHBaseSlbServerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHBaseSlbServerResponseBody(name='body'),
}

async function createHBaseSlbServer(request: CreateHBaseSlbServerRequest): CreateHBaseSlbServerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateHBaseSlbServer', 'POST', '/', 'json', false, 'json', request);
}

model CreateHbaseHaSlbRequest {
  bdsId: string(name='BdsId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  haId: string(name='HaId', position='Query'),
  haTypes: string(name='HaTypes', position='Query'),
  hbaseType: string(name='HbaseType', position='Query'),
}

model CreateHbaseHaSlbResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateHbaseHaSlbResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHbaseHaSlbResponseBody(name='body'),
}

async function createHbaseHaSlb(request: CreateHbaseHaSlbRequest): CreateHbaseHaSlbResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateHbaseHaSlb', 'POST', '/', 'json', false, 'json', request);
}

model CreateMultiZoneClusterRequest {
  arbiterVSwitchId: string(name='ArbiterVSwitchId', position='Query'),
  arbiterZoneId: string(name='ArbiterZoneId', position='Query'),
  archVersion: string(name='ArchVersion', position='Query'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  clusterName?: string(name='ClusterName', position='Query'),
  coreDiskSize: int32(name='CoreDiskSize', position='Query'),
  coreDiskType: string(name='CoreDiskType', position='Query'),
  coreInstanceType: string(name='CoreInstanceType', position='Query'),
  coreNodeCount: int32(name='CoreNodeCount', position='Query'),
  engine: string(name='Engine', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  logDiskSize: int32(name='LogDiskSize', position='Query'),
  logDiskType: string(name='LogDiskType', position='Query'),
  logInstanceType: string(name='LogInstanceType', position='Query'),
  logNodeCount: int32(name='LogNodeCount', position='Query'),
  masterInstanceType: string(name='MasterInstanceType', position='Query'),
  multiZoneCombination: string(name='MultiZoneCombination', position='Query'),
  payType: string(name='PayType', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  primaryVSwitchId: string(name='PrimaryVSwitchId', position='Query'),
  primaryZoneId: string(name='PrimaryZoneId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  securityIPList?: string(name='SecurityIPList', position='Query'),
  standbyVSwitchId: string(name='StandbyVSwitchId', position='Query'),
  standbyZoneId: string(name='StandbyZoneId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model CreateMultiZoneClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateMultiZoneClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMultiZoneClusterResponseBody(name='body'),
}

async function createMultiZoneCluster(request: CreateMultiZoneClusterRequest): CreateMultiZoneClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMultiZoneCluster', 'POST', '/', 'json', false, 'json', request);
}

model CreateRestorePlanRequest {
  clusterId: string(name='ClusterId', position='Query'),
  restoreAllTable: boolean(name='RestoreAllTable', position='Query'),
  restoreByCopy: boolean(name='RestoreByCopy', position='Query'),
  restoreToDate: string(name='RestoreToDate', position='Query'),
  tables?: string(name='Tables', position='Query'),
  targetClusterId: string(name='TargetClusterId', position='Query'),
}

model CreateRestorePlanResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateRestorePlanResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRestorePlanResponseBody(name='body'),
}

async function createRestorePlan(request: CreateRestorePlanRequest): CreateRestorePlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRestorePlan', 'POST', '/', 'json', false, 'json', request);
}

model CreateServerlessClusterRequest {
  autoRenewPeriod?: int32(name='AutoRenewPeriod', minimum=0, maximum=36, position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  clientType?: string(name='ClientType', position='Query'),
  clusterName?: string(name='ClusterName', position='Query'),
  diskType?: string(name='DiskType', position='Query'),
  engine?: string(name='Engine', position='Query'),
  engineVersion?: string(name='EngineVersion', position='Query'),
  payType: string(name='PayType', position='Query'),
  period?: int32(name='Period', minimum=0, maximum=60, position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  serverlessCapability?: int32(name='ServerlessCapability', minimum=50, maximum=20000, position='Query'),
  serverlessSpec?: string(name='ServerlessSpec', position='Query'),
  serverlessStorage?: int32(name='ServerlessStorage', minimum=10, maximum=20000, position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model CreateServerlessClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  orderId?: string(name='OrderId'),
  passWord?: string(name='PassWord'),
  requestId?: string(name='RequestId'),
}

model CreateServerlessClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServerlessClusterResponseBody(name='body'),
}

async function createServerlessCluster(request: CreateServerlessClusterRequest): CreateServerlessClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateServerlessCluster', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGlobalResourceRequest {
  clusterId: string(name='ClusterId', position='Query'),
  resourceName: string(name='ResourceName', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
}

model DeleteGlobalResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGlobalResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGlobalResourceResponseBody(name='body'),
}

async function deleteGlobalResource(request: DeleteGlobalResourceRequest): DeleteGlobalResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGlobalResource', 'POST', '/', 'json', false, 'json', request);
}

model DeleteHBaseHaDBRequest {
  bdsId: string(name='BdsId', position='Query'),
  haId: string(name='HaId', position='Query'),
}

model DeleteHBaseHaDBResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHBaseHaDBResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteHBaseHaDBResponseBody(name='body'),
}

async function deleteHBaseHaDB(request: DeleteHBaseHaDBRequest): DeleteHBaseHaDBResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteHBaseHaDB', 'POST', '/', 'json', false, 'json', request);
}

model DeleteHBaseSlbServerRequest {
  clusterId: string(name='ClusterId', position='Query'),
  slbServer: string(name='SlbServer', position='Query'),
}

model DeleteHBaseSlbServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHBaseSlbServerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteHBaseSlbServerResponseBody(name='body'),
}

async function deleteHBaseSlbServer(request: DeleteHBaseSlbServerRequest): DeleteHBaseSlbServerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteHBaseSlbServer', 'POST', '/', 'json', false, 'json', request);
}

model DeleteHbaseHaSlbRequest {
  bdsId: string(name='BdsId', position='Query'),
  haId: string(name='HaId', position='Query'),
  haTypes: string(name='HaTypes', position='Query'),
}

model DeleteHbaseHaSlbResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHbaseHaSlbResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteHbaseHaSlbResponseBody(name='body'),
}

async function deleteHbaseHaSlb(request: DeleteHbaseHaSlbRequest): DeleteHbaseHaSlbResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteHbaseHaSlb', 'POST', '/', 'json', false, 'json', request);
}

model DeleteInstanceRequest {
  clusterId: string(name='ClusterId', position='Query'),
  immediateDeleteFlag?: boolean(name='ImmediateDeleteFlag', position='Query'),
}

model DeleteInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstance(request: DeleteInstanceRequest): DeleteInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteInstance', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMultiZoneClusterRequest {
  clusterId: string(name='ClusterId', position='Query'),
  immediateDeleteFlag?: boolean(name='ImmediateDeleteFlag', position='Query'),
}

model DeleteMultiZoneClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMultiZoneClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMultiZoneClusterResponseBody(name='body'),
}

async function deleteMultiZoneCluster(request: DeleteMultiZoneClusterRequest): DeleteMultiZoneClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMultiZoneCluster', 'POST', '/', 'json', false, 'json', request);
}

model DeleteServerlessClusterRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model DeleteServerlessClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteServerlessClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteServerlessClusterResponseBody(name='body'),
}

async function deleteServerlessCluster(request: DeleteServerlessClusterRequest): DeleteServerlessClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteServerlessCluster', 'POST', '/', 'json', false, 'json', request);
}

model DeleteUserHdfsInfoRequest {
  clusterId: string(name='ClusterId', position='Query'),
  nameService: string(name='NameService', position='Query'),
}

model DeleteUserHdfsInfoResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUserHdfsInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserHdfsInfoResponseBody(name='body'),
}

async function deleteUserHdfsInfo(request: DeleteUserHdfsInfoRequest): DeleteUserHdfsInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteUserHdfsInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAvailableResourceRequest {
  chargeType: string(name='ChargeType', position='Query'),
  coreInstanceType?: string(name='CoreInstanceType', position='Query'),
  diskType?: string(name='DiskType', position='Query'),
  engine?: string(name='Engine', position='Query'),
  engineVersion?: string(name='EngineVersion', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeAvailableResourceResponseBody = {
  availableZones?: {
    availableZone?: [ 
    {
      masterResources?: {
        masterResource?: [ 
        {
          instanceType?: string(name='InstanceType'),
          instanceTypeDetail?: {
            cpu?: int32(name='Cpu'),
            mem?: int32(name='Mem'),
          }(name='InstanceTypeDetail'),
        }
      ](name='MasterResource')
      }(name='MasterResources'),
      regionId?: string(name='RegionId'),
      supportedEngines?: {
        supportedEngine?: [ 
        {
          engine?: string(name='Engine'),
          supportedEngineVersions?: {
            supportedEngineVersion?: [ 
            {
              supportedCategories?: {
                supportedCategories?: [ 
                {
                  category?: string(name='Category'),
                  supportedStorageTypes?: {
                    supportedStorageType?: [ 
                    {
                      coreResources?: {
                        coreResource?: [ 
                        {
                          DBInstanceStorageRange?: {
                            maxSize?: int32(name='MaxSize'),
                            minSize?: int32(name='MinSize'),
                            stepSize?: int32(name='StepSize'),
                          }(name='DBInstanceStorageRange'),
                          instanceType?: string(name='InstanceType'),
                          instanceTypeDetail?: {
                            cpu?: int32(name='Cpu'),
                            mem?: int32(name='Mem'),
                          }(name='InstanceTypeDetail'),
                          maxCoreCount?: int32(name='MaxCoreCount'),
                        }
                      ](name='CoreResource')
                      }(name='CoreResources'),
                      storageType?: string(name='StorageType'),
                    }
                  ](name='SupportedStorageType')
                  }(name='SupportedStorageTypes'),
                }
              ](name='SupportedCategories')
              }(name='SupportedCategories'),
              version?: string(name='Version'),
            }
          ](name='SupportedEngineVersion')
          }(name='SupportedEngineVersions'),
        }
      ](name='SupportedEngine')
      }(name='SupportedEngines'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='AvailableZone')
  }(name='AvailableZones'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableResourceResponseBody(name='body'),
}

async function describeAvailableResource(request: DescribeAvailableResourceRequest): DescribeAvailableResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableResource', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupPlanConfigRequest {
  clusterId: string(name='ClusterId', position='Query'),
}

model DescribeBackupPlanConfigResponseBody = {
  fullBackupCycle?: int32(name='FullBackupCycle'),
  minHFileBackupCount?: int32(name='MinHFileBackupCount'),
  nextFullBackupDate?: string(name='NextFullBackupDate'),
  requestId?: string(name='RequestId'),
  tables?: {
    table?: [ string ](name='Table')
  }(name='Tables'),
}

model DescribeBackupPlanConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBackupPlanConfigResponseBody(name='body'),
}

async function describeBackupPlanConfig(request: DescribeBackupPlanConfigRequest): DescribeBackupPlanConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupPlanConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupPolicyRequest {
  clusterId: string(name='ClusterId', position='Query'),
}

model DescribeBackupPolicyResponseBody = {
  backupRetentionPeriod?: string(name='BackupRetentionPeriod'),
  preferredBackupEndTimeUTC?: string(name='PreferredBackupEndTimeUTC'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod'),
  preferredBackupStartTimeUTC?: string(name='PreferredBackupStartTimeUTC'),
  preferredBackupTime?: string(name='PreferredBackupTime'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBackupPolicyResponseBody(name='body'),
}

async function describeBackupPolicy(request: DescribeBackupPolicyRequest): DescribeBackupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupPolicy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupStatusRequest {
  clusterId: string(name='ClusterId', position='Query'),
}

model DescribeBackupStatusResponseBody = {
  backupStatus?: string(name='BackupStatus'),
  bdsClusterId?: string(name='BdsClusterId'),
  clusterId?: string(name='ClusterId'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBackupStatusResponseBody(name='body'),
}

async function describeBackupStatus(request: DescribeBackupStatusRequest): DescribeBackupStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupSummaryRequest {
  clusterId: string(name='ClusterId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model DescribeBackupSummaryResponseBody = {
  full?: {
    hasMore?: string(name='HasMore'),
    nextFullBackupDate?: string(name='NextFullBackupDate'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    records?: {
      record?: [ 
      {
        createTime?: string(name='CreateTime'),
        dataSize?: string(name='DataSize'),
        finishTime?: string(name='FinishTime'),
        process?: string(name='Process'),
        recordId?: string(name='RecordId'),
        speed?: string(name='Speed'),
        status?: string(name='Status'),
      }
    ](name='Record')
    }(name='Records'),
    total?: int32(name='Total'),
  }(name='Full'),
  incr?: {
    backupLogSize?: string(name='BackupLogSize'),
    pos?: string(name='Pos'),
    queueLogNum?: string(name='QueueLogNum'),
    runningLogNum?: string(name='RunningLogNum'),
    speed?: string(name='Speed'),
    status?: string(name='Status'),
  }(name='Incr'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupSummaryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBackupSummaryResponseBody(name='body'),
}

async function describeBackupSummary(request: DescribeBackupSummaryRequest): DescribeBackupSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupTablesRequest {
  backupRecordId: string(name='BackupRecordId', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model DescribeBackupTablesResponseBody = {
  backupRecords?: {
    backupRecord?: [ 
    {
      dataSize?: string(name='DataSize'),
      endTime?: string(name='EndTime'),
      message?: string(name='Message'),
      process?: string(name='Process'),
      speed?: string(name='Speed'),
      startTime?: string(name='StartTime'),
      state?: string(name='State'),
      table?: string(name='Table'),
    }
  ](name='BackupRecord')
  }(name='BackupRecords'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  tables?: {
    table?: [ string ](name='Table')
  }(name='Tables'),
  total?: long(name='Total'),
}

model DescribeBackupTablesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBackupTablesResponseBody(name='body'),
}

async function describeBackupTables(request: DescribeBackupTablesRequest): DescribeBackupTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupTables', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupsRequest {
  backupId?: string(name='BackupId', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  endTimeUTC?: string(name='EndTimeUTC', position='Query'),
  pageNumber?: string(name='PageNumber', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  startTimeUTC?: string(name='StartTimeUTC', position='Query'),
}

model DescribeBackupsResponseBody = {
  backups?: {
    backup?: [ 
    {
      backupDBNames?: string(name='BackupDBNames'),
      backupDownloadURL?: string(name='BackupDownloadURL'),
      backupEndTime?: string(name='BackupEndTime'),
      backupEndTimeUTC?: string(name='BackupEndTimeUTC'),
      backupId?: int32(name='BackupId'),
      backupMethod?: string(name='BackupMethod'),
      backupMode?: string(name='BackupMode'),
      backupSize?: string(name='BackupSize'),
      backupStartTime?: string(name='BackupStartTime'),
      backupStartTimeUTC?: string(name='BackupStartTimeUTC'),
      backupStatus?: string(name='BackupStatus'),
      backupType?: string(name='BackupType'),
    }
  ](name='Backup')
  }(name='Backups'),
  enableStatus?: string(name='EnableStatus'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBackupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBackupsResponseBody(name='body'),
}

async function describeBackups(request: DescribeBackupsRequest): DescribeBackupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterConnectionRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeClusterConnectionResponseBody = {
  dbType?: string(name='DbType'),
  isMultimod?: string(name='IsMultimod'),
  netType?: string(name='NetType'),
  requestId?: string(name='RequestId'),
  serviceConnAddrs?: {
    serviceConnAddr?: [ 
    {
      connAddrInfo?: {
        connAddr?: string(name='ConnAddr'),
        connAddrPort?: string(name='ConnAddrPort'),
        netType?: string(name='NetType'),
      }(name='ConnAddrInfo'),
      connType?: string(name='ConnType'),
    }
  ](name='ServiceConnAddr')
  }(name='ServiceConnAddrs'),
  slbConnAddrs?: {
    slbConnAddr?: [ 
    {
      connAddrInfo?: {
        connAddr?: string(name='ConnAddr'),
        connAddrPort?: string(name='ConnAddrPort'),
        netType?: string(name='NetType'),
      }(name='ConnAddrInfo'),
      slbType?: string(name='SlbType'),
    }
  ](name='SlbConnAddr')
  }(name='SlbConnAddrs'),
  thriftConn?: {
    connAddr?: string(name='ConnAddr'),
    connAddrPort?: string(name='ConnAddrPort'),
    netType?: string(name='NetType'),
  }(name='ThriftConn'),
  uiProxyConnAddrInfo?: {
    connAddr?: string(name='ConnAddr'),
    connAddrPort?: string(name='ConnAddrPort'),
    netType?: string(name='NetType'),
  }(name='UiProxyConnAddrInfo'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zkConnAddrs?: {
    zkConnAddr?: [ 
    {
      connAddr?: string(name='ConnAddr'),
      connAddrPort?: string(name='ConnAddrPort'),
      netType?: string(name='NetType'),
    }
  ](name='ZkConnAddr')
  }(name='ZkConnAddrs'),
}

model DescribeClusterConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterConnectionResponseBody(name='body'),
}

async function describeClusterConnection(request: DescribeClusterConnectionRequest): DescribeClusterConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterConnection', 'POST', '/', 'json', false, 'json', request);
}

model DescribeColdStorageRequest {
  clusterId: string(name='ClusterId', position='Query'),
}

model DescribeColdStorageResponseBody = {
  clusterId?: string(name='ClusterId'),
  coldStorageSize?: string(name='ColdStorageSize'),
  coldStorageType?: string(name='ColdStorageType'),
  coldStorageUseAmount?: string(name='ColdStorageUseAmount'),
  coldStorageUsePercent?: string(name='ColdStorageUsePercent'),
  openStatus?: string(name='OpenStatus'),
  payType?: string(name='PayType'),
  requestId?: string(name='RequestId'),
}

model DescribeColdStorageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeColdStorageResponseBody(name='body'),
}

async function describeColdStorage(request: DescribeColdStorageRequest): DescribeColdStorageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeColdStorage', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceUsageRequest {
  clusterId: string(name='ClusterId', position='Query'),
}

model DescribeDBInstanceUsageResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DescribeDBInstanceUsageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceUsageResponseBody(name='body'),
}

async function describeDBInstanceUsage(request: DescribeDBInstanceUsageRequest): DescribeDBInstanceUsageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceUsage', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDeletedInstancesRequest {
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeDeletedInstancesResponseBody = {
  instances?: {
    instance?: [ 
    {
      clusterType?: string(name='ClusterType'),
      createdTime?: string(name='CreatedTime'),
      deleteTime?: string(name='DeleteTime'),
      engine?: string(name='Engine'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      majorVersion?: string(name='MajorVersion'),
      moduleStackVersion?: string(name='ModuleStackVersion'),
      parentId?: string(name='ParentId'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Instance')
  }(name='Instances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDeletedInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDeletedInstancesResponseBody(name='body'),
}

async function describeDeletedInstances(request: DescribeDeletedInstancesRequest): DescribeDeletedInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDeletedInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDiskWarningLineRequest {
  clusterId: string(name='ClusterId', position='Query'),
}

model DescribeDiskWarningLineResponseBody = {
  requestId?: string(name='RequestId'),
  warningLine?: string(name='WarningLine'),
}

model DescribeDiskWarningLineResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDiskWarningLineResponseBody(name='body'),
}

async function describeDiskWarningLine(request: DescribeDiskWarningLineRequest): DescribeDiskWarningLineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDiskWarningLine', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEndpointsRequest {
  clusterId: string(name='ClusterId', position='Query'),
}

model DescribeEndpointsResponseBody = {
  connAddrs?: {
    connAddrInfo?: [ 
    {
      connAddr?: string(name='ConnAddr'),
      connAddrPort?: string(name='ConnAddrPort'),
      connType?: string(name='ConnType'),
      netType?: string(name='NetType'),
    }
  ](name='ConnAddrInfo')
  }(name='ConnAddrs'),
  engine?: string(name='Engine'),
  netType?: string(name='NetType'),
  requestId?: string(name='RequestId'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model DescribeEndpointsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEndpointsResponseBody(name='body'),
}

async function describeEndpoints(request: DescribeEndpointsRequest): DescribeEndpointsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEndpoints', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceRequest {
  clusterId: string(name='ClusterId', position='Query'),
}

model DescribeInstanceResponseBody = {
  autoRenewal?: boolean(name='AutoRenewal'),
  backupStatus?: string(name='BackupStatus'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  clusterType?: string(name='ClusterType'),
  coldStorageSize?: int32(name='ColdStorageSize'),
  coldStorageStatus?: string(name='ColdStorageStatus'),
  confirmMaintainTime?: string(name='ConfirmMaintainTime'),
  coreDiskCount?: string(name='CoreDiskCount'),
  coreDiskSize?: int32(name='CoreDiskSize'),
  coreDiskType?: string(name='CoreDiskType'),
  coreInstanceType?: string(name='CoreInstanceType'),
  coreNodeCount?: int32(name='CoreNodeCount'),
  createdTime?: string(name='CreatedTime'),
  createdTimeUTC?: string(name='CreatedTimeUTC'),
  duration?: int32(name='Duration'),
  encryptionKey?: string(name='EncryptionKey'),
  encryptionType?: string(name='EncryptionType'),
  engine?: string(name='Engine'),
  expireTime?: string(name='ExpireTime'),
  expireTimeUTC?: string(name='ExpireTimeUTC'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  isDeletionProtection?: boolean(name='IsDeletionProtection'),
  isHa?: boolean(name='IsHa'),
  isLatestVersion?: boolean(name='IsLatestVersion'),
  isMultiModel?: boolean(name='IsMultiModel'),
  maintainEndTime?: string(name='MaintainEndTime'),
  maintainStartTime?: string(name='MaintainStartTime'),
  majorVersion?: string(name='MajorVersion'),
  masterDiskSize?: int32(name='MasterDiskSize'),
  masterDiskType?: string(name='MasterDiskType'),
  masterInstanceType?: string(name='MasterInstanceType'),
  masterNodeCount?: int32(name='MasterNodeCount'),
  minorVersion?: string(name='MinorVersion'),
  moduleId?: int32(name='ModuleId'),
  moduleStackVersion?: string(name='ModuleStackVersion'),
  needUpgrade?: boolean(name='NeedUpgrade'),
  needUpgradeComps?: {
    comps?: [ string ](name='Comps')
  }(name='NeedUpgradeComps'),
  networkType?: string(name='NetworkType'),
  parentId?: string(name='ParentId'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  status?: string(name='Status'),
  tags?: {
    tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag')
  }(name='Tags'),
  taskProgress?: string(name='TaskProgress'),
  vpcId?: string(name='VpcId'),
  vswitchId?: string(name='VswitchId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceResponseBody(name='body'),
}

async function describeInstance(request: DescribeInstanceRequest): DescribeInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceTypeRequest {
  instanceType?: string(name='InstanceType', position='Query'),
}

model DescribeInstanceTypeResponseBody = {
  instanceTypeSpecList?: {
    instanceTypeSpec?: [ 
    {
      cpuSize?: long(name='CpuSize'),
      instanceType?: string(name='InstanceType'),
      memSize?: long(name='MemSize'),
    }
  ](name='InstanceTypeSpec')
  }(name='InstanceTypeSpecList'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceTypeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceTypeResponseBody(name='body'),
}

async function describeInstanceType(request: DescribeInstanceTypeRequest): DescribeInstanceTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceType', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstancesRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  clusterName?: string(name='ClusterName', position='Query'),
  dbType?: string(name='DbType', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeInstancesResponseBody = {
  instances?: {
    instance?: [ 
    {
      autoRenewal?: boolean(name='AutoRenewal'),
      backupStatus?: string(name='BackupStatus'),
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      coldStorageStatus?: string(name='ColdStorageStatus'),
      coreDiskCount?: string(name='CoreDiskCount'),
      coreDiskSize?: int32(name='CoreDiskSize'),
      coreDiskType?: string(name='CoreDiskType'),
      coreInstanceType?: string(name='CoreInstanceType'),
      coreNodeCount?: int32(name='CoreNodeCount'),
      createdTime?: string(name='CreatedTime'),
      createdTimeUTC?: string(name='CreatedTimeUTC'),
      duration?: int32(name='Duration'),
      engine?: string(name='Engine'),
      expireTime?: string(name='ExpireTime'),
      expireTimeUTC?: string(name='ExpireTimeUTC'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isDeletionProtection?: boolean(name='IsDeletionProtection'),
      isHa?: boolean(name='IsHa'),
      majorVersion?: string(name='MajorVersion'),
      masterDiskSize?: int32(name='MasterDiskSize'),
      masterDiskType?: string(name='MasterDiskType'),
      masterInstanceType?: string(name='MasterInstanceType'),
      masterNodeCount?: int32(name='MasterNodeCount'),
      moduleId?: int32(name='ModuleId'),
      moduleStackVersion?: string(name='ModuleStackVersion'),
      networkType?: string(name='NetworkType'),
      parentId?: string(name='ParentId'),
      payType?: string(name='PayType'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vpcId?: string(name='VpcId'),
      vswitchId?: string(name='VswitchId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Instance')
  }(name='Instances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstancesResponseBody(name='body'),
}

async function describeInstances(request: DescribeInstancesRequest): DescribeInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIpWhitelistRequest {
  clusterId: string(name='ClusterId', position='Query'),
}

model DescribeIpWhitelistResponseBody = {
  groups?: {
    group?: [ 
    {
      groupName?: string(name='GroupName'),
      ipList?: {
        ip?: [ string ](name='Ip')
      }(name='IpList'),
      ipVersion?: int32(name='IpVersion'),
    }
  ](name='Group')
  }(name='Groups'),
  requestId?: string(name='RequestId'),
}

model DescribeIpWhitelistResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIpWhitelistResponseBody(name='body'),
}

async function describeIpWhitelist(request: DescribeIpWhitelistRequest): DescribeIpWhitelistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIpWhitelist', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMultiZoneAvailableRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
}

model DescribeMultiZoneAvailableRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      availableCombines?: {
        availableCombine?: [ 
        {
          id?: string(name='Id'),
          zones?: {
            zone?: [ string ](name='Zone')
          }(name='Zones'),
        }
      ](name='AvailableCombine')
      }(name='AvailableCombines'),
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeMultiZoneAvailableRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMultiZoneAvailableRegionsResponseBody(name='body'),
}

async function describeMultiZoneAvailableRegions(request: DescribeMultiZoneAvailableRegionsRequest): DescribeMultiZoneAvailableRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMultiZoneAvailableRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMultiZoneAvailableResourceRequest {
  chargeType: string(name='ChargeType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  zoneCombination?: string(name='ZoneCombination', position='Query'),
}

model DescribeMultiZoneAvailableResourceResponseBody = {
  availableZones?: {
    availableZone?: [ 
    {
      masterResources?: {
        masterResource?: [ 
        {
          instanceType?: string(name='InstanceType'),
          instanceTypeDetail?: {
            cpu?: int32(name='Cpu'),
            mem?: int32(name='Mem'),
          }(name='InstanceTypeDetail'),
        }
      ](name='MasterResource')
      }(name='MasterResources'),
      regionId?: string(name='RegionId'),
      supportedEngines?: {
        supportedEngine?: [ 
        {
          engine?: string(name='Engine'),
          supportedEngineVersions?: {
            supportedEngineVersion?: [ 
            {
              supportedCategories?: {
                supportedCategories?: [ 
                {
                  category?: string(name='Category'),
                  supportedStorageTypes?: {
                    supportedStorageType?: [ 
                    {
                      coreResources?: {
                        coreResource?: [ 
                        {
                          DBInstanceStorageRange?: {
                            maxSize?: int32(name='MaxSize'),
                            minSize?: int32(name='MinSize'),
                            stepSize?: int32(name='StepSize'),
                          }(name='DBInstanceStorageRange'),
                          instanceType?: string(name='InstanceType'),
                          instanceTypeDetail?: {
                            cpu?: int32(name='Cpu'),
                            mem?: int32(name='Mem'),
                          }(name='InstanceTypeDetail'),
                          maxCoreCount?: int32(name='MaxCoreCount'),
                        }
                      ](name='CoreResource')
                      }(name='CoreResources'),
                      storageType?: string(name='StorageType'),
                    }
                  ](name='SupportedStorageType')
                  }(name='SupportedStorageTypes'),
                }
              ](name='SupportedCategories')
              }(name='SupportedCategories'),
              version?: string(name='Version'),
            }
          ](name='SupportedEngineVersion')
          }(name='SupportedEngineVersions'),
        }
      ](name='SupportedEngine')
      }(name='SupportedEngines'),
      zoneCombination?: string(name='ZoneCombination'),
    }
  ](name='AvailableZone')
  }(name='AvailableZones'),
  requestId?: string(name='RequestId'),
}

model DescribeMultiZoneAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMultiZoneAvailableResourceResponseBody(name='body'),
}

async function describeMultiZoneAvailableResource(request: DescribeMultiZoneAvailableResourceRequest): DescribeMultiZoneAvailableResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMultiZoneAvailableResource', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMultiZoneClusterRequest {
  clusterId: string(name='ClusterId', position='Query'),
}

model DescribeMultiZoneClusterResponseBody = {
  arbiterVSwitchIds?: string(name='ArbiterVSwitchIds'),
  arbiterZoneId?: string(name='ArbiterZoneId'),
  autoRenewal?: boolean(name='AutoRenewal'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  coreDiskCount?: string(name='CoreDiskCount'),
  coreDiskSize?: int32(name='CoreDiskSize'),
  coreDiskType?: string(name='CoreDiskType'),
  coreInstanceType?: string(name='CoreInstanceType'),
  coreNodeCount?: int32(name='CoreNodeCount'),
  createdTime?: string(name='CreatedTime'),
  createdTimeUTC?: string(name='CreatedTimeUTC'),
  duration?: int32(name='Duration'),
  encryptionKey?: string(name='EncryptionKey'),
  encryptionType?: string(name='EncryptionType'),
  engine?: string(name='Engine'),
  expireTime?: string(name='ExpireTime'),
  expireTimeUTC?: string(name='ExpireTimeUTC'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  isDeletionProtection?: boolean(name='IsDeletionProtection'),
  logDiskCount?: string(name='LogDiskCount'),
  logDiskSize?: int32(name='LogDiskSize'),
  logDiskType?: string(name='LogDiskType'),
  logInstanceType?: string(name='LogInstanceType'),
  logNodeCount?: int32(name='LogNodeCount'),
  maintainEndTime?: string(name='MaintainEndTime'),
  maintainStartTime?: string(name='MaintainStartTime'),
  majorVersion?: string(name='MajorVersion'),
  masterDiskSize?: int32(name='MasterDiskSize'),
  masterDiskType?: string(name='MasterDiskType'),
  masterInstanceType?: string(name='MasterInstanceType'),
  masterNodeCount?: int32(name='MasterNodeCount'),
  moduleId?: int32(name='ModuleId'),
  moduleStackVersion?: string(name='ModuleStackVersion'),
  multiZoneCombination?: string(name='MultiZoneCombination'),
  multiZoneInstanceModels?: {
    multiZoneInstanceModel?: [ 
    {
      insName?: string(name='InsName'),
      isLatestVersion?: boolean(name='IsLatestVersion'),
      minorVersion?: string(name='MinorVersion'),
      role?: string(name='Role'),
      status?: string(name='Status'),
    }
  ](name='MultiZoneInstanceModel')
  }(name='MultiZoneInstanceModels'),
  networkType?: string(name='NetworkType'),
  parentId?: string(name='ParentId'),
  payType?: string(name='PayType'),
  primaryVSwitchIds?: string(name='PrimaryVSwitchIds'),
  primaryZoneId?: string(name='PrimaryZoneId'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  standbyVSwitchIds?: string(name='StandbyVSwitchIds'),
  standbyZoneId?: string(name='StandbyZoneId'),
  status?: string(name='Status'),
  tags?: {
    tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag')
  }(name='Tags'),
  vpcId?: string(name='VpcId'),
}

model DescribeMultiZoneClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMultiZoneClusterResponseBody(name='body'),
}

async function describeMultiZoneCluster(request: DescribeMultiZoneClusterRequest): DescribeMultiZoneClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMultiZoneCluster', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRecoverableTimeRangeRequest {
  clusterId: string(name='ClusterId', position='Query'),
}

model DescribeRecoverableTimeRangeResponseBody = {
  requestId?: string(name='RequestId'),
  timeBegin?: string(name='TimeBegin'),
  timeEnd?: string(name='TimeEnd'),
}

model DescribeRecoverableTimeRangeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRecoverableTimeRangeResponseBody(name='body'),
}

async function describeRecoverableTimeRange(request: DescribeRecoverableTimeRangeRequest): DescribeRecoverableTimeRangeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRecoverableTimeRange', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  engine?: string(name='Engine', position='Query'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
      zones?: {
        zone?: [ 
        {
          id?: string(name='Id'),
        }
      ](name='Zone')
      }(name='Zones'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRestoreFullDetailsRequest {
  clusterId: string(name='ClusterId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  restoreRecordId: string(name='RestoreRecordId', position='Query'),
}

model DescribeRestoreFullDetailsResponseBody = {
  requestId?: string(name='RequestId'),
  restoreFull?: {
    dataSize?: string(name='DataSize'),
    fail?: int32(name='Fail'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    restoreFullDetails?: {
      restoreFullDetail?: [ 
      {
        dataSize?: string(name='DataSize'),
        endTime?: string(name='EndTime'),
        message?: string(name='Message'),
        process?: string(name='Process'),
        speed?: string(name='Speed'),
        startTime?: string(name='StartTime'),
        state?: string(name='State'),
        table?: string(name='Table'),
      }
    ](name='RestoreFullDetail')
    }(name='RestoreFullDetails'),
    speed?: string(name='Speed'),
    succeed?: int32(name='Succeed'),
    total?: long(name='Total'),
  }(name='RestoreFull'),
}

model DescribeRestoreFullDetailsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRestoreFullDetailsResponseBody(name='body'),
}

async function describeRestoreFullDetails(request: DescribeRestoreFullDetailsRequest): DescribeRestoreFullDetailsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRestoreFullDetails', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRestoreIncrDetailRequest {
  clusterId: string(name='ClusterId', position='Query'),
  restoreRecordId: string(name='RestoreRecordId', position='Query'),
}

model DescribeRestoreIncrDetailResponseBody = {
  requestId?: string(name='RequestId'),
  restoreIncrDetail?: {
    endTime?: string(name='EndTime'),
    process?: string(name='Process'),
    restoreDelay?: string(name='RestoreDelay'),
    restoreStartTs?: string(name='RestoreStartTs'),
    restoredTs?: string(name='RestoredTs'),
    startTime?: string(name='StartTime'),
    state?: string(name='State'),
  }(name='RestoreIncrDetail'),
}

model DescribeRestoreIncrDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRestoreIncrDetailResponseBody(name='body'),
}

async function describeRestoreIncrDetail(request: DescribeRestoreIncrDetailRequest): DescribeRestoreIncrDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRestoreIncrDetail', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRestoreSchemaDetailsRequest {
  clusterId: string(name='ClusterId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  restoreRecordId: string(name='RestoreRecordId', position='Query'),
}

model DescribeRestoreSchemaDetailsResponseBody = {
  requestId?: string(name='RequestId'),
  restoreSchema?: {
    fail?: int32(name='Fail'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    restoreSchemaDetails?: {
      restoreSchemaDetail?: [ 
      {
        endTime?: string(name='EndTime'),
        message?: string(name='Message'),
        startTime?: string(name='StartTime'),
        state?: string(name='State'),
        table?: string(name='Table'),
      }
    ](name='RestoreSchemaDetail')
    }(name='RestoreSchemaDetails'),
    succeed?: int32(name='Succeed'),
    total?: long(name='Total'),
  }(name='RestoreSchema'),
}

model DescribeRestoreSchemaDetailsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRestoreSchemaDetailsResponseBody(name='body'),
}

async function describeRestoreSchemaDetails(request: DescribeRestoreSchemaDetailsRequest): DescribeRestoreSchemaDetailsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRestoreSchemaDetails', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRestoreSummaryRequest {
  clusterId: string(name='ClusterId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model DescribeRestoreSummaryResponseBody = {
  hasMoreRestoreRecord?: int32(name='HasMoreRestoreRecord'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  rescords?: {
    rescord?: [ 
    {
      bulkLoadProcess?: string(name='BulkLoadProcess'),
      createTime?: string(name='CreateTime'),
      finishTime?: string(name='FinishTime'),
      hfileRestoreProcess?: string(name='HfileRestoreProcess'),
      logProcess?: string(name='LogProcess'),
      recordId?: string(name='RecordId'),
      schemaProcess?: string(name='SchemaProcess'),
      status?: string(name='Status'),
    }
  ](name='Rescord')
  }(name='Rescords'),
  total?: int32(name='Total'),
}

model DescribeRestoreSummaryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRestoreSummaryResponseBody(name='body'),
}

async function describeRestoreSummary(request: DescribeRestoreSummaryRequest): DescribeRestoreSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRestoreSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRestoreTablesRequest {
  clusterId: string(name='ClusterId', position='Query'),
  restoreRecordId: string(name='RestoreRecordId', position='Query'),
}

model DescribeRestoreTablesResponseBody = {
  requestId?: string(name='RequestId'),
  restoreFull?: {
    dataSize?: string(name='DataSize'),
    fail?: int32(name='Fail'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    restoreFullDetails?: {
      restoreFullDetail?: [ 
      {
        dataSize?: string(name='DataSize'),
        endTime?: string(name='EndTime'),
        message?: string(name='Message'),
        process?: string(name='Process'),
        speed?: string(name='Speed'),
        startTime?: string(name='StartTime'),
        state?: string(name='State'),
        table?: string(name='Table'),
      }
    ](name='RestoreFullDetail')
    }(name='RestoreFullDetails'),
    speed?: string(name='Speed'),
    succeed?: int32(name='Succeed'),
    total?: long(name='Total'),
  }(name='RestoreFull'),
  restoreIncrDetail?: {
    endTime?: string(name='EndTime'),
    process?: string(name='Process'),
    restoreDelay?: string(name='RestoreDelay'),
    restoreStartTs?: string(name='RestoreStartTs'),
    restoredTs?: string(name='RestoredTs'),
    startTime?: string(name='StartTime'),
    state?: string(name='State'),
  }(name='RestoreIncrDetail'),
  restoreSchema?: {
    fail?: int32(name='Fail'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    restoreSchemaDetails?: {
      restoreSchemaDetail?: [ 
      {
        endTime?: string(name='EndTime'),
        message?: string(name='Message'),
        startTime?: string(name='StartTime'),
        state?: string(name='State'),
        table?: string(name='Table'),
      }
    ](name='RestoreSchemaDetail')
    }(name='RestoreSchemaDetails'),
    succeed?: int32(name='Succeed'),
    total?: long(name='Total'),
  }(name='RestoreSchema'),
  restoreSummary?: {
    endTime?: string(name='EndTime'),
    recordId?: string(name='RecordId'),
    restoreToDate?: string(name='RestoreToDate'),
    startTime?: string(name='StartTime'),
    state?: string(name='State'),
    targetCluster?: string(name='TargetCluster'),
  }(name='RestoreSummary'),
  tables?: {
    table?: [ string ](name='Table')
  }(name='Tables'),
}

model DescribeRestoreTablesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRestoreTablesResponseBody(name='body'),
}

async function describeRestoreTables(request: DescribeRestoreTablesRequest): DescribeRestoreTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRestoreTables', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSecurityGroupsRequest {
  clusterId: string(name='ClusterId', position='Query'),
}

model DescribeSecurityGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  securityGroupIds?: {
    securityGroupId?: [ string ](name='SecurityGroupId')
  }(name='SecurityGroupIds'),
}

model DescribeSecurityGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityGroupsResponseBody(name='body'),
}

async function describeSecurityGroups(request: DescribeSecurityGroupsRequest): DescribeSecurityGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecurityGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeServerlessClusterRequest {
  clusterId: string(name='ClusterId', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model DescribeServerlessClusterResponseBody = {
  autoRenew?: string(name='AutoRenew'),
  clusterType?: string(name='ClusterType'),
  createTime?: string(name='CreateTime'),
  cuSize?: string(name='CuSize'),
  diskSize?: string(name='DiskSize'),
  expireTime?: string(name='ExpireTime'),
  haType?: string(name='HaType'),
  hasUser?: string(name='HasUser'),
  innerEndpoint?: string(name='InnerEndpoint'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  isDeletionProtection?: string(name='IsDeletionProtection'),
  lockMode?: string(name='LockMode'),
  mainVersion?: string(name='MainVersion'),
  outerEndpoint?: string(name='OuterEndpoint'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  reserverMaxQpsNum?: string(name='ReserverMaxQpsNum'),
  reserverMinQpsNum?: string(name='ReserverMinQpsNum'),
  resourceGroupId?: string(name='ResourceGroupId'),
  status?: string(name='Status'),
  updateStatus?: string(name='UpdateStatus'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeServerlessClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServerlessClusterResponseBody(name='body'),
}

async function describeServerlessCluster(request: DescribeServerlessClusterRequest): DescribeServerlessClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeServerlessCluster', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSubDomainRequest {
  regionId?: string(name='RegionId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeSubDomainResponseBody = {
  requestId?: string(name='RequestId'),
  subDomain?: string(name='SubDomain'),
}

model DescribeSubDomainResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSubDomainResponseBody(name='body'),
}

async function describeSubDomain(request: DescribeSubDomainRequest): DescribeSubDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSubDomain', 'POST', '/', 'json', false, 'json', request);
}

model EnableHBaseueBackupRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  coldStorageSize?: int32(name='ColdStorageSize', position='Query'),
  hbaseueClusterId: string(name='HbaseueClusterId', position='Query'),
  nodeCount: int32(name='NodeCount', position='Query'),
}

model EnableHBaseueBackupResponseBody = {
  clusterId?: string(name='ClusterId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model EnableHBaseueBackupResponse = {
  headers: map[string]string(name='headers'),
  body: EnableHBaseueBackupResponseBody(name='body'),
}

async function enableHBaseueBackup(request: EnableHBaseueBackupRequest): EnableHBaseueBackupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableHBaseueBackup', 'POST', '/', 'json', false, 'json', request);
}

model EnableHBaseueModuleRequest {
  autoRenewPeriod?: int32(name='AutoRenewPeriod', position='Query'),
  bdsId?: string(name='BdsId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  coreInstanceType: string(name='CoreInstanceType', position='Query'),
  diskSize?: int32(name='DiskSize', position='Query'),
  diskType?: string(name='DiskType', position='Query'),
  hbaseueClusterId: string(name='HbaseueClusterId', position='Query'),
  masterInstanceType?: string(name='MasterInstanceType', position='Query'),
  moduleClusterName?: string(name='ModuleClusterName', position='Query'),
  moduleTypeName: string(name='ModuleTypeName', position='Query'),
  nodeCount: int32(name='NodeCount', position='Query'),
  payType: string(name='PayType', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
  vswitchId: string(name='VswitchId', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model EnableHBaseueModuleResponseBody = {
  clusterId?: string(name='ClusterId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model EnableHBaseueModuleResponse = {
  headers: map[string]string(name='headers'),
  body: EnableHBaseueModuleResponseBody(name='body'),
}

async function enableHBaseueModule(request: EnableHBaseueModuleRequest): EnableHBaseueModuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableHBaseueModule', 'POST', '/', 'json', false, 'json', request);
}

model EvaluateMultiZoneResourceRequest {
  arbiterVSwitchId: string(name='ArbiterVSwitchId', position='Query'),
  arbiterZoneId: string(name='ArbiterZoneId', position='Query'),
  archVersion: string(name='ArchVersion', position='Query'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', minimum=1, maximum=60, position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  clusterName?: string(name='ClusterName', position='Query'),
  coreDiskSize: int32(name='CoreDiskSize', minimum=400, maximum=64000, position='Query'),
  coreDiskType: string(name='CoreDiskType', position='Query'),
  coreInstanceType: string(name='CoreInstanceType', position='Query'),
  coreNodeCount: int32(name='CoreNodeCount', minimum=4, maximum=2000, position='Query'),
  engine: string(name='Engine', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  logDiskSize?: int32(name='LogDiskSize', minimum=400, maximum=64000, position='Query'),
  logDiskType?: string(name='LogDiskType', position='Query'),
  logInstanceType?: string(name='LogInstanceType', position='Query'),
  logNodeCount?: int32(name='LogNodeCount', minimum=4, maximum=200, position='Query'),
  masterInstanceType: string(name='MasterInstanceType', position='Query'),
  multiZoneCombination: string(name='MultiZoneCombination', position='Query'),
  payType: string(name='PayType', position='Query'),
  period?: int32(name='Period', minimum=1, maximum=60, position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  primaryVSwitchId: string(name='PrimaryVSwitchId', position='Query'),
  primaryZoneId: string(name='PrimaryZoneId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  securityIPList?: string(name='SecurityIPList', position='Query'),
  standbyVSwitchId: string(name='StandbyVSwitchId', position='Query'),
  standbyZoneId: string(name='StandbyZoneId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model EvaluateMultiZoneResourceResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EvaluateMultiZoneResourceResponse = {
  headers: map[string]string(name='headers'),
  body: EvaluateMultiZoneResourceResponseBody(name='body'),
}

async function evaluateMultiZoneResource(request: EvaluateMultiZoneResourceRequest): EvaluateMultiZoneResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EvaluateMultiZoneResource', 'POST', '/', 'json', false, 'json', request);
}

model GetMultimodeCmsUrlRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetMultimodeCmsUrlResponseBody = {
  clusterId?: string(name='ClusterId'),
  multimodCmsUrl?: string(name='MultimodCmsUrl'),
  requestId?: string(name='RequestId'),
}

model GetMultimodeCmsUrlResponse = {
  headers: map[string]string(name='headers'),
  body: GetMultimodeCmsUrlResponseBody(name='body'),
}

async function getMultimodeCmsUrl(request: GetMultimodeCmsUrlRequest): GetMultimodeCmsUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMultimodeCmsUrl', 'POST', '/', 'json', false, 'json', request);
}

model ListHBaseInstancesRequest {
  vpcId: string(name='VpcId', position='Query'),
}

model ListHBaseInstancesResponseBody = {
  instances?: {
    instance?: [ 
    {
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isDefault?: boolean(name='IsDefault'),
    }
  ](name='Instance')
  }(name='Instances'),
  requestId?: string(name='RequestId'),
}

model ListHBaseInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListHBaseInstancesResponseBody(name='body'),
}

async function listHBaseInstances(request: ListHBaseInstancesRequest): ListHBaseInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListHBaseInstances', 'POST', '/', 'json', false, 'json', request);
}

model ListInstanceServiceConfigHistoriesRequest {
  clusterId: string(name='ClusterId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListInstanceServiceConfigHistoriesResponseBody = {
  configureHistoryList?: {
    config?: [ 
    {
      configureName?: string(name='ConfigureName'),
      createTime?: string(name='CreateTime'),
      effective?: string(name='Effective'),
      newValue?: string(name='NewValue'),
      oldValue?: string(name='OldValue'),
    }
  ](name='Config')
  }(name='ConfigureHistoryList'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: long(name='TotalRecordCount'),
}

model ListInstanceServiceConfigHistoriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceServiceConfigHistoriesResponseBody(name='body'),
}

async function listInstanceServiceConfigHistories(request: ListInstanceServiceConfigHistoriesRequest): ListInstanceServiceConfigHistoriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstanceServiceConfigHistories', 'POST', '/', 'json', false, 'json', request);
}

model ListInstanceServiceConfigurationsRequest {
  clusterId: string(name='ClusterId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListInstanceServiceConfigurationsResponseBody = {
  configureList?: {
    config?: [ 
    {
      configureName?: string(name='ConfigureName'),
      configureUnit?: string(name='ConfigureUnit'),
      defaultValue?: string(name='DefaultValue'),
      description?: string(name='Description'),
      needRestart?: string(name='NeedRestart'),
      runningValue?: string(name='RunningValue'),
      valueRange?: string(name='ValueRange'),
    }
  ](name='Config')
  }(name='ConfigureList'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: long(name='TotalRecordCount'),
}

model ListInstanceServiceConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceServiceConfigurationsResponseBody(name='body'),
}

async function listInstanceServiceConfigurations(request: ListInstanceServiceConfigurationsRequest): ListInstanceServiceConfigurationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstanceServiceConfigurations', 'POST', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ListTagsRequest {
  regionId: string(name='RegionId', position='Query'),
}

model ListTagsResponseBody = {
  requestId?: string(name='RequestId'),
  tags?: {
    tag?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Tag')
  }(name='Tags'),
}

model ListTagsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagsResponseBody(name='body'),
}

async function listTags(request: ListTagsRequest): ListTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTags', 'POST', '/', 'json', false, 'json', request);
}

model ModifyBackupPlanConfigRequest {
  clusterId: string(name='ClusterId', position='Query'),
  fullBackupCycle: string(name='FullBackupCycle', position='Query'),
  minHFileBackupCount: string(name='MinHFileBackupCount', position='Query'),
  nextFullBackupDate: string(name='NextFullBackupDate', position='Query'),
  tables: string(name='Tables', position='Query'),
}

model ModifyBackupPlanConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBackupPlanConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBackupPlanConfigResponseBody(name='body'),
}

async function modifyBackupPlanConfig(request: ModifyBackupPlanConfigRequest): ModifyBackupPlanConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyBackupPlanConfig', 'POST', '/', 'json', false, 'json', request);
}

model ModifyBackupPolicyRequest {
  clusterId: string(name='ClusterId', position='Query'),
  preferredBackupEndTimeUTC?: string(name='PreferredBackupEndTimeUTC', position='Query'),
  preferredBackupPeriod: string(name='PreferredBackupPeriod', position='Query'),
  preferredBackupStartTimeUTC?: string(name='PreferredBackupStartTimeUTC', position='Query'),
  preferredBackupTime: string(name='PreferredBackupTime', position='Query'),
}

model ModifyBackupPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBackupPolicyResponseBody(name='body'),
}

async function modifyBackupPolicy(request: ModifyBackupPolicyRequest): ModifyBackupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyBackupPolicy', 'POST', '/', 'json', false, 'json', request);
}

model ModifyClusterDeletionProtectionRequest {
  clusterId: string(name='ClusterId', position='Query'),
  protection: boolean(name='Protection', position='Query'),
}

model ModifyClusterDeletionProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterDeletionProtectionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterDeletionProtectionResponseBody(name='body'),
}

async function modifyClusterDeletionProtection(request: ModifyClusterDeletionProtectionRequest): ModifyClusterDeletionProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyClusterDeletionProtection', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDiskWarningLineRequest {
  clusterId: string(name='ClusterId', position='Query'),
  warningLine: int32(name='WarningLine', minimum=0, maximum=100, position='Query'),
}

model ModifyDiskWarningLineResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDiskWarningLineResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDiskWarningLineResponseBody(name='body'),
}

async function modifyDiskWarningLine(request: ModifyDiskWarningLineRequest): ModifyDiskWarningLineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDiskWarningLine', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceMaintainTimeRequest {
  clusterId: string(name='ClusterId', position='Query'),
  maintainEndTime: string(name='MaintainEndTime', position='Query'),
  maintainStartTime: string(name='MaintainStartTime', position='Query'),
}

model ModifyInstanceMaintainTimeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceMaintainTimeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceMaintainTimeResponseBody(name='body'),
}

async function modifyInstanceMaintainTime(request: ModifyInstanceMaintainTimeRequest): ModifyInstanceMaintainTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceMaintainTime', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceNameRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  clusterName: string(name='ClusterName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ModifyInstanceNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceNameResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceNameResponseBody(name='body'),
}

async function modifyInstanceName(request: ModifyInstanceNameRequest): ModifyInstanceNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceName', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceServiceConfigRequest {
  clusterId: string(name='ClusterId', position='Query'),
  configureName?: string(name='ConfigureName', position='Query'),
  configureValue?: string(name='ConfigureValue', position='Query'),
  parameters?: string(name='Parameters', position='Query'),
  restart?: boolean(name='Restart', position='Query'),
}

model ModifyInstanceServiceConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceServiceConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceServiceConfigResponseBody(name='body'),
}

async function modifyInstanceServiceConfig(request: ModifyInstanceServiceConfigRequest): ModifyInstanceServiceConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceServiceConfig', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceTypeRequest {
  clusterId: string(name='ClusterId', position='Query'),
  coreInstanceType?: string(name='CoreInstanceType', position='Query'),
  masterInstanceType?: string(name='MasterInstanceType', position='Query'),
}

model ModifyInstanceTypeResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyInstanceTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceTypeResponseBody(name='body'),
}

async function modifyInstanceType(request: ModifyInstanceTypeRequest): ModifyInstanceTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceType', 'POST', '/', 'json', false, 'json', request);
}

model ModifyIpWhitelistRequest {
  clusterId: string(name='ClusterId', position='Query'),
  groupName: string(name='GroupName', position='Query'),
  ipList?: string(name='IpList', position='Query'),
  ipVersion: string(name='IpVersion', position='Query'),
}

model ModifyIpWhitelistResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpWhitelistResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIpWhitelistResponseBody(name='body'),
}

async function modifyIpWhitelist(request: ModifyIpWhitelistRequest): ModifyIpWhitelistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyIpWhitelist', 'POST', '/', 'json', false, 'json', request);
}

model ModifyMultiZoneClusterNodeTypeRequest {
  clusterId: string(name='ClusterId', position='Query'),
  coreInstanceType?: string(name='CoreInstanceType', position='Query'),
  logInstanceType?: string(name='LogInstanceType', position='Query'),
  masterInstanceType?: string(name='MasterInstanceType', position='Query'),
}

model ModifyMultiZoneClusterNodeTypeResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyMultiZoneClusterNodeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyMultiZoneClusterNodeTypeResponseBody(name='body'),
}

async function modifyMultiZoneClusterNodeType(request: ModifyMultiZoneClusterNodeTypeRequest): ModifyMultiZoneClusterNodeTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyMultiZoneClusterNodeType', 'POST', '/', 'json', false, 'json', request);
}

model ModifySecurityGroupsRequest {
  clusterId: string(name='ClusterId', position='Query'),
  securityGroupIds: string(name='SecurityGroupIds', position='Query'),
}

model ModifySecurityGroupsResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySecurityGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySecurityGroupsResponseBody(name='body'),
}

async function modifySecurityGroups(request: ModifySecurityGroupsRequest): ModifySecurityGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySecurityGroups', 'POST', '/', 'json', false, 'json', request);
}

model ModifyUIAccountPasswordRequest {
  accountName: string(name='AccountName', position='Query'),
  accountPassword: string(name='AccountPassword', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
}

model ModifyUIAccountPasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUIAccountPasswordResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyUIAccountPasswordResponseBody(name='body'),
}

async function modifyUIAccountPassword(request: ModifyUIAccountPasswordRequest): ModifyUIAccountPasswordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyUIAccountPassword', 'POST', '/', 'json', false, 'json', request);
}

model MoveResourceGroupRequest {
  clusterId: string(name='ClusterId', position='Query'),
  newResourceGroupId: string(name='NewResourceGroupId', position='Query'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model MoveResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: MoveResourceGroupResponseBody(name='body'),
}

async function moveResourceGroup(request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MoveResourceGroup', 'POST', '/', 'json', false, 'json', request);
}

model OpenBackupRequest {
  clusterId: string(name='ClusterId', position='Query'),
}

model OpenBackupResponseBody = {
  requestId?: string(name='RequestId'),
}

model OpenBackupResponse = {
  headers: map[string]string(name='headers'),
  body: OpenBackupResponseBody(name='body'),
}

async function openBackup(request: OpenBackupRequest): OpenBackupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenBackup', 'POST', '/', 'json', false, 'json', request);
}

model PurgeInstanceRequest {
  clusterId: string(name='ClusterId', position='Query'),
}

model PurgeInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model PurgeInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: PurgeInstanceResponseBody(name='body'),
}

async function purgeInstance(request: PurgeInstanceRequest): PurgeInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PurgeInstance', 'POST', '/', 'json', false, 'json', request);
}

model QueryHBaseHaDBRequest {
  bdsId: string(name='BdsId', position='Query'),
}

model QueryHBaseHaDBResponseBody = {
  clusterList?: {
    cluster?: [ 
    {
      activeName?: string(name='ActiveName'),
      bdsName?: string(name='BdsName'),
      haName?: string(name='HaName'),
      haSlbConnList?: {
        haSlbConn?: [ 
        {
          hbaseType?: string(name='HbaseType'),
          slbConnAddr?: string(name='SlbConnAddr'),
          slbType?: string(name='SlbType'),
        }
      ](name='HaSlbConn')
      }(name='HaSlbConnList'),
      standbyName?: string(name='StandbyName'),
    }
  ](name='Cluster')
  }(name='ClusterList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model QueryHBaseHaDBResponse = {
  headers: map[string]string(name='headers'),
  body: QueryHBaseHaDBResponseBody(name='body'),
}

async function queryHBaseHaDB(request: QueryHBaseHaDBRequest): QueryHBaseHaDBResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryHBaseHaDB', 'POST', '/', 'json', false, 'json', request);
}

model QueryXpackRelateDBRequest {
  clusterId: string(name='ClusterId', position='Query'),
  hasSingleNode?: boolean(name='HasSingleNode', position='Query'),
  relateDbType: string(name='RelateDbType', position='Query'),
}

model QueryXpackRelateDBResponseBody = {
  clusterList?: {
    cluster?: [ 
    {
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      DBType?: string(name='DBType'),
      DBVersion?: string(name='DBVersion'),
      isRelated?: boolean(name='IsRelated'),
      lockMode?: string(name='LockMode'),
      status?: string(name='Status'),
    }
  ](name='Cluster')
  }(name='ClusterList'),
  requestId?: string(name='RequestId'),
}

model QueryXpackRelateDBResponse = {
  headers: map[string]string(name='headers'),
  body: QueryXpackRelateDBResponseBody(name='body'),
}

async function queryXpackRelateDB(request: QueryXpackRelateDBRequest): QueryXpackRelateDBResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryXpackRelateDB', 'POST', '/', 'json', false, 'json', request);
}

model RelateDbForHBaseHaRequest {
  clusterId: string(name='ClusterId', position='Query'),
  haActive: string(name='HaActive', position='Query'),
  haActiveClusterKey?: string(name='HaActiveClusterKey', position='Query'),
  haActiveDBType: string(name='HaActiveDBType', position='Query'),
  haActiveHbaseFsDir?: string(name='HaActiveHbaseFsDir', position='Query'),
  haActiveHdfsUri?: string(name='HaActiveHdfsUri', position='Query'),
  haActivePassword?: string(name='HaActivePassword', position='Query'),
  haActiveUser?: string(name='HaActiveUser', position='Query'),
  haActiveVersion?: string(name='HaActiveVersion', position='Query'),
  haMigrateType: string(name='HaMigrateType', position='Query'),
  haStandby: string(name='HaStandby', position='Query'),
  haStandbyClusterKey?: string(name='HaStandbyClusterKey', position='Query'),
  haStandbyDBType: string(name='HaStandbyDBType', position='Query'),
  haStandbyHbaseFsDir?: string(name='HaStandbyHbaseFsDir', position='Query'),
  haStandbyHdfsUri?: string(name='HaStandbyHdfsUri', position='Query'),
  haStandbyPassword?: string(name='HaStandbyPassword', position='Query'),
  haStandbyUser?: string(name='HaStandbyUser', position='Query'),
  haStandbyVersion?: string(name='HaStandbyVersion', position='Query'),
  haTables?: string(name='HaTables', position='Query'),
  isActiveStandard: boolean(name='IsActiveStandard', position='Query'),
  isStandbyStandard: boolean(name='IsStandbyStandard', position='Query'),
}

model RelateDbForHBaseHaResponseBody = {
  requestId?: string(name='RequestId'),
}

model RelateDbForHBaseHaResponse = {
  headers: map[string]string(name='headers'),
  body: RelateDbForHBaseHaResponseBody(name='body'),
}

async function relateDbForHBaseHa(request: RelateDbForHBaseHaRequest): RelateDbForHBaseHaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RelateDbForHBaseHa', 'POST', '/', 'json', false, 'json', request);
}

model ReleasePublicNetworkAddressRequest {
  clusterId: string(name='ClusterId', position='Query'),
}

model ReleasePublicNetworkAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleasePublicNetworkAddressResponse = {
  headers: map[string]string(name='headers'),
  body: ReleasePublicNetworkAddressResponseBody(name='body'),
}

async function releasePublicNetworkAddress(request: ReleasePublicNetworkAddressRequest): ReleasePublicNetworkAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleasePublicNetworkAddress', 'POST', '/', 'json', false, 'json', request);
}

model RenewInstanceRequest {
  clusterId: string(name='ClusterId', position='Query'),
  duration: int32(name='Duration', position='Query'),
  pricingCycle: string(name='PricingCycle', position='Query'),
}

model RenewInstanceResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RenewInstance', 'POST', '/', 'json', false, 'json', request);
}

model ResizeColdStorageSizeRequest {
  clusterId: string(name='ClusterId', position='Query'),
  coldStorageSize: int32(name='ColdStorageSize', minimum=800, maximum=2048000, position='Query'),
}

model ResizeColdStorageSizeResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ResizeColdStorageSizeResponse = {
  headers: map[string]string(name='headers'),
  body: ResizeColdStorageSizeResponseBody(name='body'),
}

async function resizeColdStorageSize(request: ResizeColdStorageSizeRequest): ResizeColdStorageSizeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResizeColdStorageSize', 'POST', '/', 'json', false, 'json', request);
}

model ResizeDiskSizeRequest {
  clusterId: string(name='ClusterId', position='Query'),
  nodeDiskSize: int32(name='NodeDiskSize', position='Query'),
}

model ResizeDiskSizeResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ResizeDiskSizeResponse = {
  headers: map[string]string(name='headers'),
  body: ResizeDiskSizeResponseBody(name='body'),
}

async function resizeDiskSize(request: ResizeDiskSizeRequest): ResizeDiskSizeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResizeDiskSize', 'POST', '/', 'json', false, 'json', request);
}

model ResizeMultiZoneClusterDiskSizeRequest {
  clusterId: string(name='ClusterId', position='Query'),
  coreDiskSize?: int32(name='CoreDiskSize', minimum=400, maximum=64000, position='Query'),
  logDiskSize?: int32(name='LogDiskSize', minimum=400, maximum=64000, position='Query'),
}

model ResizeMultiZoneClusterDiskSizeResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ResizeMultiZoneClusterDiskSizeResponse = {
  headers: map[string]string(name='headers'),
  body: ResizeMultiZoneClusterDiskSizeResponseBody(name='body'),
}

async function resizeMultiZoneClusterDiskSize(request: ResizeMultiZoneClusterDiskSizeRequest): ResizeMultiZoneClusterDiskSizeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResizeMultiZoneClusterDiskSize', 'POST', '/', 'json', false, 'json', request);
}

model ResizeMultiZoneClusterNodeCountRequest {
  arbiterVSwitchId?: string(name='ArbiterVSwitchId', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  coreNodeCount?: int32(name='CoreNodeCount', minimum=2, maximum=1000, position='Query'),
  logNodeCount?: int32(name='LogNodeCount', minimum=4, maximum=500, position='Query'),
  primaryCoreNodeCount?: int32(name='PrimaryCoreNodeCount', minimum=1, maximum=750, position='Query'),
  primaryVSwitchId?: string(name='PrimaryVSwitchId', position='Query'),
  standbyCoreNodeCount?: int32(name='StandbyCoreNodeCount', minimum=1, maximum=750, position='Query'),
  standbyVSwitchId?: string(name='StandbyVSwitchId', position='Query'),
}

model ResizeMultiZoneClusterNodeCountResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ResizeMultiZoneClusterNodeCountResponse = {
  headers: map[string]string(name='headers'),
  body: ResizeMultiZoneClusterNodeCountResponseBody(name='body'),
}

async function resizeMultiZoneClusterNodeCount(request: ResizeMultiZoneClusterNodeCountRequest): ResizeMultiZoneClusterNodeCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResizeMultiZoneClusterNodeCount', 'POST', '/', 'json', false, 'json', request);
}

model ResizeNodeCountRequest {
  clusterId: string(name='ClusterId', position='Query'),
  nodeCount: int32(name='NodeCount', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ResizeNodeCountResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ResizeNodeCountResponse = {
  headers: map[string]string(name='headers'),
  body: ResizeNodeCountResponseBody(name='body'),
}

async function resizeNodeCount(request: ResizeNodeCountRequest): ResizeNodeCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResizeNodeCount', 'POST', '/', 'json', false, 'json', request);
}

model RestartInstanceRequest {
  clusterId: string(name='ClusterId', position='Query'),
  components?: string(name='Components', position='Query'),
}

model RestartInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RestartInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RestartInstanceResponseBody(name='body'),
}

async function restartInstance(request: RestartInstanceRequest): RestartInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestartInstance', 'POST', '/', 'json', false, 'json', request);
}

model SwitchHbaseHaSlbRequest {
  bdsId: string(name='BdsId', position='Query'),
  haId: string(name='HaId', position='Query'),
  haTypes: string(name='HaTypes', position='Query'),
  hbaseType: string(name='HbaseType', position='Query'),
}

model SwitchHbaseHaSlbResponseBody = {
  requestId?: string(name='RequestId'),
}

model SwitchHbaseHaSlbResponse = {
  headers: map[string]string(name='headers'),
  body: SwitchHbaseHaSlbResponseBody(name='body'),
}

async function switchHbaseHaSlb(request: SwitchHbaseHaSlbRequest): SwitchHbaseHaSlbResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SwitchHbaseHaSlb', 'POST', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  tag: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model UnTagResourcesRequest {
  all?: boolean(name='All', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  tagKey?: [ string ](name='TagKey', position='Query'),
}

model UnTagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UnTagResourcesResponseBody(name='body'),
}

async function unTagResources(request: UnTagResourcesRequest): UnTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnTagResources', 'POST', '/', 'json', false, 'json', request);
}

model UpgradeMinorVersionRequest {
  clusterId: string(name='ClusterId', position='Query'),
  components?: string(name='Components', position='Query'),
}

model UpgradeMinorVersionResponseBody = {
  requestId?: string(name='RequestId'),
  upgradingComponents?: string(name='UpgradingComponents'),
}

model UpgradeMinorVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeMinorVersionResponseBody(name='body'),
}

async function upgradeMinorVersion(request: UpgradeMinorVersionRequest): UpgradeMinorVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeMinorVersion', 'POST', '/', 'json', false, 'json', request);
}

model UpgradeMultiZoneClusterRequest {
  clusterId: string(name='ClusterId', position='Query'),
  components: string(name='Components', position='Query'),
  restartComponents?: string(name='RestartComponents', position='Query'),
  runMode?: string(name='RunMode', position='Query'),
  upgradeInsName?: string(name='UpgradeInsName', position='Query'),
  versions?: string(name='Versions', position='Query'),
}

model UpgradeMultiZoneClusterResponseBody = {
  requestId?: string(name='RequestId'),
  upgradingComponents?: string(name='UpgradingComponents'),
}

model UpgradeMultiZoneClusterResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeMultiZoneClusterResponseBody(name='body'),
}

async function upgradeMultiZoneCluster(request: UpgradeMultiZoneClusterRequest): UpgradeMultiZoneClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeMultiZoneCluster', 'POST', '/', 'json', false, 'json', request);
}

model XpackRelateDBRequest {
  clusterId: string(name='ClusterId', position='Query'),
  dbClusterIds: string(name='DbClusterIds', position='Query'),
  relateDbType: string(name='RelateDbType', position='Query'),
}

model XpackRelateDBResponseBody = {
  requestId?: string(name='RequestId'),
}

model XpackRelateDBResponse = {
  headers: map[string]string(name='headers'),
  body: XpackRelateDBResponseBody(name='body'),
}

async function xpackRelateDB(request: XpackRelateDBRequest): XpackRelateDBResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'XpackRelateDB', 'POST', '/', 'json', false, 'json', request);
}

