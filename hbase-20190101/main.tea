/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'hbase.aliyuncs.com',
    ap-southeast-1 = 'hbase.aliyuncs.com',
    cn-beijing = 'hbase.aliyuncs.com',
    cn-beijing-finance-1 = 'hbase.aliyuncs.com',
    cn-beijing-finance-pop = 'hbase.aliyuncs.com',
    cn-beijing-gov-1 = 'hbase.aliyuncs.com',
    cn-beijing-nu16-b01 = 'hbase.aliyuncs.com',
    cn-edge-1 = 'hbase.aliyuncs.com',
    cn-fujian = 'hbase.aliyuncs.com',
    cn-haidian-cm12-c01 = 'hbase.aliyuncs.com',
    cn-hangzhou = 'hbase.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'hbase.aliyuncs.com',
    cn-hangzhou-finance = 'hbase.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'hbase.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'hbase.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'hbase.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'hbase.aliyuncs.com',
    cn-hangzhou-test-306 = 'hbase.aliyuncs.com',
    cn-hongkong = 'hbase.aliyuncs.com',
    cn-hongkong-finance-pop = 'hbase.aliyuncs.com',
    cn-north-2-gov-1 = 'hbase.aliyuncs.com',
    cn-qingdao = 'hbase.aliyuncs.com',
    cn-qingdao-nebula = 'hbase.aliyuncs.com',
    cn-shanghai = 'hbase.aliyuncs.com',
    cn-shanghai-et15-b01 = 'hbase.aliyuncs.com',
    cn-shanghai-et2-b01 = 'hbase.aliyuncs.com',
    cn-shanghai-finance-1 = 'hbase.aliyuncs.com',
    cn-shanghai-inner = 'hbase.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'hbase.aliyuncs.com',
    cn-shenzhen = 'hbase.aliyuncs.com',
    cn-shenzhen-finance-1 = 'hbase.aliyuncs.com',
    cn-shenzhen-inner = 'hbase.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'hbase.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'hbase.aliyuncs.com',
    cn-wuhan = 'hbase.aliyuncs.com',
    cn-yushanfang = 'hbase.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'hbase.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'hbase.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'hbase.aliyuncs.com',
    eu-west-1-oxs = 'hbase.ap-northeast-1.aliyuncs.com',
    rus-west-1-pop = 'hbase.ap-northeast-1.aliyuncs.com',
    us-east-1 = 'hbase.aliyuncs.com',
    us-west-1 = 'hbase.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('hbase', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddUserHdfsInfoRequest {
  clientToken?: string(name='ClientToken'),
  clusterId?: string(name='ClusterId'),
  extInfo?: string(name='ExtInfo'),
}

model AddUserHdfsInfoResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddUserHdfsInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddUserHdfsInfoResponseBody(name='body'),
}

async function addUserHdfsInfoWithOptions(request: AddUserHdfsInfoRequest, runtime: Util.RuntimeOptions): AddUserHdfsInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.extInfo)) {
    query['ExtInfo'] = request.extInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddUserHdfsInfo',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addUserHdfsInfo(request: AddUserHdfsInfoRequest): AddUserHdfsInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUserHdfsInfoWithOptions(request, runtime);
}

model AllocatePublicNetworkAddressRequest {
  clientToken?: string(name='ClientToken'),
  clusterId?: string(name='ClusterId'),
}

model AllocatePublicNetworkAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model AllocatePublicNetworkAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AllocatePublicNetworkAddressResponseBody(name='body'),
}

async function allocatePublicNetworkAddressWithOptions(request: AllocatePublicNetworkAddressRequest, runtime: Util.RuntimeOptions): AllocatePublicNetworkAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AllocatePublicNetworkAddress',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function allocatePublicNetworkAddress(request: AllocatePublicNetworkAddressRequest): AllocatePublicNetworkAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocatePublicNetworkAddressWithOptions(request, runtime);
}

model CancelActiveOperationTasksRequest {
  ids?: string(name='Ids'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model CancelActiveOperationTasksResponseBody = {
  ids?: string(name='Ids'),
  requestId?: string(name='RequestId'),
}

model CancelActiveOperationTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelActiveOperationTasksResponseBody(name='body'),
}

async function cancelActiveOperationTasksWithOptions(request: CancelActiveOperationTasksRequest, runtime: Util.RuntimeOptions): CancelActiveOperationTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelActiveOperationTasks',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelActiveOperationTasks(request: CancelActiveOperationTasksRequest): CancelActiveOperationTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelActiveOperationTasksWithOptions(request, runtime);
}

model CheckComponentsVersionRequest {
  clusterId?: string(name='ClusterId'),
  components?: string(name='Components'),
}

model CheckComponentsVersionResponseBody = {
  components?: {
    component?: [ 
    {
      component?: string(name='Component'),
      isLatestVersion?: string(name='IsLatestVersion'),
    }
  ](name='Component')
  }(name='Components'),
  requestId?: string(name='RequestId'),
}

model CheckComponentsVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckComponentsVersionResponseBody(name='body'),
}

async function checkComponentsVersionWithOptions(request: CheckComponentsVersionRequest, runtime: Util.RuntimeOptions): CheckComponentsVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.components)) {
    query['Components'] = request.components;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckComponentsVersion',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkComponentsVersion(request: CheckComponentsVersionRequest): CheckComponentsVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkComponentsVersionWithOptions(request, runtime);
}

model CloseBackupRequest {
  clusterId?: string(name='ClusterId'),
}

model CloseBackupResponseBody = {
  requestId?: string(name='RequestId'),
}

model CloseBackupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloseBackupResponseBody(name='body'),
}

async function closeBackupWithOptions(request: CloseBackupRequest, runtime: Util.RuntimeOptions): CloseBackupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloseBackup',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function closeBackup(request: CloseBackupRequest): CloseBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return closeBackupWithOptions(request, runtime);
}

model ConvertInstanceRequest {
  clusterId?: string(name='ClusterId'),
  duration?: int32(name='Duration'),
  payType?: string(name='PayType'),
  pricingCycle?: string(name='PricingCycle'),
}

model ConvertInstanceResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ConvertInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConvertInstanceResponseBody(name='body'),
}

async function convertInstanceWithOptions(request: ConvertInstanceRequest, runtime: Util.RuntimeOptions): ConvertInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConvertInstance',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function convertInstance(request: ConvertInstanceRequest): ConvertInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertInstanceWithOptions(request, runtime);
}

model CreateBackupPlanRequest {
  clusterId?: string(name='ClusterId'),
}

model CreateBackupPlanResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBackupPlanResponseBody(name='body'),
}

async function createBackupPlanWithOptions(request: CreateBackupPlanRequest, runtime: Util.RuntimeOptions): CreateBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBackupPlan',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBackupPlan(request: CreateBackupPlanRequest): CreateBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBackupPlanWithOptions(request, runtime);
}

model CreateClusterRequest {
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
  clientToken?: string(name='ClientToken'),
  clusterName?: string(name='ClusterName'),
  coldStorageSize?: int32(name='ColdStorageSize'),
  coreInstanceType?: string(name='CoreInstanceType'),
  diskSize?: int32(name='DiskSize'),
  diskType?: string(name='DiskType'),
  encryptionKey?: string(name='EncryptionKey'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  masterInstanceType?: string(name='MasterInstanceType'),
  nodeCount?: int32(name='NodeCount'),
  payType?: string(name='PayType'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  securityIPList?: string(name='SecurityIPList'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model CreateClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateClusterResponseBody(name='body'),
}

async function createClusterWithOptions(request: CreateClusterRequest, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoRenewPeriod)) {
    query['AutoRenewPeriod'] = request.autoRenewPeriod;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.coldStorageSize)) {
    query['ColdStorageSize'] = request.coldStorageSize;
  }
  if (!Util.isUnset(request.coreInstanceType)) {
    query['CoreInstanceType'] = request.coreInstanceType;
  }
  if (!Util.isUnset(request.diskSize)) {
    query['DiskSize'] = request.diskSize;
  }
  if (!Util.isUnset(request.diskType)) {
    query['DiskType'] = request.diskType;
  }
  if (!Util.isUnset(request.encryptionKey)) {
    query['EncryptionKey'] = request.encryptionKey;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.masterInstanceType)) {
    query['MasterInstanceType'] = request.masterInstanceType;
  }
  if (!Util.isUnset(request.nodeCount)) {
    query['NodeCount'] = request.nodeCount;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.securityIPList)) {
    query['SecurityIPList'] = request.securityIPList;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCluster',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterWithOptions(request, runtime);
}

model CreateGlobalResourceRequest {
  clientToken?: string(name='ClientToken'),
  clusterId?: string(name='ClusterId'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
}

model CreateGlobalResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateGlobalResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGlobalResourceResponseBody(name='body'),
}

async function createGlobalResourceWithOptions(request: CreateGlobalResourceRequest, runtime: Util.RuntimeOptions): CreateGlobalResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGlobalResource',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGlobalResource(request: CreateGlobalResourceRequest): CreateGlobalResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGlobalResourceWithOptions(request, runtime);
}

model CreateHBaseSlbServerRequest {
  clientToken?: string(name='ClientToken'),
  clusterId?: string(name='ClusterId'),
  slbServer?: string(name='SlbServer'),
}

model CreateHBaseSlbServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateHBaseSlbServerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHBaseSlbServerResponseBody(name='body'),
}

async function createHBaseSlbServerWithOptions(request: CreateHBaseSlbServerRequest, runtime: Util.RuntimeOptions): CreateHBaseSlbServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.slbServer)) {
    query['SlbServer'] = request.slbServer;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHBaseSlbServer',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHBaseSlbServer(request: CreateHBaseSlbServerRequest): CreateHBaseSlbServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHBaseSlbServerWithOptions(request, runtime);
}

model CreateHbaseHaSlbRequest {
  bdsId?: string(name='BdsId'),
  clientToken?: string(name='ClientToken'),
  haId?: string(name='HaId'),
  haTypes?: string(name='HaTypes'),
  hbaseType?: string(name='HbaseType'),
}

model CreateHbaseHaSlbResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateHbaseHaSlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHbaseHaSlbResponseBody(name='body'),
}

async function createHbaseHaSlbWithOptions(request: CreateHbaseHaSlbRequest, runtime: Util.RuntimeOptions): CreateHbaseHaSlbResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bdsId)) {
    query['BdsId'] = request.bdsId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.haId)) {
    query['HaId'] = request.haId;
  }
  if (!Util.isUnset(request.haTypes)) {
    query['HaTypes'] = request.haTypes;
  }
  if (!Util.isUnset(request.hbaseType)) {
    query['HbaseType'] = request.hbaseType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHbaseHaSlb',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHbaseHaSlb(request: CreateHbaseHaSlbRequest): CreateHbaseHaSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHbaseHaSlbWithOptions(request, runtime);
}

model CreateMultiZoneClusterRequest {
  arbiterVSwitchId?: string(name='ArbiterVSwitchId'),
  arbiterZoneId?: string(name='ArbiterZoneId'),
  archVersion?: string(name='ArchVersion'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
  clientToken?: string(name='ClientToken'),
  clusterName?: string(name='ClusterName'),
  coreDiskSize?: int32(name='CoreDiskSize'),
  coreDiskType?: string(name='CoreDiskType'),
  coreInstanceType?: string(name='CoreInstanceType'),
  coreNodeCount?: int32(name='CoreNodeCount'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  logDiskSize?: int32(name='LogDiskSize'),
  logDiskType?: string(name='LogDiskType'),
  logInstanceType?: string(name='LogInstanceType'),
  logNodeCount?: int32(name='LogNodeCount'),
  masterInstanceType?: string(name='MasterInstanceType'),
  multiZoneCombination?: string(name='MultiZoneCombination'),
  payType?: string(name='PayType'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  primaryVSwitchId?: string(name='PrimaryVSwitchId'),
  primaryZoneId?: string(name='PrimaryZoneId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  securityIPList?: string(name='SecurityIPList'),
  standbyVSwitchId?: string(name='StandbyVSwitchId'),
  standbyZoneId?: string(name='StandbyZoneId'),
  vpcId?: string(name='VpcId'),
}

model CreateMultiZoneClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateMultiZoneClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMultiZoneClusterResponseBody(name='body'),
}

async function createMultiZoneClusterWithOptions(request: CreateMultiZoneClusterRequest, runtime: Util.RuntimeOptions): CreateMultiZoneClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.arbiterVSwitchId)) {
    query['ArbiterVSwitchId'] = request.arbiterVSwitchId;
  }
  if (!Util.isUnset(request.arbiterZoneId)) {
    query['ArbiterZoneId'] = request.arbiterZoneId;
  }
  if (!Util.isUnset(request.archVersion)) {
    query['ArchVersion'] = request.archVersion;
  }
  if (!Util.isUnset(request.autoRenewPeriod)) {
    query['AutoRenewPeriod'] = request.autoRenewPeriod;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.coreDiskSize)) {
    query['CoreDiskSize'] = request.coreDiskSize;
  }
  if (!Util.isUnset(request.coreDiskType)) {
    query['CoreDiskType'] = request.coreDiskType;
  }
  if (!Util.isUnset(request.coreInstanceType)) {
    query['CoreInstanceType'] = request.coreInstanceType;
  }
  if (!Util.isUnset(request.coreNodeCount)) {
    query['CoreNodeCount'] = request.coreNodeCount;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.logDiskSize)) {
    query['LogDiskSize'] = request.logDiskSize;
  }
  if (!Util.isUnset(request.logDiskType)) {
    query['LogDiskType'] = request.logDiskType;
  }
  if (!Util.isUnset(request.logInstanceType)) {
    query['LogInstanceType'] = request.logInstanceType;
  }
  if (!Util.isUnset(request.logNodeCount)) {
    query['LogNodeCount'] = request.logNodeCount;
  }
  if (!Util.isUnset(request.masterInstanceType)) {
    query['MasterInstanceType'] = request.masterInstanceType;
  }
  if (!Util.isUnset(request.multiZoneCombination)) {
    query['MultiZoneCombination'] = request.multiZoneCombination;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.primaryVSwitchId)) {
    query['PrimaryVSwitchId'] = request.primaryVSwitchId;
  }
  if (!Util.isUnset(request.primaryZoneId)) {
    query['PrimaryZoneId'] = request.primaryZoneId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.securityIPList)) {
    query['SecurityIPList'] = request.securityIPList;
  }
  if (!Util.isUnset(request.standbyVSwitchId)) {
    query['StandbyVSwitchId'] = request.standbyVSwitchId;
  }
  if (!Util.isUnset(request.standbyZoneId)) {
    query['StandbyZoneId'] = request.standbyZoneId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMultiZoneCluster',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMultiZoneCluster(request: CreateMultiZoneClusterRequest): CreateMultiZoneClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMultiZoneClusterWithOptions(request, runtime);
}

model CreateRestorePlanRequest {
  clusterId?: string(name='ClusterId'),
  restoreAllTable?: boolean(name='RestoreAllTable'),
  restoreByCopy?: boolean(name='RestoreByCopy'),
  restoreToDate?: string(name='RestoreToDate'),
  tables?: string(name='Tables'),
  targetClusterId?: string(name='TargetClusterId'),
}

model CreateRestorePlanResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateRestorePlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRestorePlanResponseBody(name='body'),
}

async function createRestorePlanWithOptions(request: CreateRestorePlanRequest, runtime: Util.RuntimeOptions): CreateRestorePlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.restoreAllTable)) {
    query['RestoreAllTable'] = request.restoreAllTable;
  }
  if (!Util.isUnset(request.restoreByCopy)) {
    query['RestoreByCopy'] = request.restoreByCopy;
  }
  if (!Util.isUnset(request.restoreToDate)) {
    query['RestoreToDate'] = request.restoreToDate;
  }
  if (!Util.isUnset(request.tables)) {
    query['Tables'] = request.tables;
  }
  if (!Util.isUnset(request.targetClusterId)) {
    query['TargetClusterId'] = request.targetClusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRestorePlan',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRestorePlan(request: CreateRestorePlanRequest): CreateRestorePlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRestorePlanWithOptions(request, runtime);
}

model CreateServerlessClusterRequest {
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
  clientToken?: string(name='ClientToken'),
  clientType?: string(name='ClientType'),
  clusterName?: string(name='ClusterName'),
  diskType?: string(name='DiskType'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  payType?: string(name='PayType'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  serverlessCapability?: int32(name='ServerlessCapability'),
  serverlessSpec?: string(name='ServerlessSpec'),
  serverlessStorage?: int32(name='ServerlessStorage'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model CreateServerlessClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  orderId?: string(name='OrderId'),
  passWord?: string(name='PassWord'),
  requestId?: string(name='RequestId'),
}

model CreateServerlessClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServerlessClusterResponseBody(name='body'),
}

async function createServerlessClusterWithOptions(request: CreateServerlessClusterRequest, runtime: Util.RuntimeOptions): CreateServerlessClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoRenewPeriod)) {
    query['AutoRenewPeriod'] = request.autoRenewPeriod;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clientType)) {
    query['ClientType'] = request.clientType;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.diskType)) {
    query['DiskType'] = request.diskType;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.serverlessCapability)) {
    query['ServerlessCapability'] = request.serverlessCapability;
  }
  if (!Util.isUnset(request.serverlessSpec)) {
    query['ServerlessSpec'] = request.serverlessSpec;
  }
  if (!Util.isUnset(request.serverlessStorage)) {
    query['ServerlessStorage'] = request.serverlessStorage;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateServerlessCluster',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createServerlessCluster(request: CreateServerlessClusterRequest): CreateServerlessClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServerlessClusterWithOptions(request, runtime);
}

model DeleteGlobalResourceRequest {
  clusterId?: string(name='ClusterId'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
}

model DeleteGlobalResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGlobalResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGlobalResourceResponseBody(name='body'),
}

async function deleteGlobalResourceWithOptions(request: DeleteGlobalResourceRequest, runtime: Util.RuntimeOptions): DeleteGlobalResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGlobalResource',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGlobalResource(request: DeleteGlobalResourceRequest): DeleteGlobalResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGlobalResourceWithOptions(request, runtime);
}

model DeleteHBaseHaDBRequest {
  bdsId?: string(name='BdsId'),
  haId?: string(name='HaId'),
}

model DeleteHBaseHaDBResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHBaseHaDBResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHBaseHaDBResponseBody(name='body'),
}

async function deleteHBaseHaDBWithOptions(request: DeleteHBaseHaDBRequest, runtime: Util.RuntimeOptions): DeleteHBaseHaDBResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bdsId)) {
    query['BdsId'] = request.bdsId;
  }
  if (!Util.isUnset(request.haId)) {
    query['HaId'] = request.haId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHBaseHaDB',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHBaseHaDB(request: DeleteHBaseHaDBRequest): DeleteHBaseHaDBResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHBaseHaDBWithOptions(request, runtime);
}

model DeleteHBaseSlbServerRequest {
  clusterId?: string(name='ClusterId'),
  slbServer?: string(name='SlbServer'),
}

model DeleteHBaseSlbServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHBaseSlbServerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHBaseSlbServerResponseBody(name='body'),
}

async function deleteHBaseSlbServerWithOptions(request: DeleteHBaseSlbServerRequest, runtime: Util.RuntimeOptions): DeleteHBaseSlbServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.slbServer)) {
    query['SlbServer'] = request.slbServer;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHBaseSlbServer',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHBaseSlbServer(request: DeleteHBaseSlbServerRequest): DeleteHBaseSlbServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHBaseSlbServerWithOptions(request, runtime);
}

model DeleteHbaseHaSlbRequest {
  bdsId?: string(name='BdsId'),
  haId?: string(name='HaId'),
  haTypes?: string(name='HaTypes'),
}

model DeleteHbaseHaSlbResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHbaseHaSlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHbaseHaSlbResponseBody(name='body'),
}

async function deleteHbaseHaSlbWithOptions(request: DeleteHbaseHaSlbRequest, runtime: Util.RuntimeOptions): DeleteHbaseHaSlbResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bdsId)) {
    query['BdsId'] = request.bdsId;
  }
  if (!Util.isUnset(request.haId)) {
    query['HaId'] = request.haId;
  }
  if (!Util.isUnset(request.haTypes)) {
    query['HaTypes'] = request.haTypes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHbaseHaSlb',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHbaseHaSlb(request: DeleteHbaseHaSlbRequest): DeleteHbaseHaSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHbaseHaSlbWithOptions(request, runtime);
}

model DeleteInstanceRequest {
  clusterId?: string(name='ClusterId'),
  immediateDeleteFlag?: boolean(name='ImmediateDeleteFlag'),
}

model DeleteInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstanceWithOptions(request: DeleteInstanceRequest, runtime: Util.RuntimeOptions): DeleteInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.immediateDeleteFlag)) {
    query['ImmediateDeleteFlag'] = request.immediateDeleteFlag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstance',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInstance(request: DeleteInstanceRequest): DeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstanceWithOptions(request, runtime);
}

model DeleteMultiZoneClusterRequest {
  clusterId?: string(name='ClusterId'),
  immediateDeleteFlag?: boolean(name='ImmediateDeleteFlag'),
}

model DeleteMultiZoneClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMultiZoneClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMultiZoneClusterResponseBody(name='body'),
}

async function deleteMultiZoneClusterWithOptions(request: DeleteMultiZoneClusterRequest, runtime: Util.RuntimeOptions): DeleteMultiZoneClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.immediateDeleteFlag)) {
    query['ImmediateDeleteFlag'] = request.immediateDeleteFlag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMultiZoneCluster',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMultiZoneCluster(request: DeleteMultiZoneClusterRequest): DeleteMultiZoneClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMultiZoneClusterWithOptions(request, runtime);
}

model DeleteServerlessClusterRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
}

model DeleteServerlessClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteServerlessClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServerlessClusterResponseBody(name='body'),
}

async function deleteServerlessClusterWithOptions(request: DeleteServerlessClusterRequest, runtime: Util.RuntimeOptions): DeleteServerlessClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServerlessCluster',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteServerlessCluster(request: DeleteServerlessClusterRequest): DeleteServerlessClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServerlessClusterWithOptions(request, runtime);
}

model DeleteUserHdfsInfoRequest {
  clusterId?: string(name='ClusterId'),
  nameService?: string(name='NameService'),
}

model DeleteUserHdfsInfoResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUserHdfsInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUserHdfsInfoResponseBody(name='body'),
}

async function deleteUserHdfsInfoWithOptions(request: DeleteUserHdfsInfoRequest, runtime: Util.RuntimeOptions): DeleteUserHdfsInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.nameService)) {
    query['NameService'] = request.nameService;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUserHdfsInfo',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUserHdfsInfo(request: DeleteUserHdfsInfoRequest): DeleteUserHdfsInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserHdfsInfoWithOptions(request, runtime);
}

model DescribeActiveOperationTaskTypeRequest {
  isHistory?: int32(name='IsHistory'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeActiveOperationTaskTypeResponseBody = {
  requestId?: string(name='RequestId'),
  typeList?: [ 
    {
      count?: int32(name='Count'),
      taskType?: string(name='TaskType'),
      taskTypeInfoEn?: string(name='TaskTypeInfoEn'),
      taskTypeInfoZh?: string(name='TaskTypeInfoZh'),
    }
  ](name='TypeList'),
}

model DescribeActiveOperationTaskTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeActiveOperationTaskTypeResponseBody(name='body'),
}

async function describeActiveOperationTaskTypeWithOptions(request: DescribeActiveOperationTaskTypeRequest, runtime: Util.RuntimeOptions): DescribeActiveOperationTaskTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.isHistory)) {
    query['IsHistory'] = request.isHistory;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeActiveOperationTaskType',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeActiveOperationTaskType(request: DescribeActiveOperationTaskTypeRequest): DescribeActiveOperationTaskTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeActiveOperationTaskTypeWithOptions(request, runtime);
}

model DescribeActiveOperationTasksRequest {
  allowCancel?: int32(name='AllowCancel'),
  allowChange?: int32(name='AllowChange'),
  changeLevel?: string(name='ChangeLevel'),
  dbType?: string(name='DbType'),
  insName?: string(name='InsName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  productId?: string(name='ProductId'),
  region?: string(name='Region'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  status?: int32(name='Status'),
  taskType?: string(name='TaskType'),
}

model DescribeActiveOperationTasksResponseBody = {
  items?: [ 
    {
      allowCancel?: string(name='AllowCancel'),
      allowChange?: string(name='AllowChange'),
      changeLevel?: string(name='ChangeLevel'),
      changeLevelEn?: string(name='ChangeLevelEn'),
      changeLevelZh?: string(name='ChangeLevelZh'),
      createdTime?: string(name='CreatedTime'),
      currentAVZ?: string(name='CurrentAVZ'),
      dbType?: string(name='DbType'),
      dbVersion?: string(name='DbVersion'),
      deadline?: string(name='Deadline'),
      id?: int32(name='Id'),
      impactEn?: string(name='ImpactEn'),
      impactZh?: string(name='ImpactZh'),
      insComment?: string(name='InsComment'),
      insName?: string(name='InsName'),
      modifiedTime?: string(name='ModifiedTime'),
      prepareInterval?: string(name='PrepareInterval'),
      region?: string(name='Region'),
      resultInfo?: string(name='ResultInfo'),
      startTime?: string(name='StartTime'),
      status?: int32(name='Status'),
      subInsNames?: [ string ](name='SubInsNames'),
      switchTime?: string(name='SwitchTime'),
      taskType?: string(name='TaskType'),
      taskTypeEn?: string(name='TaskTypeEn'),
      taskTypeZh?: string(name='TaskTypeZh'),
    }
  ](name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeActiveOperationTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeActiveOperationTasksResponseBody(name='body'),
}

async function describeActiveOperationTasksWithOptions(request: DescribeActiveOperationTasksRequest, runtime: Util.RuntimeOptions): DescribeActiveOperationTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allowCancel)) {
    query['AllowCancel'] = request.allowCancel;
  }
  if (!Util.isUnset(request.allowChange)) {
    query['AllowChange'] = request.allowChange;
  }
  if (!Util.isUnset(request.changeLevel)) {
    query['ChangeLevel'] = request.changeLevel;
  }
  if (!Util.isUnset(request.dbType)) {
    query['DbType'] = request.dbType;
  }
  if (!Util.isUnset(request.insName)) {
    query['InsName'] = request.insName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productId)) {
    query['ProductId'] = request.productId;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeActiveOperationTasks',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeActiveOperationTasks(request: DescribeActiveOperationTasksRequest): DescribeActiveOperationTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeActiveOperationTasksWithOptions(request, runtime);
}

model DescribeAvailableResourceRequest {
  chargeType?: string(name='ChargeType'),
  coreInstanceType?: string(name='CoreInstanceType'),
  diskType?: string(name='DiskType'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeAvailableResourceResponseBody = {
  availableZones?: {
    availableZone?: [ 
    {
      masterResources?: {
        masterResource?: [ 
        {
          instanceType?: string(name='InstanceType'),
          instanceTypeDetail?: {
            cpu?: int32(name='Cpu'),
            mem?: int32(name='Mem'),
          }(name='InstanceTypeDetail'),
        }
      ](name='MasterResource')
      }(name='MasterResources'),
      regionId?: string(name='RegionId'),
      supportedEngines?: {
        supportedEngine?: [ 
        {
          engine?: string(name='Engine'),
          supportedEngineVersions?: {
            supportedEngineVersion?: [ 
            {
              supportedCategories?: {
                supportedCategories?: [ 
                {
                  category?: string(name='Category'),
                  supportedStorageTypes?: {
                    supportedStorageType?: [ 
                    {
                      coreResources?: {
                        coreResource?: [ 
                        {
                          DBInstanceStorageRange?: {
                            maxSize?: int32(name='MaxSize'),
                            minSize?: int32(name='MinSize'),
                            stepSize?: int32(name='StepSize'),
                          }(name='DBInstanceStorageRange'),
                          instanceType?: string(name='InstanceType'),
                          instanceTypeDetail?: {
                            cpu?: int32(name='Cpu'),
                            mem?: int32(name='Mem'),
                          }(name='InstanceTypeDetail'),
                          maxCoreCount?: int32(name='MaxCoreCount'),
                        }
                      ](name='CoreResource')
                      }(name='CoreResources'),
                      storageType?: string(name='StorageType'),
                    }
                  ](name='SupportedStorageType')
                  }(name='SupportedStorageTypes'),
                }
              ](name='SupportedCategories')
              }(name='SupportedCategories'),
              version?: string(name='Version'),
            }
          ](name='SupportedEngineVersion')
          }(name='SupportedEngineVersions'),
        }
      ](name='SupportedEngine')
      }(name='SupportedEngines'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='AvailableZone')
  }(name='AvailableZones'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAvailableResourceResponseBody(name='body'),
}

async function describeAvailableResourceWithOptions(request: DescribeAvailableResourceRequest, runtime: Util.RuntimeOptions): DescribeAvailableResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.coreInstanceType)) {
    query['CoreInstanceType'] = request.coreInstanceType;
  }
  if (!Util.isUnset(request.diskType)) {
    query['DiskType'] = request.diskType;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAvailableResource',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAvailableResource(request: DescribeAvailableResourceRequest): DescribeAvailableResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableResourceWithOptions(request, runtime);
}

model DescribeBackupPlanConfigRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeBackupPlanConfigResponseBody = {
  fullBackupCycle?: int32(name='FullBackupCycle'),
  minHFileBackupCount?: int32(name='MinHFileBackupCount'),
  nextFullBackupDate?: string(name='NextFullBackupDate'),
  requestId?: string(name='RequestId'),
  tables?: {
    table?: [ string ](name='Table')
  }(name='Tables'),
}

model DescribeBackupPlanConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupPlanConfigResponseBody(name='body'),
}

async function describeBackupPlanConfigWithOptions(request: DescribeBackupPlanConfigRequest, runtime: Util.RuntimeOptions): DescribeBackupPlanConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupPlanConfig',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupPlanConfig(request: DescribeBackupPlanConfigRequest): DescribeBackupPlanConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupPlanConfigWithOptions(request, runtime);
}

model DescribeBackupPolicyRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeBackupPolicyResponseBody = {
  backupRetentionPeriod?: string(name='BackupRetentionPeriod'),
  preferredBackupEndTimeUTC?: string(name='PreferredBackupEndTimeUTC'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod'),
  preferredBackupStartTimeUTC?: string(name='PreferredBackupStartTimeUTC'),
  preferredBackupTime?: string(name='PreferredBackupTime'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupPolicyResponseBody(name='body'),
}

async function describeBackupPolicyWithOptions(request: DescribeBackupPolicyRequest, runtime: Util.RuntimeOptions): DescribeBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupPolicy',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupPolicy(request: DescribeBackupPolicyRequest): DescribeBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupPolicyWithOptions(request, runtime);
}

model DescribeBackupStatusRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeBackupStatusResponseBody = {
  backupStatus?: string(name='BackupStatus'),
  bdsClusterId?: string(name='BdsClusterId'),
  clusterId?: string(name='ClusterId'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupStatusResponseBody(name='body'),
}

async function describeBackupStatusWithOptions(request: DescribeBackupStatusRequest, runtime: Util.RuntimeOptions): DescribeBackupStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupStatus',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupStatus(request: DescribeBackupStatusRequest): DescribeBackupStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupStatusWithOptions(request, runtime);
}

model DescribeBackupSummaryRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeBackupSummaryResponseBody = {
  full?: {
    hasMore?: string(name='HasMore'),
    nextFullBackupDate?: string(name='NextFullBackupDate'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    records?: {
      record?: [ 
      {
        createTime?: string(name='CreateTime'),
        dataSize?: string(name='DataSize'),
        finishTime?: string(name='FinishTime'),
        process?: string(name='Process'),
        recordId?: string(name='RecordId'),
        speed?: string(name='Speed'),
        status?: string(name='Status'),
      }
    ](name='Record')
    }(name='Records'),
    total?: int32(name='Total'),
  }(name='Full'),
  incr?: {
    backupLogSize?: string(name='BackupLogSize'),
    pos?: string(name='Pos'),
    queueLogNum?: string(name='QueueLogNum'),
    runningLogNum?: string(name='RunningLogNum'),
    speed?: string(name='Speed'),
    status?: string(name='Status'),
  }(name='Incr'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupSummaryResponseBody(name='body'),
}

async function describeBackupSummaryWithOptions(request: DescribeBackupSummaryRequest, runtime: Util.RuntimeOptions): DescribeBackupSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupSummary',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupSummary(request: DescribeBackupSummaryRequest): DescribeBackupSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupSummaryWithOptions(request, runtime);
}

model DescribeBackupTablesRequest {
  backupRecordId?: string(name='BackupRecordId'),
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeBackupTablesResponseBody = {
  backupRecords?: {
    backupRecord?: [ 
    {
      dataSize?: string(name='DataSize'),
      endTime?: string(name='EndTime'),
      message?: string(name='Message'),
      process?: string(name='Process'),
      speed?: string(name='Speed'),
      startTime?: string(name='StartTime'),
      state?: string(name='State'),
      table?: string(name='Table'),
    }
  ](name='BackupRecord')
  }(name='BackupRecords'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  tables?: {
    table?: [ string ](name='Table')
  }(name='Tables'),
  total?: long(name='Total'),
}

model DescribeBackupTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupTablesResponseBody(name='body'),
}

async function describeBackupTablesWithOptions(request: DescribeBackupTablesRequest, runtime: Util.RuntimeOptions): DescribeBackupTablesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupRecordId)) {
    query['BackupRecordId'] = request.backupRecordId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupTables',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupTables(request: DescribeBackupTablesRequest): DescribeBackupTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupTablesWithOptions(request, runtime);
}

model DescribeBackupsRequest {
  backupId?: string(name='BackupId'),
  clusterId?: string(name='ClusterId'),
  endTime?: string(name='EndTime'),
  endTimeUTC?: string(name='EndTimeUTC'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  startTime?: string(name='StartTime'),
  startTimeUTC?: string(name='StartTimeUTC'),
}

model DescribeBackupsResponseBody = {
  backups?: {
    backup?: [ 
    {
      backupDBNames?: string(name='BackupDBNames'),
      backupDownloadURL?: string(name='BackupDownloadURL'),
      backupEndTime?: string(name='BackupEndTime'),
      backupEndTimeUTC?: string(name='BackupEndTimeUTC'),
      backupId?: int32(name='BackupId'),
      backupMethod?: string(name='BackupMethod'),
      backupMode?: string(name='BackupMode'),
      backupSize?: string(name='BackupSize'),
      backupStartTime?: string(name='BackupStartTime'),
      backupStartTimeUTC?: string(name='BackupStartTimeUTC'),
      backupStatus?: string(name='BackupStatus'),
      backupType?: string(name='BackupType'),
    }
  ](name='Backup')
  }(name='Backups'),
  enableStatus?: string(name='EnableStatus'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBackupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupsResponseBody(name='body'),
}

async function describeBackupsWithOptions(request: DescribeBackupsRequest, runtime: Util.RuntimeOptions): DescribeBackupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.endTimeUTC)) {
    query['EndTimeUTC'] = request.endTimeUTC;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.startTimeUTC)) {
    query['StartTimeUTC'] = request.startTimeUTC;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackups',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackups(request: DescribeBackupsRequest): DescribeBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupsWithOptions(request, runtime);
}

model DescribeClusterConnectionRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
}

model DescribeClusterConnectionResponseBody = {
  dbType?: string(name='DbType'),
  isMultimod?: string(name='IsMultimod'),
  netType?: string(name='NetType'),
  requestId?: string(name='RequestId'),
  serviceConnAddrs?: {
    serviceConnAddr?: [ 
    {
      connAddrInfo?: {
        connAddr?: string(name='ConnAddr'),
        connAddrPort?: string(name='ConnAddrPort'),
        netType?: string(name='NetType'),
      }(name='ConnAddrInfo'),
      connType?: string(name='ConnType'),
    }
  ](name='ServiceConnAddr')
  }(name='ServiceConnAddrs'),
  slbConnAddrs?: {
    slbConnAddr?: [ 
    {
      connAddrInfo?: {
        connAddr?: string(name='ConnAddr'),
        connAddrPort?: string(name='ConnAddrPort'),
        netType?: string(name='NetType'),
      }(name='ConnAddrInfo'),
      slbType?: string(name='SlbType'),
    }
  ](name='SlbConnAddr')
  }(name='SlbConnAddrs'),
  thriftConn?: {
    connAddr?: string(name='ConnAddr'),
    connAddrPort?: string(name='ConnAddrPort'),
    netType?: string(name='NetType'),
  }(name='ThriftConn'),
  uiProxyConnAddrInfo?: {
    connAddr?: string(name='ConnAddr'),
    connAddrPort?: string(name='ConnAddrPort'),
    netType?: string(name='NetType'),
  }(name='UiProxyConnAddrInfo'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zkConnAddrs?: {
    zkConnAddr?: [ 
    {
      connAddr?: string(name='ConnAddr'),
      connAddrPort?: string(name='ConnAddrPort'),
      netType?: string(name='NetType'),
    }
  ](name='ZkConnAddr')
  }(name='ZkConnAddrs'),
}

model DescribeClusterConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterConnectionResponseBody(name='body'),
}

async function describeClusterConnectionWithOptions(request: DescribeClusterConnectionRequest, runtime: Util.RuntimeOptions): DescribeClusterConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterConnection',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterConnection(request: DescribeClusterConnectionRequest): DescribeClusterConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterConnectionWithOptions(request, runtime);
}

model DescribeColdStorageRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeColdStorageResponseBody = {
  clusterId?: string(name='ClusterId'),
  coldStorageSize?: string(name='ColdStorageSize'),
  coldStorageType?: string(name='ColdStorageType'),
  coldStorageUseAmount?: string(name='ColdStorageUseAmount'),
  coldStorageUsePercent?: string(name='ColdStorageUsePercent'),
  openStatus?: string(name='OpenStatus'),
  payType?: string(name='PayType'),
  requestId?: string(name='RequestId'),
}

model DescribeColdStorageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeColdStorageResponseBody(name='body'),
}

async function describeColdStorageWithOptions(request: DescribeColdStorageRequest, runtime: Util.RuntimeOptions): DescribeColdStorageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeColdStorage',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeColdStorage(request: DescribeColdStorageRequest): DescribeColdStorageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeColdStorageWithOptions(request, runtime);
}

model DescribeDBInstanceUsageRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeDBInstanceUsageResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DescribeDBInstanceUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceUsageResponseBody(name='body'),
}

async function describeDBInstanceUsageWithOptions(request: DescribeDBInstanceUsageRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceUsage',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstanceUsage(request: DescribeDBInstanceUsageRequest): DescribeDBInstanceUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceUsageWithOptions(request, runtime);
}

model DescribeDeletedInstancesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model DescribeDeletedInstancesResponseBody = {
  instances?: {
    instance?: [ 
    {
      clusterType?: string(name='ClusterType'),
      createdTime?: string(name='CreatedTime'),
      deleteTime?: string(name='DeleteTime'),
      engine?: string(name='Engine'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      majorVersion?: string(name='MajorVersion'),
      moduleStackVersion?: string(name='ModuleStackVersion'),
      parentId?: string(name='ParentId'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Instance')
  }(name='Instances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDeletedInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDeletedInstancesResponseBody(name='body'),
}

async function describeDeletedInstancesWithOptions(request: DescribeDeletedInstancesRequest, runtime: Util.RuntimeOptions): DescribeDeletedInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDeletedInstances',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDeletedInstances(request: DescribeDeletedInstancesRequest): DescribeDeletedInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDeletedInstancesWithOptions(request, runtime);
}

model DescribeDiskWarningLineRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeDiskWarningLineResponseBody = {
  requestId?: string(name='RequestId'),
  warningLine?: string(name='WarningLine'),
}

model DescribeDiskWarningLineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDiskWarningLineResponseBody(name='body'),
}

async function describeDiskWarningLineWithOptions(request: DescribeDiskWarningLineRequest, runtime: Util.RuntimeOptions): DescribeDiskWarningLineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDiskWarningLine',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDiskWarningLine(request: DescribeDiskWarningLineRequest): DescribeDiskWarningLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDiskWarningLineWithOptions(request, runtime);
}

model DescribeEndpointsRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeEndpointsResponseBody = {
  connAddrs?: {
    connAddrInfo?: [ 
    {
      connAddr?: string(name='ConnAddr'),
      connAddrPort?: string(name='ConnAddrPort'),
      connType?: string(name='ConnType'),
      netType?: string(name='NetType'),
    }
  ](name='ConnAddrInfo')
  }(name='ConnAddrs'),
  engine?: string(name='Engine'),
  netType?: string(name='NetType'),
  requestId?: string(name='RequestId'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model DescribeEndpointsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEndpointsResponseBody(name='body'),
}

async function describeEndpointsWithOptions(request: DescribeEndpointsRequest, runtime: Util.RuntimeOptions): DescribeEndpointsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEndpoints',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEndpoints(request: DescribeEndpointsRequest): DescribeEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEndpointsWithOptions(request, runtime);
}

model DescribeInstanceRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeInstanceResponseBody = {
  autoRenewal?: boolean(name='AutoRenewal'),
  backupStatus?: string(name='BackupStatus'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  clusterType?: string(name='ClusterType'),
  coldStorageSize?: int32(name='ColdStorageSize'),
  coldStorageStatus?: string(name='ColdStorageStatus'),
  confirmMaintainTime?: string(name='ConfirmMaintainTime'),
  coreDiskCount?: string(name='CoreDiskCount'),
  coreDiskSize?: int32(name='CoreDiskSize'),
  coreDiskType?: string(name='CoreDiskType'),
  coreInstanceType?: string(name='CoreInstanceType'),
  coreNodeCount?: int32(name='CoreNodeCount'),
  createdTime?: string(name='CreatedTime'),
  createdTimeUTC?: string(name='CreatedTimeUTC'),
  duration?: int32(name='Duration'),
  enableHbaseProxy?: boolean(name='EnableHbaseProxy'),
  encryptionKey?: string(name='EncryptionKey'),
  encryptionType?: string(name='EncryptionType'),
  engine?: string(name='Engine'),
  expireTime?: string(name='ExpireTime'),
  expireTimeUTC?: string(name='ExpireTimeUTC'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  isDeletionProtection?: boolean(name='IsDeletionProtection'),
  isHa?: boolean(name='IsHa'),
  isLatestVersion?: boolean(name='IsLatestVersion'),
  isMultiModel?: boolean(name='IsMultiModel'),
  lproxyMinorVersion?: string(name='LproxyMinorVersion'),
  maintainEndTime?: string(name='MaintainEndTime'),
  maintainStartTime?: string(name='MaintainStartTime'),
  majorVersion?: string(name='MajorVersion'),
  masterDiskSize?: int32(name='MasterDiskSize'),
  masterDiskType?: string(name='MasterDiskType'),
  masterInstanceType?: string(name='MasterInstanceType'),
  masterNodeCount?: int32(name='MasterNodeCount'),
  minorVersion?: string(name='MinorVersion'),
  moduleId?: int32(name='ModuleId'),
  moduleStackVersion?: string(name='ModuleStackVersion'),
  needUpgrade?: boolean(name='NeedUpgrade'),
  needUpgradeComps?: {
    comps?: [ string ](name='Comps')
  }(name='NeedUpgradeComps'),
  networkType?: string(name='NetworkType'),
  parentId?: string(name='ParentId'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  status?: string(name='Status'),
  tags?: {
    tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag')
  }(name='Tags'),
  taskProgress?: string(name='TaskProgress'),
  vpcId?: string(name='VpcId'),
  vswitchId?: string(name='VswitchId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceResponseBody(name='body'),
}

async function describeInstanceWithOptions(request: DescribeInstanceRequest, runtime: Util.RuntimeOptions): DescribeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstance',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstance(request: DescribeInstanceRequest): DescribeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceWithOptions(request, runtime);
}

model DescribeInstanceTypeRequest {
  instanceType?: string(name='InstanceType'),
}

model DescribeInstanceTypeResponseBody = {
  instanceTypeSpecList?: {
    instanceTypeSpec?: [ 
    {
      cpuSize?: long(name='CpuSize'),
      instanceType?: string(name='InstanceType'),
      memSize?: long(name='MemSize'),
    }
  ](name='InstanceTypeSpec')
  }(name='InstanceTypeSpecList'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceTypeResponseBody(name='body'),
}

async function describeInstanceTypeWithOptions(request: DescribeInstanceTypeRequest, runtime: Util.RuntimeOptions): DescribeInstanceTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceType',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceType(request: DescribeInstanceTypeRequest): DescribeInstanceTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceTypeWithOptions(request, runtime);
}

model DescribeInstancesRequest {
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  dbType?: string(name='DbType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model DescribeInstancesResponseBody = {
  instances?: {
    instance?: [ 
    {
      autoRenewal?: boolean(name='AutoRenewal'),
      backupStatus?: string(name='BackupStatus'),
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      coldStorageStatus?: string(name='ColdStorageStatus'),
      coreDiskCount?: string(name='CoreDiskCount'),
      coreDiskSize?: int32(name='CoreDiskSize'),
      coreDiskType?: string(name='CoreDiskType'),
      coreInstanceType?: string(name='CoreInstanceType'),
      coreNodeCount?: int32(name='CoreNodeCount'),
      createdTime?: string(name='CreatedTime'),
      createdTimeUTC?: string(name='CreatedTimeUTC'),
      duration?: int32(name='Duration'),
      engine?: string(name='Engine'),
      expireTime?: string(name='ExpireTime'),
      expireTimeUTC?: string(name='ExpireTimeUTC'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isDeletionProtection?: boolean(name='IsDeletionProtection'),
      isHa?: boolean(name='IsHa'),
      majorVersion?: string(name='MajorVersion'),
      masterDiskSize?: int32(name='MasterDiskSize'),
      masterDiskType?: string(name='MasterDiskType'),
      masterInstanceType?: string(name='MasterInstanceType'),
      masterNodeCount?: int32(name='MasterNodeCount'),
      moduleId?: int32(name='ModuleId'),
      moduleStackVersion?: string(name='ModuleStackVersion'),
      networkType?: string(name='NetworkType'),
      parentId?: string(name='ParentId'),
      payType?: string(name='PayType'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vpcId?: string(name='VpcId'),
      vswitchId?: string(name='VswitchId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Instance')
  }(name='Instances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstancesResponseBody(name='body'),
}

async function describeInstancesWithOptions(request: DescribeInstancesRequest, runtime: Util.RuntimeOptions): DescribeInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.dbType)) {
    query['DbType'] = request.dbType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstances',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstances(request: DescribeInstancesRequest): DescribeInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstancesWithOptions(request, runtime);
}

model DescribeIpWhitelistRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeIpWhitelistResponseBody = {
  groups?: {
    group?: [ 
    {
      groupName?: string(name='GroupName'),
      ipList?: {
        ip?: [ string ](name='Ip')
      }(name='IpList'),
      ipVersion?: int32(name='IpVersion'),
    }
  ](name='Group')
  }(name='Groups'),
  requestId?: string(name='RequestId'),
}

model DescribeIpWhitelistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIpWhitelistResponseBody(name='body'),
}

async function describeIpWhitelistWithOptions(request: DescribeIpWhitelistRequest, runtime: Util.RuntimeOptions): DescribeIpWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIpWhitelist',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIpWhitelist(request: DescribeIpWhitelistRequest): DescribeIpWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpWhitelistWithOptions(request, runtime);
}

model DescribeMultiZoneAvailableRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model DescribeMultiZoneAvailableRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      availableCombines?: {
        availableCombine?: [ 
        {
          id?: string(name='Id'),
          zones?: {
            zone?: [ string ](name='Zone')
          }(name='Zones'),
        }
      ](name='AvailableCombine')
      }(name='AvailableCombines'),
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeMultiZoneAvailableRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMultiZoneAvailableRegionsResponseBody(name='body'),
}

async function describeMultiZoneAvailableRegionsWithOptions(request: DescribeMultiZoneAvailableRegionsRequest, runtime: Util.RuntimeOptions): DescribeMultiZoneAvailableRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMultiZoneAvailableRegions',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMultiZoneAvailableRegions(request: DescribeMultiZoneAvailableRegionsRequest): DescribeMultiZoneAvailableRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMultiZoneAvailableRegionsWithOptions(request, runtime);
}

model DescribeMultiZoneAvailableResourceRequest {
  chargeType?: string(name='ChargeType'),
  regionId?: string(name='RegionId'),
  zoneCombination?: string(name='ZoneCombination'),
}

model DescribeMultiZoneAvailableResourceResponseBody = {
  availableZones?: {
    availableZone?: [ 
    {
      masterResources?: {
        masterResource?: [ 
        {
          instanceType?: string(name='InstanceType'),
          instanceTypeDetail?: {
            cpu?: int32(name='Cpu'),
            mem?: int32(name='Mem'),
          }(name='InstanceTypeDetail'),
        }
      ](name='MasterResource')
      }(name='MasterResources'),
      regionId?: string(name='RegionId'),
      supportedEngines?: {
        supportedEngine?: [ 
        {
          engine?: string(name='Engine'),
          supportedEngineVersions?: {
            supportedEngineVersion?: [ 
            {
              supportedCategories?: {
                supportedCategories?: [ 
                {
                  category?: string(name='Category'),
                  supportedStorageTypes?: {
                    supportedStorageType?: [ 
                    {
                      coreResources?: {
                        coreResource?: [ 
                        {
                          DBInstanceStorageRange?: {
                            maxSize?: int32(name='MaxSize'),
                            minSize?: int32(name='MinSize'),
                            stepSize?: int32(name='StepSize'),
                          }(name='DBInstanceStorageRange'),
                          instanceType?: string(name='InstanceType'),
                          instanceTypeDetail?: {
                            cpu?: int32(name='Cpu'),
                            mem?: int32(name='Mem'),
                          }(name='InstanceTypeDetail'),
                          maxCoreCount?: int32(name='MaxCoreCount'),
                        }
                      ](name='CoreResource')
                      }(name='CoreResources'),
                      storageType?: string(name='StorageType'),
                    }
                  ](name='SupportedStorageType')
                  }(name='SupportedStorageTypes'),
                }
              ](name='SupportedCategories')
              }(name='SupportedCategories'),
              version?: string(name='Version'),
            }
          ](name='SupportedEngineVersion')
          }(name='SupportedEngineVersions'),
        }
      ](name='SupportedEngine')
      }(name='SupportedEngines'),
      zoneCombination?: string(name='ZoneCombination'),
    }
  ](name='AvailableZone')
  }(name='AvailableZones'),
  requestId?: string(name='RequestId'),
}

model DescribeMultiZoneAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMultiZoneAvailableResourceResponseBody(name='body'),
}

async function describeMultiZoneAvailableResourceWithOptions(request: DescribeMultiZoneAvailableResourceRequest, runtime: Util.RuntimeOptions): DescribeMultiZoneAvailableResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.zoneCombination)) {
    query['ZoneCombination'] = request.zoneCombination;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMultiZoneAvailableResource',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMultiZoneAvailableResource(request: DescribeMultiZoneAvailableResourceRequest): DescribeMultiZoneAvailableResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMultiZoneAvailableResourceWithOptions(request, runtime);
}

model DescribeMultiZoneClusterRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeMultiZoneClusterResponseBody = {
  arbiterVSwitchIds?: string(name='ArbiterVSwitchIds'),
  arbiterZoneId?: string(name='ArbiterZoneId'),
  autoRenewal?: boolean(name='AutoRenewal'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  coreDiskCount?: string(name='CoreDiskCount'),
  coreDiskSize?: int32(name='CoreDiskSize'),
  coreDiskType?: string(name='CoreDiskType'),
  coreInstanceType?: string(name='CoreInstanceType'),
  coreNodeCount?: int32(name='CoreNodeCount'),
  createdTime?: string(name='CreatedTime'),
  createdTimeUTC?: string(name='CreatedTimeUTC'),
  duration?: int32(name='Duration'),
  encryptionKey?: string(name='EncryptionKey'),
  encryptionType?: string(name='EncryptionType'),
  engine?: string(name='Engine'),
  expireTime?: string(name='ExpireTime'),
  expireTimeUTC?: string(name='ExpireTimeUTC'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  isDeletionProtection?: boolean(name='IsDeletionProtection'),
  logDiskCount?: string(name='LogDiskCount'),
  logDiskSize?: int32(name='LogDiskSize'),
  logDiskType?: string(name='LogDiskType'),
  logInstanceType?: string(name='LogInstanceType'),
  logNodeCount?: int32(name='LogNodeCount'),
  maintainEndTime?: string(name='MaintainEndTime'),
  maintainStartTime?: string(name='MaintainStartTime'),
  majorVersion?: string(name='MajorVersion'),
  masterDiskSize?: int32(name='MasterDiskSize'),
  masterDiskType?: string(name='MasterDiskType'),
  masterInstanceType?: string(name='MasterInstanceType'),
  masterNodeCount?: int32(name='MasterNodeCount'),
  moduleId?: int32(name='ModuleId'),
  moduleStackVersion?: string(name='ModuleStackVersion'),
  multiZoneCombination?: string(name='MultiZoneCombination'),
  multiZoneInstanceModels?: {
    multiZoneInstanceModel?: [ 
    {
      insName?: string(name='InsName'),
      isLatestVersion?: boolean(name='IsLatestVersion'),
      minorVersion?: string(name='MinorVersion'),
      role?: string(name='Role'),
      status?: string(name='Status'),
    }
  ](name='MultiZoneInstanceModel')
  }(name='MultiZoneInstanceModels'),
  networkType?: string(name='NetworkType'),
  parentId?: string(name='ParentId'),
  payType?: string(name='PayType'),
  primaryVSwitchIds?: string(name='PrimaryVSwitchIds'),
  primaryZoneId?: string(name='PrimaryZoneId'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  standbyVSwitchIds?: string(name='StandbyVSwitchIds'),
  standbyZoneId?: string(name='StandbyZoneId'),
  status?: string(name='Status'),
  tags?: {
    tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag')
  }(name='Tags'),
  vpcId?: string(name='VpcId'),
}

model DescribeMultiZoneClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMultiZoneClusterResponseBody(name='body'),
}

async function describeMultiZoneClusterWithOptions(request: DescribeMultiZoneClusterRequest, runtime: Util.RuntimeOptions): DescribeMultiZoneClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMultiZoneCluster',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMultiZoneCluster(request: DescribeMultiZoneClusterRequest): DescribeMultiZoneClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMultiZoneClusterWithOptions(request, runtime);
}

model DescribeRecoverableTimeRangeRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeRecoverableTimeRangeResponseBody = {
  requestId?: string(name='RequestId'),
  timeBegin?: string(name='TimeBegin'),
  timeEnd?: string(name='TimeEnd'),
}

model DescribeRecoverableTimeRangeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRecoverableTimeRangeResponseBody(name='body'),
}

async function describeRecoverableTimeRangeWithOptions(request: DescribeRecoverableTimeRangeRequest, runtime: Util.RuntimeOptions): DescribeRecoverableTimeRangeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRecoverableTimeRange',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRecoverableTimeRange(request: DescribeRecoverableTimeRangeRequest): DescribeRecoverableTimeRangeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecoverableTimeRangeWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  engine?: string(name='Engine'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
      zones?: {
        zone?: [ 
        {
          id?: string(name='Id'),
        }
      ](name='Zone')
      }(name='Zones'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeRestoreFullDetailsRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  restoreRecordId?: string(name='RestoreRecordId'),
}

model DescribeRestoreFullDetailsResponseBody = {
  requestId?: string(name='RequestId'),
  restoreFull?: {
    dataSize?: string(name='DataSize'),
    fail?: int32(name='Fail'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    restoreFullDetails?: {
      restoreFullDetail?: [ 
      {
        dataSize?: string(name='DataSize'),
        endTime?: string(name='EndTime'),
        message?: string(name='Message'),
        process?: string(name='Process'),
        speed?: string(name='Speed'),
        startTime?: string(name='StartTime'),
        state?: string(name='State'),
        table?: string(name='Table'),
      }
    ](name='RestoreFullDetail')
    }(name='RestoreFullDetails'),
    speed?: string(name='Speed'),
    succeed?: int32(name='Succeed'),
    total?: long(name='Total'),
  }(name='RestoreFull'),
}

model DescribeRestoreFullDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRestoreFullDetailsResponseBody(name='body'),
}

async function describeRestoreFullDetailsWithOptions(request: DescribeRestoreFullDetailsRequest, runtime: Util.RuntimeOptions): DescribeRestoreFullDetailsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.restoreRecordId)) {
    query['RestoreRecordId'] = request.restoreRecordId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRestoreFullDetails',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRestoreFullDetails(request: DescribeRestoreFullDetailsRequest): DescribeRestoreFullDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRestoreFullDetailsWithOptions(request, runtime);
}

model DescribeRestoreIncrDetailRequest {
  clusterId?: string(name='ClusterId'),
  restoreRecordId?: string(name='RestoreRecordId'),
}

model DescribeRestoreIncrDetailResponseBody = {
  requestId?: string(name='RequestId'),
  restoreIncrDetail?: {
    endTime?: string(name='EndTime'),
    process?: string(name='Process'),
    restoreDelay?: string(name='RestoreDelay'),
    restoreStartTs?: string(name='RestoreStartTs'),
    restoredTs?: string(name='RestoredTs'),
    startTime?: string(name='StartTime'),
    state?: string(name='State'),
  }(name='RestoreIncrDetail'),
}

model DescribeRestoreIncrDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRestoreIncrDetailResponseBody(name='body'),
}

async function describeRestoreIncrDetailWithOptions(request: DescribeRestoreIncrDetailRequest, runtime: Util.RuntimeOptions): DescribeRestoreIncrDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.restoreRecordId)) {
    query['RestoreRecordId'] = request.restoreRecordId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRestoreIncrDetail',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRestoreIncrDetail(request: DescribeRestoreIncrDetailRequest): DescribeRestoreIncrDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRestoreIncrDetailWithOptions(request, runtime);
}

model DescribeRestoreSchemaDetailsRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  restoreRecordId?: string(name='RestoreRecordId'),
}

model DescribeRestoreSchemaDetailsResponseBody = {
  requestId?: string(name='RequestId'),
  restoreSchema?: {
    fail?: int32(name='Fail'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    restoreSchemaDetails?: {
      restoreSchemaDetail?: [ 
      {
        endTime?: string(name='EndTime'),
        message?: string(name='Message'),
        startTime?: string(name='StartTime'),
        state?: string(name='State'),
        table?: string(name='Table'),
      }
    ](name='RestoreSchemaDetail')
    }(name='RestoreSchemaDetails'),
    succeed?: int32(name='Succeed'),
    total?: long(name='Total'),
  }(name='RestoreSchema'),
}

model DescribeRestoreSchemaDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRestoreSchemaDetailsResponseBody(name='body'),
}

async function describeRestoreSchemaDetailsWithOptions(request: DescribeRestoreSchemaDetailsRequest, runtime: Util.RuntimeOptions): DescribeRestoreSchemaDetailsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.restoreRecordId)) {
    query['RestoreRecordId'] = request.restoreRecordId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRestoreSchemaDetails',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRestoreSchemaDetails(request: DescribeRestoreSchemaDetailsRequest): DescribeRestoreSchemaDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRestoreSchemaDetailsWithOptions(request, runtime);
}

model DescribeRestoreSummaryRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeRestoreSummaryResponseBody = {
  hasMoreRestoreRecord?: int32(name='HasMoreRestoreRecord'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  rescords?: {
    rescord?: [ 
    {
      bulkLoadProcess?: string(name='BulkLoadProcess'),
      createTime?: string(name='CreateTime'),
      finishTime?: string(name='FinishTime'),
      hfileRestoreProcess?: string(name='HfileRestoreProcess'),
      logProcess?: string(name='LogProcess'),
      recordId?: string(name='RecordId'),
      schemaProcess?: string(name='SchemaProcess'),
      status?: string(name='Status'),
    }
  ](name='Rescord')
  }(name='Rescords'),
  total?: int32(name='Total'),
}

model DescribeRestoreSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRestoreSummaryResponseBody(name='body'),
}

async function describeRestoreSummaryWithOptions(request: DescribeRestoreSummaryRequest, runtime: Util.RuntimeOptions): DescribeRestoreSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRestoreSummary',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRestoreSummary(request: DescribeRestoreSummaryRequest): DescribeRestoreSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRestoreSummaryWithOptions(request, runtime);
}

model DescribeRestoreTablesRequest {
  clusterId?: string(name='ClusterId'),
  restoreRecordId?: string(name='RestoreRecordId'),
}

model DescribeRestoreTablesResponseBody = {
  requestId?: string(name='RequestId'),
  restoreFull?: {
    dataSize?: string(name='DataSize'),
    fail?: int32(name='Fail'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    restoreFullDetails?: {
      restoreFullDetail?: [ 
      {
        dataSize?: string(name='DataSize'),
        endTime?: string(name='EndTime'),
        message?: string(name='Message'),
        process?: string(name='Process'),
        speed?: string(name='Speed'),
        startTime?: string(name='StartTime'),
        state?: string(name='State'),
        table?: string(name='Table'),
      }
    ](name='RestoreFullDetail')
    }(name='RestoreFullDetails'),
    speed?: string(name='Speed'),
    succeed?: int32(name='Succeed'),
    total?: long(name='Total'),
  }(name='RestoreFull'),
  restoreIncrDetail?: {
    endTime?: string(name='EndTime'),
    process?: string(name='Process'),
    restoreDelay?: string(name='RestoreDelay'),
    restoreStartTs?: string(name='RestoreStartTs'),
    restoredTs?: string(name='RestoredTs'),
    startTime?: string(name='StartTime'),
    state?: string(name='State'),
  }(name='RestoreIncrDetail'),
  restoreSchema?: {
    fail?: int32(name='Fail'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    restoreSchemaDetails?: {
      restoreSchemaDetail?: [ 
      {
        endTime?: string(name='EndTime'),
        message?: string(name='Message'),
        startTime?: string(name='StartTime'),
        state?: string(name='State'),
        table?: string(name='Table'),
      }
    ](name='RestoreSchemaDetail')
    }(name='RestoreSchemaDetails'),
    succeed?: int32(name='Succeed'),
    total?: long(name='Total'),
  }(name='RestoreSchema'),
  restoreSummary?: {
    endTime?: string(name='EndTime'),
    recordId?: string(name='RecordId'),
    restoreToDate?: string(name='RestoreToDate'),
    startTime?: string(name='StartTime'),
    state?: string(name='State'),
    targetCluster?: string(name='TargetCluster'),
  }(name='RestoreSummary'),
  tables?: {
    table?: [ string ](name='Table')
  }(name='Tables'),
}

model DescribeRestoreTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRestoreTablesResponseBody(name='body'),
}

async function describeRestoreTablesWithOptions(request: DescribeRestoreTablesRequest, runtime: Util.RuntimeOptions): DescribeRestoreTablesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.restoreRecordId)) {
    query['RestoreRecordId'] = request.restoreRecordId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRestoreTables',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRestoreTables(request: DescribeRestoreTablesRequest): DescribeRestoreTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRestoreTablesWithOptions(request, runtime);
}

model DescribeSecurityGroupsRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeSecurityGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  securityGroupIds?: {
    securityGroupId?: [ string ](name='SecurityGroupId')
  }(name='SecurityGroupIds'),
}

model DescribeSecurityGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSecurityGroupsResponseBody(name='body'),
}

async function describeSecurityGroupsWithOptions(request: DescribeSecurityGroupsRequest, runtime: Util.RuntimeOptions): DescribeSecurityGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityGroups',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSecurityGroups(request: DescribeSecurityGroupsRequest): DescribeSecurityGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityGroupsWithOptions(request, runtime);
}

model DescribeServerlessClusterRequest {
  clusterId?: string(name='ClusterId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeServerlessClusterResponseBody = {
  autoRenew?: string(name='AutoRenew'),
  clusterType?: string(name='ClusterType'),
  createTime?: string(name='CreateTime'),
  cuSize?: string(name='CuSize'),
  diskSize?: string(name='DiskSize'),
  expireTime?: string(name='ExpireTime'),
  haType?: string(name='HaType'),
  hasUser?: string(name='HasUser'),
  innerEndpoint?: string(name='InnerEndpoint'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  isDeletionProtection?: string(name='IsDeletionProtection'),
  lockMode?: string(name='LockMode'),
  mainVersion?: string(name='MainVersion'),
  outerEndpoint?: string(name='OuterEndpoint'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  reserverMaxQpsNum?: string(name='ReserverMaxQpsNum'),
  reserverMinQpsNum?: string(name='ReserverMinQpsNum'),
  resourceGroupId?: string(name='ResourceGroupId'),
  status?: string(name='Status'),
  updateStatus?: string(name='UpdateStatus'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeServerlessClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServerlessClusterResponseBody(name='body'),
}

async function describeServerlessClusterWithOptions(request: DescribeServerlessClusterRequest, runtime: Util.RuntimeOptions): DescribeServerlessClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServerlessCluster',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServerlessCluster(request: DescribeServerlessClusterRequest): DescribeServerlessClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServerlessClusterWithOptions(request, runtime);
}

model DescribeSubDomainRequest {
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeSubDomainResponseBody = {
  requestId?: string(name='RequestId'),
  subDomain?: string(name='SubDomain'),
}

model DescribeSubDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSubDomainResponseBody(name='body'),
}

async function describeSubDomainWithOptions(request: DescribeSubDomainRequest, runtime: Util.RuntimeOptions): DescribeSubDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSubDomain',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSubDomain(request: DescribeSubDomainRequest): DescribeSubDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSubDomainWithOptions(request, runtime);
}

model EnableHBaseueBackupRequest {
  clientToken?: string(name='ClientToken'),
  coldStorageSize?: int32(name='ColdStorageSize'),
  hbaseueClusterId?: string(name='HbaseueClusterId'),
  nodeCount?: int32(name='NodeCount'),
}

model EnableHBaseueBackupResponseBody = {
  clusterId?: string(name='ClusterId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model EnableHBaseueBackupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableHBaseueBackupResponseBody(name='body'),
}

async function enableHBaseueBackupWithOptions(request: EnableHBaseueBackupRequest, runtime: Util.RuntimeOptions): EnableHBaseueBackupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.coldStorageSize)) {
    query['ColdStorageSize'] = request.coldStorageSize;
  }
  if (!Util.isUnset(request.hbaseueClusterId)) {
    query['HbaseueClusterId'] = request.hbaseueClusterId;
  }
  if (!Util.isUnset(request.nodeCount)) {
    query['NodeCount'] = request.nodeCount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableHBaseueBackup',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableHBaseueBackup(request: EnableHBaseueBackupRequest): EnableHBaseueBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableHBaseueBackupWithOptions(request, runtime);
}

model EnableHBaseueModuleRequest {
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
  bdsId?: string(name='BdsId'),
  clientToken?: string(name='ClientToken'),
  coreInstanceType?: string(name='CoreInstanceType'),
  diskSize?: int32(name='DiskSize'),
  diskType?: string(name='DiskType'),
  hbaseueClusterId?: string(name='HbaseueClusterId'),
  masterInstanceType?: string(name='MasterInstanceType'),
  moduleClusterName?: string(name='ModuleClusterName'),
  moduleTypeName?: string(name='ModuleTypeName'),
  nodeCount?: int32(name='NodeCount'),
  payType?: string(name='PayType'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
  vswitchId?: string(name='VswitchId'),
  zoneId?: string(name='ZoneId'),
}

model EnableHBaseueModuleResponseBody = {
  clusterId?: string(name='ClusterId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model EnableHBaseueModuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableHBaseueModuleResponseBody(name='body'),
}

async function enableHBaseueModuleWithOptions(request: EnableHBaseueModuleRequest, runtime: Util.RuntimeOptions): EnableHBaseueModuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoRenewPeriod)) {
    query['AutoRenewPeriod'] = request.autoRenewPeriod;
  }
  if (!Util.isUnset(request.bdsId)) {
    query['BdsId'] = request.bdsId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.coreInstanceType)) {
    query['CoreInstanceType'] = request.coreInstanceType;
  }
  if (!Util.isUnset(request.diskSize)) {
    query['DiskSize'] = request.diskSize;
  }
  if (!Util.isUnset(request.diskType)) {
    query['DiskType'] = request.diskType;
  }
  if (!Util.isUnset(request.hbaseueClusterId)) {
    query['HbaseueClusterId'] = request.hbaseueClusterId;
  }
  if (!Util.isUnset(request.masterInstanceType)) {
    query['MasterInstanceType'] = request.masterInstanceType;
  }
  if (!Util.isUnset(request.moduleClusterName)) {
    query['ModuleClusterName'] = request.moduleClusterName;
  }
  if (!Util.isUnset(request.moduleTypeName)) {
    query['ModuleTypeName'] = request.moduleTypeName;
  }
  if (!Util.isUnset(request.nodeCount)) {
    query['NodeCount'] = request.nodeCount;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.vswitchId)) {
    query['VswitchId'] = request.vswitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableHBaseueModule',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableHBaseueModule(request: EnableHBaseueModuleRequest): EnableHBaseueModuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableHBaseueModuleWithOptions(request, runtime);
}

model EvaluateMultiZoneResourceRequest {
  arbiterVSwitchId?: string(name='ArbiterVSwitchId'),
  arbiterZoneId?: string(name='ArbiterZoneId'),
  archVersion?: string(name='ArchVersion'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
  clientToken?: string(name='ClientToken'),
  clusterName?: string(name='ClusterName'),
  coreDiskSize?: int32(name='CoreDiskSize'),
  coreDiskType?: string(name='CoreDiskType'),
  coreInstanceType?: string(name='CoreInstanceType'),
  coreNodeCount?: int32(name='CoreNodeCount'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  logDiskSize?: int32(name='LogDiskSize'),
  logDiskType?: string(name='LogDiskType'),
  logInstanceType?: string(name='LogInstanceType'),
  logNodeCount?: int32(name='LogNodeCount'),
  masterInstanceType?: string(name='MasterInstanceType'),
  multiZoneCombination?: string(name='MultiZoneCombination'),
  payType?: string(name='PayType'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  primaryVSwitchId?: string(name='PrimaryVSwitchId'),
  primaryZoneId?: string(name='PrimaryZoneId'),
  regionId?: string(name='RegionId'),
  securityIPList?: string(name='SecurityIPList'),
  standbyVSwitchId?: string(name='StandbyVSwitchId'),
  standbyZoneId?: string(name='StandbyZoneId'),
  vpcId?: string(name='VpcId'),
}

model EvaluateMultiZoneResourceResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EvaluateMultiZoneResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EvaluateMultiZoneResourceResponseBody(name='body'),
}

async function evaluateMultiZoneResourceWithOptions(request: EvaluateMultiZoneResourceRequest, runtime: Util.RuntimeOptions): EvaluateMultiZoneResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.arbiterVSwitchId)) {
    query['ArbiterVSwitchId'] = request.arbiterVSwitchId;
  }
  if (!Util.isUnset(request.arbiterZoneId)) {
    query['ArbiterZoneId'] = request.arbiterZoneId;
  }
  if (!Util.isUnset(request.archVersion)) {
    query['ArchVersion'] = request.archVersion;
  }
  if (!Util.isUnset(request.autoRenewPeriod)) {
    query['AutoRenewPeriod'] = request.autoRenewPeriod;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.coreDiskSize)) {
    query['CoreDiskSize'] = request.coreDiskSize;
  }
  if (!Util.isUnset(request.coreDiskType)) {
    query['CoreDiskType'] = request.coreDiskType;
  }
  if (!Util.isUnset(request.coreInstanceType)) {
    query['CoreInstanceType'] = request.coreInstanceType;
  }
  if (!Util.isUnset(request.coreNodeCount)) {
    query['CoreNodeCount'] = request.coreNodeCount;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.logDiskSize)) {
    query['LogDiskSize'] = request.logDiskSize;
  }
  if (!Util.isUnset(request.logDiskType)) {
    query['LogDiskType'] = request.logDiskType;
  }
  if (!Util.isUnset(request.logInstanceType)) {
    query['LogInstanceType'] = request.logInstanceType;
  }
  if (!Util.isUnset(request.logNodeCount)) {
    query['LogNodeCount'] = request.logNodeCount;
  }
  if (!Util.isUnset(request.masterInstanceType)) {
    query['MasterInstanceType'] = request.masterInstanceType;
  }
  if (!Util.isUnset(request.multiZoneCombination)) {
    query['MultiZoneCombination'] = request.multiZoneCombination;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.primaryVSwitchId)) {
    query['PrimaryVSwitchId'] = request.primaryVSwitchId;
  }
  if (!Util.isUnset(request.primaryZoneId)) {
    query['PrimaryZoneId'] = request.primaryZoneId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityIPList)) {
    query['SecurityIPList'] = request.securityIPList;
  }
  if (!Util.isUnset(request.standbyVSwitchId)) {
    query['StandbyVSwitchId'] = request.standbyVSwitchId;
  }
  if (!Util.isUnset(request.standbyZoneId)) {
    query['StandbyZoneId'] = request.standbyZoneId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EvaluateMultiZoneResource',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function evaluateMultiZoneResource(request: EvaluateMultiZoneResourceRequest): EvaluateMultiZoneResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return evaluateMultiZoneResourceWithOptions(request, runtime);
}

model GetMultimodeCmsUrlRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
}

model GetMultimodeCmsUrlResponseBody = {
  clusterId?: string(name='ClusterId'),
  multimodCmsUrl?: string(name='MultimodCmsUrl'),
  requestId?: string(name='RequestId'),
}

model GetMultimodeCmsUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMultimodeCmsUrlResponseBody(name='body'),
}

async function getMultimodeCmsUrlWithOptions(request: GetMultimodeCmsUrlRequest, runtime: Util.RuntimeOptions): GetMultimodeCmsUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMultimodeCmsUrl',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMultimodeCmsUrl(request: GetMultimodeCmsUrlRequest): GetMultimodeCmsUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMultimodeCmsUrlWithOptions(request, runtime);
}

model ListHBaseInstancesRequest {
  vpcId?: string(name='VpcId'),
}

model ListHBaseInstancesResponseBody = {
  instances?: {
    instance?: [ 
    {
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      isDefault?: boolean(name='IsDefault'),
    }
  ](name='Instance')
  }(name='Instances'),
  requestId?: string(name='RequestId'),
}

model ListHBaseInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListHBaseInstancesResponseBody(name='body'),
}

async function listHBaseInstancesWithOptions(request: ListHBaseInstancesRequest, runtime: Util.RuntimeOptions): ListHBaseInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHBaseInstances',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHBaseInstances(request: ListHBaseInstancesRequest): ListHBaseInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHBaseInstancesWithOptions(request, runtime);
}

model ListInstanceServiceConfigHistoriesRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListInstanceServiceConfigHistoriesResponseBody = {
  configureHistoryList?: {
    config?: [ 
    {
      configureName?: string(name='ConfigureName'),
      createTime?: string(name='CreateTime'),
      effective?: string(name='Effective'),
      newValue?: string(name='NewValue'),
      oldValue?: string(name='OldValue'),
    }
  ](name='Config')
  }(name='ConfigureHistoryList'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: long(name='TotalRecordCount'),
}

model ListInstanceServiceConfigHistoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceServiceConfigHistoriesResponseBody(name='body'),
}

async function listInstanceServiceConfigHistoriesWithOptions(request: ListInstanceServiceConfigHistoriesRequest, runtime: Util.RuntimeOptions): ListInstanceServiceConfigHistoriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceServiceConfigHistories',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstanceServiceConfigHistories(request: ListInstanceServiceConfigHistoriesRequest): ListInstanceServiceConfigHistoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceServiceConfigHistoriesWithOptions(request, runtime);
}

model ListInstanceServiceConfigurationsRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListInstanceServiceConfigurationsResponseBody = {
  configureList?: {
    config?: [ 
    {
      configureName?: string(name='ConfigureName'),
      configureUnit?: string(name='ConfigureUnit'),
      defaultValue?: string(name='DefaultValue'),
      description?: string(name='Description'),
      needRestart?: string(name='NeedRestart'),
      runningValue?: string(name='RunningValue'),
      valueRange?: string(name='ValueRange'),
    }
  ](name='Config')
  }(name='ConfigureList'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: long(name='TotalRecordCount'),
}

model ListInstanceServiceConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceServiceConfigurationsResponseBody(name='body'),
}

async function listInstanceServiceConfigurationsWithOptions(request: ListInstanceServiceConfigurationsRequest, runtime: Util.RuntimeOptions): ListInstanceServiceConfigurationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceServiceConfigurations',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstanceServiceConfigurations(request: ListInstanceServiceConfigurationsRequest): ListInstanceServiceConfigurationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceServiceConfigurationsWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListTagsRequest {
  regionId?: string(name='RegionId'),
}

model ListTagsResponseBody = {
  requestId?: string(name='RequestId'),
  tags?: {
    tag?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Tag')
  }(name='Tags'),
}

model ListTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagsResponseBody(name='body'),
}

async function listTagsWithOptions(request: ListTagsRequest, runtime: Util.RuntimeOptions): ListTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTags',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTags(request: ListTagsRequest): ListTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagsWithOptions(request, runtime);
}

model ModifyActiveOperationTasksRequest {
  ids?: string(name='Ids'),
  immediateStart?: int32(name='ImmediateStart'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  switchTime?: string(name='SwitchTime'),
}

model ModifyActiveOperationTasksResponseBody = {
  ids?: string(name='Ids'),
  requestId?: string(name='RequestId'),
}

model ModifyActiveOperationTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyActiveOperationTasksResponseBody(name='body'),
}

async function modifyActiveOperationTasksWithOptions(request: ModifyActiveOperationTasksRequest, runtime: Util.RuntimeOptions): ModifyActiveOperationTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.immediateStart)) {
    query['ImmediateStart'] = request.immediateStart;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.switchTime)) {
    query['SwitchTime'] = request.switchTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyActiveOperationTasks',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyActiveOperationTasks(request: ModifyActiveOperationTasksRequest): ModifyActiveOperationTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyActiveOperationTasksWithOptions(request, runtime);
}

model ModifyBackupPlanConfigRequest {
  clusterId?: string(name='ClusterId'),
  fullBackupCycle?: string(name='FullBackupCycle'),
  minHFileBackupCount?: string(name='MinHFileBackupCount'),
  nextFullBackupDate?: string(name='NextFullBackupDate'),
  tables?: string(name='Tables'),
}

model ModifyBackupPlanConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBackupPlanConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyBackupPlanConfigResponseBody(name='body'),
}

async function modifyBackupPlanConfigWithOptions(request: ModifyBackupPlanConfigRequest, runtime: Util.RuntimeOptions): ModifyBackupPlanConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.fullBackupCycle)) {
    query['FullBackupCycle'] = request.fullBackupCycle;
  }
  if (!Util.isUnset(request.minHFileBackupCount)) {
    query['MinHFileBackupCount'] = request.minHFileBackupCount;
  }
  if (!Util.isUnset(request.nextFullBackupDate)) {
    query['NextFullBackupDate'] = request.nextFullBackupDate;
  }
  if (!Util.isUnset(request.tables)) {
    query['Tables'] = request.tables;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBackupPlanConfig',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyBackupPlanConfig(request: ModifyBackupPlanConfigRequest): ModifyBackupPlanConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBackupPlanConfigWithOptions(request, runtime);
}

model ModifyBackupPolicyRequest {
  clusterId?: string(name='ClusterId'),
  preferredBackupEndTimeUTC?: string(name='PreferredBackupEndTimeUTC'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod'),
  preferredBackupStartTimeUTC?: string(name='PreferredBackupStartTimeUTC'),
  preferredBackupTime?: string(name='PreferredBackupTime'),
}

model ModifyBackupPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyBackupPolicyResponseBody(name='body'),
}

async function modifyBackupPolicyWithOptions(request: ModifyBackupPolicyRequest, runtime: Util.RuntimeOptions): ModifyBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.preferredBackupEndTimeUTC)) {
    query['PreferredBackupEndTimeUTC'] = request.preferredBackupEndTimeUTC;
  }
  if (!Util.isUnset(request.preferredBackupPeriod)) {
    query['PreferredBackupPeriod'] = request.preferredBackupPeriod;
  }
  if (!Util.isUnset(request.preferredBackupStartTimeUTC)) {
    query['PreferredBackupStartTimeUTC'] = request.preferredBackupStartTimeUTC;
  }
  if (!Util.isUnset(request.preferredBackupTime)) {
    query['PreferredBackupTime'] = request.preferredBackupTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBackupPolicy',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyBackupPolicy(request: ModifyBackupPolicyRequest): ModifyBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBackupPolicyWithOptions(request, runtime);
}

model ModifyClusterDeletionProtectionRequest {
  clusterId?: string(name='ClusterId'),
  protection?: boolean(name='Protection'),
}

model ModifyClusterDeletionProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterDeletionProtectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyClusterDeletionProtectionResponseBody(name='body'),
}

async function modifyClusterDeletionProtectionWithOptions(request: ModifyClusterDeletionProtectionRequest, runtime: Util.RuntimeOptions): ModifyClusterDeletionProtectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.protection)) {
    query['Protection'] = request.protection;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterDeletionProtection',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClusterDeletionProtection(request: ModifyClusterDeletionProtectionRequest): ModifyClusterDeletionProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterDeletionProtectionWithOptions(request, runtime);
}

model ModifyDiskWarningLineRequest {
  clusterId?: string(name='ClusterId'),
  warningLine?: int32(name='WarningLine'),
}

model ModifyDiskWarningLineResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDiskWarningLineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDiskWarningLineResponseBody(name='body'),
}

async function modifyDiskWarningLineWithOptions(request: ModifyDiskWarningLineRequest, runtime: Util.RuntimeOptions): ModifyDiskWarningLineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.warningLine)) {
    query['WarningLine'] = request.warningLine;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDiskWarningLine',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDiskWarningLine(request: ModifyDiskWarningLineRequest): ModifyDiskWarningLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDiskWarningLineWithOptions(request, runtime);
}

model ModifyInstanceMaintainTimeRequest {
  clusterId?: string(name='ClusterId'),
  maintainEndTime?: string(name='MaintainEndTime'),
  maintainStartTime?: string(name='MaintainStartTime'),
}

model ModifyInstanceMaintainTimeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceMaintainTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceMaintainTimeResponseBody(name='body'),
}

async function modifyInstanceMaintainTimeWithOptions(request: ModifyInstanceMaintainTimeRequest, runtime: Util.RuntimeOptions): ModifyInstanceMaintainTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.maintainEndTime)) {
    query['MaintainEndTime'] = request.maintainEndTime;
  }
  if (!Util.isUnset(request.maintainStartTime)) {
    query['MaintainStartTime'] = request.maintainStartTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceMaintainTime',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceMaintainTime(request: ModifyInstanceMaintainTimeRequest): ModifyInstanceMaintainTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceMaintainTimeWithOptions(request, runtime);
}

model ModifyInstanceNameRequest {
  clientToken?: string(name='ClientToken'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
}

model ModifyInstanceNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceNameResponseBody(name='body'),
}

async function modifyInstanceNameWithOptions(request: ModifyInstanceNameRequest, runtime: Util.RuntimeOptions): ModifyInstanceNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceName',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceName(request: ModifyInstanceNameRequest): ModifyInstanceNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceNameWithOptions(request, runtime);
}

model ModifyInstanceServiceConfigRequest {
  clusterId?: string(name='ClusterId'),
  configureName?: string(name='ConfigureName'),
  configureValue?: string(name='ConfigureValue'),
  parameters?: string(name='Parameters'),
  restart?: boolean(name='Restart'),
}

model ModifyInstanceServiceConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceServiceConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceServiceConfigResponseBody(name='body'),
}

async function modifyInstanceServiceConfigWithOptions(request: ModifyInstanceServiceConfigRequest, runtime: Util.RuntimeOptions): ModifyInstanceServiceConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.configureName)) {
    query['ConfigureName'] = request.configureName;
  }
  if (!Util.isUnset(request.configureValue)) {
    query['ConfigureValue'] = request.configureValue;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.restart)) {
    query['Restart'] = request.restart;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceServiceConfig',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceServiceConfig(request: ModifyInstanceServiceConfigRequest): ModifyInstanceServiceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceServiceConfigWithOptions(request, runtime);
}

model ModifyInstanceTypeRequest {
  clusterId?: string(name='ClusterId'),
  coreInstanceType?: string(name='CoreInstanceType'),
  masterInstanceType?: string(name='MasterInstanceType'),
}

model ModifyInstanceTypeResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyInstanceTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceTypeResponseBody(name='body'),
}

async function modifyInstanceTypeWithOptions(request: ModifyInstanceTypeRequest, runtime: Util.RuntimeOptions): ModifyInstanceTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.coreInstanceType)) {
    query['CoreInstanceType'] = request.coreInstanceType;
  }
  if (!Util.isUnset(request.masterInstanceType)) {
    query['MasterInstanceType'] = request.masterInstanceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceType',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceType(request: ModifyInstanceTypeRequest): ModifyInstanceTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceTypeWithOptions(request, runtime);
}

model ModifyIpWhitelistRequest {
  clusterId?: string(name='ClusterId'),
  groupName?: string(name='GroupName'),
  ipList?: string(name='IpList'),
  ipVersion?: string(name='IpVersion'),
}

model ModifyIpWhitelistResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpWhitelistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyIpWhitelistResponseBody(name='body'),
}

async function modifyIpWhitelistWithOptions(request: ModifyIpWhitelistRequest, runtime: Util.RuntimeOptions): ModifyIpWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.ipList)) {
    query['IpList'] = request.ipList;
  }
  if (!Util.isUnset(request.ipVersion)) {
    query['IpVersion'] = request.ipVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIpWhitelist',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyIpWhitelist(request: ModifyIpWhitelistRequest): ModifyIpWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIpWhitelistWithOptions(request, runtime);
}

model ModifyMultiZoneClusterNodeTypeRequest {
  clusterId?: string(name='ClusterId'),
  coreInstanceType?: string(name='CoreInstanceType'),
  logInstanceType?: string(name='LogInstanceType'),
  masterInstanceType?: string(name='MasterInstanceType'),
}

model ModifyMultiZoneClusterNodeTypeResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyMultiZoneClusterNodeTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyMultiZoneClusterNodeTypeResponseBody(name='body'),
}

async function modifyMultiZoneClusterNodeTypeWithOptions(request: ModifyMultiZoneClusterNodeTypeRequest, runtime: Util.RuntimeOptions): ModifyMultiZoneClusterNodeTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.coreInstanceType)) {
    query['CoreInstanceType'] = request.coreInstanceType;
  }
  if (!Util.isUnset(request.logInstanceType)) {
    query['LogInstanceType'] = request.logInstanceType;
  }
  if (!Util.isUnset(request.masterInstanceType)) {
    query['MasterInstanceType'] = request.masterInstanceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyMultiZoneClusterNodeType',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyMultiZoneClusterNodeType(request: ModifyMultiZoneClusterNodeTypeRequest): ModifyMultiZoneClusterNodeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMultiZoneClusterNodeTypeWithOptions(request, runtime);
}

model ModifySecurityGroupsRequest {
  clusterId?: string(name='ClusterId'),
  securityGroupIds?: string(name='SecurityGroupIds'),
}

model ModifySecurityGroupsResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySecurityGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySecurityGroupsResponseBody(name='body'),
}

async function modifySecurityGroupsWithOptions(request: ModifySecurityGroupsRequest, runtime: Util.RuntimeOptions): ModifySecurityGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.securityGroupIds)) {
    query['SecurityGroupIds'] = request.securityGroupIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySecurityGroups',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySecurityGroups(request: ModifySecurityGroupsRequest): ModifySecurityGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySecurityGroupsWithOptions(request, runtime);
}

model ModifyUIAccountPasswordRequest {
  accountName?: string(name='AccountName'),
  accountPassword?: string(name='AccountPassword'),
  clusterId?: string(name='ClusterId'),
}

model ModifyUIAccountPasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUIAccountPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyUIAccountPasswordResponseBody(name='body'),
}

async function modifyUIAccountPasswordWithOptions(request: ModifyUIAccountPasswordRequest, runtime: Util.RuntimeOptions): ModifyUIAccountPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyUIAccountPassword',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyUIAccountPassword(request: ModifyUIAccountPasswordRequest): ModifyUIAccountPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyUIAccountPasswordWithOptions(request, runtime);
}

model MoveResourceGroupRequest {
  clusterId?: string(name='ClusterId'),
  newResourceGroupId?: string(name='NewResourceGroupId'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model MoveResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MoveResourceGroupResponseBody(name='body'),
}

async function moveResourceGroupWithOptions(request: MoveResourceGroupRequest, runtime: Util.RuntimeOptions): MoveResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MoveResourceGroup',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function moveResourceGroup(request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveResourceGroupWithOptions(request, runtime);
}

model OpenBackupRequest {
  clusterId?: string(name='ClusterId'),
}

model OpenBackupResponseBody = {
  requestId?: string(name='RequestId'),
}

model OpenBackupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenBackupResponseBody(name='body'),
}

async function openBackupWithOptions(request: OpenBackupRequest, runtime: Util.RuntimeOptions): OpenBackupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenBackup',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openBackup(request: OpenBackupRequest): OpenBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return openBackupWithOptions(request, runtime);
}

model PurgeInstanceRequest {
  clusterId?: string(name='ClusterId'),
}

model PurgeInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model PurgeInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PurgeInstanceResponseBody(name='body'),
}

async function purgeInstanceWithOptions(request: PurgeInstanceRequest, runtime: Util.RuntimeOptions): PurgeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PurgeInstance',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function purgeInstance(request: PurgeInstanceRequest): PurgeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return purgeInstanceWithOptions(request, runtime);
}

model QueryHBaseHaDBRequest {
  bdsId?: string(name='BdsId'),
}

model QueryHBaseHaDBResponseBody = {
  clusterList?: {
    cluster?: [ 
    {
      activeName?: string(name='ActiveName'),
      bdsName?: string(name='BdsName'),
      haName?: string(name='HaName'),
      haSlbConnList?: {
        haSlbConn?: [ 
        {
          hbaseType?: string(name='HbaseType'),
          slbConnAddr?: string(name='SlbConnAddr'),
          slbType?: string(name='SlbType'),
        }
      ](name='HaSlbConn')
      }(name='HaSlbConnList'),
      standbyName?: string(name='StandbyName'),
    }
  ](name='Cluster')
  }(name='ClusterList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model QueryHBaseHaDBResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryHBaseHaDBResponseBody(name='body'),
}

async function queryHBaseHaDBWithOptions(request: QueryHBaseHaDBRequest, runtime: Util.RuntimeOptions): QueryHBaseHaDBResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bdsId)) {
    query['BdsId'] = request.bdsId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryHBaseHaDB',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryHBaseHaDB(request: QueryHBaseHaDBRequest): QueryHBaseHaDBResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryHBaseHaDBWithOptions(request, runtime);
}

model QueryXpackRelateDBRequest {
  clusterId?: string(name='ClusterId'),
  hasSingleNode?: boolean(name='HasSingleNode'),
  relateDbType?: string(name='RelateDbType'),
}

model QueryXpackRelateDBResponseBody = {
  clusterList?: {
    cluster?: [ 
    {
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      DBType?: string(name='DBType'),
      DBVersion?: string(name='DBVersion'),
      isRelated?: boolean(name='IsRelated'),
      lockMode?: string(name='LockMode'),
      status?: string(name='Status'),
    }
  ](name='Cluster')
  }(name='ClusterList'),
  requestId?: string(name='RequestId'),
}

model QueryXpackRelateDBResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryXpackRelateDBResponseBody(name='body'),
}

async function queryXpackRelateDBWithOptions(request: QueryXpackRelateDBRequest, runtime: Util.RuntimeOptions): QueryXpackRelateDBResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.hasSingleNode)) {
    query['HasSingleNode'] = request.hasSingleNode;
  }
  if (!Util.isUnset(request.relateDbType)) {
    query['RelateDbType'] = request.relateDbType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryXpackRelateDB',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryXpackRelateDB(request: QueryXpackRelateDBRequest): QueryXpackRelateDBResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryXpackRelateDBWithOptions(request, runtime);
}

model RelateDbForHBaseHaRequest {
  clusterId?: string(name='ClusterId'),
  haActive?: string(name='HaActive'),
  haActiveClusterKey?: string(name='HaActiveClusterKey'),
  haActiveDBType?: string(name='HaActiveDBType'),
  haActiveHbaseFsDir?: string(name='HaActiveHbaseFsDir'),
  haActiveHdfsUri?: string(name='HaActiveHdfsUri'),
  haActivePassword?: string(name='HaActivePassword'),
  haActiveUser?: string(name='HaActiveUser'),
  haActiveVersion?: string(name='HaActiveVersion'),
  haMigrateType?: string(name='HaMigrateType'),
  haStandby?: string(name='HaStandby'),
  haStandbyClusterKey?: string(name='HaStandbyClusterKey'),
  haStandbyDBType?: string(name='HaStandbyDBType'),
  haStandbyHbaseFsDir?: string(name='HaStandbyHbaseFsDir'),
  haStandbyHdfsUri?: string(name='HaStandbyHdfsUri'),
  haStandbyPassword?: string(name='HaStandbyPassword'),
  haStandbyUser?: string(name='HaStandbyUser'),
  haStandbyVersion?: string(name='HaStandbyVersion'),
  haTables?: string(name='HaTables'),
  isActiveStandard?: boolean(name='IsActiveStandard'),
  isStandbyStandard?: boolean(name='IsStandbyStandard'),
}

model RelateDbForHBaseHaResponseBody = {
  requestId?: string(name='RequestId'),
}

model RelateDbForHBaseHaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RelateDbForHBaseHaResponseBody(name='body'),
}

async function relateDbForHBaseHaWithOptions(request: RelateDbForHBaseHaRequest, runtime: Util.RuntimeOptions): RelateDbForHBaseHaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.haActive)) {
    query['HaActive'] = request.haActive;
  }
  if (!Util.isUnset(request.haActiveClusterKey)) {
    query['HaActiveClusterKey'] = request.haActiveClusterKey;
  }
  if (!Util.isUnset(request.haActiveDBType)) {
    query['HaActiveDBType'] = request.haActiveDBType;
  }
  if (!Util.isUnset(request.haActiveHbaseFsDir)) {
    query['HaActiveHbaseFsDir'] = request.haActiveHbaseFsDir;
  }
  if (!Util.isUnset(request.haActiveHdfsUri)) {
    query['HaActiveHdfsUri'] = request.haActiveHdfsUri;
  }
  if (!Util.isUnset(request.haActivePassword)) {
    query['HaActivePassword'] = request.haActivePassword;
  }
  if (!Util.isUnset(request.haActiveUser)) {
    query['HaActiveUser'] = request.haActiveUser;
  }
  if (!Util.isUnset(request.haActiveVersion)) {
    query['HaActiveVersion'] = request.haActiveVersion;
  }
  if (!Util.isUnset(request.haMigrateType)) {
    query['HaMigrateType'] = request.haMigrateType;
  }
  if (!Util.isUnset(request.haStandby)) {
    query['HaStandby'] = request.haStandby;
  }
  if (!Util.isUnset(request.haStandbyClusterKey)) {
    query['HaStandbyClusterKey'] = request.haStandbyClusterKey;
  }
  if (!Util.isUnset(request.haStandbyDBType)) {
    query['HaStandbyDBType'] = request.haStandbyDBType;
  }
  if (!Util.isUnset(request.haStandbyHbaseFsDir)) {
    query['HaStandbyHbaseFsDir'] = request.haStandbyHbaseFsDir;
  }
  if (!Util.isUnset(request.haStandbyHdfsUri)) {
    query['HaStandbyHdfsUri'] = request.haStandbyHdfsUri;
  }
  if (!Util.isUnset(request.haStandbyPassword)) {
    query['HaStandbyPassword'] = request.haStandbyPassword;
  }
  if (!Util.isUnset(request.haStandbyUser)) {
    query['HaStandbyUser'] = request.haStandbyUser;
  }
  if (!Util.isUnset(request.haStandbyVersion)) {
    query['HaStandbyVersion'] = request.haStandbyVersion;
  }
  if (!Util.isUnset(request.haTables)) {
    query['HaTables'] = request.haTables;
  }
  if (!Util.isUnset(request.isActiveStandard)) {
    query['IsActiveStandard'] = request.isActiveStandard;
  }
  if (!Util.isUnset(request.isStandbyStandard)) {
    query['IsStandbyStandard'] = request.isStandbyStandard;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RelateDbForHBaseHa',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function relateDbForHBaseHa(request: RelateDbForHBaseHaRequest): RelateDbForHBaseHaResponse {
  var runtime = new Util.RuntimeOptions{};
  return relateDbForHBaseHaWithOptions(request, runtime);
}

model ReleasePublicNetworkAddressRequest {
  clusterId?: string(name='ClusterId'),
}

model ReleasePublicNetworkAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleasePublicNetworkAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleasePublicNetworkAddressResponseBody(name='body'),
}

async function releasePublicNetworkAddressWithOptions(request: ReleasePublicNetworkAddressRequest, runtime: Util.RuntimeOptions): ReleasePublicNetworkAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleasePublicNetworkAddress',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releasePublicNetworkAddress(request: ReleasePublicNetworkAddressRequest): ReleasePublicNetworkAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return releasePublicNetworkAddressWithOptions(request, runtime);
}

model RenewInstanceRequest {
  clusterId?: string(name='ClusterId'),
  duration?: int32(name='Duration'),
  pricingCycle?: string(name='PricingCycle'),
}

model RenewInstanceResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstanceWithOptions(request: RenewInstanceRequest, runtime: Util.RuntimeOptions): RenewInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenewInstance',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewInstanceWithOptions(request, runtime);
}

model ResizeColdStorageSizeRequest {
  clusterId?: string(name='ClusterId'),
  coldStorageSize?: int32(name='ColdStorageSize'),
}

model ResizeColdStorageSizeResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ResizeColdStorageSizeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResizeColdStorageSizeResponseBody(name='body'),
}

async function resizeColdStorageSizeWithOptions(request: ResizeColdStorageSizeRequest, runtime: Util.RuntimeOptions): ResizeColdStorageSizeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.coldStorageSize)) {
    query['ColdStorageSize'] = request.coldStorageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResizeColdStorageSize',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resizeColdStorageSize(request: ResizeColdStorageSizeRequest): ResizeColdStorageSizeResponse {
  var runtime = new Util.RuntimeOptions{};
  return resizeColdStorageSizeWithOptions(request, runtime);
}

model ResizeDiskSizeRequest {
  clusterId?: string(name='ClusterId'),
  nodeDiskSize?: int32(name='NodeDiskSize'),
}

model ResizeDiskSizeResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ResizeDiskSizeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResizeDiskSizeResponseBody(name='body'),
}

async function resizeDiskSizeWithOptions(request: ResizeDiskSizeRequest, runtime: Util.RuntimeOptions): ResizeDiskSizeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.nodeDiskSize)) {
    query['NodeDiskSize'] = request.nodeDiskSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResizeDiskSize',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resizeDiskSize(request: ResizeDiskSizeRequest): ResizeDiskSizeResponse {
  var runtime = new Util.RuntimeOptions{};
  return resizeDiskSizeWithOptions(request, runtime);
}

model ResizeMultiZoneClusterDiskSizeRequest {
  clusterId?: string(name='ClusterId'),
  coreDiskSize?: int32(name='CoreDiskSize'),
  logDiskSize?: int32(name='LogDiskSize'),
}

model ResizeMultiZoneClusterDiskSizeResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ResizeMultiZoneClusterDiskSizeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResizeMultiZoneClusterDiskSizeResponseBody(name='body'),
}

async function resizeMultiZoneClusterDiskSizeWithOptions(request: ResizeMultiZoneClusterDiskSizeRequest, runtime: Util.RuntimeOptions): ResizeMultiZoneClusterDiskSizeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.coreDiskSize)) {
    query['CoreDiskSize'] = request.coreDiskSize;
  }
  if (!Util.isUnset(request.logDiskSize)) {
    query['LogDiskSize'] = request.logDiskSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResizeMultiZoneClusterDiskSize',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resizeMultiZoneClusterDiskSize(request: ResizeMultiZoneClusterDiskSizeRequest): ResizeMultiZoneClusterDiskSizeResponse {
  var runtime = new Util.RuntimeOptions{};
  return resizeMultiZoneClusterDiskSizeWithOptions(request, runtime);
}

model ResizeMultiZoneClusterNodeCountRequest {
  arbiterVSwitchId?: string(name='ArbiterVSwitchId'),
  clusterId?: string(name='ClusterId'),
  coreNodeCount?: int32(name='CoreNodeCount'),
  logNodeCount?: int32(name='LogNodeCount'),
  primaryCoreNodeCount?: int32(name='PrimaryCoreNodeCount'),
  primaryVSwitchId?: string(name='PrimaryVSwitchId'),
  standbyCoreNodeCount?: int32(name='StandbyCoreNodeCount'),
  standbyVSwitchId?: string(name='StandbyVSwitchId'),
}

model ResizeMultiZoneClusterNodeCountResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ResizeMultiZoneClusterNodeCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResizeMultiZoneClusterNodeCountResponseBody(name='body'),
}

async function resizeMultiZoneClusterNodeCountWithOptions(request: ResizeMultiZoneClusterNodeCountRequest, runtime: Util.RuntimeOptions): ResizeMultiZoneClusterNodeCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.arbiterVSwitchId)) {
    query['ArbiterVSwitchId'] = request.arbiterVSwitchId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.coreNodeCount)) {
    query['CoreNodeCount'] = request.coreNodeCount;
  }
  if (!Util.isUnset(request.logNodeCount)) {
    query['LogNodeCount'] = request.logNodeCount;
  }
  if (!Util.isUnset(request.primaryCoreNodeCount)) {
    query['PrimaryCoreNodeCount'] = request.primaryCoreNodeCount;
  }
  if (!Util.isUnset(request.primaryVSwitchId)) {
    query['PrimaryVSwitchId'] = request.primaryVSwitchId;
  }
  if (!Util.isUnset(request.standbyCoreNodeCount)) {
    query['StandbyCoreNodeCount'] = request.standbyCoreNodeCount;
  }
  if (!Util.isUnset(request.standbyVSwitchId)) {
    query['StandbyVSwitchId'] = request.standbyVSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResizeMultiZoneClusterNodeCount',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resizeMultiZoneClusterNodeCount(request: ResizeMultiZoneClusterNodeCountRequest): ResizeMultiZoneClusterNodeCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return resizeMultiZoneClusterNodeCountWithOptions(request, runtime);
}

model ResizeNodeCountRequest {
  clusterId?: string(name='ClusterId'),
  nodeCount?: int32(name='NodeCount'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
}

model ResizeNodeCountResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ResizeNodeCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResizeNodeCountResponseBody(name='body'),
}

async function resizeNodeCountWithOptions(request: ResizeNodeCountRequest, runtime: Util.RuntimeOptions): ResizeNodeCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.nodeCount)) {
    query['NodeCount'] = request.nodeCount;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResizeNodeCount',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resizeNodeCount(request: ResizeNodeCountRequest): ResizeNodeCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return resizeNodeCountWithOptions(request, runtime);
}

model RestartInstanceRequest {
  clusterId?: string(name='ClusterId'),
  components?: string(name='Components'),
}

model RestartInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RestartInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartInstanceResponseBody(name='body'),
}

async function restartInstanceWithOptions(request: RestartInstanceRequest, runtime: Util.RuntimeOptions): RestartInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.components)) {
    query['Components'] = request.components;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartInstance',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restartInstance(request: RestartInstanceRequest): RestartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartInstanceWithOptions(request, runtime);
}

model SwitchHbaseHaSlbRequest {
  bdsId?: string(name='BdsId'),
  haId?: string(name='HaId'),
  haTypes?: string(name='HaTypes'),
  hbaseType?: string(name='HbaseType'),
}

model SwitchHbaseHaSlbResponseBody = {
  requestId?: string(name='RequestId'),
}

model SwitchHbaseHaSlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SwitchHbaseHaSlbResponseBody(name='body'),
}

async function switchHbaseHaSlbWithOptions(request: SwitchHbaseHaSlbRequest, runtime: Util.RuntimeOptions): SwitchHbaseHaSlbResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bdsId)) {
    query['BdsId'] = request.bdsId;
  }
  if (!Util.isUnset(request.haId)) {
    query['HaId'] = request.haId;
  }
  if (!Util.isUnset(request.haTypes)) {
    query['HaTypes'] = request.haTypes;
  }
  if (!Util.isUnset(request.hbaseType)) {
    query['HbaseType'] = request.hbaseType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SwitchHbaseHaSlb',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function switchHbaseHaSlb(request: SwitchHbaseHaSlbRequest): SwitchHbaseHaSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchHbaseHaSlbWithOptions(request, runtime);
}

model SwitchServiceRequest {
  clusterId?: string(name='ClusterId'),
  operate?: string(name='Operate'),
  serviceName?: string(name='ServiceName'),
}

model SwitchServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model SwitchServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SwitchServiceResponseBody(name='body'),
}

async function switchServiceWithOptions(request: SwitchServiceRequest, runtime: Util.RuntimeOptions): SwitchServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.operate)) {
    query['Operate'] = request.operate;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SwitchService',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function switchService(request: SwitchServiceRequest): SwitchServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchServiceWithOptions(request, runtime);
}

model TagResourcesRequest {
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UnTagResourcesRequest {
  all?: boolean(name='All'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  tagKey?: [ string ](name='TagKey'),
}

model UnTagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnTagResourcesResponseBody(name='body'),
}

async function unTagResourcesWithOptions(request: UnTagResourcesRequest, runtime: Util.RuntimeOptions): UnTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnTagResources',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unTagResources(request: UnTagResourcesRequest): UnTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return unTagResourcesWithOptions(request, runtime);
}

model UpgradeMinorVersionRequest {
  clusterId?: string(name='ClusterId'),
  components?: string(name='Components'),
}

model UpgradeMinorVersionResponseBody = {
  requestId?: string(name='RequestId'),
  upgradingComponents?: string(name='UpgradingComponents'),
}

model UpgradeMinorVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeMinorVersionResponseBody(name='body'),
}

async function upgradeMinorVersionWithOptions(request: UpgradeMinorVersionRequest, runtime: Util.RuntimeOptions): UpgradeMinorVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.components)) {
    query['Components'] = request.components;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeMinorVersion',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeMinorVersion(request: UpgradeMinorVersionRequest): UpgradeMinorVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeMinorVersionWithOptions(request, runtime);
}

model UpgradeMultiZoneClusterRequest {
  clusterId?: string(name='ClusterId'),
  components?: string(name='Components'),
  restartComponents?: string(name='RestartComponents'),
  runMode?: string(name='RunMode'),
  upgradeInsName?: string(name='UpgradeInsName'),
  versions?: string(name='Versions'),
}

model UpgradeMultiZoneClusterResponseBody = {
  requestId?: string(name='RequestId'),
  upgradingComponents?: string(name='UpgradingComponents'),
}

model UpgradeMultiZoneClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeMultiZoneClusterResponseBody(name='body'),
}

async function upgradeMultiZoneClusterWithOptions(request: UpgradeMultiZoneClusterRequest, runtime: Util.RuntimeOptions): UpgradeMultiZoneClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.components)) {
    query['Components'] = request.components;
  }
  if (!Util.isUnset(request.restartComponents)) {
    query['RestartComponents'] = request.restartComponents;
  }
  if (!Util.isUnset(request.runMode)) {
    query['RunMode'] = request.runMode;
  }
  if (!Util.isUnset(request.upgradeInsName)) {
    query['UpgradeInsName'] = request.upgradeInsName;
  }
  if (!Util.isUnset(request.versions)) {
    query['Versions'] = request.versions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeMultiZoneCluster',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeMultiZoneCluster(request: UpgradeMultiZoneClusterRequest): UpgradeMultiZoneClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeMultiZoneClusterWithOptions(request, runtime);
}

model XpackRelateDBRequest {
  clusterId?: string(name='ClusterId'),
  dbClusterIds?: string(name='DbClusterIds'),
  relateDbType?: string(name='RelateDbType'),
}

model XpackRelateDBResponseBody = {
  requestId?: string(name='RequestId'),
}

model XpackRelateDBResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: XpackRelateDBResponseBody(name='body'),
}

async function xpackRelateDBWithOptions(request: XpackRelateDBRequest, runtime: Util.RuntimeOptions): XpackRelateDBResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dbClusterIds)) {
    query['DbClusterIds'] = request.dbClusterIds;
  }
  if (!Util.isUnset(request.relateDbType)) {
    query['RelateDbType'] = request.relateDbType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'XpackRelateDB',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function xpackRelateDB(request: XpackRelateDBRequest): XpackRelateDBResponse {
  var runtime = new Util.RuntimeOptions{};
  return xpackRelateDBWithOptions(request, runtime);
}

