/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('privatelink', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model RemoveZoneFromVpcEndpointRequest {
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
  endpointId?: string(name='EndpointId'),
  dryRun?: boolean(name='DryRun'),
  clientToken?: string(name='ClientToken'),
}

model RemoveZoneFromVpcEndpointResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveZoneFromVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveZoneFromVpcEndpointResponseBody(name='body'),
}

async function removeZoneFromVpcEndpointWithOptions(request: RemoveZoneFromVpcEndpointRequest, runtime: Util.RuntimeOptions): RemoveZoneFromVpcEndpointResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveZoneFromVpcEndpoint', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeZoneFromVpcEndpoint(request: RemoveZoneFromVpcEndpointRequest): RemoveZoneFromVpcEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeZoneFromVpcEndpointWithOptions(request, runtime);
}

model ListVpcEndpointSecurityGroupsRequest {
  regionId?: string(name='RegionId'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  endpointId?: string(name='EndpointId'),
}

model ListVpcEndpointSecurityGroupsResponseBody = {
  securityGroups?: [ 
    {
      securityGroupId?: string(name='SecurityGroupId'),
    }
  ](name='SecurityGroups'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: string(name='MaxResults'),
}

model ListVpcEndpointSecurityGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcEndpointSecurityGroupsResponseBody(name='body'),
}

async function listVpcEndpointSecurityGroupsWithOptions(request: ListVpcEndpointSecurityGroupsRequest, runtime: Util.RuntimeOptions): ListVpcEndpointSecurityGroupsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVpcEndpointSecurityGroups', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVpcEndpointSecurityGroups(request: ListVpcEndpointSecurityGroupsRequest): ListVpcEndpointSecurityGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVpcEndpointSecurityGroupsWithOptions(request, runtime);
}

model ListVpcEndpointServicesByEndUserRequest {
  regionId?: string(name='RegionId'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  serviceId?: string(name='ServiceId'),
  serviceName?: string(name='ServiceName'),
}

model ListVpcEndpointServicesByEndUserResponseBody = {
  services?: [ 
    {
      payer?: string(name='Payer'),
      serviceDomain?: string(name='ServiceDomain'),
      zones?: [ string ](name='Zones'),
      serviceId?: string(name='ServiceId'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='Services'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: string(name='MaxResults'),
}

model ListVpcEndpointServicesByEndUserResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcEndpointServicesByEndUserResponseBody(name='body'),
}

async function listVpcEndpointServicesByEndUserWithOptions(request: ListVpcEndpointServicesByEndUserRequest, runtime: Util.RuntimeOptions): ListVpcEndpointServicesByEndUserResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVpcEndpointServicesByEndUser', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVpcEndpointServicesByEndUser(request: ListVpcEndpointServicesByEndUserRequest): ListVpcEndpointServicesByEndUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVpcEndpointServicesByEndUserWithOptions(request, runtime);
}

model ListVpcEndpointsRequest {
  regionId?: string(name='RegionId'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  endpointId?: string(name='EndpointId'),
  serviceName?: string(name='ServiceName'),
  vpcId?: string(name='VpcId'),
  endpointName?: string(name='EndpointName'),
  endpointStatus?: string(name='EndpointStatus'),
  connectionStatus?: string(name='ConnectionStatus'),
}

model ListVpcEndpointsResponseBody = {
  endpoints?: [ 
    {
      vpcId?: string(name='VpcId'),
      endpointName?: string(name='EndpointName'),
      createTime?: string(name='CreateTime'),
      serviceId?: string(name='ServiceId'),
      zoneAffinityEnabled?: boolean(name='ZoneAffinityEnabled'),
      endpointDomain?: string(name='EndpointDomain'),
      endpointStatus?: string(name='EndpointStatus'),
      regionId?: string(name='RegionId'),
      resourceOwner?: boolean(name='ResourceOwner'),
      bandwidth?: long(name='Bandwidth'),
      connectionStatus?: string(name='ConnectionStatus'),
      endpointDescription?: string(name='EndpointDescription'),
      endpointId?: string(name='EndpointId'),
      endpointBusinessStatus?: string(name='EndpointBusinessStatus'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='Endpoints'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: string(name='MaxResults'),
}

model ListVpcEndpointsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcEndpointsResponseBody(name='body'),
}

async function listVpcEndpointsWithOptions(request: ListVpcEndpointsRequest, runtime: Util.RuntimeOptions): ListVpcEndpointsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVpcEndpoints', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVpcEndpoints(request: ListVpcEndpointsRequest): ListVpcEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVpcEndpointsWithOptions(request, runtime);
}

model DeleteVpcEndpointRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  endpointId?: string(name='EndpointId'),
}

model DeleteVpcEndpointResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpcEndpointResponseBody(name='body'),
}

async function deleteVpcEndpointWithOptions(request: DeleteVpcEndpointRequest, runtime: Util.RuntimeOptions): DeleteVpcEndpointResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVpcEndpoint', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVpcEndpoint(request: DeleteVpcEndpointRequest): DeleteVpcEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpcEndpointWithOptions(request, runtime);
}

model OpenPrivateLinkServiceRequest {
  ownerId?: long(name='OwnerId'),
}

model OpenPrivateLinkServiceResponseBody = {
  requestId?: string(name='RequestId'),
  orderId?: string(name='OrderId'),
}

model OpenPrivateLinkServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenPrivateLinkServiceResponseBody(name='body'),
}

async function openPrivateLinkServiceWithOptions(request: OpenPrivateLinkServiceRequest, runtime: Util.RuntimeOptions): OpenPrivateLinkServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('OpenPrivateLinkService', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function openPrivateLinkService(request: OpenPrivateLinkServiceRequest): OpenPrivateLinkServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openPrivateLinkServiceWithOptions(request, runtime);
}

model EnableVpcEndpointConnectionRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  serviceId?: string(name='ServiceId'),
  endpointId?: string(name='EndpointId'),
  bandwidth?: int32(name='Bandwidth'),
}

model EnableVpcEndpointConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableVpcEndpointConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: EnableVpcEndpointConnectionResponseBody(name='body'),
}

async function enableVpcEndpointConnectionWithOptions(request: EnableVpcEndpointConnectionRequest, runtime: Util.RuntimeOptions): EnableVpcEndpointConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableVpcEndpointConnection', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableVpcEndpointConnection(request: EnableVpcEndpointConnectionRequest): EnableVpcEndpointConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableVpcEndpointConnectionWithOptions(request, runtime);
}

model AddUserToVpcEndpointServiceRequest {
  regionId?: string(name='RegionId'),
  userId?: long(name='UserId'),
  serviceId?: string(name='ServiceId'),
  dryRun?: boolean(name='DryRun'),
  clientToken?: string(name='ClientToken'),
}

model AddUserToVpcEndpointServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddUserToVpcEndpointServiceResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserToVpcEndpointServiceResponseBody(name='body'),
}

async function addUserToVpcEndpointServiceWithOptions(request: AddUserToVpcEndpointServiceRequest, runtime: Util.RuntimeOptions): AddUserToVpcEndpointServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddUserToVpcEndpointService', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addUserToVpcEndpointService(request: AddUserToVpcEndpointServiceRequest): AddUserToVpcEndpointServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUserToVpcEndpointServiceWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  regionId?: string(name='RegionId'),
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  regions?: {
    region?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Region')
  }(name='Regions'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRegions', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model UpdateVpcEndpointConnectionAttributeRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  serviceId?: string(name='ServiceId'),
  endpointId?: string(name='EndpointId'),
  bandwidth?: int32(name='Bandwidth'),
}

model UpdateVpcEndpointConnectionAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateVpcEndpointConnectionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVpcEndpointConnectionAttributeResponseBody(name='body'),
}

async function updateVpcEndpointConnectionAttributeWithOptions(request: UpdateVpcEndpointConnectionAttributeRequest, runtime: Util.RuntimeOptions): UpdateVpcEndpointConnectionAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateVpcEndpointConnectionAttribute', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateVpcEndpointConnectionAttribute(request: UpdateVpcEndpointConnectionAttributeRequest): UpdateVpcEndpointConnectionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVpcEndpointConnectionAttributeWithOptions(request, runtime);
}

model DescribeZonesRequest {
  regionId?: string(name='RegionId'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: {
    zone?: [ 
    {
      localName?: string(name='LocalName'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Zone')
  }(name='Zones'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeZonesResponseBody(name='body'),
}

async function describeZonesWithOptions(request: DescribeZonesRequest, runtime: Util.RuntimeOptions): DescribeZonesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeZones', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeZonesWithOptions(request, runtime);
}

model UpdateVpcEndpointServiceAttributeRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  serviceId?: string(name='ServiceId'),
  serviceDescription?: string(name='ServiceDescription'),
  autoAcceptEnabled?: boolean(name='AutoAcceptEnabled'),
  connectBandwidth?: int32(name='ConnectBandwidth'),
  zoneAffinityEnabled?: boolean(name='ZoneAffinityEnabled'),
}

model UpdateVpcEndpointServiceAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateVpcEndpointServiceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVpcEndpointServiceAttributeResponseBody(name='body'),
}

async function updateVpcEndpointServiceAttributeWithOptions(request: UpdateVpcEndpointServiceAttributeRequest, runtime: Util.RuntimeOptions): UpdateVpcEndpointServiceAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateVpcEndpointServiceAttribute', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateVpcEndpointServiceAttribute(request: UpdateVpcEndpointServiceAttributeRequest): UpdateVpcEndpointServiceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVpcEndpointServiceAttributeWithOptions(request, runtime);
}

model ListVpcEndpointServiceUsersRequest {
  regionId?: string(name='RegionId'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  serviceId?: string(name='ServiceId'),
  userId?: long(name='UserId'),
}

model ListVpcEndpointServiceUsersResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: string(name='MaxResults'),
  users?: [ 
    {
      userId?: long(name='UserId'),
    }
  ](name='Users'),
}

model ListVpcEndpointServiceUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcEndpointServiceUsersResponseBody(name='body'),
}

async function listVpcEndpointServiceUsersWithOptions(request: ListVpcEndpointServiceUsersRequest, runtime: Util.RuntimeOptions): ListVpcEndpointServiceUsersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVpcEndpointServiceUsers', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVpcEndpointServiceUsers(request: ListVpcEndpointServiceUsersRequest): ListVpcEndpointServiceUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVpcEndpointServiceUsersWithOptions(request, runtime);
}

model ListVpcEndpointServicesRequest {
  regionId?: string(name='RegionId'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  serviceId?: string(name='ServiceId'),
  serviceName?: string(name='ServiceName'),
  autoAcceptEnabled?: boolean(name='AutoAcceptEnabled'),
  serviceStatus?: string(name='ServiceStatus'),
  serviceBusinessStatus?: string(name='ServiceBusinessStatus'),
  zoneAffinityEnabled?: boolean(name='ZoneAffinityEnabled'),
}

model ListVpcEndpointServicesResponseBody = {
  services?: [ 
    {
      autoAcceptEnabled?: boolean(name='AutoAcceptEnabled'),
      serviceId?: string(name='ServiceId'),
      createTime?: string(name='CreateTime'),
      minBandwidth?: int32(name='MinBandwidth'),
      maxBandwidth?: int32(name='MaxBandwidth'),
      serviceStatus?: string(name='ServiceStatus'),
      zoneAffinityEnabled?: boolean(name='ZoneAffinityEnabled'),
      regionId?: string(name='RegionId'),
      serviceDomain?: string(name='ServiceDomain'),
      payer?: string(name='Payer'),
      serviceBusinessStatus?: string(name='ServiceBusinessStatus'),
      connectBandwidth?: int32(name='ConnectBandwidth'),
      serviceName?: string(name='ServiceName'),
      serviceDescription?: string(name='ServiceDescription'),
    }
  ](name='Services'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: string(name='MaxResults'),
}

model ListVpcEndpointServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcEndpointServicesResponseBody(name='body'),
}

async function listVpcEndpointServicesWithOptions(request: ListVpcEndpointServicesRequest, runtime: Util.RuntimeOptions): ListVpcEndpointServicesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVpcEndpointServices', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVpcEndpointServices(request: ListVpcEndpointServicesRequest): ListVpcEndpointServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVpcEndpointServicesWithOptions(request, runtime);
}

model AddZoneToVpcEndpointRequest {
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
  vSwitchId?: string(name='VSwitchId'),
  ip?: string(name='ip'),
  endpointId?: string(name='EndpointId'),
  dryRun?: boolean(name='DryRun'),
  clientToken?: string(name='ClientToken'),
}

model AddZoneToVpcEndpointResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddZoneToVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: AddZoneToVpcEndpointResponseBody(name='body'),
}

async function addZoneToVpcEndpointWithOptions(request: AddZoneToVpcEndpointRequest, runtime: Util.RuntimeOptions): AddZoneToVpcEndpointResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddZoneToVpcEndpoint', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addZoneToVpcEndpoint(request: AddZoneToVpcEndpointRequest): AddZoneToVpcEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return addZoneToVpcEndpointWithOptions(request, runtime);
}

model ListVpcEndpointConnectionsRequest {
  regionId?: string(name='RegionId'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  serviceId?: string(name='ServiceId'),
  endpointId?: string(name='EndpointId'),
  connectionStatus?: string(name='ConnectionStatus'),
  endpointOwnerId?: long(name='EndpointOwnerId'),
}

model ListVpcEndpointConnectionsResponseBody = {
  connections?: [ 
    {
      resourceOwner?: boolean(name='ResourceOwner'),
      zones?: [ 
        {
          vSwitchId?: string(name='VSwitchId'),
          zoneId?: string(name='ZoneId'),
          resourceId?: string(name='ResourceId'),
          eniId?: string(name='EniId'),
          zoneDomain?: string(name='ZoneDomain'),
        }
      ](name='Zones'),
      modifiedTime?: string(name='ModifiedTime'),
      bandwidth?: int32(name='Bandwidth'),
      endpointOwnerId?: long(name='EndpointOwnerId'),
      serviceId?: string(name='ServiceId'),
      connectionStatus?: string(name='ConnectionStatus'),
      endpointId?: string(name='EndpointId'),
      endpointVpcId?: string(name='EndpointVpcId'),
    }
  ](name='Connections'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: string(name='MaxResults'),
}

model ListVpcEndpointConnectionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcEndpointConnectionsResponseBody(name='body'),
}

async function listVpcEndpointConnectionsWithOptions(request: ListVpcEndpointConnectionsRequest, runtime: Util.RuntimeOptions): ListVpcEndpointConnectionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVpcEndpointConnections', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVpcEndpointConnections(request: ListVpcEndpointConnectionsRequest): ListVpcEndpointConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVpcEndpointConnectionsWithOptions(request, runtime);
}

model CreateVpcEndpointRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  endpointName?: string(name='EndpointName'),
  endpointDescription?: string(name='EndpointDescription'),
  vpcId?: string(name='VpcId'),
  serviceId?: string(name='ServiceId'),
  serviceName?: string(name='ServiceName'),
  zone?: [ 
    {
      vSwitchId?: string(name='VSwitchId'),
      zoneId?: string(name='ZoneId'),
      ip?: string(name='ip'),
    }
  ](name='Zone'),
  securityGroupId?: [ string ](name='SecurityGroupId'),
}

model CreateVpcEndpointResponseBody = {
  endpointDomain?: string(name='EndpointDomain'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  endpointBusinessStatus?: string(name='EndpointBusinessStatus'),
  endpointDescription?: string(name='EndpointDescription'),
  serviceId?: string(name='ServiceId'),
  endpointStatus?: string(name='EndpointStatus'),
  vpcId?: string(name='VpcId'),
  endpointName?: string(name='EndpointName'),
  serviceName?: string(name='ServiceName'),
  bandwidth?: long(name='Bandwidth'),
  endpointId?: string(name='EndpointId'),
  connectionStatus?: string(name='ConnectionStatus'),
}

model CreateVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpcEndpointResponseBody(name='body'),
}

async function createVpcEndpointWithOptions(request: CreateVpcEndpointRequest, runtime: Util.RuntimeOptions): CreateVpcEndpointResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVpcEndpoint', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVpcEndpoint(request: CreateVpcEndpointRequest): CreateVpcEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpcEndpointWithOptions(request, runtime);
}

model DetachSecurityGroupFromVpcEndpointRequest {
  regionId?: string(name='RegionId'),
  securityGroupId?: string(name='SecurityGroupId'),
  endpointId?: string(name='EndpointId'),
  dryRun?: boolean(name='DryRun'),
  clientToken?: string(name='ClientToken'),
}

model DetachSecurityGroupFromVpcEndpointResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachSecurityGroupFromVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: DetachSecurityGroupFromVpcEndpointResponseBody(name='body'),
}

async function detachSecurityGroupFromVpcEndpointWithOptions(request: DetachSecurityGroupFromVpcEndpointRequest, runtime: Util.RuntimeOptions): DetachSecurityGroupFromVpcEndpointResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetachSecurityGroupFromVpcEndpoint', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detachSecurityGroupFromVpcEndpoint(request: DetachSecurityGroupFromVpcEndpointRequest): DetachSecurityGroupFromVpcEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachSecurityGroupFromVpcEndpointWithOptions(request, runtime);
}

model CheckProductOpenResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckProductOpenResponse = {
  headers: map[string]string(name='headers'),
  body: CheckProductOpenResponseBody(name='body'),
}

async function checkProductOpenWithOptions(runtime: Util.RuntimeOptions): CheckProductOpenResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('CheckProductOpen', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function checkProductOpen(): CheckProductOpenResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkProductOpenWithOptions(runtime);
}

model GetVpcEndpointServiceAttributeRequest {
  regionId?: string(name='RegionId'),
  serviceId?: string(name='ServiceId'),
}

model GetVpcEndpointServiceAttributeResponseBody = {
  payer?: string(name='Payer'),
  requestId?: string(name='RequestId'),
  serviceDescription?: string(name='ServiceDescription'),
  createTime?: string(name='CreateTime'),
  maxBandwidth?: int32(name='MaxBandwidth'),
  minBandwidth?: int32(name='MinBandwidth'),
  serviceDomain?: string(name='ServiceDomain'),
  autoAcceptEnabled?: boolean(name='AutoAcceptEnabled'),
  zoneAffinityEnabled?: boolean(name='ZoneAffinityEnabled'),
  serviceId?: string(name='ServiceId'),
  zones?: [ string ](name='Zones'),
  serviceBusinessStatus?: string(name='ServiceBusinessStatus'),
  serviceName?: string(name='ServiceName'),
  serviceStatus?: string(name='ServiceStatus'),
  connectBandwidth?: int32(name='ConnectBandwidth'),
  regionId?: string(name='RegionId'),
}

model GetVpcEndpointServiceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: GetVpcEndpointServiceAttributeResponseBody(name='body'),
}

async function getVpcEndpointServiceAttributeWithOptions(request: GetVpcEndpointServiceAttributeRequest, runtime: Util.RuntimeOptions): GetVpcEndpointServiceAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetVpcEndpointServiceAttribute', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getVpcEndpointServiceAttribute(request: GetVpcEndpointServiceAttributeRequest): GetVpcEndpointServiceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVpcEndpointServiceAttributeWithOptions(request, runtime);
}

model RemoveUserFromVpcEndpointServiceRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  userId?: long(name='UserId'),
  serviceId?: string(name='ServiceId'),
}

model RemoveUserFromVpcEndpointServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveUserFromVpcEndpointServiceResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveUserFromVpcEndpointServiceResponseBody(name='body'),
}

async function removeUserFromVpcEndpointServiceWithOptions(request: RemoveUserFromVpcEndpointServiceRequest, runtime: Util.RuntimeOptions): RemoveUserFromVpcEndpointServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveUserFromVpcEndpointService', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeUserFromVpcEndpointService(request: RemoveUserFromVpcEndpointServiceRequest): RemoveUserFromVpcEndpointServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeUserFromVpcEndpointServiceWithOptions(request, runtime);
}

model DeleteVpcEndpointServiceRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  serviceId?: string(name='ServiceId'),
}

model DeleteVpcEndpointServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpcEndpointServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpcEndpointServiceResponseBody(name='body'),
}

async function deleteVpcEndpointServiceWithOptions(request: DeleteVpcEndpointServiceRequest, runtime: Util.RuntimeOptions): DeleteVpcEndpointServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVpcEndpointService', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVpcEndpointService(request: DeleteVpcEndpointServiceRequest): DeleteVpcEndpointServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpcEndpointServiceWithOptions(request, runtime);
}

model DisableVpcEndpointConnectionRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  serviceId?: string(name='ServiceId'),
  endpointId?: string(name='EndpointId'),
}

model DisableVpcEndpointConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableVpcEndpointConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DisableVpcEndpointConnectionResponseBody(name='body'),
}

async function disableVpcEndpointConnectionWithOptions(request: DisableVpcEndpointConnectionRequest, runtime: Util.RuntimeOptions): DisableVpcEndpointConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableVpcEndpointConnection', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableVpcEndpointConnection(request: DisableVpcEndpointConnectionRequest): DisableVpcEndpointConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableVpcEndpointConnectionWithOptions(request, runtime);
}

model GetVpcEndpointAttributeRequest {
  regionId?: string(name='RegionId'),
  endpointId?: string(name='EndpointId'),
}

model GetVpcEndpointAttributeResponseBody = {
  payer?: string(name='Payer'),
  endpointDomain?: string(name='EndpointDomain'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  resourceOwner?: boolean(name='ResourceOwner'),
  endpointBusinessStatus?: string(name='EndpointBusinessStatus'),
  endpointDescription?: string(name='EndpointDescription'),
  serviceId?: string(name='ServiceId'),
  endpointStatus?: string(name='EndpointStatus'),
  vpcId?: string(name='VpcId'),
  endpointName?: string(name='EndpointName'),
  serviceName?: string(name='ServiceName'),
  bandwidth?: int32(name='Bandwidth'),
  endpointId?: string(name='EndpointId'),
  regionId?: string(name='RegionId'),
  connectionStatus?: string(name='ConnectionStatus'),
  zoneAffinityEnabled?: boolean(name='ZoneAffinityEnabled'),
}

model GetVpcEndpointAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: GetVpcEndpointAttributeResponseBody(name='body'),
}

async function getVpcEndpointAttributeWithOptions(request: GetVpcEndpointAttributeRequest, runtime: Util.RuntimeOptions): GetVpcEndpointAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetVpcEndpointAttribute', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getVpcEndpointAttribute(request: GetVpcEndpointAttributeRequest): GetVpcEndpointAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVpcEndpointAttributeWithOptions(request, runtime);
}

model ListVpcEndpointZonesRequest {
  regionId?: string(name='RegionId'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  endpointId?: string(name='EndpointId'),
}

model ListVpcEndpointZonesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: string(name='MaxResults'),
  zones?: [ 
    {
      vSwitchId?: string(name='VSwitchId'),
      eniIp?: string(name='EniIp'),
      zoneStatus?: string(name='ZoneStatus'),
      zoneId?: string(name='ZoneId'),
      serviceStatus?: string(name='ServiceStatus'),
      eniId?: string(name='EniId'),
      zoneDomain?: string(name='ZoneDomain'),
      regionId?: string(name='RegionId'),
    }
  ](name='Zones'),
}

model ListVpcEndpointZonesResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcEndpointZonesResponseBody(name='body'),
}

async function listVpcEndpointZonesWithOptions(request: ListVpcEndpointZonesRequest, runtime: Util.RuntimeOptions): ListVpcEndpointZonesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVpcEndpointZones', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVpcEndpointZones(request: ListVpcEndpointZonesRequest): ListVpcEndpointZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVpcEndpointZonesWithOptions(request, runtime);
}

model AttachSecurityGroupToVpcEndpointRequest {
  regionId?: string(name='RegionId'),
  securityGroupId?: string(name='SecurityGroupId'),
  endpointId?: string(name='EndpointId'),
  dryRun?: boolean(name='DryRun'),
  clientToken?: string(name='ClientToken'),
}

model AttachSecurityGroupToVpcEndpointResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachSecurityGroupToVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: AttachSecurityGroupToVpcEndpointResponseBody(name='body'),
}

async function attachSecurityGroupToVpcEndpointWithOptions(request: AttachSecurityGroupToVpcEndpointRequest, runtime: Util.RuntimeOptions): AttachSecurityGroupToVpcEndpointResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AttachSecurityGroupToVpcEndpoint', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function attachSecurityGroupToVpcEndpoint(request: AttachSecurityGroupToVpcEndpointRequest): AttachSecurityGroupToVpcEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachSecurityGroupToVpcEndpointWithOptions(request, runtime);
}

model DetachResourceFromVpcEndpointServiceRequest {
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
  resourceId?: string(name='ResourceId'),
  serviceId?: string(name='ServiceId'),
  dryRun?: boolean(name='DryRun'),
  clientToken?: string(name='ClientToken'),
}

model DetachResourceFromVpcEndpointServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachResourceFromVpcEndpointServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DetachResourceFromVpcEndpointServiceResponseBody(name='body'),
}

async function detachResourceFromVpcEndpointServiceWithOptions(request: DetachResourceFromVpcEndpointServiceRequest, runtime: Util.RuntimeOptions): DetachResourceFromVpcEndpointServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetachResourceFromVpcEndpointService', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detachResourceFromVpcEndpointService(request: DetachResourceFromVpcEndpointServiceRequest): DetachResourceFromVpcEndpointServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachResourceFromVpcEndpointServiceWithOptions(request, runtime);
}

model AttachResourceToVpcEndpointServiceRequest {
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
  resourceId?: string(name='ResourceId'),
  serviceId?: string(name='ServiceId'),
  dryRun?: boolean(name='DryRun'),
  clientToken?: string(name='ClientToken'),
}

model AttachResourceToVpcEndpointServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachResourceToVpcEndpointServiceResponse = {
  headers: map[string]string(name='headers'),
  body: AttachResourceToVpcEndpointServiceResponseBody(name='body'),
}

async function attachResourceToVpcEndpointServiceWithOptions(request: AttachResourceToVpcEndpointServiceRequest, runtime: Util.RuntimeOptions): AttachResourceToVpcEndpointServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AttachResourceToVpcEndpointService', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function attachResourceToVpcEndpointService(request: AttachResourceToVpcEndpointServiceRequest): AttachResourceToVpcEndpointServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachResourceToVpcEndpointServiceWithOptions(request, runtime);
}

model ListVpcEndpointServiceResourcesRequest {
  regionId?: string(name='RegionId'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  serviceId?: string(name='ServiceId'),
}

model ListVpcEndpointServiceResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: string(name='MaxResults'),
  resources?: [ 
    {
      vpcId?: string(name='VpcId'),
      vSwitchId?: string(name='VSwitchId'),
      resourceType?: string(name='ResourceType'),
      zoneId?: string(name='ZoneId'),
      ip?: string(name='Ip'),
      resourceId?: string(name='ResourceId'),
      regionId?: string(name='RegionId'),
    }
  ](name='Resources'),
}

model ListVpcEndpointServiceResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcEndpointServiceResourcesResponseBody(name='body'),
}

async function listVpcEndpointServiceResourcesWithOptions(request: ListVpcEndpointServiceResourcesRequest, runtime: Util.RuntimeOptions): ListVpcEndpointServiceResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVpcEndpointServiceResources', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVpcEndpointServiceResources(request: ListVpcEndpointServiceResourcesRequest): ListVpcEndpointServiceResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVpcEndpointServiceResourcesWithOptions(request, runtime);
}

model UpdateVpcEndpointAttributeRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  endpointId?: string(name='EndpointId'),
  endpointName?: string(name='EndpointName'),
  endpointDescription?: string(name='EndpointDescription'),
}

model UpdateVpcEndpointAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateVpcEndpointAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVpcEndpointAttributeResponseBody(name='body'),
}

async function updateVpcEndpointAttributeWithOptions(request: UpdateVpcEndpointAttributeRequest, runtime: Util.RuntimeOptions): UpdateVpcEndpointAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateVpcEndpointAttribute', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateVpcEndpointAttribute(request: UpdateVpcEndpointAttributeRequest): UpdateVpcEndpointAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVpcEndpointAttributeWithOptions(request, runtime);
}

model CreateVpcEndpointServiceRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  serviceDescription?: string(name='ServiceDescription'),
  autoAcceptEnabled?: boolean(name='AutoAcceptEnabled'),
  payer?: string(name='Payer'),
  zoneAffinityEnabled?: boolean(name='ZoneAffinityEnabled'),
  resource?: [ 
    {
      resourceType?: string(name='ResourceType'),
      resourceId?: string(name='ResourceId'),
    }
  ](name='Resource'),
}

model CreateVpcEndpointServiceResponseBody = {
  serviceBusinessStatus?: string(name='ServiceBusinessStatus'),
  requestId?: string(name='RequestId'),
  serviceName?: string(name='ServiceName'),
  serviceStatus?: string(name='ServiceStatus'),
  serviceDescription?: string(name='ServiceDescription'),
  createTime?: string(name='CreateTime'),
  serviceDomain?: string(name='ServiceDomain'),
  zoneAffinityEnabled?: boolean(name='ZoneAffinityEnabled'),
  autoAcceptEnabled?: boolean(name='AutoAcceptEnabled'),
  serviceId?: string(name='ServiceId'),
}

model CreateVpcEndpointServiceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpcEndpointServiceResponseBody(name='body'),
}

async function createVpcEndpointServiceWithOptions(request: CreateVpcEndpointServiceRequest, runtime: Util.RuntimeOptions): CreateVpcEndpointServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVpcEndpointService', '2020-04-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVpcEndpointService(request: CreateVpcEndpointServiceRequest): CreateVpcEndpointServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpcEndpointServiceWithOptions(request, runtime);
}

