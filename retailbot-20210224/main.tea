/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('retailbot', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddBlackEntryRequest {
  blackEntryValue?: string(name='BlackEntryValue'),
  robotCode?: string(name='RobotCode'),
  slotId?: int32(name='SlotId'),
}

model AddBlackEntryResponseBody = {
  code?: string(name='Code'),
  data?: int32(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddBlackEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddBlackEntryResponseBody(name='body'),
}

async function addBlackEntryWithOptions(request: AddBlackEntryRequest, runtime: Util.RuntimeOptions): AddBlackEntryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.blackEntryValue)) {
    body['BlackEntryValue'] = request.blackEntryValue;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.slotId)) {
    body['SlotId'] = request.slotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddBlackEntry',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addBlackEntry(request: AddBlackEntryRequest): AddBlackEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBlackEntryWithOptions(request, runtime);
}

model AddCoreEntryRequest {
  robotCode?: string(name='RobotCode'),
  similarEntry?: {
    coreValue?: string(name='CoreValue'),
    similarValues?: [ string ](name='SimilarValues'),
  }(name='SimilarEntry'),
  slotId?: int32(name='SlotId'),
}

model AddCoreEntryShrinkRequest {
  robotCode?: string(name='RobotCode'),
  similarEntryShrink?: string(name='SimilarEntry'),
  slotId?: int32(name='SlotId'),
}

model AddCoreEntryResponseBody = {
  code?: string(name='Code'),
  data?: int32(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddCoreEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddCoreEntryResponseBody(name='body'),
}

async function addCoreEntryWithOptions(tmpReq: AddCoreEntryRequest, runtime: Util.RuntimeOptions): AddCoreEntryResponse {
  Util.validateModel(tmpReq);
  var request = new AddCoreEntryShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.similarEntry)) {
    request.similarEntryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.similarEntry, 'SimilarEntry', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.similarEntryShrink)) {
    body['SimilarEntry'] = request.similarEntryShrink;
  }
  if (!Util.isUnset(request.slotId)) {
    body['SlotId'] = request.slotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddCoreEntry',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addCoreEntry(request: AddCoreEntryRequest): AddCoreEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCoreEntryWithOptions(request, runtime);
}

model AddSlotRequest {
  alias?: string(name='Alias'),
  categoryId?: int32(name='CategoryId'),
  description?: string(name='Description'),
  ownStatus?: int32(name='OwnStatus'),
  robotCode?: string(name='RobotCode'),
  similarEntryList?: [ 
    {
      coreValue?: string(name='CoreValue'),
      similarValues?: [ string ](name='SimilarValues'),
    }
  ](name='SimilarEntryList'),
}

model AddSlotShrinkRequest {
  alias?: string(name='Alias'),
  categoryId?: int32(name='CategoryId'),
  description?: string(name='Description'),
  ownStatus?: int32(name='OwnStatus'),
  robotCode?: string(name='RobotCode'),
  similarEntryListShrink?: string(name='SimilarEntryList'),
}

model AddSlotResponseBody = {
  code?: string(name='Code'),
  data?: int32(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddSlotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddSlotResponseBody(name='body'),
}

async function addSlotWithOptions(tmpReq: AddSlotRequest, runtime: Util.RuntimeOptions): AddSlotResponse {
  Util.validateModel(tmpReq);
  var request = new AddSlotShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.similarEntryList)) {
    request.similarEntryListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.similarEntryList, 'SimilarEntryList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.alias)) {
    body['Alias'] = request.alias;
  }
  if (!Util.isUnset(request.categoryId)) {
    body['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.ownStatus)) {
    body['OwnStatus'] = request.ownStatus;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.similarEntryListShrink)) {
    body['SimilarEntryList'] = request.similarEntryListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddSlot',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addSlot(request: AddSlotRequest): AddSlotResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSlotWithOptions(request, runtime);
}

model AddSolutionRequest {
  knowledgeId?: long(name='KnowledgeId'),
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  robotCode?: string(name='RobotCode'),
  solution?: {
    conditions?: [ 
      {
        conditionType?: string(name='ConditionType'),
        conditionValue?: string(name='ConditionValue'),
        knowledgeId?: long(name='KnowledgeId'),
      }
    ](name='Conditions'),
    extraContent?: string(name='ExtraContent'),
    knowledgeId?: long(name='KnowledgeId'),
    solutionContent?: string(name='SolutionContent'),
    solutionSource?: string(name='SolutionSource'),
    solutionType?: string(name='SolutionType'),
    solutionVariables?: [ 
      {
        knowledgeId?: long(name='KnowledgeId'),
        solutionId?: long(name='SolutionId'),
        variableName?: string(name='VariableName'),
        variableType?: string(name='VariableType'),
      }
    ](name='SolutionVariables'),
  }(name='Solution'),
}

model AddSolutionShrinkRequest {
  knowledgeId?: long(name='KnowledgeId'),
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  robotCode?: string(name='RobotCode'),
  solutionShrink?: string(name='Solution'),
}

model AddSolutionResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  solutionId?: long(name='SolutionId'),
  success?: boolean(name='Success'),
}

model AddSolutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddSolutionResponseBody(name='body'),
}

async function addSolutionWithOptions(tmpReq: AddSolutionRequest, runtime: Util.RuntimeOptions): AddSolutionResponse {
  Util.validateModel(tmpReq);
  var request = new AddSolutionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.solution)) {
    request.solutionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.solution, 'Solution', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.knowledgeId)) {
    body['KnowledgeId'] = request.knowledgeId;
  }
  if (!Util.isUnset(request.operatorId)) {
    body['OperatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorName)) {
    body['OperatorName'] = request.operatorName;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.solutionShrink)) {
    body['Solution'] = request.solutionShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddSolution',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addSolution(request: AddSolutionRequest): AddSolutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSolutionWithOptions(request, runtime);
}

model AdminTestSeviceRequest {
  aliyunAccountDTO?: {
    aliUid?: long(name='AliUid'),
  }(name='AliyunAccountDTO'),
  versionId?: long(name='VersionId'),
}

model AdminTestSeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model AdminTestSeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AdminTestSeviceResponseBody(name='body'),
}

async function adminTestSeviceWithOptions(request: AdminTestSeviceRequest, runtime: Util.RuntimeOptions): AdminTestSeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.aliyunAccountDTO)) {
    bodyFlat['AliyunAccountDTO'] = request.aliyunAccountDTO;
  }
  if (!Util.isUnset(request.versionId)) {
    body['VersionId'] = request.versionId;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AdminTestSevice',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function adminTestSevice(request: AdminTestSeviceRequest): AdminTestSeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return adminTestSeviceWithOptions(request, runtime);
}

model AppGrayListBatchRemoveRequest {
  appCode?: string(name='AppCode'),
  content?: [ string ](name='Content'),
  instanceId?: string(name='InstanceId'),
  tenantId?: long(name='TenantId'),
}

model AppGrayListBatchRemoveResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AppGrayListBatchRemoveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AppGrayListBatchRemoveResponseBody(name='body'),
}

async function appGrayListBatchRemoveWithOptions(request: AppGrayListBatchRemoveRequest, runtime: Util.RuntimeOptions): AppGrayListBatchRemoveResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appCode)) {
    query['AppCode'] = request.appCode;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tenantId)) {
    query['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AppGrayListBatchRemove',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function appGrayListBatchRemove(request: AppGrayListBatchRemoveRequest): AppGrayListBatchRemoveResponse {
  var runtime = new Util.RuntimeOptions{};
  return appGrayListBatchRemoveWithOptions(request, runtime);
}

model AppGrayListBatchSaveRequest {
  appCode?: string(name='AppCode'),
  content?: [ 
    {
      sellerId?: string(name='SellerId'),
      sellerName?: string(name='SellerName'),
      shopId?: string(name='ShopId'),
      shopName?: string(name='ShopName'),
      version?: string(name='Version'),
    }
  ](name='Content'),
  instanceId?: string(name='InstanceId'),
  tenantId?: long(name='TenantId'),
}

model AppGrayListBatchSaveResponseBody = {
  code?: string(name='Code'),
  data?: any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AppGrayListBatchSaveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AppGrayListBatchSaveResponseBody(name='body'),
}

async function appGrayListBatchSaveWithOptions(request: AppGrayListBatchSaveRequest, runtime: Util.RuntimeOptions): AppGrayListBatchSaveResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appCode)) {
    query['AppCode'] = request.appCode;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tenantId)) {
    query['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AppGrayListBatchSave',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function appGrayListBatchSave(request: AppGrayListBatchSaveRequest): AppGrayListBatchSaveResponse {
  var runtime = new Util.RuntimeOptions{};
  return appGrayListBatchSaveWithOptions(request, runtime);
}

model CanRefundRequest {
  data?: string(name='Data'),
}

model CanRefundResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CanRefundResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CanRefundResponseBody(name='body'),
}

async function canRefundWithOptions(request: CanRefundRequest, runtime: Util.RuntimeOptions): CanRefundResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CanRefund',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function canRefund(request: CanRefundRequest): CanRefundResponse {
  var runtime = new Util.RuntimeOptions{};
  return canRefundWithOptions(request, runtime);
}

model CompleteCommodityRequest {
  data?: string(name='data'),
}

model CompleteCommodityResponseBody = {
  code?: string(name='code'),
  data?: string(name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  synchro?: string(name='synchro'),
}

model CompleteCommodityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CompleteCommodityResponseBody(name='body'),
}

async function completeCommodityWithOptions(request: CompleteCommodityRequest, runtime: Util.RuntimeOptions): CompleteCommodityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.data)) {
    query['data'] = request.data;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CompleteCommodity',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function completeCommodity(request: CompleteCommodityRequest): CompleteCommodityResponse {
  var runtime = new Util.RuntimeOptions{};
  return completeCommodityWithOptions(request, runtime);
}

model CreateAgingRequest {
  endTime?: long(name='EndTime'),
  instanceType?: string(name='InstanceType'),
  name?: string(name='Name'),
  robotCode?: string(name='RobotCode'),
  startTime?: long(name='StartTime'),
  timeDay?: string(name='TimeDay'),
  type?: string(name='Type'),
}

model CreateAgingResponseBody = {
  code?: string(name='Code'),
  data?: long(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateAgingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAgingResponseBody(name='body'),
}

async function createAgingWithOptions(request: CreateAgingRequest, runtime: Util.RuntimeOptions): CreateAgingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.timeDay)) {
    body['TimeDay'] = request.timeDay;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAging',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAging(request: CreateAgingRequest): CreateAgingResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAgingWithOptions(request, runtime);
}

model CreateJobRequest {
  activeJobDTO?: {
    appCode?: string(name='AppCode'),
    appVersion?: string(name='AppVersion'),
    config?: string(name='Config'),
    endTime?: long(name='EndTime'),
    instanceId?: string(name='InstanceId'),
    jobName?: string(name='JobName'),
    shopId?: string(name='ShopId'),
    startTime?: long(name='StartTime'),
  }(name='ActiveJobDTO'),
  userProfile?: {
    tenantId?: long(name='TenantId'),
  }(name='UserProfile'),
}

model CreateJobShrinkRequest {
  activeJobDTOShrink?: string(name='ActiveJobDTO'),
  userProfileShrink?: string(name='UserProfile'),
}

model CreateJobResponseBody = {
  code?: string(name='Code'),
  data?: long(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateJobResponseBody(name='body'),
}

async function createJobWithOptions(tmpReq: CreateJobRequest, runtime: Util.RuntimeOptions): CreateJobResponse {
  Util.validateModel(tmpReq);
  var request = new CreateJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.activeJobDTO)) {
    request.activeJobDTOShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.activeJobDTO, 'ActiveJobDTO', 'json');
  }
  if (!Util.isUnset(tmpReq.userProfile)) {
    request.userProfileShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userProfile, 'UserProfile', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.userProfileShrink)) {
    query['UserProfile'] = request.userProfileShrink;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.activeJobDTOShrink)) {
    body['ActiveJobDTO'] = request.activeJobDTOShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateJob',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createJob(request: CreateJobRequest): CreateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobWithOptions(request, runtime);
}

model CreateOutboundJobRequest {
  outboundJobDTO?: {
    appCode?: string(name='AppCode'),
    config?: string(name='Config'),
    crowdConfig?: string(name='CrowdConfig'),
    crowdType?: int32(name='CrowdType'),
    endTime?: string(name='EndTime'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    jobName?: string(name='JobName'),
    runConfig?: string(name='RunConfig'),
    runType?: int32(name='RunType'),
    saasId?: string(name='SaasId'),
    shopId?: long(name='ShopId'),
    startTime?: string(name='StartTime'),
    status?: int32(name='Status'),
    tenantId?: long(name='TenantId'),
    version?: string(name='Version'),
  }(name='OutboundJobDTO'),
  userProfile?: {
    appCode?: string(name='AppCode'),
    buId?: long(name='BuId'),
    platformCode?: string(name='PlatformCode'),
    tenantId?: long(name='TenantId'),
    userId?: long(name='UserId'),
    userNick?: string(name='UserNick'),
  }(name='UserProfile'),
}

model CreateOutboundJobShrinkRequest {
  outboundJobDTOShrink?: string(name='OutboundJobDTO'),
  userProfileShrink?: string(name='UserProfile'),
}

model CreateOutboundJobResponseBody = {
  code?: string(name='Code'),
  data?: long(name='Data'),
  message?: string(name='Message'),
  success?: boolean(name='Success'),
}

model CreateOutboundJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOutboundJobResponseBody(name='body'),
}

async function createOutboundJobWithOptions(tmpReq: CreateOutboundJobRequest, runtime: Util.RuntimeOptions): CreateOutboundJobResponse {
  Util.validateModel(tmpReq);
  var request = new CreateOutboundJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.outboundJobDTO)) {
    request.outboundJobDTOShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.outboundJobDTO, 'OutboundJobDTO', 'json');
  }
  if (!Util.isUnset(tmpReq.userProfile)) {
    request.userProfileShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userProfile, 'UserProfile', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.outboundJobDTOShrink)) {
    query['OutboundJobDTO'] = request.outboundJobDTOShrink;
  }
  if (!Util.isUnset(request.userProfileShrink)) {
    query['UserProfile'] = request.userProfileShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOutboundJob',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOutboundJob(request: CreateOutboundJobRequest): CreateOutboundJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOutboundJobWithOptions(request, runtime);
}

model CreateRobotRequest {
  operator?: {
    operatorId?: string(name='OperatorId'),
    operatorName?: string(name='OperatorName'),
  }(name='Operator'),
  robotDTO?: {
    channel?: string(name='Channel'),
    expireDate?: long(name='ExpireDate'),
    instanceId?: string(name='InstanceId'),
    robotType?: string(name='RobotType'),
    sellerId?: string(name='SellerId'),
    sellerNick?: string(name='SellerNick'),
    shopId?: string(name='ShopId'),
    signDate?: long(name='SignDate'),
  }(name='RobotDTO'),
}

model CreateRobotShrinkRequest {
  operatorShrink?: string(name='Operator'),
  robotDTOShrink?: string(name='RobotDTO'),
}

model CreateRobotResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  robotCode?: string(name='RobotCode'),
  success?: boolean(name='Success'),
}

model CreateRobotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRobotResponseBody(name='body'),
}

async function createRobotWithOptions(tmpReq: CreateRobotRequest, runtime: Util.RuntimeOptions): CreateRobotResponse {
  Util.validateModel(tmpReq);
  var request = new CreateRobotShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.operator)) {
    request.operatorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.operator, 'Operator', 'json');
  }
  if (!Util.isUnset(tmpReq.robotDTO)) {
    request.robotDTOShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.robotDTO, 'RobotDTO', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.operatorShrink)) {
    body['Operator'] = request.operatorShrink;
  }
  if (!Util.isUnset(request.robotDTOShrink)) {
    body['RobotDTO'] = request.robotDTOShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRobot',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRobot(request: CreateRobotRequest): CreateRobotResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRobotWithOptions(request, runtime);
}

model CreateTaskRequest {
  digTaskInfoParam?: {
    operatorId?: string(name='OperatorId'),
    operatorName?: string(name='OperatorName'),
    paramConfig?: string(name='ParamConfig'),
    robotCode?: string(name='RobotCode'),
    type?: string(name='Type'),
  }(name='DigTaskInfoParam'),
}

model CreateTaskShrinkRequest {
  digTaskInfoParamShrink?: string(name='DigTaskInfoParam'),
}

model CreateTaskResponseBody = {
  code?: string(name='Code'),
  data?: long(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTaskResponseBody(name='body'),
}

async function createTaskWithOptions(tmpReq: CreateTaskRequest, runtime: Util.RuntimeOptions): CreateTaskResponse {
  Util.validateModel(tmpReq);
  var request = new CreateTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.digTaskInfoParam)) {
    request.digTaskInfoParamShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.digTaskInfoParam, 'DigTaskInfoParam', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.digTaskInfoParamShrink)) {
    body['DigTaskInfoParam'] = request.digTaskInfoParamShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTask',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTask(request: CreateTaskRequest): CreateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTaskWithOptions(request, runtime);
}

model CreateUserAccessTokenRequest {
  aliyunUid?: string(name='AliyunUid'),
  expireTime?: long(name='ExpireTime'),
  extraInfo?: string(name='ExtraInfo'),
  sourceId?: long(name='SourceId'),
  sourceKey?: string(name='SourceKey'),
  userDto?: {
    foreignId?: string(name='ForeignId'),
    nick?: string(name='Nick'),
  }(name='UserDto'),
}

model CreateUserAccessTokenResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateUserAccessTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUserAccessTokenResponseBody(name='body'),
}

async function createUserAccessTokenWithOptions(request: CreateUserAccessTokenRequest, runtime: Util.RuntimeOptions): CreateUserAccessTokenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.aliyunUid)) {
    body['AliyunUid'] = request.aliyunUid;
  }
  if (!Util.isUnset(request.expireTime)) {
    body['ExpireTime'] = request.expireTime;
  }
  if (!Util.isUnset(request.extraInfo)) {
    body['ExtraInfo'] = request.extraInfo;
  }
  if (!Util.isUnset(request.sourceId)) {
    body['SourceId'] = request.sourceId;
  }
  if (!Util.isUnset(request.sourceKey)) {
    body['SourceKey'] = request.sourceKey;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.userDto)) {
    bodyFlat['UserDto'] = request.userDto;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateUserAccessToken',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUserAccessToken(request: CreateUserAccessTokenRequest): CreateUserAccessTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserAccessTokenWithOptions(request, runtime);
}

model DeleteAgingRequest {
  agingIds?: [ long ](name='AgingIds'),
  instanceType?: string(name='InstanceType'),
  robotCode?: string(name='RobotCode'),
}

model DeleteAgingResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteAgingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAgingResponseBody(name='body'),
}

async function deleteAgingWithOptions(request: DeleteAgingRequest, runtime: Util.RuntimeOptions): DeleteAgingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.agingIds)) {
    bodyFlat['AgingIds'] = request.agingIds;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAging',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAging(request: DeleteAgingRequest): DeleteAgingResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAgingWithOptions(request, runtime);
}

model DeleteBlackEntryRequest {
  blackEntryId?: int32(name='BlackEntryId'),
  robotCode?: string(name='RobotCode'),
  slotId?: int32(name='SlotId'),
}

model DeleteBlackEntryResponseBody = {
  code?: string(name='Code'),
  data?: int32(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteBlackEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBlackEntryResponseBody(name='body'),
}

async function deleteBlackEntryWithOptions(request: DeleteBlackEntryRequest, runtime: Util.RuntimeOptions): DeleteBlackEntryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.blackEntryId)) {
    body['BlackEntryId'] = request.blackEntryId;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.slotId)) {
    body['SlotId'] = request.slotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBlackEntry',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBlackEntry(request: DeleteBlackEntryRequest): DeleteBlackEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBlackEntryWithOptions(request, runtime);
}

model DeleteCoreEntryRequest {
  robotCode?: string(name='RobotCode'),
  similarEntry?: {
    coreEntryId?: int32(name='CoreEntryId'),
  }(name='SimilarEntry'),
  slotId?: int32(name='SlotId'),
}

model DeleteCoreEntryShrinkRequest {
  robotCode?: string(name='RobotCode'),
  similarEntryShrink?: string(name='SimilarEntry'),
  slotId?: int32(name='SlotId'),
}

model DeleteCoreEntryResponseBody = {
  code?: string(name='Code'),
  data?: int32(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteCoreEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCoreEntryResponseBody(name='body'),
}

async function deleteCoreEntryWithOptions(tmpReq: DeleteCoreEntryRequest, runtime: Util.RuntimeOptions): DeleteCoreEntryResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteCoreEntryShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.similarEntry)) {
    request.similarEntryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.similarEntry, 'SimilarEntry', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.similarEntryShrink)) {
    body['SimilarEntry'] = request.similarEntryShrink;
  }
  if (!Util.isUnset(request.slotId)) {
    body['SlotId'] = request.slotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCoreEntry',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCoreEntry(request: DeleteCoreEntryRequest): DeleteCoreEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCoreEntryWithOptions(request, runtime);
}

model DeleteJobRequest {
  appCode?: string(name='AppCode'),
  instanceId?: string(name='InstanceId'),
  jobId?: long(name='JobId'),
  shopId?: string(name='ShopId'),
  userProfile?: {
    tenantId?: long(name='TenantId'),
  }(name='UserProfile'),
}

model DeleteJobShrinkRequest {
  appCode?: string(name='AppCode'),
  instanceId?: string(name='InstanceId'),
  jobId?: long(name='JobId'),
  shopId?: string(name='ShopId'),
  userProfileShrink?: string(name='UserProfile'),
}

model DeleteJobResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteJobResponseBody(name='body'),
}

async function deleteJobWithOptions(tmpReq: DeleteJobRequest, runtime: Util.RuntimeOptions): DeleteJobResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.userProfile)) {
    request.userProfileShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userProfile, 'UserProfile', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteJob',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteJob(request: DeleteJobRequest): DeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteJobWithOptions(request, runtime);
}

model DeleteRobotRequest {
  memo?: string(name='Memo'),
  operator?: {
    operatorId?: string(name='OperatorId'),
    operatorName?: string(name='OperatorName'),
  }(name='Operator'),
  robotCode?: string(name='RobotCode'),
}

model DeleteRobotShrinkRequest {
  memo?: string(name='Memo'),
  operatorShrink?: string(name='Operator'),
  robotCode?: string(name='RobotCode'),
}

model DeleteRobotResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteRobotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRobotResponseBody(name='body'),
}

async function deleteRobotWithOptions(tmpReq: DeleteRobotRequest, runtime: Util.RuntimeOptions): DeleteRobotResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteRobotShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.operator)) {
    request.operatorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.operator, 'Operator', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.memo)) {
    body['Memo'] = request.memo;
  }
  if (!Util.isUnset(request.operatorShrink)) {
    body['Operator'] = request.operatorShrink;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRobot',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRobot(request: DeleteRobotRequest): DeleteRobotResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRobotWithOptions(request, runtime);
}

model DeleteSlotRequest {
  robotCode?: string(name='RobotCode'),
  slotId?: int32(name='SlotId'),
}

model DeleteSlotResponseBody = {
  code?: string(name='Code'),
  data?: int32(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSlotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSlotResponseBody(name='body'),
}

async function deleteSlotWithOptions(request: DeleteSlotRequest, runtime: Util.RuntimeOptions): DeleteSlotResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.slotId)) {
    body['SlotId'] = request.slotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSlot',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSlot(request: DeleteSlotRequest): DeleteSlotResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSlotWithOptions(request, runtime);
}

model DeleteSolutionRequest {
  knowledgeId?: long(name='KnowledgeId'),
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  robotCode?: string(name='RobotCode'),
  solutionIds?: [ long ](name='SolutionIds'),
}

model DeleteSolutionShrinkRequest {
  knowledgeId?: long(name='KnowledgeId'),
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  robotCode?: string(name='RobotCode'),
  solutionIdsShrink?: string(name='SolutionIds'),
}

model DeleteSolutionResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSolutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSolutionResponseBody(name='body'),
}

async function deleteSolutionWithOptions(tmpReq: DeleteSolutionRequest, runtime: Util.RuntimeOptions): DeleteSolutionResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteSolutionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.solutionIds)) {
    request.solutionIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.solutionIds, 'SolutionIds', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.knowledgeId)) {
    body['KnowledgeId'] = request.knowledgeId;
  }
  if (!Util.isUnset(request.operatorId)) {
    body['OperatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorName)) {
    body['OperatorName'] = request.operatorName;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.solutionIdsShrink)) {
    body['SolutionIds'] = request.solutionIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSolution',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSolution(request: DeleteSolutionRequest): DeleteSolutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSolutionWithOptions(request, runtime);
}

model DeleteTaskRequest {
  digDeleteParam?: {
    delMessage?: string(name='DelMessage'),
    operatorId?: string(name='OperatorId'),
    operatorName?: string(name='OperatorName'),
    robotCode?: string(name='RobotCode'),
    taskId?: long(name='TaskId'),
  }(name='DigDeleteParam'),
}

model DeleteTaskShrinkRequest {
  digDeleteParamShrink?: string(name='DigDeleteParam'),
}

model DeleteTaskResponseBody = {
  code?: string(name='Code'),
  data?: long(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTaskResponseBody(name='body'),
}

async function deleteTaskWithOptions(tmpReq: DeleteTaskRequest, runtime: Util.RuntimeOptions): DeleteTaskResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.digDeleteParam)) {
    request.digDeleteParamShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.digDeleteParam, 'DigDeleteParam', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.digDeleteParamShrink)) {
    body['DigDeleteParam'] = request.digDeleteParamShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTask',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTask(request: DeleteTaskRequest): DeleteTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTaskWithOptions(request, runtime);
}

model DisableSceneRequest {
  knowledgeIds?: [ long ](name='KnowledgeIds'),
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  robotCode?: string(name='RobotCode'),
}

model DisableSceneShrinkRequest {
  knowledgeIdsShrink?: string(name='KnowledgeIds'),
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  robotCode?: string(name='RobotCode'),
}

model DisableSceneResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableSceneResponseBody(name='body'),
}

async function disableSceneWithOptions(tmpReq: DisableSceneRequest, runtime: Util.RuntimeOptions): DisableSceneResponse {
  Util.validateModel(tmpReq);
  var request = new DisableSceneShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.knowledgeIds)) {
    request.knowledgeIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.knowledgeIds, 'KnowledgeIds', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.knowledgeIdsShrink)) {
    body['KnowledgeIds'] = request.knowledgeIdsShrink;
  }
  if (!Util.isUnset(request.operatorId)) {
    body['OperatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorName)) {
    body['OperatorName'] = request.operatorName;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DisableScene',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableScene(request: DisableSceneRequest): DisableSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableSceneWithOptions(request, runtime);
}

model EnableSceneRequest {
  knowledgeIds?: [ long ](name='KnowledgeIds'),
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  robotCode?: string(name='RobotCode'),
}

model EnableSceneShrinkRequest {
  knowledgeIdsShrink?: string(name='KnowledgeIds'),
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  robotCode?: string(name='RobotCode'),
}

model EnableSceneResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableSceneResponseBody(name='body'),
}

async function enableSceneWithOptions(tmpReq: EnableSceneRequest, runtime: Util.RuntimeOptions): EnableSceneResponse {
  Util.validateModel(tmpReq);
  var request = new EnableSceneShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.knowledgeIds)) {
    request.knowledgeIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.knowledgeIds, 'KnowledgeIds', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.knowledgeIdsShrink)) {
    body['KnowledgeIds'] = request.knowledgeIdsShrink;
  }
  if (!Util.isUnset(request.operatorId)) {
    body['OperatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorName)) {
    body['OperatorName'] = request.operatorName;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EnableScene',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableScene(request: EnableSceneRequest): EnableSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableSceneWithOptions(request, runtime);
}

model GenerateTokenRequest {
  expireTime?: int32(name='ExpireTime'),
  tenantId?: long(name='TenantId'),
  userDto?: {
    extraInfo?: string(name='ExtraInfo'),
    foreignId?: string(name='ForeignId'),
    nick?: string(name='Nick'),
    telephone?: string(name='Telephone'),
  }(name='UserDto'),
}

model GenerateTokenResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GenerateTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateTokenResponseBody(name='body'),
}

async function generateTokenWithOptions(request: GenerateTokenRequest, runtime: Util.RuntimeOptions): GenerateTokenResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateToken',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateToken(request: GenerateTokenRequest): GenerateTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateTokenWithOptions(request, runtime);
}

model GetActiveGroupRequest {
  appCode?: string(name='AppCode'),
  appVersion?: string(name='AppVersion'),
  groupId?: long(name='GroupId'),
  instanceId?: string(name='InstanceId'),
  shopId?: string(name='ShopId'),
  userProfile?: {
    tenantId?: long(name='TenantId'),
  }(name='UserProfile'),
}

model GetActiveGroupShrinkRequest {
  appCode?: string(name='AppCode'),
  appVersion?: string(name='AppVersion'),
  groupId?: long(name='GroupId'),
  instanceId?: string(name='InstanceId'),
  shopId?: string(name='ShopId'),
  userProfileShrink?: string(name='UserProfile'),
}

model GetActiveGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    appCode?: string(name='AppCode'),
    appVersion?: string(name='AppVersion'),
    config?: string(name='Config'),
    description?: string(name='Description'),
    gmtCreate?: long(name='GmtCreate'),
    gmtModified?: long(name='GmtModified'),
    instanceId?: string(name='InstanceId'),
    modifier?: string(name='Modifier'),
    name?: string(name='Name'),
    shopId?: string(name='ShopId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetActiveGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetActiveGroupResponseBody(name='body'),
}

async function getActiveGroupWithOptions(tmpReq: GetActiveGroupRequest, runtime: Util.RuntimeOptions): GetActiveGroupResponse {
  Util.validateModel(tmpReq);
  var request = new GetActiveGroupShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.userProfile)) {
    request.userProfileShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userProfile, 'UserProfile', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetActiveGroup',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getActiveGroup(request: GetActiveGroupRequest): GetActiveGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getActiveGroupWithOptions(request, runtime);
}

model GetJobRequest {
  appCode?: string(name='AppCode'),
  instanceId?: string(name='InstanceId'),
  jobId?: long(name='JobId'),
  shopId?: string(name='ShopId'),
  userProfile?: {
    tenantId?: long(name='TenantId'),
  }(name='UserProfile'),
}

model GetJobShrinkRequest {
  appCode?: string(name='AppCode'),
  instanceId?: string(name='InstanceId'),
  jobId?: long(name='JobId'),
  shopId?: string(name='ShopId'),
  userProfileShrink?: string(name='UserProfile'),
}

model GetJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    appCode?: string(name='AppCode'),
    appVersion?: string(name='AppVersion'),
    config?: string(name='Config'),
    endTime?: long(name='EndTime'),
    gmtCreate?: long(name='GmtCreate'),
    gmtModified?: long(name='GmtModified'),
    id?: long(name='Id'),
    instanceId?: string(name='InstanceId'),
    jobName?: string(name='JobName'),
    shopId?: string(name='ShopId'),
    startTime?: long(name='StartTime'),
    status?: int32(name='Status'),
    tenantId?: long(name='TenantId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJobResponseBody(name='body'),
}

async function getJobWithOptions(tmpReq: GetJobRequest, runtime: Util.RuntimeOptions): GetJobResponse {
  Util.validateModel(tmpReq);
  var request = new GetJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.userProfile)) {
    request.userProfileShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userProfile, 'UserProfile', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJob',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJob(request: GetJobRequest): GetJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobWithOptions(request, runtime);
}

model GetKnowledgeRequest {
  knowledgeId?: long(name='KnowledgeId'),
  needSolution?: boolean(name='NeedSolution'),
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  robotCode?: string(name='RobotCode'),
}

model GetKnowledgeResponseBody = {
  code?: string(name='Code'),
  knowledge?: {
    category?: {
      categoryId?: long(name='CategoryId'),
      categoryName?: string(name='CategoryName'),
      parentCategoryId?: long(name='ParentCategoryId'),
    }(name='Category'),
    createTime?: string(name='CreateTime'),
    createUserId?: string(name='CreateUserId'),
    knowledgeDescription?: string(name='KnowledgeDescription'),
    knowledgeId?: long(name='KnowledgeId'),
    knowledgeStatus?: string(name='KnowledgeStatus'),
    knowledgeTitle?: string(name='KnowledgeTitle'),
    modifyTime?: string(name='ModifyTime'),
    modifyUserId?: string(name='ModifyUserId'),
    packages?: [ 
      {
        packageCode?: string(name='PackageCode'),
        packageName?: string(name='PackageName'),
      }
    ](name='Packages'),
    sceneKey?: string(name='SceneKey'),
    similarQuestions?: [ 
      {
        createTime?: string(name='CreateTime'),
        createUserId?: string(name='CreateUserId'),
        modifyTime?: string(name='ModifyTime'),
        modifyUserId?: string(name='ModifyUserId'),
        similarQuestionEffectType?: string(name='SimilarQuestionEffectType'),
        similarQuestionId?: long(name='SimilarQuestionId'),
        similarQuestionTitle?: string(name='SimilarQuestionTitle'),
        similarQuestionType?: string(name='SimilarQuestionType'),
      }
    ](name='SimilarQuestions'),
    solutions?: [ 
      {
        conditions?: [ 
          {
            conditionType?: string(name='ConditionType'),
            conditionValue?: string(name='ConditionValue'),
            knowledgeId?: long(name='KnowledgeId'),
            solutionId?: long(name='SolutionId'),
          }
        ](name='Conditions'),
        extraContent?: string(name='ExtraContent'),
        knowledgeId?: long(name='KnowledgeId'),
        solutionContent?: string(name='SolutionContent'),
        solutionId?: long(name='SolutionId'),
        solutionSource?: string(name='SolutionSource'),
        solutionType?: string(name='SolutionType'),
        solutionVariables?: [ 
          {
            knowledgeId?: long(name='KnowledgeId'),
            solutionId?: long(name='SolutionId'),
            variableName?: string(name='VariableName'),
            variableType?: string(name='VariableType'),
          }
        ](name='SolutionVariables'),
      }
    ](name='Solutions'),
  }(name='Knowledge'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetKnowledgeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetKnowledgeResponseBody(name='body'),
}

async function getKnowledgeWithOptions(request: GetKnowledgeRequest, runtime: Util.RuntimeOptions): GetKnowledgeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.knowledgeId)) {
    body['KnowledgeId'] = request.knowledgeId;
  }
  if (!Util.isUnset(request.needSolution)) {
    body['NeedSolution'] = request.needSolution;
  }
  if (!Util.isUnset(request.operatorId)) {
    body['OperatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorName)) {
    body['OperatorName'] = request.operatorName;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetKnowledge',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getKnowledge(request: GetKnowledgeRequest): GetKnowledgeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getKnowledgeWithOptions(request, runtime);
}

model GetOssTokenRequest {
  bizType?: string(name='BizType'),
  userId?: string(name='UserId'),
}

model GetOssTokenResponseBody = {
  webUpoadPolicy?: {
    accessId?: string(name='AccessId'),
    dir?: string(name='Dir'),
    expire?: string(name='Expire'),
    host?: string(name='Host'),
    policy?: string(name='Policy'),
    signature?: string(name='Signature'),
  }(name='WebUpoadPolicy'),
}

model GetOssTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOssTokenResponseBody(name='body'),
}

async function getOssTokenWithOptions(request: GetOssTokenRequest, runtime: Util.RuntimeOptions): GetOssTokenResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOssToken',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOssToken(request: GetOssTokenRequest): GetOssTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOssTokenWithOptions(request, runtime);
}

model GetPackageVersionRequest {
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  packageCode?: string(name='PackageCode'),
}

model GetPackageVersionResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  packageCode?: string(name='PackageCode'),
  packageDetails?: [ 
    {
      createTime?: string(name='CreateTime'),
      createUserId?: string(name='CreateUserId'),
      modifyTime?: string(name='ModifyTime'),
      modifyUserId?: string(name='ModifyUserId'),
      packageDetailDescription?: string(name='PackageDetailDescription'),
      packageVersion?: string(name='PackageVersion'),
      publishTime?: string(name='PublishTime'),
    }
  ](name='PackageDetails'),
  packageName?: string(name='PackageName'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPackageVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPackageVersionResponseBody(name='body'),
}

async function getPackageVersionWithOptions(request: GetPackageVersionRequest, runtime: Util.RuntimeOptions): GetPackageVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.operatorId)) {
    body['OperatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorName)) {
    body['OperatorName'] = request.operatorName;
  }
  if (!Util.isUnset(request.packageCode)) {
    body['PackageCode'] = request.packageCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetPackageVersion',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPackageVersion(request: GetPackageVersionRequest): GetPackageVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPackageVersionWithOptions(request, runtime);
}

model GetSlotRequest {
  robotCode?: string(name='RobotCode'),
  slotId?: int32(name='SlotId'),
}

model GetSlotResponseBody = {
  code?: string(name='Code'),
  data?: {
    alias?: string(name='Alias'),
    blackEntryList?: [ 
      {
        id?: int32(name='Id'),
        slotId?: int32(name='SlotId'),
        value?: string(name='Value'),
      }
    ](name='BlackEntryList'),
    categoryId?: int32(name='CategoryId'),
    categoryName?: string(name='CategoryName'),
    description?: string(name='Description'),
    id?: int32(name='Id'),
    ownStatus?: int32(name='OwnStatus'),
    similarEntryList?: [ 
      {
        coreEntry?: {
          id?: int32(name='Id'),
          slotId?: int32(name='SlotId'),
          value?: string(name='Value'),
        }(name='CoreEntry'),
        similarEntries?: [ 
          {
            id?: int32(name='Id'),
            slotId?: int32(name='SlotId'),
            value?: string(name='Value'),
          }
        ](name='SimilarEntries'),
      }
    ](name='SimilarEntryList'),
    source?: int32(name='Source'),
    sourceName?: string(name='SourceName'),
    type?: int32(name='Type'),
    typeName?: string(name='TypeName'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSlotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSlotResponseBody(name='body'),
}

async function getSlotWithOptions(request: GetSlotRequest, runtime: Util.RuntimeOptions): GetSlotResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.slotId)) {
    body['SlotId'] = request.slotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetSlot',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSlot(request: GetSlotRequest): GetSlotResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSlotWithOptions(request, runtime);
}

model GetSolutionRequest {
  knowledgeId?: long(name='KnowledgeId'),
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  robotCode?: string(name='RobotCode'),
  solutionId?: long(name='SolutionId'),
}

model GetSolutionResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  solution?: {
    conditions?: [ 
      {
        conditionType?: string(name='ConditionType'),
        conditionValue?: string(name='ConditionValue'),
        knowledgeId?: long(name='KnowledgeId'),
        solutionId?: long(name='SolutionId'),
      }
    ](name='Conditions'),
    extraContent?: string(name='ExtraContent'),
    knowledgeId?: long(name='KnowledgeId'),
    solutionContent?: string(name='SolutionContent'),
    solutionId?: long(name='SolutionId'),
    solutionSource?: string(name='SolutionSource'),
    solutionType?: string(name='SolutionType'),
    solutionVariables?: [ 
      {
        knowledgeId?: long(name='KnowledgeId'),
        solutionId?: long(name='SolutionId'),
        variableName?: string(name='VariableName'),
        variableType?: string(name='VariableType'),
      }
    ](name='SolutionVariables'),
  }(name='Solution'),
  success?: boolean(name='Success'),
}

model GetSolutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSolutionResponseBody(name='body'),
}

async function getSolutionWithOptions(request: GetSolutionRequest, runtime: Util.RuntimeOptions): GetSolutionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.knowledgeId)) {
    body['KnowledgeId'] = request.knowledgeId;
  }
  if (!Util.isUnset(request.operatorId)) {
    body['OperatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorName)) {
    body['OperatorName'] = request.operatorName;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.solutionId)) {
    body['SolutionId'] = request.solutionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetSolution',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSolution(request: GetSolutionRequest): GetSolutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSolutionWithOptions(request, runtime);
}

model GetStsTokenRequest {
  tenantId?: long(name='TenantId'),
}

model GetStsTokenResponseBody = {
  code?: string(name='Code'),
  data?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    aliyunUid?: long(name='AliyunUid'),
    bizCode?: string(name='BizCode'),
    expiration?: string(name='Expiration'),
    securityToken?: string(name='SecurityToken'),
  }(name='Data'),
  message?: string(name='Message'),
  success?: boolean(name='Success'),
}

model GetStsTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetStsTokenResponseBody(name='body'),
}

async function getStsTokenWithOptions(request: GetStsTokenRequest, runtime: Util.RuntimeOptions): GetStsTokenResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetStsToken',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getStsToken(request: GetStsTokenRequest): GetStsTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStsTokenWithOptions(request, runtime);
}

model InstallPackageRequest {
  operator?: {
    operatorId?: string(name='OperatorId'),
    operatorName?: string(name='OperatorName'),
  }(name='Operator'),
  packages?: [ 
    {
      packageCode?: string(name='PackageCode'),
      packageVersion?: string(name='PackageVersion'),
    }
  ](name='Packages'),
  robotCode?: string(name='RobotCode'),
}

model InstallPackageShrinkRequest {
  operatorShrink?: string(name='Operator'),
  packagesShrink?: string(name='Packages'),
  robotCode?: string(name='RobotCode'),
}

model InstallPackageResponseBody = {
  code?: string(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InstallPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallPackageResponseBody(name='body'),
}

async function installPackageWithOptions(tmpReq: InstallPackageRequest, runtime: Util.RuntimeOptions): InstallPackageResponse {
  Util.validateModel(tmpReq);
  var request = new InstallPackageShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.operator)) {
    request.operatorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.operator, 'Operator', 'json');
  }
  if (!Util.isUnset(tmpReq.packages)) {
    request.packagesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.packages, 'Packages', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.operatorShrink)) {
    body['Operator'] = request.operatorShrink;
  }
  if (!Util.isUnset(request.packagesShrink)) {
    body['Packages'] = request.packagesShrink;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'InstallPackage',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installPackage(request: InstallPackageRequest): InstallPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return installPackageWithOptions(request, runtime);
}

model ListActiveGroupsRequest {
  appCode?: string(name='AppCode'),
  appVersion?: string(name='AppVersion'),
  instanceId?: string(name='InstanceId'),
  pageParam?: {
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
  }(name='PageParam'),
  shopId?: string(name='ShopId'),
  userProfile?: {
    tenantId?: long(name='TenantId'),
  }(name='UserProfile'),
}

model ListActiveGroupsShrinkRequest {
  appCode?: string(name='AppCode'),
  appVersion?: string(name='AppVersion'),
  instanceId?: string(name='InstanceId'),
  pageParamShrink?: string(name='PageParam'),
  shopId?: string(name='ShopId'),
  userProfileShrink?: string(name='UserProfile'),
}

model ListActiveGroupsResponseBody = {
  code?: string(name='Code'),
  data?: {
    groupList?: [ 
      {
        appCode?: string(name='AppCode'),
        appVersion?: string(name='AppVersion'),
        config?: string(name='Config'),
        description?: string(name='Description'),
        gmtCreate?: long(name='GmtCreate'),
        gmtModified?: long(name='GmtModified'),
        groupId?: long(name='GroupId'),
        instanceId?: string(name='InstanceId'),
        modifier?: string(name='Modifier'),
        name?: string(name='Name'),
        shopId?: string(name='ShopId'),
        status?: int32(name='Status'),
      }
    ](name='GroupList'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    totalPage?: int32(name='TotalPage'),
    totalSize?: long(name='TotalSize'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListActiveGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListActiveGroupsResponseBody(name='body'),
}

async function listActiveGroupsWithOptions(tmpReq: ListActiveGroupsRequest, runtime: Util.RuntimeOptions): ListActiveGroupsResponse {
  Util.validateModel(tmpReq);
  var request = new ListActiveGroupsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.pageParam)) {
    request.pageParamShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pageParam, 'PageParam', 'json');
  }
  if (!Util.isUnset(tmpReq.userProfile)) {
    request.userProfileShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userProfile, 'UserProfile', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListActiveGroups',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listActiveGroups(request: ListActiveGroupsRequest): ListActiveGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listActiveGroupsWithOptions(request, runtime);
}

model ListCategoriesRequest {
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  robotCode?: string(name='RobotCode'),
}

model ListCategoriesResponseBody = {
  categories?: [ 
    {
      categoryId?: long(name='CategoryId'),
      categoryName?: string(name='CategoryName'),
      children?: [ 
        {
          categoryId?: long(name='CategoryId'),
          categoryName?: string(name='CategoryName'),
          parentCategoryId?: long(name='ParentCategoryId'),
        }
      ](name='Children'),
      parentCategoryId?: long(name='ParentCategoryId'),
    }
  ](name='Categories'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListCategoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCategoriesResponseBody(name='body'),
}

async function listCategoriesWithOptions(request: ListCategoriesRequest, runtime: Util.RuntimeOptions): ListCategoriesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.operatorId)) {
    body['OperatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorName)) {
    body['OperatorName'] = request.operatorName;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListCategories',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCategories(request: ListCategoriesRequest): ListCategoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCategoriesWithOptions(request, runtime);
}

model ListIndustryPackagesRequest {
  domain?: string(name='Domain'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: int32(name='NextToken'),
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
}

model ListIndustryPackagesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  packagePage?: {
    maxResults?: int32(name='MaxResults'),
    nextToken?: int32(name='NextToken'),
    packages?: [ 
      {
        createTime?: string(name='CreateTime'),
        createUserId?: string(name='CreateUserId'),
        modifyTime?: string(name='ModifyTime'),
        modifyUserId?: string(name='ModifyUserId'),
        packageCode?: string(name='PackageCode'),
        packageDescription?: string(name='PackageDescription'),
        packageName?: string(name='PackageName'),
        packageType?: string(name='PackageType'),
      }
    ](name='Packages'),
    totalCount?: int32(name='TotalCount'),
  }(name='PackagePage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListIndustryPackagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIndustryPackagesResponseBody(name='body'),
}

async function listIndustryPackagesWithOptions(request: ListIndustryPackagesRequest, runtime: Util.RuntimeOptions): ListIndustryPackagesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domain)) {
    body['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.operatorId)) {
    body['OperatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorName)) {
    body['OperatorName'] = request.operatorName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListIndustryPackages',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listIndustryPackages(request: ListIndustryPackagesRequest): ListIndustryPackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIndustryPackagesWithOptions(request, runtime);
}

model ListJobsRequest {
  appCode?: string(name='AppCode'),
  instanceId?: string(name='InstanceId'),
  pageParam?: {
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
  }(name='PageParam'),
  shopId?: string(name='ShopId'),
  status?: [ int32 ](name='Status'),
  userProfile?: {
    tenantId?: long(name='TenantId'),
  }(name='UserProfile'),
}

model ListJobsShrinkRequest {
  appCode?: string(name='AppCode'),
  instanceId?: string(name='InstanceId'),
  pageParamShrink?: string(name='PageParam'),
  shopId?: string(name='ShopId'),
  statusShrink?: string(name='Status'),
  userProfileShrink?: string(name='UserProfile'),
}

model ListJobsResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobList?: [ 
      {
        appCode?: string(name='AppCode'),
        appVersion?: string(name='AppVersion'),
        config?: string(name='Config'),
        endTime?: long(name='EndTime'),
        gmtCreate?: long(name='GmtCreate'),
        gmtModified?: long(name='GmtModified'),
        instanceId?: string(name='InstanceId'),
        jobId?: string(name='JobId'),
        jobName?: string(name='JobName'),
        shopId?: string(name='ShopId'),
        startTime?: long(name='StartTime'),
        status?: int32(name='Status'),
      }
    ](name='JobList'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    totalPage?: int32(name='TotalPage'),
    totalSize?: long(name='TotalSize'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobsWithOptions(tmpReq: ListJobsRequest, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(tmpReq);
  var request = new ListJobsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.pageParam)) {
    request.pageParamShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pageParam, 'PageParam', 'json');
  }
  if (!Util.isUnset(tmpReq.status)) {
    request.statusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.status, 'Status', 'json');
  }
  if (!Util.isUnset(tmpReq.userProfile)) {
    request.userProfileShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userProfile, 'UserProfile', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.appCode)) {
    query['AppCode'] = request.appCode;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageParamShrink)) {
    query['PageParam'] = request.pageParamShrink;
  }
  if (!Util.isUnset(request.shopId)) {
    query['ShopId'] = request.shopId;
  }
  if (!Util.isUnset(request.statusShrink)) {
    query['Status'] = request.statusShrink;
  }
  if (!Util.isUnset(request.userProfileShrink)) {
    query['UserProfile'] = request.userProfileShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobs',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJobs(request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobsWithOptions(request, runtime);
}

model ListPackageKnowledgesRequest {
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  packageCode?: string(name='PackageCode'),
  packageVersion?: string(name='PackageVersion'),
  robotCode?: string(name='RobotCode'),
}

model ListPackageKnowledgesResponseBody = {
  code?: string(name='Code'),
  knowledges?: [ 
    {
      createTime?: string(name='CreateTime'),
      createUserId?: string(name='CreateUserId'),
      knowledgeDescription?: string(name='KnowledgeDescription'),
      knowledgeId?: long(name='KnowledgeId'),
      knowledgeStatus?: string(name='KnowledgeStatus'),
      knowledgeTitle?: string(name='KnowledgeTitle'),
      modifyTime?: string(name='ModifyTime'),
      modifyUserId?: string(name='ModifyUserId'),
      sceneKey?: string(name='SceneKey'),
      similarQuestions?: [ 
        {
          createTime?: string(name='CreateTime'),
          createUserId?: string(name='CreateUserId'),
          modifyTime?: string(name='ModifyTime'),
          modifyUserId?: string(name='ModifyUserId'),
          similarQuestionEffectType?: string(name='SimilarQuestionEffectType'),
          similarQuestionId?: long(name='SimilarQuestionId'),
          similarQuestionTitle?: string(name='SimilarQuestionTitle'),
          similarQuestionType?: string(name='SimilarQuestionType'),
        }
      ](name='SimilarQuestions'),
      solutions?: [ 
        {
          conditions?: [ 
            {
              conditionType?: string(name='ConditionType'),
              conditionValue?: string(name='ConditionValue'),
              knowledgeId?: long(name='KnowledgeId'),
              solutionId?: long(name='SolutionId'),
            }
          ](name='Conditions'),
          extraContent?: string(name='ExtraContent'),
          knowledgeId?: long(name='KnowledgeId'),
          solutionContent?: string(name='SolutionContent'),
          solutionId?: long(name='SolutionId'),
          solutionSource?: string(name='SolutionSource'),
          solutionType?: string(name='SolutionType'),
        }
      ](name='Solutions'),
    }
  ](name='Knowledges'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListPackageKnowledgesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPackageKnowledgesResponseBody(name='body'),
}

async function listPackageKnowledgesWithOptions(request: ListPackageKnowledgesRequest, runtime: Util.RuntimeOptions): ListPackageKnowledgesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.operatorId)) {
    body['OperatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorName)) {
    body['OperatorName'] = request.operatorName;
  }
  if (!Util.isUnset(request.packageCode)) {
    body['PackageCode'] = request.packageCode;
  }
  if (!Util.isUnset(request.packageVersion)) {
    body['PackageVersion'] = request.packageVersion;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPackageKnowledges',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPackageKnowledges(request: ListPackageKnowledgesRequest): ListPackageKnowledgesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPackageKnowledgesWithOptions(request, runtime);
}

model ListPackageVersionsRequest {
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  packageCodes?: [ string ](name='PackageCodes'),
}

model ListPackageVersionsShrinkRequest {
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  packageCodesShrink?: string(name='PackageCodes'),
}

model ListPackageVersionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  packages?: [ 
    {
      packageCode?: string(name='PackageCode'),
      packageDetails?: [ 
        {
          createTime?: string(name='CreateTime'),
          createUserId?: string(name='CreateUserId'),
          modifyTime?: string(name='ModifyTime'),
          modifyUserId?: string(name='ModifyUserId'),
          packageDetailDescription?: string(name='PackageDetailDescription'),
          packageVersion?: string(name='PackageVersion'),
          publishTime?: string(name='PublishTime'),
        }
      ](name='PackageDetails'),
      packageName?: string(name='PackageName'),
    }
  ](name='Packages'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListPackageVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPackageVersionsResponseBody(name='body'),
}

async function listPackageVersionsWithOptions(tmpReq: ListPackageVersionsRequest, runtime: Util.RuntimeOptions): ListPackageVersionsResponse {
  Util.validateModel(tmpReq);
  var request = new ListPackageVersionsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.packageCodes)) {
    request.packageCodesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.packageCodes, 'PackageCodes', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.operatorId)) {
    body['OperatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorName)) {
    body['OperatorName'] = request.operatorName;
  }
  if (!Util.isUnset(request.packageCodesShrink)) {
    body['PackageCodes'] = request.packageCodesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPackageVersions',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPackageVersions(request: ListPackageVersionsRequest): ListPackageVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPackageVersionsWithOptions(request, runtime);
}

model ListSlotsRequest {
  categoryId?: int32(name='CategoryId'),
  keyword?: string(name='Keyword'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  robotCode?: string(name='RobotCode'),
  source?: int32(name='Source'),
  type?: int32(name='Type'),
}

model ListSlotsResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNo?: int32(name='PageNo'),
    resultData?: [ 
      {
        alias?: string(name='Alias'),
        categoryId?: int32(name='CategoryId'),
        categoryName?: string(name='CategoryName'),
        description?: string(name='Description'),
        id?: int32(name='Id'),
        ownStatus?: int32(name='OwnStatus'),
        source?: int32(name='Source'),
        sourceName?: string(name='SourceName'),
        type?: int32(name='Type'),
        typeName?: string(name='TypeName'),
      }
    ](name='ResultData'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListSlotsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSlotsResponseBody(name='body'),
}

async function listSlotsWithOptions(request: ListSlotsRequest, runtime: Util.RuntimeOptions): ListSlotsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.categoryId)) {
    body['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.keyword)) {
    body['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNo)) {
    body['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.source)) {
    body['Source'] = request.source;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListSlots',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSlots(request: ListSlotsRequest): ListSlotsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSlotsWithOptions(request, runtime);
}

model ListSubscribedPackageKnowledgesRequest {
  categoryId?: long(name='CategoryId'),
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  packageCodes?: [ string ](name='PackageCodes'),
  robotCode?: string(name='RobotCode'),
}

model ListSubscribedPackageKnowledgesResponseBody = {
  code?: string(name='Code'),
  knowledges?: [ 
    {
      createTime?: string(name='CreateTime'),
      createUserId?: string(name='CreateUserId'),
      knowledgeDescription?: string(name='KnowledgeDescription'),
      knowledgeId?: long(name='KnowledgeId'),
      knowledgeStatus?: string(name='KnowledgeStatus'),
      knowledgeTitle?: string(name='KnowledgeTitle'),
      modifyTime?: string(name='ModifyTime'),
      modifyUserId?: string(name='ModifyUserId'),
      sceneKey?: string(name='SceneKey'),
      similarQuestions?: [ 
        {
          createTime?: string(name='CreateTime'),
          createUserId?: string(name='CreateUserId'),
          modifyTime?: string(name='ModifyTime'),
          modifyUserId?: string(name='ModifyUserId'),
          similarQuestionEffectType?: string(name='SimilarQuestionEffectType'),
          similarQuestionId?: long(name='SimilarQuestionId'),
          similarQuestionTitle?: string(name='SimilarQuestionTitle'),
          similarQuestionType?: string(name='SimilarQuestionType'),
        }
      ](name='SimilarQuestions'),
      solutions?: [ 
        {
          conditions?: [ 
            {
              conditionType?: string(name='ConditionType'),
              conditionValue?: string(name='ConditionValue'),
              knowledgeId?: long(name='KnowledgeId'),
              solutionId?: long(name='SolutionId'),
            }
          ](name='Conditions'),
          extraContent?: string(name='ExtraContent'),
          knowledgeId?: long(name='KnowledgeId'),
          solutionContent?: string(name='SolutionContent'),
          solutionId?: long(name='SolutionId'),
          solutionSource?: string(name='SolutionSource'),
          solutionType?: string(name='SolutionType'),
        }
      ](name='Solutions'),
    }
  ](name='Knowledges'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListSubscribedPackageKnowledgesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSubscribedPackageKnowledgesResponseBody(name='body'),
}

async function listSubscribedPackageKnowledgesWithOptions(request: ListSubscribedPackageKnowledgesRequest, runtime: Util.RuntimeOptions): ListSubscribedPackageKnowledgesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.categoryId)) {
    body['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.operatorId)) {
    body['OperatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorName)) {
    body['OperatorName'] = request.operatorName;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.packageCodes)) {
    bodyFlat['PackageCodes'] = request.packageCodes;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListSubscribedPackageKnowledges',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSubscribedPackageKnowledges(request: ListSubscribedPackageKnowledgesRequest): ListSubscribedPackageKnowledgesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSubscribedPackageKnowledgesWithOptions(request, runtime);
}

model ListSubscriptionByPackageRequest {
  packageDTO?: {
    packageCode?: string(name='PackageCode'),
    packageVersion?: string(name='PackageVersion'),
  }(name='PackageDTO'),
  pageData?: {
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='PageData'),
}

model ListSubscriptionByPackageShrinkRequest {
  packageDTOShrink?: string(name='PackageDTO'),
  pageDataShrink?: string(name='PageData'),
}

model ListSubscriptionByPackageResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageData?: {
    data?: [ 
      {
        packageCode?: string(name='PackageCode'),
        packageVersion?: string(name='PackageVersion'),
        robotCode?: string(name='RobotCode'),
      }
    ](name='Data'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageData'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListSubscriptionByPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSubscriptionByPackageResponseBody(name='body'),
}

async function listSubscriptionByPackageWithOptions(tmpReq: ListSubscriptionByPackageRequest, runtime: Util.RuntimeOptions): ListSubscriptionByPackageResponse {
  Util.validateModel(tmpReq);
  var request = new ListSubscriptionByPackageShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.packageDTO)) {
    request.packageDTOShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.packageDTO, 'PackageDTO', 'json');
  }
  if (!Util.isUnset(tmpReq.pageData)) {
    request.pageDataShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pageData, 'PageData', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.packageDTOShrink)) {
    body['PackageDTO'] = request.packageDTOShrink;
  }
  if (!Util.isUnset(request.pageDataShrink)) {
    body['PageData'] = request.pageDataShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListSubscriptionByPackage',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSubscriptionByPackage(request: ListSubscriptionByPackageRequest): ListSubscriptionByPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSubscriptionByPackageWithOptions(request, runtime);
}

model ListSubscriptionByRobotRequest {
  robotCode?: string(name='RobotCode'),
}

model ListSubscriptionByRobotResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      packageCode?: string(name='PackageCode'),
      packageVersion?: string(name='PackageVersion'),
      robotCode?: string(name='RobotCode'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListSubscriptionByRobotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSubscriptionByRobotResponseBody(name='body'),
}

async function listSubscriptionByRobotWithOptions(request: ListSubscriptionByRobotRequest, runtime: Util.RuntimeOptions): ListSubscriptionByRobotResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListSubscriptionByRobot',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSubscriptionByRobot(request: ListSubscriptionByRobotRequest): ListSubscriptionByRobotResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSubscriptionByRobotWithOptions(request, runtime);
}

model ListSyncMessagesRequest {
  messageDTOList?: [ 
    {
      chatId?: string(name='ChatId'),
      content?: string(name='Content'),
      contentType?: string(name='ContentType'),
      direction?: string(name='Direction'),
      messageId?: string(name='MessageId'),
      robotCode?: string(name='RobotCode'),
      sellerId?: string(name='SellerId'),
      sellerNick?: string(name='SellerNick'),
      sendTime?: long(name='SendTime'),
      sessionId?: string(name='SessionId'),
      source?: string(name='Source'),
      staffId?: string(name='StaffId'),
      staffNick?: string(name='StaffNick'),
      userId?: string(name='UserId'),
      userNick?: string(name='UserNick'),
    }
  ](name='MessageDTOList'),
}

model ListSyncMessagesShrinkRequest {
  messageDTOListShrink?: string(name='MessageDTOList'),
}

model ListSyncMessagesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListSyncMessagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSyncMessagesResponseBody(name='body'),
}

async function listSyncMessagesWithOptions(tmpReq: ListSyncMessagesRequest, runtime: Util.RuntimeOptions): ListSyncMessagesResponse {
  Util.validateModel(tmpReq);
  var request = new ListSyncMessagesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.messageDTOList)) {
    request.messageDTOListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.messageDTOList, 'MessageDTOList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.messageDTOListShrink)) {
    body['MessageDTOList'] = request.messageDTOListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListSyncMessages',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSyncMessages(request: ListSyncMessagesRequest): ListSyncMessagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSyncMessagesWithOptions(request, runtime);
}

model ListSyncRobotMessagesRequest {
  robotMessageDTOList?: [ 
    {
      answerId?: string(name='AnswerId'),
      answerType?: string(name='AnswerType'),
      chatId?: string(name='ChatId'),
      reason?: string(name='Reason'),
      robotCode?: string(name='RobotCode'),
      sceneKey?: string(name='SceneKey'),
      sessionId?: string(name='SessionId'),
      solutions?: [ string ](name='Solutions'),
      useDxm?: boolean(name='UseDxm'),
    }
  ](name='RobotMessageDTOList'),
}

model ListSyncRobotMessagesShrinkRequest {
  robotMessageDTOListShrink?: string(name='RobotMessageDTOList'),
}

model ListSyncRobotMessagesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListSyncRobotMessagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSyncRobotMessagesResponseBody(name='body'),
}

async function listSyncRobotMessagesWithOptions(tmpReq: ListSyncRobotMessagesRequest, runtime: Util.RuntimeOptions): ListSyncRobotMessagesResponse {
  Util.validateModel(tmpReq);
  var request = new ListSyncRobotMessagesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.robotMessageDTOList)) {
    request.robotMessageDTOListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.robotMessageDTOList, 'RobotMessageDTOList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.robotMessageDTOListShrink)) {
    body['RobotMessageDTOList'] = request.robotMessageDTOListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListSyncRobotMessages',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSyncRobotMessages(request: ListSyncRobotMessagesRequest): ListSyncRobotMessagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSyncRobotMessagesWithOptions(request, runtime);
}

model OlineIsvTestRequest {
  aliyunAccountDTO?: {
    aliUid?: long(name='AliUid'),
  }(name='AliyunAccountDTO'),
  versionId?: long(name='VersionId'),
}

model OlineIsvTestResponseBody = {
  requestId?: string(name='RequestId'),
}

model OlineIsvTestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OlineIsvTestResponseBody(name='body'),
}

async function olineIsvTestWithOptions(request: OlineIsvTestRequest, runtime: Util.RuntimeOptions): OlineIsvTestResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.aliyunAccountDTO)) {
    bodyFlat['AliyunAccountDTO'] = request.aliyunAccountDTO;
  }
  if (!Util.isUnset(request.versionId)) {
    body['VersionId'] = request.versionId;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'OlineIsvTest',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function olineIsvTest(request: OlineIsvTestRequest): OlineIsvTestResponse {
  var runtime = new Util.RuntimeOptions{};
  return olineIsvTestWithOptions(request, runtime);
}

model PayOrderCallbackRequest {
  data?: string(name='data'),
}

model PayOrderCallbackResponseBody = {
  code?: string(name='code'),
  data?: string(name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  synchro?: boolean(name='synchro'),
}

model PayOrderCallbackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PayOrderCallbackResponseBody(name='body'),
}

async function payOrderCallbackWithOptions(request: PayOrderCallbackRequest, runtime: Util.RuntimeOptions): PayOrderCallbackResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.data)) {
    query['data'] = request.data;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PayOrderCallback',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function payOrderCallback(request: PayOrderCallbackRequest): PayOrderCallbackResponse {
  var runtime = new Util.RuntimeOptions{};
  return payOrderCallbackWithOptions(request, runtime);
}

model ProcessMessageRequest {
  data?: string(name='data'),
}

model ProcessMessageResponseBody = {
  code?: string(name='code'),
  data?: string(name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ProcessMessageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ProcessMessageResponseBody(name='body'),
}

async function processMessageWithOptions(request: ProcessMessageRequest, runtime: Util.RuntimeOptions): ProcessMessageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.data)) {
    query['data'] = request.data;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ProcessMessage',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function processMessage(request: ProcessMessageRequest): ProcessMessageResponse {
  var runtime = new Util.RuntimeOptions{};
  return processMessageWithOptions(request, runtime);
}

model QueryByTaskIdRequest {
  robotCode?: string(name='RobotCode'),
  taskId?: long(name='TaskId'),
}

model QueryByTaskIdResponseBody = {
  code?: string(name='Code'),
  data?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    answerFilePath?: string(name='AnswerFilePath'),
    bucketName?: string(name='BucketName'),
    endpoint?: string(name='Endpoint'),
    expirationDate?: long(name='ExpirationDate'),
    queryFilePath?: string(name='QueryFilePath'),
    robotCode?: string(name='RobotCode'),
    securityToken?: string(name='SecurityToken'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryByTaskIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryByTaskIdResponseBody(name='body'),
}

async function queryByTaskIdWithOptions(request: QueryByTaskIdRequest, runtime: Util.RuntimeOptions): QueryByTaskIdResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryByTaskId',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryByTaskId(request: QueryByTaskIdRequest): QueryByTaskIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryByTaskIdWithOptions(request, runtime);
}

model QueryModuleSwitchStatusRequest {
  robotCode?: string(name='RobotCode'),
  switchType?: string(name='SwitchType'),
}

model QueryModuleSwitchStatusResponseBody = {
  code?: string(name='Code'),
  data?: int32(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryModuleSwitchStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryModuleSwitchStatusResponseBody(name='body'),
}

async function queryModuleSwitchStatusWithOptions(request: QueryModuleSwitchStatusRequest, runtime: Util.RuntimeOptions): QueryModuleSwitchStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.switchType)) {
    body['SwitchType'] = request.switchType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryModuleSwitchStatus',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryModuleSwitchStatus(request: QueryModuleSwitchStatusRequest): QueryModuleSwitchStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryModuleSwitchStatusWithOptions(request, runtime);
}

model QueryOutboundJobRequest {
  id?: long(name='Id'),
  saasId?: string(name='SaasId'),
  userProfile?: {
    appCode?: string(name='AppCode'),
    buId?: long(name='BuId'),
    platformCode?: string(name='PlatformCode'),
    tenantId?: long(name='TenantId'),
    userId?: long(name='UserId'),
    userNick?: string(name='UserNick'),
  }(name='UserProfile'),
}

model QueryOutboundJobShrinkRequest {
  id?: long(name='Id'),
  saasId?: string(name='SaasId'),
  userProfileShrink?: string(name='UserProfile'),
}

model QueryOutboundJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    appCode?: string(name='AppCode'),
    appId?: string(name='AppId'),
    config?: string(name='Config'),
    crowdConfig?: string(name='CrowdConfig'),
    crowdType?: int32(name='CrowdType'),
    endTime?: string(name='EndTime'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    jobName?: string(name='JobName'),
    runConfig?: string(name='RunConfig'),
    runType?: int32(name='RunType'),
    saasId?: string(name='SaasId'),
    shopId?: long(name='ShopId'),
    startTime?: string(name='StartTime'),
    status?: int32(name='Status'),
    tenantId?: long(name='TenantId'),
    version?: string(name='Version'),
  }(name='Data'),
  message?: string(name='Message'),
}

model QueryOutboundJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryOutboundJobResponseBody(name='body'),
}

async function queryOutboundJobWithOptions(tmpReq: QueryOutboundJobRequest, runtime: Util.RuntimeOptions): QueryOutboundJobResponse {
  Util.validateModel(tmpReq);
  var request = new QueryOutboundJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.userProfile)) {
    request.userProfileShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userProfile, 'UserProfile', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryOutboundJob',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryOutboundJob(request: QueryOutboundJobRequest): QueryOutboundJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOutboundJobWithOptions(request, runtime);
}

model QueryOutboundJobDataRequest {
  endTime?: string(name='EndTime'),
  jobId?: long(name='JobId'),
  saasId?: string(name='SaasId'),
  startTime?: string(name='StartTime'),
  userProfile?: {
    appCode?: string(name='AppCode'),
    buId?: long(name='BuId'),
    platformCode?: string(name='PlatformCode'),
    tenantId?: long(name='TenantId'),
    userId?: long(name='UserId'),
    userNick?: string(name='UserNick'),
  }(name='UserProfile'),
}

model QueryOutboundJobDataShrinkRequest {
  endTime?: string(name='EndTime'),
  jobId?: long(name='JobId'),
  saasId?: string(name='SaasId'),
  startTime?: string(name='StartTime'),
  userProfileShrink?: string(name='UserProfile'),
}

model QueryOutboundJobDataResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      appCode?: string(name='AppCode'),
      batchNo?: string(name='BatchNo'),
      callCount?: int32(name='CallCount'),
      config?: string(name='Config'),
      count?: int32(name='Count'),
      endTime?: string(name='EndTime'),
      executeTime?: string(name='ExecuteTime'),
      finishTime?: string(name='FinishTime'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: long(name='Id'),
      jobId?: long(name='JobId'),
      saasId?: string(name='SaasId'),
      startTime?: string(name='StartTime'),
      status?: int32(name='Status'),
      successCount?: int32(name='SuccessCount'),
      tenantId?: long(name='TenantId'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  success?: boolean(name='Success'),
}

model QueryOutboundJobDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryOutboundJobDataResponseBody(name='body'),
}

async function queryOutboundJobDataWithOptions(tmpReq: QueryOutboundJobDataRequest, runtime: Util.RuntimeOptions): QueryOutboundJobDataResponse {
  Util.validateModel(tmpReq);
  var request = new QueryOutboundJobDataShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.userProfile)) {
    request.userProfileShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userProfile, 'UserProfile', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryOutboundJobData',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryOutboundJobData(request: QueryOutboundJobDataRequest): QueryOutboundJobDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOutboundJobDataWithOptions(request, runtime);
}

model QueryOutboundJobDetailRecordRequest {
  jobTaskDetailPaginatedQuery?: {
    batchNo?: string(name='BatchNo'),
    currentPage?: int32(name='CurrentPage'),
    jobId?: long(name='JobId'),
    order?: string(name='Order'),
    pageSize?: int32(name='PageSize'),
    sortField?: string(name='SortField'),
    statusSet?: [ int32 ](name='StatusSet'),
  }(name='JobTaskDetailPaginatedQuery'),
  saasId?: string(name='SaasId'),
  userProfile?: {
    appCode?: string(name='AppCode'),
    buId?: long(name='BuId'),
    platformCode?: string(name='PlatformCode'),
    tenantId?: long(name='TenantId'),
    userId?: long(name='UserId'),
    userNick?: string(name='UserNick'),
  }(name='UserProfile'),
}

model QueryOutboundJobDetailRecordShrinkRequest {
  jobTaskDetailPaginatedQueryShrink?: string(name='JobTaskDetailPaginatedQuery'),
  saasId?: string(name='SaasId'),
  userProfileShrink?: string(name='UserProfile'),
}

model QueryOutboundJobDetailRecordResponseBody = {
  code?: string(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  data?: [ 
    {
      batchNo?: string(name='BatchNo'),
      bizId?: string(name='BizId'),
      bizOrderId?: long(name='BizOrderId'),
      bizType?: string(name='BizType'),
      buyerId?: long(name='BuyerId'),
      callTime?: string(name='CallTime'),
      dataType?: int32(name='DataType'),
      duration?: int32(name='Duration'),
      extraParams?: string(name='ExtraParams'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: long(name='Id'),
      jobId?: long(name='JobId'),
      mobileNo?: string(name='MobileNo'),
      playComplete?: int32(name='PlayComplete'),
      productName?: string(name='ProductName'),
      referenceId?: string(name='ReferenceId'),
      reserve1?: int32(name='Reserve1'),
      reserve2?: long(name='Reserve2'),
      reserve4?: string(name='Reserve4'),
      status?: int32(name='Status'),
      storeName?: string(name='StoreName'),
      subBizOrder?: long(name='SubBizOrder'),
      tenantId?: long(name='TenantId'),
      yunTaskId?: string(name='YunTaskId'),
    }
  ](name='Data'),
  extData?: map[string]string(name='ExtData'),
  message?: string(name='Message'),
  totalItems?: int32(name='TotalItems'),
}

model QueryOutboundJobDetailRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryOutboundJobDetailRecordResponseBody(name='body'),
}

async function queryOutboundJobDetailRecordWithOptions(tmpReq: QueryOutboundJobDetailRecordRequest, runtime: Util.RuntimeOptions): QueryOutboundJobDetailRecordResponse {
  Util.validateModel(tmpReq);
  var request = new QueryOutboundJobDetailRecordShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.jobTaskDetailPaginatedQuery)) {
    request.jobTaskDetailPaginatedQueryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.jobTaskDetailPaginatedQuery, 'JobTaskDetailPaginatedQuery', 'json');
  }
  if (!Util.isUnset(tmpReq.userProfile)) {
    request.userProfileShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userProfile, 'UserProfile', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryOutboundJobDetailRecord',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryOutboundJobDetailRecord(request: QueryOutboundJobDetailRecordRequest): QueryOutboundJobDetailRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOutboundJobDetailRecordWithOptions(request, runtime);
}

model QueryOutboundJobsRequest {
  appCode?: string(name='AppCode'),
  saasId?: string(name='SaasId'),
  shopId?: string(name='ShopId'),
  userProfile?: {
    appCode?: string(name='AppCode'),
    buId?: long(name='BuId'),
    platformCode?: string(name='PlatformCode'),
    tenantId?: long(name='TenantId'),
    userId?: long(name='UserId'),
    userNick?: string(name='UserNick'),
  }(name='UserProfile'),
  version?: string(name='Version'),
}

model QueryOutboundJobsShrinkRequest {
  appCode?: string(name='AppCode'),
  saasId?: string(name='SaasId'),
  shopId?: string(name='ShopId'),
  userProfileShrink?: string(name='UserProfile'),
  version?: string(name='Version'),
}

model QueryOutboundJobsResponseBody = {
  content?: {
    code?: string(name='Code'),
    data?: [ 
      {
        appCode?: string(name='AppCode'),
        appId?: string(name='AppId'),
        config?: string(name='Config'),
        crowdConfig?: string(name='CrowdConfig'),
        crowdType?: int32(name='CrowdType'),
        endTime?: string(name='EndTime'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        jobName?: string(name='JobName'),
        runConfig?: string(name='RunConfig'),
        runType?: int32(name='RunType'),
        saasId?: string(name='SaasId'),
        shopId?: long(name='ShopId'),
        startTime?: string(name='StartTime'),
        status?: int32(name='Status'),
        tenantId?: long(name='TenantId'),
        version?: string(name='Version'),
      }
    ](name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='Content'),
  first?: boolean(name='First'),
  last?: boolean(name='Last'),
}

model QueryOutboundJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryOutboundJobsResponseBody(name='body'),
}

async function queryOutboundJobsWithOptions(tmpReq: QueryOutboundJobsRequest, runtime: Util.RuntimeOptions): QueryOutboundJobsResponse {
  Util.validateModel(tmpReq);
  var request = new QueryOutboundJobsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.userProfile)) {
    request.userProfileShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userProfile, 'UserProfile', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.appCode)) {
    query['AppCode'] = request.appCode;
  }
  if (!Util.isUnset(request.saasId)) {
    query['SaasId'] = request.saasId;
  }
  if (!Util.isUnset(request.shopId)) {
    query['ShopId'] = request.shopId;
  }
  if (!Util.isUnset(request.userProfileShrink)) {
    query['UserProfile'] = request.userProfileShrink;
  }
  if (!Util.isUnset(request.version)) {
    query['Version'] = request.version;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryOutboundJobs',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryOutboundJobs(request: QueryOutboundJobsRequest): QueryOutboundJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOutboundJobsWithOptions(request, runtime);
}

model QuerySlotsRequest {
  categoryId?: int32(name='CategoryId'),
  currentPage?: int32(name='CurrentPage'),
  keyword?: string(name='Keyword'),
  pageSize?: int32(name='PageSize'),
  robotCode?: string(name='RobotCode'),
  source?: int32(name='Source'),
  type?: int32(name='Type'),
}

model QuerySlotsResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    resultData?: [ 
      {
        alias?: string(name='Alias'),
        categoryId?: int32(name='CategoryId'),
        categoryName?: string(name='CategoryName'),
        description?: string(name='Description'),
        id?: int32(name='Id'),
        ownStatus?: int32(name='OwnStatus'),
        source?: int32(name='Source'),
        sourceName?: string(name='SourceName'),
        type?: int32(name='Type'),
        typeName?: string(name='TypeName'),
      }
    ](name='ResultData'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySlotsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySlotsResponseBody(name='body'),
}

async function querySlotsWithOptions(request: QuerySlotsRequest, runtime: Util.RuntimeOptions): QuerySlotsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.categoryId)) {
    body['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.currentPage)) {
    body['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.keyword)) {
    body['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.source)) {
    body['Source'] = request.source;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySlots',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySlots(request: QuerySlotsRequest): QuerySlotsResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySlotsWithOptions(request, runtime);
}

model QueryTaskListRequest {
  digTaskPageQuery?: {
    endDate?: string(name='EndDate'),
    robotCode?: string(name='RobotCode'),
    startDate?: string(name='StartDate'),
    type?: string(name='Type'),
  }(name='DigTaskPageQuery'),
  pageData?: {
    maxResults?: long(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='PageData'),
}

model QueryTaskListShrinkRequest {
  digTaskPageQueryShrink?: string(name='DigTaskPageQuery'),
  pageDataShrink?: string(name='PageData'),
}

model QueryTaskListResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageData?: {
    data?: [ 
      {
        operateDate?: string(name='OperateDate'),
        paramConfig?: string(name='ParamConfig'),
        robotCode?: string(name='RobotCode'),
        status?: long(name='Status'),
        taskId?: long(name='TaskId'),
        type?: string(name='Type'),
      }
    ](name='Data'),
    maxResults?: long(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='PageData'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryTaskListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTaskListResponseBody(name='body'),
}

async function queryTaskListWithOptions(tmpReq: QueryTaskListRequest, runtime: Util.RuntimeOptions): QueryTaskListResponse {
  Util.validateModel(tmpReq);
  var request = new QueryTaskListShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.digTaskPageQuery)) {
    request.digTaskPageQueryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.digTaskPageQuery, 'DigTaskPageQuery', 'json');
  }
  if (!Util.isUnset(tmpReq.pageData)) {
    request.pageDataShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pageData, 'PageData', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.digTaskPageQueryShrink)) {
    body['DigTaskPageQuery'] = request.digTaskPageQueryShrink;
  }
  if (!Util.isUnset(request.pageDataShrink)) {
    body['PageData'] = request.pageDataShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryTaskList',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTaskList(request: QueryTaskListRequest): QueryTaskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTaskListWithOptions(request, runtime);
}

model RecognizeMessageRequest {
  chatId?: string(name='ChatId'),
  clientInfo?: {
    clientApp?: string(name='ClientApp'),
    clientOs?: string(name='ClientOs'),
    clientVersion?: string(name='ClientVersion'),
  }(name='ClientInfo'),
  content?: string(name='Content'),
  contentType?: string(name='ContentType'),
  expectedSlots?: [ 
    {
      slotKey?: string(name='SlotKey'),
    }
  ](name='ExpectedSlots'),
  extraContent?: map[string]any(name='ExtraContent'),
  focusItemId?: string(name='FocusItemId'),
  focusOrderId?: string(name='FocusOrderId'),
  items?: [ 
    {
      categoryId?: string(name='CategoryId'),
      itemId?: string(name='ItemId'),
      picUrl?: string(name='PicUrl'),
      price?: float(name='Price'),
      property?: map[string]string(name='Property'),
      sellerId?: string(name='SellerId'),
      shopCategoryIds?: [ string ](name='ShopCategoryIds'),
      title?: string(name='Title'),
    }
  ](name='Items'),
  orders?: [ 
    {
      buyerId?: string(name='BuyerId'),
      buyerRateStatus?: string(name='BuyerRateStatus'),
      count?: int32(name='Count'),
      createTime?: long(name='CreateTime'),
      itemId?: string(name='ItemId'),
      itemPic?: string(name='ItemPic'),
      itemTitle?: string(name='ItemTitle'),
      logisticsStatus?: string(name='LogisticsStatus'),
      orderId?: string(name='OrderId'),
      parentOrderId?: string(name='ParentOrderId'),
      payStatus?: string(name='PayStatus'),
      payTime?: long(name='PayTime'),
      price?: float(name='Price'),
      refundStatus?: string(name='RefundStatus'),
      sellerId?: string(name='SellerId'),
      skuProperty?: string(name='SkuProperty'),
    }
  ](name='Orders'),
  packages?: [ 
    {
      packageCode?: string(name='PackageCode'),
      packageVersion?: string(name='PackageVersion'),
    }
  ](name='Packages'),
  platformCode?: string(name='PlatformCode'),
  robotCode?: string(name='RobotCode'),
  round?: int32(name='Round'),
  sellerId?: string(name='SellerId'),
  sellerNick?: string(name='SellerNick'),
  serviceMode?: string(name='ServiceMode'),
  sessionId?: string(name='SessionId'),
  staffId?: string(name='StaffId'),
  staffNick?: string(name='StaffNick'),
  stressTesting?: boolean(name='StressTesting'),
  userId?: string(name='UserId'),
  userNick?: string(name='UserNick'),
  variables?: map[string]any(name='Variables'),
}

model RecognizeMessageShrinkRequest {
  chatId?: string(name='ChatId'),
  clientInfoShrink?: string(name='ClientInfo'),
  content?: string(name='Content'),
  contentType?: string(name='ContentType'),
  expectedSlotsShrink?: string(name='ExpectedSlots'),
  extraContentShrink?: string(name='ExtraContent'),
  focusItemId?: string(name='FocusItemId'),
  focusOrderId?: string(name='FocusOrderId'),
  itemsShrink?: string(name='Items'),
  ordersShrink?: string(name='Orders'),
  packagesShrink?: string(name='Packages'),
  platformCode?: string(name='PlatformCode'),
  robotCode?: string(name='RobotCode'),
  round?: int32(name='Round'),
  sellerId?: string(name='SellerId'),
  sellerNick?: string(name='SellerNick'),
  serviceMode?: string(name='ServiceMode'),
  sessionId?: string(name='SessionId'),
  staffId?: string(name='StaffId'),
  staffNick?: string(name='StaffNick'),
  stressTesting?: boolean(name='StressTesting'),
  userId?: string(name='UserId'),
  userNick?: string(name='UserNick'),
  variablesShrink?: string(name='Variables'),
}

model RecognizeMessageResponseBody = {
  code?: string(name='Code'),
  data?: {
    knowledges?: [ 
      {
        knowledgeId?: long(name='KnowledgeId'),
        knowledgeTitle?: string(name='KnowledgeTitle'),
        sceneKey?: string(name='SceneKey'),
        solutions?: [ 
          {
            conditions?: [ 
              {
                conditionType?: string(name='ConditionType'),
                conditionValue?: string(name='ConditionValue'),
              }
            ](name='Conditions'),
            extraContent?: string(name='ExtraContent'),
            knowledgeId?: long(name='KnowledgeId'),
            solutionContent?: string(name='SolutionContent'),
            solutionId?: long(name='SolutionId'),
            solutionSource?: string(name='SolutionSource'),
            solutionType?: string(name='SolutionType'),
            solutionVariables?: [ 
              {
                variableName?: string(name='VariableName'),
                variableType?: string(name='VariableType'),
              }
            ](name='SolutionVariables'),
          }
        ](name='Solutions'),
      }
    ](name='Knowledges'),
    outputMessages?: [ 
      {
        outputContent?: map[string]any(name='OutputContent'),
        outputContentType?: string(name='OutputContentType'),
      }
    ](name='OutputMessages'),
    scene?: {
      emotionTag?: string(name='EmotionTag'),
      itemId?: string(name='ItemId'),
      orderId?: string(name='OrderId'),
      sceneDTOs?: [ 
        {
          sceneKey?: string(name='SceneKey'),
          sceneSource?: string(name='SceneSource'),
        }
      ](name='SceneDTOs'),
      semanticComplete?: string(name='SemanticComplete'),
    }(name='Scene'),
    unitSlots?: {
      unitSpans?: [ 
        {
          alias?: string(name='Alias'),
          end?: int32(name='End'),
          numericSlotValue?: {
            num?: double(name='Num'),
            unit?: {
              unitKey?: string(name='UnitKey'),
              unitName?: string(name='UnitName'),
            }(name='Unit'),
          }(name='NumericSlotValue'),
          score?: double(name='Score'),
          slotKey?: string(name='SlotKey'),
          slotValue?: string(name='SlotValue'),
          source?: string(name='Source'),
          start?: int32(name='Start'),
        }
      ](name='UnitSpans'),
    }(name='UnitSlots'),
    extOutput?: map[string]any(name='extOutput'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RecognizeMessageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecognizeMessageResponseBody(name='body'),
}

async function recognizeMessageWithOptions(tmpReq: RecognizeMessageRequest, runtime: Util.RuntimeOptions): RecognizeMessageResponse {
  Util.validateModel(tmpReq);
  var request = new RecognizeMessageShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.clientInfo)) {
    request.clientInfoShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.clientInfo, 'ClientInfo', 'json');
  }
  if (!Util.isUnset(tmpReq.expectedSlots)) {
    request.expectedSlotsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.expectedSlots, 'ExpectedSlots', 'json');
  }
  if (!Util.isUnset(tmpReq.extraContent)) {
    request.extraContentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extraContent, 'ExtraContent', 'json');
  }
  if (!Util.isUnset(tmpReq.items)) {
    request.itemsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.items, 'Items', 'json');
  }
  if (!Util.isUnset(tmpReq.orders)) {
    request.ordersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.orders, 'Orders', 'json');
  }
  if (!Util.isUnset(tmpReq.packages)) {
    request.packagesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.packages, 'Packages', 'json');
  }
  if (!Util.isUnset(tmpReq.variables)) {
    request.variablesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.variables, 'Variables', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.chatId)) {
    body['ChatId'] = request.chatId;
  }
  if (!Util.isUnset(request.clientInfoShrink)) {
    body['ClientInfo'] = request.clientInfoShrink;
  }
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.contentType)) {
    body['ContentType'] = request.contentType;
  }
  if (!Util.isUnset(request.expectedSlotsShrink)) {
    body['ExpectedSlots'] = request.expectedSlotsShrink;
  }
  if (!Util.isUnset(request.extraContentShrink)) {
    body['ExtraContent'] = request.extraContentShrink;
  }
  if (!Util.isUnset(request.focusItemId)) {
    body['FocusItemId'] = request.focusItemId;
  }
  if (!Util.isUnset(request.focusOrderId)) {
    body['FocusOrderId'] = request.focusOrderId;
  }
  if (!Util.isUnset(request.itemsShrink)) {
    body['Items'] = request.itemsShrink;
  }
  if (!Util.isUnset(request.ordersShrink)) {
    body['Orders'] = request.ordersShrink;
  }
  if (!Util.isUnset(request.packagesShrink)) {
    body['Packages'] = request.packagesShrink;
  }
  if (!Util.isUnset(request.platformCode)) {
    body['PlatformCode'] = request.platformCode;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.round)) {
    body['Round'] = request.round;
  }
  if (!Util.isUnset(request.sellerId)) {
    body['SellerId'] = request.sellerId;
  }
  if (!Util.isUnset(request.sellerNick)) {
    body['SellerNick'] = request.sellerNick;
  }
  if (!Util.isUnset(request.serviceMode)) {
    body['ServiceMode'] = request.serviceMode;
  }
  if (!Util.isUnset(request.sessionId)) {
    body['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.staffId)) {
    body['StaffId'] = request.staffId;
  }
  if (!Util.isUnset(request.staffNick)) {
    body['StaffNick'] = request.staffNick;
  }
  if (!Util.isUnset(request.stressTesting)) {
    body['StressTesting'] = request.stressTesting;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userNick)) {
    body['UserNick'] = request.userNick;
  }
  if (!Util.isUnset(request.variablesShrink)) {
    body['Variables'] = request.variablesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RecognizeMessage',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recognizeMessage(request: RecognizeMessageRequest): RecognizeMessageResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeMessageWithOptions(request, runtime);
}

model RecognizeMessageForTestRequest {
  chatId?: string(name='ChatId'),
  clientInfo?: {
    clientApp?: string(name='ClientApp'),
    clientOs?: string(name='ClientOs'),
    clientVersion?: string(name='ClientVersion'),
  }(name='ClientInfo'),
  content?: string(name='Content'),
  contentType?: string(name='ContentType'),
  expectedSlots?: [ 
    {
      slotKey?: string(name='SlotKey'),
    }
  ](name='ExpectedSlots'),
  extraContent?: map[string]any(name='ExtraContent'),
  focusItemId?: string(name='FocusItemId'),
  focusOrderId?: string(name='FocusOrderId'),
  ignoreSceneSwitch?: boolean(name='IgnoreSceneSwitch'),
  items?: [ 
    {
      categoryId?: string(name='CategoryId'),
      itemId?: string(name='ItemId'),
      picUrl?: string(name='PicUrl'),
      price?: float(name='Price'),
      property?: map[string]string(name='Property'),
      sellerId?: string(name='SellerId'),
      shopCategoryIds?: [ string ](name='ShopCategoryIds'),
      title?: string(name='Title'),
    }
  ](name='Items'),
  orders?: [ 
    {
      buyerId?: string(name='BuyerId'),
      buyerRateStatus?: string(name='BuyerRateStatus'),
      count?: int32(name='Count'),
      createTime?: long(name='CreateTime'),
      itemId?: string(name='ItemId'),
      itemPic?: string(name='ItemPic'),
      itemTitle?: string(name='ItemTitle'),
      logisticsStatus?: string(name='LogisticsStatus'),
      orderId?: string(name='OrderId'),
      parentOrderId?: string(name='ParentOrderId'),
      payStatus?: string(name='PayStatus'),
      payTime?: long(name='PayTime'),
      price?: float(name='Price'),
      refundStatus?: string(name='RefundStatus'),
      sellerId?: string(name='SellerId'),
      skuProperty?: string(name='SkuProperty'),
    }
  ](name='Orders'),
  robotCode?: string(name='RobotCode'),
  round?: int32(name='Round'),
  sellerId?: string(name='SellerId'),
  sellerNick?: string(name='SellerNick'),
  serviceMode?: string(name='ServiceMode'),
  sessionId?: string(name='SessionId'),
  staffId?: string(name='StaffId'),
  staffNick?: string(name='StaffNick'),
  userId?: string(name='UserId'),
  userNick?: string(name='UserNick'),
}

model RecognizeMessageForTestShrinkRequest {
  chatId?: string(name='ChatId'),
  clientInfoShrink?: string(name='ClientInfo'),
  content?: string(name='Content'),
  contentType?: string(name='ContentType'),
  expectedSlotsShrink?: string(name='ExpectedSlots'),
  extraContentShrink?: string(name='ExtraContent'),
  focusItemId?: string(name='FocusItemId'),
  focusOrderId?: string(name='FocusOrderId'),
  ignoreSceneSwitch?: boolean(name='IgnoreSceneSwitch'),
  itemsShrink?: string(name='Items'),
  ordersShrink?: string(name='Orders'),
  robotCode?: string(name='RobotCode'),
  round?: int32(name='Round'),
  sellerId?: string(name='SellerId'),
  sellerNick?: string(name='SellerNick'),
  serviceMode?: string(name='ServiceMode'),
  sessionId?: string(name='SessionId'),
  staffId?: string(name='StaffId'),
  staffNick?: string(name='StaffNick'),
  userId?: string(name='UserId'),
  userNick?: string(name='UserNick'),
}

model RecognizeMessageForTestResponseBody = {
  code?: string(name='Code'),
  data?: {
    knowledges?: [ 
      {
        knowledgeId?: long(name='KnowledgeId'),
        knowledgeTitle?: string(name='KnowledgeTitle'),
        sceneKey?: string(name='SceneKey'),
        solutions?: [ 
          {
            conditions?: [ 
              {
                conditionType?: string(name='ConditionType'),
                conditionValue?: string(name='ConditionValue'),
              }
            ](name='Conditions'),
            extraContent?: string(name='ExtraContent'),
            knowledgeId?: long(name='KnowledgeId'),
            solutionContent?: string(name='SolutionContent'),
            solutionId?: long(name='SolutionId'),
            solutionSource?: string(name='SolutionSource'),
            solutionType?: string(name='SolutionType'),
            solutionVariables?: [ 
              {
                variableName?: string(name='VariableName'),
                variableType?: string(name='VariableType'),
              }
            ](name='SolutionVariables'),
          }
        ](name='Solutions'),
      }
    ](name='Knowledges'),
    outputMessages?: [ 
      {
        outputContent?: map[string]any(name='OutputContent'),
        outputContentType?: string(name='OutputContentType'),
      }
    ](name='OutputMessages'),
    scene?: {
      emotionTag?: string(name='EmotionTag'),
      itemId?: string(name='ItemId'),
      orderId?: string(name='OrderId'),
      sceneDTOs?: [ 
        {
          sceneKey?: string(name='SceneKey'),
          sceneSource?: string(name='SceneSource'),
        }
      ](name='SceneDTOs'),
      semanticComplete?: string(name='SemanticComplete'),
    }(name='Scene'),
    unitSlots?: {
      unitSpans?: [ 
        {
          alias?: string(name='Alias'),
          end?: int32(name='End'),
          numericSlotValue?: {
            num?: double(name='Num'),
            unit?: {
              unitKey?: string(name='UnitKey'),
              unitName?: string(name='UnitName'),
            }(name='Unit'),
          }(name='NumericSlotValue'),
          score?: double(name='Score'),
          slotKey?: string(name='SlotKey'),
          slotValue?: string(name='SlotValue'),
          source?: string(name='Source'),
          start?: int32(name='Start'),
        }
      ](name='UnitSpans'),
    }(name='UnitSlots'),
    extOutput?: map[string]any(name='extOutput'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RecognizeMessageForTestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecognizeMessageForTestResponseBody(name='body'),
}

async function recognizeMessageForTestWithOptions(tmpReq: RecognizeMessageForTestRequest, runtime: Util.RuntimeOptions): RecognizeMessageForTestResponse {
  Util.validateModel(tmpReq);
  var request = new RecognizeMessageForTestShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.clientInfo)) {
    request.clientInfoShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.clientInfo, 'ClientInfo', 'json');
  }
  if (!Util.isUnset(tmpReq.expectedSlots)) {
    request.expectedSlotsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.expectedSlots, 'ExpectedSlots', 'json');
  }
  if (!Util.isUnset(tmpReq.extraContent)) {
    request.extraContentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extraContent, 'ExtraContent', 'json');
  }
  if (!Util.isUnset(tmpReq.items)) {
    request.itemsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.items, 'Items', 'json');
  }
  if (!Util.isUnset(tmpReq.orders)) {
    request.ordersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.orders, 'Orders', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.chatId)) {
    body['ChatId'] = request.chatId;
  }
  if (!Util.isUnset(request.clientInfoShrink)) {
    body['ClientInfo'] = request.clientInfoShrink;
  }
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.contentType)) {
    body['ContentType'] = request.contentType;
  }
  if (!Util.isUnset(request.expectedSlotsShrink)) {
    body['ExpectedSlots'] = request.expectedSlotsShrink;
  }
  if (!Util.isUnset(request.extraContentShrink)) {
    body['ExtraContent'] = request.extraContentShrink;
  }
  if (!Util.isUnset(request.focusItemId)) {
    body['FocusItemId'] = request.focusItemId;
  }
  if (!Util.isUnset(request.focusOrderId)) {
    body['FocusOrderId'] = request.focusOrderId;
  }
  if (!Util.isUnset(request.ignoreSceneSwitch)) {
    body['IgnoreSceneSwitch'] = request.ignoreSceneSwitch;
  }
  if (!Util.isUnset(request.itemsShrink)) {
    body['Items'] = request.itemsShrink;
  }
  if (!Util.isUnset(request.ordersShrink)) {
    body['Orders'] = request.ordersShrink;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.round)) {
    body['Round'] = request.round;
  }
  if (!Util.isUnset(request.sellerId)) {
    body['SellerId'] = request.sellerId;
  }
  if (!Util.isUnset(request.sellerNick)) {
    body['SellerNick'] = request.sellerNick;
  }
  if (!Util.isUnset(request.serviceMode)) {
    body['ServiceMode'] = request.serviceMode;
  }
  if (!Util.isUnset(request.sessionId)) {
    body['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.staffId)) {
    body['StaffId'] = request.staffId;
  }
  if (!Util.isUnset(request.staffNick)) {
    body['StaffNick'] = request.staffNick;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userNick)) {
    body['UserNick'] = request.userNick;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RecognizeMessageForTest',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recognizeMessageForTest(request: RecognizeMessageForTestRequest): RecognizeMessageForTestResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeMessageForTestWithOptions(request, runtime);
}

model RefundRequest {
  data?: string(name='data'),
}

model RefundResponseBody = {
  code?: string(name='code'),
  data?: string(name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model RefundResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefundResponseBody(name='body'),
}

async function refundWithOptions(request: RefundRequest, runtime: Util.RuntimeOptions): RefundResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.data)) {
    query['data'] = request.data;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Refund',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refund(request: RefundRequest): RefundResponse {
  var runtime = new Util.RuntimeOptions{};
  return refundWithOptions(request, runtime);
}

model ReleaseServiceTestRequest {
  aliyunAccountDTO?: {
    aliUid?: long(name='AliUid'),
  }(name='AliyunAccountDTO'),
}

model ReleaseServiceTestResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseServiceTestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleaseServiceTestResponseBody(name='body'),
}

async function releaseServiceTestWithOptions(request: ReleaseServiceTestRequest, runtime: Util.RuntimeOptions): ReleaseServiceTestResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.aliyunAccountDTO)) {
    bodyFlat['AliyunAccountDTO'] = request.aliyunAccountDTO;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseServiceTest',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseServiceTest(request: ReleaseServiceTestRequest): ReleaseServiceTestResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseServiceTestWithOptions(request, runtime);
}

model SaveModuleSwitchRequest {
  robotCode?: string(name='RobotCode'),
  status?: int32(name='Status'),
  switchType?: string(name='SwitchType'),
}

model SaveModuleSwitchResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveModuleSwitchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveModuleSwitchResponseBody(name='body'),
}

async function saveModuleSwitchWithOptions(request: SaveModuleSwitchRequest, runtime: Util.RuntimeOptions): SaveModuleSwitchResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  if (!Util.isUnset(request.switchType)) {
    body['SwitchType'] = request.switchType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SaveModuleSwitch',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveModuleSwitch(request: SaveModuleSwitchRequest): SaveModuleSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveModuleSwitchWithOptions(request, runtime);
}

model SyncMessageRequest {
  chatId?: string(name='ChatId'),
  content?: string(name='Content'),
  contentType?: string(name='ContentType'),
  direction?: string(name='Direction'),
  messageId?: string(name='MessageId'),
  robotCode?: string(name='RobotCode'),
  sellerId?: string(name='SellerId'),
  sellerNick?: string(name='SellerNick'),
  sendTime?: long(name='SendTime'),
  sessionId?: string(name='SessionId'),
  source?: string(name='Source'),
  staffId?: string(name='StaffId'),
  staffNick?: string(name='StaffNick'),
  userId?: string(name='UserId'),
  userNick?: string(name='UserNick'),
}

model SyncMessageResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SyncMessageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SyncMessageResponseBody(name='body'),
}

async function syncMessageWithOptions(request: SyncMessageRequest, runtime: Util.RuntimeOptions): SyncMessageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chatId)) {
    body['ChatId'] = request.chatId;
  }
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.contentType)) {
    body['ContentType'] = request.contentType;
  }
  if (!Util.isUnset(request.direction)) {
    body['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.messageId)) {
    body['MessageId'] = request.messageId;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.sellerId)) {
    body['SellerId'] = request.sellerId;
  }
  if (!Util.isUnset(request.sellerNick)) {
    body['SellerNick'] = request.sellerNick;
  }
  if (!Util.isUnset(request.sendTime)) {
    body['SendTime'] = request.sendTime;
  }
  if (!Util.isUnset(request.sessionId)) {
    body['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.source)) {
    body['Source'] = request.source;
  }
  if (!Util.isUnset(request.staffId)) {
    body['StaffId'] = request.staffId;
  }
  if (!Util.isUnset(request.staffNick)) {
    body['StaffNick'] = request.staffNick;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userNick)) {
    body['UserNick'] = request.userNick;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SyncMessage',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function syncMessage(request: SyncMessageRequest): SyncMessageResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncMessageWithOptions(request, runtime);
}

model SyncRobotMessageRequest {
  answer?: string(name='Answer'),
  answerId?: string(name='AnswerId'),
  answerType?: string(name='AnswerType'),
  chatId?: string(name='ChatId'),
  reason?: string(name='Reason'),
  robotCode?: string(name='RobotCode'),
  sceneKey?: string(name='SceneKey'),
  sessionId?: string(name='SessionId'),
  solutions?: [ string ](name='Solutions'),
  useDxm?: string(name='UseDxm'),
}

model SyncRobotMessageShrinkRequest {
  answer?: string(name='Answer'),
  answerId?: string(name='AnswerId'),
  answerType?: string(name='AnswerType'),
  chatId?: string(name='ChatId'),
  reason?: string(name='Reason'),
  robotCode?: string(name='RobotCode'),
  sceneKey?: string(name='SceneKey'),
  sessionId?: string(name='SessionId'),
  solutionsShrink?: string(name='Solutions'),
  useDxm?: string(name='UseDxm'),
}

model SyncRobotMessageResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SyncRobotMessageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SyncRobotMessageResponseBody(name='body'),
}

async function syncRobotMessageWithOptions(tmpReq: SyncRobotMessageRequest, runtime: Util.RuntimeOptions): SyncRobotMessageResponse {
  Util.validateModel(tmpReq);
  var request = new SyncRobotMessageShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.solutions)) {
    request.solutionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.solutions, 'Solutions', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.answer)) {
    body['Answer'] = request.answer;
  }
  if (!Util.isUnset(request.answerId)) {
    body['AnswerId'] = request.answerId;
  }
  if (!Util.isUnset(request.answerType)) {
    body['AnswerType'] = request.answerType;
  }
  if (!Util.isUnset(request.chatId)) {
    body['ChatId'] = request.chatId;
  }
  if (!Util.isUnset(request.reason)) {
    body['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.sceneKey)) {
    body['SceneKey'] = request.sceneKey;
  }
  if (!Util.isUnset(request.sessionId)) {
    body['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.solutionsShrink)) {
    body['Solutions'] = request.solutionsShrink;
  }
  if (!Util.isUnset(request.useDxm)) {
    body['UseDxm'] = request.useDxm;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SyncRobotMessage',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function syncRobotMessage(request: SyncRobotMessageRequest): SyncRobotMessageResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncRobotMessageWithOptions(request, runtime);
}

model UninstallPackageRequest {
  operator?: {
    operatorId?: string(name='OperatorId'),
    operatorName?: string(name='OperatorName'),
  }(name='Operator'),
  packages?: [ 
    {
      packageCode?: string(name='PackageCode'),
      packageVersion?: string(name='PackageVersion'),
    }
  ](name='Packages'),
  robotCode?: string(name='RobotCode'),
}

model UninstallPackageShrinkRequest {
  operatorShrink?: string(name='Operator'),
  packagesShrink?: string(name='Packages'),
  robotCode?: string(name='RobotCode'),
}

model UninstallPackageResponseBody = {
  code?: string(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UninstallPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallPackageResponseBody(name='body'),
}

async function uninstallPackageWithOptions(tmpReq: UninstallPackageRequest, runtime: Util.RuntimeOptions): UninstallPackageResponse {
  Util.validateModel(tmpReq);
  var request = new UninstallPackageShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.operator)) {
    request.operatorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.operator, 'Operator', 'json');
  }
  if (!Util.isUnset(tmpReq.packages)) {
    request.packagesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.packages, 'Packages', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.operatorShrink)) {
    body['Operator'] = request.operatorShrink;
  }
  if (!Util.isUnset(request.packagesShrink)) {
    body['Packages'] = request.packagesShrink;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UninstallPackage',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uninstallPackage(request: UninstallPackageRequest): UninstallPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallPackageWithOptions(request, runtime);
}

model UpdateAgingRequest {
  endTime?: long(name='EndTime'),
  id?: long(name='Id'),
  instanceType?: string(name='InstanceType'),
  name?: string(name='Name'),
  robotCode?: string(name='RobotCode'),
  startTime?: long(name='StartTime'),
  timeDay?: string(name='TimeDay'),
  type?: string(name='Type'),
}

model UpdateAgingResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateAgingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAgingResponseBody(name='body'),
}

async function updateAgingWithOptions(request: UpdateAgingRequest, runtime: Util.RuntimeOptions): UpdateAgingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.timeDay)) {
    body['TimeDay'] = request.timeDay;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAging',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAging(request: UpdateAgingRequest): UpdateAgingResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAgingWithOptions(request, runtime);
}

model UpdateBlackEntryRequest {
  blackEntryId?: int32(name='BlackEntryId'),
  blackEntryValue?: string(name='BlackEntryValue'),
  robotCode?: string(name='RobotCode'),
  slotId?: int32(name='SlotId'),
}

model UpdateBlackEntryResponseBody = {
  code?: string(name='Code'),
  data?: int32(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateBlackEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateBlackEntryResponseBody(name='body'),
}

async function updateBlackEntryWithOptions(request: UpdateBlackEntryRequest, runtime: Util.RuntimeOptions): UpdateBlackEntryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.blackEntryId)) {
    body['BlackEntryId'] = request.blackEntryId;
  }
  if (!Util.isUnset(request.blackEntryValue)) {
    body['BlackEntryValue'] = request.blackEntryValue;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.slotId)) {
    body['SlotId'] = request.slotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBlackEntry',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateBlackEntry(request: UpdateBlackEntryRequest): UpdateBlackEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBlackEntryWithOptions(request, runtime);
}

model UpdateCoreEntryRequest {
  robotCode?: string(name='RobotCode'),
  similarEntry?: {
    coreEntryId?: int32(name='CoreEntryId'),
    coreValue?: string(name='CoreValue'),
    similarValues?: [ string ](name='SimilarValues'),
  }(name='SimilarEntry'),
  slotId?: int32(name='SlotId'),
}

model UpdateCoreEntryShrinkRequest {
  robotCode?: string(name='RobotCode'),
  similarEntryShrink?: string(name='SimilarEntry'),
  slotId?: int32(name='SlotId'),
}

model UpdateCoreEntryResponseBody = {
  code?: string(name='Code'),
  data?: int32(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateCoreEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCoreEntryResponseBody(name='body'),
}

async function updateCoreEntryWithOptions(tmpReq: UpdateCoreEntryRequest, runtime: Util.RuntimeOptions): UpdateCoreEntryResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateCoreEntryShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.similarEntry)) {
    request.similarEntryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.similarEntry, 'SimilarEntry', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.similarEntryShrink)) {
    body['SimilarEntry'] = request.similarEntryShrink;
  }
  if (!Util.isUnset(request.slotId)) {
    body['SlotId'] = request.slotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCoreEntry',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCoreEntry(request: UpdateCoreEntryRequest): UpdateCoreEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCoreEntryWithOptions(request, runtime);
}

model UpdateJobRequest {
  activeJobDTO?: {
    appCode?: string(name='AppCode'),
    config?: string(name='Config'),
    endTime?: long(name='EndTime'),
    instanceId?: string(name='InstanceId'),
    jobId?: long(name='JobId'),
    jobName?: string(name='JobName'),
    shopId?: string(name='ShopId'),
    startTime?: long(name='StartTime'),
    status?: int32(name='Status'),
  }(name='ActiveJobDTO'),
  userProfile?: {
    tenantId?: long(name='TenantId'),
  }(name='UserProfile'),
}

model UpdateJobShrinkRequest {
  activeJobDTO?: {
    appCode?: string(name='AppCode'),
    config?: string(name='Config'),
    endTime?: long(name='EndTime'),
    instanceId?: string(name='InstanceId'),
    jobId?: long(name='JobId'),
    jobName?: string(name='JobName'),
    shopId?: string(name='ShopId'),
    startTime?: long(name='StartTime'),
    status?: int32(name='Status'),
  }(name='ActiveJobDTO'),
  userProfileShrink?: string(name='UserProfile'),
}

model UpdateJobResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateJobResponseBody(name='body'),
}

async function updateJobWithOptions(tmpReq: UpdateJobRequest, runtime: Util.RuntimeOptions): UpdateJobResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.userProfile)) {
    request.userProfileShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userProfile, 'UserProfile', 'json');
  }
  var body : map[string]any = {};
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.activeJobDTO)) {
    bodyFlat['ActiveJobDTO'] = request.activeJobDTO;
  }
  if (!Util.isUnset(request.userProfileShrink)) {
    body['UserProfile'] = request.userProfileShrink;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateJob',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateJob(request: UpdateJobRequest): UpdateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateJobWithOptions(request, runtime);
}

model UpdateKnowledgeRequest {
  knowledge?: {
    knowledgeId?: long(name='KnowledgeId'),
    similarQuestions?: [ 
      {
        action?: string(name='Action'),
        similarQuestionEffectType?: string(name='SimilarQuestionEffectType'),
        similarQuestionId?: long(name='SimilarQuestionId'),
        similarQuestionTitle?: string(name='SimilarQuestionTitle'),
      }
    ](name='SimilarQuestions'),
  }(name='Knowledge'),
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  robotCode?: string(name='RobotCode'),
}

model UpdateKnowledgeResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateKnowledgeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateKnowledgeResponseBody(name='body'),
}

async function updateKnowledgeWithOptions(request: UpdateKnowledgeRequest, runtime: Util.RuntimeOptions): UpdateKnowledgeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.knowledge)) {
    bodyFlat['Knowledge'] = request.knowledge;
  }
  if (!Util.isUnset(request.operatorId)) {
    body['OperatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorName)) {
    body['OperatorName'] = request.operatorName;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateKnowledge',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateKnowledge(request: UpdateKnowledgeRequest): UpdateKnowledgeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateKnowledgeWithOptions(request, runtime);
}

model UpdateRobotRequest {
  operator?: {
    operatorId?: string(name='OperatorId'),
    operatorName?: string(name='OperatorName'),
  }(name='Operator'),
  robotDTO?: {
    expireDate?: long(name='ExpireDate'),
    instanceId?: string(name='InstanceId'),
    robotCode?: string(name='RobotCode'),
    sellerId?: string(name='SellerId'),
    sellerNick?: string(name='SellerNick'),
    shopId?: string(name='ShopId'),
    signDate?: long(name='SignDate'),
  }(name='RobotDTO'),
}

model UpdateRobotShrinkRequest {
  operatorShrink?: string(name='Operator'),
  robotDTOShrink?: string(name='RobotDTO'),
}

model UpdateRobotResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateRobotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRobotResponseBody(name='body'),
}

async function updateRobotWithOptions(tmpReq: UpdateRobotRequest, runtime: Util.RuntimeOptions): UpdateRobotResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateRobotShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.operator)) {
    request.operatorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.operator, 'Operator', 'json');
  }
  if (!Util.isUnset(tmpReq.robotDTO)) {
    request.robotDTOShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.robotDTO, 'RobotDTO', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.operatorShrink)) {
    body['Operator'] = request.operatorShrink;
  }
  if (!Util.isUnset(request.robotDTOShrink)) {
    body['RobotDTO'] = request.robotDTOShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRobot',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRobot(request: UpdateRobotRequest): UpdateRobotResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRobotWithOptions(request, runtime);
}

model UpdateSlotOwnerStatusRequest {
  ownStatus?: int32(name='OwnStatus'),
  robotCode?: string(name='RobotCode'),
  slotId?: int32(name='SlotId'),
}

model UpdateSlotOwnerStatusResponseBody = {
  code?: string(name='Code'),
  data?: int32(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSlotOwnerStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSlotOwnerStatusResponseBody(name='body'),
}

async function updateSlotOwnerStatusWithOptions(request: UpdateSlotOwnerStatusRequest, runtime: Util.RuntimeOptions): UpdateSlotOwnerStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ownStatus)) {
    body['OwnStatus'] = request.ownStatus;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.slotId)) {
    body['SlotId'] = request.slotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSlotOwnerStatus',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSlotOwnerStatus(request: UpdateSlotOwnerStatusRequest): UpdateSlotOwnerStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSlotOwnerStatusWithOptions(request, runtime);
}

model UpdateSolutionRequest {
  knowledgeId?: long(name='KnowledgeId'),
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  robotCode?: string(name='RobotCode'),
  solution?: {
    conditions?: [ 
      {
        conditionType?: string(name='ConditionType'),
        conditionValue?: string(name='ConditionValue'),
        knowledgeId?: long(name='KnowledgeId'),
        solutionId?: long(name='SolutionId'),
      }
    ](name='Conditions'),
    extraContent?: string(name='ExtraContent'),
    knowledgeId?: long(name='KnowledgeId'),
    solutionContent?: string(name='SolutionContent'),
    solutionId?: long(name='SolutionId'),
    solutionSource?: string(name='SolutionSource'),
    solutionType?: string(name='SolutionType'),
    solutionVariables?: [ 
      {
        knowledgeId?: long(name='KnowledgeId'),
        solutionId?: long(name='SolutionId'),
        variableName?: string(name='VariableName'),
        variableType?: string(name='VariableType'),
      }
    ](name='SolutionVariables'),
  }(name='Solution'),
}

model UpdateSolutionShrinkRequest {
  knowledgeId?: long(name='KnowledgeId'),
  operatorId?: string(name='OperatorId'),
  operatorName?: string(name='OperatorName'),
  robotCode?: string(name='RobotCode'),
  solutionShrink?: string(name='Solution'),
}

model UpdateSolutionResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSolutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSolutionResponseBody(name='body'),
}

async function updateSolutionWithOptions(tmpReq: UpdateSolutionRequest, runtime: Util.RuntimeOptions): UpdateSolutionResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateSolutionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.solution)) {
    request.solutionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.solution, 'Solution', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.knowledgeId)) {
    body['KnowledgeId'] = request.knowledgeId;
  }
  if (!Util.isUnset(request.operatorId)) {
    body['OperatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorName)) {
    body['OperatorName'] = request.operatorName;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.solutionShrink)) {
    body['Solution'] = request.solutionShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSolution',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSolution(request: UpdateSolutionRequest): UpdateSolutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSolutionWithOptions(request, runtime);
}

model UpgradeIsvConfigRequest {
  aliyunAccountDTO?: {
    aliUid?: long(name='AliUid'),
  }(name='AliyunAccountDTO'),
  versionId?: long(name='VersionId'),
}

model UpgradeIsvConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpgradeIsvConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeIsvConfigResponseBody(name='body'),
}

async function upgradeIsvConfigWithOptions(request: UpgradeIsvConfigRequest, runtime: Util.RuntimeOptions): UpgradeIsvConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.aliyunAccountDTO)) {
    bodyFlat['AliyunAccountDTO'] = request.aliyunAccountDTO;
  }
  if (!Util.isUnset(request.versionId)) {
    body['VersionId'] = request.versionId;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeIsvConfig',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeIsvConfig(request: UpgradeIsvConfigRequest): UpgradeIsvConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeIsvConfigWithOptions(request, runtime);
}

model UpgradePackageRequest {
  operator?: {
    operatorId?: string(name='OperatorId'),
    operatorName?: string(name='OperatorName'),
  }(name='Operator'),
  packageDTO?: {
    packageCode?: string(name='PackageCode'),
    packageVersion?: string(name='PackageVersion'),
  }(name='PackageDTO'),
  robotCodes?: [ string ](name='RobotCodes'),
}

model UpgradePackageShrinkRequest {
  operatorShrink?: string(name='Operator'),
  packageDTOShrink?: string(name='PackageDTO'),
  robotCodesShrink?: string(name='RobotCodes'),
}

model UpgradePackageResponseBody = {
  code?: string(name='Code'),
  data?: {
    failedRobotCodes?: [ string ](name='FailedRobotCodes'),
    successRobotCodes?: [ string ](name='SuccessRobotCodes'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpgradePackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradePackageResponseBody(name='body'),
}

async function upgradePackageWithOptions(tmpReq: UpgradePackageRequest, runtime: Util.RuntimeOptions): UpgradePackageResponse {
  Util.validateModel(tmpReq);
  var request = new UpgradePackageShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.operator)) {
    request.operatorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.operator, 'Operator', 'json');
  }
  if (!Util.isUnset(tmpReq.packageDTO)) {
    request.packageDTOShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.packageDTO, 'PackageDTO', 'json');
  }
  if (!Util.isUnset(tmpReq.robotCodes)) {
    request.robotCodesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.robotCodes, 'RobotCodes', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.operatorShrink)) {
    body['Operator'] = request.operatorShrink;
  }
  if (!Util.isUnset(request.packageDTOShrink)) {
    body['PackageDTO'] = request.packageDTOShrink;
  }
  if (!Util.isUnset(request.robotCodesShrink)) {
    body['RobotCodes'] = request.robotCodesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpgradePackage',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradePackage(request: UpgradePackageRequest): UpgradePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradePackageWithOptions(request, runtime);
}

model UploadKnowledgeResultRequest {
  digDatas?: [ 
    {
      acceptType?: string(name='AcceptType'),
      contentType?: string(name='ContentType'),
      kmpAnswerId?: string(name='KmpAnswerId'),
      kmpClusterId?: string(name='KmpClusterId'),
      knowledgeId?: string(name='KnowledgeId'),
      questionId?: string(name='QuestionId'),
      questionName?: string(name='QuestionName'),
      robotCode?: string(name='RobotCode'),
      sceneKey?: string(name='SceneKey'),
      sceneName?: string(name='SceneName'),
      solutionId?: string(name='SolutionId'),
      taskId?: long(name='TaskId'),
    }
  ](name='DigDatas'),
}

model UploadKnowledgeResultShrinkRequest {
  digDatasShrink?: string(name='DigDatas'),
}

model UploadKnowledgeResultResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UploadKnowledgeResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadKnowledgeResultResponseBody(name='body'),
}

async function uploadKnowledgeResultWithOptions(tmpReq: UploadKnowledgeResultRequest, runtime: Util.RuntimeOptions): UploadKnowledgeResultResponse {
  Util.validateModel(tmpReq);
  var request = new UploadKnowledgeResultShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.digDatas)) {
    request.digDatasShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.digDatas, 'DigDatas', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.digDatasShrink)) {
    body['DigDatas'] = request.digDatasShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UploadKnowledgeResult',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadKnowledgeResult(request: UploadKnowledgeResultRequest): UploadKnowledgeResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadKnowledgeResultWithOptions(request, runtime);
}

model UploadLabelDataRequest {
  chatId?: string(name='ChatId'),
  content?: string(name='Content'),
  correct?: boolean(name='Correct'),
  correctSceneKey?: string(name='CorrectSceneKey'),
  robotCode?: string(name='RobotCode'),
  sceneKey?: string(name='SceneKey'),
  sellerId?: string(name='SellerId'),
  sellerNick?: string(name='SellerNick'),
  sendTime?: long(name='SendTime'),
  sessionId?: string(name='SessionId'),
  staffId?: string(name='StaffId'),
  staffNick?: string(name='StaffNick'),
  userId?: string(name='UserId'),
  userNick?: string(name='UserNick'),
}

model UploadLabelDataResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UploadLabelDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadLabelDataResponseBody(name='body'),
}

async function uploadLabelDataWithOptions(request: UploadLabelDataRequest, runtime: Util.RuntimeOptions): UploadLabelDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.chatId)) {
    body['ChatId'] = request.chatId;
  }
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.correct)) {
    body['Correct'] = request.correct;
  }
  if (!Util.isUnset(request.correctSceneKey)) {
    body['CorrectSceneKey'] = request.correctSceneKey;
  }
  if (!Util.isUnset(request.robotCode)) {
    body['RobotCode'] = request.robotCode;
  }
  if (!Util.isUnset(request.sceneKey)) {
    body['SceneKey'] = request.sceneKey;
  }
  if (!Util.isUnset(request.sellerId)) {
    body['SellerId'] = request.sellerId;
  }
  if (!Util.isUnset(request.sellerNick)) {
    body['SellerNick'] = request.sellerNick;
  }
  if (!Util.isUnset(request.sendTime)) {
    body['SendTime'] = request.sendTime;
  }
  if (!Util.isUnset(request.sessionId)) {
    body['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.staffId)) {
    body['StaffId'] = request.staffId;
  }
  if (!Util.isUnset(request.staffNick)) {
    body['StaffNick'] = request.staffNick;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userNick)) {
    body['UserNick'] = request.userNick;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UploadLabelData',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadLabelData(request: UploadLabelDataRequest): UploadLabelDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadLabelDataWithOptions(request, runtime);
}

model UploadTaskFileRequest {
  bizType?: string(name='BizType'),
  fileName?: string(name='FileName'),
  productId?: long(name='ProductId'),
  userId?: string(name='UserId'),
}

model UploadTaskFileResponseBody = {
  code?: string(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
}

model UploadTaskFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadTaskFileResponseBody(name='body'),
}

async function uploadTaskFileWithOptions(request: UploadTaskFileRequest, runtime: Util.RuntimeOptions): UploadTaskFileResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadTaskFile',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadTaskFile(request: UploadTaskFileRequest): UploadTaskFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadTaskFileWithOptions(request, runtime);
}

model VerifyOrderRequest {
  data?: string(name='data'),
}

model VerifyOrderResponseBody = {
  code?: string(name='code'),
  data?: string(name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model VerifyOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyOrderResponseBody(name='body'),
}

async function verifyOrderWithOptions(request: VerifyOrderRequest, runtime: Util.RuntimeOptions): VerifyOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.data)) {
    query['data'] = request.data;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyOrder',
    version = '2021-02-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyOrder(request: VerifyOrderRequest): VerifyOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyOrderWithOptions(request, runtime);
}

