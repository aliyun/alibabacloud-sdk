/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'servicemesh';
  @version = '2020-01-11';
  @endpointRule = 'central';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AddClusterIntoServiceMeshRequest {
  clusterId: string(name='ClusterId', example='ce3c25e247da24f3aab9b7edfae83****', position='Body'),
  ignoreNamespaceCheck?: boolean(name='IgnoreNamespaceCheck', example='false', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', example='cb8963379255149cb98c8686f274x****', position='Body'),
}

model AddClusterIntoServiceMeshResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='success'),
  requestId?: string(name='RequestId', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model AddClusterIntoServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddClusterIntoServiceMeshResponseBody(name='body'),
}

async function addClusterIntoServiceMesh(request: AddClusterIntoServiceMeshRequest): AddClusterIntoServiceMeshResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddClusterIntoServiceMesh', 'POST', '/', 'json', true, 'form', request);
}

model AddVMIntoServiceMeshRequest {
  ecsId: string(name='EcsId', description='The ID of the ECS instance.', example='i-2ze90ts4e7dj3650****', position='Query'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='ccb37ff104caf419fbf48fb38e6f3****', position='Query'),
}

model AddVMIntoServiceMeshResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='4b2c0fe0-6705-4614-8521-6b9d289163c8'),
}

model AddVMIntoServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddVMIntoServiceMeshResponseBody(name='body'),
}

/**
  * @deprecated
  *
 */
// Deprecated
async function addVMIntoServiceMesh(request: AddVMIntoServiceMeshRequest): AddVMIntoServiceMeshResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddVMIntoServiceMesh', 'POST', '/', 'json', false, 'json', request);
}

model CreateASMGatewayRequest {
  body?: string(name='Body', description='The YAML content that is used to create the ASM gateway.', example='{"apiVersion":"istio.alibabacloud.com/v1beta1","kind":"IstioGateway","metadata":{"name":"ingressgateway","namespace":"istio-system"},"spec":{"gatewayType":"ingress","clusterIds":["xxxxx"],"ports":[{"name":"http-0","port":80,"targetPort":80,"protocol":"TCP"},{"name":"https-1","port":443,"targetPort":443,"protocol":"TCP"}],"serviceAnnotations":{"service.beta.kubernetes.io/alicloud-loadbalancer-address-type":"internet","service.beta.kubernetes.io/alibaba-cloud-loadbalancer-spec":"slb.s1.small"},"replicaCount":2,"resources":{"limits":{"cpu":"2","memory":"4G"},"requests":{"cpu":"200m","memory":"256Mi"}},"serviceType":"LoadBalancer","maxReplicas":2,"minReplicas":2}}', position='Body'),
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='cb8963379255149cb98c8686f274x****', position='Body'),
}

model CreateASMGatewayResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model CreateASMGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateASMGatewayResponseBody(name='body'),
}

async function createASMGateway(request: CreateASMGatewayRequest): CreateASMGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateASMGateway', 'POST', '/', 'json', true, 'form', request);
}

model CreateGatewaySecretRequest {
  cert?: string(name='Cert', description='The content of the certificate.', example='-----BEGIN CERTIFICATE----- MIIC2DCCAcACA-----END CERTIF****-----', position='Body'),
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway', position='Body'),
  key?: string(name='Key', description='The private key of the certificate.', example='MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQC2ag/Bzcgm****', position='Body'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='bookinfo-secret', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
}

model CreateGatewaySecretResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
  secretCreateRecord?: map[string]SecretCreateRecordValue(name='SecretCreateRecord', description='The record of creating the secret.'),
}

model CreateGatewaySecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGatewaySecretResponseBody(name='body'),
}

async function createGatewaySecret(request: CreateGatewaySecretRequest): CreateGatewaySecretResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGatewaySecret', 'POST', '/', 'json', true, 'form', request);
}

model CreateIstioGatewayDomainsRequest {
  credential?: string(name='Credential', description='The name of the secret that contains the Transport Layer Security (TLS) certificate and certificate authority (CA) certificate.', example='bookinfo-secret', position='Body'),
  forceHttps?: boolean(name='ForceHttps', description='Specifies whether to forcibly use TLS to protect connection security.

*   `true`: forcibly uses TLS to protect connection security.
*   `false`: does not forcibly use TLS to protect connection security.', example='true', position='Body'),
  hosts: string(name='Hosts', description='The one or more domain names that are exposed by the ASM gateway. Separate multiple domain names with commas (,).', example='example.com,demo.com', position='Body'),
  istioGatewayName: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway', position='Body'),
  limit?: string(name='Limit', description='The maximum number of ASM gateways to query.', example='10', position='Body'),
  namespace?: string(name='Namespace', description='The name of the namespace.', example='default', position='Body'),
  number: int32(name='Number', description='The port that is provided by the ASM gateway.', example='443', position='Body'),
  portName: string(name='PortName', description='The name of the port.', example='http-demo', position='Body'),
  protocol: string(name='Protocol', description='The type of the protocol. Valid values: `HTTP`, `HTTPS`, `GRPC`, `HTTP2`, `MONGO`, `TCP`, and `TLS`.', example='HTTPS', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
}

model CreateIstioGatewayDomainsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model CreateIstioGatewayDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIstioGatewayDomainsResponseBody(name='body'),
}

async function createIstioGatewayDomains(request: CreateIstioGatewayDomainsRequest): CreateIstioGatewayDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateIstioGatewayDomains', 'POST', '/', 'json', true, 'form', request);
}

model CreateIstioGatewayRoutesRequest {
  description?: string(name='Description', description='The description of the routing rule.', example='demo route', position='Body'),
  gatewayRoute?: {
    domains?: [ string ](name='Domains', description='The requested domain names.'),
    HTTPAdvancedOptions?: {
      delegate?: {
        name?: string(name='Name', description='The name of the virtual service.', example='reviews'),
        namespace?: string(name='Namespace', description='The namespace to which the virtual service belongs.', example='default'),
      }(name='Delegate', description='The virtual service that defines traffic routing.'),
      fault?: {
        abort?: {
          httpStatus?: int32(name='HttpStatus', description='The HTTP status code.', example='400'),
          percentage?: {
            value?: float(name='Value', description='The percentage of requests that are aborted with the specified error code, which is expressed as a decimal.', example='0.1'),
          }(name='Percentage', description='The percentage of requests that are aborted with the specified error code.'),
        }(name='Abort', description='The configurations for aborting requests with specified error codes.'),
        delay?: {
          fixedDelay?: string(name='FixedDelay', description='The fixed duration for request delay.', example='5s'),
          percentage?: {
            value?: float(name='Value', description='The percentage of requests to which the delay fault is injected, which is expressed as a decimal.', example='0.1'),
          }(name='Percentage', description='The percentage of requests to which the delay fault is injected.'),
        }(name='Delay', description='The duration to delay a request.'),
      }(name='Fault', description='The configurations of fault injection.'),
      HTTPRedirect?: {
        authority?: string(name='Authority', description='The value to be used to overwrite the value of the Authority or Host header during redirection.``', example='newratings.default.svc.cluster.local'),
        redirectCode?: int32(name='RedirectCode', description='The HTTP status code to be used to indicate URL redirection. Default value: 301.', example='301'),
        uri?: string(name='Uri', description='The value to be used to overwrite the URL path during redirection.', example='/v1/getProductRatings'),
      }(name='HTTPRedirect', description='The HTTP redirection rule.'),
      mirror?: {
        host?: string(name='Host', description='The name of the service defined in the service registry.', example='reviews.default.svc.cluster.local'),
        subset?: string(name='Subset', description='The name of the service subset.', example='v1'),
      }(name='Mirror', description='The configurations for mirroring HTTP traffic to another destination in addition to forwarding requests to the specified destination.'),
      mirrorPercentage?: {
        value?: float(name='Value', description='The percentage of requests that are mirrored to another destination except for the original destination, which is expressed as a decimal.', example='0.2'),
      }(name='MirrorPercentage', description='The percentage of requests that are mirrored to another destination except for the original destination.'),
      retries?: {
        attempts?: int32(name='Attempts', description='The number of retries that are allowed for a request.', example='3'),
        perTryTimeout?: string(name='PerTryTimeout', description='The timeout period for each retry. Example: `5s`.', example='5s'),
        retryOn?: string(name='RetryOn', description='The condition for retries. Example: `connect-failure,refused-stream,503`.', example='connect-failure,refused-stream,503'),
        retryRemoteLocalities?: {
          value?: boolean(name='Value', description='Specifies whether to allow retries to other localities. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
        }(name='RetryRemoteLocalities', description='Specifies whether to allow retries to other localities.'),
      }(name='Retries', description='The configurations of retries for failed requests.'),
      rewrite?: {
        authority?: string(name='Authority', description='The value to be used to overwrite the value of the Authority or Host header.', example='newratings.default.svc.cluster.local'),
        uri?: string(name='Uri', description='The value to be used to overwrite the path or prefix of the URI.', example='/v1/getProductRatings'),
      }(name='Rewrite', description='The configurations for rewriting the virtual service.'),
      timeout?: string(name='Timeout', description='The timeout period for requests.', example='5s'),
    }(name='HTTPAdvancedOptions', description='The advanced settings for routing HTTP traffic.'),
    matchRequest?: {
      headers?: [ 
        {
          matchingContent?: string(name='MatchingContent', description='The header value to be matched.', example='v1'),
          matchingMode?: string(name='MatchingMode', description='The matching mode for the header value. Valid values:

*   `exact`: exact match
*   `prefix`: match by prefix
*   `regex`: match by regular expression', example='exact'),
          name?: string(name='Name', description='The header key to be matched.', example='x-request-id'),
        }
      ](name='Headers', description='The request headers to be matched.'),
      ports?: [ int32 ](name='Ports', description='The ports of destination services for Layer 4 weighted routing.'),
      TLSMatchAttributes?: [ 
        {
          SNIHosts?: [ string ](name='SNIHosts', description='The Server Name Indication (SNI) values to be matched.'),
          TLSPort?: int32(name='TLSPort', description='The TLS port.', example='443'),
        }
      ](name='TLSMatchAttributes', description='The matching rule for Transport Layer Security (TLS) traffic.'),
      URI?: {
        matchingContent?: string(name='MatchingContent', description='The content to be matched.', example='/ratings/v2/'),
        matchingMode?: string(name='MatchingMode', description='The matching mode for the routing rule. Valid values:

*   `exact`: exact match
*   `prefix`: match by prefix
*   `regex`: match by regular expression', example='prefix'),
      }(name='URI', description='The matching rule for URIs.'),
    }(name='MatchRequest', description='The matching rules for traffic routing.'),
    namespace?: string(name='Namespace', description='The namespace.', example='default'),
    rawVSRoute?: any(name='RawVSRoute', description='A JSON string. This parameter corresponds to the three routing types in virtual services and provides configuration entries for advanced features. The value of this parameter overwrites the configurations in RouteName, RouteType, MatchRequest, and HTTPAdvancedOptions.', example='{
  "http": {
    "route": [
      {
        "destination": {
          "host": "httpbin"
        }
      }
    ],
    "name": "httpbin",
    "match": [
      {
        "uri": {
          "prefix": "/"
        }
      }
    ],
    "fault": {
      "delay": {
        "fixedDelay": "2s",
        "percentage": {
          "value": 70
        }
      }
    }
  }
}'),
    routeDestinations?: [ 
      {
        destination?: {
          host?: string(name='Host', description='The name of the service defined in the service registry.', example='reviews'),
          port?: {
            number?: int32(name='Number', description='The port number.', example='80'),
          }(name='Port', description='The port.'),
          subset?: string(name='Subset', description='The name of the service subset.', example='v1'),
        }(name='Destination', description='The unique endpoint of the destination service to which the specified requests are sent.'),
        weight?: int32(name='Weight', description='The weight of the service subset.', example='80'),
      }
    ](name='RouteDestinations', description='The endpoints of destination services for Layer 4 weighted routing.'),
    routeName?: string(name='RouteName', description='The name of the routing rule.', example='reviews-v2-routes'),
    routeType?: string(name='RouteType', description='The type of the traffic to be routed. Valid values: `HTTP`, `TLS`, and `TCP`.', example='HTTP'),
  }(name='GatewayRoute', description='The information about the routing rule to be created for the ASM gateway.', shrink='json', position='Body'),
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway', position='Body'),
  priority?: int32(name='Priority', description='The priority of the routing rule. The value of this parameter is an integer. A smaller value indicates a higher priority.', example='1', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
  status?: int32(name='Status', description='The status of the routing rule. Valid values:

*   `0`: The routing rule is valid.
*   `1`: The routing rule is invalid.
*   `2`: An error occurs during the creation or update of the routing rule.', example='1', position='Body'),
}

model CreateIstioGatewayRoutesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model CreateIstioGatewayRoutesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIstioGatewayRoutesResponseBody(name='body'),
}

async function createIstioGatewayRoutes(request: CreateIstioGatewayRoutesRequest): CreateIstioGatewayRoutesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateIstioGatewayRoutes', 'POST', '/', 'json', true, 'form', request);
}

model CreateServiceMeshRequest {
  accessLogEnabled?: boolean(name='AccessLogEnabled', description='Specifies whether to enable access log collection. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  accessLogFile?: string(name='AccessLogFile', description='Specifies whether to enable access log collection. Valid values:

*   "": disables access log collection.
*   `/dev/stdout`: enables access log collection. Access logs are written to /dev/stdout.', example='/dev/stdout', position='Body'),
  accessLogFormat?: string(name='AccessLogFormat', description='Custom fields of access logs. To set this parameter, you must enable access log collection. Otherwise, you cannot set this parameter. The value must be a JSON string. The following key values must be contained: authority_for, bytes_received, bytes_sent, downstream_local_address, downstream_remote_address, duration, istio_policy_status, method, path, protocol, requested_server_name, response_code, response_flags, route_name, start_time, trace_id, upstream_cluster, upstream_host, upstream_local_address, upstream_service_time, upstream_transport_failure_reason, user_agent, and x_forwarded_for.', example='{"authority_for":"%REQ(:AUTHORITY)%","bytes_received":"%BYTES_RECEIVED%","bytes_sent":"%BYTES_SENT%","downstream_local_address":"%DOWNSTREAM_LOCAL_ADDRESS%","downstream_remote_address":"%DOWNSTREAM_REMOTE_ADDRESS%","duration":"%DURATION%","istio_policy_status":"%DYNAMIC_METADATA(istio.mixer:status)%","method":"%REQ(:METHOD)%","path":"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%","protocol":"%PROTOCOL%","request_id":"%REQ(X-REQUEST-ID)%","requested_server_name":"%REQUESTED_SERVER_NAME%","response_code":"%RESPONSE_CODE%","response_flags":"%RESPONSE_FLAGS%","route_name":"%ROUTE_NAME%","start_time":"%START_TIME%","trace_id":"%REQ(X-B3-TRACEID)%","upstream_cluster":"%UPSTREAM_CLUSTER%","upstream_host":"%UPSTREAM_HOST%","upstream_local_address":"%UPSTREAM_LOCAL_ADDRESS%","upstream_service_time":"%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)%","upstream_transport_failure_reason":"%UPSTREAM_TRANSPORT_FAILURE_REASON%","user_agent":"%REQ(USER-AGENT)%","x_forwarded_for":"%REQ(X-FORWARDED-FOR)%"}', position='Body'),
  accessLogProject?: string(name='AccessLogProject', description='The SLS project from which access logs are collected.', example='mesh-log-cf245a429b6ff4b6e97f20797758*****', position='Body'),
  accessLogServiceEnabled?: boolean(name='AccessLogServiceEnabled', description='Specifies whether to enable gRPC Access Log Service (ALS) of Envoy. gRPC is short for Google Remote Procedure Call. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  accessLogServiceHost?: string(name='AccessLogServiceHost', description='The endpoint of Envoy\\"s gRPC ALS.', example='0.0.0.0', position='Body'),
  accessLogServicePort?: int32(name='AccessLogServicePort', description='The port of Envoy\\"s gRPC ALS.', example='9999', position='Body'),
  apiServerLoadBalancerSpec?: string(name='ApiServerLoadBalancerSpec', description='The type of the CLB instance that is bound to Istio Pilot. Valid values: `slb.s1.small`, `slb.s2.small`, `slb.s2.medium`, `slb.s3.small`, `slb.s3.medium`, and `slb.s3.large`.', example='slb.s1.small', position='Body'),
  apiServerPublicEip?: boolean(name='ApiServerPublicEip', description='Specifies whether to expose the API server to the Internet. Valid values:

*   `true`
*   `false`

Default value: `false`.

> If you set this parameter to `false`, the API server cannot be accessed over the Internet.', example='false', position='Body'),
  auditProject?: string(name='AuditProject', description='The name of the Log Service project that is used for mesh audit.

Default value: mesh-log-{ASM instance ID}.', example='mesh-log-xxxx', position='Body'),
  autoRenew?: boolean(name='AutoRenew', description='Specifies whether to enable auto-renewal for the CLB instance if the CLB instance uses the subscription billing method. Valid values:

- true

- false', example='true', position='Body'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', description='The auto-renewal period of the CLB instance. This parameter is valid only if the `ChargeType` parameter is set to `PrePay`. If the original subscription period of the CLB instance is less than one year, the value of this parameter indicates the number of months for auto-renewal. If the original subscription period of the CLB instance is more than one year, the value of this parameter indicates the number of years for auto-renewal.', example='3', position='Body'),
  CRAggregationEnabled?: boolean(name='CRAggregationEnabled', description='Specifies whether to allow the Kubernetes API of clusters on the data plane to access Istio resources. The version of the ASM instance must be V1.9.7.93 or later. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  chargeType?: string(name='ChargeType', description='The billing method of the CLB instance. Valid values:

*   `PayOnDemand`: pay-as-you-go.
*   `PrePay`: subscription.', example='PrePay', position='Body'),
  clusterDomain?: string(name='ClusterDomain', position='Body'),
  clusterSpec?: string(name='ClusterSpec', description='The edition of the ASM instance. Valid values:

- `standard`: Standard Edition

- `enterprise`: Enterprise Edition

- `ultimate`: Ultimate Edition', example='standard', position='Body'),
  configSourceEnabled?: boolean(name='ConfigSourceEnabled', description='Specifies whether to enable the external service registry. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  configSourceNacosID?: string(name='ConfigSourceNacosID', description='The instance ID of the Nacos registry.', example='mse-cn-tl326******', position='Body'),
  controlPlaneLogEnabled?: boolean(name='ControlPlaneLogEnabled', description='Specifies whether to enable the collection of control plane logs. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  controlPlaneLogProject?: string(name='ControlPlaneLogProject', description='The name of the Log Service project that is used to collect the logs of the control plane.', example='mesh-log-cf245a429b6ff4b6e97f20797758*****', position='Body'),
  customizedPrometheus?: boolean(name='CustomizedPrometheus', description='Specifies whether to use a custom Prometheus instance. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  customizedZipkin?: boolean(name='CustomizedZipkin', description='Specifies whether to use a self-managed Zipkin system to collect tracing data. Valid values:

*   `true`: uses a self-managed Zipkin system to collect tracing data.
*   `false`: uses Alibaba Cloud Tracing Analysis to collect tracing data.

Default value: `false`.', example='false', position='Body'),
  DNSProxyingEnabled?: boolean(name='DNSProxyingEnabled', description='Specifies whether to enable the DNS proxy feature. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  dubboFilterEnabled?: boolean(name='DubboFilterEnabled', description='Specifies whether to enable Dubbo Filter. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  edition?: string(name='Edition', description='The edition of the ASM instance.', example='Pro', position='Body'),
  enableAmbient?: boolean(name='EnableAmbient', description='Specifies whether to enable the Ambient Mesh mode for the ASM instance.', example='false', position='Body'),
  enableAudit?: boolean(name='EnableAudit', description='Specifies whether to enable the mesh audit feature. To enable this feature, make sure that you have activated [Log Service](https://sls.console.aliyun.com/). Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  enableCRHistory?: boolean(name='EnableCRHistory', description='Specifies whether to enable the rollback feature for Istio resources. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  enableSDSServer?: boolean(name='EnableSDSServer', description='Specifies whether to enable Secret Discovery Service (SDS). Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  excludeIPRanges?: string(name='ExcludeIPRanges', description='The IP ranges in CIDR form to be excluded from redirection to the sidecar proxy in the ASM instance.', example='100.100.10*.***', position='Body'),
  excludeInboundPorts?: string(name='ExcludeInboundPorts', description='The inbound ports to be excluded from redirection to the sidecar proxy in the ASM instance. Separate multiple port numbers with commas (,).', example='80,81', position='Body'),
  excludeOutboundPorts?: string(name='ExcludeOutboundPorts', description='The outbound ports to be excluded from redirection to the sidecar proxy in the ASM instance. Separate multiple port numbers with commas (,).', example='80,81', position='Body'),
  existingCaCert?: string(name='ExistingCaCert', description='The existing CA certificate, which is encoded in Base64. This parameter is used in scenarios where you migrate open source Istio to ASM. It specifies the content of the ca-cert.pem file in the istio-ca-secret secret. The secret is in the istio-system namespace of the Kubernetes cluster where the open source Istio is installed.', example='CA cert content, base64 encoded format.', position='Body'),
  existingCaKey?: string(name='ExistingCaKey', description='The existing CA key, which is encoded in Base64. This parameter is used in scenarios where you migrate open source Istio to ASM. It specifies the content of the ca-key.pem file in the istio-ca-secret secret. The secret is in the istio-system namespace of the Kubernetes cluster where the open source Istio is installed.', example='CA key content, base64 encoded format.', position='Body'),
  existingCaType?: string(name='ExistingCaType', description='The type of the existing CA certificate. Valid values:

*   1: Self-signed certificate generated by istiod. The certificate corresponds to the secret named istio-ca-secret in the istio-system namespace. If you use this type of certificate, you must set the `ExistingCaCert` and `ExsitingCaKey` parameters.
*   2: Administrator-specified certificate. For more information, see [plugin ca cert](https://istio.io/latest/docs/tasks/security/cert-management/plugin-ca-cert/). In most cases, the certificate corresponds to the secret named cacerts in the istio-system namespace. If you use this type of certificate, you must set the `ExisingRootCaCert` and `ExisingRootCaKey` parameters.', example='1', position='Body'),
  existingRootCaCert?: string(name='ExistingRootCaCert', description='The existing root certificate, which is encoded in Base64.', example='Existing CA cert content, base64 encoded format.', position='Body'),
  existingRootCaKey?: string(name='ExistingRootCaKey', description='The private key that corresponds to the root certificate, which is encoded in Base64.', example='Existing CA key content, base64 encoded format.', position='Body'),
  filterGatewayClusterConfig?: boolean(name='FilterGatewayClusterConfig', description='Specifies whether to enable gateway configuration filtering. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  gatewayAPIEnabled?: boolean(name='GatewayAPIEnabled', description='Specifies whether to enable Gateway API. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  guestCluster?: string(name='GuestCluster', description='When you create an ASM instance, you can add a cluster to the ASM instance. If you do not specify this parameter, no cluster is added to the ASM instance. The cluster and the ASM instance must be in the same vSwitch of the same VPC and have the same domain name.', example='ACK cluster id', position='Body'),
  includeIPRanges?: string(name='IncludeIPRanges', description='The IP ranges in CIDR form for which traffic is to be redirected to the sidecar proxy in the ASM instance.', example='*', position='Body'),
  istioVersion?: string(name='IstioVersion', description='The Istio version of the ASM instance.', example='v1.5.4.1-g5960ec40-aliyun', position='Body'),
  kialiEnabled?: boolean(name='KialiEnabled', description='Specifies whether to enable the mesh topology feature. To enable this feature, make sure that you have enabled Prometheus monitoring. If Prometheus monitoring is disabled, you must set this parameter to `false`.`` Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  localityLBConf?: string(name='LocalityLBConf', description='The configurations for the access to the nearest instance.', example='{"failover":[{"from":"cn-hangzhou","to":"cn-shanghai"}]}', position='Body'),
  localityLoadBalancing?: boolean(name='LocalityLoadBalancing', description='Specifies whether to route traffic to the nearest instance. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  MSEEnabled?: boolean(name='MSEEnabled', description='Specifies whether to enable Microservices Engine (MSE). Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  multiBufferEnabled?: boolean(name='MultiBufferEnabled', description='Specifies whether to enable MultiBuffer-based Transport Layer Security (TLS) acceleration. Valid values:

- `true`

- `false`


Default value: `true`', example='true', position='Body'),
  multiBufferPollDelay?: string(name='MultiBufferPollDelay', description='The pull-request latency. Default value: 30. Unit: seconds.', example='30s', position='Body'),
  mysqlFilterEnabled?: boolean(name='MysqlFilterEnabled', description='Specifies whether to enable MySQL Filter. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  name?: string(name='Name', description='The name of the ASM instance.', example='mesh1', position='Body'),
  OPALimitCPU?: string(name='OPALimitCPU', description='The maximum number of CPU cores that are available to the OPA container.', example='2', position='Body'),
  OPALimitMemory?: string(name='OPALimitMemory', description='The maximum size of the memory that is available to the OPA container. You can specify the parameter value in the standard quantity representation form used by Kubernetes. 1 Mi equals 1,024 KB.', example='1024Mi', position='Body'),
  OPALogLevel?: string(name='OPALogLevel', description='The log level of the OPA container.', example='info', position='Body'),
  OPARequestCPU?: string(name='OPARequestCPU', description='The minimum number of CPU cores that are required by the OPA container. You can specify the parameter value in the standard representation form of CPUs in Kubernetes. For example, if you set the value to 1, one CPU core is required.', example='1', position='Body'),
  OPARequestMemory?: string(name='OPARequestMemory', description='The minimum size of the memory that is required by the OPA container. You can specify the parameter value in the standard quantity representation form used by Kubernetes. 1 Mi equals 1,024 KB.', example='512Mi', position='Body'),
  opaEnabled?: boolean(name='OpaEnabled', description='Specifies whether to enable the OPA plug-in. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  openAgentPolicy?: boolean(name='OpenAgentPolicy', description='Specifies whether to install the Open Policy Agent (OPA) plug-in. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  period?: int32(name='Period', description='The auto-renewal period of the CLB instance. This parameter is valid only if `ChargeType` is set to `PrePaid`. The value of this parameter indicates the purchased month of the CLB instance when the subscription billing method is used. For example, if the subscription period is one year, set this parameter to 12.', example='3', position='Body'),
  pilotLoadBalancerSpec?: string(name='PilotLoadBalancerSpec', description='The type of the CLB instance that is bound to Istio Pilot. Valid values: `slb.s1.small`, `slb.s2.small`, `slb.s2.medium`, `slb.s3.small`, `slb.s3.medium`, and `slb.s3.large`.', example='slb.s1.small', position='Body'),
  prometheusUrl?: string(name='PrometheusUrl', description='The endpoint of the custom Prometheus instance.', example='http://prometheus:9090', position='Body'),
  proxyLimitCPU?: string(name='ProxyLimitCPU', description='The maximum number of CPU cores that are available to the proxy container.', example='2000m', position='Body'),
  proxyLimitMemory?: string(name='ProxyLimitMemory', description='The maximum size of the memory that is available to the proxy container.', example='1024Mi', position='Body'),
  proxyRequestCPU?: string(name='ProxyRequestCPU', description='The minimum number of CPU cores that are required by the proxy container.', example='100m', position='Body'),
  proxyRequestMemory?: string(name='ProxyRequestMemory', description='The minimum size of the memory that is required by the proxy container.', example='128Mi', position='Body'),
  redisFilterEnabled?: boolean(name='RedisFilterEnabled', description='Specifies whether to enable Redis Filter. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='true', position='Body'),
  regionId: string(name='RegionId', description='The ID of the region in which the ASM instance resides.', example='cn-hangzhou', position='Body'),
  tag?: [ 
    {
      key?: string(name='Key', description='The name of the tag.', example='env'),
      value?: string(name='Value', description='The value of the tag.', example='prod'),
    }
  ](name='Tag', description='Tag of the ASM instance. A tag contains the following information:

*   key: the name of the tag
*   value: the value of the tag', position='Query'),
  telemetry?: boolean(name='Telemetry', description='Specifies whether to enable Prometheus monitoring. We recommend that you use Prometheus Service of [Application Real-Time Monitoring Service (ARMS)](https://arms.console.aliyun.com/). Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  thriftFilterEnabled?: boolean(name='ThriftFilterEnabled', description='Specifies whether to enable Thrift Filter. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  traceSampling?: float(name='TraceSampling', description='The sampling percentage of Tracing Analysis.', example='100', position='Body'),
  tracing?: boolean(name='Tracing', description='Specifies whether to enable the Tracing Analysis feature. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
  useExistingCA?: boolean(name='UseExistingCA', description='Specifies whether to use an existing CA certificate and private key.', example='false', position='Body'),
  vSwitches: string(name='VSwitches', description='The ID of the vSwitch to which the ASM instance is connected.', example='["vsw-xzegf5dndkbf4m6eg****"]', position='Body'),
  vpcId: string(name='VpcId', description='The ID of the virtual private cloud (VPC) in which the ASM instance resides.', example='vpc-xzelac2tw4ic7wz31****', position='Body'),
  webAssemblyFilterEnabled?: boolean(name='WebAssemblyFilterEnabled', description='Specifies whether to enable WebAssembly Filter. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false', position='Body'),
}

model CreateServiceMeshResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
}

model CreateServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceMeshResponseBody(name='body'),
}

async function createServiceMesh(request: CreateServiceMeshRequest): CreateServiceMeshResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateServiceMesh', 'POST', '/', 'json', true, 'form', request);
}

model CreateSwimLaneRequest {
  groupName?: string(name='GroupName', description='The name of the lane group.', example='test', position='Body'),
  labelSelectorKey?: string(name='LabelSelectorKey', description='The label key of the associated service workload. Set the value to `ASM_TRAFFIC_TAG`.', example='ASM_TRAFFIC_TAG', position='Body'),
  labelSelectorValue?: string(name='LabelSelectorValue', description='The label value of the associated service workload.``', example='v3', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the Service Mesh (ASM) instance.', example='*****', position='Body'),
  servicesList?: string(name='ServicesList', description='The list of services associated with the lane. The value is a JSON array. The format of a single service is `$Cluster name/$Cluster ID/$Namespace/$Service name`.', example='[\\"sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mocka\\",\\"sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockb\\",\\"sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockc\\"]', position='Body'),
  swimLaneName?: string(name='SwimLaneName', description='The name of the lane.', example='s3', position='Body'),
}

model CreateSwimLaneResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='*****'),
}

model CreateSwimLaneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSwimLaneResponseBody(name='body'),
}

async function createSwimLane(request: CreateSwimLaneRequest): CreateSwimLaneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSwimLane', 'POST', '/', 'json', true, 'form', request);
}

model CreateSwimLaneGroupRequest {
  groupName: string(name='GroupName', description='The name of the lane group.', example='test', position='Body'),
  ingressGatewayName: string(name='IngressGatewayName', description='The name of the ingress gateway.', example='ingressgateway', position='Body'),
  ingressType: string(name='IngressType', description='The type of the gateway for ingress traffic. Only ASM ingress gateways are supported.', example='ASM', position='Body'),
  isPermissive?: boolean(name='IsPermissive', position='Body'),
  routeHeader?: string(name='RouteHeader', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the Alibaba Cloud Service Mesh (ASM) instance.', example='xxx', position='Body'),
  servicesList: string(name='ServicesList', description='A list of services associated with the lane group. The value is a JSON array. The format of a service is `$Cluster name/$Cluster ID/$Namespace/$Service name`.', example='[\\"sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mocka\\",\\"sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockb\\",\\"sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockc\\"]', position='Body'),
  traceHeader?: string(name='TraceHeader', position='Body'),
}

model CreateSwimLaneGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='yyyy'),
}

model CreateSwimLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSwimLaneGroupResponseBody(name='body'),
}

async function createSwimLaneGroup(request: CreateSwimLaneGroupRequest): CreateSwimLaneGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSwimLaneGroup', 'POST', '/', 'json', true, 'form', request);
}

model CreateWaypointRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster on the data plane.', example='cb8963379255149cb98c8686f274x****', minLength=1, position='Body'),
  HPAEnabled?: boolean(name='HPAEnabled', description='Specifies whether to enable Horizontal Pod Autoscaling (HPA).', example='false', position='Body'),
  HPAMaxReplicas?: int32(name='HPAMaxReplicas', description='The maximum number of waypoint proxy pods when HPA is enabled.', example='4', minimum=0, position='Body'),
  HPAMinReplicas?: int32(name='HPAMinReplicas', description='The minimum number of waypoint proxy pods when HPA is enabled.', example='2', minimum=0, position='Body'),
  HPATargetCPU?: int32(name='HPATargetCPU', description='The expected CPU utilization when HPA is enabled.', example='93', minimum=0, maximum=100, position='Body'),
  HPATargetMemory?: int32(name='HPATargetMemory', description='The expected memory usage when HPA is enabled.', example='91', minimum=0, maximum=100, position='Body'),
  limitCPU?: string(name='LimitCPU', description='The maximum number of CPU cores that are available to the waypoint proxy pods.', example='2000m', position='Body'),
  limitMemory?: string(name='LimitMemory', description='The maximum size of the memory that is available to the waypoint proxy pods.', example='1024Mi', position='Body'),
  namespace: string(name='Namespace', description='The namespace.', example='default', position='Body'),
  preferECI?: boolean(name='PreferECI', description='Specifies whether to deploy waypoint proxy pods based on Elastic Container Instance (ECI).', example='false', position='Body'),
  replicas?: int32(name='Replicas', description='The number of waypoint proxy pods.', example='1', minimum=0, position='Body'),
  requestCPU?: string(name='RequestCPU', description='The number of CPU cores requested by the waypoint proxy pods.', example='100m', position='Body'),
  requestMemory?: string(name='RequestMemory', description='The size of the memory requested by the waypoint proxy pods.', example='128Mi', position='Body'),
  serviceAccount?: string(name='ServiceAccount', description='The service account on which the waypoint proxy takes effect. If you do not specify this parameter, the waypoint proxy takes effect for the entire namespace.', example='bookinfo-productpage', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The Service Mesh (ASM) instance ID.', example='ce134b0727aa2492db69f6c3880e****', minLength=1, position='Body'),
}

model CreateWaypointResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='71680038-8009-5073-B43E-C057E9******'),
}

model CreateWaypointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateWaypointResponseBody(name='body'),
}

async function createWaypoint(request: CreateWaypointRequest): CreateWaypointResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateWaypoint', 'POST', '/', 'json', true, 'form', request);
}

model DeleteGatewayRouteRequest {
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway', position='Body'),
  routeName?: string(name='RouteName', description='The name of the routing rule.', example='http-route', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
}

model DeleteGatewayRouteResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DeleteGatewayRouteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGatewayRouteResponseBody(name='body'),
}

async function deleteGatewayRoute(request: DeleteGatewayRouteRequest): DeleteGatewayRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGatewayRoute', 'POST', '/', 'json', true, 'form', request);
}

model DeleteGatewaySecretRequest {
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway', position='Body'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='bookinfo-secret', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
}

model DeleteGatewaySecretResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
  secretDeleteRecord?: map[string]SecretDeleteRecordValue(name='SecretDeleteRecord', description='The records of deleting the secret in all clusters.'),
}

model DeleteGatewaySecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGatewaySecretResponseBody(name='body'),
}

async function deleteGatewaySecret(request: DeleteGatewaySecretRequest): DeleteGatewaySecretResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGatewaySecret', 'POST', '/', 'json', true, 'form', request);
}

model DeleteIstioGatewayDomainsRequest {
  hosts?: string(name='Hosts', description='The domain names of the one or more hosts that are exposed by the ASM gateway. Separate multiple domain names with commas (,).', example='example.com,demo.com', position='Body'),
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway', position='Body'),
  limit?: string(name='Limit', description='The maximum number of Istio gateways to query.', example='10', position='Body'),
  namespace?: string(name='Namespace', description='The name of the namespace.', example='default', position='Body'),
  portName?: string(name='PortName', description='The port name.', example='https', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
}

model DeleteIstioGatewayDomainsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DeleteIstioGatewayDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIstioGatewayDomainsResponseBody(name='body'),
}

async function deleteIstioGatewayDomains(request: DeleteIstioGatewayDomainsRequest): DeleteIstioGatewayDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIstioGatewayDomains', 'POST', '/', 'json', true, 'form', request);
}

model DeleteServiceMeshRequest {
  force?: boolean(name='Force', description='Specifies whether to forcibly delete the ASM instance. Valid values:

*   `true`: forcibly deletes the ASM instance.
*   `false`: does not forcibly delete the ASM instance.

Default value: false.', example='false', position='Body'),
  retainResources?: string(name='RetainResources', description='A JSON string that can be parsed into a string array. You can use this JSON string to specify the IDs of the resource instances that need to be retained when the ASM instance is deleted.', example='[" lb-bp1fxvl3q8akbj6m*****", "lb-bp1hoxkolggdw0y3*****"]', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
}

model DeleteServiceMeshResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='11fd0027-c27e-41bb-a565-75583054****'),
}

model DeleteServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceMeshResponseBody(name='body'),
}

async function deleteServiceMesh(request: DeleteServiceMeshRequest): DeleteServiceMeshResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteServiceMesh', 'POST', '/', 'json', true, 'form', request);
}

model DeleteSwimLaneRequest {
  groupName?: string(name='GroupName', description='The name of the lane group.', example='test', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the Service Mesh (ASM) instance.', example='xxx', position='Body'),
  swimLaneName?: string(name='SwimLaneName', description='The name of the lane.', example='s1', position='Body'),
}

model DeleteSwimLaneResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='xxx'),
}

model DeleteSwimLaneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSwimLaneResponseBody(name='body'),
}

async function deleteSwimLane(request: DeleteSwimLaneRequest): DeleteSwimLaneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSwimLane', 'POST', '/', 'json', true, 'form', request);
}

model DeleteSwimLaneGroupRequest {
  groupName?: string(name='GroupName', description='The name of the lane group.', example='test', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the Service Mesh (ASM) instance.', example='xxx', position='Body'),
}

model DeleteSwimLaneGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='xxxx'),
}

model DeleteSwimLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSwimLaneGroupResponseBody(name='body'),
}

async function deleteSwimLaneGroup(request: DeleteSwimLaneGroupRequest): DeleteSwimLaneGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSwimLaneGroup', 'POST', '/', 'json', true, 'form', request);
}

model DeleteWaypointRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster on the data plane.', example='ce3c25e247da24f3aab9b7edfae83****', position='Body'),
  name: string(name='Name', description='Waypoint', example='bookinfo-reviews', position='Body'),
  namespace: string(name='Namespace', description='The namespace.', example='default', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The Service Mesh (ASM) instance ID.', example='cb8963379255149cb98c8686f274x****', position='Body'),
}

model DeleteWaypointResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model DeleteWaypointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteWaypointResponseBody(name='body'),
}

async function deleteWaypoint(request: DeleteWaypointRequest): DeleteWaypointResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWaypoint', 'POST', '/', 'json', true, 'form', request);
}

model DescribeASMGatewayImportedServicesRequest {
  ASMGatewayName?: string(name='ASMGatewayName', description='The name of the ASM gateway.', example='ingressgateway', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
  serviceNamespace?: string(name='ServiceNamespace', description='The namespace in which the services reside.', example='default', position='Body'),
}

model DescribeASMGatewayImportedServicesResponseBody = {
  importedServices?: [ 
    {
      serviceName?: string(name='ServiceName', description='The name of a service.', example='productpage'),
      serviceNamespace?: string(name='ServiceNamespace', description='The namespace in which the service resides.', example='default'),
    }
  ](name='ImportedServices', description='The list of the imported services.'),
  requestId?: string(name='RequestId', description='The request ID.', example='11fd0027-c27e-41bb-a565-75583054****'),
}

model DescribeASMGatewayImportedServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeASMGatewayImportedServicesResponseBody(name='body'),
}

async function describeASMGatewayImportedServices(request: DescribeASMGatewayImportedServicesRequest): DescribeASMGatewayImportedServicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeASMGatewayImportedServices', 'POST', '/', 'json', true, 'form', request);
}

model DescribeCCMVersionRequest {
  serviceMeshId: string(name='ServiceMeshId', description='The versions of the CCM component in all clusters on the data plane.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Query'),
}

model DescribeCCMVersionResponseBody = {
  CCMVersions?: map[string]CCMVersionsValue(name='CCMVersions', description='The ID of the request.'),
  requestId?: string(name='RequestId', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model DescribeCCMVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCCMVersionResponseBody(name='body'),
}

async function describeCCMVersion(request: DescribeCCMVersionRequest): DescribeCCMVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCCMVersion', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCensRequest {
  serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='ce134b0727aa2492db69f6c3880e1****', position='Query'),
}

model DescribeCensResponseBody = {
  clusters?: [ string ](name='Clusters', description='The list of Kubernetes clusters that are added to the same ASM instance but are in different VPCs and are not connected by using a Cloud Enterprise Network (CEN) instance.'),
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model DescribeCensResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCensResponseBody(name='body'),
}

async function describeCens(request: DescribeCensRequest): DescribeCensResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCens', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterGrafanaRequest {
  k8sClusterId: string(name='K8sClusterId', description='The ID of the cluster on the data plane.', example='ce3c25e247da24f3aab9b7edfae83****', position='Query'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='cb8963379255149cb98c8686f274x****', position='Query'),
}

model DescribeClusterGrafanaResponseBody = {
  dashboards?: [ 
    {
      title?: string(name='Title', description='The title of the Grafana dashboard.', example='test'),
      url?: string(name='Url', description='The endpoint of a Grafana dashboard.', example='test.com'),
    }
  ](name='Dashboards', description='The information of Grafana dashboards.'),
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model DescribeClusterGrafanaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterGrafanaResponseBody(name='body'),
}

async function describeClusterGrafana(request: DescribeClusterGrafanaRequest): DescribeClusterGrafanaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterGrafana', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterPrometheusRequest {
  k8sClusterId?: string(name='K8sClusterId', description='The ID of the cluster on the data plane.', example='ce3c25e247da24f3aab9b7edfae83****', position='Query'),
  k8sClusterRegionId?: string(name='K8sClusterRegionId', description='The ID of the region where the cluster on the data plane resides.', example='cn-hangzhou', position='Query'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='cb8963379255149cb98c8686f274x****', position='Query'),
}

model DescribeClusterPrometheusResponseBody = {
  prometheus?: string(name='Prometheus', description='The public endpoint of the Prometheus service that is used to monitor a cluster in the ASM instance.', example='p.com'),
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model DescribeClusterPrometheusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterPrometheusResponseBody(name='body'),
}

async function describeClusterPrometheus(request: DescribeClusterPrometheusRequest): DescribeClusterPrometheusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterPrometheus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClustersInServiceMeshRequest {
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='cb8963379255149cb98c8686f274x****', position='Query'),
}

model DescribeClustersInServiceMeshResponseBody = {
  clusters?: [ 
    {
      accessLogDashboards?: [ 
        {
          title?: string(name='Title', description='The name of the dashboard for access logs.', example='mesh-access-log_details_cn'),
          url?: string(name='Url', description='The URL of the dashboard for access logs.', example='https://sls.console.aliyun.com/next/project/****/dashboard/mesh-access-log_details_cn'),
        }
      ](name='AccessLogDashboards', description='The configurations of access log collection.'),
      clusterDomain?: string(name='ClusterDomain', description='The domain name of the cluster.', example='example.com'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c80f45444b3da447da60a911390c2****'),
      clusterType?: string(name='ClusterType', description='The type of the cluster.', example='Ask'),
      creationTime?: string(name='CreationTime', description='The time when the cluster was created.', example='2020-05-12T15:38:16+08:00'),
      errorMessage?: string(name='ErrorMessage', description='The error message.', example=','),
      logtailInstalledState?: string(name='LogtailInstalledState', description='Indicates whether the Logtail component is installed in the cluster. Valid values:

*   `logtail_installed`: The Logtail component is installed.

\\-`logtail_uninstalled`: The Logtail component is not installed.

*   `logtail_state_get_error`: The Logtail component failed to be installed.', example='logtail_installed'),
      name?: string(name='Name', description='The name of the cluster.', example='ask1'),
      regionId?: string(name='RegionId', description='The ID of the region in which the cluster resides.', example='cn-hangzhou'),
      sgId?: string(name='SgId', description='The ID of the security group.', example='sg-bp197668l6iupljy****'),
      state?: string(name='State', description='The status of the cluster.', example='running'),
      updateTime?: string(name='UpdateTime', description='The time when the cluster was last modified.', example='2020-05-12T15:38:16+08:00'),
      version?: string(name='Version', description='The version number of the cluster.', example='v1.16.6-aliyun.1'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-2zew0rajjkmxy2369****'),
    }
  ](name='Clusters', description='The list of the clusters in the ASM instance.'),
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeClustersInServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClustersInServiceMeshResponseBody(name='body'),
}

async function describeClustersInServiceMesh(request: DescribeClustersInServiceMeshRequest): DescribeClustersInServiceMeshResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClustersInServiceMesh', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCrTemplatesRequest {
  istioVersion: string(name='IstioVersion', description='The Istio version used in ASM.', example='v1.9.7.31-g24cdcb43-aliyun', position='Body'),
  kind: string(name='Kind', description='The type of Istio resource whose common YAML templates you want to query. Valid values:

*   AuthorizationPolicy
*   RequestAuthentication
*   PeerAuthentication
*   WorkloadGroup
*   WorkloadEntry
*   Sidecar
*   EnvoyFilter
*   ServiceEntry
*   Gateway
*   DestinationRule
*   VirtualService', example='VirtualService', position='Body'),
}

model DescribeCrTemplatesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='74E97AE2-2900-55C1-A069-C3C1EA*****'),
  templates?: [ 
    {
      chineseName?: string(name='ChineseName', description='The Chinese name of the YAML template.'),
      englishName?: string(name='EnglishName', description='The English name of the YAML template.', example='HTTP basic routing'),
      yaml?: string(name='Yaml', description='The content in the YAML template.', example='apiVersion: networking.istio.io/v1beta1\\nkind: VirtualService\\nmetadata:\\n  name: reviews-route # Name for this VirtualService.\\nspec:\\n  hosts:\\n  - reviews.prod.svc.cluster.local # Service that this VirtualSerivce belongs to. \\n  http:\\n  - name: \\"reviews-route\\" # Name for the route.\\n    route:\\n    - destination: # Uniquely identifies the instances of a service to which all traffic should be forwarded to.\\n        host: reviews.prod.svc.cluster.local # The name of a service from the service registry or ServiceEntry.\\n        port:\\n          number: 8080"'),
    }
  ](name='Templates', description='The common YAML templates for the specified type of Istio resource.'),
}

model DescribeCrTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCrTemplatesResponseBody(name='body'),
}

async function describeCrTemplates(request: DescribeCrTemplatesRequest): DescribeCrTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCrTemplates', 'POST', '/', 'json', true, 'form', request);
}

model DescribeEipResourcesRequest {
  pageNum?: int32(name='PageNum', description='The number of the page to return. Default value: 1.', example='1', position='Body'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='50', position='Body'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='cb8963379255149cb98c8686f274x****', position='Body'),
}

model DescribeEipResourcesResponseBody = {
  eipList?: [ 
    {
      allocationId?: string(name='AllocationId', description='The ID of the EIP.', example='eip-2zeerraiwb7ujxscd****'),
      instanceType?: string(name='InstanceType', description='The type of the resource that is associated with the EIP. Valid values:

*   `EcsInstance`: an ECS instance in a VPC
*   `SlbInstance`: a Server Load Balancer (SLB) instance in a VPC
*   `Nat`: a NAT gateway
*   `HaVip`: a high-availability virtual IP address (HAVIP)
*   `NetworkInterface`: a secondary elastic network interface (ENI)

Default value: `EcsInstance`.', example='SlbInstance'),
      ipAddress?: string(name='IpAddress', description='The IP address of the EIP.', example='120.xx.xx.112'),
      status?: string(name='Status', description='The status of the EIP. Valid values:

*   `Associating`: The EIP is being associated with a resource.
*   `Unassociating`: The EIP is being disassociated from a resource.
*   `InUse`: The EIP is associated with a resource.
*   `Available`: The EIP is available.', example='InUse'),
    }
  ](name='EipList', description='The EIPs.'),
  pageResult?: {
    pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
    totalCount?: int32(name='TotalCount', description='The number of entries returned.', example='10'),
  }(name='PageResult', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model DescribeEipResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEipResourcesResponseBody(name='body'),
}

async function describeEipResources(request: DescribeEipResourcesRequest): DescribeEipResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEipResources', 'POST', '/', 'json', true, 'form', request);
}

model DescribeGatewaySecretDetailsRequest {
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
}

model DescribeGatewaySecretDetailsResponseBody = {
  gatewaySecretDetails?: [ 
    {
      expiredTime?: string(name='ExpiredTime', description='The time when the certificate expires.', example='2023-03-03 07:45'),
      gatewayName?: string(name='GatewayName', description='The name of the gateway.', example='bookinfo-gateway'),
      issueTime?: string(name='IssueTime', description='The time when the certificate was issued.', example='2022-03-03 07:45'),
      message?: string(name='Message', description='*   An error message is returned if the status of the gateway is abnormal. Examples: `tls.crt not exist`, `tls.key not exist`, and `secret type must be kubernetes.io/tls`.
*   An empty value is returned if the status of the gateway is normal.', example='tls.crt not exist'),
      SNI?: string(name='SNI', description='The Server Name Indication (SNI) value.', example='demo.com'),
      secretName?: string(name='SecretName', description='The name of the secret.', example='demo-secret'),
      state?: string(name='State', description='The status of the certificate. Valid values:

*   `normal`
*   `abnormal`', example='normal'),
    }
  ](name='GatewaySecretDetails', description='The detailed information about the secret of the ASM gateway.'),
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeGatewaySecretDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGatewaySecretDetailsResponseBody(name='body'),
}

async function describeGatewaySecretDetails(request: DescribeGatewaySecretDetailsRequest): DescribeGatewaySecretDetailsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGatewaySecretDetails', 'POST', '/', 'json', true, 'form', request);
}

model DescribeGuestClusterAccessLogDashboardsRequest {
  k8sClusterId: string(name='K8sClusterId', description='The ID of the cluster on the data plane.', example='ce3c25e247da24f3aab9b7edfae83****', position='Body'),
}

model DescribeGuestClusterAccessLogDashboardsResponseBody = {
  dashboards?: [ 
    {
      title?: string(name='Title', description='The title of the dashboard.', example='test'),
      url?: string(name='Url', description='The URL of a dashboard.', example='test.com'),
    }
  ](name='Dashboards', description='The access log dashboards of the cluster on the data plane.'),
  k8sClusterId?: string(name='K8sClusterId', description='The ID of the cluster on the data plane.', example='ce3c25e247da24f3aab9b7edfae83****'),
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model DescribeGuestClusterAccessLogDashboardsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGuestClusterAccessLogDashboardsResponseBody(name='body'),
}

async function describeGuestClusterAccessLogDashboards(request: DescribeGuestClusterAccessLogDashboardsRequest): DescribeGuestClusterAccessLogDashboardsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGuestClusterAccessLogDashboards', 'POST', '/', 'json', true, 'form', request);
}

model DescribeGuestClusterNamespacesRequest {
  guestClusterID: string(name='GuestClusterID', description='The ID of the Kubernetes cluster that is added to the ASM instance.', example='c584d805c7bd442b8bac421f9849f****', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='ce134b0727aa2492db69f6c3880e****', position='Body'),
  showNsLabels?: boolean(name='ShowNsLabels', description='Specifies whether to return the labels of the namespaces.', example='true', position='Body'),
}

model DescribeGuestClusterNamespacesResponseBody = {
  nsLabels?: map[string]any(name='NsLabels', description='The labels of the namespaces. Labels are returned only when `ShowNsLabels` is set to `true`.', example='{"default":{"istio-injection":"enabled"}}'),
  nsList?: [ string ](name='NsList', description='The names of the namespaces.'),
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeGuestClusterNamespacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGuestClusterNamespacesResponseBody(name='body'),
}

async function describeGuestClusterNamespaces(request: DescribeGuestClusterNamespacesRequest): DescribeGuestClusterNamespacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGuestClusterNamespaces', 'POST', '/', 'json', true, 'form', request);
}

model DescribeGuestClusterPodsRequest {
  guestClusterID: string(name='GuestClusterID', description='The ID of the Kubernetes cluster that is added to the ASM instance.', example='c49ad2169d5a04f2d89dfc4b6bcu****', position='Body'),
  namespace: string(name='Namespace', description='The namespace.', example='default', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c78d60f98fa43403ab6e0701b2678****', position='Body'),
}

model DescribeGuestClusterPodsResponseBody = {
  podList?: [ string ](name='PodList', description='The list of the names of the queried pods.'),
  requestId?: string(name='RequestId', description='The request ID.', example='EDDC0D86-2FC3-56FB-9213-96EB0A3523F1'),
}

model DescribeGuestClusterPodsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGuestClusterPodsResponseBody(name='body'),
}

async function describeGuestClusterPods(request: DescribeGuestClusterPodsRequest): DescribeGuestClusterPodsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGuestClusterPods', 'POST', '/', 'json', true, 'form', request);
}

model DescribeImportedServicesDetailRequest {
  ASMGatewayName?: string(name='ASMGatewayName', description='The name of the ASM gateway.', example='ingressgateway', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='cb8963379255149cb98c8686f274x****', position='Body'),
  serviceNamespace?: string(name='ServiceNamespace', description='The namespace in which the services reside.', example='default', position='Body'),
}

model DescribeImportedServicesDetailResponseBody = {
  details?: [ 
    {
      clusterIds?: [ string ](name='ClusterIds', description='The clusters on the data plane.'),
      labels?: map[string]string(name='Labels', description='The labels of the service.'),
      namespace?: string(name='Namespace', description='The namespace in which the service resides.', example='default'),
      ports?: [ 
        {
          name?: string(name='Name', description='The name of a port.', example='http-0'),
          nodePort?: int32(name='NodePort', description='The node port.', example='12345'),
          port?: int32(name='Port', description='The port number.', example='80'),
          protocol?: string(name='Protocol', description='The protocol of the port.', example='tcp'),
          targetPort?: int32(name='TargetPort', description='The container port.', example='8080'),
        }
      ](name='Ports', description='The ports declared for the service.'),
      serviceName?: string(name='ServiceName', description='The name of a service.', example='productpage'),
      serviceType?: string(name='ServiceType', description='The type of the service.', example='Kubernetes'),
    }
  ](name='Details', description='The details of the services.'),
  requestId?: string(name='RequestId', description='The request ID.', example='E0496204-7586-5B4C-B364-2361CC0EDxxxx'),
}

model DescribeImportedServicesDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImportedServicesDetailResponseBody(name='body'),
}

async function describeImportedServicesDetail(request: DescribeImportedServicesDetailRequest): DescribeImportedServicesDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImportedServicesDetail', 'POST', '/', 'json', true, 'form', request);
}

model DescribeIstioGatewayDomainsRequest {
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway', position='Body'),
  limit?: string(name='Limit', description='The maximum number of Istio gateways to query.', example='10', position='Body'),
  namespace?: string(name='Namespace', description='The namespace in which the ASM gateway resides.', example='default', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
}

model DescribeIstioGatewayDomainsResponseBody = {
  gatewaySecretDetails?: [ 
    {
      credentialName?: string(name='CredentialName', description='The name of the secret that contains the Transport Layer Security (TLS) certificate and certificate authority (CA) certificate.', example='bookinfo-secret'),
      detail?: string(name='Detail', description='The details of the domain name in the JSON format.', example='{   "servers": [     {       "port": {         "number": 27018,         "name": "mongo",         "protocol": "MONGO"       },       "hosts": [         "*"       ]     }   ] }'),
      domains?: [ string ](name='Domains', description='The list of domain names.'),
      gatewayCRName?: string(name='GatewayCRName', description='The name of the Istio gateway.', example='ingressgateway'),
      namespace?: string(name='Namespace', description='The namespace in which the ASM gateway resides.', example='default'),
      portName?: string(name='PortName', description='The port name.', example='https-demo'),
      protocol?: string(name='Protocol', description='The type of the protocol. Valid values: `HTTP`, `HTTPS`, `GRPC`, `HTTP2`, `MONGO`, `TCP`, and `TLS`.', example='HTTPS'),
    }
  ](name='GatewaySecretDetails', description='The domain names that are exposed by the ASM gateway.'),
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeIstioGatewayDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIstioGatewayDomainsResponseBody(name='body'),
}

async function describeIstioGatewayDomains(request: DescribeIstioGatewayDomainsRequest): DescribeIstioGatewayDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIstioGatewayDomains', 'POST', '/', 'json', true, 'form', request);
}

model DescribeIstioGatewayRouteDetailRequest {
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway', position='Body'),
  routeName?: string(name='RouteName', description='The name of the routing rule.', example='demo-route', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
}

model DescribeIstioGatewayRouteDetailResponseBody = {
  description?: string(name='Description', description='The description of the routing rule.', example='demo route'),
  namespace?: string(name='Namespace', description='The namespace.', example='default'),
  priority?: int32(name='Priority', description='The priority of the routing rule. The value of this parameter is an integer. A smaller value indicates a higher priority.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
  routeDetail?: {
    domains?: [ string ](name='Domains'),
    HTTPAdvancedOptions?: {
      delegate?: {
        name?: string(name='Name', description='The name of the virtual service.', example='reviews'),
        namespace?: string(name='Namespace', description='The namespace to which the virtual service belongs.', example='default'),
      }(name='Delegate', description='The virtual service that defines traffic routing.'),
      fault?: {
        abort?: {
          httpStatus?: int32(name='HttpStatus', description='The HTTP status code.', example='400'),
          percentage?: {
            value?: float(name='Value', description='The percentage of requests that are mirrored to another destination except for the original destination, which is expressed as a decimal.', example='0.1'),
          }(name='Percentage', description='The percentage of requests that are aborted with the specified error code.'),
        }(name='Abort', description='The configurations for aborting requests with specified error codes.'),
        delay?: {
          exponentialDelay?: string(name='ExponentialDelay', description='The duration for request delay is expressed as 2 raised to the power of x. You must specify the value of x.', example='3'),
          fixedDelay?: string(name='FixedDelay', description='The fixed duration for request delay.', example='5s'),
          percentage?: {
            value?: float(name='Value', description='The percentage of requests that are aborted with the specified error code, which is expressed as a decimal.', example='0.1'),
          }(name='Percentage', description='The percentage of requests to which the delay fault is injected.'),
        }(name='Delay', description='The duration to delay a request.'),
      }(name='Fault', description='The configurations of fault injection.'),
      HTTPRedirect?: {
        authority?: string(name='Authority', description='The value to be used to overwrite the value of the Authority or Host header during redirection.', example='newratings.default.svc.cluster.local'),
        redirectCode?: int32(name='RedirectCode', description='The HTTP status code to be used to indicate URL redirection. Default value: 301.', example='301'),
        uri?: string(name='Uri', description='The value to be used to overwrite the URL path during redirection.', example='/v1/getProductRatings'),
      }(name='HTTPRedirect', description='The HTTP redirection rule.'),
      mirror?: {
        host?: string(name='Host', description='The name of the service defined in the service registry.', example='reviews.default.svc.cluster.local'),
        subset?: string(name='Subset', description='The name of the service subset.', example='v1'),
      }(name='Mirror', description='The configurations for mirroring HTTP traffic to another destination in addition to forwarding requests to the specified destination.'),
      mirrorPercentage?: {
        value?: float(name='Value', description='The percentage of requests that are aborted with the specified error code, which is expressed as a decimal.', example='0.2'),
      }(name='MirrorPercentage', description='The percentage of requests that are aborted with the specified error code.'),
      retries?: {
        attempts?: int32(name='Attempts', description='The number of retries that are allowed for a request.', example='3'),
        perTryTimeout?: string(name='PerTryTimeout', description='The timeout period for each retry.', example='2s'),
        retryOn?: string(name='RetryOn', description='The condition for retries. Example: `connect-failure,refused-stream,503`.', example='connect-failure,refused-stream,503'),
        retryRemoteLocalities?: {
          value?: boolean(name='Value', description='Specifies whether to allow retries to other localities. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
        }(name='RetryRemoteLocalities', description='Specifies whether to allow retries to other localities.'),
      }(name='Retries', description='The configurations of retries for failed requests.'),
      rewrite?: {
        authority?: string(name='Authority', description='The value to be used to overwrite the value of the Authority or Host header.', example='newratings.default.svc.cluster.local'),
        uri?: string(name='Uri', description='The value to be used to overwrite the path or prefix of the URI.', example='/v1/getProductRatings'),
      }(name='Rewrite', description='The configurations for rewriting the virtual service.'),
      timeout?: string(name='Timeout', description='The timeout period for requests.', example='5s'),
    }(name='HTTPAdvancedOptions', description='The advanced settings for routing HTTP traffic.'),
    hasUnsafeFeatures?: boolean(name='HasUnsafeFeatures', description='If the value is true, the original YAML file contains features that are not supported on the current interface.', example='true'),
    matchRequest?: {
      headers?: [ 
        {
          matchingContent?: string(name='MatchingContent', description='The header value to be matched.', example='v1'),
          matchingMode?: string(name='MatchingMode', description='The matching mode for the header value. Valid values:

*   `exact`: exact match
*   `prefix`: match by prefix
*   `regex`: match by regular expression', example='exact'),
          name?: string(name='Name', description='The header key to be matched.', example='x-request-id'),
        }
      ](name='Headers', description='The request headers to be matched.'),
      ports?: [ int32 ](name='Ports', description='The ports.'),
      TLSMatchAttributes?: [ 
        {
          SNIHosts?: [ string ](name='SNIHosts', description='The Server Name Indication (SNI) values to be matched.'),
          TLSPort?: int32(name='TLSPort', description='The TLS port.', example='443'),
        }
      ](name='TLSMatchAttributes', description='The matching rules for Transport Layer Security (TLS) traffic.'),
      URI?: {
        matchingContent?: string(name='MatchingContent', description='The content to be matched.', example='/ratings/v2/'),
        matchingMode?: string(name='MatchingMode', description='The matching mode. Valid values:

*   `exact`: exact match
*   `prefix`: match by prefix
*   `regex`: match by regular expression', example='prefix'),
      }(name='URI', description='The matching rule for URIs.'),
    }(name='MatchRequest', description='The matching rules for traffic routing.'),
    rawVSRoute?: string(name='RawVSRoute', description='The original YAML file of the virtual service that is serialized into a JSON string.', example='{}'),
    routeDestinations?: [ 
      {
        destination?: {
          host?: string(name='Host', description='The name of the service defined in the service registry.', example='reviews'),
          port?: {
            number?: int32(name='Number', description='The ports of the specified hosts to which the traffic is routed.', example='443'),
          }(name='Port', description='The ports of the specified hosts from which the traffic is routed.'),
          subset?: string(name='Subset', description='The name of the service subset.', example='v1'),
        }(name='Destination', description='The unique endpoint of the destination service to which the specified requests are sent.'),
        headers?: {
          request?: {
            add?: map[string]any(name='Add', description='The values to be added to the header key.', example='key'),
            remove?: [ string ](name='Remove', description='The header value to be deleted.'),
            set?: map[string]string(name='Set', description='The header key to be used to overwrite the original header key.'),
          }(name='Request', description='The request header to be matched.'),
          response?: {
            add?: map[string]any(name='Add', description='The values to be added to the header key.', example='key'),
            remove?: [ string ](name='Remove', description='The header value to be deleted.'),
            set?: map[string]any(name='Set', description='The header key to be used to overwrite the original header key.', example='key'),
          }(name='Response', description='The processing of the headers of the response that is to be returned.'),
        }(name='Headers', description='The list of the request headers to be matched.'),
        weight?: int32(name='Weight', description='The traffic weight. Valid values: 1 to 100.', example='80'),
      }
    ](name='RouteDestinations', description='The endpoints of destination services for Layer 4 weighted routing.'),
    routeName?: string(name='RouteName', description='The name of the routing rule.', example='demo-route'),
    routeType?: string(name='RouteType', description='The type of the traffic to be routed. Valid values: `HTTP`, `TLS`, and `TCP`.', example='HTTP'),
  }(name='RouteDetail', description='The detailed information about the routing rule.'),
  status?: int32(name='Status', description='The status of the routing rule. Valid values:

*   `0`: The routing rule is valid.
*   `1`: The routing rule is invalid.
*   `2`: An error occurs during the creation or update of the routing rule.', example='1'),
}

model DescribeIstioGatewayRouteDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIstioGatewayRouteDetailResponseBody(name='body'),
}

async function describeIstioGatewayRouteDetail(request: DescribeIstioGatewayRouteDetailRequest): DescribeIstioGatewayRouteDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIstioGatewayRouteDetail', 'POST', '/', 'json', true, 'form', request);
}

model DescribeIstioGatewayRoutesRequest {
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
}

model DescribeIstioGatewayRoutesResponseBody = {
  managementRoutes?: [ 
    {
      ASMGatewayName?: string(name='ASMGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
      description?: string(name='Description', description='The description of the routing rule.', example='demo route'),
      destinationHost?: [ string ](name='DestinationHost', description='Destination hosts list.'),
      destinationSubSet?: [ string ](name='DestinationSubSet', description='Destination subset list.'),
      namespace?: string(name='Namespace', description='The namespace.', example='istio-demo'),
      priority?: int32(name='Priority', description='The priority of the routing rule. The value of this parameter is an integer. A smaller value indicates a higher priority.', example='1'),
      routeName?: string(name='RouteName', description='The name of the routing rule.', example='http-route'),
      routePath?: string(name='RoutePath', description='The path that is used to match request URLs.', example='/reviews/v1'),
      status?: int32(name='Status', description='The status of the routing rule. Valid values:

*   `0`: The routing rule is valid.
*   `1`: The routing rule is invalid.
*   `2`: An error occurs during the creation or update of the routing rule.', example='1'),
    }
  ](name='ManagementRoutes', description='The routing rules.'),
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeIstioGatewayRoutesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIstioGatewayRoutesResponseBody(name='body'),
}

async function describeIstioGatewayRoutes(request: DescribeIstioGatewayRoutesRequest): DescribeIstioGatewayRoutesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIstioGatewayRoutes', 'POST', '/', 'json', true, 'form', request);
}

model DescribeMetadataRequest {
}

model DescribeMetadataResponseBody = {
  metaData?: {
    currentVersion?: string(name='CurrentVersion', description='The current version.', example='v1.14.3.87-g96cf7305-aliyun'),
    proEdition?: {
      currentVersion?: string(name='CurrentVersion', description='The current version.', example='v1.14.3.87-g96cf7305-aliyun'),
      versionCrds?: [  map[string]any ](name='VersionCrds', description='The CRDs of all ASM versions.'),
      versionRegistry?: [  map[string]any ](name='VersionRegistry', description='The Istio versions corresponding to the ASM versions.'),
      versions?: [ string ](name='Versions', description='The list of ASM versions.'),
    }(name='ProEdition', description='The version information about ASM of a commercial edition.'),
    regions?: [ string ](name='Regions', description='The regions where ASM instances can be created.'),
    versionCrds?: [  map[string]any ](name='VersionCrds', description='The custom resource definitions (CRDs) of all ASM versions.'),
    versionRegistry?: [  map[string]any ](name='VersionRegistry', description='The Istio versions corresponding to the ASM versions.'),
    versions?: [ string ](name='Versions', description='The list of ASM versions.'),
  }(name='MetaData', description='The metadata of ASM, which contains basic information about ASM.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F93DDAD7-6E04-5AC3-86F4-852708******'),
}

model DescribeMetadataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMetadataResponseBody(name='body'),
}

async function describeMetadata(request: DescribeMetadataRequest): DescribeMetadataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMetadata', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNamespaceScopeSidecarConfigRequest {
  namespace?: string(name='Namespace', description='The namespace.', example='default', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c7120e75a202d4fd8acb028a86b6a****', position='Body'),
}

model DescribeNamespaceScopeSidecarConfigResponseBody = {
  configPatches?: {
    concurrency?: int32(name='Concurrency', description='The number of worker threads to run in the istio-proxy container.', example='2'),
    enableCoreDump?: boolean(name='EnableCoreDump'),
    excludeInboundPorts?: string(name='ExcludeInboundPorts', description='The inbound ports to be excluded from redirection to the sidecar proxy in the ASM instance.', example='82'),
    excludeOutboundIPRanges?: string(name='ExcludeOutboundIPRanges', description='The outbound IP ranges in CIDR form to be excluded from redirection to the sidecar proxy in the ASM instance.', example='192.168.1.3/31'),
    excludeOutboundPorts?: string(name='ExcludeOutboundPorts', description='The outbound ports to be excluded from redirection to the sidecar proxy in the ASM instance.', example='81'),
    holdApplicationUntilProxyStarts?: boolean(name='HoldApplicationUntilProxyStarts', description='Indicates whether applications can be started only after the istio-proxy container starts. Valid values:

*   `true`
*   false', example='true'),
    includeInboundPorts?: string(name='IncludeInboundPorts', description='The inbound ports for which traffic is to be redirected to the sidecar proxy in the ASM instance.', example='83'),
    includeOutboundIPRanges?: string(name='IncludeOutboundIPRanges', description='The outbound IP ranges in CIDR form for which traffic is to be redirected to the sidecar proxy in the ASM instance.', example='192.168.1.4/31'),
    includeOutboundPorts?: string(name='IncludeOutboundPorts', description='The outbound ports for which traffic is to be redirected to the sidecar proxy in the ASM instance.', example='84'),
    interceptionMode?: string(name='InterceptionMode', description='The mode in which the sidecar proxy intercepts inbound traffic. Valid values:

*   `REDIRECT` (default): In this mode, source IP addresses are lost during traffic redirection to the sidecar proxy.
*   `TPROXY`: In this mode, both the source and destination IP addresses and ports are preserved.', example='TPROXY'),
    istioDNSProxyEnabled?: boolean(name='IstioDNSProxyEnabled', description='Indicates whether the Domain Name System (DNS) proxy feature is enabled. Valid values:

*   `true`
*   `false`', example='true'),
    lifecycleStr?: string(name='LifecycleStr', description='The JSON string that describes the lifecycle of the sidecar proxy.', example='{"postStart":{"exec":{"command":["pilot-agent","wait"]}},"preStop":{"exec":{"command":["/bin/sh","-c","sleep 15"]}}}'),
    logLevel?: string(name='LogLevel', description='The log level. Valid values: `info`, `debug`, `trace`, and `error`.', example='info'),
    privileged?: boolean(name='Privileged'),
    proxyMetadata?: map[string]string(name='ProxyMetadata'),
    proxyStatsMatcher?: {
      inclusionPrefixes?: [ string ](name='InclusionPrefixes', description='The prefixes of the custom Envoy statistics that are reported by the sidecar proxy.'),
      inclusionRegexps?: [ string ](name='InclusionRegexps', description='The regular expressions for specifying the custom Envoy statistics that are reported by the sidecar proxy.'),
      inclusionSuffixes?: [ string ](name='InclusionSuffixes', description='The suffixes of the custom Envoy statistics that are reported by the sidecar proxy.'),
    }(name='ProxyStatsMatcher', description='The custom Envoy statistics that are reported by the sidecar proxy.'),
    readinessFailureThreshold?: int32(name='ReadinessFailureThreshold'),
    readinessInitialDelaySeconds?: int32(name='ReadinessInitialDelaySeconds'),
    readinessPeriodSeconds?: int32(name='ReadinessPeriodSeconds'),
    sidecarProxyAckSloResource?: {
      limits?: map[string]string(name='Limits'),
      requests?: map[string]string(name='Requests'),
    }(name='SidecarProxyAckSloResource'),
    sidecarProxyInitAckSloResource?: {
      limits?: map[string]string(name='Limits'),
      requests?: map[string]string(name='Requests'),
    }(name='SidecarProxyInitAckSloResource'),
    sidecarProxyInitResourceLimit?: {
      resourceCPULimit?: string(name='ResourceCPULimit', description='The maximum number of CPU cores.', example='2000 m'),
      resourceMemoryLimit?: string(name='ResourceMemoryLimit', description='The maximum size of the memory.', example='50 Mi'),
    }(name='SidecarProxyInitResourceLimit', description='The maximum size of resources that are available to the istio-init container in the pod into which the sidecar proxy is injected. The istio-init container is used in this topic.'),
    sidecarProxyInitResourceRequest?: {
      resourceCPURequest?: string(name='ResourceCPURequest', description='The minimum number of CPU cores.', example='60 m'),
      resourceMemoryRequest?: string(name='ResourceMemoryRequest', description='The minimum size of the memory.', example='30 Mi'),
    }(name='SidecarProxyInitResourceRequest', description='The minimum size of resources that are required by the istio-init container.'),
    sidecarProxyResourceLimit?: {
      resourceCPULimit?: string(name='ResourceCPULimit', description='The maximum number of CPU cores.', example='2000 m'),
      resourceMemoryLimit?: string(name='ResourceMemoryLimit', description='The maximum size of the memory.', example='50 Mi'),
    }(name='SidecarProxyResourceLimit', description='The maximum size of resources that are available to the sidecar proxy container.'),
    sidecarProxyResourceRequest?: {
      resourceCPURequest?: string(name='ResourceCPURequest', description='The minimum number of CPU cores.', example='60 m'),
      resourceMemoryRequest?: string(name='ResourceMemoryRequest', description='The minimum size of the memory.', example='30 Mi'),
    }(name='SidecarProxyResourceRequest', description='The minimum size of resources that are required by the sidecar proxy container.'),
    terminationDrainDuration?: string(name='TerminationDrainDuration', description='The maximum period of time allowed for connections to complete on sidecar proxy shutdown.', example='6s'),
    tracing?: {
      customTags?: map[string]any(name='CustomTags', description='The custom tags added to reported spans. The key of a tag is of the string type. The value of a tag is in the JSON format. A custom tag can belong to one of the following types:

*   `literal`: The tag value is a fixed value in the JSON format. This tag must contain the `value` field that specifies a literal. Example: `{"value":"test"}`.
*   `header`: The tag value is a request header in the JSON format. This tag must contain the `name` field and the `defaultValue` field. The name field indicates the name of the request header. The defaultValue field indicates the default value that is used when no request header is available. Example: `{"name":"test","defaultValue":"test"}`.
*   `environment`: The tag value is an environment variable in the JSON format. This tag must contain the `name` field and the `defaultValue` field. The name field indicates the name of the environment variable. The defaultValue field indicates the environment variable that is used when no environment variable is available. Example: `{"name":"test","defaultValue":"test"}`.', example='{"test":{"literal":{"value":"test"}}}'),
      maxPathTagLength?: int32(name='MaxPathTagLength', description='The maximum tag length.', example='10'),
      sampling?: double(name='Sampling', description='The sampling rate.', example='99.8'),
    }(name='Tracing', description='The custom configurations of Tracing Analysis.'),
  }(name='ConfigPatches', description='The namespace-level sidecar proxy configurations.'),
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeNamespaceScopeSidecarConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNamespaceScopeSidecarConfigResponseBody(name='body'),
}

async function describeNamespaceScopeSidecarConfig(request: DescribeNamespaceScopeSidecarConfigRequest): DescribeNamespaceScopeSidecarConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNamespaceScopeSidecarConfig', 'POST', '/', 'json', true, 'form', request);
}

model DescribeNodesInstanceTypeRequest {
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the Alibaba Cloud Service Mesh (ASM) instance.', example='cb8963379255149cb98c8686f274x****', position='Body'),
}

model DescribeNodesInstanceTypeResponseBody = {
  instanceTypes?: [ 
    {
      key?: string(name='Key', example='feature.node.kubernetes.io/mb-feature-enable'),
      multiBufferEnabled?: boolean(name='MultiBufferEnabled', description='Indicates whether the instance type supports Multi-Buffer acceleration. Valid values:

*   `true`
*   `false`', example='true'),
      nodeType?: string(name='NodeType', description='The instance type of the node.', example='ecs.g7.xlarge'),
      value?: string(name='Value', example='true'),
    }
  ](name='InstanceTypes', description='The instance types of the nodes.'),
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model DescribeNodesInstanceTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNodesInstanceTypeResponseBody(name='body'),
}

async function describeNodesInstanceType(request: DescribeNodesInstanceTypeRequest): DescribeNodesInstanceTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNodesInstanceType', 'POST', '/', 'json', true, 'form', request);
}

model DescribeReusableSlbRequest {
  k8sClusterId: string(name='K8sClusterId', description='The ID of the Kubernetes cluster on the data plane.', example='ca2cfe41fefeb489d9b9dba18a7c5****', position='Body'),
  networkType: string(name='NetworkType', description='The network type of the SLB instance. Valid values:

*   `intranet`
*   `internet`', example='internet', position='Body'),
}

model DescribeReusableSlbResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EDDC0D86-2FC3-56FB-9213-96EB0A3523F1'),
  reusableSlbList?: [ 
    {
      loadBalancerId?: string(name='LoadBalancerId', description='The ID of the SLB instance.', example='lb-bp17xygzsxth0bwlz****'),
      loadBalancerName?: string(name='LoadBalancerName', description='The name of the SLB instance.', example='ad6044b015ac54484a20c47241175bb3'),
    }
  ](name='ReusableSlbList', description='The list of SLB instances that can be reused.'),
}

model DescribeReusableSlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeReusableSlbResponseBody(name='body'),
}

async function describeReusableSlb(request: DescribeReusableSlbRequest): DescribeReusableSlbResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeReusableSlb', 'POST', '/', 'json', true, 'form', request);
}

model DescribeServiceMeshAdditionalStatusRequest {
  checkMode?: string(name='CheckMode', description='The check mode of the ASM instance. Valid values:

*   `normal`: checks the Server Load Balancer (SLB) instances created for exposing the API server and Istio Pilot, audit logs, and installation of Logtail for clusters on the data plane.
*   `full`: checks control plane logs, access logs, security groups, and the elastic IP addresses (EIPs) of the API server in addition to the check items in normal mode.', example='full', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='ca04bc38979214bf2882be79d39b4****', position='Body'),
}

model DescribeServiceMeshAdditionalStatusResponseBody = {
  clusterStatus?: {
    accessLogProjectStatus?: string(name='AccessLogProjectStatus', description='Indicates whether access logs exist. Valid values:

*   `exist`: Access logs exist.
*   `not_exist`: Access logs do not exist.
*   `failed`: The check fails.
*   `time_out`: The check times out.', example='exist'),
    apiServerEIPStatus?: string(name='ApiServerEIPStatus', description='The check result of the EIP associated with the API server. Valid values:

*   `exist`: The EIP exists.
*   `not_exist`: The EIP does not exist.
*   `failed`: The check fails.
*   `time_out`: The check times out.
*   `not_in_use`: The EIP is not associated with the API Server.
*   `locked`: The EIP is locked.', example='exist'),
    apiServerLoadBalancerStatus?: {
      locked?: boolean(name='Locked', description='Indicates whether the SLB instance is locked. Valid values:

*   `true`
*   `false`', example='false'),
      payType?: string(name='PayType', description='The billing method of the SLB instance. Valid values:

*   `PrePay`: subscription
*   `PayOnDemand`: pay-as-you-go', example='PrePay'),
      reused?: boolean(name='Reused', description='Indicates whether the SLB instance is reused. Valid values:

*   `true`
*   `false`', example='false'),
      SLBBackEndServerNumStatus?: string(name='SLBBackEndServerNumStatus', description='The check result of the number of backend servers of the SLB instance created for exposing the API server. Valid values:

*   `too_much`: An excessive number of backend servers are created.
*   `num_exact`: A proper number of backend servers are created.
*   `too_little`: The number of backend servers falls short.', example='num_exact'),
      SLBExistStatus?: string(name='SLBExistStatus', description='The check result of the SLB instance. Valid values:

*   `exist`: The SLB instance exists.
*   `not_exist`: The SLB instance does not exist.
*   `conflict`: Conflicts are detected.
*   `failed`: The check fails.
*   `time_out`: The check times out.', example='exist'),
    }(name='ApiServerLoadBalancerStatus', description='The check results of the SLB instance created for exposing the API server.'),
    auditProjectStatus?: string(name='AuditProjectStatus', description='Indicates whether audit logs exist. Valid values:

*   `exist`
*   `not exist`', example='exist'),
    canaryPilotLoadBalancerStatus?: {
      locked?: boolean(name='Locked', description='Indicates whether the SLB instance is locked due to overdue payments. Valid values: `true` `false`', example='false'),
      payType?: string(name='PayType', example='PayOnDemand'),
      reused?: boolean(name='Reused', description='Indicates whether the SLB instance is reused. Valid values:

*   `true`: The SLB instance is reused. Non-ASM listener configuration is detected in the listener configurations of the SLB instance.
*   `false`: The SLB instance is not reused.', example='false'),
      SLBBackEndServerNumStatus?: string(name='SLBBackEndServerNumStatus', description='The check result of the number of backend servers of the SLB instance created for exposing Istio Pilot. Valid values:

*   `num_exact`: A proper number of backend servers are created.
*   `too_much`: An excessive number of backend servers are created.
*   `too_little`: The number of backend servers falls short.', example='num_exact'),
      SLBExistStatus?: string(name='SLBExistStatus', description='The check result of the SLB instance. Valid values:

*   `exist`: The SLB instance exists.
*   `not_exist`: The SLB instance does not exist.
*   `time_out`: The check times out.
*   `failed`: The SLB instance has expired.', example='exist'),
    }(name='CanaryPilotLoadBalancerStatus', description='The check results of the SLB instance that is created for exposing Istio Pilot and used during canary release.'),
    controlPlaneProjectStatus?: string(name='ControlPlaneProjectStatus', description='Indicates whether control plane logs exist. Valid values:

*   `exist`: Control plane logs exist.
*   `not_exist`: Control plane logs do not exist.
*   `failed`: The check fails.
*   `time_out`: The check times out.', example='exist'),
    logtailStatusRecord?: map[string]any(name='LogtailStatusRecord', description='Indicates whether Logtail is installed in clusters on the data plane.', example='{   "ca35eae22013e43758a0e26d04****":{     "accessLogDashboards":[       {         "title":"mesh-access-log_details_cn",         "url":"https://sls.console.aliyun.com/lognext/project/****/dashboard/mesh-access-log_details_cn"       },       {         "title":"mesh-access-log_monitoring_center_cn",         "url":"https://sls.console.aliyun.com/lognext/project/****/dashboard/mesh-access-log_monitoring_center_cn"       }     ],     "logtailStatus":"exist",     "clusterId":"ca35eae22013e43758a0e26d04****"   } }'),
    pilotLoadBalancerStatus?: {
      locked?: boolean(name='Locked', description='Indicates whether the SLB instance is locked. Valid values:

*   `true`
*   `false`', example='false'),
      payType?: string(name='PayType', description='The billing method of the SLB instance. Valid values:

*   `PrePay`: subscription
*   `PayOnDemand`: pay-as-you-go', example='PayOnDemand'),
      reused?: boolean(name='Reused', description='Indicates whether the SLB instance is reused. Valid values:

*   `true`
*   `false`', example='true'),
      SLBBackEndServerNumStatus?: string(name='SLBBackEndServerNumStatus', description='The check result of the number of backend servers of the SLB instance created for exposing Istio Pilot. Valid values:

*   `too_much`: An excessive number of backend servers are created.
*   `num_exact`: A proper number of backend servers are created.
*   `too_little`: The number of backend servers falls short.', example='num_exact'),
      SLBExistStatus?: string(name='SLBExistStatus', description='The check result of the SLB instance. Valid values:

*   `exist`: The SLB instance exists.
*   `not_exist`: The SLB instance does not exist.
*   `conflict`: Conflicts are detected.
*   `failed`: The check fails.
*   `time_out`: The check times out.', example='exist'),
    }(name='PilotLoadBalancerStatus', description='The check results of the SLB instance created for exposing Istio Pilot.'),
    RAMApplicationStatus?: string(name='RAMApplicationStatus', description='The status of the RAM OAuth application that is integrated with Mesh Topology. Valid values:

*   `exist`: The RAM OAuth application exists.
*   `reused`: The RAM OAuth application is reused.
*   `not_exist`: The RAM OAuth application does not exist.
*   `failed`: The check fails.
*   `time_out`: The check times out.', example='reused'),
    sgStatus?: string(name='SgStatus', description='Indicates whether the security group is reused. Valid values:

*   `reused`: The security group is reused.
*   `not_reused`: The security group is not reused.
*   `failed`: The check fails.
*   `time_out`: The check times out.', example='reused'),
  }(name='ClusterStatus', description='The status of the cluster.'),
  requestId?: string(name='RequestId', description='The request ID.', example='11fd0027-c27e-41bb-a565-75583054****'),
}

model DescribeServiceMeshAdditionalStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshAdditionalStatusResponseBody(name='body'),
}

async function describeServiceMeshAdditionalStatus(request: DescribeServiceMeshAdditionalStatusRequest): DescribeServiceMeshAdditionalStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeServiceMeshAdditionalStatus', 'POST', '/', 'json', true, 'form', request);
}

model DescribeServiceMeshClustersRequest {
  limit?: long(name='Limit', description='The maximum number of entries per page.', example='30', position='Body'),
  offset?: long(name='Offset', description='The position where the query starts.', example='20', position='Body'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='cb8963379255149cb98c8686f274x****', position='Query'),
}

model DescribeServiceMeshClustersResponseBody = {
  clusters?: [ 
    {
      clusterDomain?: string(name='ClusterDomain', description='The domain name of the cluster.', example='c.com'),
      clusterId?: string(name='ClusterId', description='The cluster ID.', example='c80f45444b3da447da60a911390c2****'),
      clusterType?: string(name='ClusterType', description='The cluster type.', example='Ask'),
      creationTime?: string(name='CreationTime', description='The time when the cluster was created.', example='2020-05-12T15:38:16+08:00'),
      errorMessage?: string(name='ErrorMessage', description='The error message about the cluster.', example='fail'),
      forbiddenFlag?: long(name='ForbiddenFlag', description='Indicates that the cluster is available or the reason why the cluster cannot be added to the ASM instance. Valid values:

*   `0`: The cluster can be added to the ASM instance.
*   `1`: The cluster cannot be added to the ASM instance because you do not have administrator permissions on the cluster.
*   `2`: The cluster cannot be added to the ASM instance because the cluster and the ASM instance reside in different VPCs between which no private connections are built.
*   `3`: The CIDR block of the cluster conflicts with that of the ASM instance.
*   `4`: The cluster has a namespace that is named istio-system.', example='0'),
      forbiddenInfo?: string(name='ForbiddenInfo', description='The reason why the cluster on the data plane cannot be added to the ASM instance. The value is a JSON string in the following format:

    [
      {
        "cluster": "cdd55bd6e054b4c6ca18ec02614******",
        "object": "Pod",
        "cidr": "172.16.0.0/24"
      },
      {
        "cluster": "cfa37fdf7cb1641e1976f8293ac******",
        "object": "Pod",
        "cidr": "172.16.0.0/24"
      }
    ]

In the preceding example, the CIDR block `172.16.0.0/24` of the pod in the `cdd55bd6e054b4c6ca18ec02614******` cluster conflicts with the CIDR block `172.16.0.0/24` of the pod in the `cfa37fdf7cb1641e1976f8293ac******` cluster.

Valid values of the `object` parameter:

*   `Pod`
*   `Service`
*   `VSwitch`
*   `VPC`
*   `VPC CIDR`', example='[{"cluster":"cdd55bd6e054b4c6ca18ec02614******", "object":"Pod", "cidr":"172.16.0.0/24"},{"cluster":"cfa37fdf7cb1641e1976f8293ac******", "object":"Pod", "cidr":"172.16.0.0/24"}]'),
      name?: string(name='Name', description='The name of the cluster.', example='ask1'),
      regionId?: string(name='RegionId', description='The ID of the region in which the cluster resides.', example='cn-hangzhou'),
      serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='cb8963379255149cb98c8686f274x****'),
      sgId?: string(name='SgId', description='The ID of the security group.', example='sg-bp197668l6iupljy****'),
      state?: string(name='State', description='The state of the cluster. Valid values:

*   `running`: The cluster is running.
*   `starting`: The cluster is starting.
*   `stopping`: The cluster is being stopped.
*   `stopped`: The cluster is stopped.
*   `failed`: The cluster fails to be run.', example='running'),
      updateTime?: string(name='UpdateTime', description='The time when the cluster was last modified.', example='2020-05-12T15:38:16+08:00'),
      version?: string(name='Version', description='The version number of the cluster.', example='v1.16.6-aliyun.1'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-8vbrwmt95b4zf6wf7****'),
    }
  ](name='Clusters', description='The queried clusters.'),
  numberOfClusters?: long(name='NumberOfClusters', example='5'),
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeServiceMeshClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshClustersResponseBody(name='body'),
}

async function describeServiceMeshClusters(request: DescribeServiceMeshClustersRequest): DescribeServiceMeshClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeServiceMeshClusters', 'POST', '/', 'json', true, 'form', request);
}

model DescribeServiceMeshDetailRequest {
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
}

model DescribeServiceMeshDetailResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='11fd0027-c27e-41bb-a565-75583054****'),
  serviceMesh?: {
    clusterSpec?: string(name='ClusterSpec', description='The specification of the ASM instance. Valid values:

*   `standard`: Standard Edition
*   `enterprise`: Enterprise Edition
*   `ultimate`: Ultimate Edition', example='standard'),
    clusters?: [ string ](name='Clusters', description='The clusters.'),
    endpoints?: {
      intranetApiServerEndpoint?: string(name='IntranetApiServerEndpoint', description='The endpoint that is used to access the API server from the internal network.', example='https://192.168.**.**:6443'),
      intranetPilotEndpoint?: string(name='IntranetPilotEndpoint', description='The endpoint that is used to access Istio Pilot from the internal network.', example='192.168.**.**:15011'),
      publicApiServerEndpoint?: string(name='PublicApiServerEndpoint', description='The endpoint that is used to access the API server over the Internet.', example='https://123.56.**.**:6443'),
      publicPilotEndpoint?: string(name='PublicPilotEndpoint', description='The endpoint that is used to expose Istio Pilot to the Internet.', example='182.92.**.**:15011'),
    }(name='Endpoints', description='The endpoints of the ASM instance.'),
    ownerId?: string(name='OwnerId', description='The ID of the Alibaba Cloud service instance for which the ASM instance is created.', example='cc3e96f249d124eb38b72718ec5*****'),
    ownerType?: string(name='OwnerType', description='The Alibaba Cloud service for which the ASM instance is created. Valid values:

*   `ackone`: The ASM instance is created for Alibaba Cloud Distributed Cloud Container Platform (ACK One).
*   An empty value indicates that the ASM instance is created by the user.', example='ackone'),
    serviceMeshInfo?: {
      creationTime?: string(name='CreationTime', description='The time when the ASM instance was created.', example='2020-04-21T09:42:20+08:00'),
      errorMessage?: string(name='ErrorMessage', description='The returned error message.', example='error'),
      name?: string(name='Name', description='The name of the ASM instance.', example='mesh1'),
      profile?: string(name='Profile', description='The edition of the ASM instance. Valid values:

*   `Default`: Standard Edition
*   `Pro`: Enterprise Edition and Ultimate Edition', example='Default'),
      regionId?: string(name='RegionId', description='The ID of the region in which the ASM instance resides.', example='cn-beijing'),
      serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
      state?: string(name='State', description='The state of the ASM instance.', example='running'),
      updateTime?: string(name='UpdateTime', description='The time when the ASM instance was last modified.', example='2020-06-03T14:48:54+08:00'),
      version?: string(name='Version', description='The version of the ASM instance.', example='v1.7.4.0-gfb34ba99-aliyun'),
    }(name='ServiceMeshInfo', description='The basic information about the ASM instance.'),
    spec?: {
      loadBalancer?: {
        apiServerLoadbalancerId?: string(name='ApiServerLoadbalancerId', description='The ID of the CLB instance that is used when the API server is exposed to the Internet.', example='lb-2zekaak10uxds44vx****'),
        apiServerPublicEip?: boolean(name='ApiServerPublicEip', description='Indicates whether the API server is exposed to the Internet. Valid values:

*   `true`
*   `false`', example='true'),
        pilotPublicEip?: boolean(name='PilotPublicEip', description='Indicates whether Istio Pilot is exposed to the Internet. Valid values:

*   `true`
*   `false`', example='true'),
        pilotPublicLoadbalancerId?: string(name='PilotPublicLoadbalancerId', description='The ID of the Classic Load Balancer (CLB) instance that is used when Istio Pilot is exposed to the Internet.', example='lb-2zesa8qs8kbkj9jkl****'),
      }(name='LoadBalancer', description='The information about load balancing.'),
      meshConfig?: {
        accessLog?: {
          enabled?: boolean(name='Enabled', description='Indicates whether access log collection is enabled. Valid values:

*   `true`
*   `false`', example='true'),
          project?: string(name='Project', description='The name of the Simple Log Service project that stores access logs.', example='k8s-log-b7b05d08670e41ca8c8fc0b7718f*****'),
        }(name='AccessLog', description='The configurations of access log collection.'),
        audit?: {
          auditProjectStatus?: string(name='AuditProjectStatus', description='Indicates whether an audit project exists in the ASM instance. Valid values:

*   `audit_project_exist`: An audit project exists.
*   `audit_project_not_exist`: No audit project exists.', example='audit_project_not_exist'),
          enabled?: boolean(name='Enabled', description='Indicates whether mesh audit is enabled. Valid values:

*   `true`
*   `false`', example='true'),
          project?: string(name='Project', description='The name of the Simple Log Service project that is used for mesh audit.', example='audit-project'),
        }(name='Audit', description='The information about mesh audit.'),
        controlPlaneLogInfo?: {
          enabled?: boolean(name='Enabled', description='Indicates whether the collection of control plane logs is enabled. Valid values:

*   `true`
*   `false`', example='false'),
          logTTL?: int32(name='LogTTL'),
          project?: string(name='Project', description='The name of the Simple Log Service project that stores control plane logs.', example='mesh-log-cbeb85a09161b4a26ab73e0ac****'),
        }(name='ControlPlaneLogInfo', description='The configurations of control plane log collection.'),
        customizedZipkin?: boolean(name='CustomizedZipkin', description='Indicates whether a custom Zipkin system is used. Valid values:

*   `true`
*   `false`', example='false'),
        edition?: {
          istiodImageTag?: string(name='IstiodImageTag', description='The version of the Istiod image.', example='v1.9.7.1-3-gb3f1ab3c9c-pro-aliyun'),
          name?: string(name='Name', description='The name of the edition.', example='Pro'),
          proxyImageTag?: string(name='ProxyImageTag', description='The version of the Istio Proxy image.', example='v1.9.7.1-3-gb3f1ab3c9c-pro-aliyun'),
        }(name='Edition', description='The information about the edition.'),
        enableLocalityLB?: boolean(name='EnableLocalityLB', description='Indicates whether the feature that routes traffic to the nearest instance is enabled. Valid values:

*   `true`
*   `false`', example='true'),
        excludeIPRanges?: string(name='ExcludeIPRanges', description='The IP ranges in CIDR form to be excluded from redirection to sidecar proxies in the ASM instance.', example='172.16.0.0'),
        excludeInboundPorts?: string(name='ExcludeInboundPorts', description='The inbound ports to be excluded from redirection to sidecar proxies in the ASM instance.', example='80,81'),
        excludeOutboundPorts?: string(name='ExcludeOutboundPorts', description='The outbound ports to be excluded from redirection to sidecar proxies in the ASM instance.', example='80,81'),
        extraConfiguration?: {
          accessLogExtraConf?: {
            gatewayEnabled?: boolean(name='GatewayEnabled'),
            gatewayLifecycle?: int32(name='GatewayLifecycle', description='The retention period for the access logs of the ingress gateway. Unit: day. The logs are collected by using Simple Log Service. For example, the value 30 indicates that the logs are retained for 30 days.', example='30'),
            sidecarEnabled?: boolean(name='SidecarEnabled'),
            sidecarLifecycle?: int32(name='SidecarLifecycle', description='The retention period for the access logs of sidecar proxies. Unit: day. The logs are collected by using Simple Log Service. For example, the value 30 indicates that the logs are retained for 30 days.', example='30'),
          }(name='AccessLogExtraConf', description='The configurations of additional features for access log collection.'),
          adaptiveXdsConfiguration?: {
            egressAutoscaleEnabled?: boolean(name='EgressAutoscaleEnabled', description='Indicates whether Horizontal Pod Autoscaling (HPA) is enabled for the egress gateway.', example='true'),
            egressHpaCpu?: {
              targetAverageUtilization?: int32(name='TargetAverageUtilization', description='The expected CPU utilization when HPA is enabled. Valid values: 1 to 100. If the CPU utilization exceeds this value, the number of pod replicas increases. If the CPU utilization is less than this value, the number of pod replicas decreases.', example='80'),
            }(name='EgressHpaCpu', description='The CPU resource configurations of the egress gateway when HPA is enabled.'),
            egressHpaMemory?: {
              targetAverageUtilization?: int32(name='TargetAverageUtilization', description='The expected memory usage when HPA is enabled. Valid values: 1 to 100. If the memory usage exceeds this value, the number of pod replicas increases. If the memory usage is less than this value, the number of pod replicas decreases.', example='80'),
            }(name='EgressHpaMemory', description='The memory resource configurations of the egress gateway when HPA is enabled.'),
            egressMaxReplica?: int32(name='EgressMaxReplica', description='The maximum number of egress gateway pod replicas when HPA is enabled.', example='2'),
            egressMinReplica?: int32(name='EgressMinReplica', description='The minimum number of egress gateway pod replicas when HPA is enabled.', example='1'),
            egressReplicaCount?: int32(name='EgressReplicaCount', description='The number of the egress gateway pod replicas.', example='2'),
            egressResources?: {
              limits?: map[string]any(name='Limits', description='The resources that are available to the egress gateway.', example='{"cpu":"200m", "memory": "512Mi"}'),
              requests?: map[string]any(name='Requests', description='The resources that are requested by the egress gateway.', example='{"cpu":"100m", "memory": "256Mi"}'),
            }(name='EgressResources', description='The resource configurations of the egress gateway that is used by adaptive xDS optimization.'),
            enabled?: boolean(name='Enabled', description='Indicates whether adaptive xDS optimization is enabled.', example='true'),
          }(name='AdaptiveXdsConfiguration', description='The configurations of adaptive xDS optimization.'),
          autoDiagnosis?: {
            autoDiagnosisEnabled?: boolean(name='AutoDiagnosisEnabled', description='Indicates whether automatic diagnostics is enabled for the ASM instance. If you enable this feature, the ASM instance is automatically diagnosed 5 minutes after you modify an Istio resource.', example='true'),
          }(name='AutoDiagnosis', description='The configurations of automatic diagnostics for the ASM instance.'),
          CRAggregationConfiguration?: {
            enabled?: boolean(name='Enabled', description='Indicates whether Istio resources can be accessed by using the Kubernetes API on the data plane.', example='true'),
          }(name='CRAggregationConfiguration', description='Access to Istio resources by using the Kubernetes API on the data plane.'),
          CRAggregationEnabled?: boolean(name='CRAggregationEnabled', description='Indicates whether the Kubernetes API of clusters on the data plane can be used to access Istio resources. Valid values:

*   `true`
*   `false`', example='false'),
          discoverySelectors?: [  map[string]any ](name='DiscoverySelectors', description='The label selectors used to specify the namespaces of the clusters on the data plane. The control plane discovers and processes only application services in the specified namespaces.'),
          istioCRHistory?: {
            enableHistory?: boolean(name='EnableHistory', description='Indicates whether the rollback feature for Istio resources is enabled. Valid values:

*   `true`
*   `false`', example='false'),
          }(name='IstioCRHistory', description='The configurations of the rollback feature for Istio resources.'),
          lifecycle?: {
            postStart?: {
              exec?: {
                command?: [ string ](name='command', description='The executed commands. The value is a string that consists of JSON arrays.'),
              }(name='exec', description='The post-start script.'),
              httpGet?: {
                host?: string(name='host', description='The URL of the request.', example='127.xx.xx.1'),
                httpHeaders?: [ 
                  {
                    name?: string(name='name', description='The name of the HTTP request header.', example='key'),
                    value?: string(name='value', description='The value of the HTTP request header field.', example='value'),
                  }
                ](name='httpHeaders', description='The HTTP request headers.'),
                port?: string(name='port', description='The port number of the request.', example='80'),
                scheme?: string(name='scheme', description='The request method. Valid values: `http` and `https`.', example='http'),
              }(name='httpGet', description='The HTTP GET request that is sent before the instance stops.'),
              tcpSocket?: {
                host?: string(name='host', description='The URL of the TCP socket request.', example='127.xx.xx.1'),
                port?: string(name='port', description='The port number of the TCP socket request.', example='888'),
              }(name='tcpSocket', description='The TCP socket request that is sent.'),
            }(name='postStart', description='The post-start parameters.'),
            preStop?: {
              exec?: {
                command?: [ string ](name='command', description='The executed commands. The value is a string that consists of JSON arrays.'),
              }(name='exec', description='The pre-close script.'),
              httpGet?: {
                host?: string(name='host', description='The URL of the request.', example='127.xx.xx.1'),
                httpHeaders?: [ 
                  {
                    name?: string(name='name', description='The name of the HTTP request header.', example='key'),
                    value?: string(name='value', description='The value of the HTTP request header field.', example='value'),
                  }
                ](name='httpHeaders', description='The HTTP request headers.'),
                port?: string(name='port', description='The port number of the request.', example='80'),
                scheme?: string(name='scheme', description='The request method. Valid values: `http` and `https`.', example='http'),
              }(name='httpGet', description='The HTTP GET request that is sent before the instance stops.'),
              tcpSocket?: {
                host?: string(name='host', description='The URL of the request.', example='127.xx.xx.1'),
                port?: string(name='port', description='The port number of the request.', example='888'),
              }(name='tcpSocket', description='The TCP socket request that is sent.'),
            }(name='preStop', description='The pre-close parameters.'),
          }(name='Lifecycle', description='The lifecycle of Istio Proxy.'),
          multiBuffer?: {
            enabled?: boolean(name='Enabled', description='Indicates whether MulitiBuffer-based TLS acceleration is enabled. Valid values:

*   `true`
*   `false`', example='false'),
            pollDelay?: string(name='PollDelay', description='The pull-request latency.', example='0.02s'),
          }(name='MultiBuffer', description='The information about Transport Layer Security (TLS) acceleration based on MulitiBuffer.'),
          NFDConfiguration?: {
            enabled?: boolean(name='Enabled', description='Indicates whether NFD is enabled.', example='true'),
            NFDLabelPruned?: boolean(name='NFDLabelPruned', description='Indicates whether feature labels on nodes are cleared when NFD is disabled.', example='true'),
          }(name='NFDConfiguration', description='The configurations of Node Feature Discovery (NFD).'),
          OPAScopeInjection?: {
            OPAScopeInjected?: boolean(name='OPAScopeInjected', description='Indicates whether the feature of controlling the OPA injection scope is enabled. Valid values:

*   `true`
*   `false`', example='false'),
          }(name='OPAScopeInjection', description='The configurations of the feature of controlling the OPA injection scope.'),
          sidecarProxyInitResourceLimit?: {
            resourceCPULimit?: string(name='ResourceCPULimit', description='The maximum number of CPU cores that are available to the istio-init container.', example='2000m'),
            resourceMemoryLimit?: string(name='ResourceMemoryLimit', description='The maximum size of the memory that is available to the istio-init container.', example='1024Mi'),
          }(name='SidecarProxyInitResourceLimit', description='The resource limits on the istio-init container.'),
          sidecarProxyInitResourceRequest?: {
            resourceCPURequest?: string(name='ResourceCPURequest', description='The number of CPU cores that are requested by the istio-init container.', example='10m'),
            resourceMemoryRequest?: string(name='ResourceMemoryRequest', description='The size of the memory that is requested by the istio-init container.', example='10Mi'),
          }(name='SidecarProxyInitResourceRequest', description='The resources that are required by the istio-init container.'),
          terminationDrainDuration?: string(name='TerminationDrainDuration', description='The maximum period of time that Istio Proxy waits for a request to end.', example='5s'),
        }(name='ExtraConfiguration', description='The configurations of additional features for the ASM instance.'),
        includeIPRanges?: string(name='IncludeIPRanges', description='The IP ranges in CIDR form to redirect to the sidecar proxies in the ASM instance.', example='192.168.0.0/16'),
        k8sNewAPIsSupport?: {
          gatewayAPIEnabled?: boolean(name='GatewayAPIEnabled', description='Indicates whether Gateway API is enabled. Valid values:

*   `true`
*   `false`', example='false'),
        }(name='K8sNewAPIsSupport', description='The information about the Kubernetes API.'),
        kiali?: {
          enabled?: boolean(name='Enabled', description='Indicates whether mesh topology is enabled. Mesh topology can be enabled only when Prometheus monitoring is enabled. If Prometheus monitoring is disabled, you must set this parameter to `false`.`` Valid values:

*   `true`
*   `false`', example='false'),
          url?: string(name='Url', description='The endpoint of the mesh topology service.', example='http://1.2.**.**:20001'),
        }(name='Kiali', description='The configurations of mesh topology.'),
        localityLB?: {
          distribute?: map[string]any(name='Distribute', description='The configurations of cross-region traffic distribution.

>  Either `Failover` or Distribute can be set. If you set `Distribute`, you cannot set Failover.', example='[{"from":"cn-shanghai","to":{"cn-hangzhou/*":50,"cn-shanghai/*":25,"cn-zhangjiakou/*":25}},{"from":"cn-hangzhou","to":{"cn-hangzhou/*":50,"cn-shanghai/*":25,"cn-zhangjiakou/*":25}}]'),
          enabled?: boolean(name='Enabled', description='Indicates whether cross-region load balancing is enabled. Valid values:

*   `true`
*   `false`', example='false'),
          failover?: map[string]any(name='Failover', description='The configurations of cross-region failover.

>  Either Failover or `Distribute` can be set. If you set `Failover`, you cannot set `Distribute`.', example='{"failover":[{"from":"cn-hangzhou","to":"cn-shanghai"}]}'),
        }(name='LocalityLB', description='The configurations of cross-region load balancing.'),
        MSE?: {
          enabled?: boolean(name='Enabled', description='Indicates whether MSE is enabled. Valid values:

*   `true`
*   `false`', example='false'),
        }(name='MSE', description='The configurations of Microservices Engine (MSE).'),
        OPA?: {
          enabled?: boolean(name='Enabled', description='Indicates whether the OPA plug-in is installed. Valid values:

*   `true`
*   `false`', example='true'),
          limitCPU?: string(name='LimitCPU', description='The maximum number of CPU cores that are available to the OPA proxy container.', example='1'),
          limitMemory?: string(name='LimitMemory', description='The maximum size of the memory that is available to the OPA proxy container.', example='512Mi'),
          logLevel?: string(name='LogLevel', description='The level of the logs to be generated for OPA.', example='info'),
          requestCPU?: string(name='RequestCPU', description='The number of CPU cores that are requested by the OPA proxy container.', example='2'),
          requestMemory?: string(name='RequestMemory', description='The size of the memory that is requested by OPA.', example='1024Mi'),
        }(name='OPA', description='The information about the Open Policy Agent (OPA) plug-in.'),
        outboundTrafficPolicy?: string(name='OutboundTrafficPolicy', description='The outbound traffic policy. Valid values:

*   `ALLOW_ANY`: Outbound traffic to all external services is allowed.
*   `REGISTRY_ONLY`: Outbound traffic is allowed to only external services that are defined in the service registry of the ASM instance.', example='ALLOW_ANY'),
        pilot?: {
          configSource?: {
            enabled?: boolean(name='Enabled', description='Indicates whether communication is allowed between external services and services in the mesh. Valid values:

*   `true`
*   `false`', example='false'),
            nacosID?: string(name='NacosID', description='The ID of the Nacos instance that provides external service information.', example='mse-cn-tl326******'),
          }(name='ConfigSource', description='The configurations of communication between external services and services in the mesh.'),
          feature?: {
            enableSDSServer?: boolean(name='EnableSDSServer', description='Indicates whether Secret Discovery Service (SDS) is enabled. Valid values:

*   `true`
*   `false`', example='false'),
            filterGatewayClusterConfig?: boolean(name='FilterGatewayClusterConfig', description='Indicates whether gateway configuration filtering is enabled. Valid values:

*   `true`
*   `false`', example='false'),
          }(name='Feature', description='The configurations of Pilot features.'),
          http10Enabled?: boolean(name='Http10Enabled', description='Indicates whether HTTP/1.0 is supported. Valid values:

*   `true`
*   `false`', example='false'),
          traceSampling?: float(name='TraceSampling', description='The sampling percentage of tracing analysis.', example='100'),
        }(name='Pilot', description='The Pilot configurations.'),
        prometheus?: {
          externalUrl?: string(name='ExternalUrl', description='The endpoint of Prometheus monitoring. If you use a custom Prometheus instance, this parameter is populated by the system.', example='http://prometheus:9090'),
          useExternal?: boolean(name='UseExternal', description='Indicates whether a custom Prometheus instance is used. Valid values:

*   `true`
*   `false`', example='false'),
        }(name='Prometheus', description='The configurations of Prometheus monitoring.'),
        protocolSupport?: {
          dubboFilterEnabled?: boolean(name='DubboFilterEnabled', description='Indicates whether Dubbo Filter is enabled. Valid values:

*   `true`
*   `false`', example='false'),
          mysqlFilterEnabled?: boolean(name='MysqlFilterEnabled', description='Indicates whether MySQL Filter is enabled. Valid values:

*   `true`
*   `false`', example='false'),
          redisFilterEnabled?: boolean(name='RedisFilterEnabled', description='Indicates whether Redis Filter is enabled. Valid values:

*   `true`
*   `false`', example='false'),
          thriftFilterEnabled?: boolean(name='ThriftFilterEnabled', description='Indicates whether Thrift Filter is enabled. Valid values:

*   `true`
*   `false`', example='false'),
        }(name='ProtocolSupport', description='The configurations of protocol support.'),
        proxy?: {
          accessLogFile?: string(name='AccessLogFile', description='The path to the file that stores the access logs of sidecar proxies.', example='/dev/stdout'),
          accessLogFormat?: string(name='AccessLogFormat', description='The format of the access logs of sidecar proxies.', example='{"authority_for":"%REQ(:AUTHORITY)%","bytes_received":"%BYTES_RECEIVED%","bytes_sent":"%BYTES_SENT%","downstream_local_address":"%DOWNSTREAM_LOCAL_ADDRESS%","downstream_remote_address":"%DOWNSTREAM_REMOTE_ADDRESS%","duration":"%DURATION%","istio_policy_status":"%DYNAMIC_METADATA(istio.mixer:status)%","method":"%REQ(:METHOD)%","path":"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%","protocol":"%PROTOCOL%","request_id":"%REQ(X-REQUEST-ID)%","requested_server_name":"%REQUESTED_SERVER_NAME%","response_code":"%RESPONSE_CODE%","response_flags":"%RESPONSE_FLAGS%","route_name":"%ROUTE_NAME%","start_time":"%START_TIME%","trace_id":"%REQ(X-B3-TRACEID)%","upstream_cluster":"%UPSTREAM_CLUSTER%","upstream_host":"%UPSTREAM_HOST%","upstream_local_address":"%UPSTREAM_LOCAL_ADDRESS%","upstream_service_time":"%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)%","upstream_transport_failure_reason":"%UPSTREAM_TRANSPORT_FAILURE_REASON%","user_agent":"%REQ(USER-AGENT)%","x_forwarded_for":"%REQ(X-FORWARDED-FOR)%"}'),
          accessLogServiceEnabled?: boolean(name='AccessLogServiceEnabled', description='Indicates whether gRPC Access Log Service (ALS) for Envoy is enabled. Valid values:

*   `true`
*   `false`', example='false'),
          accessLogServiceHost?: string(name='AccessLogServiceHost', description='The endpoint of gRPC ALS for Envoy.', example='0.0.0.0'),
          accessLogServicePort?: int32(name='AccessLogServicePort', description='The port of gRPC ALS for Envoy.', example='9999'),
          clusterDomain?: string(name='ClusterDomain', description='The trusted domain.', example='cluster.domain'),
          enableDNSProxying?: boolean(name='EnableDNSProxying', description='Indicates whether the Domain Name System (DNS) proxy feature is enabled. Valid values:

*   `true`
*   `false`', example='false'),
          limitCPU?: string(name='LimitCPU', description='The maximum number of CPU cores.', example='2000m'),
          limitMemory?: string(name='LimitMemory', description='The maximum size of the memory.', example='1024Mi'),
          requestCPU?: string(name='RequestCPU', description='The number of CPU cores that are requested.', example='100m'),
          requestMemory?: string(name='RequestMemory', description='The size of the memory that is requested.', example='128Mi'),
        }(name='Proxy', description='The proxy configurations.'),
        sidecarInjector?: {
          autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled', description='Indicates whether automatic sidecar proxy injection can be enabled by using pod annotations. Valid values:

*   `true`
*   `false`', example='true'),
          enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault', description='Indicates whether automatic sidecar proxy injection is enabled for all namespaces. Valid values:

*   `true`
*   `false`', example='false'),
          initCNIConfiguration?: {
            enabled?: boolean(name='Enabled', description='Indicates whether the CNI plug-in is enabled. Valid values:

*   `true`
*   `false`', example='false'),
            excludeNamespaces?: string(name='ExcludeNamespaces', description='The namespaces to exclude. The CNI plug-in ignores pods in the excluded namespaces.', example='kube-system,istio-system'),
          }(name='InitCNIConfiguration', description='The configurations of Container Network Interface (CNI).'),
          limitCPU?: string(name='LimitCPU', description='The maximum number of CPU cores that are available to the pod where the sidecar injector resides.', example='4000m'),
          limitMemory?: string(name='LimitMemory', description='The maximum size of the memory that is available to the pod where the sidecar injector resides.', example='2048Mi'),
          requestCPU?: string(name='RequestCPU', description='The number of CPU cores that are requested by the pod where the sidecar injector resides.', example='1000m'),
          requestMemory?: string(name='RequestMemory', description='The size of the memory that is requested by the pod where the sidecar injector resides.', example='512Mi'),
          sidecarInjectorNum?: int32(name='SidecarInjectorNum', description='The number of component replicas that are used for sidecar proxy injection. Default value: `1`.', example='1'),
          sidecarInjectorWebhookAsYaml?: string(name='SidecarInjectorWebhookAsYaml', description='Other configurations of automatic sidecar proxy injection, in the YAML format. For more information, see [Enable automatic sidecar proxy injection](~~186136~~).', example='{"injectedAnnotations":{"test/istio-init":"runtime/default2","test/istio-proxy":"runtime/default"},"replicaCount":2,"nodeSelector":{"beta.kubernetes.io/os":"linux"}}'),
        }(name='SidecarInjector', description='The configurations of the sidecar injector.'),
        telemetry?: boolean(name='Telemetry', description='Indicates whether Prometheus monitoring is enabled. We recommend that you use [Managed Service for Prometheus](https://arms.console.aliyun.com/). Valid values:

*   `true`
*   `false`', example='true'),
        tracing?: boolean(name='Tracing', description='Indicates whether tracing analysis is enabled. This feature can be enabled only after [Managed Service for OpenTelemetry](https://tracing-analysis.console.aliyun.com/) is activated. Valid values:

*   `true`
*   `false`', example='true'),
        webAssemblyFilterDeployment?: {
          enabled?: boolean(name='Enabled', description='Indicates whether WebAssembly Filter is enabled. Valid values:

*   `true`
*   `false`', example='false'),
        }(name='WebAssemblyFilterDeployment', description='The configurations of WebAssembly Filter.'),
      }(name='MeshConfig', description='The configurations of the ASM instance.'),
      network?: {
        securityGroupId?: string(name='SecurityGroupId', description='The security group ID.', example='sg-2ze384sxttxbctnj****'),
        vSwitches?: [ string ](name='VSwitches', description='The virtual switches (vSwitches).'),
        vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-2zew0rajjkmxy2369****'),
      }(name='Network', description='The network configurations of the ASM instance.'),
    }(name='Spec', description='The specifications of the ASM instance.'),
  }(name='ServiceMesh', description='The details of the ASM instance.'),
}

model DescribeServiceMeshDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshDetailResponseBody(name='body'),
}

async function describeServiceMeshDetail(request: DescribeServiceMeshDetailRequest): DescribeServiceMeshDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeServiceMeshDetail', 'POST', '/', 'json', true, 'form', request);
}

model DescribeServiceMeshKubeconfigRequest {
  privateIpAddress?: boolean(name='PrivateIpAddress', description='Specifies whether to query the kubeconfig file that is used for Internet access or internal network access.', example='false', position='Query'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Query'),
}

model DescribeServiceMeshKubeconfigResponseBody = {
  expireTime?: string(name='ExpireTime', description='The expiration time of the kubeconfig certificate. The format is: YYYY-MM-DD hh: mm: ss.', example='2024-05-28 16:00:00'),
  kubeconfig?: string(name='Kubeconfig', description='The content of the kubeconfig file of the cluster.', example='apiVersion: v1 clusters: - cluster:     server: https://47.110.xx.xx:6443     certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURUakNDQWphZ0F3SUJBZ0lVYzBQVy82ejR1aHlxYkRRdnNsV1htSmpJeFdNd0RRWUpLb1pJaHZjTkFRRUwKQlFBd1BqRW5NQThHQTFVRUNoTUlhR0Z1WjNwb2IzVXdGQVlEVlFRS0V3MWhiR2xpWVdKaElHTnNiM1ZrTVJNdwpFUVlEVlFRREV3cHJkV0psY201bGRHVnpNQ0FYRFRJeU1EUXdOekExTVRnd01Gb1lEekl3TlRJd016TXdNRFV4Ck9EQXdXakErTVNjd0R3WURWUVFLRXdob1lXNW5lbWh2ZFRBVUJnTlZCQW9URFdGc2FXSmhZbUVnWTJ4dmRXUXgKRXpBUkJnTlZCQU1UQ210MVltVnlibVYwWlhNd2dnRWlNQTBHQ1NxR1NJYjNEUUVCQVFVQUE0SUJE****'),
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeServiceMeshKubeconfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshKubeconfigResponseBody(name='body'),
}

async function describeServiceMeshKubeconfig(request: DescribeServiceMeshKubeconfigRequest): DescribeServiceMeshKubeconfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeServiceMeshKubeconfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeServiceMeshLogsRequest {
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='ca04bc38979214bf2882be79d39b4****', position='Body'),
}

model DescribeServiceMeshLogsResponseBody = {
  logs?: [ 
    {
      creationTime?: string(name='CreationTime', description='The point in time when the logs were generated.', example='2021-11-19T15:21:53+08:00'),
      log?: string(name='Log', description='The content of the logs.', example='[RequestID: 31d3a0f0-07ed-4f6e-9004-1804498c****, UID-110982038403****] c096d641835af4658827a4c66c234**** | Start to add cluster c186a6d9641a24098b5499d4d8313****'),
      serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='ca04bc38979214bf2882be79d39b4****'),
    }
  ](name='Logs', description='The details of the logs.'),
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeServiceMeshLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshLogsResponseBody(name='body'),
}

async function describeServiceMeshLogs(request: DescribeServiceMeshLogsRequest): DescribeServiceMeshLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeServiceMeshLogs', 'POST', '/', 'json', true, 'form', request);
}

model DescribeServiceMeshProxyStatusRequest {
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='ca04bc38979214bf2882be79d39b4****', position='Body'),
}

model DescribeServiceMeshProxyStatusResponseBody = {
  code?: string(name='Code', description='The status code. Valid values:

`200`: The operation is successful.

*   `403`: You are not authorized to perform this operation.
*   `503`: A backend server error occurs.', example='200'),
  message?: string(name='Message', description='The returned message.', example='success'),
  proxyStatus?: [ 
    {
      clusterSynced?: string(name='ClusterSynced', description='The update status of the proxy. Valid values:

*   `SYNCED`: The status of the proxy is updated.
*   `NOT SENT`: The status of the proxy is not updated.
*   `STALE (Never Acknowledged)`: Istiod has sent multiple requests to the Envoy proxy to update the status of the proxy but receives no response.
*   `STALE`: Istiod has sent a request to the Envoy proxy to update the status of the proxy but receives no response.', example='SYNCED'),
      endpointPercent?: string(name='EndpointPercent', description='The percentage of the updated endpoints.', example='1'),
      endpointSynced?: string(name='EndpointSynced', description='The update status of the endpoint. Valid values:

*   `SYNCED`: The status of the endpoint is updated.
*   `NOT SENT`: The status of the endpoint is not updated.
*   `STALE (Never Acknowledged)`: Istiod has sent multiple requests to the Envoy proxy to update the status of the endpoint but receives no response.
*   `STALE`: Istiod has sent a request to the Envoy proxy to update the status of the endpoint but receives no response.', example='SYNCED'),
      istioVersion?: string(name='IstioVersion', description='The version of Istiod.', example='1.9.7'),
      listenerSynced?: string(name='ListenerSynced', description='The update status of the listener. Valid values:

*   `SYNCED`: The status of the listener is updated.
*   `NOT SENT`: The status of the listener is not updated.
*   `STALE (Never Acknowledged)`: Istiod has sent multiple requests to the Envoy proxy to update the status of the listener but receives no response.
*   `STALE`: Istiod has sent a request to the Envoy proxy to update the status of the listener but receives no response.', example='SYNCED'),
      proxyId?: string(name='ProxyId', description='The ID of the proxy on the data plane.', example='119q****'),
      proxyVersion?: string(name='ProxyVersion', description='The version number of a proxy on the data plane.', example='1.9.7'),
      routeSynced?: string(name='RouteSynced', description='The update status of the route. Valid values:

*   `SYNCED`: The status of the route is updated.
*   `NOT SENT`: The status of the route is not updated.
*   `STALE (Never Acknowledged)`: Istiod has sent multiple requests to the Envoy proxy to update the status of the route but receives no response.
*   `STALE`: Istiod has sent a request to the Envoy proxy to update the status of the route but receives no response.', example='SYNCED'),
    }
  ](name='ProxyStatus', description='The information about the status of the proxies on the data plane.'),
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
  success?: string(name='Success', description='Indicates whether the request was successful.', example='success'),
}

model DescribeServiceMeshProxyStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshProxyStatusResponseBody(name='body'),
}

async function describeServiceMeshProxyStatus(request: DescribeServiceMeshProxyStatusRequest): DescribeServiceMeshProxyStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeServiceMeshProxyStatus', 'POST', '/', 'json', true, 'form', request);
}

model DescribeServiceMeshUpgradeStatusRequest {
  allIstioGatewayFullNames?: string(name='AllIstioGatewayFullNames', description='The fully qualified names of ingress gateways in the ASM instance. Separate multiple names with commas (,).', example='istio-system:ingressgateway1,istio-system:ingressgateway2', position='Body'),
  guestClusterIds?: string(name='GuestClusterIds', description='The IDs of the clusters on the data plane of the ASM instance. Separate multiple clusters with commas (,).', example='caeac85a793c94afbbb0a4bb20320****', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='11fd0027-c27e-41bb-a565-75583054****', position='Query'),
}

model DescribeServiceMeshUpgradeStatusResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='11fd0027-c27e-41bb-a565-75583054****'),
  upgradeDetail?: {
    finishedGatewaysNum?: long(name='FinishedGatewaysNum', description='The number of ingress gateways that are upgraded.', example='1'),
    gatewayStatusRecord?: map[string]UpgradeDetailGatewayStatusRecordValue(name='GatewayStatusRecord', description='The information about the status of the ingress gateways.'),
    meshStatus?: string(name='MeshStatus', description='The status of the ASM instance. Valid values:

*   running: The instance is running.
*   `upgrading`: The instance is being upgraded.
*   `upgrading_failed`: The upgrade of the instance fails.', example='running'),
    totalGatewaysNum?: long(name='TotalGatewaysNum', description='The total number of ingress gateways in the ASM instance.', example='2'),
  }(name='UpgradeDetail', description='The upgrade results.'),
}

model DescribeServiceMeshUpgradeStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshUpgradeStatusResponseBody(name='body'),
}

async function describeServiceMeshUpgradeStatus(request: DescribeServiceMeshUpgradeStatusRequest): DescribeServiceMeshUpgradeStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeServiceMeshUpgradeStatus', 'POST', '/', 'json', true, 'form', request);
}

model DescribeServiceMeshVMsRequest {
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='ccb37ff104caf419fbf48fb38e6f****', position='Query'),
}

model DescribeServiceMeshVMsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='4b2c0fe0-6705-4614-8521-6b9d289163c8'),
  vMs?: [ 
    {
      hasTag?: boolean(name='HasTag', description='Indicates whether the ECS instance has labels.', example='false'),
      hostName?: string(name='HostName', description='The host name.', example='iZ2ze45cgxkx4q12eh****'),
      instanceId?: string(name='InstanceId', description='The ID of the ECS instance.', example='i-2ze0kub9scdguom****'),
      ipAddress?: string(name='IpAddress', description='The IP address of the ECS instance.', example='192.168.2.241'),
      region?: string(name='Region', description='The region ID.', example='cn-beijing'),
      securityGroupIds?: string(name='SecurityGroupIds', description='The security group to which the ECS instance belongs.', example='sg-2zeaqy08amco9osl****'),
      serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='ccb37ff104caf419fbf48fb38e6f3****'),
      status?: string(name='Status', description='The state of the ECS instance.', example='Running'),
    }
  ](name='VMs', description='The ECS instances that reside in the same VPC as the ASM instance.'),
}

model DescribeServiceMeshVMsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshVMsResponseBody(name='body'),
}

/**
  * @deprecated
  *
 */
// Deprecated
async function describeServiceMeshVMs(request: DescribeServiceMeshVMsRequest): DescribeServiceMeshVMsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeServiceMeshVMs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeServiceMeshesRequest {
  tag?: [ 
    {
      key?: string(name='Key', example='test'),
      value?: string(name='Value', example='yahaha'),
    }
  ](name='Tag', position='Query'),
}

model DescribeServiceMeshesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
  serviceMeshes?: [ 
    {
      clusterSpec?: string(name='ClusterSpec', description='The edition of the ASM instance. Valid values:

*   `standard`: Standard Edition
*   `enterprise`: Enterprise Edition
*   `ultimate`: Ultimate Edition', example='standard'),
      clusters?: [ string ](name='Clusters', description='The clusters.'),
      endpoints?: {
        intranetApiServerEndpoint?: string(name='IntranetApiServerEndpoint', description='The endpoint that is used to access the API server over the internal network.', example='https://192.168.xx.xx:6443'),
        intranetPilotEndpoint?: string(name='IntranetPilotEndpoint', description='The endpoint that is used to access Istio Pilot from the internal network.', example='192.168.xx.xx:15011'),
        publicApiServerEndpoint?: string(name='PublicApiServerEndpoint', description='The endpoint that is used to access the API server over the Internet.', example='https://123.56.xx.xx:6443'),
        publicPilotEndpoint?: string(name='PublicPilotEndpoint', description='The endpoint that is used to expose Istio Pilot to the Internet.', example='182.92.xx.xx:15011'),
        reverseTunnelEndpoint?: string(name='ReverseTunnelEndpoint', description='The endpoint of the reverse tunnel.', example='...'),
      }(name='Endpoints', description='The information about all endpoints of the ASM instances.'),
      ownerId?: string(name='OwnerId', description='The ID of the Alibaba Cloud service instance for which the ASM instance is created.', example='cc3e96f249d124eb38b72718ec5*****'),
      ownerType?: string(name='OwnerType', description='The Alibaba Cloud service for which the ASM instance is created. Valid values:

*   `ackone`: The ASM instance is created for Alibaba Cloud Distributed Cloud Container Platform (ACK One).
*   An empty value indicates that the ASM instance is created by the user.', example='ackone'),
      serviceMeshInfo?: {
        creationTime?: string(name='CreationTime', description='The time when the ASM instance was created.', example='2020-04-21T09:42:20+08:00'),
        errorMessage?: string(name='ErrorMessage', description='The error message.', example='error'),
        name?: string(name='Name', description='The name of the ASM instance.', example='test'),
        profile?: string(name='Profile', description='The edition of the ASM instance before ASM is available for commercial use. Valid values:

*   `Pro`: Professional Edition
*   `Default`: Standard Edition', example='Pro'),
        regionId?: string(name='RegionId', description='The region ID of the ASM instance.', example='cn-beijing'),
        serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='cb8963379255149cb98c8686f274x****'),
        state?: string(name='State', description='The state of the ASM instance.', example='success'),
        updateTime?: string(name='UpdateTime', description='The time when the ASM instance was last modified.', example='2020-04-21T09:42:20+08:00'),
        version?: string(name='Version', description='The version number of the ASM instance.', example='1'),
      }(name='ServiceMeshInfo', description='The basic information about the ASM instances.'),
      spec?: {
        loadBalancer?: {
          apiServerLoadbalancerId?: string(name='ApiServerLoadbalancerId', description='The ID of the SLB instance that is used when the API server is exposed to the Internet.', example='lb-2zekaak10uxds44vx****'),
          apiServerPublicEip?: boolean(name='ApiServerPublicEip', description='Indicates whether the API server is exposed to the Internet. Valid values:

*   `true`
*   `false`', example='true'),
          pilotPublicEip?: boolean(name='PilotPublicEip', description='Indicates whether Istio Pilot is exposed to the Internet. Valid values:

*   `true`
*   `false`', example='true'),
          pilotPublicLoadbalancerId?: string(name='PilotPublicLoadbalancerId', description='The ID of the Server Load Balancer (SLB) instance that is used when Istio Pilot is exposed to the Internet.', example='lb-2zesa8qs8kbkj9jkl****'),
        }(name='LoadBalancer', description='The information about load balancing.'),
        meshConfig?: {
          mtls?: boolean(name='Mtls', description='Indicates whether nearby access is enabled. Valid values:

*   `true`
*   `false`', example='true'),
          outboundTrafficPolicy?: string(name='OutboundTrafficPolicy', description='The outbound traffic policy. Valid values:

*   `ALLOW_ANY`: Outbound traffic to an external service is allowed.
*   `REGISTRY_ONLY`: Outbound traffic is allowed to only external services that are defined in the service registry of the ASM instance.', example='ALLOW_ANY'),
          pilot?: {
            http10Enabled?: boolean(name='Http10Enabled', description='Indicates whether the support for HTTP 1.0 is enabled. Valid values:

*   `true`
*   `false`', example='true'),
            traceSampling?: float(name='TraceSampling', description='The sampling rate when Tracing Analysis is enabled.', example='0.2'),
          }(name='Pilot', description='The configurations of the control plane.'),
          sidecarInjector?: {
            autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled', description='Indicates whether automatic sidecar proxy injection is enabled by using annotations.', example='true'),
            enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault', description='Indicates whether automatic sidecar proxy injection is enabled for all namespaces. Valid values:

*   `true`
*   `false`', example='false'),
            initCNIConfiguration?: {
              enabled?: boolean(name='Enabled', description='Indicates whether elevated privileges are required for the istio-init container when you perform traffic redirection for the istio-proxy container. Valid values:

*   `true`
*   `false`', example='true'),
              excludeNamespaces?: string(name='ExcludeNamespaces', description='The namespace for which sidecar proxy injection is disabled.', example='default,foo'),
            }(name='InitCNIConfiguration', description='The initial configurations of Container Network Interface (CNI).'),
          }(name='SidecarInjector', description='The configurations of sidecar proxy injection.'),
          strictMtls?: boolean(name='StrictMtls', description='Indicates whether mutual Transport Layer Security (mTLS) is strictly enforced.', example='true'),
          telemetry?: boolean(name='Telemetry', description='Indicates whether Prometheus monitoring is enabled. We recommend that you use Managed Service for Prometheus. Valid values:

*   `true`
*   `false`', example='true'),
          tracing?: boolean(name='Tracing', description='Indicates whether the tracing feature is enabled. This feature can be enabled only after Tracing Analysis is activated. Valid values:

*   `true`
*   `false`', example='true'),
        }(name='MeshConfig', description='The configurations of the ASM instance.'),
        network?: {
          securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', example='sg-2ze384sxttxbctnj****'),
          vSwitches?: [ string ](name='VSwitches', description='The IDs of the vSwitches.'),
          vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-2zew0rajjkmxy2369****'),
        }(name='Network', description='The network configurations of the ASM instance.'),
      }(name='Spec', description='The specifications of the ASM instance.'),
      tag?: [ 
        {
          key?: string(name='Key', example='test'),
          value?: string(name='Value', example='yahaha'),
        }
      ](name='Tag'),
      upgradable?: boolean(name='Upgradable', example='false'),
    }
  ](name='ServiceMeshes', description='The information about the ASM instances.'),
}

model DescribeServiceMeshesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshesResponseBody(name='body'),
}

async function describeServiceMeshes(request: DescribeServiceMeshesRequest): DescribeServiceMeshesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeServiceMeshes', 'GET', '/', 'json', false, 'json', request);
}

model DescribeUpgradeVersionRequest {
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Query'),
}

model DescribeUpgradeVersionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='11fd0027-c27e-41bb-a565-75583054****'),
  version?: {
    istioOperatorVersion?: string(name='IstioOperatorVersion', description='The version of the ASM instance.', example='v1.10.5.34-g7689a219-aliyun'),
    istioVersion?: string(name='IstioVersion', description='The Istio version.', example='1.10.5.34'),
    kubernetesVersion?: string(name='KubernetesVersion', description='The Kubernetes version.', example='1.20'),
  }(name='Version', description='The version information.'),
}

model DescribeUpgradeVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUpgradeVersionResponseBody(name='body'),
}

async function describeUpgradeVersion(request: DescribeUpgradeVersionRequest): DescribeUpgradeVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUpgradeVersion', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUserPermissionsRequest {
  subAccountUserId: string(name='SubAccountUserId', description='The ID of a RAM user or RAM role.', example='27852573609480****', position='Body'),
}

model DescribeUserPermissionsResponseBody = {
  permissions?: [ 
    {
      isRamRole?: string(name='IsRamRole', description='The entity to which the permissions are granted. A value of `true` indicates that the permissions are granted to a RAM user. A value of `false` indicates that the permissions are granted to a RAM role.', example='false'),
      parentId?: string(name='ParentId', description='The value is fixed as `0`.', example='0'),
      resourceId?: string(name='ResourceId', description='The ID of the ASM instance.', example='c57b848115458460583a4260cb713****'),
      resourceType?: string(name='ResourceType', description='The value is fixed as `cluster`.', example='cluster'),
      roleName?: string(name='RoleName', description='The name of the permissions. Valid values:

*   `istio-admin`: the permissions of ASM administrators.
*   `istio-ops`: the permissions of ASM restricted users.
*   `istio-readonly`: the read-only permissions.', example='istio-admin'),
      roleType?: string(name='RoleType', description='The value is fixed as `custom`.', example='custom'),
    }
  ](name='Permissions', description='The permissions that are granted to an entity.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5A7C9E37-C171-584F-9A99-869B48C4196D'),
}

model DescribeUserPermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUserPermissionsResponseBody(name='body'),
}

async function describeUserPermissions(request: DescribeUserPermissionsRequest): DescribeUserPermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUserPermissions', 'POST', '/', 'json', true, 'form', request);
}

model DescribeUsersWithPermissionsRequest {
  userType: string(name='UserType', description='Specifies whether to query the IDs of all RAM users or RAM roles to which an RBAC role is assigned. Valid values:

*   `SubUser`: Query the IDs of all RAM users to which an RBAC role is assigned.
*   `RamRole`: Query the IDs of all RAM roles to which an RBAC role is assigned.', example='SubUser', position='Body'),
}

model DescribeUsersWithPermissionsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='12B94024-C241-13CD-BA44-6106DF1****'),
  UIDs?: [ string ](name='UIDs', description='The list of the IDs of the RAM users or RAM roles to which an RBAC role is assigned.'),
}

model DescribeUsersWithPermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUsersWithPermissionsResponseBody(name='body'),
}

async function describeUsersWithPermissions(request: DescribeUsersWithPermissionsRequest): DescribeUsersWithPermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUsersWithPermissions', 'POST', '/', 'json', true, 'form', request);
}

model DescribeVMsInServiceMeshRequest {
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='ccb37ff104caf419fbf48fb38e6f3****', position='Query'),
}

model DescribeVMsInServiceMeshResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='4b2c0fe0-6705-4614-8521-6b9d289163c8'),
  vMs?: [ 
    {
      hasTag?: boolean(name='HasTag', description='Indicates whether the ECS instance has labels.', example='true'),
      hostName?: string(name='HostName', description='The host name.', example='iZ2ze45cgxkx4q12eh9l****'),
      instanceId?: string(name='InstanceId', description='The ID of the ECS instance.', example='i-2ze45cgxkx4q12e****'),
      ipAddress?: string(name='IpAddress', description='The IP address of the ECS instance.', example='10.0.*,***'),
      region?: string(name='Region', description='The region ID.', example='cn-beijing'),
      securityGroupIds?: string(name='SecurityGroupIds', description='The security group to which the ECS instance belongs.', example='sg-2zeaqy08amco9osl****'),
      status?: string(name='Status', description='The state of the ECS instance.', example='Running'),
    }
  ](name='VMs', description='The VMs that are added to the ASM instance.'),
}

model DescribeVMsInServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVMsInServiceMeshResponseBody(name='body'),
}

/**
  * @deprecated
  *
 */
// Deprecated
async function describeVMsInServiceMesh(request: DescribeVMsInServiceMeshRequest): DescribeVMsInServiceMeshResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVMsInServiceMesh', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVSwitchesRequest {
  regionId: string(name='RegionId', description='The region ID.', example='cn-hangzhou', position='Body'),
  vpcId: string(name='VpcId', description='The VPC ID.', example='vpc-bp17gig441u0msmd78****', position='Body'),
}

model DescribeVSwitchesResponseBody = {
  maxResults?: int32(name='MaxResults', description='The maximum number of entries returned.', example='10'),
  nextToken: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.', example=''),
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
  totalCount?: int32(name='TotalCount', description='The total number of vSwitches that are deployed in the VPC in the region. This parameter is optional and is not returned by default.', example='10'),
  vSwitches?: [ 
    {
      isDefault?: boolean(name='IsDefault', description='Indicates whether the vSwitch is the default vSwitch. Valid values:

*   `true`
*   `false`', example='false'),
      status?: string(name='Status', description='The state of the vSwitch. Valid values:

*   `Pending`: The vSwitch is being configured.
*   `Available`: The vSwitch is available.', example='Available'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-bp1g24p9no0iqir46****'),
      vSwitchName?: string(name='VSwitchName', description='The name of the vSwitch.', example='vsw-test'),
      vpcId?: string(name='VpcId', description='The ID of the VPC to which the vSwitch belongs.', example='vpc-bp17gig441u0msmd6****'),
      zoneId?: string(name='ZoneId', description='The zone to which the switch belongs.', example='cn-hangzhou-k'),
    }
  ](name='VSwitches', description='The available vSwitches.'),
}

model DescribeVSwitchesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVSwitchesResponseBody(name='body'),
}

async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVSwitches', 'POST', '/', 'json', true, 'form', request);
}

model DescribeVersionsRequest {
}

model DescribeVersionsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
  versionInfo?: [ 
    {
      edition?: string(name='Edition', description='The edition of the ASM instance. Valid values:

*   `Default`: Standard Edition
*   `Pro`: Professional Edition that is commercially released', example='Default'),
      versions?: [ string ](name='Versions', description='The list of ASM versions available for the ASM instance of the current edition.'),
    }
  ](name='VersionInfo', description='The available ASM versions.'),
}

model DescribeVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVersionsResponseBody(name='body'),
}

async function describeVersions(request: DescribeVersionsRequest): DescribeVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVersions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVpcsRequest {
  regionId: string(name='RegionId', description='The region ID.', example='cn-hangzhou', position='Body'),
}

model DescribeVpcsResponseBody = {
  maxResults?: int32(name='MaxResults', description='The maximum number of entries returned on a single page.', example='10'),
  nextToken: string(name='NextToken', description='The token that marks the end of the current returned page. If this parameter is empty, it indicates that you have retrieved all the data.', example='""'),
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned. By default, this parameter is not returned.', example='10'),
  vpcs?: [ 
    {
      isDefault?: boolean(name='IsDefault', description='Indicates whether the VPC is the default VPC in the specified region. Valid values:

*   `true`: yes
*   `false`: no', example='false'),
      status?: string(name='Status', description='The status of the VPC. Valid values:

*   `Pending`: The VPC is being configured.
*   `Available`: The VPC is available for use.', example='Available'),
      vpcId?: string(name='VpcId', description='The ID of a VPC.', example='vpc-bp1qkf2o3xmqc2519****'),
      vpcName?: string(name='VpcName', description='The name of the VPC.', example='vpc-test'),
    }
  ](name='Vpcs', description='The list of VPCs that are available in the specified region.'),
}

model DescribeVpcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVpcsResponseBody(name='body'),
}

async function describeVpcs(request: DescribeVpcsRequest): DescribeVpcsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVpcs', 'POST', '/', 'json', true, 'form', request);
}

model GetCaCertRequest {
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c7894c929677643a5bfe1a732d778a****', position='Body'),
}

model GetCaCertResponseBody = {
  caCert?: string(name='CaCert', description='The Base64-encoded content of the CA certificate.', example='-----BEGIN CERTIFICATE-----\\nMIIFszCCA5ugAwIBAgIDM/1OMA0GCSqGSIb3DQEBCwUAME427zhT4HDLcCEW****-----END CERTIFICATE-----\\n'),
  requestId?: string(name='RequestId', description='The request ID.', example='E0496204-7586-5B4C-B364-2361CC0ED****'),
}

model GetCaCertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCaCertResponseBody(name='body'),
}

async function getCaCert(request: GetCaCertRequest): GetCaCertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetCaCert', 'POST', '/', 'json', true, 'form', request);
}

model GetDeploymentBySelectorRequest {
  guestCluster?: string(name='GuestCluster', description='The name of the cluster.', example='cbe80a56d07ed45818b4d39273e23****', position='Body'),
  labelSelector?: map[string]string(name='LabelSelector', description='The label selector information.', shrink='json', position='Body'),
  limit?: long(name='Limit', description='The maximum number of returned data entries.', example='10', position='Body'),
  mark?: string(name='Mark', description='The marker of data queried last time.', example='eyJ2IjoibWV0YS5rOHMuaW8vdjEiLCJydiI6NzgxODk3MCwic3RhcnQiOiJuZ2lueDQ1N1x1MDAw****', position='Body'),
  nameSpace?: string(name='NameSpace', description='The namespace.', example='default', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the Alibaba Cloud Service Mesh (ASM) instance.', example='ce9fc65def2aa4c918747b9360fbd****', position='Body'),
}

model GetDeploymentBySelectorResponseBody = {
  deploymentNameList?: [ bytes ](name='DeploymentNameList', description='The queried workloads.'),
  mark?: string(name='Mark', description='The end-of-data marker.', example='eyJ2IjoibWV0YS5rOHMuaW8vdjEiLCJydiI6NTgyMDUzMzk5MCwic3RhcnQiOiJwbXMtYWRhcHRlci1kZGxsXHUwMDA****'),
  requestId?: string(name='RequestId', description='The request ID.', example='946690C2-41D3-55A0-A501-E2FFAB5F****'),
}

model GetDeploymentBySelectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeploymentBySelectorResponseBody(name='body'),
}

async function getDeploymentBySelector(request: GetDeploymentBySelectorRequest): GetDeploymentBySelectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDeploymentBySelector', 'POST', '/', 'json', true, 'form', request);
}

model GetGrafanaDashboardUrlRequest {
  k8sClusterId: string(name='K8sClusterId', description='The ID of the Container Service for Kubernetes (ACK) or ACK Serverless cluster.', example='c94ca2d27f7aa47ab84ed73e6f084****', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the Service Mesh (ASM) instance.', example='cb8963379255149cb98c8686f274x****', position='Body'),
  title: string(name='Title', description='The name of the dashboard.', example='Cloud ASM Istio Http Gateway', position='Body'),
}

model GetGrafanaDashboardUrlResponseBody = {
  dashboards?: [ 
    {
      title?: string(name='Title', description='The name of the dashboard.', example='Cloud ASM Istio Http Gateway'),
      url?: string(name='Url', description='The URL of the dashboard.', example='https://g.console.aliyun.com/d/181863583797****-14651340-200-2/alibaba-cloud-mesh-service?orgId=32****&refresh=60s'),
    }
  ](name='Dashboards', description='The information about the dashboard.'),
  requestId?: string(name='RequestId', description='The request ID.', example='76DBB8A0-5AA6-5A56-9A8A-****'),
}

model GetGrafanaDashboardUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGrafanaDashboardUrlResponseBody(name='body'),
}

async function getGrafanaDashboardUrl(request: GetGrafanaDashboardUrlRequest): GetGrafanaDashboardUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetGrafanaDashboardUrl', 'POST', '/', 'json', true, 'form', request);
}

model GetRegisteredServiceEndpointsRequest {
  clusterIds?: string(name='ClusterIds', description='The name of the registered service.', example='c8b054ee8c3914d079b5ce9733328****,c58faedb8a78640d3aeb0372e4c02****', position='Body'),
  name?: string(name='Name', description='The type of the registered service. Valid values:

*   `ServiceEntry`: indicates that the service is registered by creating a service entry.
*   `Kubernetes`: indicates that the service is registered on a Kubernetes cluster on the data plane.', example='reviews', position='Body'),
  namespace?: string(name='Namespace', description='The IDs of clusters in the ASM instance. Separate multiple cluster IDs with commas (,).', example='default', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The name of the namespace.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
  serviceType?: string(name='ServiceType', description='The endpoints of the registered service.', example='Kubernetes', position='Body'),
}

model GetRegisteredServiceEndpointsResponseBody = {
  endPointSlice?: {
    endpointsDetails?: [ 
      {
        address?: string(name='Address', description='The port of the registered service.', example='127.2.**.**'),
        hostname?: string(name='Hostname', description='The ID of the region in which the registered service resides.', example='www.demo.com'),
        podName?: string(name='PodName', description='The IP address of the registered service.', example='provider-v1-8c86b6898-h***'),
        ports?: [ int32 ](name='Ports', description='The host name of the registered service.'),
        region?: string(name='Region', description='Indicates whether sidecar proxies are injected. Valid values:

*   `true`: yes
*   `false`: no', example='cn-hangzhou'),
        sidecarInjected?: boolean(name='SidecarInjected', description='The ID of the request.', example='false'),
      }
    ](name='EndpointsDetails', description='The name of the pod.'),
    location?: string(name='Location', description='The details of the endpoint of the registered service.', example='MESH_INTERNAL'),
    namespace?: string(name='Namespace', description='The location of the registered service. Valid values:

*   `MESH_INTERNAL`: The service is deployed inside the ASM instance.
*   `MESH_EXTERNAL`: The service is deployed outside the ASM instance.', example='default'),
    serviceName?: string(name='ServiceName', description='The name of the namespace.', example='reviews'),
  }(name='EndPointSlice', description='The name of the registered service.'),
  requestId?: string(name='RequestId', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
  serviceEndpoints?: [ 
    {
      address?: string(name='Address', description='The ID of the cluster on the data plane.', example='192.168.25.153'),
      clusterId?: string(name='ClusterId', description='The details of the endpoints of the registered service.', example='c80f45444b3da447da60a911390c2****'),
    }
  ](name='ServiceEndpoints', description='The IP address of the registered service.'),
}

model GetRegisteredServiceEndpointsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRegisteredServiceEndpointsResponseBody(name='body'),
}

async function getRegisteredServiceEndpoints(request: GetRegisteredServiceEndpointsRequest): GetRegisteredServiceEndpointsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetRegisteredServiceEndpoints', 'POST', '/', 'json', true, 'form', request);
}

model GetRegisteredServiceNamespacesRequest {
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='cb8963379255149cb98c8686f274x****', position='Body'),
}

model GetRegisteredServiceNamespacesResponseBody = {
  namespaces?: [ string ](name='Namespaces', description='The names of the queried namespaces.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model GetRegisteredServiceNamespacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRegisteredServiceNamespacesResponseBody(name='body'),
}

async function getRegisteredServiceNamespaces(request: GetRegisteredServiceNamespacesRequest): GetRegisteredServiceNamespacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetRegisteredServiceNamespaces', 'POST', '/', 'json', true, 'form', request);
}

model GetSwimLaneDetailRequest {
  groupName?: string(name='GroupName', description='The name of the lane group.', example='test', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the Service Mesh (ASM) instance.', example='xxx', position='Body'),
  swimLaneName?: string(name='SwimLaneName', description='The name of the lane.', example='s1', position='Body'),
}

model GetSwimLaneDetailResponseBody = {
  ingressRule?: string(name='IngressRule', description='The traffic routing rule that routes traffic to the lane by using the ingress gateway. The traffic routing rule contains one or more custom routes.', example='[{"Domains":["*"],"RouteName":"r1","MatchRequest":{"Headers":[{"Name":"x-asm-prefer-tag","MatchingMode":"exact","MatchingContent":"s1"}],"URI":{"MatchingMode":"exact","MatchingContent":"/mock"}},"RouteDestinations":[{"Destination":{"Host":"mocka.default.svc.cluster.local","Subset":"s1"}}]},{"Domains":["*"],"RouteName":"hello","MatchRequest":{"Headers":[{"Name":"x-asm-prefer-tag","MatchingMode":"exact","MatchingContent":"s1"}],"URI":{"MatchingMode":"exact","MatchingContent":"/mocktest"}},"RouteDestinations":[{"Destination":{"Host":"mocka.default.svc.cluster.local","Subset":"s1"}}]}]'),
  ingressService?: string(name='IngressService', description='This parameter is deprecated.', example='mocka.default.svc.cluster.local'),
  labelSelectorKey?: string(name='LabelSelectorKey', description='The label key of the associated service workload. The value is fixed as **ASM_TRAFFIC_TAG**.', example='ASM_TRAFFIC_TAG'),
  labelSelectorValue?: string(name='LabelSelectorValue', description='The value of ASM_TRAFFIC_TAG.', example='v1'),
  requestId?: string(name='RequestId', description='The request ID.', example='yyyy'),
  servicesList?: string(name='ServicesList', description='A list of services associated with the lane.', example='["sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mocka","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockb","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockc"]'),
}

model GetSwimLaneDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSwimLaneDetailResponseBody(name='body'),
}

async function getSwimLaneDetail(request: GetSwimLaneDetailRequest): GetSwimLaneDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSwimLaneDetail', 'POST', '/', 'json', true, 'form', request);
}

model GetSwimLaneGroupListRequest {
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='xxxx', position='Body'),
}

model GetSwimLaneGroupListResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='yyyy'),
  swimLaneGroupList?: [ 
    {
      fallbackTarget?: string(name='FallbackTarget'),
      groupName?: string(name='GroupName', description='The name of a lane group.', example='test'),
      ingressGatewayName?: string(name='IngressGatewayName', description='The name of the ingress gateway.', example='ingressgateway'),
      ingressType?: string(name='IngressType', description='The ingress type. Traffic routing rules can be configured only in an ingress gateway.', example='ASM'),
      isPermissive?: boolean(name='IsPermissive'),
      routeHeader?: string(name='RouteHeader'),
      serviceList?: string(name='ServiceList', description='A list of services associated with the lane group.', example='["sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mocka","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockb","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockc"]'),
      swimLaneLabels?: string(name='SwimLaneLabels'),
      traceHeader?: string(name='TraceHeader'),
    }
  ](name='SwimLaneGroupList', description='The information about the lane groups.'),
}

model GetSwimLaneGroupListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSwimLaneGroupListResponseBody(name='body'),
}

async function getSwimLaneGroupList(request: GetSwimLaneGroupListRequest): GetSwimLaneGroupListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSwimLaneGroupList', 'POST', '/', 'json', true, 'form', request);
}

model GetSwimLaneListRequest {
  groupName?: string(name='GroupName', description='The name of the lane group.', example='test', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the Service Mesh (ASM) instance.', example='xxx', position='Body'),
}

model GetSwimLaneListResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='yyyy'),
  swimLaneList?: [ 
    {
      groupName?: string(name='GroupName', description='The name of the lane group.', example='test'),
      ingressRule?: string(name='IngressRule', description='The traffic routing rule associated with the lane.', example='[{"Domains":["*"],"RouteName":"r1","MatchRequest":{"Headers":[{"Name":"x-asm-prefer-tag","MatchingMode":"exact","MatchingContent":"s1"}],"URI":{"MatchingMode":"exact","MatchingContent":"/mock"}},"RouteDestinations":[{"Destination":{"Host":"mocka.default.svc.cluster.local","Subset":"s1"}}]},{"Domains":["*"],"RouteName":"hello","MatchRequest":{"Headers":[{"Name":"x-asm-prefer-tag","MatchingMode":"exact","MatchingContent":"s1"}],"URI":{"MatchingMode":"exact","MatchingContent":"/mocktest"}},"RouteDestinations":[{"Destination":{"Host":"mocka.default.svc.cluster.local","Subset":"s1"}}]}]'),
      ingressService?: string(name='IngressService', description='This parameter is deprecated.', example='mocka.default.svc.cluster.local'),
      labelSelectorKey?: string(name='LabelSelectorKey', description='The label key of the associated service workload. The value is fixed as `ASM_TRAFFIC_TAG`.', example='ASM_TRAFFIC_TAG'),
      labelSelectorValue?: string(name='LabelSelectorValue', description='The label value of the associated service workload.``', example='v1'),
      name?: string(name='Name', description='The name of a lane.', example='s1'),
      serviceList?: string(name='ServiceList', description='A list of services associated with the lane.', example='["sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mocka","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockb","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockc"]'),
    }
  ](name='SwimLaneList', description='A list of all the lanes in the lane group.'),
}

model GetSwimLaneListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSwimLaneListResponseBody(name='body'),
}

async function getSwimLaneList(request: GetSwimLaneListRequest): GetSwimLaneListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSwimLaneList', 'POST', '/', 'json', true, 'form', request);
}

model GetVmAppMeshInfoRequest {
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='ce51a7de4a5144db88a864****', position='Query'),
}

model GetVmAppMeshInfoResponseBody = {
  data?: string(name='Data', description='The response parameters.', example='...'),
  requestId?: string(name='RequestId', description='The request ID.', example='9522f7c9-63a1-4603-b850-37d12a****'),
}

model GetVmAppMeshInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVmAppMeshInfoResponseBody(name='body'),
}

/**
  * @deprecated
  *
 */
// Deprecated
async function getVmAppMeshInfo(request: GetVmAppMeshInfoRequest): GetVmAppMeshInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVmAppMeshInfo', 'GET', '/', 'json', false, 'json', request);
}

model GetVmMetaRequest {
  namespace?: string(name='Namespace', description='The name of the namespace. This parameter is valid only after you set the Namespace and the ServiceAccount parameters.', example='hello', position='Query'),
  serviceAccount?: string(name='ServiceAccount', description='The service account. This parameter is valid only after you set the Namespace and the ServiceAccount parameters.', example='http-sa', position='Query'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='ce51a7de4a5144db88a864ed91****', position='Query'),
  trustDomain?: string(name='TrustDomain', description='The trusted domain. Default value: cluster.local. This parameter is valid only after you set the Namespace and the ServiceAccount parameters.', example='cluster.local', position='Query'),
}

model GetVmMetaResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9522f7c9-63a1-4603-b850-37d12a****'),
  vmMetaInfo?: {
    envoyEnvContent?: string(name='EnvoyEnvContent', description='The content of the EnvoyEnv file.', example='....'),
    hostsContent?: string(name='HostsContent', description='The content of the hosts file.', example='....'),
    tokenContent?: string(name='TokenContent', description='The content of the Token file.', example='....'),
  }(name='VmMetaInfo', description='The metadata that is required to add a non-containerized application to the ASM instance.'),
}

model GetVmMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVmMetaResponseBody(name='body'),
}

/**
  * @deprecated
  *
 */
// Deprecated
async function getVmMeta(request: GetVmMetaRequest): GetVmMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVmMeta', 'GET', '/', 'json', false, 'json', request);
}

model GrantUserPermissionsRequest {
  permissions?: string(name='Permissions', description='The permissions that are granted to an entity. The content is a string that consists of JSON arrays. You must specify all permissions that you want to grant to an entity. You can add or remove permissions by modifying the content. Field definition of the sample code:

*   `IsCustom`: a parameter that is required by the system. Set the value to `true`.
*   `Cluster`: the ID of the Service Mesh (ASM) instance.
*   `RoleName`: the name of the permissions. Valid values: `istio-admin`, `istio-ops`, and `istio-readonly`. A value of istio-admin indicates the permissions of ASM administrators. A value of istio-ops indicates the permissions of ASM restricted users. A value of istio-readonly indicates the read-only permissions.
*   `IsRamRole`: the entity to which you want to grant the permissions. To grant the permissions to a RAM role, set the value to `true`. Otherwise, set the value to `false`.', example='[{"IsCustom":true,"RoleName":"istio-ops","Cluster":"c57b848115458460583a4260cb713****","RoleType":"custom","IsRamRole":false},{"IsCustom":true,"RoleName":"istio-ops","Cluster":"c4ec191f4e12145c09286ea3e2b8f****","RoleType":"custom","IsRamRole":false}]', position='Body'),
  subAccountUserId?: string(name='SubAccountUserId', description='The ID of the RAM user or RAM role.', example='27852573609480****', position='Body'),
  subAccountUserIds?: [ string ](name='SubAccountUserIds', description='The IDs of RAM users or RAM roles. You can grant permissions to multiple users at a time.', shrink='json', position='Body'),
}

model GrantUserPermissionsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A7C9E37-C171-584F-9A99-869B48C4****'),
}

model GrantUserPermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GrantUserPermissionsResponseBody(name='body'),
}

async function grantUserPermissions(request: GrantUserPermissionsRequest): GrantUserPermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GrantUserPermissions', 'POST', '/', 'json', true, 'form', request);
}

model ListServiceAccountsRequest {
  clusterId: string(name='ClusterId', example='ce3c25e247da24f3aab9b7edfae83****', minLength=1, position='Body'),
  namespace?: string(name='Namespace', example='default', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', example='ce134b0727aa2492db69f6c3880e1****', minLength=1, position='Body'),
}

model ListServiceAccountsResponseBody = {
  requestId?: string(name='RequestId', example='8349374D-0F22-5CAB-9DE3-8CCE8EFA71FF'),
  serviceAccounts?: [ 
    {
      name?: string(name='Name', example='bookinfo-reviews'),
      namespace?: string(name='Namespace', example='default'),
    }
  ](name='ServiceAccounts'),
}

model ListServiceAccountsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceAccountsResponseBody(name='body'),
}

async function listServiceAccounts(request: ListServiceAccountsRequest): ListServiceAccountsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListServiceAccounts', 'POST', '/', 'json', true, 'form', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.', example='""', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the ASM instance.', example='cn-hangzhou', position='Query'),
  resourceId?: [ string ](name='ResourceId', description='The IDs of the ASM instances.', position='Query'),
  resourceType: string(name='ResourceType', description='The resource type. Set the value to `servicemesh`.', example='servicemesh', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.

A tag key can be up to 128 characters in length. The tag key cannot contain `http://` or `https://` and cannot start with `aliyun` or `acs:`.', example='test'),
      value?: string(name='Value', description='The tag value of the resource.

The tag value can be left empty or a string of up to 128 characters. The tag value cannot start with aliyun or acs:, and cannot contain http:// or https://.

Each tag key must have a unique tag value. You can specify at most 20 tag values in each call.', example='yahaha'),
    }
  ](name='Tag', description='The tags. A maximum of 20 tags are supported.', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.', example='""'),
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId', description='The ID of the ASM instance.', example='863c333b-9a8e-4b53-a13f-52a979362431'),
      resourceType?: string(name='ResourceType', description='The resource type. Set the value to `servicemesh`.', example='servicemesh'),
      tagKey?: string(name='TagKey', description='The tag key.', example='k1'),
      tagValue?: string(name='TagValue', description='The tag value.', example='yahaha'),
    }
  ](name='TagResources', description='The details of the queried clusters and tags.'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ListWaypointsRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster on the data plane.', example='ce3c25e247da24f3aab9b7edfae83****', minLength=1, position='Body'),
  continue?: string(name='Continue', position='Body'),
  limit?: long(name='Limit', position='Body'),
  name?: string(name='Name', position='Body'),
  namespace?: string(name='Namespace', description='The namespace.', example='default', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The Service Mesh (ASM) instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', minLength=1, position='Body'),
}

model ListWaypointsResponseBody = {
  continue?: string(name='Continue'),
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
  waypoints?: [ 
    {
      HPAEnabled?: string(name='HPAEnabled', description='Indicates whether Horizontal Pod Autoscaling (HPA) is enabled.', example='false'),
      HPAMaxReplicas?: string(name='HPAMaxReplicas', description='The maximum number of waypoint proxy pods when HPA is enabled.', example='4'),
      HPAMinReplicas?: string(name='HPAMinReplicas', description='The minimum number of waypoint proxy pods when HPA is enabled.', example='2'),
      HPATargetCPU?: string(name='HPATargetCPU', description='The expected CPU utilization when HPA is enabled.', example='93'),
      HPATargetMemory?: string(name='HPATargetMemory', description='The expected memory usage when HPA is enabled.', example='91'),
      limitCPU?: string(name='LimitCPU', description='The maximum number of CPU cores that are available to the waypoint proxy pods.', example='2000m'),
      limitMemory?: string(name='LimitMemory', description='The maximum size of the memory that is available to the waypoint proxy pods.', example='1024Mi'),
      name?: string(name='Name', description='The name of the gateway resource corresponding to the waypoint proxy. If the waypoint proxy takes effect on a service account, the name is the service account name. If the waypoint proxy takes effect for the entire namespace, the name is "namespace".', example='namespace'),
      namespace?: string(name='Namespace', description='The namespace.', example='default'),
      preferECI?: string(name='PreferECI', description='Indicates whether waypoint proxy pods are deployed based on Elastic Container Instance (ECI).', example='false'),
      replicas?: string(name='Replicas', description='The number of waypoint proxy pods.', example='1'),
      requestCPU?: string(name='RequestCPU', description='The number of CPU cores requested by the waypoint proxy pods.', example='100m'),
      requestMemory?: string(name='RequestMemory', description='The size of the memory requested by the waypoint proxy pods.', example='128Mi'),
      serviceAccount?: string(name='ServiceAccount', description='The service account on which the waypoint proxy takes effect. If this parameter is not specified, the waypoint proxy takes effect for the entire namespace.', example='bookinfo-productpage'),
    }
  ](name='Waypoints', description='The list of waypoint proxy configurations.'),
}

model ListWaypointsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListWaypointsResponseBody(name='body'),
}

async function listWaypoints(request: ListWaypointsRequest): ListWaypointsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListWaypoints', 'POST', '/', 'json', true, 'form', request);
}

model ModifyApiServerEipResourceRequest {
  apiServerEipId?: string(name='ApiServerEipId', description='The ID of the EIP.', example='eip-bp1adu9jegmxnaoq****', position='Body'),
  operation?: string(name='Operation', description='The type of the operation. Valid values:

*   `UnBindEip`: disassociates an EIP from the API server.
*   `BindEip`: associates an EIP with the API server.', example='BindEip', position='Body'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the Alibaba Cloud Service Mesh (ASM) instance.', example='cb8963379255149cb98c8686f274x****', position='Body'),
}

model ModifyApiServerEipResourceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model ModifyApiServerEipResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyApiServerEipResourceResponseBody(name='body'),
}

async function modifyApiServerEipResource(request: ModifyApiServerEipResourceRequest): ModifyApiServerEipResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyApiServerEipResource', 'POST', '/', 'json', true, 'form', request);
}

model ModifyServiceMeshNameRequest {
  name: string(name='Name', description='The new name of the ASM instance.', example='test-mesh', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='cdd30a90a7cea480ebcc7ff****', position='Body'),
}

model ModifyServiceMeshNameResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EDDC0D86-2FC3-56FB-9213-96EB0A3523F1'),
}

model ModifyServiceMeshNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyServiceMeshNameResponseBody(name='body'),
}

async function modifyServiceMeshName(request: ModifyServiceMeshNameRequest): ModifyServiceMeshNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyServiceMeshName', 'POST', '/', 'json', true, 'form', request);
}

model ReActivateAuditRequest {
  enableAudit?: boolean(name='EnableAudit', description='Specifies whether to recreate a project that is used to store audit logs. Valid values:

*   true: recreates a project.
*   false: does not recreate a project.', example='true', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the Service Mesh (ASM) instance.', example='c5bf9eb05c4424b89985d6536a809****', position='Body'),
}

model ReActivateAuditResponseBody = {
  data?: string(name='Data', description='The name of the project that is used to store audit logs.', example='k8s-log-c0703599f695f4b8fa1c6492a33af****'),
  requestId?: string(name='RequestId', description='The request ID.', example='17163CE9-CE4B-1B87-9185-1A1AD7E7****'),
}

model ReActivateAuditResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReActivateAuditResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that you understand the billing methods of Simple Log Service. For more information, visit the [pricing page](https://www.aliyun.com/price/product?spm=5176.10695662.1119587.4.194c6a67rcPWQH#/sls/detail).
  *
 */
async function reActivateAudit(request: ReActivateAuditRequest): ReActivateAuditResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReActivateAudit', 'POST', '/', 'json', true, 'form', request);
}

model RemoveClusterFromServiceMeshRequest {
  clusterId: string(name='ClusterId', example='cb8963379255149cb98c8686f274x****', position='Body'),
  reserveNamespace?: boolean(name='ReserveNamespace', example='false', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', example='ce3c25e247da24f3aab9b7edfae83****', position='Body'),
}

model RemoveClusterFromServiceMeshResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='success'),
  requestId?: string(name='RequestId', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model RemoveClusterFromServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveClusterFromServiceMeshResponseBody(name='body'),
}

async function removeClusterFromServiceMesh(request: RemoveClusterFromServiceMeshRequest): RemoveClusterFromServiceMeshResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveClusterFromServiceMesh', 'POST', '/', 'json', true, 'form', request);
}

model RemoveVMFromServiceMeshRequest {
  ecsId: string(name='EcsId', description='The ID of the ECS instance.', example='i-2ze90ts4edj3650****', position='Query'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='ccb37ff104caf419fbf48fb38e6f3****', position='Query'),
}

model RemoveVMFromServiceMeshResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='4b2c0fe0-6705-4614-8521-6b9d289163c8'),
}

model RemoveVMFromServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveVMFromServiceMeshResponseBody(name='body'),
}

/**
  * @deprecated
  *
 */
// Deprecated
async function removeVMFromServiceMesh(request: RemoveVMFromServiceMeshRequest): RemoveVMFromServiceMeshResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveVMFromServiceMesh', 'POST', '/', 'json', false, 'json', request);
}

model RevokeKubeconfigRequest {
  privateIpAddress?: boolean(name='PrivateIpAddress', description='Specifies whether to return the kubeconfig file for private access.

*   `true`: returns the kubeconfig file for private access.
*   `false`: returns the kubeconfig file for public access.', example='false', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the ASM instance for which you want to revoke its kubeconfig file.', example='cf08a11940e8c46c48bc791fcdb3****', position='Body'),
}

model RevokeKubeconfigResponseBody = {
  kubeconfig?: string(name='Kubeconfig', description='The new kubeconfig file generated.', example='apiVersion: v1 clusters: - cluster:     server: https://121.**.**.**:6443     certificate-authority-data: *****   name: kubernetes contexts: - context:     cluster: kubernetes     user: "*****"   name: ***** current-context: ***** kind: Config preferences: {} users: - name: "*****"   user:     client-certificate-data: *****     client-key-data: *****'),
  requestId?: string(name='RequestId', description='The request ID.', example='7CF71C8B-79DD-150F-929E-267C51C5E311'),
}

model RevokeKubeconfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokeKubeconfigResponseBody(name='body'),
}

async function revokeKubeconfig(request: RevokeKubeconfigRequest): RevokeKubeconfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokeKubeconfig', 'POST', '/', 'json', true, 'form', request);
}

model TagResourcesRequest {
  regionId: string(name='RegionId', description='The region ID of the Service Mesh (ASM) instance.', example='cn-hangzhou', position='Query'),
  resourceId: [ string ](name='ResourceId', description='The IDs of the ASM instances.', position='Query'),
  resourceType: string(name='ResourceType', description='The resource type. Set the value to `servicemesh`.', example='servicemesh', position='Query'),
  tag: [ 
    {
      key: string(name='Key', description='The tag keys.

The following limits apply:

*   The key of tag N cannot be an empty string.
*   Valid values of N: 1 to 20.
*   The tag key can be up to 128 characters in length.
*   The tag key cannot start with `aliyun` or `acs:`.
*   The tag key cannot contain `http://` or `https://`.', example='test'),
      value: string(name='Value', description='The tag values.

The following limits apply:

*   The value of tag N cannot be an empty string.
*   Valid values of N: 1 to 20.
*   The tag value can be up to 128 characters in length.
*   The tag value cannot contain `http://` or `https://`.', example='yahaha'),
    }
  ](name='Tag', description='The tags.', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to delete all tags. This parameter takes effect only when the TagKey.N parameter is not specified. Valid values:

*   true
*   false

Default value: false.', example='false', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the ASM instance.', example='cn-hangzhou', position='Query'),
  resourceId: [ string ](name='ResourceId', description='The IDs of the ASM instances.', position='Query'),
  resourceType: string(name='ResourceType', description='The resource type. Set the value to `servicemesh`.', example='servicemesh', position='Query'),
  tagKey?: [ string ](name='TagKey', description='The tag keys.', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

model UpdateASMGatewayRequest {
  body?: string(name='Body', description='The new YAML content of the ASM gateway.', example='{"apiVersion":"istio.alibabacloud.com/v1beta1","kind":"IstioGateway","metadata":{"name":"ingressgateway","namespace":"istio-system"},"spec":{"gatewayType":"ingress","clusterIds":["xxxxx"],"ports":[{"name":"http-0","port":80,"targetPort":80,"protocol":"TCP"},{"name":"https-1","port":443,"targetPort":443,"protocol":"TCP"}],"serviceAnnotations":{"service.beta.kubernetes.io/alicloud-loadbalancer-address-type":"internet","service.beta.kubernetes.io/alibaba-cloud-loadbalancer-spec":"slb.s1.small"},"replicaCount":2,"resources":{"limits":{"cpu":"2","memory":"4G"},"requests":{"cpu":"200m","memory":"256Mi"}},"serviceType":"LoadBalancer","maxReplicas":2,"minReplicas":2}}', position='Body'),
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='cb8963379255149cb98c8686f274x****', position='Body'),
}

model UpdateASMGatewayResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model UpdateASMGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateASMGatewayResponseBody(name='body'),
}

async function updateASMGateway(request: UpdateASMGatewayRequest): UpdateASMGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateASMGateway', 'POST', '/', 'json', true, 'form', request);
}

model UpdateASMGatewayImportedServicesRequest {
  ASMGatewayName?: string(name='ASMGatewayName', description='The name of the ASM gateway.', example='ingressgateway', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
  serviceNames?: string(name='ServiceNames', description='The names of the services. Separate multiple service names with commas (,). Example: reviews,sleep.', example='reviews,sleep', position='Body'),
  serviceNamespace?: string(name='ServiceNamespace', description='The namespace in which the service resides.', example='default', position='Body'),
}

model UpdateASMGatewayImportedServicesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='11fd0027-c27e-41bb-a565-75583054****'),
}

model UpdateASMGatewayImportedServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateASMGatewayImportedServicesResponseBody(name='body'),
}

async function updateASMGatewayImportedServices(request: UpdateASMGatewayImportedServicesRequest): UpdateASMGatewayImportedServicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateASMGatewayImportedServices', 'POST', '/', 'json', true, 'form', request);
}

model UpdateASMNamespaceFromGuestClusterRequest {
  k8sClusterId: string(name='K8sClusterId', description='The ID of the Kubernetes cluster whose namespace information you want to synchronize to ASM. The Kubernetes cluster is added to the ASM instance that is specified by the ServiceMeshId parameter.', example='c6f6d46583def494ba1f2e2937c8*****', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='cbf9ca9e6d5dc4c87a3ecd0ebf1e*****', position='Body'),
}

model UpdateASMNamespaceFromGuestClusterResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9DEC6122-ACEC-183D-8451-8E0A1A******'),
}

model UpdateASMNamespaceFromGuestClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateASMNamespaceFromGuestClusterResponseBody(name='body'),
}

async function updateASMNamespaceFromGuestCluster(request: UpdateASMNamespaceFromGuestClusterRequest): UpdateASMNamespaceFromGuestClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateASMNamespaceFromGuestCluster', 'POST', '/', 'json', true, 'form', request);
}

model UpdateControlPlaneLogConfigRequest {
  enabled: boolean(name='Enabled', description='Specifies whether to collect control plane logs to Simple Log Service.', example='false', position='Body'),
  logTTLInDay?: int32(name='LogTTLInDay', description='The time to live (TTL) period of the collected logs. Unit: day.', example='30', minimum=1, maximum=3000, position='Body'),
  project?: string(name='Project', description='The name of the Simple Log Service project to which control plane logs are collected.', example='aia-asm-deva-sh', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the Service Mesh (ASM) instance.', example='c20667db760fe4ee6910220136624****', position='Body'),
}

model UpdateControlPlaneLogConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='488F046B-63D2-5D96-9A70-E00C3685D49F'),
}

model UpdateControlPlaneLogConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateControlPlaneLogConfigResponseBody(name='body'),
}

async function updateControlPlaneLogConfig(request: UpdateControlPlaneLogConfigRequest): UpdateControlPlaneLogConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateControlPlaneLogConfig', 'POST', '/', 'json', true, 'form', request);
}

model UpdateIstioGatewayRoutesRequest {
  description?: string(name='Description', description='The description of the routing rule.', example='demo route', position='Body'),
  gatewayRoute?: {
    domains?: [ string ](name='Domains', description='The list of requested domain names.'),
    HTTPAdvancedOptions?: {
      delegate?: {
        name?: string(name='Name', description='The name of the virtual service.', example='reviews'),
        namespace?: string(name='Namespace', description='The namespace to which the virtual service belongs.', example='default'),
      }(name='Delegate', description='The virtual service that defines traffic routing.'),
      fault?: {
        abort?: {
          httpStatus?: int32(name='HttpStatus', description='The HTTP status code.', example='400'),
          percentage?: {
            value?: float(name='Value', description='The percentage of requests that are aborted with the specified error code, which is expressed as a decimal.', example='0.1'),
          }(name='Percentage', description='The percentage of requests that are aborted with the specified error code.'),
        }(name='Abort', description='The configurations for aborting requests with specified error codes.'),
        delay?: {
          fixedDelay?: string(name='FixedDelay', description='The fixed duration for request delay.', example='5s'),
          percentage?: {
            value?: float(name='Value', description='The percentage of requests to which the delay fault is injected, which is expressed as a decimal.', example='0.1'),
          }(name='Percentage', description='The percentage of requests to which the delay fault is injected.'),
        }(name='Delay', description='The duration to delay a request.'),
      }(name='Fault', description='The configurations of fault injection.'),
      HTTPRedirect?: {
        authority?: string(name='Authority', description='The value to be used to overwrite the value of the Authority or Host header during redirection.', example='newratings.default.svc.cluster.local'),
        redirectCode?: int32(name='RedirectCode', description='The HTTP status code to be used to indicate URL redirection. Default value: 301.', example='301'),
        uri?: string(name='Uri', description='The value to be used to overwrite the URL path during redirection.', example='/v1/getProductRatings'),
      }(name='HTTPRedirect', description='The HTTP redirection rule.'),
      mirror?: {
        host?: string(name='Host', description='The name of the service defined in the service registry.', example='reviews.default.svc.cluster.local'),
        subset?: string(name='Subset', description='The name of the service subset.', example='v1'),
      }(name='Mirror', description='The configurations for mirroring HTTP traffic to another destination in addition to forwarding requests to the specified destination.'),
      mirrorPercentage?: {
        value?: float(name='Value', description='The percentage of requests that are mirrored to another destination except for the original destination, which is expressed as a decimal.', example='0.2'),
      }(name='MirrorPercentage', description='The percentage of requests that are mirrored to another destination except for the original destination.'),
      retries?: {
        attempts?: int32(name='Attempts', description='The number of retries that are allowed for a request.', example='3'),
        perTryTimeout?: string(name='PerTryTimeout', description='The timeout period for each retry.', example='2s'),
        retryOn?: string(name='RetryOn', description='The condition for retries. Example: `connect-failure,refused-stream,503`.', example='connect-failure,refused-stream,503'),
        retryRemoteLocalities?: {
          value?: boolean(name='Value', description='Specifies whether to allow retries to other localities. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
        }(name='RetryRemoteLocalities', description='Specifies whether to allow retries to other localities.'),
      }(name='Retries', description='The configurations of retries for failed requests.'),
      rewrite?: {
        authority?: string(name='Authority', description='The value to be used to overwrite the value of the Authority or Host header.', example='newratings.default.svc.cluster.local'),
        uri?: string(name='Uri', description='The value to be used to overwrite the path or prefix of the URI.', example='/v1/getProductRatings'),
      }(name='Rewrite', description='The configurations for rewriting the virtual service.'),
      timeout?: string(name='Timeout', description='The timeout period for requests.', example='5s'),
    }(name='HTTPAdvancedOptions', description='The advanced settings for routing HTTP traffic.'),
    matchRequest?: {
      headers?: [ 
        {
          matchingContent?: string(name='MatchingContent', description='The header value to be matched.', example='v1'),
          matchingMode?: string(name='MatchingMode', description='The matching mode for the header value. Valid values:

*   `exact`: exact match
*   `prefix`: match by prefix
*   `regex`: match by regular expression', example='exact'),
          name?: string(name='Name', description='The header key to be matched.', example='x-request-id'),
        }
      ](name='Headers', description='The request headers to be matched.'),
      ports?: [ int32 ](name='Ports', description='The ports.'),
      TLSMatchAttributes?: [ 
        {
          SNIHosts?: [ string ](name='SNIHosts', description='The Server Name Indication (SNI) values to be matched.'),
          TLSPort?: int32(name='TLSPort', description='The TLS port.', example='443'),
        }
      ](name='TLSMatchAttributes', description='The matching rule for Transport Layer Security (TLS) traffic.'),
      URI?: {
        matchingContent?: string(name='MatchingContent', description='The content to be matched.', example='/ratings/v2/'),
        matchingMode?: string(name='MatchingMode', description='The matching mode for the routing rule. Valid values:

*   `exact`: exact match
*   `prefix`: match by prefix
*   `regex`: match by regular expression', example='prefix'),
      }(name='URI', description='The matching rule for URIs.'),
    }(name='MatchRequest', description='The matching rules for traffic routing.'),
    namespace?: string(name='Namespace', description='The namespace.', example='default'),
    rawVSRoute?: any(name='RawVSRoute', description='The original YAML file of the virtual service that is serialized in a JSON string.', example='{}'),
    routeDestinations?: [ 
      {
        destination?: {
          host?: string(name='Host', description='The name of the service defined in the service registry.', example='reviews'),
          port?: {
            number?: int32(name='Number', description='The port number.', example='80'),
          }(name='Port', description='The port of the destination service.

>  If the destination service of the route has only one port, this field can be left empty. If the destination service has multiple ports, you must specify the port number.'),
          subset?: string(name='Subset', description='The name of the service subset.', example='v1'),
        }(name='Destination', description='The unique endpoint of the destination service to which the specified requests are sent.'),
        weight?: int32(name='Weight', description='The weight of the service subset.', example='80'),
      }
    ](name='RouteDestinations', description='The endpoints of destination services for Layer 4 weighted routing.'),
    routeName?: string(name='RouteName', description='The name of the routing rule.', example='reviews-v2-routes'),
    routeType?: string(name='RouteType', description='The type of the traffic to be routed. Valid values: `HTTP`, `TLS`, and `TCP`.', example='HTTP'),
  }(name='GatewayRoute', description='The information about the routing rule to be updated for the ASM gateway.', shrink='json', position='Body'),
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway', position='Body'),
  priority?: int32(name='Priority', description='The priority of the routing rule. The value of this parameter is an integer. A smaller value indicates a higher priority.', example='1', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
  status?: int32(name='Status', description='The status of the routing rule. Valid values:

*   `0`: The routing rule is valid.
*   `1`: The routing rule is invalid.
*   `2`: An error occurs during the creation or update of the routing rule.', example='1', position='Body'),
}

model UpdateIstioGatewayRoutesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model UpdateIstioGatewayRoutesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIstioGatewayRoutesResponseBody(name='body'),
}

async function updateIstioGatewayRoutes(request: UpdateIstioGatewayRoutesRequest): UpdateIstioGatewayRoutesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateIstioGatewayRoutes', 'POST', '/', 'json', true, 'form', request);
}

model UpdateIstioInjectionConfigRequest {
  dataPlaneMode?: string(name='DataPlaneMode', description='The data plane mode of the namespace. This parameter is valid only when the Ambient Mesh mode is enabled for the current Service Mesh (ASM) instance. Valid values:

*   ambient: sets the data plane mode of the namespace to the Ambient Mesh mode.
*   sidecar: sets the data plane mode of the namespace to the Sidecar mode.', example='ambient', position='Body'),
  enableIstioInjection?: boolean(name='EnableIstioInjection', description='Specifies whether to enable Istio automatic sidecar injection.', example='true', position='Body'),
  enableSidecarSetInjection?: boolean(name='EnableSidecarSetInjection', description='Specifies whether to enable automatic sidecar injection by using SidecarSet.', example='false', position='Body'),
  istioRev?: string(name='IstioRev', description='Specifies the version to be injected into the namespace. This parameter is valid only when the ASM instance performs a canary release. When IstioRev is not empty, you must not specify EnableIstioInjection and EnableSidecarSetInjection.', example='canary', position='Body'),
  namespace: string(name='Namespace', description='The namespace for which you want to modify the sidecar injection setting.', example='default', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='ce2cdbb9d013f447180cf5ca8bb******', position='Body'),
}

model UpdateIstioInjectionConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='98B268E6-9381-5A98-8012-6E7E82******'),
}

model UpdateIstioInjectionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIstioInjectionConfigResponseBody(name='body'),
}

async function updateIstioInjectionConfig(request: UpdateIstioInjectionConfigRequest): UpdateIstioInjectionConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateIstioInjectionConfig', 'POST', '/', 'json', true, 'form', request);
}

model UpdateIstioRouteAdditionalStatusRequest {
  description?: string(name='Description', description='The description of the routing rule.', example='demo route', position='Query'),
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway', position='Body'),
  priority?: int32(name='Priority', description='The priority of the routing rule. The value of this parameter is an integer. A smaller value indicates a higher priority.', example='0', position='Query'),
  routeName?: string(name='RouteName', description='The name of the routing rule.', example='http-test', position='Query'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
  status?: int32(name='Status', description='The status of the routing rule. Valid values: 0: The routing rule is valid. 1: The routing rule is invalid. 2: An error occurs during the creation or update of the routing rule.', example='0', position='Query'),
}

model UpdateIstioRouteAdditionalStatusResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model UpdateIstioRouteAdditionalStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIstioRouteAdditionalStatusResponseBody(name='body'),
}

async function updateIstioRouteAdditionalStatus(request: UpdateIstioRouteAdditionalStatusRequest): UpdateIstioRouteAdditionalStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateIstioRouteAdditionalStatus', 'POST', '/', 'json', true, 'form', request);
}

model UpdateMeshCRAggregationRequest {
  CPULimit?: string(name='CPULimit', description='The maximum number of CPU cores that are available for the components installed in the ACK cluster on the data plane if you enable the Kubernetes API to access Istio resources in the ASM instance. You can specify the parameter value in the standard quantity representation used by Kubernetes.', example='1', position='Body'),
  CPURequirement?: string(name='CPURequirement', description='The number of CPU cores that are requested by the components installed in the Container Service for Kubernetes (ACK) cluster on the data plane if you enable the Kubernetes API to access Istio resources in the ASM instance. You can specify the parameter value in the standard quantity representation used by Kubernetes.', example='1', position='Body'),
  enabled?: boolean(name='Enabled', description='Specifies whether to enable the Kubernetes API on the data plane to access Istio resources in the ASM instance. Valid values:

*   `true`: enables the Kubernetes API to access Istio resources in the ASM instance.
*   `false`: disables the Kubernetes API to access Istio resources in the ASM instance.', example='true', position='Body'),
  memoryLimit?: string(name='MemoryLimit', description='The maximum size of the memory that is available for the components installed in the ACK cluster on the data plane if you enable the Kubernetes API to access Istio resources in the ASM instance. You can specify the parameter value in the standard quantity representation used by Kubernetes. 1 Mi equals 1,024 KB.', example='500Mi', position='Body'),
  memoryRequirement?: string(name='MemoryRequirement', description='The size of the memory that is requested by the components installed in the ACK cluster on the data plane if you enable the Kubernetes API to access Istio resources in the ASM instance. You can specify the parameter value in the standard quantity representation used by Kubernetes. 1 Mi equals 1,024 KB.', example='500Mi', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The Service Mesh (ASM) instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Body'),
  usePublicApiServer?: boolean(name='UsePublicApiServer', description='Specifies whether the Kubernetes API on the data plane uses the public endpoint of the API server to access Istio resources in the ASM instance. Valid values:

*   `true`: The Kubernetes API on the data plane uses the public endpoint of the API server to access Istio resources in the ASM instance.
*   `false`: The Kubernetes API on the data plane uses the private endpoint of the API server to access Istio resources in the ASM instance.

Default value: `false`.', example='false', position='Body'),
}

model UpdateMeshCRAggregationResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model UpdateMeshCRAggregationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMeshCRAggregationResponseBody(name='body'),
}

async function updateMeshCRAggregation(request: UpdateMeshCRAggregationRequest): UpdateMeshCRAggregationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMeshCRAggregation', 'POST', '/', 'json', true, 'form', request);
}

model UpdateMeshFeatureRequest {
  accessLogEnabled?: boolean(name='AccessLogEnabled', description='Specifies whether to enable access log collection. Valid values:

*   `true`: enables access log collection.
*   `false`: disables access log collection.

Default value: `false`.', example='false', position='Body'),
  accessLogFile?: string(name='AccessLogFile', description='Specifies whether to enable access logging. Valid values:

*   `""`: disables access logging.
*   `/dev/stdout`: enables access logging. Access logs are written to /dev/stdout.', example='', position='Body'),
  accessLogFormat?: string(name='AccessLogFormat', description='The custom format of access logs. To set this parameter, make sure that you have enabled access log collection. The value must be a JSON string. The following key names must be contained: authority_for, bytes_received, bytes_sent, downstream_local_address, downstream_remote_address, duration, istio_policy_status, method, path, protocol, requested_server_name, response_code, response_flags, route_name, start_time, trace_id, upstream_cluster, upstream_host, upstream_local_address, upstream_service_time, upstream_transport_failure_reason, user_agent, and x_forwarded_for.', example='{"authority_for":"%REQ(:AUTHORITY)%","bytes_received":"%BYTES_RECEIVED%","bytes_sent":"%BYTES_SENT%","downstream_local_address":"%DOWNSTREAM_LOCAL_ADDRESS%","downstream_remote_address":"%DOWNSTREAM_REMOTE_ADDRESS%","duration":"%DURATION%","istio_policy_status":"%DYNAMIC_METADATA(istio.mixer:status)%","method":"%REQ(:METHOD)%","path":"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%","protocol":"%PROTOCOL%","request_id":"%REQ(X-REQUEST-ID)%","requested_server_name":"%REQUESTED_SERVER_NAME%","response_code":"%RESPONSE_CODE%","response_flags":"%RESPONSE_FLAGS%","route_name":"%ROUTE_NAME%","start_time":"%START_TIME%","trace_id":"%REQ(X-B3-TRACEID)%","upstream_cluster":"%UPSTREAM_CLUSTER%","upstream_host":"%UPSTREAM_HOST%","upstream_local_address":"%UPSTREAM_LOCAL_ADDRESS%","upstream_service_time":"%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)%","upstream_transport_failure_reason":"%UPSTREAM_TRANSPORT_FAILURE_REASON%","user_agent":"%REQ(USER-AGENT)%","x_forwarded_for":"%REQ(X-FORWARDED-FOR)%"}', position='Body'),
  accessLogGatewayEnabled?: boolean(name='AccessLogGatewayEnabled', position='Query'),
  accessLogGatewayLifecycle?: int32(name='AccessLogGatewayLifecycle', description='The retention period for the access logs of the sidecar proxy. Unit: day. The logs are collected by using Log Service. For example, `30` indicates 30 days.', example='30', position='Body'),
  accessLogProject?: string(name='AccessLogProject', description='The custom project on which the Log Service collects logs.', example='mesh-log-cf245a429b6ff4b6e97f20797758e****', position='Body'),
  accessLogServiceEnabled?: boolean(name='AccessLogServiceEnabled', description='Specifies whether to enable gRPC Access Log Service (ALS) for Envoy. Valid values:

*   `true`: enables gRPC ALS for Envoy.
*   `false`: disables gRPC ALS for Envoy.

Default value: `false`.', example='false', position='Body'),
  accessLogServiceHost?: string(name='AccessLogServiceHost', description='The endpoint of gRPC ALS for Envoy.', example='0.0.0.0', position='Body'),
  accessLogServicePort?: int32(name='AccessLogServicePort', description='The port of gRPC ALS for Envoy.', example='9999', position='Body'),
  accessLogSidecarEnabled?: boolean(name='AccessLogSidecarEnabled', position='Query'),
  accessLogSidecarLifecycle?: int32(name='AccessLogSidecarLifecycle', description='Specifies whether to enable automatic diagnostics for the ASM instance. If you enable this feature, the ASM instance is automatically diagnosed when you modify Istio resources in the ASM instance.', example='30', position='Body'),
  auditProject?: string(name='AuditProject', description='The name of the Log Service project that is used for mesh audit.

Default value: `mesh-log-{ASM instance ID}`.', example='mesh-log-c08ba3fd1e64xxb0f8cc1ad8****', position='Body'),
  autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled', description='Specifies whether to enable automatic sidecar proxy injection by using pod annotations. Valid values:

*   `true`: enables automatic sidecar proxy injection by using pod annotations.
*   `false`: disables automatic sidecar proxy injection by using pod annotations.

Default value: `false`.', example='false', position='Body'),
  CRAggregationEnabled?: boolean(name='CRAggregationEnabled', description='Specifies whether to use the Kubernetes API of clusters on the data plane to access Istio resources. To use this feature, the version of the ASM instance must be V1.9.7.93 or later.', example='false', position='Body'),
  clusterSpec?: string(name='ClusterSpec', description='Specifies whether to enable the feature of controlling the OPA injection scope. Valid values:

*   `true`: enables the feature.
*   `false`: disables the feature.', example='standard', position='Body'),
  cniEnabled?: boolean(name='CniEnabled', description='Specifies whether to enable the Container Network Interface (CNI) plug-in. Valid values:

*   `true`: enables the CNI plug-in.
*   `false`: disables the CNI plug-in.

Default value: `false`.', example='false', position='Body'),
  cniExcludeNamespaces?: string(name='CniExcludeNamespaces', description='The namespaces to be excluded for the CNI plug-in.', example='kube-system', position='Body'),
  concurrency?: int32(name='Concurrency', description='Specifies whether to delay application container startup until the sidecar proxy container is started in a pod.', example='2', position='Body'),
  configSourceEnabled?: boolean(name='ConfigSourceEnabled', description='Specifies whether to enable the external service registry. Valid values:

*   `true`: enables the external service registry.
*   `false`: disables the external service registry.

Default value: `false`.', example='false', position='Body'),
  configSourceNacosID?: string(name='ConfigSourceNacosID', description='The instance ID of the Nacos registry.', example='mse-cn-tl326******', position='Body'),
  customizedPrometheus?: boolean(name='CustomizedPrometheus', description='Specifies whether to use a custom Prometheus instance. Valid values:

*   `true`: uses a custom Prometheus instance.
*   `false`: does not use a custom Prometheus instance.

Default value: `false`.', example='false', position='Body'),
  customizedZipkin?: boolean(name='CustomizedZipkin', description='Specifies whether to use a self-managed Zipkin system to collect tracing data. Valid values:

*   `true`: uses a self-managed Zipkin system.
*   `false`: does not use a self-managed Zipkin system.

Default value: `false`.', example='false', position='Body'),
  DNSProxyingEnabled?: boolean(name='DNSProxyingEnabled', description='Specifies whether to enable DNS proxy. Valid values:

*   `true`: enables the DNS proxy feature.
*   `false`: disables the DNS proxy feature.

Default value: `false`.', example='false', position='Body'),
  defaultComponentsScheduleConfig?: string(name='DefaultComponentsScheduleConfig', description='Specifies the default scheduling configurations that ASM delivers to components on the data plane. You can configure `nodeSelector` and `tolerations` in the JSON format.

> 

*   Modifying the value of this parameter is a high-risk operation. The modification will cause all components on the data plane of ASM to restart. Exercise caution before modifying the value of this parameter.

*   The configurations specified by this parameter do not apply to the ASM gateway. You can configure gateway-specific scheduling on the ASM gateway.', example='{"tolerations":[{"key":"test-taints", "operator":"Exists", "effect":"NoSchedule"}], "nodeSelector":{"kubernetes.io/hostname":"test-nodes"}}', position='Body'),
  discoverySelectors?: string(name='DiscoverySelectors', description='The label selectors used to specify the namespaces of the clusters on the data plane for selective service discovery.', example='[{"matchExpressions":[{"key":"asm-discovery","operator":"Exists"}]}]', position='Body'),
  dubboFilterEnabled?: boolean(name='DubboFilterEnabled', description='Specifies whether to enable Dubbo Filter. Valid values:

*   `true`: enables Dubbo Filter.
*   `false`: disables Dubbo Filter.

Default value: `false`.', example='false', position='Body'),
  enableAudit?: boolean(name='EnableAudit', description='Specifies whether to enable the mesh audit feature. To enable this feature, make sure that you have activated [Log Service](https://sls.console.aliyun.com/). Valid values:

*   `true`: enables the mesh audit feature.
*   `false`: disables the mesh audit feature.

Default value: `false`.', example='false', position='Body'),
  enableAutoDiagnosis?: boolean(name='EnableAutoDiagnosis', description='The ports for which outbound traffic is redirected to the sidecar proxy.', example='true', position='Body'),
  enableBootstrapXdsAgent?: boolean(name='EnableBootstrapXdsAgent', description='Specifies the authentication token of an ARMS Prometheus instance when the Mesh Topology feature is enabled and ARMS Prometheus is used to collect monitoring metrics. The token is used to allow Mesh Topology to access the ARMS Prometheus instance. The token is in the JSON format. The key in the JSON object is the ID of the cluster on the data plane, and the value is the authentication token of the ARMS Prometheus instance deployed in the cluster.', example='true', position='Body'),
  enableCRHistory?: boolean(name='EnableCRHistory', description='Specifies whether to enable the rollback feature for Istio resources.', example='false', position='Body'),
  enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault', description='Specifies whether to enable automatic sidecar proxy injection for all namespaces. Valid values:

*   `true`: enables automatic sidecar proxy injection for all namespaces.
*   `false`: disables automatic sidecar proxy injection for all namespaces.

Default value: `false`.', example='false', position='Body'),
  enableSDSServer?: boolean(name='EnableSDSServer', description='Specifies whether to enable Secret Discovery Service (SDS). Valid values:

*   `true`: enables SDS.
*   `false`: disables SDS.

Default value: `false`.', example='false', position='Body'),
  excludeIPRanges?: string(name='ExcludeIPRanges', description='The IP addresses of external services to which traffic is not intercepted.', example='100.100.XXX.XXX', position='Body'),
  excludeInboundPorts?: string(name='ExcludeInboundPorts', description='The ports for which inbound traffic is not redirected to the sidecar proxy. Separate multiple ports with commas (,).', example='80,81', position='Body'),
  excludeOutboundPorts?: string(name='ExcludeOutboundPorts', description='The ports for which outbound traffic is not redirected to the sidecar proxy. Separate multiple ports with commas (,).', example='80,81', position='Body'),
  filterGatewayClusterConfig?: boolean(name='FilterGatewayClusterConfig', description='Specifies whether to enable gateway configuration filtering. Valid values:

*   `true`: enables gateway configuration filtering.
*   `false`: disables gateway configuration filtering.

Default value: `false`.', example='false', position='Body'),
  gatewayAPIEnabled?: boolean(name='GatewayAPIEnabled', description='Specifies whether to enable Gateway API. Valid values:

*   `true`: enables Gateway API.
*   `false`: disables Gateway API.

Default value: `false`.', example='false', position='Body'),
  holdApplicationUntilProxyStarts?: boolean(name='HoldApplicationUntilProxyStarts', description='Other metrics of the sidecar proxy on the data plane.', example='true', position='Body'),
  http10Enabled?: boolean(name='Http10Enabled', description='Specifies whether to support HTTP 1.0. Valid values:

*   `true`: supports HTTP 1.0.
*   `false`: does not support HTTP 1.0.

Default value: `false`.', example='false', position='Body'),
  includeIPRanges?: string(name='IncludeIPRanges', description='The IP addresses of external services to which traffic is intercepted.', example='*', position='Body'),
  includeInboundPorts?: string(name='IncludeInboundPorts', description='The ports for which inbound traffic is redirected to the sidecar proxy.', example='80,81', position='Body'),
  includeOutboundPorts?: string(name='IncludeOutboundPorts', description='The log level of the sidecar proxy on the data plane. Log levels include `none`, `error`, `warn`, `info`, and `debug`. The levels correspond to different amounts of information reported by the logs. For example, none-level logs report the least information, while debug-level logs report the most information.', example='8000,8001', position='Body'),
  integrateKiali?: boolean(name='IntegrateKiali', description='Specifies whether to enable Node Feature Discovery (NFD).', example='false', position='Body'),
  interceptionMode?: string(name='InterceptionMode', description='Specifies whether to load the bootstrap configuration before the sidecar proxy is started.', example='TPROXY', position='Body'),
  kialiArmsAuthTokens?: string(name='KialiArmsAuthTokens', description='Specifies the default scheduling configurations that ASM delivers to components on the data plane. You can configure `nodeSelector` and tolerations in the JSON format.

> *   Modifying the value of this parameter is a high-risk operation. The modification will cause all components on the data plane of ASM to restart. Exercise caution before modifying the value of this parameter.
>*   The configurations specified by this parameter do not apply to the ASM gateway. You can configure gateway-specific scheduling on the ASM gateway.', example='{"c31e3b******5634b":"token_example"}', position='Body'),
  kialiEnabled?: boolean(name='KialiEnabled', description='Specifies whether to enable the Mesh Topology feature. To enable this feature, make sure that you have enabled Prometheus monitoring. If Prometheus monitoring is disabled, the Mesh Topology feature must be disabled. Valid values:````

*   `true`: enables the Mesh Topology feature.
*   `false`: disables the Mesh Topology feature.

Default value: `false`.', example='false', position='Body'),
  kialiServiceAnnotations?: string(name='KialiServiceAnnotations', description='Specifies Classic Load Balancer (CLB) instances by using annotations when the Mesh Topology feature is enabled. These CLB instances are used to access the Mesh Topology feature in different clusters.

This parameter is a JSON-encoded string. The key in the JSON object is the ID of a cluster on the data plane, and the value is the annotation content of the Mesh Topology service in the cluster.

For more information about how to configure CLB instances by using annotations, see [Add annotations to the YAML file of a Service to configure CLB instances](https://www.alibabacloud.com/help/container-service-for-kubernetes/latest/use-annotations-to-configure-load-balancing-1).', example='{"c31e3b******5634b":{"service.beta.kubernetes.io/alibaba-cloud-loadbalancer-address-type":"intranet"}}', position='Body'),
  lifecycle?: string(name='Lifecycle', description='The lifecycle of the sidecar proxy.', example='{"postStart":{"exec":{"command":["pilot-agent","wait"]}},"preStop":{"exec":{"command":["/bin/sh","-c","sleep 15"]}}}', position='Body'),
  localityLBConf?: string(name='LocalityLBConf', description='The configurations of cross-region load balancing. Valid values:

*   `failover`: the configurations of cross-region failover. Example:

<!---->

    failover: [// Cross-region failover configurations of the struct type. 
            {
                // If a service fails in the China (Beijing) region, the traffic is redirected to the same service in the China (Hangzhou) region. 
                from: "cn-beijing", 
                to: "cn-hangzhou",
            }
        ]

*   `distribute`: the configurations of cross-region traffic distribution. Example:

<!---->

    distribute: [// Cross-region traffic distribution configurations of the struct type. 
            {
                // For traffic that is routed to the China (Beijing) region, 70% of the traffic is allocated to the China (Beijing) region and the rest of the traffic is redirected to the China (Hangzhou) region. 
                "from": "cn-beijing",
                "to": {
                    "cn-beijing": 70,
                    "cn-hangzhou": 30,
                }
            }
        ]', example='{"failover":[{"from":"cn-hangzhou","to":"cn-shanghai"}]}', position='Body'),
  localityLoadBalancing?: boolean(name='LocalityLoadBalancing', description='Specifies whether to enable cross-region load balancing. Valid values:

*   `true`: enables cross-region load balancing.
*   `false`: disables cross-region load balancing.

Default value: `false`.', example='true', position='Body'),
  logLevel?: string(name='LogLevel', description='The number of worker threads used by the sidecar proxy on the data plane.', example='info', position='Body'),
  MSEEnabled?: boolean(name='MSEEnabled', description='Specifies whether to enable Microservice Engine (MSE). Valid values:

*   `true`: enables MSE.
*   `false`: disables MSE.

Default value: `false`.', example='false', position='Body'),
  multiBufferEnabled?: boolean(name='MultiBufferEnabled', description='Specifies whether to enable Transport Layer Security (TLS) acceleration based on MultiBuffer.', example='false', position='Body'),
  multiBufferPollDelay?: string(name='MultiBufferPollDelay', description='The pull-request latency. By default, this parameter is left empty.', example='0.02s', position='Body'),
  mysqlFilterEnabled?: boolean(name='MysqlFilterEnabled', description='Specifies whether to enable MySQL Filter. Valid values:

*   `true`: enables MySQL Filter.
*   `false`: disables MySQL Filter.

Default value: `false`.', example='false', position='Body'),
  NFDEnabled?: boolean(name='NFDEnabled', description='Specifies whether to clear feature labels on nodes when NFD is disabled.

This parameter is valid only when the `NFDEnabled` parameter is set to `false`.', example='false', position='Body'),
  NFDLabelPruned?: boolean(name='NFDLabelPruned', description='The minimum number of CPU cores requested by the proxy service that exports Tracing Analysis data. For example, `1000m` indicates one CPU core.', example='false', position='Body'),
  OPAInjectorCPULimit?: string(name='OPAInjectorCPULimit', description='The maximum size of the memory that is available to the pod that injects OPA proxies into application pods. For example, `1024Mi` indicates 1024 MB.', example='1000m', position='Body'),
  OPAInjectorCPURequirement?: string(name='OPAInjectorCPURequirement', description='The minimum size of the memory requested by the pod that injects OPA proxies into application pods. For example, `50 Mi` indicates 50 MB.', example='80m', position='Body'),
  OPAInjectorMemoryLimit?: string(name='OPAInjectorMemoryLimit', description='Specifies whether to create a CLB instance for accessing the ASM mesh topology.', example='1024Mi', position='Body'),
  OPAInjectorMemoryRequirement?: string(name='OPAInjectorMemoryRequirement', description='The maximum number of CPU cores that are available to the pod that injects OPA proxies into application pods. For example, `1000m` indicates one CPU core.', example='50Mi', position='Body'),
  OPALimitCPU?: string(name='OPALimitCPU', description='The maximum number of CPU cores that are available to the OPA proxy container.', example='2', position='Body'),
  OPALimitMemory?: string(name='OPALimitMemory', description='The maximum size of the memory that is available to the OPA proxy container.', example='1024Mi', position='Body'),
  OPALogLevel?: string(name='OPALogLevel', description='The log level of the OPA proxy container.

*   `info`: outputs all information.
*   `debug`: outputs debugging and error information.
*   `error`: outputs only error information.', example='info', position='Body'),
  OPARequestCPU?: string(name='OPARequestCPU', description='The number of CPU cores that are requested by the OPA proxy container.', example='1', position='Body'),
  OPARequestMemory?: string(name='OPARequestMemory', description='The size of the memory that is requested by the OPA proxy container.', example='512Mi', position='Body'),
  OPAScopeInjected?: boolean(name='OPAScopeInjected', description='The minimum number of CPU cores requested by the pod that injects OPA proxies into application pods. For example, `1000m` indicates one CPU core.', example='false', position='Body'),
  opaEnabled?: boolean(name='OpaEnabled', description='Specifies whether to enable the OPA plug-in. Valid values:

*   `true`: enables the OPA plug-in.
*   `false`: disables the OPA plug-in.

Default value: `false`.', example='false', position='Body'),
  openAgentPolicy?: boolean(name='OpenAgentPolicy', description='Specifies whether to install the Open Policy Agent (OPA) plug-in. Valid values:

*   `true`: installs the OPA plug-in.
*   `false`: does not install the OPA plug-in.

Default value: `false`.', example='false', position='Body'),
  outboundTrafficPolicy?: string(name='OutboundTrafficPolicy', description='The policy for accessing external services. Valid values:

*   `ALLOW_ANY`: allows access to all external services.
*   `REGISTRY_ONLY`: allows access to only the external services that are defined in the ServiceEntry of the ASM instance.', example='ALLOW_ANY', position='Body'),
  prometheusUrl?: string(name='PrometheusUrl', description='The endpoint of Prometheus monitoring. If you use ARMS Prometheus, set this parameter to the endpoint of Prometheus provided by ARMS.', example='http://prometheus:9090', position='Body'),
  proxyInitCPUResourceLimit?: string(name='ProxyInitCPUResourceLimit', description='The maximum number of CPU cores that are available to the istio-init container.', example='2000m', position='Body'),
  proxyInitCPUResourceRequest?: string(name='ProxyInitCPUResourceRequest', description='The number of CPU cores that are requested by the istio-init container.', example='10m', position='Body'),
  proxyInitMemoryResourceLimit?: string(name='ProxyInitMemoryResourceLimit', description='The maximum size of the memory that is available to the istio-init container.', example='1024Mi', position='Body'),
  proxyInitMemoryResourceRequest?: string(name='ProxyInitMemoryResourceRequest', description='The size of the memory that is requested by the istio-init container.', example='10Mi', position='Body'),
  proxyLimitCPU?: string(name='ProxyLimitCPU', description='The maximum number of CPU cores that are available to the sidecar proxy container.', example='2000m', position='Body'),
  proxyLimitMemory?: string(name='ProxyLimitMemory', description='The maximum size of the memory that is available to the sidecar proxy container.', example='1024Mi', position='Body'),
  proxyRequestCPU?: string(name='ProxyRequestCPU', description='The number of CPU cores that are requested by the sidecar proxy container.', example='100m', position='Body'),
  proxyRequestMemory?: string(name='ProxyRequestMemory', description='The size of the memory that is requested by the sidecar proxy container.', example='128Mi', position='Body'),
  proxyStatsMatcher?: string(name='ProxyStatsMatcher', description='The mode in which the sidecar proxy intercepts inbound traffic. Valid values:

*   `REDIRECT`: The sidecar proxy intercepts inbound traffic in the REDIRECT mode.
*   `TPROXY`: The sidecar proxy intercepts inbound traffic in the TPROXY mode.', example='{"inclusionRegexps":".*adaptive_concurrency.*"}', position='Body'),
  redisFilterEnabled?: boolean(name='RedisFilterEnabled', description='Specifies whether to enable Redis Filter. Valid values:

*   `true`: enables Redis Filter.
*   `false`: disables Redis Filter.

Default value: `false`.', example='false', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='cb8963379255149cb98c8686f274x****', position='Body'),
  sidecarInjectorLimitCPU?: string(name='SidecarInjectorLimitCPU', description='The maximum number of CPU cores that are available to the pod where a sidecar proxy injector resides.', example='4000m', position='Body'),
  sidecarInjectorLimitMemory?: string(name='SidecarInjectorLimitMemory', description='The maximum size of the memory that is available to the pod where a sidecar proxy injector resides.', example='2048Mi', position='Body'),
  sidecarInjectorRequestCPU?: string(name='SidecarInjectorRequestCPU', description='The number of CPU cores that are requested by the pod where a sidecar proxy injector resides.', example='1000m', position='Body'),
  sidecarInjectorRequestMemory?: string(name='SidecarInjectorRequestMemory', description='The size of the memory that is requested by the pod where a sidecar proxy injector resides.', example='512Mi', position='Body'),
  sidecarInjectorWebhookAsYaml?: string(name='SidecarInjectorWebhookAsYaml', description='Other configurations of automatic sidecar proxy injection, in the YAML format.', example='{"injectedAnnotations":{"test/istio-init":"runtime/default2","test/istio-proxy":"runtime/default"},"replicaCount":2,"nodeSelector":{"beta.kubernetes.io/os":"linux"}}', position='Body'),
  telemetry?: boolean(name='Telemetry', description='Specifies whether to enable Prometheus monitoring. We recommend that you enable [ARMS Prometheus](https://arms.console.aliyun.com/). Valid values:

*   `true`: enables Prometheus monitoring.
*   `false`: disables Prometheus monitoring.

Default value: `false`.', example='false', position='Body'),
  terminationDrainDuration?: string(name='TerminationDrainDuration', description='The maximum period of time that the sidecar proxy waits for requests to be processed before the proxy is stopped. For example, if you want to specify a period of 5 seconds, set this parameter to 5s.', example='5s', position='Body'),
  thriftFilterEnabled?: boolean(name='ThriftFilterEnabled', description='Specifies whether to enable Thrift Filter. Valid values:

*   `true`: enables Thrift Filter.
*   `false`: disables Thrift Filter.

Default value: `false`.', example='false', position='Body'),
  traceCustomTags?: string(name='TraceCustomTags', description='The custom tag of Tracing Analysis. Specify this parameter in the JSON format.

    {
        "name1": CustomTag,
        "name2": CustomTag
    }

Tag key: literal, header, or environment.

    {
        "literal": {
            "value": "Fixed value"
        }
        "header": {
            "name": "Header name"
            "defaultValue": "Default value that is used if the specified header does not exist"
        }
        "environment": {
            "name": "Environment variable name"
            "defaultValue": "Default value that is used if the specified environment variable does not exist"
        }
    }', example='{"mytag": {"literal":{"value":"test"}}}', position='Body'),
  traceMaxPathTagLength?: string(name='TraceMaxPathTagLength', description='The maximum length of the request path contained in the HttpUrl span tag. Default value: `256`.', example='256', position='Body'),
  traceSampling?: float(name='TraceSampling', description='The sampling percentage of Tracing Analysis.', example='100', position='Body'),
  tracing?: boolean(name='Tracing', description='Specifies whether to enable the Tracing Analysis feature. To enable this feature, make sure that you have activated [Tracing Analysis](https://tracing-analysis.console.aliyun.com/). Valid values:

*   `true`: enables the Tracing Analysis feature.
*   `false`: disables the Tracing Analysis feature.

Default value: `false`.', example='false', position='Body'),
  tracingOnExtZipkinLimitCPU?: string(name='TracingOnExtZipkinLimitCPU', description='The maximum size of the memory that is available to the proxy service that exports Tracing Analysis data. For example, `1Mi` indicates 1 MB.', example='1000Mi', position='Body'),
  tracingOnExtZipkinLimitMemory?: string(name='TracingOnExtZipkinLimitMemory', description='The retention period for the access logs of the ingress gateway. Unit: day. The logs are collected by using Log Service. For example, `30` indicates 30 days.', example='1024Mi', position='Body'),
  tracingOnExtZipkinRequestCPU?: string(name='TracingOnExtZipkinRequestCPU', description='The minimum size of the memory requested by the proxy service that exports Tracing Analysis data. For example, `1Mi` indicates 1 MB.', example='200m', position='Body'),
  tracingOnExtZipkinRequestMemory?: string(name='TracingOnExtZipkinRequestMemory', description='The maximum number of CPU cores that are available to the proxy service that exports Tracing Analysis data. For example, `1000m` indicates one CPU core.', example='200Mi', position='Body'),
  webAssemblyFilterEnabled?: boolean(name='WebAssemblyFilterEnabled', description='Specifies whether to enable WebAssembly Filter. Valid values:

*   `true`: enables WebAssembly Filter.
*   `false`: disables WebAssembly Filter.

Default value: `false`.', example='false', position='Body'),
}

model UpdateMeshFeatureResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model UpdateMeshFeatureResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMeshFeatureResponseBody(name='body'),
}

async function updateMeshFeature(request: UpdateMeshFeatureRequest): UpdateMeshFeatureResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMeshFeature', 'POST', '/', 'json', true, 'form', request);
}

model UpdateNamespaceScopeSidecarConfigRequest {
  concurrency?: int32(name='Concurrency', description='The number of worker threads to run in Istio Proxy.', example='2', position='Body'),
  enableCoreDump?: boolean(name='EnableCoreDump', example='false', position='Body'),
  excludeIPRanges?: string(name='ExcludeIPRanges', description='The range of IP addresses that are allowed to access external services. (`global.proxy.excludelPRanges`)', example='172.16.0.0/12', position='Body'),
  excludeInboundPorts?: string(name='ExcludeInboundPorts', description='The port that the inbound traffic of the sidecar proxy does not pass through.', example='82', position='Body'),
  excludeOutboundPorts?: string(name='ExcludeOutboundPorts', description='The port that the outbound traffic of the sidecar proxy does not pass through.', example='81', position='Body'),
  holdApplicationUntilProxyStarts?: boolean(name='HoldApplicationUntilProxyStarts', description='Specifies whether applications can be started only after Istio Proxy starts. Valid values:

*   `true`: Applications can be started only after Istio Proxy starts.
*   `false`: Applications can be started before Istio Proxy starts.', example='true', position='Body'),
  includeIPRanges?: string(name='IncludeIPRanges', description='The range of IP addresses that are denied to access external services. (`global.proxy.includelPRanges`)', example='*', position='Body'),
  includeInboundPorts?: string(name='IncludeInboundPorts', description='The port that the inbound traffic of the sidecar proxy passes through.', example='83', position='Body'),
  includeOutboundPorts?: string(name='IncludeOutboundPorts', description='The port that the outbound traffic of the sidecar proxy passes through.', example='84', position='Body'),
  interceptionMode?: string(name='InterceptionMode', description='The mode in which the sidecar proxy intercepts inbound traffic. Valid values:

*   `REDIRECT`: The sidecar proxy intercepts inbound traffic in the REDIRECT mode.
*   `TPROXY`: The sidecar proxy intercepts inbound traffic in the TPROXY mode.', example='TPROXY', position='Body'),
  istioDNSProxyEnabled?: boolean(name='IstioDNSProxyEnabled', description='Specifies whether to enable the Domain Name System (DNS) proxy feature. Valid values:

*   `true`: The DNS proxy feature is enabled.
*   `false`: The DNS proxy feature is disabled.', example='true', position='Body'),
  lifecycle?: string(name='Lifecycle', description='The lifecycle of the sidecar proxy.', example='{"postStart":{"exec":{"command":["pilot-agent","wait"]}},"preStop":{"exec":{"command":["/bin/sh","-c","sleep 15"]}}}', position='Body'),
  logLevel?: string(name='LogLevel', description='The log level. Valid values: `info`, `debug`, `tracing`, and `error`.', example='info', position='Body'),
  namespace?: string(name='Namespace', description='The namespace for which you want to update the sidecar proxy configurations.', example='default', position='Body'),
  postStart?: string(name='PostStart', description='The post-start parameters of Istio Proxy.', example='{"exec":{"command":["pilot-agent","wait"]}}', position='Body'),
  preStop?: string(name='PreStop', description='The pre-close parameters of Istio Proxy.', example='{"exec":{"command":["/bin/sh","-c","sleep 15"]}}', position='Body'),
  privileged?: boolean(name='Privileged', example='false', position='Body'),
  proxyInitAckSloCPUResourceLimit?: string(name='ProxyInitAckSloCPUResourceLimit', example='2000', position='Body'),
  proxyInitAckSloCPUResourceRequest?: string(name='ProxyInitAckSloCPUResourceRequest', example='100', position='Body'),
  proxyInitAckSloMemoryResourceLimit?: string(name='ProxyInitAckSloMemoryResourceLimit', example='2048Mi', position='Body'),
  proxyInitAckSloMemoryResourceRequest?: string(name='ProxyInitAckSloMemoryResourceRequest', example='128Mi', position='Body'),
  proxyInitCPUResourceLimit?: string(name='ProxyInitCPUResourceLimit', description='The maximum number of CPU cores that are available to the sidecar proxy init container.', example='2000 m', position='Body'),
  proxyInitCPUResourceRequest?: string(name='ProxyInitCPUResourceRequest', description='The minimum number of CPU cores that are requested by the sidecar proxy init container.', example='60 m', position='Body'),
  proxyInitMemoryResourceLimit?: string(name='ProxyInitMemoryResourceLimit', description='The maximum size of memory that is available to the sidecar proxy init container.', example='50 Mi', position='Body'),
  proxyInitMemoryResourceRequest?: string(name='ProxyInitMemoryResourceRequest', description='The minimum size of memory that is requested by the sidecar proxy init container.', example='30 Mi', position='Body'),
  proxyMetadata?: string(name='ProxyMetadata', description='The environment variables that are added to a sidecar proxy. The environment variables are represented as JSON objects. The keys and values in the JSON objects represent the keys and values added to the environment variables of the sidecar proxy.', example='{"EXIT_ON_ZERO_ACTIVE_CONNECTIONS":"true"}', position='Body'),
  proxyStatsMatcher?: string(name='ProxyStatsMatcher', description='The monitoring metrics for data collected by Envoy proxies. The value is in the JSON format.', example='{ "inclusionPrefixes": [ "cluster.outbound", "cluster_manager", "listener_manager", "server", "cluster.xds-grpc" ], "inclusionRegexps": [ "listener.*.downstream_cx_total", "listener.*.downstream_cx_active" ] }', position='Body'),
  readinessFailureThreshold?: int32(name='ReadinessFailureThreshold', example='5', position='Body'),
  readinessInitialDelaySeconds?: int32(name='ReadinessInitialDelaySeconds', example='1', position='Body'),
  readinessPeriodSeconds?: int32(name='ReadinessPeriodSeconds', example='2', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='ca04bc38979214bf2882be79d39b4****', position='Body'),
  sidecarProxyAckSloCPUResourceLimit?: string(name='SidecarProxyAckSloCPUResourceLimit', example='2000', position='Body'),
  sidecarProxyAckSloCPUResourceRequest?: string(name='SidecarProxyAckSloCPUResourceRequest', example='100', position='Body'),
  sidecarProxyAckSloMemoryResourceLimit?: string(name='SidecarProxyAckSloMemoryResourceLimit', example='2048Mi', position='Body'),
  sidecarProxyAckSloMemoryResourceRequest?: string(name='SidecarProxyAckSloMemoryResourceRequest', example='128Mi', position='Body'),
  sidecarProxyCPUResourceLimit?: string(name='SidecarProxyCPUResourceLimit', description='The maximum number of CPU cores that are available to the sidecar proxy container.', example='2000 m', position='Body'),
  sidecarProxyCPUResourceRequest?: string(name='SidecarProxyCPUResourceRequest', description='The minimum number of CPU cores that are requested by the sidecar proxy container.', example='60 m', position='Body'),
  sidecarProxyMemoryResourceLimit?: string(name='SidecarProxyMemoryResourceLimit', description='The maximum size of memory that is available to the sidecar proxy container.', example='50 Mi', position='Body'),
  sidecarProxyMemoryResourceRequest?: string(name='SidecarProxyMemoryResourceRequest', description='The minimum size of memory that is requested by the sidecar proxy container.', example='30 Mi', position='Body'),
  terminationDrainDuration?: string(name='TerminationDrainDuration', description='The maximum period of time that the sidecar proxy waits for a request to end.', example='6s', position='Body'),
  tracing?: string(name='Tracing', description='The custom configurations of Tracing Analysis. The configurations must be serialized into JSON strings. The configurations contain the following parameters:

*   `sampling`: The sampling rate, which is of the DOUBLE type.

*   `custom_tags`: The custom tags added to reported spans, which are of the MAP type. The key of a tag is of the string type. The value of a tag is in the JSON format. A custom tag can belong to one of the following types:

    *   `literal`: The tag value is a fixed value in the JSON format. This tag must contain the `value` field that specifies a literal. Example: `{"value":"test"}`.
    *   `header`: The tag value is a request header in the JSON format. This tag must contain the `name` field and `defaultValue` field.The name field indicates the name of the request header. The defaultValue field indicates the default value that is used when no request header is available. Example: `{"name":"test","defaultValue":"test"}`.
    *   `environment`: The tag value is an environment variable in the JSON format. This tag must contain the `name` field and `defaultValue` field. The name field indicates the name of the environment variable. The defaultValue field indicates the environment variable that is used when no environment variable is available. Example: `{"name":"test","defaultValue":"test"}`.', example='{"sampling":99.8,"custom_tags":{"test":{"literal":{"value":"testnamespace"}}}}', position='Body'),
}

model UpdateNamespaceScopeSidecarConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model UpdateNamespaceScopeSidecarConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateNamespaceScopeSidecarConfigResponseBody(name='body'),
}

async function updateNamespaceScopeSidecarConfig(request: UpdateNamespaceScopeSidecarConfigRequest): UpdateNamespaceScopeSidecarConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateNamespaceScopeSidecarConfig', 'POST', '/', 'json', true, 'form', request);
}

model UpdateSwimLaneRequest {
  groupName?: string(name='GroupName', description='The name of the lane group.', example='test', position='Body'),
  labelSelectorKey?: string(name='LabelSelectorKey', description='The label key of the associated service workload. Set the value to `ASM_TRAFFIC_TAG`.', example='ASM_TRAFFIC_TAG', position='Body'),
  labelSelectorValue?: string(name='LabelSelectorValue', description='The label value of the associated service workload.``', example='v1', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ID of the Service Mesh (ASM) instance.', example='xxx', position='Body'),
  servicesList?: string(name='ServicesList', description='A list of services associated with the lane.', example='["sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mocka","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockb","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockc"]', position='Body'),
  swimLaneName?: string(name='SwimLaneName', description='The name of the lane.', example='s1', position='Body'),
}

model UpdateSwimLaneResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='yyy'),
}

model UpdateSwimLaneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSwimLaneResponseBody(name='body'),
}

async function updateSwimLane(request: UpdateSwimLaneRequest): UpdateSwimLaneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSwimLane', 'POST', '/', 'json', true, 'form', request);
}

model UpdateSwimLaneGroupRequest {
  fallbackTarget?: string(name='FallbackTarget', position='Body'),
  groupName?: string(name='GroupName', description='The name of the lane group.', example='test', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The Service Mesh (ASM) instance ID.', example='xxx', position='Body'),
  servicesList?: string(name='ServicesList', description='A list of services associated with the lane group.', example='["sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mocka","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockb","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockc"]', position='Body'),
}

model UpdateSwimLaneGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='yyy'),
}

model UpdateSwimLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSwimLaneGroupResponseBody(name='body'),
}

async function updateSwimLaneGroup(request: UpdateSwimLaneGroupRequest): UpdateSwimLaneGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSwimLaneGroup', 'POST', '/', 'json', true, 'form', request);
}

model UpdateWaypointRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster on the data plane.', example='ce3c25e247da24f3aab9b7edfae83****', minLength=1, position='Body'),
  HPAEnabled?: boolean(name='HPAEnabled', description='Specifies whether to enable Horizontal Pod Autoscaling (HPA).', example='false', position='Body'),
  HPAMaxReplicas?: int32(name='HPAMaxReplicas', description='The maximum number of waypoint proxy pods when HPA is enabled.', example='4', minimum=0, position='Body'),
  HPAMinReplicas?: int32(name='HPAMinReplicas', description='The minimum number of waypoint proxy pods when HPA is enabled.', example='2', minimum=0, position='Body'),
  HPATargetCPU?: int32(name='HPATargetCPU', description='The expected CPU utilization when HPA is enabled.', example='91', minimum=0, maximum=100, position='Body'),
  HPATargetMemory?: int32(name='HPATargetMemory', description='The expected memory usage when HPA is enabled.', example='89', minimum=0, maximum=100, position='Body'),
  limitCPU?: string(name='LimitCPU', description='The maximum number of CPU cores that are available to the waypoint proxy pods.', example='2000m', position='Body'),
  limitMemory?: string(name='LimitMemory', description='The maximum size of the memory that is available to the waypoint proxy pods.', example='1024Mi', position='Body'),
  name: string(name='Name', description='Waypoint', example='bookinfo-reviews', position='Body'),
  namespace: string(name='Namespace', description='The namespace.', example='default', position='Body'),
  preferECI?: boolean(name='PreferECI', description='Specifies whether to deploy waypoint proxy pods based on Elastic Container Instance (ECI).', example='false', position='Body'),
  replicas?: int32(name='Replicas', description='The number of waypoint proxy pods.', example='1', minimum=0, position='Body'),
  requestCPU?: string(name='RequestCPU', description='The number of CPU cores requested by the waypoint proxy pods.', example='100m', position='Body'),
  requestMemory?: string(name='RequestMemory', description='The size of the memory requested by the waypoint proxy pods.', example='128Mi', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The Service Mesh (ASM) instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', minLength=1, position='Body'),
}

model UpdateWaypointResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='71680038-8009-5073-B43E-C057E9******'),
}

model UpdateWaypointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateWaypointResponseBody(name='body'),
}

async function updateWaypoint(request: UpdateWaypointRequest): UpdateWaypointResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateWaypoint', 'POST', '/', 'json', true, 'form', request);
}

model UpgradeMeshEditionPartiallyRequest {
  ASMGatewayContinue?: boolean(name='ASMGatewayContinue', description='Specifies whether to upgrade the ASM gateways for the ASM instance. Valid values:

*   `true`
*   `false`', example='true', position='Body'),
  expectedVersion?: string(name='ExpectedVersion', example='v1.15.3.118-g4712daf0-aliyun', position='Body'),
  preCheck?: boolean(name='PreCheck', description='Specifies whether to perform an upgrade check. If the value of this parameter is set to true, only the upgrade check is performed and the ASM instance is not upgraded.', example='true', position='Body'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='ca04bc38979214bf2882be79d39b4****', position='Body'),
  switchToPro?: boolean(name='SwitchToPro', description='Specifies whether to upgrade the ASM instance to Professional Edition. Valid values:

*   `true`
*   `false`', example='true', deprecated='true', position='Body'),
  upgradeGatewayRecords?: string(name='UpgradeGatewayRecords', description='Specifies the ASM gateways to be upgraded. Separate multiple ASM gateways with commas (,).', example='ingressgateway1,ingressgateway2', position='Body'),
}

model UpgradeMeshEditionPartiallyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model UpgradeMeshEditionPartiallyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeMeshEditionPartiallyResponseBody(name='body'),
}

async function upgradeMeshEditionPartially(request: UpgradeMeshEditionPartiallyRequest): UpgradeMeshEditionPartiallyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeMeshEditionPartially', 'POST', '/', 'json', true, 'form', request);
}

model UpgradeMeshVersionRequest {
  preCheck?: boolean(name='PreCheck', description='Specifies whether to perform a precheck. Default value: false. If this parameter is set to true, this call only checks whether the current ASM instance meets the upgrade conditions and does not actually perform an upgrade.', example='false', position='Query'),
  serviceMeshId: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****', position='Query'),
}

model UpgradeMeshVersionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='11fd0027-c27e-41bb-a565-75583054****'),
}

model UpgradeMeshVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeMeshVersionResponseBody(name='body'),
}

async function upgradeMeshVersion(request: UpgradeMeshVersionRequest): UpgradeMeshVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeMeshVersion', 'POST', '/', 'json', false, 'json', request);
}

model SecretCreateRecordValue = {
  state?: string(name='State', description='The result of creating the secret. Valid values:

*   `success`: The secret was created.
*   `fail`: The secret failed to be created.', example='success'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster on the data plane.', example='c08ba3fd1e6484b0f8cc1ad8xe10d****'),
  message?: string(name='Message', description='The error message returned when exceptions occur. Otherwise, an empty value is returned.', example='timeout'),
}

model SecretDeleteRecordValue = {
  state?: string(name='State', description='The result of deleting the secret. Valid values:

*   `success`: The secret was deleted.
*   `fail`: The secret failed to be deleted.', example='success'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
  message?: string(name='Message', description='The error message returned when exceptions occur. Otherwise, an empty value is returned.', example='timeout'),
}

model CCMVersionsValue = {
  queryState?: string(name='QueryState', example='time_out'),
  version?: string(name='Version', example='v2.0.1'),
  SLBGracefulDrainSupport?: boolean(name='SLBGracefulDrainSupport', example='true'),
  clusterId?: string(name='ClusterId', example='cfbb81b9b51a44b299349xxxxxxxxxxxx'),
  message?: string(name='Message', example='timeout error'),
}

model UpgradeDetailGatewayStatusRecordValue = {
  status?: string(name='Status', description='The upgrade status of the ingress gateway. Valid values:

*   `upgrading`: The ingress gateway is being upgraded.
*   `pending`: The ingress gateway waits to be upgraded.
*   `finished`: The ingress gateway upgrade is complete.
*   `notStart`: The ingress gateway upgrade does not start.
*   `failed`: The ingress gateway upgrade fails.
*   `unknown`: The upgrade status of the ingress gateway is unknown.', example='upgrading'),
  message?: string(name='Message', description='Additional status information of the ingress gateway.', example='success'),
  version?: string(name='Version', description='The version of the ingress gateway.', example='1.9.7'),
}

