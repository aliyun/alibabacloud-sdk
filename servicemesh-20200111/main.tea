/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('servicemesh', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model RunDiagnosisRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model RunDiagnosisResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model RunDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  body: RunDiagnosisResponseBody(name='body'),
}

async function runDiagnosisWithOptions(request: RunDiagnosisRequest, runtime: Util.RuntimeOptions): RunDiagnosisResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RunDiagnosis', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function runDiagnosis(request: RunDiagnosisRequest): RunDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  return runDiagnosisWithOptions(request, runtime);
}

model DescribeGuestClusterAccessLogDashboardsRequest {
  k8sClusterId?: string(name='K8sClusterId'),
}

model DescribeGuestClusterAccessLogDashboardsResponseBody = {
  requestId?: string(name='RequestId'),
  dashboards?: [ 
    {
      url?: string(name='Url'),
      title?: string(name='Title'),
    }
  ](name='Dashboards'),
  k8sClusterId?: string(name='K8sClusterId'),
}

model DescribeGuestClusterAccessLogDashboardsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGuestClusterAccessLogDashboardsResponseBody(name='body'),
}

async function describeGuestClusterAccessLogDashboardsWithOptions(request: DescribeGuestClusterAccessLogDashboardsRequest, runtime: Util.RuntimeOptions): DescribeGuestClusterAccessLogDashboardsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeGuestClusterAccessLogDashboards', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeGuestClusterAccessLogDashboards(request: DescribeGuestClusterAccessLogDashboardsRequest): DescribeGuestClusterAccessLogDashboardsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGuestClusterAccessLogDashboardsWithOptions(request, runtime);
}

model ListBuiltinEnvoyFilterRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  id?: string(name='Id'),
}

model ListBuiltinEnvoyFilterResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model ListBuiltinEnvoyFilterResponse = {
  headers: map[string]string(name='headers'),
  body: ListBuiltinEnvoyFilterResponseBody(name='body'),
}

async function listBuiltinEnvoyFilterWithOptions(request: ListBuiltinEnvoyFilterRequest, runtime: Util.RuntimeOptions): ListBuiltinEnvoyFilterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListBuiltinEnvoyFilter', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listBuiltinEnvoyFilter(request: ListBuiltinEnvoyFilterRequest): ListBuiltinEnvoyFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBuiltinEnvoyFilterWithOptions(request, runtime);
}

model DescribeServiceMeshesResponseBody = {
  requestId?: string(name='RequestId'),
  serviceMeshes?: [ 
    {
      endpoints?: {
        intranetPilotEndpoint?: string(name='IntranetPilotEndpoint'),
        reverseTunnelEndpoint?: string(name='ReverseTunnelEndpoint'),
        publicPilotEndpoint?: string(name='PublicPilotEndpoint'),
        intranetApiServerEndpoint?: string(name='IntranetApiServerEndpoint'),
        publicApiServerEndpoint?: string(name='PublicApiServerEndpoint'),
      }(name='Endpoints'),
      serviceMeshInfo?: {
        profile?: string(name='Profile'),
        creationTime?: string(name='CreationTime'),
        updateTime?: string(name='UpdateTime'),
        errorMessage?: string(name='ErrorMessage'),
        version?: string(name='Version'),
        state?: string(name='State'),
        serviceMeshId?: string(name='ServiceMeshId'),
        name?: string(name='Name'),
        regionId?: string(name='RegionId'),
      }(name='ServiceMeshInfo'),
      spec?: {
        network?: {
          vpcId?: string(name='VpcId'),
          securityGroupId?: string(name='SecurityGroupId'),
          vSwitches?: [ string ](name='VSwitches'),
        }(name='Network'),
        loadBalancer?: {
          pilotPublicEip?: boolean(name='PilotPublicEip'),
          pilotPublicLoadbalancerId?: string(name='PilotPublicLoadbalancerId'),
          apiServerLoadbalancerId?: string(name='ApiServerLoadbalancerId'),
          apiServerPublicEip?: boolean(name='ApiServerPublicEip'),
        }(name='LoadBalancer'),
        meshConfig?: {
          telemetry?: boolean(name='Telemetry'),
          outboundTrafficPolicy?: string(name='OutboundTrafficPolicy'),
          tracing?: boolean(name='Tracing'),
          strictMtls?: boolean(name='StrictMtls'),
          pilot?: {
            http10Enabled?: boolean(name='Http10Enabled'),
            traceSampling?: float(name='TraceSampling'),
          }(name='Pilot'),
          mtls?: boolean(name='Mtls'),
          sidecarInjector?: {
            enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault'),
            autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled'),
            initCNIConfiguration?: {
              excludeNamespaces?: string(name='ExcludeNamespaces'),
              enabled?: boolean(name='Enabled'),
            }(name='InitCNIConfiguration'),
          }(name='SidecarInjector'),
        }(name='MeshConfig'),
      }(name='Spec'),
      clusters?: [ string ](name='Clusters'),
    }
  ](name='ServiceMeshes'),
}

model DescribeServiceMeshesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServiceMeshesResponseBody(name='body'),
}

async function describeServiceMeshesWithOptions(runtime: Util.RuntimeOptions): DescribeServiceMeshesResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('DescribeServiceMeshes', '2020-01-11', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeServiceMeshes(): DescribeServiceMeshesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshesWithOptions(runtime);
}

model ModifyBuiltinEnvoyFilterRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  parameters?: string(name='Parameters'),
  istioVersion?: string(name='IstioVersion'),
}

model ModifyBuiltinEnvoyFilterResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBuiltinEnvoyFilterResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBuiltinEnvoyFilterResponseBody(name='body'),
}

async function modifyBuiltinEnvoyFilterWithOptions(request: ModifyBuiltinEnvoyFilterRequest, runtime: Util.RuntimeOptions): ModifyBuiltinEnvoyFilterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyBuiltinEnvoyFilter', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyBuiltinEnvoyFilter(request: ModifyBuiltinEnvoyFilterRequest): ModifyBuiltinEnvoyFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBuiltinEnvoyFilterWithOptions(request, runtime);
}

model DescribeAvailableNacosInstancesRequest {
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
}

model DescribeAvailableNacosInstancesResponseBody = {
  requestId?: string(name='RequestId'),
  data?: [ string ](name='Data'),
}

model DescribeAvailableNacosInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableNacosInstancesResponseBody(name='body'),
}

async function describeAvailableNacosInstancesWithOptions(request: DescribeAvailableNacosInstancesRequest, runtime: Util.RuntimeOptions): DescribeAvailableNacosInstancesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeAvailableNacosInstances', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeAvailableNacosInstances(request: DescribeAvailableNacosInstancesRequest): DescribeAvailableNacosInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableNacosInstancesWithOptions(request, runtime);
}

model DescribeIngressGatewaysRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeIngressGatewaysResponseBody = {
  requestId?: string(name='RequestId'),
  ingressGateways?: [  map[string]any ](name='IngressGateways'),
}

model DescribeIngressGatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIngressGatewaysResponseBody(name='body'),
}

async function describeIngressGatewaysWithOptions(request: DescribeIngressGatewaysRequest, runtime: Util.RuntimeOptions): DescribeIngressGatewaysResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeIngressGateways', '2020-01-11', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeIngressGateways(request: DescribeIngressGatewaysRequest): DescribeIngressGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIngressGatewaysWithOptions(request, runtime);
}

model DescribeServiceMeshDetailRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeServiceMeshDetailResponseBody = {
  requestId?: string(name='RequestId'),
  serviceMesh?: {
    endpoints?: {
      intranetPilotEndpoint?: string(name='IntranetPilotEndpoint'),
      publicPilotEndpoint?: string(name='PublicPilotEndpoint'),
      intranetApiServerEndpoint?: string(name='IntranetApiServerEndpoint'),
      publicApiServerEndpoint?: string(name='PublicApiServerEndpoint'),
    }(name='Endpoints'),
    serviceMeshInfo?: {
      profile?: string(name='Profile'),
      creationTime?: string(name='CreationTime'),
      updateTime?: string(name='UpdateTime'),
      errorMessage?: string(name='ErrorMessage'),
      version?: string(name='Version'),
      state?: string(name='State'),
      serviceMeshId?: string(name='ServiceMeshId'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
    }(name='ServiceMeshInfo'),
    spec?: {
      network?: {
        vpcId?: string(name='VpcId'),
        securityGroupId?: string(name='SecurityGroupId'),
        vSwitches?: [ string ](name='VSwitches'),
      }(name='Network'),
      loadBalancer?: {
        pilotPublicEip?: boolean(name='PilotPublicEip'),
        pilotPublicLoadbalancerId?: string(name='PilotPublicLoadbalancerId'),
        apiServerLoadbalancerId?: string(name='ApiServerLoadbalancerId'),
        apiServerPublicEip?: boolean(name='ApiServerPublicEip'),
      }(name='LoadBalancer'),
      meshConfig?: {
        OPA?: {
          requestMemory?: string(name='RequestMemory'),
          logLevel?: string(name='LogLevel'),
          enabled?: boolean(name='Enabled'),
          limitMemory?: string(name='LimitMemory'),
          requestCPU?: string(name='RequestCPU'),
          limitCPU?: string(name='LimitCPU'),
        }(name='OPA'),
        prometheus?: {
          useExternal?: boolean(name='UseExternal'),
          externalUrl?: string(name='ExternalUrl'),
        }(name='Prometheus'),
        accessLog?: {
          enabled?: boolean(name='Enabled'),
        }(name='AccessLog'),
        pilot?: {
          http10Enabled?: boolean(name='Http10Enabled'),
          traceSampling?: float(name='TraceSampling'),
          feature?: {
            filterGatewayClusterConfig?: boolean(name='FilterGatewayClusterConfig'),
            enableSDSServer?: boolean(name='EnableSDSServer'),
          }(name='Feature'),
        }(name='Pilot'),
        MSE?: {
          enabled?: boolean(name='Enabled'),
        }(name='MSE'),
        customizedZipkin?: boolean(name='CustomizedZipkin'),
        sidecarInjector?: {
          enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault'),
          requestMemory?: string(name='RequestMemory'),
          limitMemory?: string(name='LimitMemory'),
          requestCPU?: string(name='RequestCPU'),
          autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled'),
          limitCPU?: string(name='LimitCPU'),
          initCNIConfiguration?: {
            excludeNamespaces?: string(name='ExcludeNamespaces'),
            enabled?: boolean(name='Enabled'),
          }(name='InitCNIConfiguration'),
          sidecarInjectorWebhookAsYaml?: string(name='SidecarInjectorWebhookAsYaml'),
        }(name='SidecarInjector'),
        includeIPRanges?: string(name='IncludeIPRanges'),
        excludeIPRanges?: string(name='ExcludeIPRanges'),
        excludeOutboundPorts?: string(name='ExcludeOutboundPorts'),
        excludeInboundPorts?: string(name='ExcludeInboundPorts'),
        telemetry?: boolean(name='Telemetry'),
        edition?: string(name='Edition'),
        protocolSupport?: {
          mysqlFilterEnabled?: boolean(name='MysqlFilterEnabled'),
          redisFilterEnabled?: boolean(name='RedisFilterEnabled'),
          thriftFilterEnabled?: boolean(name='ThriftFilterEnabled'),
          dubboFilterEnabled?: boolean(name='DubboFilterEnabled'),
        }(name='ProtocolSupport'),
        outboundTrafficPolicy?: string(name='OutboundTrafficPolicy'),
        kiali?: {
          enabled?: boolean(name='Enabled'),
          url?: string(name='Url'),
        }(name='Kiali'),
        tracing?: boolean(name='Tracing'),
        webAssemblyFilterDeployment?: {
          enabled?: boolean(name='Enabled'),
        }(name='WebAssemblyFilterDeployment'),
        enableLocalityLB?: boolean(name='EnableLocalityLB'),
        audit?: {
          enabled?: boolean(name='Enabled'),
          project?: string(name='Project'),
        }(name='Audit'),
        proxy?: {
          requestMemory?: string(name='RequestMemory'),
          clusterDomain?: string(name='ClusterDomain'),
          limitMemory?: string(name='LimitMemory'),
          requestCPU?: string(name='RequestCPU'),
          enableDNSProxying?: boolean(name='EnableDNSProxying'),
          limitCPU?: string(name='LimitCPU'),
          accessLogServiceEnabled?: boolean(name='AccessLogServiceEnabled'),
          accessLogServiceHost?: string(name='AccessLogServiceHost'),
          accessLogServicePort?: int32(name='AccessLogServicePort'),
        }(name='Proxy'),
        k8sNewAPIsSupport?: {
          gatewayAPIEnabled?: boolean(name='GatewayAPIEnabled'),
        }(name='K8sNewAPIsSupport'),
      }(name='MeshConfig'),
    }(name='Spec'),
    clusters?: [ string ](name='Clusters'),
  }(name='ServiceMesh'),
}

model DescribeServiceMeshDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServiceMeshDetailResponseBody(name='body'),
}

async function describeServiceMeshDetailWithOptions(request: DescribeServiceMeshDetailRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshDetailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeServiceMeshDetail', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeServiceMeshDetail(request: DescribeServiceMeshDetailRequest): DescribeServiceMeshDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshDetailWithOptions(request, runtime);
}

model UpgradeMeshVersionRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model UpgradeMeshVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpgradeMeshVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeMeshVersionResponseBody(name='body'),
}

async function upgradeMeshVersionWithOptions(request: UpgradeMeshVersionRequest, runtime: Util.RuntimeOptions): UpgradeMeshVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpgradeMeshVersion', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function upgradeMeshVersion(request: UpgradeMeshVersionRequest): UpgradeMeshVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeMeshVersionWithOptions(request, runtime);
}

model DescribeServiceMeshKubeconfigRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  privateIpAddress?: boolean(name='PrivateIpAddress'),
}

model DescribeServiceMeshKubeconfigResponseBody = {
  requestId?: string(name='RequestId'),
  kubeconfig?: string(name='Kubeconfig'),
}

model DescribeServiceMeshKubeconfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServiceMeshKubeconfigResponseBody(name='body'),
}

async function describeServiceMeshKubeconfigWithOptions(request: DescribeServiceMeshKubeconfigRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshKubeconfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeServiceMeshKubeconfig', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeServiceMeshKubeconfig(request: DescribeServiceMeshKubeconfigRequest): DescribeServiceMeshKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshKubeconfigWithOptions(request, runtime);
}

model GetCaCertRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetCaCertResponseBody = {
  requestId?: string(name='RequestId'),
  caCert?: string(name='CaCert', description='base64 encode format'),
}

model GetCaCertResponse = {
  headers: map[string]string(name='headers'),
  body: GetCaCertResponseBody(name='body'),
}

async function getCaCertWithOptions(request: GetCaCertRequest, runtime: Util.RuntimeOptions): GetCaCertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetCaCert', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getCaCert(request: GetCaCertRequest): GetCaCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCaCertWithOptions(request, runtime);
}

model GetServiceMeshSlbRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetServiceMeshSlbResponseBody = {
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      status?: string(name='Status'),
      serverHealthStatus?: string(name='ServerHealthStatus'),
      loadBalancerId?: string(name='LoadBalancerId'),
    }
  ](name='Data'),
}

model GetServiceMeshSlbResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceMeshSlbResponseBody(name='body'),
}

async function getServiceMeshSlbWithOptions(request: GetServiceMeshSlbRequest, runtime: Util.RuntimeOptions): GetServiceMeshSlbResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetServiceMeshSlb', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getServiceMeshSlb(request: GetServiceMeshSlbRequest): GetServiceMeshSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServiceMeshSlbWithOptions(request, runtime);
}

model GetRegisteredServiceEndpointsRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  namespace?: string(name='Namespace'),
  name?: string(name='Name'),
}

model GetRegisteredServiceEndpointsResponseBody = {
  serviceEndpoints?: [ 
    {
      address?: string(name='Address'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='ServiceEndpoints'),
  requestId?: string(name='RequestId'),
}

model GetRegisteredServiceEndpointsResponse = {
  headers: map[string]string(name='headers'),
  body: GetRegisteredServiceEndpointsResponseBody(name='body'),
}

async function getRegisteredServiceEndpointsWithOptions(request: GetRegisteredServiceEndpointsRequest, runtime: Util.RuntimeOptions): GetRegisteredServiceEndpointsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRegisteredServiceEndpoints', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRegisteredServiceEndpoints(request: GetRegisteredServiceEndpointsRequest): GetRegisteredServiceEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegisteredServiceEndpointsWithOptions(request, runtime);
}

model GetAutoInjectionLabelSyncStatusRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetAutoInjectionLabelSyncStatusResponseBody = {
  status?: string(name='Status'),
  requestId?: string(name='RequestId'),
}

model GetAutoInjectionLabelSyncStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetAutoInjectionLabelSyncStatusResponseBody(name='body'),
}

async function getAutoInjectionLabelSyncStatusWithOptions(request: GetAutoInjectionLabelSyncStatusRequest, runtime: Util.RuntimeOptions): GetAutoInjectionLabelSyncStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetAutoInjectionLabelSyncStatus', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getAutoInjectionLabelSyncStatus(request: GetAutoInjectionLabelSyncStatusRequest): GetAutoInjectionLabelSyncStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAutoInjectionLabelSyncStatusWithOptions(request, runtime);
}

model GetRegisteredServiceNamespacesRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetRegisteredServiceNamespacesResponseBody = {
  namespaces?: [ string ](name='Namespaces'),
  requestId?: string(name='RequestId'),
}

model GetRegisteredServiceNamespacesResponse = {
  headers: map[string]string(name='headers'),
  body: GetRegisteredServiceNamespacesResponseBody(name='body'),
}

async function getRegisteredServiceNamespacesWithOptions(request: GetRegisteredServiceNamespacesRequest, runtime: Util.RuntimeOptions): GetRegisteredServiceNamespacesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRegisteredServiceNamespaces', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRegisteredServiceNamespaces(request: GetRegisteredServiceNamespacesRequest): GetRegisteredServiceNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegisteredServiceNamespacesWithOptions(request, runtime);
}

model DescribeVSwitchesRequest {
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
}

model DescribeVSwitchesResponseBody = {
  totalCount?: int32(name='TotalCount', description='TotalCount本次请求条件下的数据总量，此参数为可选参数，默认可不返回'),
  requestId?: string(name='RequestId', description='Id of the request'),
  nextToken?: string(name='NextToken', description='表示当前调用返回读取到的位置，空代表数据已经读取完毕'),
  maxResults?: int32(name='MaxResults', description='MaxResults本次请求所返回的最大记录条数'),
  vSwitches?: [ 
    {
      vpcId?: string(name='VpcId'),
      vSwitchId?: string(name='VSwitchId'),
      status?: string(name='Status'),
      isDefault?: boolean(name='IsDefault'),
      vSwitchName?: string(name='VSwitchName'),
    }
  ](name='VSwitches', description='VSwitches'),
}

model DescribeVSwitchesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVSwitchesResponseBody(name='body'),
}

async function describeVSwitchesWithOptions(request: DescribeVSwitchesRequest, runtime: Util.RuntimeOptions): DescribeVSwitchesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVSwitches', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVSwitchesWithOptions(request, runtime);
}

model DescribeVpcsRequest {
  regionId?: string(name='RegionId'),
}

model DescribeVpcsResponseBody = {
  totalCount?: int32(name='TotalCount', description='TotalCount本次请求条件下的数据总量，此参数为可选参数，默认可不返回'),
  requestId?: string(name='RequestId', description='Id of the request'),
  nextToken?: string(name='NextToken', description='表示当前调用返回读取到的位置，空代表数据已经读取完毕'),
  maxResults?: int32(name='MaxResults', description='MaxResults本次请求所返回的最大记录条数'),
  vpcs?: [ 
    {
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
      status?: string(name='Status'),
      isDefault?: boolean(name='IsDefault'),
    }
  ](name='Vpcs', description='Vpcs'),
}

model DescribeVpcsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpcsResponseBody(name='body'),
}

async function describeVpcsWithOptions(request: DescribeVpcsRequest, runtime: Util.RuntimeOptions): DescribeVpcsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpcs', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpcs(request: DescribeVpcsRequest): DescribeVpcsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcsWithOptions(request, runtime);
}

model RemoveVmAppFromMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  namespace?: string(name='Namespace'),
  serviceName?: string(name='ServiceName'),
}

model RemoveVmAppFromMeshResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model RemoveVmAppFromMeshResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveVmAppFromMeshResponseBody(name='body'),
}

async function removeVmAppFromMeshWithOptions(request: RemoveVmAppFromMeshRequest, runtime: Util.RuntimeOptions): RemoveVmAppFromMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveVmAppFromMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeVmAppFromMesh(request: RemoveVmAppFromMeshRequest): RemoveVmAppFromMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeVmAppFromMeshWithOptions(request, runtime);
}

model DescribeClusterPrometheusRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  k8sClusterId?: string(name='K8sClusterId'),
  k8sClusterRegionId?: string(name='K8sClusterRegionId'),
}

model DescribeClusterPrometheusResponseBody = {
  requestId?: string(name='RequestId'),
  prometheus?: string(name='Prometheus'),
}

model DescribeClusterPrometheusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterPrometheusResponseBody(name='body'),
}

async function describeClusterPrometheusWithOptions(request: DescribeClusterPrometheusRequest, runtime: Util.RuntimeOptions): DescribeClusterPrometheusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeClusterPrometheus', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeClusterPrometheus(request: DescribeClusterPrometheusRequest): DescribeClusterPrometheusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterPrometheusWithOptions(request, runtime);
}

model UpdateIstioInjectionConfigRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  namespace?: string(name='Namespace'),
  enableIstioInjection?: boolean(name='EnableIstioInjection'),
}

model UpdateIstioInjectionConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIstioInjectionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIstioInjectionConfigResponseBody(name='body'),
}

async function updateIstioInjectionConfigWithOptions(request: UpdateIstioInjectionConfigRequest, runtime: Util.RuntimeOptions): UpdateIstioInjectionConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateIstioInjectionConfig', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateIstioInjectionConfig(request: UpdateIstioInjectionConfigRequest): UpdateIstioInjectionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIstioInjectionConfigWithOptions(request, runtime);
}

model GetVmMetaRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  trustDomain?: string(name='TrustDomain'),
  namespace?: string(name='Namespace'),
  serviceAccount?: string(name='ServiceAccount'),
}

model GetVmMetaResponseBody = {
  vmMetaInfo?: {
    hostsContent?: string(name='HostsContent'),
    tokenContent?: string(name='TokenContent'),
    envoyEnvContent?: string(name='EnvoyEnvContent'),
  }(name='VmMetaInfo'),
  requestId?: string(name='RequestId'),
}

model GetVmMetaResponse = {
  headers: map[string]string(name='headers'),
  body: GetVmMetaResponseBody(name='body'),
}

async function getVmMetaWithOptions(request: GetVmMetaRequest, runtime: Util.RuntimeOptions): GetVmMetaResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetVmMeta', '2020-01-11', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getVmMeta(request: GetVmMetaRequest): GetVmMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVmMetaWithOptions(request, runtime);
}

model DescribeUpgradeVersionRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeUpgradeVersionResponseBody = {
  requestId?: string(name='RequestId'),
  version?: {
    kubernetesVersion?: string(name='KubernetesVersion'),
    istioOperatorVersion?: string(name='IstioOperatorVersion'),
    istioVersion?: string(name='IstioVersion'),
  }(name='Version'),
}

model DescribeUpgradeVersionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUpgradeVersionResponseBody(name='body'),
}

async function describeUpgradeVersionWithOptions(request: DescribeUpgradeVersionRequest, runtime: Util.RuntimeOptions): DescribeUpgradeVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeUpgradeVersion', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeUpgradeVersion(request: DescribeUpgradeVersionRequest): DescribeUpgradeVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUpgradeVersionWithOptions(request, runtime);
}

model DescribeClustersInServiceMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeClustersInServiceMeshResponseBody = {
  requestId?: string(name='RequestId'),
  clusters?: [ 
    {
      sgId?: string(name='SgId'),
      vpcId?: string(name='VpcId'),
      creationTime?: string(name='CreationTime'),
      updateTime?: string(name='UpdateTime'),
      errorMessage?: string(name='ErrorMessage'),
      state?: string(name='State'),
      accessLogDashboards?: [ 
        {
          url?: string(name='Url'),
          title?: string(name='Title'),
        }
      ](name='AccessLogDashboards'),
      regionId?: string(name='RegionId'),
      clusterDomain?: string(name='ClusterDomain'),
      version?: string(name='Version'),
      clusterType?: string(name='ClusterType'),
      name?: string(name='Name'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='Clusters'),
}

model DescribeClustersInServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClustersInServiceMeshResponseBody(name='body'),
}

async function describeClustersInServiceMeshWithOptions(request: DescribeClustersInServiceMeshRequest, runtime: Util.RuntimeOptions): DescribeClustersInServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeClustersInServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeClustersInServiceMesh(request: DescribeClustersInServiceMeshRequest): DescribeClustersInServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClustersInServiceMeshWithOptions(request, runtime);
}

model GetBuiltinEnvoyFilterCatalogRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetBuiltinEnvoyFilterCatalogResponseBody = {
  requestId?: string(name='RequestId'),
  data?: map[string]any(name='Data'),
}

model GetBuiltinEnvoyFilterCatalogResponse = {
  headers: map[string]string(name='headers'),
  body: GetBuiltinEnvoyFilterCatalogResponseBody(name='body'),
}

async function getBuiltinEnvoyFilterCatalogWithOptions(request: GetBuiltinEnvoyFilterCatalogRequest, runtime: Util.RuntimeOptions): GetBuiltinEnvoyFilterCatalogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetBuiltinEnvoyFilterCatalog', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getBuiltinEnvoyFilterCatalog(request: GetBuiltinEnvoyFilterCatalogRequest): GetBuiltinEnvoyFilterCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBuiltinEnvoyFilterCatalogWithOptions(request, runtime);
}

model DescribeClusterGrafanaRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  k8sClusterId?: string(name='K8sClusterId'),
}

model DescribeClusterGrafanaResponseBody = {
  requestId?: string(name='RequestId'),
  dashboards?: [ 
    {
      url?: string(name='Url'),
      title?: string(name='Title'),
    }
  ](name='Dashboards'),
}

model DescribeClusterGrafanaResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterGrafanaResponseBody(name='body'),
}

async function describeClusterGrafanaWithOptions(request: DescribeClusterGrafanaRequest, runtime: Util.RuntimeOptions): DescribeClusterGrafanaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeClusterGrafana', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeClusterGrafana(request: DescribeClusterGrafanaRequest): DescribeClusterGrafanaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterGrafanaWithOptions(request, runtime);
}

model GetDiagnosisRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetDiagnosisResponseBody = {
  status?: string(name='Status'),
  requestId?: string(name='RequestId'),
  runAt?: string(name='RunAt'),
  result?: string(name='Result'),
}

model GetDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  body: GetDiagnosisResponseBody(name='body'),
}

async function getDiagnosisWithOptions(request: GetDiagnosisRequest, runtime: Util.RuntimeOptions): GetDiagnosisResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetDiagnosis', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getDiagnosis(request: GetDiagnosisRequest): GetDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDiagnosisWithOptions(request, runtime);
}

model GetRegisteredServicesRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  namespace?: string(name='Namespace'),
}

model GetRegisteredServicesResponseBody = {
  services?: [ string ](name='Services'),
  requestId?: string(name='RequestId'),
}

model GetRegisteredServicesResponse = {
  headers: map[string]string(name='headers'),
  body: GetRegisteredServicesResponseBody(name='body'),
}

async function getRegisteredServicesWithOptions(request: GetRegisteredServicesRequest, runtime: Util.RuntimeOptions): GetRegisteredServicesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRegisteredServices', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRegisteredServices(request: GetRegisteredServicesRequest): GetRegisteredServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegisteredServicesWithOptions(request, runtime);
}

model DescribeCensRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeCensResponseBody = {
  requestId?: string(name='RequestId'),
  clusters?: [ string ](name='Clusters'),
}

model DescribeCensResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCensResponseBody(name='body'),
}

async function describeCensWithOptions(request: DescribeCensRequest, runtime: Util.RuntimeOptions): DescribeCensResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeCens', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeCens(request: DescribeCensRequest): DescribeCensResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCensWithOptions(request, runtime);
}

model DeleteServiceMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  force?: boolean(name='Force'),
}

model DeleteServiceMeshResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteServiceMeshResponseBody(name='body'),
}

async function deleteServiceMeshWithOptions(request: DeleteServiceMeshRequest, runtime: Util.RuntimeOptions): DeleteServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteServiceMesh(request: DeleteServiceMeshRequest): DeleteServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServiceMeshWithOptions(request, runtime);
}

model GetSaTokenRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  namespace?: string(name='Namespace'),
  serviceAccountName?: string(name='ServiceAccountName'),
  needRefresh?: boolean(name='NeedRefresh'),
}

model GetSaTokenResponseBody = {
  requestId?: string(name='RequestId'),
  token?: string(name='Token', description='Token of service account'),
}

model GetSaTokenResponse = {
  headers: map[string]string(name='headers'),
  body: GetSaTokenResponseBody(name='body'),
}

async function getSaTokenWithOptions(request: GetSaTokenRequest, runtime: Util.RuntimeOptions): GetSaTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetSaToken', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getSaToken(request: GetSaTokenRequest): GetSaTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSaTokenWithOptions(request, runtime);
}

model GetVmAppMeshInfoRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetVmAppMeshInfoResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model GetVmAppMeshInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetVmAppMeshInfoResponseBody(name='body'),
}

async function getVmAppMeshInfoWithOptions(request: GetVmAppMeshInfoRequest, runtime: Util.RuntimeOptions): GetVmAppMeshInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetVmAppMeshInfo', '2020-01-11', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getVmAppMeshInfo(request: GetVmAppMeshInfoRequest): GetVmAppMeshInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVmAppMeshInfoWithOptions(request, runtime);
}

model RemoveClusterFromServiceMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  clusterId?: string(name='ClusterId'),
}

model RemoveClusterFromServiceMeshResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model RemoveClusterFromServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveClusterFromServiceMeshResponseBody(name='body'),
}

async function removeClusterFromServiceMeshWithOptions(request: RemoveClusterFromServiceMeshRequest, runtime: Util.RuntimeOptions): RemoveClusterFromServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveClusterFromServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeClusterFromServiceMesh(request: RemoveClusterFromServiceMeshRequest): RemoveClusterFromServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeClusterFromServiceMeshWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  businessLocations?: string(name='BusinessLocations'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeRegions', '2020-01-11', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model SetServiceRegistrySourceRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  config?: map[string]any(name='Config'),
}

model SetServiceRegistrySourceShrinkRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  configShrink?: string(name='Config'),
}

model SetServiceRegistrySourceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model SetServiceRegistrySourceResponse = {
  headers: map[string]string(name='headers'),
  body: SetServiceRegistrySourceResponseBody(name='body'),
}

async function setServiceRegistrySourceWithOptions(tmpReq: SetServiceRegistrySourceRequest, runtime: Util.RuntimeOptions): SetServiceRegistrySourceResponse {
  Util.validateModel(tmpReq);
  var request = new SetServiceRegistrySourceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.config)) {
    request.configShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.config, 'Config', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetServiceRegistrySource', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setServiceRegistrySource(request: SetServiceRegistrySourceRequest): SetServiceRegistrySourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return setServiceRegistrySourceWithOptions(request, runtime);
}

model AddClusterIntoServiceMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  clusterId?: string(name='ClusterId'),
}

model AddClusterIntoServiceMeshResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model AddClusterIntoServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: AddClusterIntoServiceMeshResponseBody(name='body'),
}

async function addClusterIntoServiceMeshWithOptions(request: AddClusterIntoServiceMeshRequest, runtime: Util.RuntimeOptions): AddClusterIntoServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddClusterIntoServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addClusterIntoServiceMesh(request: AddClusterIntoServiceMeshRequest): AddClusterIntoServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return addClusterIntoServiceMeshWithOptions(request, runtime);
}

model AddBuiltinEnvoyFilterRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  parameters?: string(name='Parameters'),
  istioVersion?: string(name='IstioVersion'),
}

model AddBuiltinEnvoyFilterResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddBuiltinEnvoyFilterResponse = {
  headers: map[string]string(name='headers'),
  body: AddBuiltinEnvoyFilterResponseBody(name='body'),
}

async function addBuiltinEnvoyFilterWithOptions(request: AddBuiltinEnvoyFilterRequest, runtime: Util.RuntimeOptions): AddBuiltinEnvoyFilterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddBuiltinEnvoyFilter', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addBuiltinEnvoyFilter(request: AddBuiltinEnvoyFilterRequest): AddBuiltinEnvoyFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBuiltinEnvoyFilterWithOptions(request, runtime);
}

model GetEcsListRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetEcsListResponseBody = {
  ecsInstances?: [ 
    {
      instanceId?: string(name='InstanceId'),
      hostName?: string(name='HostName'),
      ipAddress?: string(name='IpAddress'),
      status?: string(name='Status'),
      hasTag?: boolean(name='HasTag'),
      securityGroupIds?: [ string ](name='SecurityGroupIds'),
    }
  ](name='EcsInstances'),
  requestId?: string(name='RequestId'),
}

model GetEcsListResponse = {
  headers: map[string]string(name='headers'),
  body: GetEcsListResponseBody(name='body'),
}

async function getEcsListWithOptions(request: GetEcsListRequest, runtime: Util.RuntimeOptions): GetEcsListResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetEcsList', '2020-01-11', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getEcsList(request: GetEcsListRequest): GetEcsListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEcsListWithOptions(request, runtime);
}

model UpdateMeshFeatureRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  tracing?: boolean(name='Tracing'),
  traceSampling?: float(name='TraceSampling'),
  localityLoadBalancing?: boolean(name='LocalityLoadBalancing'),
  telemetry?: boolean(name='Telemetry'),
  openAgentPolicy?: boolean(name='OpenAgentPolicy'),
  OPALogLevel?: string(name='OPALogLevel'),
  OPARequestCPU?: string(name='OPARequestCPU'),
  OPARequestMemory?: string(name='OPARequestMemory'),
  OPALimitCPU?: string(name='OPALimitCPU'),
  OPALimitMemory?: string(name='OPALimitMemory'),
  enableAudit?: boolean(name='EnableAudit'),
  auditProject?: string(name='AuditProject'),
  clusterDomain?: string(name='ClusterDomain'),
  customizedZipkin?: boolean(name='CustomizedZipkin'),
  outboundTrafficPolicy?: string(name='OutboundTrafficPolicy'),
  proxyRequestCPU?: string(name='ProxyRequestCPU'),
  proxyRequestMemory?: string(name='ProxyRequestMemory'),
  proxyLimitCPU?: string(name='ProxyLimitCPU'),
  proxyLimitMemory?: string(name='ProxyLimitMemory'),
  includeIPRanges?: string(name='IncludeIPRanges'),
  excludeIPRanges?: string(name='ExcludeIPRanges'),
  excludeOutboundPorts?: string(name='ExcludeOutboundPorts'),
  excludeInboundPorts?: string(name='ExcludeInboundPorts'),
  enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault'),
  autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled'),
  sidecarInjectorRequestCPU?: string(name='SidecarInjectorRequestCPU'),
  sidecarInjectorRequestMemory?: string(name='SidecarInjectorRequestMemory'),
  sidecarInjectorLimitCPU?: string(name='SidecarInjectorLimitCPU'),
  sidecarInjectorLimitMemory?: string(name='SidecarInjectorLimitMemory'),
  sidecarInjectorWebhookAsYaml?: string(name='SidecarInjectorWebhookAsYaml'),
  cniEnabled?: boolean(name='CniEnabled'),
  cniExcludeNamespaces?: string(name='CniExcludeNamespaces'),
  opaEnabled?: boolean(name='OpaEnabled'),
  http10Enabled?: boolean(name='Http10Enabled'),
  kialiEnabled?: boolean(name='KialiEnabled'),
  customizedPrometheus?: boolean(name='CustomizedPrometheus'),
  prometheusUrl?: string(name='PrometheusUrl'),
  accessLogEnabled?: boolean(name='AccessLogEnabled'),
  MSEEnabled?: boolean(name='MSEEnabled'),
  redisFilterEnabled?: boolean(name='RedisFilterEnabled'),
  mysqlFilterEnabled?: boolean(name='MysqlFilterEnabled'),
  thriftFilterEnabled?: boolean(name='ThriftFilterEnabled'),
  webAssemblyFilterEnabled?: boolean(name='WebAssemblyFilterEnabled'),
  DNSProxyingEnabled?: boolean(name='DNSProxyingEnabled'),
  dubboFilterEnabled?: boolean(name='DubboFilterEnabled'),
  filterGatewayClusterConfig?: boolean(name='FilterGatewayClusterConfig'),
  enableSDSServer?: boolean(name='EnableSDSServer'),
  accessLogServiceEnabled?: boolean(name='AccessLogServiceEnabled'),
  accessLogServiceHost?: string(name='AccessLogServiceHost'),
  accessLogServicePort?: int32(name='AccessLogServicePort'),
  gatewayAPIEnabled?: boolean(name='GatewayAPIEnabled'),
  configSourceEnabled?: boolean(name='ConfigSourceEnabled'),
  configSourceNacosID?: string(name='ConfigSourceNacosID'),
}

model UpdateMeshFeatureResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMeshFeatureResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMeshFeatureResponseBody(name='body'),
}

async function updateMeshFeatureWithOptions(request: UpdateMeshFeatureRequest, runtime: Util.RuntimeOptions): UpdateMeshFeatureResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateMeshFeature', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateMeshFeature(request: UpdateMeshFeatureRequest): UpdateMeshFeatureResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMeshFeatureWithOptions(request, runtime);
}

model AddVmAppToMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  namespace?: string(name='Namespace'),
  serviceName?: string(name='ServiceName'),
  ips?: string(name='Ips'),
  ports?: string(name='Ports'),
  labels?: string(name='Labels'),
  annotations?: string(name='Annotations'),
  serviceAccount?: string(name='ServiceAccount'),
  force?: boolean(name='Force'),
}

model AddVmAppToMeshResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model AddVmAppToMeshResponse = {
  headers: map[string]string(name='headers'),
  body: AddVmAppToMeshResponseBody(name='body'),
}

async function addVmAppToMeshWithOptions(request: AddVmAppToMeshRequest, runtime: Util.RuntimeOptions): AddVmAppToMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddVmAppToMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addVmAppToMesh(request: AddVmAppToMeshRequest): AddVmAppToMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVmAppToMeshWithOptions(request, runtime);
}

model CreateServiceMeshRequest {
  regionId?: string(name='RegionId'),
  istioVersion?: string(name='IstioVersion'),
  vpcId?: string(name='VpcId'),
  apiServerPublicEip?: boolean(name='ApiServerPublicEip'),
  pilotPublicEip?: boolean(name='PilotPublicEip'),
  tracing?: boolean(name='Tracing'),
  name?: string(name='Name'),
  vSwitches?: string(name='VSwitches'),
  traceSampling?: float(name='TraceSampling'),
  localityLoadBalancing?: boolean(name='LocalityLoadBalancing'),
  telemetry?: boolean(name='Telemetry'),
  openAgentPolicy?: boolean(name='OpenAgentPolicy'),
  OPALogLevel?: string(name='OPALogLevel'),
  OPARequestCPU?: string(name='OPARequestCPU'),
  OPARequestMemory?: string(name='OPARequestMemory'),
  OPALimitCPU?: string(name='OPALimitCPU'),
  OPALimitMemory?: string(name='OPALimitMemory'),
  enableAudit?: boolean(name='EnableAudit'),
  auditProject?: string(name='AuditProject'),
  proxyRequestCPU?: string(name='ProxyRequestCPU'),
  proxyRequestMemory?: string(name='ProxyRequestMemory'),
  proxyLimitCPU?: string(name='ProxyLimitCPU'),
  proxyLimitMemory?: string(name='ProxyLimitMemory'),
  includeIPRanges?: string(name='IncludeIPRanges'),
  excludeIPRanges?: string(name='ExcludeIPRanges'),
  excludeOutboundPorts?: string(name='ExcludeOutboundPorts'),
  excludeInboundPorts?: string(name='ExcludeInboundPorts'),
  opaEnabled?: boolean(name='OpaEnabled'),
  kialiEnabled?: boolean(name='KialiEnabled'),
  accessLogEnabled?: boolean(name='AccessLogEnabled'),
  customizedPrometheus?: boolean(name='CustomizedPrometheus'),
  prometheusUrl?: string(name='PrometheusUrl'),
  redisFilterEnabled?: boolean(name='RedisFilterEnabled'),
  mysqlFilterEnabled?: boolean(name='MysqlFilterEnabled'),
  thriftFilterEnabled?: boolean(name='ThriftFilterEnabled'),
  webAssemblyFilterEnabled?: boolean(name='WebAssemblyFilterEnabled'),
  MSEEnabled?: boolean(name='MSEEnabled'),
  DNSProxyingEnabled?: boolean(name='DNSProxyingEnabled'),
  edition?: string(name='Edition'),
  configSourceEnabled?: boolean(name='ConfigSourceEnabled'),
  configSourceNacosID?: string(name='ConfigSourceNacosID'),
  dubboFilterEnabled?: boolean(name='DubboFilterEnabled'),
  filterGatewayClusterConfig?: boolean(name='FilterGatewayClusterConfig'),
  enableSDSServer?: boolean(name='EnableSDSServer'),
  accessLogServiceEnabled?: boolean(name='AccessLogServiceEnabled'),
  accessLogServiceHost?: string(name='AccessLogServiceHost'),
  accessLogServicePort?: int32(name='AccessLogServicePort'),
  gatewayAPIEnabled?: boolean(name='GatewayAPIEnabled'),
}

model CreateServiceMeshResponseBody = {
  requestId?: string(name='RequestId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model CreateServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServiceMeshResponseBody(name='body'),
}

async function createServiceMeshWithOptions(request: CreateServiceMeshRequest, runtime: Util.RuntimeOptions): CreateServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createServiceMesh(request: CreateServiceMeshRequest): CreateServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceMeshWithOptions(request, runtime);
}

model GetServiceRegistrySourceRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetServiceRegistrySourceResponseBody = {
  status?: string(name='Status'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model GetServiceRegistrySourceResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceRegistrySourceResponseBody(name='body'),
}

async function getServiceRegistrySourceWithOptions(request: GetServiceRegistrySourceRequest, runtime: Util.RuntimeOptions): GetServiceRegistrySourceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetServiceRegistrySource', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getServiceRegistrySource(request: GetServiceRegistrySourceRequest): GetServiceRegistrySourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServiceRegistrySourceWithOptions(request, runtime);
}

model RemoveBuiltinEnvoyFilterRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  istioVersion?: string(name='IstioVersion'),
}

model RemoveBuiltinEnvoyFilterResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveBuiltinEnvoyFilterResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveBuiltinEnvoyFilterResponseBody(name='body'),
}

async function removeBuiltinEnvoyFilterWithOptions(request: RemoveBuiltinEnvoyFilterRequest, runtime: Util.RuntimeOptions): RemoveBuiltinEnvoyFilterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveBuiltinEnvoyFilter', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeBuiltinEnvoyFilter(request: RemoveBuiltinEnvoyFilterRequest): RemoveBuiltinEnvoyFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeBuiltinEnvoyFilterWithOptions(request, runtime);
}

model GetBuiltinEnvoyFilterRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  istioVersion?: string(name='IstioVersion'),
}

model GetBuiltinEnvoyFilterResponseBody = {
  parameters?: string(name='Parameters'),
  requestId?: string(name='RequestId'),
}

model GetBuiltinEnvoyFilterResponse = {
  headers: map[string]string(name='headers'),
  body: GetBuiltinEnvoyFilterResponseBody(name='body'),
}

async function getBuiltinEnvoyFilterWithOptions(request: GetBuiltinEnvoyFilterRequest, runtime: Util.RuntimeOptions): GetBuiltinEnvoyFilterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetBuiltinEnvoyFilter', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getBuiltinEnvoyFilter(request: GetBuiltinEnvoyFilterRequest): GetBuiltinEnvoyFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBuiltinEnvoyFilterWithOptions(request, runtime);
}

model InitializeASMRoleResponseBody = {
  requestId?: string(name='RequestId'),
}

model InitializeASMRoleResponse = {
  headers: map[string]string(name='headers'),
  body: InitializeASMRoleResponseBody(name='body'),
}

async function initializeASMRoleWithOptions(runtime: Util.RuntimeOptions): InitializeASMRoleResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('InitializeASMRole', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function initializeASMRole(): InitializeASMRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return initializeASMRoleWithOptions(runtime);
}

model AddMeshTagToEcsRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  ecsId?: string(name='EcsId'),
}

model AddMeshTagToEcsResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddMeshTagToEcsResponse = {
  headers: map[string]string(name='headers'),
  body: AddMeshTagToEcsResponseBody(name='body'),
}

async function addMeshTagToEcsWithOptions(request: AddMeshTagToEcsRequest, runtime: Util.RuntimeOptions): AddMeshTagToEcsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddMeshTagToEcs', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addMeshTagToEcs(request: AddMeshTagToEcsRequest): AddMeshTagToEcsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMeshTagToEcsWithOptions(request, runtime);
}

