/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  

  checkConfig(config);
  @endpoint = getEndpoint('servicemesh', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AddClusterIntoServiceMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  clusterId?: string(name='ClusterId'),
}

model AddClusterIntoServiceMeshResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model AddClusterIntoServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: AddClusterIntoServiceMeshResponseBody(name='body'),
}

async function addClusterIntoServiceMeshWithOptions(request: AddClusterIntoServiceMeshRequest, runtime: Util.RuntimeOptions): AddClusterIntoServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddClusterIntoServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addClusterIntoServiceMesh(request: AddClusterIntoServiceMeshRequest): AddClusterIntoServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return addClusterIntoServiceMeshWithOptions(request, runtime);
}

model AddVmAppToMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  namespace?: string(name='Namespace'),
  serviceName?: string(name='ServiceName'),
  ips?: string(name='Ips'),
  ports?: string(name='Ports'),
  labels?: string(name='Labels'),
  annotations?: string(name='Annotations'),
  serviceAccount?: string(name='ServiceAccount'),
  useWorkload?: boolean(name='UseWorkload'),
  force?: boolean(name='Force'),
}

model AddVmAppToMeshResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model AddVmAppToMeshResponse = {
  headers: map[string]string(name='headers'),
  body: AddVmAppToMeshResponseBody(name='body'),
}

async function addVmAppToMeshWithOptions(request: AddVmAppToMeshRequest, runtime: Util.RuntimeOptions): AddVmAppToMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddVmAppToMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addVmAppToMesh(request: AddVmAppToMeshRequest): AddVmAppToMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVmAppToMeshWithOptions(request, runtime);
}

model CreateServiceMeshRequest {
  regionId?: string(name='RegionId'),
  istioVersion?: string(name='IstioVersion'),
  vpcId?: string(name='VpcId'),
  apiServerPublicEip?: boolean(name='ApiServerPublicEip'),
  pilotPublicEip?: boolean(name='PilotPublicEip'),
  strictMTLS?: boolean(name='StrictMTLS'),
  outboundTrafficPolicy?: string(name='OutboundTrafficPolicy'),
  tracing?: boolean(name='Tracing'),
  name?: string(name='Name'),
  vSwitches?: string(name='VSwitches'),
  traceSampling?: float(name='TraceSampling'),
  localityLoadBalancing?: boolean(name='LocalityLoadBalancing'),
  telemetry?: boolean(name='Telemetry'),
  openAgentPolicy?: boolean(name='OpenAgentPolicy'),
  OPALogLevel?: string(name='OPALogLevel'),
  OPARequestCPU?: string(name='OPARequestCPU'),
  OPARequestMemory?: string(name='OPARequestMemory'),
  OPALimitCPU?: string(name='OPALimitCPU'),
  OPALimitMemory?: string(name='OPALimitMemory'),
  enableAudit?: boolean(name='EnableAudit'),
  auditProject?: string(name='AuditProject'),
  CADisableSecretAutoGeneration?: boolean(name='CADisableSecretAutoGeneration'),
  CAListenedNamespaces?: string(name='CAListenedNamespaces'),
  appNamespaces?: string(name='AppNamespaces'),
  clusterDomain?: string(name='ClusterDomain'),
  proxyRequestCPU?: string(name='ProxyRequestCPU'),
  proxyRequestMemory?: string(name='ProxyRequestMemory'),
  proxyLimitCPU?: string(name='ProxyLimitCPU'),
  proxyLimitMemory?: string(name='ProxyLimitMemory'),
  includeIPRanges?: string(name='IncludeIPRanges'),
  excludeIPRanges?: string(name='ExcludeIPRanges'),
  excludeOutboundPorts?: string(name='ExcludeOutboundPorts'),
  excludeInboundPorts?: string(name='ExcludeInboundPorts'),
  opaEnabled?: boolean(name='OpaEnabled'),
}

model CreateServiceMeshResponseBody = {
  requestId?: string(name='RequestId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model CreateServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServiceMeshResponseBody(name='body'),
}

async function createServiceMeshWithOptions(request: CreateServiceMeshRequest, runtime: Util.RuntimeOptions): CreateServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createServiceMesh(request: CreateServiceMeshRequest): CreateServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceMeshWithOptions(request, runtime);
}

model DeleteServiceMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  force?: boolean(name='Force'),
}

model DeleteServiceMeshResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteServiceMeshResponseBody(name='body'),
}

async function deleteServiceMeshWithOptions(request: DeleteServiceMeshRequest, runtime: Util.RuntimeOptions): DeleteServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteServiceMesh(request: DeleteServiceMeshRequest): DeleteServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServiceMeshWithOptions(request, runtime);
}

model DescribeCensRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeCensResponseBody = {
  requestId?: string(name='RequestId'),
  clusters?: [ string ](name='Clusters'),
}

model DescribeCensResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCensResponseBody(name='body'),
}

async function describeCensWithOptions(request: DescribeCensRequest, runtime: Util.RuntimeOptions): DescribeCensResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeCens', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeCens(request: DescribeCensRequest): DescribeCensResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCensWithOptions(request, runtime);
}

model DescribeClusterGrafanaRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  k8sClusterId?: string(name='K8sClusterId'),
}

model DescribeClusterGrafanaResponseBody = {
  requestId?: string(name='RequestId'),
  dashboards?: [ 
    {
      url?: string(name='Url'),
      title?: string(name='Title'),
    }
  ](name='Dashboards'),
}

model DescribeClusterGrafanaResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterGrafanaResponseBody(name='body'),
}

async function describeClusterGrafanaWithOptions(request: DescribeClusterGrafanaRequest, runtime: Util.RuntimeOptions): DescribeClusterGrafanaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeClusterGrafana', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeClusterGrafana(request: DescribeClusterGrafanaRequest): DescribeClusterGrafanaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterGrafanaWithOptions(request, runtime);
}

model DescribeClusterPrometheusRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  k8sClusterId?: string(name='K8sClusterId'),
  k8sClusterRegionId?: string(name='K8sClusterRegionId'),
}

model DescribeClusterPrometheusResponseBody = {
  requestId?: string(name='RequestId'),
  prometheus?: string(name='Prometheus'),
}

model DescribeClusterPrometheusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterPrometheusResponseBody(name='body'),
}

async function describeClusterPrometheusWithOptions(request: DescribeClusterPrometheusRequest, runtime: Util.RuntimeOptions): DescribeClusterPrometheusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeClusterPrometheus', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeClusterPrometheus(request: DescribeClusterPrometheusRequest): DescribeClusterPrometheusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterPrometheusWithOptions(request, runtime);
}

model DescribeClustersInServiceMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeClustersInServiceMeshResponseBody = {
  requestId?: string(name='RequestId'),
  clusters?: [ 
    {
      sgId?: string(name='SgId'),
      vpcId?: string(name='VpcId'),
      creationTime?: string(name='CreationTime'),
      updateTime?: string(name='UpdateTime'),
      errorMessage?: string(name='ErrorMessage'),
      state?: string(name='State'),
      regionId?: string(name='RegionId'),
      clusterDomain?: string(name='ClusterDomain'),
      version?: string(name='Version'),
      clusterType?: string(name='ClusterType'),
      name?: string(name='Name'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='Clusters'),
}

model DescribeClustersInServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClustersInServiceMeshResponseBody(name='body'),
}

async function describeClustersInServiceMeshWithOptions(request: DescribeClustersInServiceMeshRequest, runtime: Util.RuntimeOptions): DescribeClustersInServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeClustersInServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeClustersInServiceMesh(request: DescribeClustersInServiceMeshRequest): DescribeClustersInServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClustersInServiceMeshWithOptions(request, runtime);
}

model DescribeGuestClusterAccessLogDashboardsRequest {
  k8sClusterId?: string(name='K8sClusterId'),
}

model DescribeGuestClusterAccessLogDashboardsResponseBody = {
  requestId?: string(name='RequestId'),
  dashboards?: [ 
    {
      url?: string(name='Url'),
      title?: string(name='Title'),
    }
  ](name='Dashboards'),
  k8sClusterId?: string(name='K8sClusterId'),
}

model DescribeGuestClusterAccessLogDashboardsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGuestClusterAccessLogDashboardsResponseBody(name='body'),
}

async function describeGuestClusterAccessLogDashboardsWithOptions(request: DescribeGuestClusterAccessLogDashboardsRequest, runtime: Util.RuntimeOptions): DescribeGuestClusterAccessLogDashboardsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeGuestClusterAccessLogDashboards', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeGuestClusterAccessLogDashboards(request: DescribeGuestClusterAccessLogDashboardsRequest): DescribeGuestClusterAccessLogDashboardsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGuestClusterAccessLogDashboardsWithOptions(request, runtime);
}

model DescribeIngressGatewaysRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeIngressGatewaysResponseBody = {
  requestId?: string(name='RequestId'),
  ingressGateways?: [  map[string]any ](name='IngressGateways'),
}

model DescribeIngressGatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIngressGatewaysResponseBody(name='body'),
}

async function describeIngressGatewaysWithOptions(request: DescribeIngressGatewaysRequest, runtime: Util.RuntimeOptions): DescribeIngressGatewaysResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeIngressGateways', '2020-01-11', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeIngressGateways(request: DescribeIngressGatewaysRequest): DescribeIngressGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIngressGatewaysWithOptions(request, runtime);
}

model DescribeServiceMeshDetailRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeServiceMeshDetailResponseBody = {
  requestId?: string(name='RequestId'),
  serviceMesh?: {
    endpoints?: {
      intranetPilotEndpoint?: string(name='IntranetPilotEndpoint'),
      publicPilotEndpoint?: string(name='PublicPilotEndpoint'),
      intranetApiServerEndpoint?: string(name='IntranetApiServerEndpoint'),
      publicApiServerEndpoint?: string(name='PublicApiServerEndpoint'),
    }(name='Endpoints'),
    serviceMeshInfo?: {
      creationTime?: string(name='CreationTime'),
      updateTime?: string(name='UpdateTime'),
      errorMessage?: string(name='ErrorMessage'),
      version?: string(name='Version'),
      state?: string(name='State'),
      serviceMeshId?: string(name='ServiceMeshId'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
    }(name='ServiceMeshInfo'),
    spec?: {
      network?: {
        vpcId?: string(name='VpcId'),
        securityGroupId?: string(name='SecurityGroupId'),
        vSwitches?: [ string ](name='VSwitches'),
      }(name='Network'),
      loadBalancer?: {
        pilotPublicEip?: boolean(name='PilotPublicEip'),
        pilotPublicLoadbalancerId?: string(name='PilotPublicLoadbalancerId'),
        apiServerLoadbalancerId?: string(name='ApiServerLoadbalancerId'),
        apiServerPublicEip?: boolean(name='ApiServerPublicEip'),
      }(name='LoadBalancer'),
      meshConfig?: {
        telemetry?: boolean(name='Telemetry'),
        OPA?: {
          requestMemory?: string(name='RequestMemory'),
          logLevel?: string(name='LogLevel'),
          enabled?: boolean(name='Enabled'),
          limitMemory?: string(name='LimitMemory'),
          requestCPU?: string(name='RequestCPU'),
          limitCPU?: string(name='LimitCPU'),
        }(name='OPA'),
        outboundTrafficPolicy?: string(name='OutboundTrafficPolicy'),
        tracing?: boolean(name='Tracing'),
        enableLocalityLB?: boolean(name='EnableLocalityLB'),
        audit?: {
          enabled?: boolean(name='Enabled'),
          project?: string(name='Project'),
        }(name='Audit'),
        pilot?: {
          http10Enabled?: boolean(name='Http10Enabled'),
          traceSampling?: float(name='TraceSampling'),
        }(name='Pilot'),
        customizedZipkin?: boolean(name='CustomizedZipkin'),
        includeIPRanges?: string(name='IncludeIPRanges'),
        sidecarInjector?: {
          enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault'),
          requestMemory?: string(name='RequestMemory'),
          limitMemory?: string(name='LimitMemory'),
          requestCPU?: string(name='RequestCPU'),
          autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled'),
          limitCPU?: string(name='LimitCPU'),
          initCNIConfiguration?: {
            excludeNamespaces?: string(name='ExcludeNamespaces'),
            enabled?: boolean(name='Enabled'),
          }(name='InitCNIConfiguration'),
          sidecarInjectorWebhookAsYaml?: string(name='SidecarInjectorWebhookAsYaml'),
        }(name='SidecarInjector'),
        proxy?: {
          requestMemory?: string(name='RequestMemory'),
          clusterDomain?: string(name='ClusterDomain'),
          limitMemory?: string(name='LimitMemory'),
          requestCPU?: string(name='RequestCPU'),
          limitCPU?: string(name='LimitCPU'),
        }(name='Proxy'),
      }(name='MeshConfig'),
    }(name='Spec'),
    clusters?: [ string ](name='Clusters'),
  }(name='ServiceMesh'),
}

model DescribeServiceMeshDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServiceMeshDetailResponseBody(name='body'),
}

async function describeServiceMeshDetailWithOptions(request: DescribeServiceMeshDetailRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshDetailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeServiceMeshDetail', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeServiceMeshDetail(request: DescribeServiceMeshDetailRequest): DescribeServiceMeshDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshDetailWithOptions(request, runtime);
}

model DescribeServiceMeshesResponseBody = {
  requestId?: string(name='RequestId'),
  serviceMeshes?: [ 
    {
      endpoints?: {
        intranetPilotEndpoint?: string(name='IntranetPilotEndpoint'),
        reverseTunnelEndpoint?: string(name='ReverseTunnelEndpoint'),
        publicPilotEndpoint?: string(name='PublicPilotEndpoint'),
        intranetApiServerEndpoint?: string(name='IntranetApiServerEndpoint'),
        publicApiServerEndpoint?: string(name='PublicApiServerEndpoint'),
      }(name='Endpoints'),
      serviceMeshInfo?: {
        creationTime?: string(name='CreationTime'),
        updateTime?: string(name='UpdateTime'),
        errorMessage?: string(name='ErrorMessage'),
        version?: string(name='Version'),
        state?: string(name='State'),
        serviceMeshId?: string(name='ServiceMeshId'),
        name?: string(name='Name'),
        regionId?: string(name='RegionId'),
      }(name='ServiceMeshInfo'),
      spec?: {
        network?: {
          vpcId?: string(name='VpcId'),
          securityGroupId?: string(name='SecurityGroupId'),
          vSwitches?: [ string ](name='VSwitches'),
        }(name='Network'),
        loadBalancer?: {
          pilotPublicEip?: boolean(name='PilotPublicEip'),
          pilotPublicLoadbalancerId?: string(name='PilotPublicLoadbalancerId'),
          apiServerLoadbalancerId?: string(name='ApiServerLoadbalancerId'),
          apiServerPublicEip?: boolean(name='ApiServerPublicEip'),
        }(name='LoadBalancer'),
        meshConfig?: {
          telemetry?: boolean(name='Telemetry'),
          outboundTrafficPolicy?: string(name='OutboundTrafficPolicy'),
          tracing?: boolean(name='Tracing'),
          strictMtls?: boolean(name='StrictMtls'),
          pilot?: {
            http10Enabled?: boolean(name='Http10Enabled'),
            traceSampling?: float(name='TraceSampling'),
          }(name='Pilot'),
          mtls?: boolean(name='Mtls'),
          sidecarInjector?: {
            enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault'),
            autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled'),
            initCNIConfiguration?: {
              excludeNamespaces?: string(name='ExcludeNamespaces'),
              enabled?: boolean(name='Enabled'),
            }(name='InitCNIConfiguration'),
          }(name='SidecarInjector'),
        }(name='MeshConfig'),
      }(name='Spec'),
      clusters?: [ string ](name='Clusters'),
    }
  ](name='ServiceMeshes'),
}

model DescribeServiceMeshesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServiceMeshesResponseBody(name='body'),
}

async function describeServiceMeshesWithOptions(runtime: Util.RuntimeOptions): DescribeServiceMeshesResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('DescribeServiceMeshes', '2020-01-11', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeServiceMeshes(): DescribeServiceMeshesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshesWithOptions(runtime);
}

model DescribeServiceMeshKubeconfigRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  privateIpAddress?: boolean(name='PrivateIpAddress'),
}

model DescribeServiceMeshKubeconfigResponseBody = {
  requestId?: string(name='RequestId'),
  kubeconfig?: string(name='Kubeconfig'),
}

model DescribeServiceMeshKubeconfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServiceMeshKubeconfigResponseBody(name='body'),
}

async function describeServiceMeshKubeconfigWithOptions(request: DescribeServiceMeshKubeconfigRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshKubeconfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeServiceMeshKubeconfig', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeServiceMeshKubeconfig(request: DescribeServiceMeshKubeconfigRequest): DescribeServiceMeshKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshKubeconfigWithOptions(request, runtime);
}

model DescribeUpgradeVersionRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeUpgradeVersionResponseBody = {
  requestId?: string(name='RequestId'),
  version?: {
    kubernetesVersion?: string(name='KubernetesVersion'),
    istioOperatorVersion?: string(name='IstioOperatorVersion'),
    istioVersion?: string(name='IstioVersion'),
  }(name='Version'),
}

model DescribeUpgradeVersionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUpgradeVersionResponseBody(name='body'),
}

async function describeUpgradeVersionWithOptions(request: DescribeUpgradeVersionRequest, runtime: Util.RuntimeOptions): DescribeUpgradeVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeUpgradeVersion', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeUpgradeVersion(request: DescribeUpgradeVersionRequest): DescribeUpgradeVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUpgradeVersionWithOptions(request, runtime);
}

model GetDiagnosisRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetDiagnosisResponseBody = {
  requestId?: string(name='RequestId'),
  runAt?: string(name='RunAt'),
  result?: string(name='Result'),
}

model GetDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  body: GetDiagnosisResponseBody(name='body'),
}

async function getDiagnosisWithOptions(request: GetDiagnosisRequest, runtime: Util.RuntimeOptions): GetDiagnosisResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetDiagnosis', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getDiagnosis(request: GetDiagnosisRequest): GetDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDiagnosisWithOptions(request, runtime);
}

model GetRegisteredServiceEndpointsRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  namespace?: string(name='Namespace'),
  name?: string(name='Name'),
}

model GetRegisteredServiceEndpointsResponseBody = {
  serviceEndpoints?: [ 
    {
      address?: string(name='Address'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='ServiceEndpoints'),
  requestId?: string(name='RequestId'),
}

model GetRegisteredServiceEndpointsResponse = {
  headers: map[string]string(name='headers'),
  body: GetRegisteredServiceEndpointsResponseBody(name='body'),
}

async function getRegisteredServiceEndpointsWithOptions(request: GetRegisteredServiceEndpointsRequest, runtime: Util.RuntimeOptions): GetRegisteredServiceEndpointsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRegisteredServiceEndpoints', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRegisteredServiceEndpoints(request: GetRegisteredServiceEndpointsRequest): GetRegisteredServiceEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegisteredServiceEndpointsWithOptions(request, runtime);
}

model GetRegisteredServiceNamespacesRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetRegisteredServiceNamespacesResponseBody = {
  namespaces?: [ string ](name='Namespaces'),
  requestId?: string(name='RequestId'),
}

model GetRegisteredServiceNamespacesResponse = {
  headers: map[string]string(name='headers'),
  body: GetRegisteredServiceNamespacesResponseBody(name='body'),
}

async function getRegisteredServiceNamespacesWithOptions(request: GetRegisteredServiceNamespacesRequest, runtime: Util.RuntimeOptions): GetRegisteredServiceNamespacesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRegisteredServiceNamespaces', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRegisteredServiceNamespaces(request: GetRegisteredServiceNamespacesRequest): GetRegisteredServiceNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegisteredServiceNamespacesWithOptions(request, runtime);
}

model GetRegisteredServicesRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  namespace?: string(name='Namespace'),
}

model GetRegisteredServicesResponseBody = {
  services?: [ string ](name='Services'),
  requestId?: string(name='RequestId'),
}

model GetRegisteredServicesResponse = {
  headers: map[string]string(name='headers'),
  body: GetRegisteredServicesResponseBody(name='body'),
}

async function getRegisteredServicesWithOptions(request: GetRegisteredServicesRequest, runtime: Util.RuntimeOptions): GetRegisteredServicesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRegisteredServices', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRegisteredServices(request: GetRegisteredServicesRequest): GetRegisteredServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegisteredServicesWithOptions(request, runtime);
}

model GetServiceMeshSlbRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetServiceMeshSlbResponseBody = {
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      status?: string(name='Status'),
      serverHealthStatus?: string(name='ServerHealthStatus'),
      loadBalancerId?: string(name='LoadBalancerId'),
    }
  ](name='Data'),
}

model GetServiceMeshSlbResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceMeshSlbResponseBody(name='body'),
}

async function getServiceMeshSlbWithOptions(request: GetServiceMeshSlbRequest, runtime: Util.RuntimeOptions): GetServiceMeshSlbResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetServiceMeshSlb', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getServiceMeshSlb(request: GetServiceMeshSlbRequest): GetServiceMeshSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServiceMeshSlbWithOptions(request, runtime);
}

model GetVmAppMeshInfoRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetVmAppMeshInfoResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model GetVmAppMeshInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetVmAppMeshInfoResponseBody(name='body'),
}

async function getVmAppMeshInfoWithOptions(request: GetVmAppMeshInfoRequest, runtime: Util.RuntimeOptions): GetVmAppMeshInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetVmAppMeshInfo', '2020-01-11', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getVmAppMeshInfo(request: GetVmAppMeshInfoRequest): GetVmAppMeshInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVmAppMeshInfoWithOptions(request, runtime);
}

model GetVmMetaRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  trustDomain?: string(name='TrustDomain'),
  namespace?: string(name='Namespace'),
  serviceAccount?: string(name='ServiceAccount'),
}

model GetVmMetaResponseBody = {
  vmMetaInfo?: {
    tokenPath?: string(name='TokenPath'),
    hostsContent?: string(name='HostsContent'),
    envoyEnvPath?: string(name='EnvoyEnvPath'),
    tokenContent?: string(name='TokenContent'),
    certChainPath?: string(name='CertChainPath'),
    rootCertContent?: string(name='RootCertContent'),
    keyContent?: string(name='KeyContent'),
    rootCertPath?: string(name='RootCertPath'),
    certChainContent?: string(name='CertChainContent'),
    hostsPath?: string(name='HostsPath'),
    keyPath?: string(name='KeyPath'),
    envoyEnvContent?: string(name='EnvoyEnvContent'),
  }(name='VmMetaInfo'),
  requestId?: string(name='RequestId'),
}

model GetVmMetaResponse = {
  headers: map[string]string(name='headers'),
  body: GetVmMetaResponseBody(name='body'),
}

async function getVmMetaWithOptions(request: GetVmMetaRequest, runtime: Util.RuntimeOptions): GetVmMetaResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetVmMeta', '2020-01-11', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getVmMeta(request: GetVmMetaRequest): GetVmMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVmMetaWithOptions(request, runtime);
}

model RemoveClusterFromServiceMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  clusterId?: string(name='ClusterId'),
}

model RemoveClusterFromServiceMeshResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model RemoveClusterFromServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveClusterFromServiceMeshResponseBody(name='body'),
}

async function removeClusterFromServiceMeshWithOptions(request: RemoveClusterFromServiceMeshRequest, runtime: Util.RuntimeOptions): RemoveClusterFromServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveClusterFromServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeClusterFromServiceMesh(request: RemoveClusterFromServiceMeshRequest): RemoveClusterFromServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeClusterFromServiceMeshWithOptions(request, runtime);
}

model RemoveVmAppFromMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  namespace?: string(name='Namespace'),
  serviceName?: string(name='ServiceName'),
}

model RemoveVmAppFromMeshResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model RemoveVmAppFromMeshResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveVmAppFromMeshResponseBody(name='body'),
}

async function removeVmAppFromMeshWithOptions(request: RemoveVmAppFromMeshRequest, runtime: Util.RuntimeOptions): RemoveVmAppFromMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveVmAppFromMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeVmAppFromMesh(request: RemoveVmAppFromMeshRequest): RemoveVmAppFromMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeVmAppFromMeshWithOptions(request, runtime);
}

model RunDiagnosisRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model RunDiagnosisResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model RunDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  body: RunDiagnosisResponseBody(name='body'),
}

async function runDiagnosisWithOptions(request: RunDiagnosisRequest, runtime: Util.RuntimeOptions): RunDiagnosisResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RunDiagnosis', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function runDiagnosis(request: RunDiagnosisRequest): RunDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  return runDiagnosisWithOptions(request, runtime);
}

model UpdateIstioInjectionConfigRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  namespace?: string(name='Namespace'),
  enableIstioInjection?: boolean(name='EnableIstioInjection'),
}

model UpdateIstioInjectionConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIstioInjectionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIstioInjectionConfigResponseBody(name='body'),
}

async function updateIstioInjectionConfigWithOptions(request: UpdateIstioInjectionConfigRequest, runtime: Util.RuntimeOptions): UpdateIstioInjectionConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateIstioInjectionConfig', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateIstioInjectionConfig(request: UpdateIstioInjectionConfigRequest): UpdateIstioInjectionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIstioInjectionConfigWithOptions(request, runtime);
}

model UpdateMeshFeatureRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  tracing?: boolean(name='Tracing'),
  traceSampling?: float(name='TraceSampling'),
  localityLoadBalancing?: boolean(name='LocalityLoadBalancing'),
  telemetry?: boolean(name='Telemetry'),
  openAgentPolicy?: boolean(name='OpenAgentPolicy'),
  OPALogLevel?: string(name='OPALogLevel'),
  OPARequestCPU?: string(name='OPARequestCPU'),
  OPARequestMemory?: string(name='OPARequestMemory'),
  OPALimitCPU?: string(name='OPALimitCPU'),
  OPALimitMemory?: string(name='OPALimitMemory'),
  pilotPublicEip?: boolean(name='PilotPublicEip'),
  enableAudit?: boolean(name='EnableAudit'),
  auditProject?: string(name='AuditProject'),
  CADisableSecretAutoGeneration?: boolean(name='CADisableSecretAutoGeneration'),
  CAListenedNamespaces?: string(name='CAListenedNamespaces'),
  appNamespaces?: string(name='AppNamespaces'),
  clusterDomain?: string(name='ClusterDomain'),
  customizedZipkin?: boolean(name='CustomizedZipkin'),
  outboundTrafficPolicy?: string(name='OutboundTrafficPolicy'),
  proxyRequestCPU?: string(name='ProxyRequestCPU'),
  proxyRequestMemory?: string(name='ProxyRequestMemory'),
  proxyLimitCPU?: string(name='ProxyLimitCPU'),
  proxyLimitMemory?: string(name='ProxyLimitMemory'),
  includeIPRanges?: string(name='IncludeIPRanges'),
  enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault'),
  autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled'),
  sidecarInjectorRequestCPU?: string(name='SidecarInjectorRequestCPU'),
  sidecarInjectorRequestMemory?: string(name='SidecarInjectorRequestMemory'),
  sidecarInjectorLimitCPU?: string(name='SidecarInjectorLimitCPU'),
  sidecarInjectorLimitMemory?: string(name='SidecarInjectorLimitMemory'),
  sidecarInjectorWebhookAsYaml?: string(name='SidecarInjectorWebhookAsYaml'),
  cniEnabled?: boolean(name='CniEnabled'),
  cniExcludeNamespaces?: string(name='CniExcludeNamespaces'),
  opaEnabled?: boolean(name='OpaEnabled'),
  http10Enabled?: boolean(name='Http10Enabled'),
}

model UpdateMeshFeatureResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMeshFeatureResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMeshFeatureResponseBody(name='body'),
}

async function updateMeshFeatureWithOptions(request: UpdateMeshFeatureRequest, runtime: Util.RuntimeOptions): UpdateMeshFeatureResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateMeshFeature', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateMeshFeature(request: UpdateMeshFeatureRequest): UpdateMeshFeatureResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMeshFeatureWithOptions(request, runtime);
}

model UpgradeMeshVersionRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model UpgradeMeshVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpgradeMeshVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeMeshVersionResponseBody(name='body'),
}

async function upgradeMeshVersionWithOptions(request: UpgradeMeshVersionRequest, runtime: Util.RuntimeOptions): UpgradeMeshVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpgradeMeshVersion', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function upgradeMeshVersion(request: UpgradeMeshVersionRequest): UpgradeMeshVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeMeshVersionWithOptions(request, runtime);
}

