/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('servicemesh', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AddBuiltinEnvoyFilterRequest {
  id?: string(name='Id'),
  istioVersion?: string(name='IstioVersion'),
  name?: string(name='Name'),
  parameters?: string(name='Parameters'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model AddBuiltinEnvoyFilterResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddBuiltinEnvoyFilterResponse = {
  headers: map[string]string(name='headers'),
  body: AddBuiltinEnvoyFilterResponseBody(name='body'),
}

async function addBuiltinEnvoyFilterWithOptions(request: AddBuiltinEnvoyFilterRequest, runtime: Util.RuntimeOptions): AddBuiltinEnvoyFilterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddBuiltinEnvoyFilter', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addBuiltinEnvoyFilter(request: AddBuiltinEnvoyFilterRequest): AddBuiltinEnvoyFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBuiltinEnvoyFilterWithOptions(request, runtime);
}

model AddClusterIntoServiceMeshRequest {
  clusterId?: string(name='ClusterId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model AddClusterIntoServiceMeshResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AddClusterIntoServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: AddClusterIntoServiceMeshResponseBody(name='body'),
}

async function addClusterIntoServiceMeshWithOptions(request: AddClusterIntoServiceMeshRequest, runtime: Util.RuntimeOptions): AddClusterIntoServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddClusterIntoServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addClusterIntoServiceMesh(request: AddClusterIntoServiceMeshRequest): AddClusterIntoServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return addClusterIntoServiceMeshWithOptions(request, runtime);
}

model AddMeshTagToEcsRequest {
  ecsId?: string(name='EcsId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model AddMeshTagToEcsResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddMeshTagToEcsResponse = {
  headers: map[string]string(name='headers'),
  body: AddMeshTagToEcsResponseBody(name='body'),
}

async function addMeshTagToEcsWithOptions(request: AddMeshTagToEcsRequest, runtime: Util.RuntimeOptions): AddMeshTagToEcsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddMeshTagToEcs', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addMeshTagToEcs(request: AddMeshTagToEcsRequest): AddMeshTagToEcsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMeshTagToEcsWithOptions(request, runtime);
}

model AddVMIntoServiceMeshRequest {
  ecsId?: string(name='EcsId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model AddVMIntoServiceMeshResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AddVMIntoServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: AddVMIntoServiceMeshResponseBody(name='body'),
}

async function addVMIntoServiceMeshWithOptions(request: AddVMIntoServiceMeshRequest, runtime: Util.RuntimeOptions): AddVMIntoServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddVMIntoServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addVMIntoServiceMesh(request: AddVMIntoServiceMeshRequest): AddVMIntoServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVMIntoServiceMeshWithOptions(request, runtime);
}

model CreateExtensionProviderRequest {
  config?: string(name='Config'),
  name?: string(name='Name'),
  serviceMeshId?: string(name='ServiceMeshId'),
  type?: string(name='Type'),
}

model CreateExtensionProviderResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateExtensionProviderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateExtensionProviderResponseBody(name='body'),
}

async function createExtensionProviderWithOptions(request: CreateExtensionProviderRequest, runtime: Util.RuntimeOptions): CreateExtensionProviderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateExtensionProvider', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createExtensionProvider(request: CreateExtensionProviderRequest): CreateExtensionProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createExtensionProviderWithOptions(request, runtime);
}

model CreateServiceMeshRequest {
  accessLogEnabled?: boolean(name='AccessLogEnabled'),
  accessLogFile?: string(name='AccessLogFile'),
  accessLogFormat?: string(name='AccessLogFormat'),
  accessLogProject?: string(name='AccessLogProject'),
  accessLogServiceEnabled?: boolean(name='AccessLogServiceEnabled'),
  accessLogServiceHost?: string(name='AccessLogServiceHost'),
  accessLogServicePort?: int32(name='AccessLogServicePort'),
  apiServerPublicEip?: boolean(name='ApiServerPublicEip'),
  auditProject?: string(name='AuditProject'),
  CRAggregationEnabled?: boolean(name='CRAggregationEnabled'),
  configSourceEnabled?: boolean(name='ConfigSourceEnabled'),
  configSourceNacosID?: string(name='ConfigSourceNacosID'),
  controlPlaneLogEnabled?: boolean(name='ControlPlaneLogEnabled'),
  controlPlaneLogProject?: string(name='ControlPlaneLogProject'),
  customizedPrometheus?: boolean(name='CustomizedPrometheus'),
  customizedZipkin?: boolean(name='CustomizedZipkin'),
  DNSProxyingEnabled?: boolean(name='DNSProxyingEnabled'),
  dubboFilterEnabled?: boolean(name='DubboFilterEnabled'),
  edition?: string(name='Edition'),
  enableAudit?: boolean(name='EnableAudit'),
  enableCRHistory?: boolean(name='EnableCRHistory'),
  enableSDSServer?: boolean(name='EnableSDSServer'),
  excludeIPRanges?: string(name='ExcludeIPRanges'),
  excludeInboundPorts?: string(name='ExcludeInboundPorts'),
  excludeOutboundPorts?: string(name='ExcludeOutboundPorts'),
  filterGatewayClusterConfig?: boolean(name='FilterGatewayClusterConfig'),
  gatewayAPIEnabled?: boolean(name='GatewayAPIEnabled'),
  includeIPRanges?: string(name='IncludeIPRanges'),
  istioVersion?: string(name='IstioVersion'),
  kialiEnabled?: boolean(name='KialiEnabled'),
  localityLBConf?: string(name='LocalityLBConf'),
  localityLoadBalancing?: boolean(name='LocalityLoadBalancing'),
  MSEEnabled?: boolean(name='MSEEnabled'),
  mysqlFilterEnabled?: boolean(name='MysqlFilterEnabled'),
  name?: string(name='Name'),
  OPALimitCPU?: string(name='OPALimitCPU'),
  OPALimitMemory?: string(name='OPALimitMemory'),
  OPALogLevel?: string(name='OPALogLevel'),
  OPARequestCPU?: string(name='OPARequestCPU'),
  OPARequestMemory?: string(name='OPARequestMemory'),
  opaEnabled?: boolean(name='OpaEnabled'),
  openAgentPolicy?: boolean(name='OpenAgentPolicy'),
  pilotPublicEip?: boolean(name='PilotPublicEip'),
  prometheusUrl?: string(name='PrometheusUrl'),
  proxyLimitCPU?: string(name='ProxyLimitCPU'),
  proxyLimitMemory?: string(name='ProxyLimitMemory'),
  proxyRequestCPU?: string(name='ProxyRequestCPU'),
  proxyRequestMemory?: string(name='ProxyRequestMemory'),
  redisFilterEnabled?: boolean(name='RedisFilterEnabled'),
  regionId?: string(name='RegionId'),
  telemetry?: boolean(name='Telemetry'),
  thriftFilterEnabled?: boolean(name='ThriftFilterEnabled'),
  traceSampling?: float(name='TraceSampling'),
  tracing?: boolean(name='Tracing'),
  vSwitches?: string(name='VSwitches'),
  vpcId?: string(name='VpcId'),
  webAssemblyFilterEnabled?: boolean(name='WebAssemblyFilterEnabled'),
}

model CreateServiceMeshResponseBody = {
  requestId?: string(name='RequestId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model CreateServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServiceMeshResponseBody(name='body'),
}

async function createServiceMeshWithOptions(request: CreateServiceMeshRequest, runtime: Util.RuntimeOptions): CreateServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createServiceMesh(request: CreateServiceMeshRequest): CreateServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceMeshWithOptions(request, runtime);
}

model DeleteExtensionProviderRequest {
  name?: string(name='Name'),
  serviceMeshId?: string(name='ServiceMeshId'),
  type?: string(name='Type'),
}

model DeleteExtensionProviderResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExtensionProviderResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExtensionProviderResponseBody(name='body'),
}

async function deleteExtensionProviderWithOptions(request: DeleteExtensionProviderRequest, runtime: Util.RuntimeOptions): DeleteExtensionProviderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteExtensionProvider', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteExtensionProvider(request: DeleteExtensionProviderRequest): DeleteExtensionProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExtensionProviderWithOptions(request, runtime);
}

model DeleteServiceMeshRequest {
  force?: boolean(name='Force'),
  retainResources?: string(name='RetainResources'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DeleteServiceMeshResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteServiceMeshResponseBody(name='body'),
}

async function deleteServiceMeshWithOptions(request: DeleteServiceMeshRequest, runtime: Util.RuntimeOptions): DeleteServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteServiceMesh(request: DeleteServiceMeshRequest): DeleteServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServiceMeshWithOptions(request, runtime);
}

model DescribeAlertActionPoliciesRequest {
  page?: int32(name='Page'),
}

model DescribeAlertActionPoliciesResponseBody = {
  actionPolicyList?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
    }
  ](name='ActionPolicyList'),
  pageTotal?: int32(name='PageTotal'),
  requestId?: string(name='RequestId'),
}

model DescribeAlertActionPoliciesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAlertActionPoliciesResponseBody(name='body'),
}

async function describeAlertActionPoliciesWithOptions(request: DescribeAlertActionPoliciesRequest, runtime: Util.RuntimeOptions): DescribeAlertActionPoliciesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeAlertActionPolicies', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeAlertActionPolicies(request: DescribeAlertActionPoliciesRequest): DescribeAlertActionPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlertActionPoliciesWithOptions(request, runtime);
}

model DescribeAvailableNacosInstancesRequest {
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
}

model DescribeAvailableNacosInstancesResponseBody = {
  data?: [ string ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableNacosInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableNacosInstancesResponseBody(name='body'),
}

async function describeAvailableNacosInstancesWithOptions(request: DescribeAvailableNacosInstancesRequest, runtime: Util.RuntimeOptions): DescribeAvailableNacosInstancesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeAvailableNacosInstances', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeAvailableNacosInstances(request: DescribeAvailableNacosInstancesRequest): DescribeAvailableNacosInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableNacosInstancesWithOptions(request, runtime);
}

model DescribeCensRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeCensResponseBody = {
  clusters?: [ string ](name='Clusters'),
  requestId?: string(name='RequestId'),
}

model DescribeCensResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCensResponseBody(name='body'),
}

async function describeCensWithOptions(request: DescribeCensRequest, runtime: Util.RuntimeOptions): DescribeCensResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeCens', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeCens(request: DescribeCensRequest): DescribeCensResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCensWithOptions(request, runtime);
}

model DescribeClusterGrafanaRequest {
  k8sClusterId?: string(name='K8sClusterId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeClusterGrafanaResponseBody = {
  dashboards?: [ 
    {
      title?: string(name='Title'),
      url?: string(name='Url'),
    }
  ](name='Dashboards'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterGrafanaResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterGrafanaResponseBody(name='body'),
}

async function describeClusterGrafanaWithOptions(request: DescribeClusterGrafanaRequest, runtime: Util.RuntimeOptions): DescribeClusterGrafanaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeClusterGrafana', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeClusterGrafana(request: DescribeClusterGrafanaRequest): DescribeClusterGrafanaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterGrafanaWithOptions(request, runtime);
}

model DescribeClusterPrometheusRequest {
  k8sClusterId?: string(name='K8sClusterId'),
  k8sClusterRegionId?: string(name='K8sClusterRegionId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeClusterPrometheusResponseBody = {
  prometheus?: string(name='Prometheus'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterPrometheusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterPrometheusResponseBody(name='body'),
}

async function describeClusterPrometheusWithOptions(request: DescribeClusterPrometheusRequest, runtime: Util.RuntimeOptions): DescribeClusterPrometheusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeClusterPrometheus', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeClusterPrometheus(request: DescribeClusterPrometheusRequest): DescribeClusterPrometheusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterPrometheusWithOptions(request, runtime);
}

model DescribeClustersInServiceMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeClustersInServiceMeshResponseBody = {
  clusters?: [ 
    {
      accessLogDashboards?: [ 
        {
          title?: string(name='Title'),
          url?: string(name='Url'),
        }
      ](name='AccessLogDashboards'),
      clusterDomain?: string(name='ClusterDomain'),
      clusterId?: string(name='ClusterId'),
      clusterType?: string(name='ClusterType'),
      creationTime?: string(name='CreationTime'),
      errorMessage?: string(name='ErrorMessage'),
      logtailInstalledState?: string(name='LogtailInstalledState'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      sgId?: string(name='SgId'),
      state?: string(name='State'),
      updateTime?: string(name='UpdateTime'),
      version?: string(name='Version'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Clusters'),
  requestId?: string(name='RequestId'),
}

model DescribeClustersInServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClustersInServiceMeshResponseBody(name='body'),
}

async function describeClustersInServiceMeshWithOptions(request: DescribeClustersInServiceMeshRequest, runtime: Util.RuntimeOptions): DescribeClustersInServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeClustersInServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeClustersInServiceMesh(request: DescribeClustersInServiceMeshRequest): DescribeClustersInServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClustersInServiceMeshWithOptions(request, runtime);
}

model DescribeControlPlaneLogAlertRulesRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeControlPlaneLogAlertRulesResponseBody = {
  data?: [ 
    {
      actionPolicyId?: string(name='ActionPolicyId'),
      enabled?: boolean(name='Enabled'),
      info?: {
        description?: string(name='Description'),
        title?: string(name='Title'),
      }(name='Info'),
      ruleId?: string(name='RuleId'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeControlPlaneLogAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeControlPlaneLogAlertRulesResponseBody(name='body'),
}

async function describeControlPlaneLogAlertRulesWithOptions(request: DescribeControlPlaneLogAlertRulesRequest, runtime: Util.RuntimeOptions): DescribeControlPlaneLogAlertRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeControlPlaneLogAlertRules', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeControlPlaneLogAlertRules(request: DescribeControlPlaneLogAlertRulesRequest): DescribeControlPlaneLogAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeControlPlaneLogAlertRulesWithOptions(request, runtime);
}

model DescribeCrTemplatesRequest {
  istioVersion?: string(name='IstioVersion'),
  kind?: string(name='Kind'),
}

model DescribeCrTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  templates?: [ 
    {
      chineseName?: string(name='ChineseName'),
      englishName?: string(name='EnglishName'),
      yaml?: string(name='Yaml'),
    }
  ](name='Templates'),
}

model DescribeCrTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCrTemplatesResponseBody(name='body'),
}

async function describeCrTemplatesWithOptions(request: DescribeCrTemplatesRequest, runtime: Util.RuntimeOptions): DescribeCrTemplatesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeCrTemplates', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeCrTemplates(request: DescribeCrTemplatesRequest): DescribeCrTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCrTemplatesWithOptions(request, runtime);
}

model DescribeExtensionProviderRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
  type?: string(name='Type'),
}

model DescribeExtensionProviderResponseBody = {
  extensionProviders?: [  map[string]any ](name='ExtensionProviders'),
  requestId?: string(name='RequestId'),
}

model DescribeExtensionProviderResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeExtensionProviderResponseBody(name='body'),
}

async function describeExtensionProviderWithOptions(request: DescribeExtensionProviderRequest, runtime: Util.RuntimeOptions): DescribeExtensionProviderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeExtensionProvider', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeExtensionProvider(request: DescribeExtensionProviderRequest): DescribeExtensionProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExtensionProviderWithOptions(request, runtime);
}

model DescribeGuestClusterAccessLogDashboardsRequest {
  k8sClusterId?: string(name='K8sClusterId'),
}

model DescribeGuestClusterAccessLogDashboardsResponseBody = {
  dashboards?: [ 
    {
      title?: string(name='Title'),
      url?: string(name='Url'),
    }
  ](name='Dashboards'),
  k8sClusterId?: string(name='K8sClusterId'),
  requestId?: string(name='RequestId'),
}

model DescribeGuestClusterAccessLogDashboardsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGuestClusterAccessLogDashboardsResponseBody(name='body'),
}

async function describeGuestClusterAccessLogDashboardsWithOptions(request: DescribeGuestClusterAccessLogDashboardsRequest, runtime: Util.RuntimeOptions): DescribeGuestClusterAccessLogDashboardsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeGuestClusterAccessLogDashboards', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeGuestClusterAccessLogDashboards(request: DescribeGuestClusterAccessLogDashboardsRequest): DescribeGuestClusterAccessLogDashboardsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGuestClusterAccessLogDashboardsWithOptions(request, runtime);
}

model DescribeGuestClusterNamespacesRequest {
  guestClusterID?: string(name='GuestClusterID'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeGuestClusterNamespacesResponseBody = {
  nsList?: [ string ](name='NsList'),
  requestId?: string(name='RequestId'),
}

model DescribeGuestClusterNamespacesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGuestClusterNamespacesResponseBody(name='body'),
}

async function describeGuestClusterNamespacesWithOptions(request: DescribeGuestClusterNamespacesRequest, runtime: Util.RuntimeOptions): DescribeGuestClusterNamespacesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeGuestClusterNamespaces', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeGuestClusterNamespaces(request: DescribeGuestClusterNamespacesRequest): DescribeGuestClusterNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGuestClusterNamespacesWithOptions(request, runtime);
}

model DescribeGuestClusterPodsRequest {
  guestClusterID?: string(name='GuestClusterID'),
  namespace?: string(name='Namespace'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeGuestClusterPodsResponseBody = {
  podList?: [ string ](name='PodList'),
  requestId?: string(name='RequestId'),
}

model DescribeGuestClusterPodsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGuestClusterPodsResponseBody(name='body'),
}

async function describeGuestClusterPodsWithOptions(request: DescribeGuestClusterPodsRequest, runtime: Util.RuntimeOptions): DescribeGuestClusterPodsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeGuestClusterPods', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeGuestClusterPods(request: DescribeGuestClusterPodsRequest): DescribeGuestClusterPodsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGuestClusterPodsWithOptions(request, runtime);
}

model DescribeIngressGatewaysRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeIngressGatewaysResponseBody = {
  ingressGateways?: [  map[string]any ](name='IngressGateways'),
  requestId?: string(name='RequestId'),
}

model DescribeIngressGatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIngressGatewaysResponseBody(name='body'),
}

async function describeIngressGatewaysWithOptions(request: DescribeIngressGatewaysRequest, runtime: Util.RuntimeOptions): DescribeIngressGatewaysResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeIngressGateways', '2020-01-11', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeIngressGateways(request: DescribeIngressGatewaysRequest): DescribeIngressGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIngressGatewaysWithOptions(request, runtime);
}

model DescribeNamespaceScopeSidecarConfigRequest {
  namespace?: string(name='Namespace'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeNamespaceScopeSidecarConfigResponseBody = {
  configPatches?: {
    excludeInboundPorts?: string(name='ExcludeInboundPorts'),
    excludeOutboundIPRanges?: string(name='ExcludeOutboundIPRanges'),
    excludeOutboundPorts?: string(name='ExcludeOutboundPorts'),
    includeInboundPorts?: string(name='IncludeInboundPorts'),
    includeOutboundIPRanges?: string(name='IncludeOutboundIPRanges'),
    includeOutboundPorts?: string(name='IncludeOutboundPorts'),
    istioDNSProxyEnabled?: boolean(name='IstioDNSProxyEnabled'),
    lifecycleStr?: string(name='LifecycleStr'),
    sidecarProxyInitResourceLimit?: {
      resourceCPULimit?: string(name='ResourceCPULimit'),
      resourceMemoryLimit?: string(name='ResourceMemoryLimit'),
    }(name='SidecarProxyInitResourceLimit'),
    sidecarProxyInitResourceRequest?: {
      resourceCPURequest?: string(name='ResourceCPURequest'),
      resourceMemoryRequest?: string(name='ResourceMemoryRequest'),
    }(name='SidecarProxyInitResourceRequest'),
    sidecarProxyResourceLimit?: {
      resourceCPULimit?: string(name='ResourceCPULimit'),
      resourceMemoryLimit?: string(name='ResourceMemoryLimit'),
    }(name='SidecarProxyResourceLimit'),
    sidecarProxyResourceRequest?: {
      resourceCPURequest?: string(name='ResourceCPURequest'),
      resourceMemoryRequest?: string(name='ResourceMemoryRequest'),
    }(name='SidecarProxyResourceRequest'),
    terminationDrainDuration?: string(name='TerminationDrainDuration'),
  }(name='ConfigPatches'),
  requestId?: string(name='RequestId'),
}

model DescribeNamespaceScopeSidecarConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNamespaceScopeSidecarConfigResponseBody(name='body'),
}

async function describeNamespaceScopeSidecarConfigWithOptions(request: DescribeNamespaceScopeSidecarConfigRequest, runtime: Util.RuntimeOptions): DescribeNamespaceScopeSidecarConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeNamespaceScopeSidecarConfig', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeNamespaceScopeSidecarConfig(request: DescribeNamespaceScopeSidecarConfigRequest): DescribeNamespaceScopeSidecarConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNamespaceScopeSidecarConfigWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model DescribeRegionsResponseBody = {
  businessLocations?: string(name='BusinessLocations'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeRegions', '2020-01-11', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeServiceMeshDetailRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeServiceMeshDetailResponseBody = {
  requestId?: string(name='RequestId'),
  serviceMesh?: {
    clusters?: [ string ](name='Clusters'),
    endpoints?: {
      intranetApiServerEndpoint?: string(name='IntranetApiServerEndpoint'),
      intranetPilotEndpoint?: string(name='IntranetPilotEndpoint'),
      publicApiServerEndpoint?: string(name='PublicApiServerEndpoint'),
      publicPilotEndpoint?: string(name='PublicPilotEndpoint'),
    }(name='Endpoints'),
    serviceMeshInfo?: {
      creationTime?: string(name='CreationTime'),
      errorMessage?: string(name='ErrorMessage'),
      name?: string(name='Name'),
      profile?: string(name='Profile'),
      regionId?: string(name='RegionId'),
      serviceMeshId?: string(name='ServiceMeshId'),
      state?: string(name='State'),
      updateTime?: string(name='UpdateTime'),
      version?: string(name='Version'),
    }(name='ServiceMeshInfo'),
    spec?: {
      loadBalancer?: {
        apiServerLoadbalancerId?: string(name='ApiServerLoadbalancerId'),
        apiServerPublicEip?: boolean(name='ApiServerPublicEip'),
        pilotPublicEip?: boolean(name='PilotPublicEip'),
        pilotPublicLoadbalancerId?: string(name='PilotPublicLoadbalancerId'),
      }(name='LoadBalancer'),
      meshConfig?: {
        accessLog?: {
          enabled?: boolean(name='Enabled'),
          project?: string(name='Project'),
        }(name='AccessLog'),
        audit?: {
          auditProjectStatus?: string(name='AuditProjectStatus'),
          enabled?: boolean(name='Enabled'),
          project?: string(name='Project'),
        }(name='Audit'),
        controlPlaneLogInfo?: {
          enabled?: boolean(name='Enabled'),
          project?: string(name='Project'),
        }(name='ControlPlaneLogInfo'),
        customizedZipkin?: boolean(name='CustomizedZipkin'),
        edition?: {
          istiodImageTag?: string(name='IstiodImageTag'),
          name?: string(name='Name'),
          proxyImageTag?: string(name='ProxyImageTag'),
        }(name='Edition'),
        enableLocalityLB?: boolean(name='EnableLocalityLB'),
        excludeIPRanges?: string(name='ExcludeIPRanges'),
        excludeInboundPorts?: string(name='ExcludeInboundPorts'),
        excludeOutboundPorts?: string(name='ExcludeOutboundPorts'),
        extraConfiguration?: {
          CRAggregationEnabled?: boolean(name='CRAggregationEnabled'),
          discoverySelectors?: [  map[string]any ](name='DiscoverySelectors'),
          istioCRHistory?: {
            enableHistory?: boolean(name='EnableHistory'),
          }(name='IstioCRHistory'),
          lifecycle?: {
            postStart?: {
              exec?: {
                command?: [ string ](name='Command'),
              }(name='Exec'),
              HTTPGet?: {
                HTTPHeaders?: [ 
                  {
                    name?: string(name='Name'),
                    value?: string(name='Value'),
                  }
                ](name='HTTPHeaders'),
                host?: string(name='Host'),
                port?: string(name='Port'),
                scheme?: string(name='Scheme'),
              }(name='HTTPGet'),
              TCPSocket?: {
                host?: string(name='Host'),
                port?: string(name='Port'),
              }(name='TCPSocket'),
            }(name='PostStart'),
            preStop?: {
              exec?: {
                command?: [ string ](name='Command'),
              }(name='Exec'),
              HTTPGet?: {
                HTTPHeaders?: [ 
                  {
                    name?: string(name='Name'),
                    value?: string(name='Value'),
                  }
                ](name='HTTPHeaders'),
                host?: string(name='Host'),
                port?: string(name='Port'),
                scheme?: string(name='Scheme'),
              }(name='HTTPGet'),
              TCPSocket?: {
                host?: string(name='Host'),
                port?: string(name='Port'),
              }(name='TCPSocket'),
            }(name='PreStop'),
          }(name='Lifecycle'),
          multiBuffer?: {
            enabled?: boolean(name='Enabled'),
            pollDelay?: string(name='PollDelay'),
          }(name='MultiBuffer'),
          sidecarProxyInitResourceLimit?: {
            resourceCPULimit?: string(name='ResourceCPULimit'),
            resourceMemoryLimit?: string(name='ResourceMemoryLimit'),
          }(name='SidecarProxyInitResourceLimit'),
          sidecarProxyInitResourceRequest?: {
            resourceCPURequest?: string(name='ResourceCPURequest'),
            resourceMemoryRequest?: string(name='ResourceMemoryRequest'),
          }(name='SidecarProxyInitResourceRequest'),
          terminationDrainDuration?: string(name='TerminationDrainDuration'),
        }(name='ExtraConfiguration'),
        includeIPRanges?: string(name='IncludeIPRanges'),
        k8sNewAPIsSupport?: {
          gatewayAPIEnabled?: boolean(name='GatewayAPIEnabled'),
        }(name='K8sNewAPIsSupport'),
        kiali?: {
          enabled?: boolean(name='Enabled'),
          url?: string(name='Url'),
        }(name='Kiali'),
        localityLB?: {
          distribute?: map[string]any(name='Distribute'),
          enabled?: boolean(name='Enabled'),
          failover?: map[string]any(name='Failover'),
        }(name='LocalityLB'),
        MSE?: {
          enabled?: boolean(name='Enabled'),
        }(name='MSE'),
        OPA?: {
          enabled?: boolean(name='Enabled'),
          limitCPU?: string(name='LimitCPU'),
          limitMemory?: string(name='LimitMemory'),
          logLevel?: string(name='LogLevel'),
          requestCPU?: string(name='RequestCPU'),
          requestMemory?: string(name='RequestMemory'),
        }(name='OPA'),
        outboundTrafficPolicy?: string(name='OutboundTrafficPolicy'),
        pilot?: {
          configSource?: {
            enabled?: boolean(name='Enabled'),
            nacosID?: string(name='NacosID'),
          }(name='ConfigSource'),
          feature?: {
            enableSDSServer?: boolean(name='EnableSDSServer'),
            filterGatewayClusterConfig?: boolean(name='FilterGatewayClusterConfig'),
          }(name='Feature'),
          http10Enabled?: boolean(name='Http10Enabled'),
          traceSampling?: float(name='TraceSampling'),
        }(name='Pilot'),
        prometheus?: {
          externalUrl?: string(name='ExternalUrl'),
          useExternal?: boolean(name='UseExternal'),
        }(name='Prometheus'),
        protocolSupport?: {
          dubboFilterEnabled?: boolean(name='DubboFilterEnabled'),
          mysqlFilterEnabled?: boolean(name='MysqlFilterEnabled'),
          redisFilterEnabled?: boolean(name='RedisFilterEnabled'),
          thriftFilterEnabled?: boolean(name='ThriftFilterEnabled'),
        }(name='ProtocolSupport'),
        proxy?: {
          accessLogFile?: string(name='AccessLogFile'),
          accessLogFormat?: string(name='AccessLogFormat'),
          accessLogServiceEnabled?: boolean(name='AccessLogServiceEnabled'),
          accessLogServiceHost?: string(name='AccessLogServiceHost'),
          accessLogServicePort?: int32(name='AccessLogServicePort'),
          clusterDomain?: string(name='ClusterDomain'),
          enableDNSProxying?: boolean(name='EnableDNSProxying'),
          limitCPU?: string(name='LimitCPU'),
          limitMemory?: string(name='LimitMemory'),
          requestCPU?: string(name='RequestCPU'),
          requestMemory?: string(name='RequestMemory'),
        }(name='Proxy'),
        sidecarInjector?: {
          autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled'),
          enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault'),
          initCNIConfiguration?: {
            enabled?: boolean(name='Enabled'),
            excludeNamespaces?: string(name='ExcludeNamespaces'),
          }(name='InitCNIConfiguration'),
          limitCPU?: string(name='LimitCPU'),
          limitMemory?: string(name='LimitMemory'),
          requestCPU?: string(name='RequestCPU'),
          requestMemory?: string(name='RequestMemory'),
          sidecarInjectorWebhookAsYaml?: string(name='SidecarInjectorWebhookAsYaml'),
        }(name='SidecarInjector'),
        telemetry?: boolean(name='Telemetry'),
        tracing?: boolean(name='Tracing'),
        webAssemblyFilterDeployment?: {
          enabled?: boolean(name='Enabled'),
        }(name='WebAssemblyFilterDeployment'),
      }(name='MeshConfig'),
      network?: {
        securityGroupId?: string(name='SecurityGroupId'),
        vSwitches?: [ string ](name='VSwitches'),
        vpcId?: string(name='VpcId'),
      }(name='Network'),
    }(name='Spec'),
  }(name='ServiceMesh'),
}

model DescribeServiceMeshDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServiceMeshDetailResponseBody(name='body'),
}

async function describeServiceMeshDetailWithOptions(request: DescribeServiceMeshDetailRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshDetailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeServiceMeshDetail', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeServiceMeshDetail(request: DescribeServiceMeshDetailRequest): DescribeServiceMeshDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshDetailWithOptions(request, runtime);
}

model DescribeServiceMeshGatewayPodStatusRequest {
  gatewayFullName?: string(name='GatewayFullName'),
  guestClusterIds?: string(name='GuestClusterIds'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeServiceMeshGatewayPodStatusResponseBody = {
  ASMGatewayDetails?: [ 
    {
      clusterID?: string(name='ClusterID'),
      gatewayName?: string(name='GatewayName'),
      readyPodNum?: long(name='ReadyPodNum'),
      specPodNum?: long(name='SpecPodNum'),
    }
  ](name='ASMGatewayDetails'),
  requestId?: string(name='RequestId'),
}

model DescribeServiceMeshGatewayPodStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServiceMeshGatewayPodStatusResponseBody(name='body'),
}

async function describeServiceMeshGatewayPodStatusWithOptions(request: DescribeServiceMeshGatewayPodStatusRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshGatewayPodStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeServiceMeshGatewayPodStatus', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeServiceMeshGatewayPodStatus(request: DescribeServiceMeshGatewayPodStatusRequest): DescribeServiceMeshGatewayPodStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshGatewayPodStatusWithOptions(request, runtime);
}

model DescribeServiceMeshGatewaySLBStatusRequest {
  gatewayAddresses?: string(name='GatewayAddresses'),
  gatewayFullName?: string(name='GatewayFullName'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeServiceMeshGatewaySLBStatusResponseBody = {
  gatewaySLB?: map[string]GatewaySLBValue(name='GatewaySLB'),
  requestId?: string(name='RequestId'),
}

model DescribeServiceMeshGatewaySLBStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServiceMeshGatewaySLBStatusResponseBody(name='body'),
}

async function describeServiceMeshGatewaySLBStatusWithOptions(request: DescribeServiceMeshGatewaySLBStatusRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshGatewaySLBStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeServiceMeshGatewaySLBStatus', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeServiceMeshGatewaySLBStatus(request: DescribeServiceMeshGatewaySLBStatusRequest): DescribeServiceMeshGatewaySLBStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshGatewaySLBStatusWithOptions(request, runtime);
}

model DescribeServiceMeshKubeconfigRequest {
  privateIpAddress?: boolean(name='PrivateIpAddress'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeServiceMeshKubeconfigResponseBody = {
  kubeconfig?: string(name='Kubeconfig'),
  requestId?: string(name='RequestId'),
}

model DescribeServiceMeshKubeconfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServiceMeshKubeconfigResponseBody(name='body'),
}

async function describeServiceMeshKubeconfigWithOptions(request: DescribeServiceMeshKubeconfigRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshKubeconfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeServiceMeshKubeconfig', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeServiceMeshKubeconfig(request: DescribeServiceMeshKubeconfigRequest): DescribeServiceMeshKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshKubeconfigWithOptions(request, runtime);
}

model DescribeServiceMeshUpgradeStatusRequest {
  allIstioGatewayFullNames?: string(name='AllIstioGatewayFullNames'),
  guestClusterIds?: string(name='GuestClusterIds'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeServiceMeshUpgradeStatusResponseBody = {
  requestId?: string(name='RequestId'),
  upgradeDetail?: {
    finishedGatewaysNum?: long(name='FinishedGatewaysNum'),
    gatewayStatusRecord?: map[string]UpgradeDetailGatewayStatusRecordValue(name='GatewayStatusRecord'),
    meshStatus?: string(name='MeshStatus'),
    totalGatewaysNum?: long(name='TotalGatewaysNum'),
  }(name='UpgradeDetail'),
}

model DescribeServiceMeshUpgradeStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServiceMeshUpgradeStatusResponseBody(name='body'),
}

async function describeServiceMeshUpgradeStatusWithOptions(request: DescribeServiceMeshUpgradeStatusRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshUpgradeStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeServiceMeshUpgradeStatus', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeServiceMeshUpgradeStatus(request: DescribeServiceMeshUpgradeStatusRequest): DescribeServiceMeshUpgradeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshUpgradeStatusWithOptions(request, runtime);
}

model DescribeServiceMeshVMsRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeServiceMeshVMsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  VMs?: [ 
    {
      hasTag?: boolean(name='HasTag'),
      hostName?: string(name='HostName'),
      instanceId?: string(name='InstanceId'),
      ipAddress?: string(name='IpAddress'),
      region?: string(name='Region'),
      securityGroupIds?: string(name='SecurityGroupIds'),
      serviceMeshId?: string(name='ServiceMeshId'),
      status?: string(name='Status'),
    }
  ](name='VMs'),
}

model DescribeServiceMeshVMsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServiceMeshVMsResponseBody(name='body'),
}

async function describeServiceMeshVMsWithOptions(request: DescribeServiceMeshVMsRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshVMsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeServiceMeshVMs', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeServiceMeshVMs(request: DescribeServiceMeshVMsRequest): DescribeServiceMeshVMsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshVMsWithOptions(request, runtime);
}

model DescribeServiceMeshesResponseBody = {
  requestId?: string(name='RequestId'),
  serviceMeshes?: [ 
    {
      clusters?: [ string ](name='Clusters'),
      endpoints?: {
        intranetApiServerEndpoint?: string(name='IntranetApiServerEndpoint'),
        intranetPilotEndpoint?: string(name='IntranetPilotEndpoint'),
        publicApiServerEndpoint?: string(name='PublicApiServerEndpoint'),
        publicPilotEndpoint?: string(name='PublicPilotEndpoint'),
        reverseTunnelEndpoint?: string(name='ReverseTunnelEndpoint'),
      }(name='Endpoints'),
      serviceMeshInfo?: {
        creationTime?: string(name='CreationTime'),
        errorMessage?: string(name='ErrorMessage'),
        name?: string(name='Name'),
        profile?: string(name='Profile'),
        regionId?: string(name='RegionId'),
        serviceMeshId?: string(name='ServiceMeshId'),
        state?: string(name='State'),
        updateTime?: string(name='UpdateTime'),
        version?: string(name='Version'),
      }(name='ServiceMeshInfo'),
      spec?: {
        loadBalancer?: {
          apiServerLoadbalancerId?: string(name='ApiServerLoadbalancerId'),
          apiServerPublicEip?: boolean(name='ApiServerPublicEip'),
          pilotPublicEip?: boolean(name='PilotPublicEip'),
          pilotPublicLoadbalancerId?: string(name='PilotPublicLoadbalancerId'),
        }(name='LoadBalancer'),
        meshConfig?: {
          mtls?: boolean(name='Mtls'),
          outboundTrafficPolicy?: string(name='OutboundTrafficPolicy'),
          pilot?: {
            http10Enabled?: boolean(name='Http10Enabled'),
            traceSampling?: float(name='TraceSampling'),
          }(name='Pilot'),
          sidecarInjector?: {
            autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled'),
            enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault'),
            initCNIConfiguration?: {
              enabled?: boolean(name='Enabled'),
              excludeNamespaces?: string(name='ExcludeNamespaces'),
            }(name='InitCNIConfiguration'),
          }(name='SidecarInjector'),
          strictMtls?: boolean(name='StrictMtls'),
          telemetry?: boolean(name='Telemetry'),
          tracing?: boolean(name='Tracing'),
        }(name='MeshConfig'),
        network?: {
          securityGroupId?: string(name='SecurityGroupId'),
          vSwitches?: [ string ](name='VSwitches'),
          vpcId?: string(name='VpcId'),
        }(name='Network'),
      }(name='Spec'),
    }
  ](name='ServiceMeshes'),
}

model DescribeServiceMeshesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServiceMeshesResponseBody(name='body'),
}

async function describeServiceMeshesWithOptions(runtime: Util.RuntimeOptions): DescribeServiceMeshesResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('DescribeServiceMeshes', '2020-01-11', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeServiceMeshes(): DescribeServiceMeshesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshesWithOptions(runtime);
}

model DescribeUpgradeVersionRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeUpgradeVersionResponseBody = {
  requestId?: string(name='RequestId'),
  version?: {
    istioOperatorVersion?: string(name='IstioOperatorVersion'),
    istioVersion?: string(name='IstioVersion'),
    kubernetesVersion?: string(name='KubernetesVersion'),
  }(name='Version'),
}

model DescribeUpgradeVersionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUpgradeVersionResponseBody(name='body'),
}

async function describeUpgradeVersionWithOptions(request: DescribeUpgradeVersionRequest, runtime: Util.RuntimeOptions): DescribeUpgradeVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeUpgradeVersion', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeUpgradeVersion(request: DescribeUpgradeVersionRequest): DescribeUpgradeVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUpgradeVersionWithOptions(request, runtime);
}

model DescribeVMsInServiceMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeVMsInServiceMeshResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  VMs?: [ 
    {
      hasTag?: boolean(name='HasTag'),
      hostName?: string(name='HostName'),
      instanceId?: string(name='InstanceId'),
      ipAddress?: string(name='IpAddress'),
      region?: string(name='Region'),
      securityGroupIds?: string(name='SecurityGroupIds'),
      status?: string(name='Status'),
    }
  ](name='VMs'),
}

model DescribeVMsInServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVMsInServiceMeshResponseBody(name='body'),
}

async function describeVMsInServiceMeshWithOptions(request: DescribeVMsInServiceMeshRequest, runtime: Util.RuntimeOptions): DescribeVMsInServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVMsInServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVMsInServiceMesh(request: DescribeVMsInServiceMeshRequest): DescribeVMsInServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVMsInServiceMeshWithOptions(request, runtime);
}

model DescribeVSwitchesRequest {
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
}

model DescribeVSwitchesResponseBody = {
  maxResults?: int32(name='MaxResults', description='MaxResults本次请求所返回的最大记录条数'),
  nextToken?: string(name='NextToken', description='表示当前调用返回读取到的位置，空代表数据已经读取完毕'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount', description='TotalCount本次请求条件下的数据总量，此参数为可选参数，默认可不返回'),
  vSwitches?: [ 
    {
      isDefault?: boolean(name='IsDefault'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vSwitchName?: string(name='VSwitchName'),
      vpcId?: string(name='VpcId'),
    }
  ](name='VSwitches', description='VSwitches'),
}

model DescribeVSwitchesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVSwitchesResponseBody(name='body'),
}

async function describeVSwitchesWithOptions(request: DescribeVSwitchesRequest, runtime: Util.RuntimeOptions): DescribeVSwitchesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVSwitches', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVSwitchesWithOptions(request, runtime);
}

model DescribeVpcsRequest {
  regionId?: string(name='RegionId'),
}

model DescribeVpcsResponseBody = {
  maxResults?: int32(name='MaxResults', description='MaxResults本次请求所返回的最大记录条数'),
  nextToken?: string(name='NextToken', description='表示当前调用返回读取到的位置，空代表数据已经读取完毕'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount', description='TotalCount本次请求条件下的数据总量，此参数为可选参数，默认可不返回'),
  vpcs?: [ 
    {
      isDefault?: boolean(name='IsDefault'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
    }
  ](name='Vpcs', description='Vpcs'),
}

model DescribeVpcsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpcsResponseBody(name='body'),
}

async function describeVpcsWithOptions(request: DescribeVpcsRequest, runtime: Util.RuntimeOptions): DescribeVpcsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpcs', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpcs(request: DescribeVpcsRequest): DescribeVpcsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcsWithOptions(request, runtime);
}

model DisableControlPlaneLogAlertRequest {
  ruleId?: string(name='RuleId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DisableControlPlaneLogAlertResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableControlPlaneLogAlertResponse = {
  headers: map[string]string(name='headers'),
  body: DisableControlPlaneLogAlertResponseBody(name='body'),
}

async function disableControlPlaneLogAlertWithOptions(request: DisableControlPlaneLogAlertRequest, runtime: Util.RuntimeOptions): DisableControlPlaneLogAlertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableControlPlaneLogAlert', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableControlPlaneLogAlert(request: DisableControlPlaneLogAlertRequest): DisableControlPlaneLogAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableControlPlaneLogAlertWithOptions(request, runtime);
}

model EnableControlPlaneLogAlertRequest {
  actionPolicyId?: string(name='ActionPolicyId'),
  ruleId?: string(name='RuleId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model EnableControlPlaneLogAlertResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableControlPlaneLogAlertResponse = {
  headers: map[string]string(name='headers'),
  body: EnableControlPlaneLogAlertResponseBody(name='body'),
}

async function enableControlPlaneLogAlertWithOptions(request: EnableControlPlaneLogAlertRequest, runtime: Util.RuntimeOptions): EnableControlPlaneLogAlertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableControlPlaneLogAlert', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableControlPlaneLogAlert(request: EnableControlPlaneLogAlertRequest): EnableControlPlaneLogAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableControlPlaneLogAlertWithOptions(request, runtime);
}

model GetAutoInjectionLabelSyncStatusRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetAutoInjectionLabelSyncStatusResponseBody = {
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model GetAutoInjectionLabelSyncStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetAutoInjectionLabelSyncStatusResponseBody(name='body'),
}

async function getAutoInjectionLabelSyncStatusWithOptions(request: GetAutoInjectionLabelSyncStatusRequest, runtime: Util.RuntimeOptions): GetAutoInjectionLabelSyncStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetAutoInjectionLabelSyncStatus', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getAutoInjectionLabelSyncStatus(request: GetAutoInjectionLabelSyncStatusRequest): GetAutoInjectionLabelSyncStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAutoInjectionLabelSyncStatusWithOptions(request, runtime);
}

model GetBuiltinEnvoyFilterRequest {
  id?: string(name='Id'),
  istioVersion?: string(name='IstioVersion'),
  name?: string(name='Name'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetBuiltinEnvoyFilterResponseBody = {
  parameters?: string(name='Parameters'),
  requestId?: string(name='RequestId'),
}

model GetBuiltinEnvoyFilterResponse = {
  headers: map[string]string(name='headers'),
  body: GetBuiltinEnvoyFilterResponseBody(name='body'),
}

async function getBuiltinEnvoyFilterWithOptions(request: GetBuiltinEnvoyFilterRequest, runtime: Util.RuntimeOptions): GetBuiltinEnvoyFilterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetBuiltinEnvoyFilter', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getBuiltinEnvoyFilter(request: GetBuiltinEnvoyFilterRequest): GetBuiltinEnvoyFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBuiltinEnvoyFilterWithOptions(request, runtime);
}

model GetBuiltinEnvoyFilterCatalogRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetBuiltinEnvoyFilterCatalogResponseBody = {
  data?: map[string]any(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetBuiltinEnvoyFilterCatalogResponse = {
  headers: map[string]string(name='headers'),
  body: GetBuiltinEnvoyFilterCatalogResponseBody(name='body'),
}

async function getBuiltinEnvoyFilterCatalogWithOptions(request: GetBuiltinEnvoyFilterCatalogRequest, runtime: Util.RuntimeOptions): GetBuiltinEnvoyFilterCatalogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetBuiltinEnvoyFilterCatalog', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getBuiltinEnvoyFilterCatalog(request: GetBuiltinEnvoyFilterCatalogRequest): GetBuiltinEnvoyFilterCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBuiltinEnvoyFilterCatalogWithOptions(request, runtime);
}

model GetCaCertRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetCaCertResponseBody = {
  caCert?: string(name='CaCert', description='base64 encode format'),
  requestId?: string(name='RequestId'),
}

model GetCaCertResponse = {
  headers: map[string]string(name='headers'),
  body: GetCaCertResponseBody(name='body'),
}

async function getCaCertWithOptions(request: GetCaCertRequest, runtime: Util.RuntimeOptions): GetCaCertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetCaCert', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getCaCert(request: GetCaCertRequest): GetCaCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCaCertWithOptions(request, runtime);
}

model GetDiagnosisRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetDiagnosisResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  runAt?: string(name='RunAt'),
  status?: string(name='Status'),
}

model GetDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  body: GetDiagnosisResponseBody(name='body'),
}

async function getDiagnosisWithOptions(request: GetDiagnosisRequest, runtime: Util.RuntimeOptions): GetDiagnosisResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetDiagnosis', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getDiagnosis(request: GetDiagnosisRequest): GetDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDiagnosisWithOptions(request, runtime);
}

model GetEcsListRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetEcsListResponseBody = {
  ecsInstances?: [ 
    {
      hasTag?: boolean(name='HasTag'),
      hostName?: string(name='HostName'),
      instanceId?: string(name='InstanceId'),
      ipAddress?: string(name='IpAddress'),
      securityGroupIds?: [ string ](name='SecurityGroupIds'),
      status?: string(name='Status'),
    }
  ](name='EcsInstances'),
  requestId?: string(name='RequestId'),
}

model GetEcsListResponse = {
  headers: map[string]string(name='headers'),
  body: GetEcsListResponseBody(name='body'),
}

async function getEcsListWithOptions(request: GetEcsListRequest, runtime: Util.RuntimeOptions): GetEcsListResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetEcsList', '2020-01-11', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getEcsList(request: GetEcsListRequest): GetEcsListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEcsListWithOptions(request, runtime);
}

model GetRegisteredServiceEndpointsRequest {
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetRegisteredServiceEndpointsResponseBody = {
  requestId?: string(name='RequestId'),
  serviceEndpoints?: [ 
    {
      address?: string(name='Address'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='ServiceEndpoints'),
}

model GetRegisteredServiceEndpointsResponse = {
  headers: map[string]string(name='headers'),
  body: GetRegisteredServiceEndpointsResponseBody(name='body'),
}

async function getRegisteredServiceEndpointsWithOptions(request: GetRegisteredServiceEndpointsRequest, runtime: Util.RuntimeOptions): GetRegisteredServiceEndpointsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRegisteredServiceEndpoints', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRegisteredServiceEndpoints(request: GetRegisteredServiceEndpointsRequest): GetRegisteredServiceEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegisteredServiceEndpointsWithOptions(request, runtime);
}

model GetRegisteredServiceNamespacesRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetRegisteredServiceNamespacesResponseBody = {
  namespaces?: [ string ](name='Namespaces'),
  requestId?: string(name='RequestId'),
}

model GetRegisteredServiceNamespacesResponse = {
  headers: map[string]string(name='headers'),
  body: GetRegisteredServiceNamespacesResponseBody(name='body'),
}

async function getRegisteredServiceNamespacesWithOptions(request: GetRegisteredServiceNamespacesRequest, runtime: Util.RuntimeOptions): GetRegisteredServiceNamespacesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRegisteredServiceNamespaces', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRegisteredServiceNamespaces(request: GetRegisteredServiceNamespacesRequest): GetRegisteredServiceNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegisteredServiceNamespacesWithOptions(request, runtime);
}

model GetRegisteredServicesRequest {
  namespace?: string(name='Namespace'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetRegisteredServicesResponseBody = {
  requestId?: string(name='RequestId'),
  services?: [ string ](name='Services'),
}

model GetRegisteredServicesResponse = {
  headers: map[string]string(name='headers'),
  body: GetRegisteredServicesResponseBody(name='body'),
}

async function getRegisteredServicesWithOptions(request: GetRegisteredServicesRequest, runtime: Util.RuntimeOptions): GetRegisteredServicesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRegisteredServices', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRegisteredServices(request: GetRegisteredServicesRequest): GetRegisteredServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegisteredServicesWithOptions(request, runtime);
}

model GetSaTokenRequest {
  namespace?: string(name='Namespace'),
  needRefresh?: boolean(name='NeedRefresh'),
  serviceAccountName?: string(name='ServiceAccountName'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetSaTokenResponseBody = {
  requestId?: string(name='RequestId'),
  token?: string(name='Token', description='Token of service account'),
}

model GetSaTokenResponse = {
  headers: map[string]string(name='headers'),
  body: GetSaTokenResponseBody(name='body'),
}

async function getSaTokenWithOptions(request: GetSaTokenRequest, runtime: Util.RuntimeOptions): GetSaTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetSaToken', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getSaToken(request: GetSaTokenRequest): GetSaTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSaTokenWithOptions(request, runtime);
}

model GetServiceMeshSlbRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetServiceMeshSlbResponseBody = {
  data?: [ 
    {
      loadBalancerId?: string(name='LoadBalancerId'),
      serverHealthStatus?: string(name='ServerHealthStatus'),
      status?: string(name='Status'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model GetServiceMeshSlbResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceMeshSlbResponseBody(name='body'),
}

async function getServiceMeshSlbWithOptions(request: GetServiceMeshSlbRequest, runtime: Util.RuntimeOptions): GetServiceMeshSlbResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetServiceMeshSlb', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getServiceMeshSlb(request: GetServiceMeshSlbRequest): GetServiceMeshSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServiceMeshSlbWithOptions(request, runtime);
}

model GetServiceRegistrySourceRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetServiceRegistrySourceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  status?: string(name='Status'),
}

model GetServiceRegistrySourceResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceRegistrySourceResponseBody(name='body'),
}

async function getServiceRegistrySourceWithOptions(request: GetServiceRegistrySourceRequest, runtime: Util.RuntimeOptions): GetServiceRegistrySourceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetServiceRegistrySource', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getServiceRegistrySource(request: GetServiceRegistrySourceRequest): GetServiceRegistrySourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServiceRegistrySourceWithOptions(request, runtime);
}

model GetVmAppMeshInfoRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetVmAppMeshInfoResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetVmAppMeshInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetVmAppMeshInfoResponseBody(name='body'),
}

async function getVmAppMeshInfoWithOptions(request: GetVmAppMeshInfoRequest, runtime: Util.RuntimeOptions): GetVmAppMeshInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetVmAppMeshInfo', '2020-01-11', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getVmAppMeshInfo(request: GetVmAppMeshInfoRequest): GetVmAppMeshInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVmAppMeshInfoWithOptions(request, runtime);
}

model GetVmMetaRequest {
  namespace?: string(name='Namespace'),
  serviceAccount?: string(name='ServiceAccount'),
  serviceMeshId?: string(name='ServiceMeshId'),
  trustDomain?: string(name='TrustDomain'),
}

model GetVmMetaResponseBody = {
  requestId?: string(name='RequestId'),
  vmMetaInfo?: {
    envoyEnvContent?: string(name='EnvoyEnvContent'),
    hostsContent?: string(name='HostsContent'),
    tokenContent?: string(name='TokenContent'),
  }(name='VmMetaInfo'),
}

model GetVmMetaResponse = {
  headers: map[string]string(name='headers'),
  body: GetVmMetaResponseBody(name='body'),
}

async function getVmMetaWithOptions(request: GetVmMetaRequest, runtime: Util.RuntimeOptions): GetVmMetaResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetVmMeta', '2020-01-11', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getVmMeta(request: GetVmMetaRequest): GetVmMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVmMetaWithOptions(request, runtime);
}

model InitializeASMRoleResponseBody = {
  requestId?: string(name='RequestId'),
}

model InitializeASMRoleResponse = {
  headers: map[string]string(name='headers'),
  body: InitializeASMRoleResponseBody(name='body'),
}

async function initializeASMRoleWithOptions(runtime: Util.RuntimeOptions): InitializeASMRoleResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('InitializeASMRole', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function initializeASMRole(): InitializeASMRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return initializeASMRoleWithOptions(runtime);
}

model ListBuiltinEnvoyFilterRequest {
  id?: string(name='Id'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model ListBuiltinEnvoyFilterResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListBuiltinEnvoyFilterResponse = {
  headers: map[string]string(name='headers'),
  body: ListBuiltinEnvoyFilterResponseBody(name='body'),
}

async function listBuiltinEnvoyFilterWithOptions(request: ListBuiltinEnvoyFilterRequest, runtime: Util.RuntimeOptions): ListBuiltinEnvoyFilterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListBuiltinEnvoyFilter', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listBuiltinEnvoyFilter(request: ListBuiltinEnvoyFilterRequest): ListBuiltinEnvoyFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBuiltinEnvoyFilterWithOptions(request, runtime);
}

model ModifyBuiltinEnvoyFilterRequest {
  id?: string(name='Id'),
  istioVersion?: string(name='IstioVersion'),
  name?: string(name='Name'),
  parameters?: string(name='Parameters'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model ModifyBuiltinEnvoyFilterResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBuiltinEnvoyFilterResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBuiltinEnvoyFilterResponseBody(name='body'),
}

async function modifyBuiltinEnvoyFilterWithOptions(request: ModifyBuiltinEnvoyFilterRequest, runtime: Util.RuntimeOptions): ModifyBuiltinEnvoyFilterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyBuiltinEnvoyFilter', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyBuiltinEnvoyFilter(request: ModifyBuiltinEnvoyFilterRequest): ModifyBuiltinEnvoyFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBuiltinEnvoyFilterWithOptions(request, runtime);
}

model ModifyServiceMeshNameRequest {
  name?: string(name='Name'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model ModifyServiceMeshNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyServiceMeshNameResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyServiceMeshNameResponseBody(name='body'),
}

async function modifyServiceMeshNameWithOptions(request: ModifyServiceMeshNameRequest, runtime: Util.RuntimeOptions): ModifyServiceMeshNameResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyServiceMeshName', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyServiceMeshName(request: ModifyServiceMeshNameRequest): ModifyServiceMeshNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyServiceMeshNameWithOptions(request, runtime);
}

model ReActivateAuditRequest {
  enableAudit?: boolean(name='EnableAudit'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model ReActivateAuditResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ReActivateAuditResponse = {
  headers: map[string]string(name='headers'),
  body: ReActivateAuditResponseBody(name='body'),
}

async function reActivateAuditWithOptions(request: ReActivateAuditRequest, runtime: Util.RuntimeOptions): ReActivateAuditResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReActivateAudit', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function reActivateAudit(request: ReActivateAuditRequest): ReActivateAuditResponse {
  var runtime = new Util.RuntimeOptions{};
  return reActivateAuditWithOptions(request, runtime);
}

model RemoveBuiltinEnvoyFilterRequest {
  id?: string(name='Id'),
  istioVersion?: string(name='IstioVersion'),
  name?: string(name='Name'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model RemoveBuiltinEnvoyFilterResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveBuiltinEnvoyFilterResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveBuiltinEnvoyFilterResponseBody(name='body'),
}

async function removeBuiltinEnvoyFilterWithOptions(request: RemoveBuiltinEnvoyFilterRequest, runtime: Util.RuntimeOptions): RemoveBuiltinEnvoyFilterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveBuiltinEnvoyFilter', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeBuiltinEnvoyFilter(request: RemoveBuiltinEnvoyFilterRequest): RemoveBuiltinEnvoyFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeBuiltinEnvoyFilterWithOptions(request, runtime);
}

model RemoveClusterFromServiceMeshRequest {
  clusterId?: string(name='ClusterId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model RemoveClusterFromServiceMeshResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model RemoveClusterFromServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveClusterFromServiceMeshResponseBody(name='body'),
}

async function removeClusterFromServiceMeshWithOptions(request: RemoveClusterFromServiceMeshRequest, runtime: Util.RuntimeOptions): RemoveClusterFromServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveClusterFromServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeClusterFromServiceMesh(request: RemoveClusterFromServiceMeshRequest): RemoveClusterFromServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeClusterFromServiceMeshWithOptions(request, runtime);
}

model RemoveVMFromServiceMeshRequest {
  ecsId?: string(name='EcsId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model RemoveVMFromServiceMeshResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RemoveVMFromServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveVMFromServiceMeshResponseBody(name='body'),
}

async function removeVMFromServiceMeshWithOptions(request: RemoveVMFromServiceMeshRequest, runtime: Util.RuntimeOptions): RemoveVMFromServiceMeshResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveVMFromServiceMesh', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeVMFromServiceMesh(request: RemoveVMFromServiceMeshRequest): RemoveVMFromServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeVMFromServiceMeshWithOptions(request, runtime);
}

model RunDiagnosisRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model RunDiagnosisResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model RunDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  body: RunDiagnosisResponseBody(name='body'),
}

async function runDiagnosisWithOptions(request: RunDiagnosisRequest, runtime: Util.RuntimeOptions): RunDiagnosisResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RunDiagnosis', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function runDiagnosis(request: RunDiagnosisRequest): RunDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  return runDiagnosisWithOptions(request, runtime);
}

model SetServiceRegistrySourceRequest {
  config?: map[string]any(name='Config'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model SetServiceRegistrySourceShrinkRequest {
  configShrink?: string(name='Config'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model SetServiceRegistrySourceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model SetServiceRegistrySourceResponse = {
  headers: map[string]string(name='headers'),
  body: SetServiceRegistrySourceResponseBody(name='body'),
}

async function setServiceRegistrySourceWithOptions(tmpReq: SetServiceRegistrySourceRequest, runtime: Util.RuntimeOptions): SetServiceRegistrySourceResponse {
  Util.validateModel(tmpReq);
  var request = new SetServiceRegistrySourceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.config)) {
    request.configShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.config, 'Config', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetServiceRegistrySource', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setServiceRegistrySource(request: SetServiceRegistrySourceRequest): SetServiceRegistrySourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return setServiceRegistrySourceWithOptions(request, runtime);
}

model UpdateControlPlaneLogAlertActionPolicyRequest {
  actionPolicyId?: string(name='ActionPolicyId'),
  ruleId?: string(name='RuleId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model UpdateControlPlaneLogAlertActionPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateControlPlaneLogAlertActionPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateControlPlaneLogAlertActionPolicyResponseBody(name='body'),
}

async function updateControlPlaneLogAlertActionPolicyWithOptions(request: UpdateControlPlaneLogAlertActionPolicyRequest, runtime: Util.RuntimeOptions): UpdateControlPlaneLogAlertActionPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateControlPlaneLogAlertActionPolicy', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateControlPlaneLogAlertActionPolicy(request: UpdateControlPlaneLogAlertActionPolicyRequest): UpdateControlPlaneLogAlertActionPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateControlPlaneLogAlertActionPolicyWithOptions(request, runtime);
}

model UpdateControlPlaneLogConfigRequest {
  enabled?: boolean(name='Enabled'),
  project?: string(name='Project'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model UpdateControlPlaneLogConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateControlPlaneLogConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateControlPlaneLogConfigResponseBody(name='body'),
}

async function updateControlPlaneLogConfigWithOptions(request: UpdateControlPlaneLogConfigRequest, runtime: Util.RuntimeOptions): UpdateControlPlaneLogConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateControlPlaneLogConfig', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateControlPlaneLogConfig(request: UpdateControlPlaneLogConfigRequest): UpdateControlPlaneLogConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateControlPlaneLogConfigWithOptions(request, runtime);
}

model UpdateExtensionProviderRequest {
  config?: string(name='Config'),
  name?: string(name='Name'),
  serviceMeshId?: string(name='ServiceMeshId'),
  type?: string(name='Type'),
}

model UpdateExtensionProviderResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateExtensionProviderResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExtensionProviderResponseBody(name='body'),
}

async function updateExtensionProviderWithOptions(request: UpdateExtensionProviderRequest, runtime: Util.RuntimeOptions): UpdateExtensionProviderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateExtensionProvider', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateExtensionProvider(request: UpdateExtensionProviderRequest): UpdateExtensionProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateExtensionProviderWithOptions(request, runtime);
}

model UpdateIstioInjectionConfigRequest {
  enableIstioInjection?: boolean(name='EnableIstioInjection'),
  enableSidecarSetInjection?: boolean(name='EnableSidecarSetInjection'),
  namespace?: string(name='Namespace'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model UpdateIstioInjectionConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIstioInjectionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIstioInjectionConfigResponseBody(name='body'),
}

async function updateIstioInjectionConfigWithOptions(request: UpdateIstioInjectionConfigRequest, runtime: Util.RuntimeOptions): UpdateIstioInjectionConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateIstioInjectionConfig', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateIstioInjectionConfig(request: UpdateIstioInjectionConfigRequest): UpdateIstioInjectionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIstioInjectionConfigWithOptions(request, runtime);
}

model UpdateMeshFeatureRequest {
  accessLogEnabled?: boolean(name='AccessLogEnabled'),
  accessLogFile?: string(name='AccessLogFile'),
  accessLogFormat?: string(name='AccessLogFormat'),
  accessLogProject?: string(name='AccessLogProject'),
  accessLogServiceEnabled?: boolean(name='AccessLogServiceEnabled'),
  accessLogServiceHost?: string(name='AccessLogServiceHost'),
  accessLogServicePort?: int32(name='AccessLogServicePort'),
  auditProject?: string(name='AuditProject'),
  autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled'),
  CRAggregationEnabled?: boolean(name='CRAggregationEnabled'),
  cniEnabled?: boolean(name='CniEnabled'),
  cniExcludeNamespaces?: string(name='CniExcludeNamespaces'),
  configSourceEnabled?: boolean(name='ConfigSourceEnabled'),
  configSourceNacosID?: string(name='ConfigSourceNacosID'),
  customizedPrometheus?: boolean(name='CustomizedPrometheus'),
  customizedZipkin?: boolean(name='CustomizedZipkin'),
  DNSProxyingEnabled?: boolean(name='DNSProxyingEnabled'),
  discoverySelectors?: string(name='DiscoverySelectors'),
  dubboFilterEnabled?: boolean(name='DubboFilterEnabled'),
  enableAudit?: boolean(name='EnableAudit'),
  enableCRHistory?: boolean(name='EnableCRHistory'),
  enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault'),
  enableSDSServer?: boolean(name='EnableSDSServer'),
  excludeIPRanges?: string(name='ExcludeIPRanges'),
  excludeInboundPorts?: string(name='ExcludeInboundPorts'),
  excludeOutboundPorts?: string(name='ExcludeOutboundPorts'),
  filterGatewayClusterConfig?: boolean(name='FilterGatewayClusterConfig'),
  gatewayAPIEnabled?: boolean(name='GatewayAPIEnabled'),
  http10Enabled?: boolean(name='Http10Enabled'),
  includeIPRanges?: string(name='IncludeIPRanges'),
  includeInboundPorts?: string(name='IncludeInboundPorts'),
  kialiEnabled?: boolean(name='KialiEnabled'),
  lifecycle?: string(name='Lifecycle'),
  localityLBConf?: string(name='LocalityLBConf'),
  localityLoadBalancing?: boolean(name='LocalityLoadBalancing'),
  MSEEnabled?: boolean(name='MSEEnabled'),
  multiBufferEnabled?: boolean(name='MultiBufferEnabled'),
  multiBufferPollDelay?: string(name='MultiBufferPollDelay'),
  mysqlFilterEnabled?: boolean(name='MysqlFilterEnabled'),
  OPALimitCPU?: string(name='OPALimitCPU'),
  OPALimitMemory?: string(name='OPALimitMemory'),
  OPALogLevel?: string(name='OPALogLevel'),
  OPARequestCPU?: string(name='OPARequestCPU'),
  OPARequestMemory?: string(name='OPARequestMemory'),
  opaEnabled?: boolean(name='OpaEnabled'),
  openAgentPolicy?: boolean(name='OpenAgentPolicy'),
  outboundTrafficPolicy?: string(name='OutboundTrafficPolicy'),
  prometheusUrl?: string(name='PrometheusUrl'),
  proxyInitCPUResourceLimit?: string(name='ProxyInitCPUResourceLimit'),
  proxyInitCPUResourceRequest?: string(name='ProxyInitCPUResourceRequest'),
  proxyInitMemoryResourceLimit?: string(name='ProxyInitMemoryResourceLimit'),
  proxyInitMemoryResourceRequest?: string(name='ProxyInitMemoryResourceRequest'),
  proxyLimitCPU?: string(name='ProxyLimitCPU'),
  proxyLimitMemory?: string(name='ProxyLimitMemory'),
  proxyRequestCPU?: string(name='ProxyRequestCPU'),
  proxyRequestMemory?: string(name='ProxyRequestMemory'),
  redisFilterEnabled?: boolean(name='RedisFilterEnabled'),
  serviceMeshId?: string(name='ServiceMeshId'),
  sidecarInjectorLimitCPU?: string(name='SidecarInjectorLimitCPU'),
  sidecarInjectorLimitMemory?: string(name='SidecarInjectorLimitMemory'),
  sidecarInjectorRequestCPU?: string(name='SidecarInjectorRequestCPU'),
  sidecarInjectorRequestMemory?: string(name='SidecarInjectorRequestMemory'),
  sidecarInjectorWebhookAsYaml?: string(name='SidecarInjectorWebhookAsYaml'),
  telemetry?: boolean(name='Telemetry'),
  terminationDrainDuration?: string(name='TerminationDrainDuration'),
  thriftFilterEnabled?: boolean(name='ThriftFilterEnabled'),
  traceSampling?: float(name='TraceSampling'),
  tracing?: boolean(name='Tracing'),
  webAssemblyFilterEnabled?: boolean(name='WebAssemblyFilterEnabled'),
}

model UpdateMeshFeatureResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMeshFeatureResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMeshFeatureResponseBody(name='body'),
}

async function updateMeshFeatureWithOptions(request: UpdateMeshFeatureRequest, runtime: Util.RuntimeOptions): UpdateMeshFeatureResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateMeshFeature', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateMeshFeature(request: UpdateMeshFeatureRequest): UpdateMeshFeatureResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMeshFeatureWithOptions(request, runtime);
}

model UpdateNamespaceScopeSidecarConfigRequest {
  excludeIPRanges?: string(name='ExcludeIPRanges'),
  excludeInboundPorts?: string(name='ExcludeInboundPorts'),
  excludeOutboundPorts?: string(name='ExcludeOutboundPorts'),
  includeIPRanges?: string(name='IncludeIPRanges'),
  includeInboundPorts?: string(name='IncludeInboundPorts'),
  includeOutboundPorts?: string(name='IncludeOutboundPorts'),
  istioDNSProxyEnabled?: boolean(name='IstioDNSProxyEnabled'),
  lifecycle?: string(name='Lifecycle'),
  namespace?: string(name='Namespace'),
  proxyInitCPUResourceLimit?: string(name='ProxyInitCPUResourceLimit'),
  proxyInitCPUResourceRequest?: string(name='ProxyInitCPUResourceRequest'),
  proxyInitMemoryResourceLimit?: string(name='ProxyInitMemoryResourceLimit'),
  proxyInitMemoryResourceRequest?: string(name='ProxyInitMemoryResourceRequest'),
  serviceMeshId?: string(name='ServiceMeshId'),
  sidecarProxyCPUResourceLimit?: string(name='SidecarProxyCPUResourceLimit'),
  sidecarProxyCPUResourceRequest?: string(name='SidecarProxyCPUResourceRequest'),
  sidecarProxyMemoryResourceLimit?: string(name='SidecarProxyMemoryResourceLimit'),
  sidecarProxyMemoryResourceRequest?: string(name='SidecarProxyMemoryResourceRequest'),
  terminationDrainDuration?: string(name='TerminationDrainDuration'),
}

model UpdateNamespaceScopeSidecarConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateNamespaceScopeSidecarConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNamespaceScopeSidecarConfigResponseBody(name='body'),
}

async function updateNamespaceScopeSidecarConfigWithOptions(request: UpdateNamespaceScopeSidecarConfigRequest, runtime: Util.RuntimeOptions): UpdateNamespaceScopeSidecarConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateNamespaceScopeSidecarConfig', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateNamespaceScopeSidecarConfig(request: UpdateNamespaceScopeSidecarConfigRequest): UpdateNamespaceScopeSidecarConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNamespaceScopeSidecarConfigWithOptions(request, runtime);
}

model UpgradeMeshVersionRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model UpgradeMeshVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpgradeMeshVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeMeshVersionResponseBody(name='body'),
}

async function upgradeMeshVersionWithOptions(request: UpgradeMeshVersionRequest, runtime: Util.RuntimeOptions): UpgradeMeshVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpgradeMeshVersion', '2020-01-11', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function upgradeMeshVersion(request: UpgradeMeshVersionRequest): UpgradeMeshVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeMeshVersionWithOptions(request, runtime);
}

model GatewaySLBValue = {
  SLBAddress?: string(name='SLBAddress'),
  loadBalancerId?: string(name='LoadBalancerId'),
  backendServers?: {
    port?: long(name='Port'),
    protocol?: string(name='Protocol'),
    serverIp?: string(name='ServerIp'),
    serverHealthStatus?: string(name='ServerHealthStatus'),
    serverId?: string(name='ServerId'),
    vpcId?: string(name='VpcId'),
    listenerPort?: long(name='ListenerPort'),
    weight?: string(name='Weight'),
    description?: string(name='Description'),
    eniHost?: string(name='EniHost'),
    type?: string(name='Type'),
  }(name='BackendServers'),
  SLBHealthCheckState?: string(name='SLBHealthCheckState'),
}

model UpgradeDetailGatewayStatusRecordValue = {
  status?: string(name='Status'),
  message?: string(name='Message'),
  version?: string(name='Version'),
}

