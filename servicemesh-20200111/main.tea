/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('servicemesh', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model SecretCreateRecordValue = {
  state?: string(name='State', example='success'),
  clusterId?: string(name='ClusterId', example='c08ba3fd1e6484b0f8cc1ad8xe10d****'),
  message?: string(name='Message', example='timeout'),
}

model SecretDeleteRecordValue = {
  state?: string(name='State', example='success'),
  clusterId?: string(name='ClusterId', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
  message?: string(name='Message', example='timeout'),
}

model CCMVersionsValue = {
  queryState?: string(name='QueryState', example='time_out'),
  version?: string(name='Version', example='v2.0.1'),
  SLBGracefulDrainSupport?: boolean(name='SLBGracefulDrainSupport', example='true'),
  clusterId?: string(name='ClusterId', example='cfbb81b9b51a44b299349xxxxxxxxxxxx'),
  message?: string(name='Message', example='timeout error'),
}

model UpgradeDetailGatewayStatusRecordValue = {
  status?: string(name='Status', example='upgrading'),
  message?: string(name='Message', example='success'),
  version?: string(name='Version', example='1.9.7'),
}

model AddClusterIntoServiceMeshRequest {
  clusterId?: string(name='ClusterId', example='ce3c25e247da24f3aab9b7edfae83****'),
  ignoreNamespaceCheck?: boolean(name='IgnoreNamespaceCheck', description='添加集群时不检查目标集群是否存在istio-system namespace，一般用于自建istio 迁移ASM 场景', example='false'),
  serviceMeshId?: string(name='ServiceMeshId', example='cb8963379255149cb98c8686f274x****'),
}

model AddClusterIntoServiceMeshResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='success'),
  requestId?: string(name='RequestId', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model AddClusterIntoServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddClusterIntoServiceMeshResponseBody(name='body'),
}

async function addClusterIntoServiceMeshWithOptions(request: AddClusterIntoServiceMeshRequest, runtime: Util.RuntimeOptions): AddClusterIntoServiceMeshResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ignoreNamespaceCheck)) {
    body['IgnoreNamespaceCheck'] = request.ignoreNamespaceCheck;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddClusterIntoServiceMesh',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addClusterIntoServiceMesh(request: AddClusterIntoServiceMeshRequest): AddClusterIntoServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return addClusterIntoServiceMeshWithOptions(request, runtime);
}

model AddVMIntoServiceMeshRequest {
  ecsId?: string(name='EcsId', description='The ID of the ECS instance.', example='i-2ze90ts4e7dj3650****'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='ccb37ff104caf419fbf48fb38e6f3****'),
}

model AddVMIntoServiceMeshResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='4b2c0fe0-6705-4614-8521-6b9d289163c8'),
}

model AddVMIntoServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddVMIntoServiceMeshResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request AddVMIntoServiceMeshRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AddVMIntoServiceMeshResponse
 */
// Deprecated
async function addVMIntoServiceMeshWithOptions(request: AddVMIntoServiceMeshRequest, runtime: Util.RuntimeOptions): AddVMIntoServiceMeshResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ecsId)) {
    query['EcsId'] = request.ecsId;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddVMIntoServiceMesh',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request AddVMIntoServiceMeshRequest
  * @return AddVMIntoServiceMeshResponse
 */
// Deprecated
async function addVMIntoServiceMesh(request: AddVMIntoServiceMeshRequest): AddVMIntoServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVMIntoServiceMeshWithOptions(request, runtime);
}

model CreateASMGatewayRequest {
  body?: string(name='Body', description='The YAML content that is used to create the ASM gateway.', example='{"apiVersion":"istio.alibabacloud.com/v1beta1","kind":"IstioGateway","metadata":{"name":"ingressgateway","namespace":"istio-system"},"spec":{"gatewayType":"ingress","clusterIds":["xxxxx"],"ports":[{"name":"http-0","port":80,"targetPort":80,"protocol":"TCP"},{"name":"https-1","port":443,"targetPort":443,"protocol":"TCP"}],"serviceAnnotations":{"service.beta.kubernetes.io/alicloud-loadbalancer-address-type":"internet","service.beta.kubernetes.io/alibaba-cloud-loadbalancer-spec":"slb.s1.small"},"replicaCount":2,"resources":{"limits":{"cpu":"2","memory":"4G"},"requests":{"cpu":"200m","memory":"256Mi"}},"serviceType":"LoadBalancer","maxReplicas":2,"minReplicas":2}}'),
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='cb8963379255149cb98c8686f274x****'),
}

model CreateASMGatewayResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model CreateASMGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateASMGatewayResponseBody(name='body'),
}

async function createASMGatewayWithOptions(request: CreateASMGatewayRequest, runtime: Util.RuntimeOptions): CreateASMGatewayResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['Body'] = request.body;
  }
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateASMGateway',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createASMGateway(request: CreateASMGatewayRequest): CreateASMGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createASMGatewayWithOptions(request, runtime);
}

model CreateGatewaySecretRequest {
  cert?: string(name='Cert', description='The content of the certificate.', example='-----BEGIN CERTIFICATE----- MIIC2DCCAcACA-----END CERTIF****-----'),
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  key?: string(name='Key', description='The private key of the certificate.', example='MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQC2ag/Bzcgm****'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='bookinfo-secret'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
}

model CreateGatewaySecretResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
  secretCreateRecord?: map[string]SecretCreateRecordValue(name='SecretCreateRecord', description='The record of creating the secret.'),
}

model CreateGatewaySecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGatewaySecretResponseBody(name='body'),
}

async function createGatewaySecretWithOptions(request: CreateGatewaySecretRequest, runtime: Util.RuntimeOptions): CreateGatewaySecretResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.cert)) {
    body['Cert'] = request.cert;
  }
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.key)) {
    body['Key'] = request.key;
  }
  if (!Util.isUnset(request.secretName)) {
    body['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateGatewaySecret',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGatewaySecret(request: CreateGatewaySecretRequest): CreateGatewaySecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGatewaySecretWithOptions(request, runtime);
}

model CreateIstioGatewayDomainsRequest {
  credential?: string(name='Credential', description='The name of the secret that contains the Transport Layer Security (TLS) certificate and certificate authority (CA) certificate.', example='bookinfo-secret'),
  forceHttps?: boolean(name='ForceHttps', description='Specifies whether to forcibly use TLS to protect connection security.

*   `true`: forcibly uses TLS to protect connection security.
*   `false`: does not forcibly use TLS to protect connection security.', example='true'),
  hosts?: string(name='Hosts', description='The domain names of the one or more hosts that are exposed by the ASM gateway. Separate multiple domain names with commas (,).', example='example.com,demo.com'),
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  limit?: string(name='Limit', description='The maximum number of ASM gateways to query.', example='10'),
  namespace?: string(name='Namespace', description='The name of the namespace.', example='default'),
  number?: int32(name='Number', description='The port that is provided by the ASM gateway.', example='443'),
  portName?: string(name='PortName', description='The name of the port.', example='http-demo'),
  protocol?: string(name='Protocol', description='The type of the protocol. Valid values: `HTTP`, `HTTPS`, `GRPC`, `HTTP2`, `MONGO`, `TCP`, and `TLS`.', example='HTTPS'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
}

model CreateIstioGatewayDomainsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model CreateIstioGatewayDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIstioGatewayDomainsResponseBody(name='body'),
}

async function createIstioGatewayDomainsWithOptions(request: CreateIstioGatewayDomainsRequest, runtime: Util.RuntimeOptions): CreateIstioGatewayDomainsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.credential)) {
    body['Credential'] = request.credential;
  }
  if (!Util.isUnset(request.forceHttps)) {
    body['ForceHttps'] = request.forceHttps;
  }
  if (!Util.isUnset(request.hosts)) {
    body['Hosts'] = request.hosts;
  }
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.number)) {
    body['Number'] = request.number;
  }
  if (!Util.isUnset(request.portName)) {
    body['PortName'] = request.portName;
  }
  if (!Util.isUnset(request.protocol)) {
    body['Protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIstioGatewayDomains',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIstioGatewayDomains(request: CreateIstioGatewayDomainsRequest): CreateIstioGatewayDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIstioGatewayDomainsWithOptions(request, runtime);
}

model CreateIstioGatewayRoutesRequest {
  description?: string(name='Description', description='The description of the routing rule.', example='demo route'),
  gatewayRoute?: {
    domains?: [ string ](name='Domains', description='The requested domain names.'),
    HTTPAdvancedOptions?: {
      delegate?: {
        name?: string(name='Name', description='The name of the virtual service.', example='reviews'),
        namespace?: string(name='Namespace', description='The namespace to which the virtual service belongs.', example='default'),
      }(name='Delegate', description='The virtual service that defines traffic routing.'),
      fault?: {
        abort?: {
          httpStatus?: int32(name='HttpStatus', description='The HTTP status code.', example='400'),
          percentage?: {
            value?: float(name='Value', description='The percentage of requests that are aborted with the specified error code, which is expressed as a decimal.', example='0.1'),
          }(name='Percentage', description='The percentage of requests that are aborted with the specified error code.'),
        }(name='Abort', description='The configurations for aborting requests with specified error codes.'),
        delay?: {
          fixedDelay?: string(name='FixedDelay', description='The fixed duration for request delay.', example='5s'),
          percentage?: {
            value?: float(name='Value', description='The percentage of requests to which the delay fault is injected, which is expressed as a decimal.', example='0.1'),
          }(name='Percentage', description='The percentage of requests to which the delay fault is injected.'),
        }(name='Delay', description='The duration to delay a request.'),
      }(name='Fault', description='The configurations of fault injection.'),
      HTTPRedirect?: {
        authority?: string(name='Authority', description='The value to be used to overwrite the value of the Authority or Host header during redirection.``', example='newratings.default.svc.cluster.local'),
        redirectCode?: int32(name='RedirectCode', description='The HTTP status code to be used to indicate URL redirection. Default value: 301.', example='301'),
        uri?: string(name='Uri', description='The value to be used to overwrite the URL path during redirection.', example='/v1/getProductRatings'),
      }(name='HTTPRedirect', description='The HTTP redirection rule.'),
      mirror?: {
        host?: string(name='Host', description='The name of the service defined in the service registry.', example='reviews.default.svc.cluster.local'),
        subset?: string(name='Subset', description='The name of the service subset.', example='v1'),
      }(name='Mirror', description='The configurations for mirroring HTTP traffic to another destination in addition to forwarding requests to the specified destination.'),
      mirrorPercentage?: {
        value?: float(name='Value', description='The percentage of requests that are mirrored to another destination except for the original destination, which is expressed as a decimal.', example='0.2'),
      }(name='MirrorPercentage', description='The percentage of requests that are mirrored to another destination except for the original destination.'),
      retries?: {
        attempts?: int32(name='Attempts', description='The number of retries that are allowed for a request.', example='3'),
        perTryTimeout?: string(name='PerTryTimeout', description='The timeout period for each retry. Example: `5s`.', example='5s'),
        retryOn?: string(name='RetryOn', description='The condition for retries. Example: `connect-failure,refused-stream,503`.', example='connect-failure,refused-stream,503'),
        retryRemoteLocalities?: {
          value?: boolean(name='Value', description='Specifies whether to allow retries to other localities. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
        }(name='RetryRemoteLocalities', description='Specifies whether to allow retries to other localities.'),
      }(name='Retries', description='The configurations of retries for failed requests.'),
      rewrite?: {
        authority?: string(name='Authority', description='The value to be used to overwrite the value of the Authority or Host header.', example='newratings.default.svc.cluster.local'),
        uri?: string(name='Uri', description='The value to be used to overwrite the path or prefix of the URI.', example='/v1/getProductRatings'),
      }(name='Rewrite', description='The configurations for rewriting the virtual service.'),
      timeout?: string(name='Timeout', description='The timeout period for requests.', example='5s'),
    }(name='HTTPAdvancedOptions', description='The advanced settings for routing HTTP traffic.'),
    matchRequest?: {
      headers?: [ 
        {
          matchingContent?: string(name='MatchingContent', description='The header value to be matched.', example='v1'),
          matchingMode?: string(name='MatchingMode', description='The matching mode for the header value. Valid values:

*   `exact`: exact match
*   `prefix`: match by prefix
*   `regex`: match by regular expression', example='exact'),
          name?: string(name='Name', description='The header key to be matched.', example='x-request-id'),
        }
      ](name='Headers', description='The request headers to be matched.'),
      ports?: [ int32 ](name='Ports', description='The ports of destination services for Layer 4 weighted routing.'),
      TLSMatchAttributes?: [ 
        {
          SNIHosts?: [ string ](name='SNIHosts', description='The Server Name Indication (SNI) values to be matched.'),
          TLSPort?: int32(name='TLSPort', description='The TLS port.', example='443'),
        }
      ](name='TLSMatchAttributes', description='The matching rule for Transport Layer Security (TLS) traffic.'),
      URI?: {
        matchingContent?: string(name='MatchingContent', description='The content to be matched.', example='/ratings/v2/'),
        matchingMode?: string(name='MatchingMode', description='The matching mode for the routing rule. Valid values:

*   `exact`: exact match
*   `prefix`: match by prefix
*   `regex`: match by regular expression', example='prefix'),
      }(name='URI', description='The matching rule for URIs.'),
    }(name='MatchRequest', description='The matching rules for traffic routing.'),
    namespace?: string(name='Namespace', description='The namespace.', example='default'),
    rawVSRoute?: any(name='RawVSRoute', description='A JSON string. This parameter corresponds to the three routing types in virtual services and provides configuration entries for advanced features. The value of this parameter overwrites the configurations in RouteName, RouteType, MatchRequest, and HTTPAdvancedOptions.', example='{
  "http": {
    "route": [
      {
        "destination": {
          "host": "httpbin"
        }
      }
    ],
    "name": "httpbin",
    "match": [
      {
        "uri": {
          "prefix": "/"
        }
      }
    ],
    "fault": {
      "delay": {
        "fixedDelay": "2s",
        "percentage": {
          "value": 70
        }
      }
    }
  }
}'),
    routeDestinations?: [ 
      {
        destination?: {
          host?: string(name='Host', description='The name of the service defined in the service registry.', example='reviews'),
          port?: {
            number?: int32(name='Number', description='The port number.', example='80'),
          }(name='Port', description='The port.'),
          subset?: string(name='Subset', description='The name of the service subset.', example='v1'),
        }(name='Destination', description='The unique endpoint of the destination service to which the specified requests are sent.'),
        weight?: int32(name='Weight', description='The weight of the service subset.', example='80'),
      }
    ](name='RouteDestinations', description='The endpoints of destination services for Layer 4 weighted routing.'),
    routeName?: string(name='RouteName', description='The name of the routing rule.', example='reviews-v2-routes'),
    routeType?: string(name='RouteType', description='The type of the traffic to be routed. Valid values: `HTTP`, `TLS`, and `TCP`.', example='HTTP'),
  }(name='GatewayRoute', description='The information about the routing rule to be created for the ASM gateway.'),
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  priority?: int32(name='Priority', description='The priority of the routing rule. The value of this parameter is an integer. A smaller value indicates a higher priority.', example='1'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
  status?: int32(name='Status', description='The status of the routing rule. Valid values:

*   `0`: The routing rule is valid.
*   `1`: The routing rule is invalid.
*   `2`: An error occurs during the creation or update of the routing rule.', example='1'),
}

model CreateIstioGatewayRoutesShrinkRequest {
  description?: string(name='Description', description='The description of the routing rule.', example='demo route'),
  gatewayRouteShrink?: string(name='GatewayRoute', description='The information about the routing rule to be created for the ASM gateway.'),
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  priority?: int32(name='Priority', description='The priority of the routing rule. The value of this parameter is an integer. A smaller value indicates a higher priority.', example='1'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
  status?: int32(name='Status', description='The status of the routing rule. Valid values:

*   `0`: The routing rule is valid.
*   `1`: The routing rule is invalid.
*   `2`: An error occurs during the creation or update of the routing rule.', example='1'),
}

model CreateIstioGatewayRoutesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model CreateIstioGatewayRoutesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIstioGatewayRoutesResponseBody(name='body'),
}

async function createIstioGatewayRoutesWithOptions(tmpReq: CreateIstioGatewayRoutesRequest, runtime: Util.RuntimeOptions): CreateIstioGatewayRoutesResponse {
  Util.validateModel(tmpReq);
  var request = new CreateIstioGatewayRoutesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.gatewayRoute)) {
    request.gatewayRouteShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.gatewayRoute, 'GatewayRoute', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.gatewayRouteShrink)) {
    body['GatewayRoute'] = request.gatewayRouteShrink;
  }
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.priority)) {
    body['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIstioGatewayRoutes',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIstioGatewayRoutes(request: CreateIstioGatewayRoutesRequest): CreateIstioGatewayRoutesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIstioGatewayRoutesWithOptions(request, runtime);
}

model CreateServiceMeshRequest {
  accessLogEnabled?: boolean(name='AccessLogEnabled', description='Specifies whether to enable access log collection. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  accessLogFile?: string(name='AccessLogFile', description='Specifies whether to enable access log collection. Valid values:

*   "": disables access log collection.
*   `/dev/stdout`: enables access log collection. Access logs are written to /dev/stdout.', example='/dev/stdout'),
  accessLogFormat?: string(name='AccessLogFormat', description='Custom fields of access logs. To set this parameter, you must enable access log collection. Otherwise, you cannot set this parameter. The value must be a JSON string. The following key values must be contained: authority_for, bytes_received, bytes_sent, downstream_local_address, downstream_remote_address, duration, istio_policy_status, method, path, protocol, requested_server_name, response_code, response_flags, route_name, start_time, trace_id, upstream_cluster, upstream_host, upstream_local_address, upstream_service_time, upstream_transport_failure_reason, user_agent, and x_forwarded_for.', example='{"authority_for":"%REQ(:AUTHORITY)%","bytes_received":"%BYTES_RECEIVED%","bytes_sent":"%BYTES_SENT%","downstream_local_address":"%DOWNSTREAM_LOCAL_ADDRESS%","downstream_remote_address":"%DOWNSTREAM_REMOTE_ADDRESS%","duration":"%DURATION%","istio_policy_status":"%DYNAMIC_METADATA(istio.mixer:status)%","method":"%REQ(:METHOD)%","path":"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%","protocol":"%PROTOCOL%","request_id":"%REQ(X-REQUEST-ID)%","requested_server_name":"%REQUESTED_SERVER_NAME%","response_code":"%RESPONSE_CODE%","response_flags":"%RESPONSE_FLAGS%","route_name":"%ROUTE_NAME%","start_time":"%START_TIME%","trace_id":"%REQ(X-B3-TRACEID)%","upstream_cluster":"%UPSTREAM_CLUSTER%","upstream_host":"%UPSTREAM_HOST%","upstream_local_address":"%UPSTREAM_LOCAL_ADDRESS%","upstream_service_time":"%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)%","upstream_transport_failure_reason":"%UPSTREAM_TRANSPORT_FAILURE_REASON%","user_agent":"%REQ(USER-AGENT)%","x_forwarded_for":"%REQ(X-FORWARDED-FOR)%"}'),
  accessLogProject?: string(name='AccessLogProject', description='The SLS project from which access logs are collected.', example='mesh-log-cf245a429b6ff4b6e97f20797758*****'),
  accessLogServiceEnabled?: boolean(name='AccessLogServiceEnabled', description='Specifies whether to enable gRPC Access Log Service (ALS) of Envoy. gRPC is short for Google Remote Procedure Call. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  accessLogServiceHost?: string(name='AccessLogServiceHost', description='The endpoint of Envoy\\"s gRPC ALS.', example='0.0.0.0'),
  accessLogServicePort?: int32(name='AccessLogServicePort', description='The port of Envoy\\"s gRPC ALS.', example='9999'),
  apiServerLoadBalancerSpec?: string(name='ApiServerLoadBalancerSpec', description='The type of the SLB instance that is bound to Istio Pilot. Valid values: `slb.s1.small`, `slb.s2.small`, `slb.s2.medium`, `slb.s3.small`, `slb.s3.medium`, and `slb.s3.large`.', example='slb.s1.small'),
  apiServerPublicEip?: boolean(name='ApiServerPublicEip', description='Specifies whether to expose the API server to the Internet. Valid values:

*   `true`
*   `false`

Default value: `false`.

> If you set this parameter to `false`, the API server cannot be accessed over the Internet.', example='false'),
  auditProject?: string(name='AuditProject', description='The name of the Log Service project that is used for mesh audit.

Default value: mesh-log-{ASM instance ID}.', example='mesh-log-xxxx'),
  autoRenew?: boolean(name='AutoRenew', description='Specifies whether to enable auto-renewal for the SLB instance if the SLB instance uses the subscription billing method. Valid values:

- true

- false', example='true'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', description='The auto-renewal period of the SLB instance. This parameter is valid only if the `ChargeType` parameter is set to `PrePay`. If the original subscription period of the SLB instance is less than one year, the value of this parameter indicates the number of months for auto-renewal. If the original subscription period of the SLB instance is more than one year, the value of this parameter indicates the number of years for auto-renewal.', example='3'),
  CRAggregationEnabled?: boolean(name='CRAggregationEnabled', description='Specifies whether to allow the Kubernetes API of clusters on the data plane to access Istio resources. The version of the ASM instance must be V1.9.7.93 or later. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  chargeType?: string(name='ChargeType', description='The billing method of the SLB instance. Valid values:

*   `PayOnDemand`: pay-as-you-go.
*   `PrePay`: subscription.', example='PrePay'),
  clusterSpec?: string(name='ClusterSpec', description='The edition of the ASM instance. Valid values:

- `standard`: Standard Edition

- `enterprise`: Enterprise Edition

- `ultimate`: Ultimate Edition', example='standard'),
  configSourceEnabled?: boolean(name='ConfigSourceEnabled', description='Specifies whether to enable the external service registry. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  configSourceNacosID?: string(name='ConfigSourceNacosID', description='The instance ID of the Nacos registry.', example='mse-cn-tl326******'),
  controlPlaneLogEnabled?: boolean(name='ControlPlaneLogEnabled', description='Specifies whether to enable the collection of control plane logs. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  controlPlaneLogProject?: string(name='ControlPlaneLogProject', description='The name of the Log Service project that is used to collect the logs of the control plane.', example='mesh-log-cf245a429b6ff4b6e97f20797758*****'),
  customizedPrometheus?: boolean(name='CustomizedPrometheus', description='Specifies whether to use a custom Prometheus instance. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  customizedZipkin?: boolean(name='CustomizedZipkin', description='Specifies whether to use a self-managed Zipkin system to collect tracing data. Valid values:

*   `true`: uses a self-managed Zipkin system to collect tracing data.
*   `false`: uses Alibaba Cloud Tracing Analysis to collect tracing data.

Default value: `false`.', example='false'),
  DNSProxyingEnabled?: boolean(name='DNSProxyingEnabled', description='Specifies whether to enable the DNS proxy feature. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  dubboFilterEnabled?: boolean(name='DubboFilterEnabled', description='Specifies whether to enable Dubbo Filter. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  edition?: string(name='Edition', description='The edition of the ASM instance.', example='Pro'),
  enableAmbient?: boolean(name='EnableAmbient'),
  enableAudit?: boolean(name='EnableAudit', description='Specifies whether to enable the mesh audit feature. To enable this feature, make sure that you have activated [Log Service](https://sls.console.aliyun.com/). Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  enableCRHistory?: boolean(name='EnableCRHistory', description='Specifies whether to enable the rollback feature for Istio resources. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  enableSDSServer?: boolean(name='EnableSDSServer', description='Specifies whether to enable Secret Discovery Service (SDS). Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  excludeIPRanges?: string(name='ExcludeIPRanges', description='The IP ranges in CIDR form to be excluded from redirection to the sidecar proxy in the ASM instance.', example='100.100.10*.***'),
  excludeInboundPorts?: string(name='ExcludeInboundPorts', description='The inbound ports to be excluded from redirection to the sidecar proxy in the ASM instance. Separate multiple port numbers with commas (,).', example='80,81'),
  excludeOutboundPorts?: string(name='ExcludeOutboundPorts', description='The outbound ports to be excluded from redirection to the sidecar proxy in the ASM instance. Separate multiple port numbers with commas (,).', example='80,81'),
  existingCaCert?: string(name='ExistingCaCert', description='The existing CA certificate, which is encoded in Base64. This parameter is used in scenarios where you migrate open source Istio to ASM. It specifies the content of the ca-cert.pem file in the istio-ca-secret secret. The secret is in the istio-system namespace of the Kubernetes cluster where the open source Istio is installed.', example='CA cert content, base64 encoded format.'),
  existingCaKey?: string(name='ExistingCaKey', description='The existing CA key, which is encoded in Base64. This parameter is used in scenarios where you migrate open source Istio to ASM. It specifies the content of the ca-key.pem file in the istio-ca-secret secret. The secret is in the istio-system namespace of the Kubernetes cluster where the open source Istio is installed.', example='CA key content, base64 encoded format.'),
  existingCaType?: string(name='ExistingCaType', description='The type of the existing CA certificate. Valid values:

*   1: Self-signed certificate generated by istiod. The certificate corresponds to the secret named istio-ca-secret in the istio-system namespace. If you use this type of certificate, you must set the `ExistingCaCert` and `ExsitingCaKey` parameters.
*   2: Administrator-specified certificate. For more information, see [plugin ca cert](https://istio.io/latest/docs/tasks/security/cert-management/plugin-ca-cert/). In most cases, the certificate corresponds to the secret named cacerts in the istio-system namespace. If you use this type of certificate, you must set the `ExisingRootCaCert` and `ExisingRootCaKey` parameters.', example='1'),
  existingRootCaCert?: string(name='ExistingRootCaCert', description='The existing root certificate, which is encoded in Base64.', example='Existing CA cert content, base64 encoded format.'),
  existingRootCaKey?: string(name='ExistingRootCaKey', description='The private key that corresponds to the root certificate, which is encoded in Base64.', example='Existing CA key content, base64 encoded format.'),
  filterGatewayClusterConfig?: boolean(name='FilterGatewayClusterConfig', description='Specifies whether to enable gateway configuration filtering. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  gatewayAPIEnabled?: boolean(name='GatewayAPIEnabled', description='Specifies whether to enable Gateway API. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  guestCluster?: string(name='GuestCluster', description='After this ASM instance is successfully created, automatically add an ACK cluster to it. 
Make sure this ASM instance and ACK cluster have same VPC, VSwitch, cluster domain.', example='ACK cluster id'),
  includeIPRanges?: string(name='IncludeIPRanges', description='The IP ranges in CIDR form for which traffic is to be redirected to the sidecar proxy in the ASM instance.', example='*'),
  istioVersion?: string(name='IstioVersion', description='The Istio version of the ASM instance.', example='v1.5.4.1-g5960ec40-aliyun'),
  kialiEnabled?: boolean(name='KialiEnabled', description='Specifies whether to enable the mesh topology feature. To enable this feature, make sure that you have enabled Prometheus monitoring. If Prometheus monitoring is disabled, you must set this parameter to `false`.`` Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  localityLBConf?: string(name='LocalityLBConf', description='The configurations for the access to the nearest instance.', example='{"failover":[{"from":"cn-hangzhou","to":"cn-shanghai"}]}'),
  localityLoadBalancing?: boolean(name='LocalityLoadBalancing', description='Specifies whether to route traffic to the nearest instance. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  MSEEnabled?: boolean(name='MSEEnabled', description='Specifies whether to enable Microservices Engine (MSE). Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  multiBufferEnabled?: boolean(name='MultiBufferEnabled', description='Specifies whether to enable MultiBuffer-based Transport Layer Security (TLS) acceleration. Valid values:

- `true`

- `false`


Default value: `true`', example='true'),
  multiBufferPollDelay?: string(name='MultiBufferPollDelay', description='The pull-request latency. Default value: 30. Unit: seconds.', example='30s'),
  mysqlFilterEnabled?: boolean(name='MysqlFilterEnabled', description='Specifies whether to enable MySQL Filter. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  name?: string(name='Name', description='The name of the ASM instance.', example='mesh1'),
  OPALimitCPU?: string(name='OPALimitCPU', description='The maximum number of CPU cores that are available to the OPA container.', example='2'),
  OPALimitMemory?: string(name='OPALimitMemory', description='The maximum size of the memory that is available to the OPA container. You can specify the parameter value in the standard quantity representation form used by Kubernetes. 1 Mi equals 1,024 KB.', example='1024Mi'),
  OPALogLevel?: string(name='OPALogLevel', description='The log level of the OPA container.', example='info'),
  OPARequestCPU?: string(name='OPARequestCPU', description='The minimum number of CPU cores that are required by the OPA container. You can specify the parameter value in the standard representation form of CPUs in Kubernetes. For example, if you set the value to 1, one CPU core is required.', example='1'),
  OPARequestMemory?: string(name='OPARequestMemory', description='The minimum size of the memory that is required by the OPA container. You can specify the parameter value in the standard quantity representation form used by Kubernetes. 1 Mi equals 1,024 KB.', example='512Mi'),
  opaEnabled?: boolean(name='OpaEnabled', description='Specifies whether to enable the OPA plug-in. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  openAgentPolicy?: boolean(name='OpenAgentPolicy', description='Specifies whether to install the Open Policy Agent (OPA) plug-in. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  period?: int32(name='Period', description='The auto-renewal period of the SLB instance. This parameter is valid only if `ChargeType` is set to `PrePaid`. The value of this parameter indicates the purchased month of the SLB instance when the subscription billing method is used. For example, if the subscription period is one year, set this parameter to 12.', example='3'),
  pilotLoadBalancerSpec?: string(name='PilotLoadBalancerSpec', description='The type of the SLB instance that is bound to Istio Pilot. Valid values: `slb.s1.small`, `slb.s2.small`, `slb.s2.medium`, `slb.s3.small`, `slb.s3.medium`, and `slb.s3.large`.', example='slb.s1.small'),
  prometheusUrl?: string(name='PrometheusUrl', description='The endpoint of the custom Prometheus instance.', example='http://prometheus:9090'),
  proxyLimitCPU?: string(name='ProxyLimitCPU', description='The maximum number of CPU cores that are available to the proxy container.', example='2000m'),
  proxyLimitMemory?: string(name='ProxyLimitMemory', description='The maximum size of the memory that is available to the proxy container.', example='1024Mi'),
  proxyRequestCPU?: string(name='ProxyRequestCPU', description='The minimum number of CPU cores that are required by the proxy container.', example='100m'),
  proxyRequestMemory?: string(name='ProxyRequestMemory', description='The minimum size of the memory that is required by the proxy container.', example='128Mi'),
  redisFilterEnabled?: boolean(name='RedisFilterEnabled', description='Specifies whether to enable Redis Filter. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='true'),
  regionId?: string(name='RegionId', description='The ID of the region in which the ASM instance resides.', example='cn-hangzhou'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  telemetry?: boolean(name='Telemetry', description='Specifies whether to enable Prometheus monitoring. We recommend that you use Prometheus Service of [Application Real-Time Monitoring Service (ARMS)](https://arms.console.aliyun.com/). Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  thriftFilterEnabled?: boolean(name='ThriftFilterEnabled', description='Specifies whether to enable Thrift Filter. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  traceSampling?: float(name='TraceSampling', description='The sampling percentage of Tracing Analysis.', example='100'),
  tracing?: boolean(name='Tracing', description='Specifies whether to enable the Tracing Analysis feature. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
  useExistingCA?: boolean(name='UseExistingCA', description='Specifies whether to use an existing CA certificate and private key.', example='false'),
  vSwitches?: string(name='VSwitches', description='The ID of the vSwitch to which the ASM instance is connected.', example='["vsw-xzegf5dndkbf4m6eg****"]'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC) in which the ASM instance resides.', example='vpc-xzelac2tw4ic7wz31****'),
  webAssemblyFilterEnabled?: boolean(name='WebAssemblyFilterEnabled', description='Specifies whether to enable WebAssembly Filter. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
}

model CreateServiceMeshResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
}

model CreateServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceMeshResponseBody(name='body'),
}

async function createServiceMeshWithOptions(request: CreateServiceMeshRequest, runtime: Util.RuntimeOptions): CreateServiceMeshResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessLogEnabled)) {
    body['AccessLogEnabled'] = request.accessLogEnabled;
  }
  if (!Util.isUnset(request.accessLogFile)) {
    body['AccessLogFile'] = request.accessLogFile;
  }
  if (!Util.isUnset(request.accessLogFormat)) {
    body['AccessLogFormat'] = request.accessLogFormat;
  }
  if (!Util.isUnset(request.accessLogProject)) {
    body['AccessLogProject'] = request.accessLogProject;
  }
  if (!Util.isUnset(request.accessLogServiceEnabled)) {
    body['AccessLogServiceEnabled'] = request.accessLogServiceEnabled;
  }
  if (!Util.isUnset(request.accessLogServiceHost)) {
    body['AccessLogServiceHost'] = request.accessLogServiceHost;
  }
  if (!Util.isUnset(request.accessLogServicePort)) {
    body['AccessLogServicePort'] = request.accessLogServicePort;
  }
  if (!Util.isUnset(request.apiServerLoadBalancerSpec)) {
    body['ApiServerLoadBalancerSpec'] = request.apiServerLoadBalancerSpec;
  }
  if (!Util.isUnset(request.apiServerPublicEip)) {
    body['ApiServerPublicEip'] = request.apiServerPublicEip;
  }
  if (!Util.isUnset(request.auditProject)) {
    body['AuditProject'] = request.auditProject;
  }
  if (!Util.isUnset(request.autoRenew)) {
    body['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.autoRenewPeriod)) {
    body['AutoRenewPeriod'] = request.autoRenewPeriod;
  }
  if (!Util.isUnset(request.CRAggregationEnabled)) {
    body['CRAggregationEnabled'] = request.CRAggregationEnabled;
  }
  if (!Util.isUnset(request.chargeType)) {
    body['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.clusterSpec)) {
    body['ClusterSpec'] = request.clusterSpec;
  }
  if (!Util.isUnset(request.configSourceEnabled)) {
    body['ConfigSourceEnabled'] = request.configSourceEnabled;
  }
  if (!Util.isUnset(request.configSourceNacosID)) {
    body['ConfigSourceNacosID'] = request.configSourceNacosID;
  }
  if (!Util.isUnset(request.controlPlaneLogEnabled)) {
    body['ControlPlaneLogEnabled'] = request.controlPlaneLogEnabled;
  }
  if (!Util.isUnset(request.controlPlaneLogProject)) {
    body['ControlPlaneLogProject'] = request.controlPlaneLogProject;
  }
  if (!Util.isUnset(request.customizedPrometheus)) {
    body['CustomizedPrometheus'] = request.customizedPrometheus;
  }
  if (!Util.isUnset(request.customizedZipkin)) {
    body['CustomizedZipkin'] = request.customizedZipkin;
  }
  if (!Util.isUnset(request.DNSProxyingEnabled)) {
    body['DNSProxyingEnabled'] = request.DNSProxyingEnabled;
  }
  if (!Util.isUnset(request.dubboFilterEnabled)) {
    body['DubboFilterEnabled'] = request.dubboFilterEnabled;
  }
  if (!Util.isUnset(request.edition)) {
    body['Edition'] = request.edition;
  }
  if (!Util.isUnset(request.enableAmbient)) {
    body['EnableAmbient'] = request.enableAmbient;
  }
  if (!Util.isUnset(request.enableAudit)) {
    body['EnableAudit'] = request.enableAudit;
  }
  if (!Util.isUnset(request.enableCRHistory)) {
    body['EnableCRHistory'] = request.enableCRHistory;
  }
  if (!Util.isUnset(request.enableSDSServer)) {
    body['EnableSDSServer'] = request.enableSDSServer;
  }
  if (!Util.isUnset(request.excludeIPRanges)) {
    body['ExcludeIPRanges'] = request.excludeIPRanges;
  }
  if (!Util.isUnset(request.excludeInboundPorts)) {
    body['ExcludeInboundPorts'] = request.excludeInboundPorts;
  }
  if (!Util.isUnset(request.excludeOutboundPorts)) {
    body['ExcludeOutboundPorts'] = request.excludeOutboundPorts;
  }
  if (!Util.isUnset(request.existingCaCert)) {
    body['ExistingCaCert'] = request.existingCaCert;
  }
  if (!Util.isUnset(request.existingCaKey)) {
    body['ExistingCaKey'] = request.existingCaKey;
  }
  if (!Util.isUnset(request.existingCaType)) {
    body['ExistingCaType'] = request.existingCaType;
  }
  if (!Util.isUnset(request.existingRootCaCert)) {
    body['ExistingRootCaCert'] = request.existingRootCaCert;
  }
  if (!Util.isUnset(request.existingRootCaKey)) {
    body['ExistingRootCaKey'] = request.existingRootCaKey;
  }
  if (!Util.isUnset(request.filterGatewayClusterConfig)) {
    body['FilterGatewayClusterConfig'] = request.filterGatewayClusterConfig;
  }
  if (!Util.isUnset(request.gatewayAPIEnabled)) {
    body['GatewayAPIEnabled'] = request.gatewayAPIEnabled;
  }
  if (!Util.isUnset(request.guestCluster)) {
    body['GuestCluster'] = request.guestCluster;
  }
  if (!Util.isUnset(request.includeIPRanges)) {
    body['IncludeIPRanges'] = request.includeIPRanges;
  }
  if (!Util.isUnset(request.istioVersion)) {
    body['IstioVersion'] = request.istioVersion;
  }
  if (!Util.isUnset(request.kialiEnabled)) {
    body['KialiEnabled'] = request.kialiEnabled;
  }
  if (!Util.isUnset(request.localityLBConf)) {
    body['LocalityLBConf'] = request.localityLBConf;
  }
  if (!Util.isUnset(request.localityLoadBalancing)) {
    body['LocalityLoadBalancing'] = request.localityLoadBalancing;
  }
  if (!Util.isUnset(request.MSEEnabled)) {
    body['MSEEnabled'] = request.MSEEnabled;
  }
  if (!Util.isUnset(request.multiBufferEnabled)) {
    body['MultiBufferEnabled'] = request.multiBufferEnabled;
  }
  if (!Util.isUnset(request.multiBufferPollDelay)) {
    body['MultiBufferPollDelay'] = request.multiBufferPollDelay;
  }
  if (!Util.isUnset(request.mysqlFilterEnabled)) {
    body['MysqlFilterEnabled'] = request.mysqlFilterEnabled;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.OPALimitCPU)) {
    body['OPALimitCPU'] = request.OPALimitCPU;
  }
  if (!Util.isUnset(request.OPALimitMemory)) {
    body['OPALimitMemory'] = request.OPALimitMemory;
  }
  if (!Util.isUnset(request.OPALogLevel)) {
    body['OPALogLevel'] = request.OPALogLevel;
  }
  if (!Util.isUnset(request.OPARequestCPU)) {
    body['OPARequestCPU'] = request.OPARequestCPU;
  }
  if (!Util.isUnset(request.OPARequestMemory)) {
    body['OPARequestMemory'] = request.OPARequestMemory;
  }
  if (!Util.isUnset(request.opaEnabled)) {
    body['OpaEnabled'] = request.opaEnabled;
  }
  if (!Util.isUnset(request.openAgentPolicy)) {
    body['OpenAgentPolicy'] = request.openAgentPolicy;
  }
  if (!Util.isUnset(request.period)) {
    body['Period'] = request.period;
  }
  if (!Util.isUnset(request.pilotLoadBalancerSpec)) {
    body['PilotLoadBalancerSpec'] = request.pilotLoadBalancerSpec;
  }
  if (!Util.isUnset(request.prometheusUrl)) {
    body['PrometheusUrl'] = request.prometheusUrl;
  }
  if (!Util.isUnset(request.proxyLimitCPU)) {
    body['ProxyLimitCPU'] = request.proxyLimitCPU;
  }
  if (!Util.isUnset(request.proxyLimitMemory)) {
    body['ProxyLimitMemory'] = request.proxyLimitMemory;
  }
  if (!Util.isUnset(request.proxyRequestCPU)) {
    body['ProxyRequestCPU'] = request.proxyRequestCPU;
  }
  if (!Util.isUnset(request.proxyRequestMemory)) {
    body['ProxyRequestMemory'] = request.proxyRequestMemory;
  }
  if (!Util.isUnset(request.redisFilterEnabled)) {
    body['RedisFilterEnabled'] = request.redisFilterEnabled;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.telemetry)) {
    body['Telemetry'] = request.telemetry;
  }
  if (!Util.isUnset(request.thriftFilterEnabled)) {
    body['ThriftFilterEnabled'] = request.thriftFilterEnabled;
  }
  if (!Util.isUnset(request.traceSampling)) {
    body['TraceSampling'] = request.traceSampling;
  }
  if (!Util.isUnset(request.tracing)) {
    body['Tracing'] = request.tracing;
  }
  if (!Util.isUnset(request.useExistingCA)) {
    body['UseExistingCA'] = request.useExistingCA;
  }
  if (!Util.isUnset(request.vSwitches)) {
    body['VSwitches'] = request.vSwitches;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.webAssemblyFilterEnabled)) {
    body['WebAssemblyFilterEnabled'] = request.webAssemblyFilterEnabled;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceMesh',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createServiceMesh(request: CreateServiceMeshRequest): CreateServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceMeshWithOptions(request, runtime);
}

model CreateSwimLaneRequest {
  groupName?: string(name='GroupName', description='The name of the lane group.', example='test'),
  labelSelectorKey?: string(name='LabelSelectorKey', description='The label key of the associated service workload. Set the value to `ASM_TRAFFIC_TAG`.', example='ASM_TRAFFIC_TAG'),
  labelSelectorValue?: string(name='LabelSelectorValue', description='The label value of the associated service workload.``', example='v3'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='*****'),
  servicesList?: string(name='ServicesList', description='The list of services associated with the lane. The value is a JSON array. The format of a single service is `$Cluster name /$Cluster ID/$Namespace/$Service name`.', example='[\\"sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mocka\\",\\"sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockb\\",\\"sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockc\\"]'),
  swimLaneName?: string(name='SwimLaneName', description='The name of the lane.', example='s3'),
}

model CreateSwimLaneResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='*****'),
}

model CreateSwimLaneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSwimLaneResponseBody(name='body'),
}

async function createSwimLaneWithOptions(request: CreateSwimLaneRequest, runtime: Util.RuntimeOptions): CreateSwimLaneResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    body['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.labelSelectorKey)) {
    body['LabelSelectorKey'] = request.labelSelectorKey;
  }
  if (!Util.isUnset(request.labelSelectorValue)) {
    body['LabelSelectorValue'] = request.labelSelectorValue;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.servicesList)) {
    body['ServicesList'] = request.servicesList;
  }
  if (!Util.isUnset(request.swimLaneName)) {
    body['SwimLaneName'] = request.swimLaneName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSwimLane',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSwimLane(request: CreateSwimLaneRequest): CreateSwimLaneResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSwimLaneWithOptions(request, runtime);
}

model CreateSwimLaneGroupRequest {
  groupName?: string(name='GroupName', description='The name of the lane group.', example='test'),
  ingressGatewayName?: string(name='IngressGatewayName', description='The name of the ingress gateway.', example='ingressgateway'),
  ingressType?: string(name='IngressType', description='The type of the gateway for ingress traffic. Only ASM ingress gateways are supported.', example='ASM'),
  isPermissive?: boolean(name='IsPermissive'),
  routeHeader?: string(name='RouteHeader'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the Alibaba Cloud Service Mesh (ASM) instance.', example='xxx'),
  servicesList?: string(name='ServicesList', description='A list of services associated with the lane group. The value is a JSON array. The format of a service is `$Cluster name/$Cluster ID/$Namespace/$Service name`.', example='[\\"sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mocka\\",\\"sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockb\\",\\"sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockc\\"]'),
  traceHeader?: string(name='TraceHeader'),
}

model CreateSwimLaneGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='yyyy'),
}

model CreateSwimLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSwimLaneGroupResponseBody(name='body'),
}

async function createSwimLaneGroupWithOptions(request: CreateSwimLaneGroupRequest, runtime: Util.RuntimeOptions): CreateSwimLaneGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    body['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.ingressGatewayName)) {
    body['IngressGatewayName'] = request.ingressGatewayName;
  }
  if (!Util.isUnset(request.ingressType)) {
    body['IngressType'] = request.ingressType;
  }
  if (!Util.isUnset(request.isPermissive)) {
    body['IsPermissive'] = request.isPermissive;
  }
  if (!Util.isUnset(request.routeHeader)) {
    body['RouteHeader'] = request.routeHeader;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.servicesList)) {
    body['ServicesList'] = request.servicesList;
  }
  if (!Util.isUnset(request.traceHeader)) {
    body['TraceHeader'] = request.traceHeader;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSwimLaneGroup',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSwimLaneGroup(request: CreateSwimLaneGroupRequest): CreateSwimLaneGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSwimLaneGroupWithOptions(request, runtime);
}

model DeleteGatewayRouteRequest {
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  routeName?: string(name='RouteName', description='The name of the routing rule.', example='http-route'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
}

model DeleteGatewayRouteResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DeleteGatewayRouteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGatewayRouteResponseBody(name='body'),
}

async function deleteGatewayRouteWithOptions(request: DeleteGatewayRouteRequest, runtime: Util.RuntimeOptions): DeleteGatewayRouteResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.routeName)) {
    body['RouteName'] = request.routeName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGatewayRoute',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGatewayRoute(request: DeleteGatewayRouteRequest): DeleteGatewayRouteResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGatewayRouteWithOptions(request, runtime);
}

model DeleteGatewaySecretRequest {
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='bookinfo-secret'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
}

model DeleteGatewaySecretResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
  secretDeleteRecord?: map[string]SecretDeleteRecordValue(name='SecretDeleteRecord', description='The record of deleting the secret.'),
}

model DeleteGatewaySecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGatewaySecretResponseBody(name='body'),
}

async function deleteGatewaySecretWithOptions(request: DeleteGatewaySecretRequest, runtime: Util.RuntimeOptions): DeleteGatewaySecretResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.secretName)) {
    body['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGatewaySecret',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGatewaySecret(request: DeleteGatewaySecretRequest): DeleteGatewaySecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGatewaySecretWithOptions(request, runtime);
}

model DeleteIstioGatewayDomainsRequest {
  hosts?: string(name='Hosts', description='The domain names of the one or more hosts that are exposed by the ASM gateway. Separate multiple domain names with commas (,).', example='example.com,demo.com'),
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  limit?: string(name='Limit', description='The maximum number of ASM gateways to query.', example='10'),
  namespace?: string(name='Namespace', description='The namespace in which the ASM gateway resides.', example='default'),
  portName?: string(name='PortName', description='The name of the port.', example='https'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
}

model DeleteIstioGatewayDomainsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DeleteIstioGatewayDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIstioGatewayDomainsResponseBody(name='body'),
}

async function deleteIstioGatewayDomainsWithOptions(request: DeleteIstioGatewayDomainsRequest, runtime: Util.RuntimeOptions): DeleteIstioGatewayDomainsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.hosts)) {
    body['Hosts'] = request.hosts;
  }
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.portName)) {
    body['PortName'] = request.portName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIstioGatewayDomains',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIstioGatewayDomains(request: DeleteIstioGatewayDomainsRequest): DeleteIstioGatewayDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIstioGatewayDomainsWithOptions(request, runtime);
}

model DeleteServiceMeshRequest {
  force?: boolean(name='Force', description='Specifies whether to forcibly delete the ASM instance. Valid values:

*   `true`: forcibly deletes the ASM instance.
*   `false`: does not forcibly delete the ASM instance.

Default value: false.', example='false'),
  retainResources?: string(name='RetainResources', description='A JSON string that can be parsed into a string array. You can use this JSON string to specify the IDs of the resource instances that need to be retained when the ASM instance is deleted.', example='[" lb-bp1fxvl3q8akbj6m*****", "lb-bp1hoxkolggdw0y3*****"]'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
}

model DeleteServiceMeshResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='11fd0027-c27e-41bb-a565-75583054****'),
}

model DeleteServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceMeshResponseBody(name='body'),
}

async function deleteServiceMeshWithOptions(request: DeleteServiceMeshRequest, runtime: Util.RuntimeOptions): DeleteServiceMeshResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.force)) {
    body['Force'] = request.force;
  }
  if (!Util.isUnset(request.retainResources)) {
    body['RetainResources'] = request.retainResources;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceMesh',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteServiceMesh(request: DeleteServiceMeshRequest): DeleteServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServiceMeshWithOptions(request, runtime);
}

model DeleteSwimLaneRequest {
  groupName?: string(name='GroupName', description='The name of the lane group.', example='test'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='xxx'),
  swimLaneName?: string(name='SwimLaneName', description='The name of the lane.', example='s1'),
}

model DeleteSwimLaneResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='xxx'),
}

model DeleteSwimLaneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSwimLaneResponseBody(name='body'),
}

async function deleteSwimLaneWithOptions(request: DeleteSwimLaneRequest, runtime: Util.RuntimeOptions): DeleteSwimLaneResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    body['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.swimLaneName)) {
    body['SwimLaneName'] = request.swimLaneName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSwimLane',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSwimLane(request: DeleteSwimLaneRequest): DeleteSwimLaneResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSwimLaneWithOptions(request, runtime);
}

model DeleteSwimLaneGroupRequest {
  groupName?: string(name='GroupName', description='The name of the lane group.', example='test'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='xxx'),
}

model DeleteSwimLaneGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='xxxx'),
}

model DeleteSwimLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSwimLaneGroupResponseBody(name='body'),
}

async function deleteSwimLaneGroupWithOptions(request: DeleteSwimLaneGroupRequest, runtime: Util.RuntimeOptions): DeleteSwimLaneGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    body['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSwimLaneGroup',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSwimLaneGroup(request: DeleteSwimLaneGroupRequest): DeleteSwimLaneGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSwimLaneGroupWithOptions(request, runtime);
}

model DescribeASMGatewayImportedServicesRequest {
  ASMGatewayName?: string(name='ASMGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
  serviceNamespace?: string(name='ServiceNamespace', description='The namespace in which the service resides.', example='default'),
}

model DescribeASMGatewayImportedServicesResponseBody = {
  importedServices?: [ 
    {
      serviceName?: string(name='ServiceName', description='The name of the service.', example='productpage'),
      serviceNamespace?: string(name='ServiceNamespace', description='The namespace in which the service resides.', example='default'),
    }
  ](name='ImportedServices', description='The imported services.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='11fd0027-c27e-41bb-a565-75583054****'),
}

model DescribeASMGatewayImportedServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeASMGatewayImportedServicesResponseBody(name='body'),
}

async function describeASMGatewayImportedServicesWithOptions(request: DescribeASMGatewayImportedServicesRequest, runtime: Util.RuntimeOptions): DescribeASMGatewayImportedServicesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ASMGatewayName)) {
    body['ASMGatewayName'] = request.ASMGatewayName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.serviceNamespace)) {
    body['ServiceNamespace'] = request.serviceNamespace;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeASMGatewayImportedServices',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeASMGatewayImportedServices(request: DescribeASMGatewayImportedServicesRequest): DescribeASMGatewayImportedServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeASMGatewayImportedServicesWithOptions(request, runtime);
}

model DescribeCCMVersionRequest {
  serviceMeshId?: string(name='ServiceMeshId', description='The versions of the CCM component in all clusters on the data plane.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
}

model DescribeCCMVersionResponseBody = {
  CCMVersions?: map[string]CCMVersionsValue(name='CCMVersions', description='The ID of the request.'),
  requestId?: string(name='RequestId', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model DescribeCCMVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCCMVersionResponseBody(name='body'),
}

async function describeCCMVersionWithOptions(request: DescribeCCMVersionRequest, runtime: Util.RuntimeOptions): DescribeCCMVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCCMVersion',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCCMVersion(request: DescribeCCMVersionRequest): DescribeCCMVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCCMVersionWithOptions(request, runtime);
}

model DescribeCensRequest {
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='ce134b0727aa2492db69f6c3880e1****'),
}

model DescribeCensResponseBody = {
  clusters?: [ string ](name='Clusters', description='The IDs of the queried Kubernetes clusters.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model DescribeCensResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCensResponseBody(name='body'),
}

async function describeCensWithOptions(request: DescribeCensRequest, runtime: Util.RuntimeOptions): DescribeCensResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCens',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCens(request: DescribeCensRequest): DescribeCensResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCensWithOptions(request, runtime);
}

model DescribeClusterGrafanaRequest {
  k8sClusterId?: string(name='K8sClusterId', description='The ID of the cluster on the data plane.', example='ce3c25e247da24f3aab9b7edfae83****'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='cb8963379255149cb98c8686f274x****'),
}

model DescribeClusterGrafanaResponseBody = {
  dashboards?: [ 
    {
      title?: string(name='Title', description='The title of the Grafana dashboard.', example='test'),
      url?: string(name='Url', description='The endpoint of the Grafana dashboard.', example='test.com'),
    }
  ](name='Dashboards', description='The information of Grafana dashboards.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model DescribeClusterGrafanaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterGrafanaResponseBody(name='body'),
}

async function describeClusterGrafanaWithOptions(request: DescribeClusterGrafanaRequest, runtime: Util.RuntimeOptions): DescribeClusterGrafanaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.k8sClusterId)) {
    query['K8sClusterId'] = request.k8sClusterId;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterGrafana',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterGrafana(request: DescribeClusterGrafanaRequest): DescribeClusterGrafanaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterGrafanaWithOptions(request, runtime);
}

model DescribeClusterPrometheusRequest {
  k8sClusterId?: string(name='K8sClusterId', description='The ID of the cluster on the data plane.', example='ce3c25e247da24f3aab9b7edfae83****'),
  k8sClusterRegionId?: string(name='K8sClusterRegionId', description='The ID of the region where the cluster on the data plane resides.', example='cn-hangzhou'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='cb8963379255149cb98c8686f274x****'),
}

model DescribeClusterPrometheusResponseBody = {
  prometheus?: string(name='Prometheus', description='The public endpoint of the Prometheus service that is used to monitor a cluster in the ASM instance.', example='p.com'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model DescribeClusterPrometheusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterPrometheusResponseBody(name='body'),
}

async function describeClusterPrometheusWithOptions(request: DescribeClusterPrometheusRequest, runtime: Util.RuntimeOptions): DescribeClusterPrometheusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.k8sClusterId)) {
    query['K8sClusterId'] = request.k8sClusterId;
  }
  if (!Util.isUnset(request.k8sClusterRegionId)) {
    query['K8sClusterRegionId'] = request.k8sClusterRegionId;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterPrometheus',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterPrometheus(request: DescribeClusterPrometheusRequest): DescribeClusterPrometheusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterPrometheusWithOptions(request, runtime);
}

model DescribeClustersInServiceMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='cb8963379255149cb98c8686f274x****'),
}

model DescribeClustersInServiceMeshResponseBody = {
  clusters?: [ 
    {
      accessLogDashboards?: [ 
        {
          title?: string(name='Title', description='The name of the dashboard for access logs.', example='mesh-access-log_details_cn'),
          url?: string(name='Url', description='The URL of the dashboard for access logs.', example='https://sls.console.aliyun.com/next/project/****/dashboard/mesh-access-log_details_cn'),
        }
      ](name='AccessLogDashboards', description='The configurations of access log collection.'),
      clusterDomain?: string(name='ClusterDomain', description='The domain of the cluster.', example='example.com'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c80f45444b3da447da60a911390c2****'),
      clusterType?: string(name='ClusterType', description='The type of the cluster.', example='Ask'),
      creationTime?: string(name='CreationTime', description='The point in time when the cluster was created.', example='2020-05-12T15:38:16+08:00'),
      errorMessage?: string(name='ErrorMessage', description='The error message that is returned when the call failed.', example=','),
      logtailInstalledState?: string(name='LogtailInstalledState', description='Indicates whether the Logtail component is installed in the cluster. Valid values:

*   `logtail_installed`: The Logtail component is installed.

\\-`logtail_uninstalled`: The Logtail component is not installed.

*   `logtail_state_get_error`: The Logtail component fails to be installed.', example='logtail_installed'),
      name?: string(name='Name', description='The name of the cluster.', example='ask1'),
      regionId?: string(name='RegionId', description='The ID of the region in which the cluster resides.', example='cn-hangzhou'),
      sgId?: string(name='SgId', description='The ID of the security group.', example='sg-bp197668l6iupljy****'),
      state?: string(name='State', description='The status of the cluster.', example='running'),
      updateTime?: string(name='UpdateTime', description='The point in time when the cluster was last modified.', example='2020-05-12T15:38:16+08:00'),
      version?: string(name='Version', description='The version number of the cluster.', example='v1.16.6-aliyun.1'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-2zew0rajjkmxy2369****'),
    }
  ](name='Clusters', description='The clusters in the ASM instance.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeClustersInServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClustersInServiceMeshResponseBody(name='body'),
}

async function describeClustersInServiceMeshWithOptions(request: DescribeClustersInServiceMeshRequest, runtime: Util.RuntimeOptions): DescribeClustersInServiceMeshResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClustersInServiceMesh',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClustersInServiceMesh(request: DescribeClustersInServiceMeshRequest): DescribeClustersInServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClustersInServiceMeshWithOptions(request, runtime);
}

model DescribeCrTemplatesRequest {
  istioVersion?: string(name='IstioVersion', description='The Istio version used in ASM.', example='v1.9.7.31-g24cdcb43-aliyun'),
  kind?: string(name='Kind', description='The type of Istio resource whose common YAML templates you want to query. Valid values:

*   AuthorizationPolicy
*   RequestAuthentication
*   PeerAuthentication
*   WorkloadGroup
*   WorkloadEntry
*   Sidecar
*   EnvoyFilter
*   ServiceEntry
*   Gateway
*   DestinationRule
*   VirtualService', example='VirtualService'),
}

model DescribeCrTemplatesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='74E97AE2-2900-55C1-A069-C3C1EA*****'),
  templates?: [ 
    {
      chineseName?: string(name='ChineseName', description='The Chinese name of the YAML template.'),
      englishName?: string(name='EnglishName', description='The English name of the YAML template.', example='HTTP basic routing'),
      yaml?: string(name='Yaml', description='The content in the YAML template.', example='apiVersion: networking.istio.io/v1beta1\\nkind: VirtualService\\nmetadata:\\n  name: reviews-route # Name for this VirtualService.\\nspec:\\n  hosts:\\n  - reviews.prod.svc.cluster.local # Service that this VirtualSerivce belongs to. \\n  http:\\n  - name: \\"reviews-route\\" # Name for the route.\\n    route:\\n    - destination: # Uniquely identifies the instances of a service to which all traffic should be forwarded to.\\n        host: reviews.prod.svc.cluster.local # The name of a service from the service registry or ServiceEntry.\\n        port:\\n          number: 8080"'),
    }
  ](name='Templates', description='The common YAML templates for the specified type of Istio resource.'),
}

model DescribeCrTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCrTemplatesResponseBody(name='body'),
}

async function describeCrTemplatesWithOptions(request: DescribeCrTemplatesRequest, runtime: Util.RuntimeOptions): DescribeCrTemplatesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.istioVersion)) {
    body['IstioVersion'] = request.istioVersion;
  }
  if (!Util.isUnset(request.kind)) {
    body['Kind'] = request.kind;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCrTemplates',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCrTemplates(request: DescribeCrTemplatesRequest): DescribeCrTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCrTemplatesWithOptions(request, runtime);
}

model DescribeEipResourcesRequest {
  pageNum?: int32(name='PageNum', description='The number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='50'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='cb8963379255149cb98c8686f274x****'),
}

model DescribeEipResourcesResponseBody = {
  eipList?: [ 
    {
      allocationId?: string(name='AllocationId', description='The ID of the EIP.', example='eip-2zeerraiwb7ujxscd****'),
      instanceType?: string(name='InstanceType', description='The type of the resource that is associated with the EIP. Valid values:

*   `EcsInstance`: an ECS instance in a VPC
*   `SlbInstance`: a Server Load Balancer (SLB) instance in a VPC
*   `Nat`: a NAT gateway
*   `HaVip`: a high-availability virtual IP address (HAVIP)
*   `NetworkInterface`: a secondary elastic network interface (ENI)

Default value: `EcsInstance`.', example='SlbInstance'),
      ipAddress?: string(name='IpAddress', description='The IP address of the EIP.', example='120.xx.xx.112'),
      status?: string(name='Status', description='The status of the EIP. Valid values:

*   `Associating`: The EIP is being associated with a resource.
*   `Unassociating`: The EIP is being disassociated from a resource.
*   `InUse`: The EIP is associated with a resource.
*   `Available`: The EIP is available.', example='InUse'),
    }
  ](name='EipList', description='The EIPs.'),
  pageResult?: {
    pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
    totalCount?: int32(name='TotalCount', description='The number of entries returned.', example='10'),
  }(name='PageResult', description='The pagination information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model DescribeEipResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEipResourcesResponseBody(name='body'),
}

async function describeEipResourcesWithOptions(request: DescribeEipResourcesRequest, runtime: Util.RuntimeOptions): DescribeEipResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEipResources',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEipResources(request: DescribeEipResourcesRequest): DescribeEipResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipResourcesWithOptions(request, runtime);
}

model DescribeGatewaySecretDetailsRequest {
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
}

model DescribeGatewaySecretDetailsResponseBody = {
  gatewaySecretDetails?: [ 
    {
      expiredTime?: string(name='ExpiredTime', description='The time when the certificate expires.', example='2023-03-03 07:45'),
      gatewayName?: string(name='GatewayName', description='The name of the gateway.', example='bookinfo-gateway'),
      issueTime?: string(name='IssueTime', description='The time when the certificate was issued.', example='2022-03-03 07:45'),
      message?: string(name='Message', description='*   An error message is returned if the status of the gateway is abnormal. Examples: `tls.crt not exist`, `tls.key not exist`, and `secret type must be kubernetes.io/tls`.
*   An empty value is returned if the status of the gateway is normal.', example='tls.crt not exist'),
      SNI?: string(name='SNI', description='The Server Name Indication (SNI) value that indicates the hostname of the service.', example='demo.com'),
      secretName?: string(name='SecretName', description='The name of the secret.', example='demo-secret'),
      state?: string(name='State', description='The status of the certificate. Valid values:

*   `normal`
*   `abnormal`', example='normal'),
    }
  ](name='GatewaySecretDetails', description='The detailed information about the secret of the ASM gateway.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeGatewaySecretDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGatewaySecretDetailsResponseBody(name='body'),
}

async function describeGatewaySecretDetailsWithOptions(request: DescribeGatewaySecretDetailsRequest, runtime: Util.RuntimeOptions): DescribeGatewaySecretDetailsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGatewaySecretDetails',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGatewaySecretDetails(request: DescribeGatewaySecretDetailsRequest): DescribeGatewaySecretDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGatewaySecretDetailsWithOptions(request, runtime);
}

model DescribeGuestClusterAccessLogDashboardsRequest {
  k8sClusterId?: string(name='K8sClusterId', description='The ID of the cluster on the data plane.', example='ce3c25e247da24f3aab9b7edfae83****'),
}

model DescribeGuestClusterAccessLogDashboardsResponseBody = {
  dashboards?: [ 
    {
      title?: string(name='Title', description='The title of the report.', example='test'),
      url?: string(name='Url', description='The URL of the report.', example='test.com'),
    }
  ](name='Dashboards', description='The access log reports of a cluster on the data plane.'),
  k8sClusterId?: string(name='K8sClusterId', description='The ID of the cluster on the data plane.', example='ce3c25e247da24f3aab9b7edfae83****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model DescribeGuestClusterAccessLogDashboardsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGuestClusterAccessLogDashboardsResponseBody(name='body'),
}

async function describeGuestClusterAccessLogDashboardsWithOptions(request: DescribeGuestClusterAccessLogDashboardsRequest, runtime: Util.RuntimeOptions): DescribeGuestClusterAccessLogDashboardsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.k8sClusterId)) {
    body['K8sClusterId'] = request.k8sClusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGuestClusterAccessLogDashboards',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGuestClusterAccessLogDashboards(request: DescribeGuestClusterAccessLogDashboardsRequest): DescribeGuestClusterAccessLogDashboardsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGuestClusterAccessLogDashboardsWithOptions(request, runtime);
}

model DescribeGuestClusterNamespacesRequest {
  guestClusterID?: string(name='GuestClusterID', description='The ID of the Kubernetes cluster that is added to the ASM instance.', example='c584d805c7bd442b8bac421f9849f****'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='ce134b0727aa2492db69f6c3880e****'),
  showNsLabels?: boolean(name='ShowNsLabels', description='Specifies whether to return the labels of the namespaces.', example='true'),
}

model DescribeGuestClusterNamespacesResponseBody = {
  nsLabels?: map[string]any(name='NsLabels', description='The labels of the namespaces. Labels are returned only when the `ShowNsLabels` parameter is set to `true`.', example='{"default":{"istio-injection":"enabled"}}'),
  nsList?: [ string ](name='NsList', description='The names of the namespaces.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeGuestClusterNamespacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGuestClusterNamespacesResponseBody(name='body'),
}

async function describeGuestClusterNamespacesWithOptions(request: DescribeGuestClusterNamespacesRequest, runtime: Util.RuntimeOptions): DescribeGuestClusterNamespacesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.guestClusterID)) {
    body['GuestClusterID'] = request.guestClusterID;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.showNsLabels)) {
    body['ShowNsLabels'] = request.showNsLabels;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGuestClusterNamespaces',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGuestClusterNamespaces(request: DescribeGuestClusterNamespacesRequest): DescribeGuestClusterNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGuestClusterNamespacesWithOptions(request, runtime);
}

model DescribeGuestClusterPodsRequest {
  guestClusterID?: string(name='GuestClusterID', description='The ID of the Kubernetes cluster that is added to the ASM instance.', example='c49ad2169d5a04f2d89dfc4b6bcu****'),
  namespace?: string(name='Namespace', description='The name of the namespace.', example='default'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c78d60f98fa43403ab6e0701b2678****'),
}

model DescribeGuestClusterPodsResponseBody = {
  podList?: [ string ](name='PodList', description='The names of the queried pods.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EDDC0D86-2FC3-56FB-9213-96EB0A3523F1'),
}

model DescribeGuestClusterPodsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGuestClusterPodsResponseBody(name='body'),
}

async function describeGuestClusterPodsWithOptions(request: DescribeGuestClusterPodsRequest, runtime: Util.RuntimeOptions): DescribeGuestClusterPodsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.guestClusterID)) {
    body['GuestClusterID'] = request.guestClusterID;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGuestClusterPods',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGuestClusterPods(request: DescribeGuestClusterPodsRequest): DescribeGuestClusterPodsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGuestClusterPodsWithOptions(request, runtime);
}

model DescribeImportedServicesDetailRequest {
  ASMGatewayName?: string(name='ASMGatewayName', description='The name of the service.', example='ingressgateway'),
  serviceMeshId?: string(name='ServiceMeshId', description='The details of the services.', example='cb8963379255149cb98c8686f274x****'),
  serviceNamespace?: string(name='ServiceNamespace', description='The namespace in which the service resides.', example='default'),
}

model DescribeImportedServicesDetailResponseBody = {
  details?: [ 
    {
      clusterIds?: [ string ](name='ClusterIds', description='The name of the port.'),
      labels?: map[string]string(name='Labels', description='The ports declared for the service.'),
      namespace?: string(name='Namespace', description='Kubernetes', example='default'),
      ports?: [ 
        {
          name?: string(name='Name', description='The container port.', example='http-0'),
          nodePort?: int32(name='NodePort', example='12345'),
          port?: int32(name='Port', example='80'),
          protocol?: string(name='Protocol', description='The node port.', example='tcp'),
          targetPort?: int32(name='TargetPort', example='8080'),
        }
      ](name='Ports', description='The port number.'),
      serviceName?: string(name='ServiceName', description='The type of the service.', example='productpage'),
      serviceType?: string(name='ServiceType', description='The protocol of the port.', example='Kubernetes'),
    }
  ](name='Details', description='The IDs of the clusters to which the service belongs.'),
  requestId?: string(name='RequestId', description='The labels of the service.', example='E0496204-7586-5B4C-B364-2361CC0EDxxxx'),
}

model DescribeImportedServicesDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImportedServicesDetailResponseBody(name='body'),
}

async function describeImportedServicesDetailWithOptions(request: DescribeImportedServicesDetailRequest, runtime: Util.RuntimeOptions): DescribeImportedServicesDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ASMGatewayName)) {
    body['ASMGatewayName'] = request.ASMGatewayName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.serviceNamespace)) {
    body['ServiceNamespace'] = request.serviceNamespace;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImportedServicesDetail',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImportedServicesDetail(request: DescribeImportedServicesDetailRequest): DescribeImportedServicesDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImportedServicesDetailWithOptions(request, runtime);
}

model DescribeIstioGatewayDomainsRequest {
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  limit?: string(name='Limit', description='The maximum number of ASM gateways to query.', example='10'),
  namespace?: string(name='Namespace', description='The namespace in which the ASM gateway resides.', example='default'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
}

model DescribeIstioGatewayDomainsResponseBody = {
  gatewaySecretDetails?: [ 
    {
      credentialName?: string(name='CredentialName', description='The name of the secret that contains the Transport Layer Security (TLS) certificate and certificate authority (CA) certificate.', example='bookinfo-secret'),
      detail?: string(name='Detail', description='The details of the domain name in the JSON format.', example='{   "servers": [     {       "port": {         "number": 27018,         "name": "mongo",         "protocol": "MONGO"       },       "hosts": [         "*"       ]     }   ] }'),
      domains?: [ string ](name='Domains', description='The domain name.'),
      gatewayCRName?: string(name='GatewayCRName'),
      namespace?: string(name='Namespace', description='The namespace in which the ASM gateway resides.', example='default'),
      portName?: string(name='PortName', description='The name of the port.', example='https-demo'),
      protocol?: string(name='Protocol', description='The type of the protocol. Valid values: `HTTP`, `HTTPS`, `GRPC`, `HTTP2`, `MONGO`, `TCP`, and `TLS`.', example='HTTPS'),
    }
  ](name='GatewaySecretDetails', description='The domain names that are exposed by the ASM gateway.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeIstioGatewayDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIstioGatewayDomainsResponseBody(name='body'),
}

async function describeIstioGatewayDomainsWithOptions(request: DescribeIstioGatewayDomainsRequest, runtime: Util.RuntimeOptions): DescribeIstioGatewayDomainsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIstioGatewayDomains',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIstioGatewayDomains(request: DescribeIstioGatewayDomainsRequest): DescribeIstioGatewayDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIstioGatewayDomainsWithOptions(request, runtime);
}

model DescribeIstioGatewayRouteDetailRequest {
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  routeName?: string(name='RouteName', description='The name of the routing rule.', example='demo-route'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
}

model DescribeIstioGatewayRouteDetailResponseBody = {
  description?: string(name='Description', description='The description of the routing rule.', example='demo route'),
  namespace?: string(name='Namespace', description='The namespace.', example='default'),
  priority?: int32(name='Priority', description='The priority of the routing rule. The value of this parameter is an integer. A smaller value indicates a higher priority.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
  routeDetail?: {
    domains?: [ string ](name='Domains'),
    HTTPAdvancedOptions?: {
      delegate?: {
        name?: string(name='Name', description='The name of the virtual service.', example='reviews'),
        namespace?: string(name='Namespace', description='The namespace to which the virtual service belongs.', example='default'),
      }(name='Delegate', description='The virtual service that defines traffic routing.'),
      fault?: {
        abort?: {
          httpStatus?: int32(name='HttpStatus', description='The HTTP status code.', example='400'),
          percentage?: {
            value?: float(name='Value', description='The percentage of requests that are mirrored to another destination except for the original destination, which is expressed as a decimal.', example='0.1'),
          }(name='Percentage', description='The percentage of requests that are aborted with the specified error code.'),
        }(name='Abort', description='The configurations for aborting requests with specified error codes.'),
        delay?: {
          exponentialDelay?: string(name='ExponentialDelay', description='The duration for request delay is expressed as 2 raised to the power of x. You must specify the value of x.', example='3'),
          fixedDelay?: string(name='FixedDelay', description='The fixed duration for request delay.', example='5s'),
          percentage?: {
            value?: float(name='Value', description='The percentage of requests that are aborted with the specified error code, which is expressed as a decimal.', example='0.1'),
          }(name='Percentage', description='The percentage of requests to which the delay fault is injected.'),
        }(name='Delay', description='The duration to delay a request.'),
      }(name='Fault', description='The configurations of fault injection.'),
      HTTPRedirect?: {
        authority?: string(name='Authority', description='The value to be used to overwrite the value of the Authority or Host header during redirection.', example='newratings.default.svc.cluster.local'),
        redirectCode?: int32(name='RedirectCode', description='The HTTP status code to be used to indicate URL redirection. Default value: 301.', example='301'),
        uri?: string(name='Uri', description='The value to be used to overwrite the URL path during redirection.', example='/v1/getProductRatings'),
      }(name='HTTPRedirect', description='The HTTP redirection rule.'),
      mirror?: {
        host?: string(name='Host', description='The name of the service defined in the service registry.', example='reviews.default.svc.cluster.local'),
        subset?: string(name='Subset', description='The name of the service subset.', example='v1'),
      }(name='Mirror', description='The configurations for mirroring HTTP traffic to another destination in addition to forwarding requests to the specified destination.'),
      mirrorPercentage?: {
        value?: float(name='Value', description='The percentage of requests that are aborted with the specified error code, which is expressed as a decimal.', example='0.2'),
      }(name='MirrorPercentage', description='The percentage of requests that are aborted with the specified error code.'),
      retries?: {
        attempts?: int32(name='Attempts', description='The number of retries that are allowed for a request.', example='3'),
        perTryTimeout?: string(name='PerTryTimeout', description='The timeout period for each retry.', example='2s'),
        retryOn?: string(name='RetryOn', description='The condition for retries. Example: `connect-failure,refused-stream,503`.', example='connect-failure,refused-stream,503'),
        retryRemoteLocalities?: {
          value?: boolean(name='Value', description='Specifies whether to allow retries to other localities. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
        }(name='RetryRemoteLocalities', description='Specifies whether to allow retries to other localities.'),
      }(name='Retries', description='The configurations of retries for failed requests.'),
      rewrite?: {
        authority?: string(name='Authority', description='The value to be used to overwrite the value of the Authority or Host header.', example='newratings.default.svc.cluster.local'),
        uri?: string(name='Uri', description='The value to be used to overwrite the path or prefix of the URI.', example='/v1/getProductRatings'),
      }(name='Rewrite', description='The configurations for rewriting the virtual service.'),
      timeout?: string(name='Timeout', description='The timeout period for requests.', example='5s'),
    }(name='HTTPAdvancedOptions', description='The advanced settings for routing HTTP traffic.'),
    hasUnsafeFeatures?: boolean(name='HasUnsafeFeatures'),
    matchRequest?: {
      headers?: [ 
        {
          matchingContent?: string(name='MatchingContent', description='The header value to be matched.', example='v1'),
          matchingMode?: string(name='MatchingMode', description='The matching mode for the header value. Valid values:

*   `exact`: exact match
*   `prefix`: match by prefix
*   `regex`: match by regular expression', example='exact'),
          name?: string(name='Name', description='The header key to be matched.', example='x-request-id'),
        }
      ](name='Headers', description='The request headers to be matched.'),
      ports?: [ int32 ](name='Ports', description='The ports.'),
      TLSMatchAttributes?: [ 
        {
          SNIHosts?: [ string ](name='SNIHosts', description='The Server Name Indication (SNI) values to be matched.'),
          TLSPort?: int32(name='TLSPort', description='The TLS port.', example='443'),
        }
      ](name='TLSMatchAttributes', description='The matching rules for Transport Layer Security (TLS) traffic.'),
      URI?: {
        matchingContent?: string(name='MatchingContent', description='The content to be matched.', example='/ratings/v2/'),
        matchingMode?: string(name='MatchingMode', description='The matching mode. Valid values:

*   `exact`: exact match
*   `prefix`: match by prefix
*   `regex`: match by regular expression', example='prefix'),
      }(name='URI', description='The matching rule for URIs.'),
    }(name='MatchRequest', description='The matching rules for traffic routing.'),
    rawVSRoute?: string(name='RawVSRoute'),
    routeDestinations?: [ 
      {
        destination?: {
          host?: string(name='Host', description='The name of the service defined in the service registry.', example='reviews'),
          port?: {
            number?: int32(name='Number', description='The ports of the specified hosts to which the traffic is routed.', example='443'),
          }(name='Port', description='The ports.'),
          subset?: string(name='Subset', description='The name of the service subset.', example='v1'),
        }(name='Destination', description='The unique endpoint of the destination service to which the specified requests are sent.'),
        headers?: {
          request?: {
            add?: map[string]any(name='Add', description='The values to be added to the header key.', example='key'),
            remove?: [ string ](name='Remove', description='The header value to be deleted.'),
            set?: map[string]string(name='Set', description='The header key to be used to overwrite the original header key.'),
          }(name='Request', description='The request header to be matched.'),
          response?: {
            add?: map[string]any(name='Add', description='The values to be added to the header key.', example='key'),
            remove?: [ string ](name='Remove', description='The header value to be deleted.'),
            set?: map[string]any(name='Set', description='The header key to be used to overwrite the original header key.', example='key'),
          }(name='Response', description='The processing of the headers of the response that is to be returned.'),
        }(name='Headers', description='The request headers to be matched.'),
        weight?: int32(name='Weight', description='The traffic weight. Valid values: 1 to 100.', example='80'),
      }
    ](name='RouteDestinations', description='The endpoints of destination services for Layer 4 weighted routing.'),
    routeName?: string(name='RouteName', description='The name of the routing rule.', example='demo-route'),
    routeType?: string(name='RouteType', description='The type of the traffic to be routed. Valid values: `HTTP`, `TLS`, and `TCP`.', example='HTTP'),
  }(name='RouteDetail', description='The detailed information about the routing rule.'),
  status?: int32(name='Status', description='The status of the routing rule. Valid values:

*   `0`: The routing rule is valid.
*   `1`: The routing rule is invalid.
*   `2`: An error occurs during the creation or update of the routing rule.', example='1'),
}

model DescribeIstioGatewayRouteDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIstioGatewayRouteDetailResponseBody(name='body'),
}

async function describeIstioGatewayRouteDetailWithOptions(request: DescribeIstioGatewayRouteDetailRequest, runtime: Util.RuntimeOptions): DescribeIstioGatewayRouteDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.routeName)) {
    body['RouteName'] = request.routeName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIstioGatewayRouteDetail',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIstioGatewayRouteDetail(request: DescribeIstioGatewayRouteDetailRequest): DescribeIstioGatewayRouteDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIstioGatewayRouteDetailWithOptions(request, runtime);
}

model DescribeIstioGatewayRoutesRequest {
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
}

model DescribeIstioGatewayRoutesResponseBody = {
  managementRoutes?: [ 
    {
      ASMGatewayName?: string(name='ASMGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
      description?: string(name='Description', description='The description of the routing rule.', example='demo route'),
      destinationHost?: [ string ](name='DestinationHost'),
      destinationSubSet?: [ string ](name='DestinationSubSet'),
      namespace?: string(name='Namespace', description='The namespace.', example='istio-demo'),
      priority?: int32(name='Priority', description='The priority of the routing rule. The value of this parameter is an integer. A smaller value indicates a higher priority.', example='1'),
      routeName?: string(name='RouteName', description='The name of the routing rule.', example='http-route'),
      routePath?: string(name='RoutePath', description='The path that is used to match request URLs.', example='/reviews/v1'),
      status?: int32(name='Status', description='The status of the routing rule. Valid values:

*   `0`: The routing rule is valid.
*   `1`: The routing rule is invalid.
*   `2`: An error occurs during the creation or update of the routing rule.', example='1'),
    }
  ](name='ManagementRoutes', description='The routing rules.'),
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeIstioGatewayRoutesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIstioGatewayRoutesResponseBody(name='body'),
}

async function describeIstioGatewayRoutesWithOptions(request: DescribeIstioGatewayRoutesRequest, runtime: Util.RuntimeOptions): DescribeIstioGatewayRoutesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIstioGatewayRoutes',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIstioGatewayRoutes(request: DescribeIstioGatewayRoutesRequest): DescribeIstioGatewayRoutesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIstioGatewayRoutesWithOptions(request, runtime);
}

model DescribeMetadataResponseBody = {
  metaData?: {
    currentVersion?: string(name='CurrentVersion', description='The current version.', example='v1.14.3.87-g96cf7305-aliyun'),
    proEdition?: {
      currentVersion?: string(name='CurrentVersion', description='The current version.', example='v1.14.3.87-g96cf7305-aliyun'),
      versionCrds?: [  map[string]any ](name='VersionCrds', description='The CRDs of the versions.'),
      versionRegistry?: [  map[string]any ](name='VersionRegistry', description='The ASM version and the corresponding Istio version.'),
      versions?: [ string ](name='Versions', description='The supported versions.'),
    }(name='ProEdition', description='The version information about ASM of a commercial edition.'),
    regions?: [ string ](name='Regions', description='The regions where ASM instances can be created.'),
    versionCrds?: [  map[string]any ](name='VersionCrds', description='The Custom Resource Definitions (CRDs) of the versions.'),
    versionRegistry?: [  map[string]any ](name='VersionRegistry', description='The ASM version and the corresponding Istio version.'),
    versions?: [ string ](name='Versions', description='The supported versions.'),
  }(name='MetaData', description='The metadata of ASM, which contains basic information about ASM.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F93DDAD7-6E04-5AC3-86F4-852708******'),
}

model DescribeMetadataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMetadataResponseBody(name='body'),
}

async function describeMetadataWithOptions(runtime: Util.RuntimeOptions): DescribeMetadataResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeMetadata',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMetadata(): DescribeMetadataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetadataWithOptions(runtime);
}

model DescribeNamespaceScopeSidecarConfigRequest {
  namespace?: string(name='Namespace', description='The namespace.', example='default'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c7120e75a202d4fd8acb028a86b6a****'),
}

model DescribeNamespaceScopeSidecarConfigResponseBody = {
  configPatches?: {
    concurrency?: int32(name='Concurrency', description='The number of worker threads to run in the istio-proxy container.', example='2'),
    enableCoreDump?: boolean(name='EnableCoreDump'),
    excludeInboundPorts?: string(name='ExcludeInboundPorts', description='The inbound ports to be excluded from redirection to the sidecar proxy in the ASM instance.', example='82'),
    excludeOutboundIPRanges?: string(name='ExcludeOutboundIPRanges', description='The outbound IP ranges in CIDR form to be excluded from redirection to the sidecar proxy in the ASM instance.', example='192.168.1.3/31'),
    excludeOutboundPorts?: string(name='ExcludeOutboundPorts', description='The outbound ports to be excluded from redirection to the sidecar proxy in the ASM instance.', example='81'),
    holdApplicationUntilProxyStarts?: boolean(name='HoldApplicationUntilProxyStarts', description='Indicates whether applications can be started only after the istio-proxy container starts. Valid values:

*   `true`
*   false', example='true'),
    includeInboundPorts?: string(name='IncludeInboundPorts', description='The inbound ports for which traffic is to be redirected to the sidecar proxy in the ASM instance.', example='83'),
    includeOutboundIPRanges?: string(name='IncludeOutboundIPRanges', description='The outbound IP ranges in CIDR form for which traffic is to be redirected to the sidecar proxy in the ASM instance.', example='192.168.1.4/31'),
    includeOutboundPorts?: string(name='IncludeOutboundPorts', description='The outbound ports for which traffic is to be redirected to the sidecar proxy in the ASM instance.', example='84'),
    interceptionMode?: string(name='InterceptionMode', description='The mode in which the sidecar proxy intercepts inbound traffic. Valid values:

*   `REDIRECT` (default): In this mode, source IP addresses are lost during traffic redirection to the sidecar proxy.
*   `TPROXY`: In this mode, both the source and destination IP addresses and ports are preserved.'),
    istioDNSProxyEnabled?: boolean(name='IstioDNSProxyEnabled', description='Indicates whether the Domain Name System (DNS) proxy feature is enabled. Valid values:

*   `true`
*   `false`', example='true'),
    lifecycleStr?: string(name='LifecycleStr', description='The JSON string that describes the lifecycle of the sidecar proxy.', example='{"postStart":{"exec":{"command":["pilot-agent","wait"]}},"preStop":{"exec":{"command":["/bin/sh","-c","sleep 15"]}}}'),
    logLevel?: string(name='LogLevel', description='The log level. Valid values: `info`, `debug`, `trace`, and `error`.', example='info'),
    privileged?: boolean(name='Privileged'),
    proxyMetadata?: map[string]string(name='ProxyMetadata'),
    proxyStatsMatcher?: {
      inclusionPrefixes?: [ string ](name='InclusionPrefixes', description='The prefixes of the custom Envoy statistics that are reported by the sidecar proxy.'),
      inclusionRegexps?: [ string ](name='InclusionRegexps', description='The regular expressions for specifying the custom Envoy statistics that are reported by the sidecar proxy.'),
      inclusionSuffixes?: [ string ](name='InclusionSuffixes', description='The suffixes of the custom Envoy statistics that are reported by the sidecar proxy.'),
    }(name='ProxyStatsMatcher', description='The custom Envoy statistics that are reported by the sidecar proxy.'),
    readinessFailureThreshold?: int32(name='ReadinessFailureThreshold'),
    readinessInitialDelaySeconds?: int32(name='ReadinessInitialDelaySeconds'),
    readinessPeriodSeconds?: int32(name='ReadinessPeriodSeconds'),
    sidecarProxyAckSloResource?: {
      limits?: map[string]string(name='Limits'),
      requests?: map[string]string(name='Requests'),
    }(name='SidecarProxyAckSloResource'),
    sidecarProxyInitAckSloResource?: {
      limits?: map[string]string(name='Limits'),
      requests?: map[string]string(name='Requests'),
    }(name='SidecarProxyInitAckSloResource'),
    sidecarProxyInitResourceLimit?: {
      resourceCPULimit?: string(name='ResourceCPULimit', description='The maximum number of CPU cores.', example='2000 m'),
      resourceMemoryLimit?: string(name='ResourceMemoryLimit', description='The maximum size of the memory.', example='50 Mi'),
    }(name='SidecarProxyInitResourceLimit', description='The maximum size of resources that are available to the istio-init container in the pod into which the sidecar proxy is injected. The istio-init container is used in this topic.'),
    sidecarProxyInitResourceRequest?: {
      resourceCPURequest?: string(name='ResourceCPURequest', description='The minimum number of CPU cores.', example='60 m'),
      resourceMemoryRequest?: string(name='ResourceMemoryRequest', description='The minimum size of the memory.', example='30 Mi'),
    }(name='SidecarProxyInitResourceRequest', description='The minimum size of resources that are required by the istio-init container.'),
    sidecarProxyResourceLimit?: {
      resourceCPULimit?: string(name='ResourceCPULimit', description='The maximum number of CPU cores.', example='2000 m'),
      resourceMemoryLimit?: string(name='ResourceMemoryLimit', description='The maximum size of the memory.', example='50 Mi'),
    }(name='SidecarProxyResourceLimit', description='The maximum size of resources that are available to the sidecar proxy container.'),
    sidecarProxyResourceRequest?: {
      resourceCPURequest?: string(name='ResourceCPURequest', description='The minimum number of CPU cores.', example='60 m'),
      resourceMemoryRequest?: string(name='ResourceMemoryRequest', description='The minimum size of the memory.', example='30 Mi'),
    }(name='SidecarProxyResourceRequest', description='The minimum size of resources that are required by the sidecar proxy container.'),
    terminationDrainDuration?: string(name='TerminationDrainDuration', description='The maximum period of time allowed for connections to complete on sidecar proxy shutdown.', example='6s'),
    tracing?: {
      customTags?: map[string]any(name='CustomTags', description='The custom tags added to reported spans. The key of a tag is of the string type. The value of a tag is in the JSON format. A custom tag can belong to one of the following types:

*   `literal`: The tag value is a fixed value in the JSON format. This tag must contain the `value` field that specifies a literal. Example: `{"value":"test"}`.
*   `header`: The tag value is a request header in the JSON format. This tag must contain the `name` field and the `defaultValue` field. The name field indicates the name of the request header. The defaultValue field indicates the default value that is used when no request header is available. Example: `{"name":"test","defaultValue":"test"}`.
*   `environment`: The tag value is an environment variable in the JSON format. This tag must contain the `name` field and the `defaultValue` field. The name field indicates the name of the environment variable. The defaultValue field indicates the environment variable that is used when no environment variable is available. Example: `{"name":"test","defaultValue":"test"}`.'),
      maxPathTagLength?: int32(name='MaxPathTagLength', description='The maximum tag length.'),
      sampling?: double(name='Sampling', description='The sampling rate.'),
    }(name='Tracing', description='The custom configurations of Tracing Analysis.'),
  }(name='ConfigPatches', description='The namespace-level sidecar proxy configurations.'),
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeNamespaceScopeSidecarConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNamespaceScopeSidecarConfigResponseBody(name='body'),
}

async function describeNamespaceScopeSidecarConfigWithOptions(request: DescribeNamespaceScopeSidecarConfigRequest, runtime: Util.RuntimeOptions): DescribeNamespaceScopeSidecarConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNamespaceScopeSidecarConfig',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNamespaceScopeSidecarConfig(request: DescribeNamespaceScopeSidecarConfigRequest): DescribeNamespaceScopeSidecarConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNamespaceScopeSidecarConfigWithOptions(request, runtime);
}

model DescribeNodesInstanceTypeRequest {
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the Alibaba Cloud Service Mesh (ASM) instance.', example='cb8963379255149cb98c8686f274x****'),
}

model DescribeNodesInstanceTypeResponseBody = {
  instanceTypes?: [ 
    {
      key?: string(name='Key', example='feature.node.kubernetes.io/mb-feature-enable'),
      multiBufferEnabled?: boolean(name='MultiBufferEnabled', description='Indicates whether the instance type supports Multi-Buffer acceleration. Valid values:

*   `true`
*   `false`', example='true'),
      nodeType?: string(name='NodeType', description='The instance type of the node.', example='ecs.g7.xlarge'),
      value?: string(name='Value', example='true'),
    }
  ](name='InstanceTypes', description='The instance types of the nodes.'),
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model DescribeNodesInstanceTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNodesInstanceTypeResponseBody(name='body'),
}

async function describeNodesInstanceTypeWithOptions(request: DescribeNodesInstanceTypeRequest, runtime: Util.RuntimeOptions): DescribeNodesInstanceTypeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNodesInstanceType',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNodesInstanceType(request: DescribeNodesInstanceTypeRequest): DescribeNodesInstanceTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNodesInstanceTypeWithOptions(request, runtime);
}

model DescribeReusableSlbRequest {
  k8sClusterId?: string(name='K8sClusterId', description='The ID of the Kubernetes cluster on the data plane.', example='ca2cfe41fefeb489d9b9dba18a7c5****'),
  networkType?: string(name='NetworkType', description='The network type of the SLB instance. Valid values:

*   `intranet`
*   `internet`', example='internet'),
}

model DescribeReusableSlbResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='EDDC0D86-2FC3-56FB-9213-96EB0A3523F1'),
  reusableSlbList?: [ 
    {
      loadBalancerId?: string(name='LoadBalancerId', description='The ID of the SLB instance.', example='lb-bp17xygzsxth0bwlz****'),
      loadBalancerName?: string(name='LoadBalancerName', description='The name of the SLB instance.', example='ad6044b015ac54484a20c47241175bb3'),
    }
  ](name='ReusableSlbList', description='The list of SLB instances that can be reused.'),
}

model DescribeReusableSlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeReusableSlbResponseBody(name='body'),
}

async function describeReusableSlbWithOptions(request: DescribeReusableSlbRequest, runtime: Util.RuntimeOptions): DescribeReusableSlbResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.k8sClusterId)) {
    body['K8sClusterId'] = request.k8sClusterId;
  }
  if (!Util.isUnset(request.networkType)) {
    body['NetworkType'] = request.networkType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeReusableSlb',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeReusableSlb(request: DescribeReusableSlbRequest): DescribeReusableSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReusableSlbWithOptions(request, runtime);
}

model DescribeServiceMeshAdditionalStatusRequest {
  checkMode?: string(name='CheckMode', description='The check mode of the ASM instance. Valid values:

*   `normal`: checks the Server Load Balancer (SLB) instances created for exposing the API server and Istio Pilot, audit logs, and installation of Logtail for clusters on the data plane.
*   `full`: checks control plane logs, access logs, security groups, and the elastic IP addresses (EIPs) of the API server in addition to the check items in normal mode.', example='full'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='ca04bc38979214bf2882be79d39b4****'),
}

model DescribeServiceMeshAdditionalStatusResponseBody = {
  clusterStatus?: {
    accessLogProjectStatus?: string(name='AccessLogProjectStatus', description='Indicates whether access logs exist. Valid values:

*   `exist`: Access logs exist.
*   `not_exist`: Access logs do not exist.
*   `failed`: The check fails.
*   `time_out`: The check times out.', example='exist'),
    apiServerEIPStatus?: string(name='ApiServerEIPStatus', description='The check result of the EIP associated with the API server. Valid values:

*   `exist`: The EIP exists.
*   `not_exist`: The EIP does not exist.
*   `failed`: The check fails.
*   `time_out`: The check times out.
*   `not_in_use`: The EIP is not associated with the API Server.
*   `locked`: The EIP is locked.', example='exist'),
    apiServerLoadBalancerStatus?: {
      locked?: boolean(name='Locked', description='Indicates whether the SLB instance is locked. Valid values:

*   `true`
*   `false`', example='false'),
      payType?: string(name='PayType', description='The billing method of the SLB instance. Valid values:

*   `PrePay`: subscription
*   `PayOnDemand`: pay-as-you-go', example='PrePay'),
      reused?: boolean(name='Reused', description='Indicates whether the SLB instance is reused. Valid values:

*   `true`
*   `false`', example='false'),
      SLBBackEndServerNumStatus?: string(name='SLBBackEndServerNumStatus', description='The check result of the number of backend servers of the SLB instance created for exposing the API server. Valid values:

*   `too_much`: An excessive number of backend servers are created.
*   `num_exact`: A proper number of backend servers are created.
*   `too_little`: The number of backend servers falls short.', example='num_exact'),
      SLBExistStatus?: string(name='SLBExistStatus', description='The check result of the SLB instance. Valid values:

*   `exist`: The SLB instance exists.
*   `not_exist`: The SLB instance does not exist.
*   `conflict`: Conflicts are detected.
*   `failed`: The check fails.
*   `time_out`: The check times out.', example='exist'),
    }(name='ApiServerLoadBalancerStatus', description='The check results of the SLB instance created for exposing the API server.'),
    auditProjectStatus?: string(name='AuditProjectStatus', description='Indicates whether audit logs exist. Valid values:

*   `exist`
*   `not exist`', example='exist'),
    canaryPilotLoadBalancerStatus?: {
      locked?: boolean(name='Locked', description='Indicates whether the SLB instance is locked due to overdue payments. Valid values: `true` `false`', example='false'),
      payType?: string(name='PayType', example='PayOnDemand'),
      reused?: boolean(name='Reused', description='Indicates whether the SLB instance is reused. Valid values:

*   `true`: The SLB instance is reused. Non-ASM listener configuration is detected in the listener configurations of the SLB instance.
*   `false`: The SLB instance is not reused.', example='false'),
      SLBBackEndServerNumStatus?: string(name='SLBBackEndServerNumStatus', description='The check result of the number of backend servers of the SLB instance created for exposing Istio Pilot. Valid values:

*   `num_exact`: A proper number of backend servers are created.
*   `too_much`: An excessive number of backend servers are created.
*   `too_little`: The number of backend servers falls short.', example='num_exact'),
      SLBExistStatus?: string(name='SLBExistStatus', description='The check result of the SLB instance. Valid values:

*   `exist`: The SLB instance exists.
*   `not_exist`: The SLB instance does not exist.
*   `time_out`: The check times out.
*   `failed`: The SLB instance has expired.', example='exist'),
    }(name='CanaryPilotLoadBalancerStatus', description='The check results of the SLB instance that is created for exposing Istio Pilot and used during canary release.'),
    controlPlaneProjectStatus?: string(name='ControlPlaneProjectStatus', description='Indicates whether control plane logs exist. Valid values:

*   `exist`: Control plane logs exist.
*   `not_exist`: Control plane logs do not exist.
*   `failed`: The check fails.
*   `time_out`: The check times out.', example='exist'),
    logtailStatusRecord?: map[string]any(name='LogtailStatusRecord', description='Indicates whether Logtail is installed in clusters on the data plane.', example='{   "ca35eae22013e43758a0e26d04****":{     "accessLogDashboards":[       {         "title":"mesh-access-log_details_cn",         "url":"https://sls.console.aliyun.com/lognext/project/****/dashboard/mesh-access-log_details_cn"       },       {         "title":"mesh-access-log_monitoring_center_cn",         "url":"https://sls.console.aliyun.com/lognext/project/****/dashboard/mesh-access-log_monitoring_center_cn"       }     ],     "logtailStatus":"exist",     "clusterId":"ca35eae22013e43758a0e26d04****"   } }'),
    pilotLoadBalancerStatus?: {
      locked?: boolean(name='Locked', description='Indicates whether the SLB instance is locked. Valid values:

*   `true`
*   `false`', example='false'),
      payType?: string(name='PayType', description='The billing method of the SLB instance. Valid values:

*   `PrePay`: subscription
*   `PayOnDemand`: pay-as-you-go', example='PayOnDemand'),
      reused?: boolean(name='Reused', description='Indicates whether the SLB instance is reused. Valid values:

*   `true`
*   `false`', example='true'),
      SLBBackEndServerNumStatus?: string(name='SLBBackEndServerNumStatus', description='The check result of the number of backend servers of the SLB instance created for exposing Istio Pilot. Valid values:

*   `too_much`: An excessive number of backend servers are created.
*   `num_exact`: A proper number of backend servers are created.
*   `too_little`: The number of backend servers falls short.', example='num_exact'),
      SLBExistStatus?: string(name='SLBExistStatus', description='The check result of the SLB instance. Valid values:

*   `exist`: The SLB instance exists.
*   `not_exist`: The SLB instance does not exist.
*   `conflict`: Conflicts are detected.
*   `failed`: The check fails.
*   `time_out`: The check times out.', example='exist'),
    }(name='PilotLoadBalancerStatus', description='The check results of the SLB instance created for exposing Istio Pilot.'),
    RAMApplicationStatus?: string(name='RAMApplicationStatus', description='The status of the RAM OAuth application that is integrated with Mesh Topology. Valid values:

*   `exist`: The RAM OAuth application exists.
*   `reused`: The RAM OAuth application is reused.
*   `not_exist`: The RAM OAuth application does not exist.
*   `failed`: The check fails.
*   `time_out`: The check times out.', example='reused'),
    sgStatus?: string(name='SgStatus', description='Indicates whether the security group is reused. Valid values:

*   `reused`: The security group is reused.
*   `not_reused`: The security group is not reused.
*   `failed`: The check fails.
*   `time_out`: The check times out.', example='reused'),
  }(name='ClusterStatus', description='The status of the cluster.'),
  requestId?: string(name='RequestId', description='The request ID.', example='11fd0027-c27e-41bb-a565-75583054****'),
}

model DescribeServiceMeshAdditionalStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshAdditionalStatusResponseBody(name='body'),
}

async function describeServiceMeshAdditionalStatusWithOptions(request: DescribeServiceMeshAdditionalStatusRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshAdditionalStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkMode)) {
    body['CheckMode'] = request.checkMode;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshAdditionalStatus',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMeshAdditionalStatus(request: DescribeServiceMeshAdditionalStatusRequest): DescribeServiceMeshAdditionalStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshAdditionalStatusWithOptions(request, runtime);
}

model DescribeServiceMeshClustersRequest {
  limit?: long(name='Limit', description='The maximum number of clusters in a cluster list.', example='30'),
  offset?: long(name='Offset', description='The position where the query starts.', example='20'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='cb8963379255149cb98c8686f274x****'),
}

model DescribeServiceMeshClustersResponseBody = {
  clusters?: [ 
    {
      clusterDomain?: string(name='ClusterDomain', description='The domain name of the cluster.', example='c.com'),
      clusterId?: string(name='ClusterId', description='The cluster ID.', example='c80f45444b3da447da60a911390c2****'),
      clusterType?: string(name='ClusterType', description='The cluster type.', example='Ask'),
      creationTime?: string(name='CreationTime', description='The time when the cluster was created.', example='2020-05-12T15:38:16+08:00'),
      errorMessage?: string(name='ErrorMessage', description='The error message about the cluster.', example='fail'),
      forbiddenFlag?: long(name='ForbiddenFlag', description='Indicates that the cluster is available or the reason why the cluster cannot be added to the ASM instance. Valid values:

*   `0`: The cluster can be added to the ASM instance.
*   `1`: The cluster cannot be added to the ASM instance because you do not have administrator permissions on the cluster.
*   `2`: The cluster cannot be added to the ASM instance because the cluster and the ASM instance reside in different VPCs between which no private connections are built.
*   `3`: The CIDR block of the cluster conflicts with that of the ASM instance.
*   `4`: The cluster has a namespace that is named istio system.', example='0'),
      forbiddenInfo?: string(name='ForbiddenInfo', example='[{"cluster":"cdd55bd6e054b4c6ca18ec02614******", "object":"Pod", "cidr":"172.16.0.0/24"},{"cluster":"cfa37fdf7cb1641e1976f8293ac******", "object":"Pod", "cidr":"172.16.0.0/24"}]'),
      name?: string(name='Name', description='The name of the cluster.', example='ask1'),
      regionId?: string(name='RegionId', description='The ID of the region in which the cluster resides.', example='cn-hangzhou'),
      serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='cb8963379255149cb98c8686f274x****'),
      sgId?: string(name='SgId', description='The ID of the security group.', example='sg-bp197668l6iupljy****'),
      state?: string(name='State', description='The state of the cluster. Valid values:

*   `running`: The cluster is running.
*   `starting`: The cluster is starting.
*   `stopping`: The cluster is being stopped.
*   `stopped`: The cluster is stopped.
*   `failed`: The cluster fails to be run.', example='running'),
      updateTime?: string(name='UpdateTime', description='The time when the cluster was last modified.', example='2020-05-12T15:38:16+08:00'),
      version?: string(name='Version', description='The version number of the cluster.', example='v1.16.6-aliyun.1'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-8vbrwmt95b4zf6wf7****'),
    }
  ](name='Clusters', description='The queried clusters.'),
  numberOfClusters?: long(name='NumberOfClusters', example='5'),
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeServiceMeshClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshClustersResponseBody(name='body'),
}

async function describeServiceMeshClustersWithOptions(request: DescribeServiceMeshClustersRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshClustersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.offset)) {
    body['Offset'] = request.offset;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshClusters',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMeshClusters(request: DescribeServiceMeshClustersRequest): DescribeServiceMeshClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshClustersWithOptions(request, runtime);
}

model DescribeServiceMeshDetailRequest {
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
}

model DescribeServiceMeshDetailResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='11fd0027-c27e-41bb-a565-75583054****'),
  serviceMesh?: {
    clusterSpec?: string(name='ClusterSpec', description='The specification of the ASM instance. Valid values:

- `standard`: Standard Edition
- `enterprise`: Enterprise Edition
- `ultimate`: Ultimate Edition', example='standard'),
    clusters?: [ string ](name='Clusters', description='The list of clusters.'),
    endpoints?: {
      intranetApiServerEndpoint?: string(name='IntranetApiServerEndpoint', description='The endpoint that is used to access the API server from the internal network.', example='https://192.168.**.**:6443'),
      intranetPilotEndpoint?: string(name='IntranetPilotEndpoint', description='The endpoint that is used to access Istio Pilot from the internal network.', example='192.168.**.**:15011'),
      publicApiServerEndpoint?: string(name='PublicApiServerEndpoint', description='The endpoint that is used to expose the API server to the Internet.', example='https://123.56.**.**:6443'),
      publicPilotEndpoint?: string(name='PublicPilotEndpoint', description='The endpoint that is used to expose Istio Pilot to the Internet.', example='182.92.**.**:15011'),
    }(name='Endpoints', description='The endpoints of the ASM instance.'),
    ownerId?: string(name='OwnerId', description='The ID of the Alibaba Cloud service instance for which the ASM instance is created.', example='cc3e96f249d124eb38b72718ec5*****'),
    ownerType?: string(name='OwnerType', description='The Alibaba Cloud service for which the ASM instance is created. Valid values:

- `ackone`: The ASM instance is created for Alibaba Cloud Distributed Cloud Container Platform (ACK One).
- An empty value indicates that the ASM instance is created by the user.', example='ackone'),
    serviceMeshInfo?: {
      creationTime?: string(name='CreationTime', description='The time when the ASM instance was created.', example='2020-04-21T09:42:20+08:00'),
      errorMessage?: string(name='ErrorMessage', description='The error message that is returned when the call failed.', example='error'),
      name?: string(name='Name', description='The name of the ASM instance.', example='mesh1'),
      profile?: string(name='Profile', description='The edition of the ASM instance. Valid values:

*   `Default`: Standard Edition
*   `Pro`: Professional Edition', example='Default'),
      regionId?: string(name='RegionId', description='The ID of the region in which the ASM instance resides.', example='cn-beijing'),
      serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
      state?: string(name='State', description='The status of the ASM instance.', example='running'),
      updateTime?: string(name='UpdateTime', description='The time when the ASM instance was last modified.', example='2020-06-03T14:48:54+08:00'),
      version?: string(name='Version', description='The version of the ASM instance.', example='v1.7.4.0-gfb34ba99-aliyun'),
    }(name='ServiceMeshInfo', description='The basic information about the ASM instance.'),
    spec?: {
      loadBalancer?: {
        apiServerLoadbalancerId?: string(name='ApiServerLoadbalancerId', description='The ID of the SLB instance that is used when the API server is exposed to the Internet.', example='lb-2zekaak10uxds44vx****'),
        apiServerPublicEip?: boolean(name='ApiServerPublicEip', description='Indicates whether the API server is exposed to the Internet. Valid values:

*   `true`: The API server is exposed to the Internet.
*   `false`: The API server is not exposed to the Internet.', example='true'),
        pilotPublicEip?: boolean(name='PilotPublicEip', description='Indicates whether Istio Pilot is exposed to the Internet. Valid values:

*   `true`: Istio Pilot is exposed to the Internet.
*   `false`: Istio Pilot is not exposed to the Internet.', example='true'),
        pilotPublicLoadbalancerId?: string(name='PilotPublicLoadbalancerId', description='The ID of the Server Load Balancer (SLB) instance that is used when Istio Pilot is exposed to the Internet.', example='lb-2zesa8qs8kbkj9jkl****'),
      }(name='LoadBalancer', description='The information about load balancing.'),
      meshConfig?: {
        accessLog?: {
          enabled?: boolean(name='Enabled', description='Indicates whether access log collection is enabled. Valid values:

*   `true`: Access log collection is enabled.
*   `false`: Access log collection is disabled.', example='true'),
          project?: string(name='Project', description='The name of the Log Service project that stores access logs.', example='k8s-log-b7b05d08670e41ca8c8fc0b7718f*****'),
        }(name='AccessLog', description='The configurations of access log collection.'),
        audit?: {
          auditProjectStatus?: string(name='AuditProjectStatus', description='Indicates whether an audit project exists in the ASM instance. Valid values:

*   `audit_project_exist`: An audit project exists.
*   `audit_project_not_exist`: No audit project exists.', example='audit_project_not_exist'),
          enabled?: boolean(name='Enabled', description='Indicates whether mesh audit is enabled. Valid values:

*   `true`: Mesh audit is enabled.
*   `false`: Mesh audit is disabled.', example='true'),
          project?: string(name='Project', description='The name of the Log Service project that is used for mesh audit.', example='audit-project'),
        }(name='Audit', description='The information about mesh audit.'),
        controlPlaneLogInfo?: {
          enabled?: boolean(name='Enabled', description='Indicates whether the collection of control-plane logs is enabled. Valid values:

*   `true`: The collection of control-plane logs is enabled.
*   `false`: The collection of control-plane logs is disabled.', example='false'),
          logTTL?: int32(name='LogTTL'),
          project?: string(name='Project', description='The name of the Log Service project that stores control-plane logs.', example='mesh-log-cbeb85a09161b4a26ab73e0ac****'),
        }(name='ControlPlaneLogInfo', description='The configurations of control-plane log collection.'),
        customizedZipkin?: boolean(name='CustomizedZipkin', description='Indicates whether a custom Zipkin system is used. Valid values:

*   `true`: A custom Zipkin system is used.
*   `false`: No custom Zipkin system is used.', example='false'),
        edition?: {
          istiodImageTag?: string(name='IstiodImageTag', description='The version of the Istiod image.', example='v1.9.7.1-3-gb3f1ab3c9c-pro-aliyun'),
          name?: string(name='Name', description='The name of the edition.', example='Pro'),
          proxyImageTag?: string(name='ProxyImageTag', description='The version of the Istio Proxy image.', example='v1.9.7.1-3-gb3f1ab3c9c-pro-aliyun'),
        }(name='Edition', description='The information about the edition.'),
        enableLocalityLB?: boolean(name='EnableLocalityLB', description='Indicates whether the feature that routes traffic to the nearest instance is enabled. Valid values:

*   `true`: The feature is enabled.
*   `false`: The feature is disabled.', example='true'),
        excludeIPRanges?: string(name='ExcludeIPRanges', description='The IP ranges in CIDR form to be excluded from redirection to sidecar proxies in the ASM instance.', example='172.16.0.0'),
        excludeInboundPorts?: string(name='ExcludeInboundPorts', description='The inbound ports to be excluded from redirection to sidecar proxies in the ASM instance.', example='80,81'),
        excludeOutboundPorts?: string(name='ExcludeOutboundPorts', description='The outbound ports to be excluded from redirection to sidecar proxies in the ASM instance.', example='80,81'),
        extraConfiguration?: {
          accessLogExtraConf?: {
            gatewayEnabled?: boolean(name='GatewayEnabled'),
            gatewayLifecycle?: int32(name='GatewayLifecycle', description='The retention period for the access logs of the ingress gateway. Unit: day. The logs are collected by using the Log Service. For example, a value of 30 indicates that the logs are retained for 30 days.', example='30'),
            sidecarEnabled?: boolean(name='SidecarEnabled'),
            sidecarLifecycle?: int32(name='SidecarLifecycle', description='The retention period for the access logs of sidecar proxies. Unit: day. The logs are collected by using the Log Service. For example, a value of 30 indicates that the logs are retained for 30 days.', example='30'),
          }(name='AccessLogExtraConf', description='The configurations of additional features for access log collection'),
          adaptiveXdsConfiguration?: {
            egressAutoscaleEnabled?: boolean(name='EgressAutoscaleEnabled', description='Indicates whether Horizontal Pod Autoscaling (HPA) is enabled for the egress gateway.', example='true'),
            egressHpaCpu?: {
              targetAverageUtilization?: int32(name='TargetAverageUtilization', description='The expected CPU utilization when HPA is enabled. Valid values: 1 to 100. If the CPU utilization exceeds this value, the number of pod replicas increases. If the CPU utilization is less than this value, the number of pod replicas decreases.', example='80'),
            }(name='EgressHpaCpu', description='The CPU resource configurations of the egress gateway when HPA is enabled.'),
            egressHpaMemory?: {
              targetAverageUtilization?: int32(name='TargetAverageUtilization', description='The expected memory usage when HPA is enabled. Valid values: 1 to 100. If the memory usage exceeds this value, the number of pod replicas increases. If the memory usage is less than this value, the number of pod replicas decreases.', example='80'),
            }(name='EgressHpaMemory', description='The memory resource configurations of the egress gateway when HPA is enabled.'),
            egressMaxReplica?: int32(name='EgressMaxReplica', description='The maximum number of egress gateway pod replicas when HPA is enabled.', example='2'),
            egressMinReplica?: int32(name='EgressMinReplica', description='The minimum number of egress gateway pod replicas when HPA is enabled.', example='1'),
            egressReplicaCount?: int32(name='EgressReplicaCount', description='The number of the egress gateway pod replicas.', example='2'),
            egressResources?: {
              limits?: map[string]any(name='Limits', description='The resources that are available to the egress gateway.', example='{"cpu":"200m", "memory": "512Mi"}'),
              requests?: map[string]any(name='Requests', description='The resources that are requested by the egress gateway.', example='{"cpu":"100m", "memory": "256Mi"}'),
            }(name='EgressResources', description='The resource configurations of the egress gateway that is used by adaptive xDS optimization.'),
            enabled?: boolean(name='Enabled', description='Indicates whether adaptive xDS optimization is enabled.', example='true'),
          }(name='AdaptiveXdsConfiguration', description='The configurations of adaptive xDS optimization.'),
          autoDiagnosis?: {
            autoDiagnosisEnabled?: boolean(name='AutoDiagnosisEnabled', description='Indicates whether automatic diagnosis is enabled for the ASM instance. If you enable this feature, the ASM instance is automatically diagnosed five minutes after you modify an Istio resource.', example='true'),
          }(name='AutoDiagnosis', description='The configurations of automatic diagnosis for the ASM instance.'),
          CRAggregationConfiguration?: {
            enabled?: boolean(name='Enabled', description='Indicates whether Istio resources can be accessed by using the Kubernetes API on the data plane.', example='true'),
          }(name='CRAggregationConfiguration', description='Access to Istio resources by using the Kubernetes API on the data plane.'),
          CRAggregationEnabled?: boolean(name='CRAggregationEnabled', description='Indicates whether the Kubernetes API of clusters on the data plane can be used to access Istio resources. Valid values:

*   `true`: The Kubernetes API of clusters on the data plane can be used to access Istio resources.
*   `false`: The Kubernetes API of clusters on the data plane cannot be used to access Istio resources.', example='false'),
          discoverySelectors?: [  map[string]any ](name='DiscoverySelectors', description='The label selectors used to specify namespaces on the data plane. The control plane discovers and process only application services in the specified namespaces.'),
          istioCRHistory?: {
            enableHistory?: boolean(name='EnableHistory', description='Indicates whether the rollback feature for Istio resources is enabled. Valid values:

*   `true`: The rollback feature for Istio resources is enabled.
*   `false`: The rollback feature for Istio resources is disabled.', example='false'),
          }(name='IstioCRHistory', description='The configurations of the rollback feature for Istio resources.'),
          lifecycle?: {
            postStart?: {
              exec?: {
                command?: [ string ](name='command', description='The executed command.'),
              }(name='exec', description='The post-start script.'),
              httpGet?: {
                host?: string(name='host', description='The URL of the request.', example='127.xx.xx.1'),
                httpHeaders?: [ 
                  {
                    name?: string(name='name', description='The name of the HTTP request header.', example='key'),
                    value?: string(name='value', description='The value of the HTTP request header field.', example='value'),
                  }
                ](name='httpHeaders', description='The HTTP request headers.'),
                port?: string(name='port', description='The port number of the request.', example='80'),
                scheme?: string(name='scheme', description='The request method. Valid values: `http` and `https`.', example='http'),
              }(name='httpGet', description='The HTTP GET request that is sent before the instance stops.'),
              tcpSocket?: {
                host?: string(name='host', description='The URL of the TCP socket request.', example='127.xx.xx.1'),
                port?: string(name='port', description='The port number of the TCP socket request.', example='888'),
              }(name='tcpSocket', description='The TCP socket request that is sent.'),
            }(name='postStart', description='The post-start parameters.'),
            preStop?: {
              exec?: {
                command?: [ string ](name='command', description='The executed command.'),
              }(name='exec', description='The pre-close script.'),
              httpGet?: {
                host?: string(name='host', description='The URL of the request.', example='127.xx.xx.1'),
                httpHeaders?: [ 
                  {
                    name?: string(name='name', description='The name of the HTTP request header.', example='key'),
                    value?: string(name='value', description='The value of the HTTP request header field.', example='value'),
                  }
                ](name='httpHeaders', description='The HTTP request headers.'),
                port?: string(name='port', description='The port number of the request.', example='80'),
                scheme?: string(name='scheme', description='The request method. Valid values: `http` and `https`.', example='http'),
              }(name='httpGet', description='The HTTP GET request that is sent before the instance stops.'),
              tcpSocket?: {
                host?: string(name='host', description='The URL of the request.', example='127.xx.xx.1'),
                port?: string(name='port', description='The port number of the request.', example='888'),
              }(name='tcpSocket', description='The TCP socket request that is sent.'),
            }(name='preStop', description='The pre-close parameters.'),
          }(name='Lifecycle', description='The lifecycle of Istio Proxy.'),
          multiBuffer?: {
            enabled?: boolean(name='Enabled', description='Indicates whether MulitiBuffer-based TLS acceleration is enabled. Valid values:

*   `true`: MulitiBuffer-based TLS acceleration is enabled.
*   `false`: MulitiBuffer-based TLS acceleration is disabled.', example='false'),
            pollDelay?: string(name='PollDelay', description='The pull-request latency.', example='0.02s'),
          }(name='MultiBuffer', description='The information about Transport Layer Security (TLS) acceleration based on MulitiBuffer.'),
          NFDConfiguration?: {
            enabled?: boolean(name='Enabled', description='Indicates whether NFD is enabled.', example='true'),
            NFDLabelPruned?: boolean(name='NFDLabelPruned', description='Indicates whether feature labels on nodes are cleared when NFD is disabled.', example='true'),
          }(name='NFDConfiguration', description='The configurations of Node Feature Discovery (NFD).'),
          OPAScopeInjection?: {
            OPAScopeInjected?: boolean(name='OPAScopeInjected', description='Indicates whether the feature of controlling the OPA injection scope is enabled. Valid values:

*   `true`: The feature is enabled.
*   `false`: The feature is disabled.', example='false'),
          }(name='OPAScopeInjection', description='The configurations of the feature of controlling the OPA injection scope.'),
          sidecarProxyInitResourceLimit?: {
            resourceCPULimit?: string(name='ResourceCPULimit', description='The maximum number of CPU cores that are available to the istio-init container.', example='2000m'),
            resourceMemoryLimit?: string(name='ResourceMemoryLimit', description='The maximum size of the memory that is available to the istio-init container.', example='1024Mi'),
          }(name='SidecarProxyInitResourceLimit', description='The resource limits on the istio-init container.'),
          sidecarProxyInitResourceRequest?: {
            resourceCPURequest?: string(name='ResourceCPURequest', description='The number of CPU cores that are requested by the istio-init container.', example='10m'),
            resourceMemoryRequest?: string(name='ResourceMemoryRequest', description='The size of the memory that is requested by the istio-init container.', example='10Mi'),
          }(name='SidecarProxyInitResourceRequest', description='The resources that are requested by the istio-init container.'),
          terminationDrainDuration?: string(name='TerminationDrainDuration', description='The maximum period of time that Istio Proxy waits for a request to end.', example='5s'),
        }(name='ExtraConfiguration', description='The configurations of additional features for the ASM instance.'),
        includeIPRanges?: string(name='IncludeIPRanges', description='The IP ranges in CIDR form to redirect to the sidecar proxies in the ASM instance.', example='192.168.0.0/16'),
        k8sNewAPIsSupport?: {
          gatewayAPIEnabled?: boolean(name='GatewayAPIEnabled', description='Indicates whether Gateway API is enabled. Valid values:

*   `true`: Gateway API is enabled.
*   `false`: Gateway API is disabled.', example='false'),
        }(name='K8sNewAPIsSupport', description='The information about the Kubernetes API.'),
        kiali?: {
          enabled?: boolean(name='Enabled', description='Indicates whether mesh topology is enabled. Mesh topology can be enabled only when Prometheus monitoring is enabled. If Prometheus monitoring is disabled, you must set this parameter to `false`. Valid values:

*   `true`: Mesh topology is enabled.
*   `false`: Mesh topology is disabled.', example='false'),
          url?: string(name='Url', description='The endpoint of the mesh topology service.', example='http://1.2.**.**:20001'),
        }(name='Kiali', description='The configurations of mesh topology.'),
        localityLB?: {
          distribute?: map[string]any(name='Distribute', description='The configurations of cross-region traffic distribution.

>  Only one of `Failover` and Distribute parameters can be set. If you set the `Distribute` parameter, you cannot set the Failover parameter.', example='[{"from":"cn-shanghai","to":{"cn-hangzhou/*":50,"cn-shanghai/*":25,"cn-zhangjiakou/*":25}},{"from":"cn-hangzhou","to":{"cn-hangzhou/*":50,"cn-shanghai/*":25,"cn-zhangjiakou/*":25}}]'),
          enabled?: boolean(name='Enabled', description='Indicates whether cross-region load balancing is enabled. Valid values:

*   `true`: Cross-region load balancing is enabled.
*   `false`: Cross-region load balancing is disabled.', example='false'),
          failover?: map[string]any(name='Failover', description='The configurations of cross-region failover.

>  Only one of Failover and `Distribute` parameters can be set. If you set the `Failover` parameter, you cannot set the `Distribute` parameter.', example='{"failover":[{"from":"cn-hangzhou","to":"cn-shanghai"}]}'),
        }(name='LocalityLB', description='The configurations of cross-region load balancing.'),
        MSE?: {
          enabled?: boolean(name='Enabled', description='Indicates whether MSE is enabled. Valid values:

- `true`: MSE is enabled.
- `false`: MSE is disabled.', example='false'),
        }(name='MSE', description='The configurations of Microservices Engine (MSE).'),
        OPA?: {
          enabled?: boolean(name='Enabled', description='Indicates whether the OPA plug-in is installed. Valid values:

*   `true`: The OPA plug-in is installed.
*   `false`: The OPA plug-in is not installed.', example='true'),
          limitCPU?: string(name='LimitCPU', description='The maximum number of CPU cores that are available to the OPA proxy container.', example='1'),
          limitMemory?: string(name='LimitMemory', description='The maximum size of the memory that is available to the OPA proxy container.', example='512Mi'),
          logLevel?: string(name='LogLevel', description='The level of the logs to be generated for OPA.', example='info'),
          requestCPU?: string(name='RequestCPU', description='The number of CPU cores that are requested by the OPA proxy container.', example='2'),
          requestMemory?: string(name='RequestMemory', description='The size of the memory that is requested by the OPA proxy container.', example='1024Mi'),
        }(name='OPA', description='The information about the Open Policy Agent (OPA) plug-in.'),
        outboundTrafficPolicy?: string(name='OutboundTrafficPolicy', description='The outbound traffic policy. Valid values:

*   `ALLOW_ANY`: Outbound traffic to all external services is allowed.
*   `REGISTRY_ONLY`: Outbound traffic is allowed to only external services that are defined in the service registry of the ASM instance.', example='ALLOW_ANY'),
        pilot?: {
          configSource?: {
            enabled?: boolean(name='Enabled', description='Indicates whether communication is allowed between external services and services in the mesh. Valid values:

*   `true`: The communication is allowed.
*   `false`: The communication is not allowed.', example='false'),
            nacosID?: string(name='NacosID', description='The ID of the Nacos instance that provides external service information.', example='mse-cn-tl326******'),
          }(name='ConfigSource', description='The configurations of communication between external services and services in the mesh.'),
          feature?: {
            enableSDSServer?: boolean(name='EnableSDSServer', description='Indicates whether Secret Discovery Service (SDS) is enabled. Valid values:

*   `true`: SDS is enabled.
*   `false`: SDS is disabled.', example='false'),
            filterGatewayClusterConfig?: boolean(name='FilterGatewayClusterConfig', description='Indicates whether gateway configuration filtering is enabled. Valid values:

*   `true`: Gateway configuration filtering is enabled.
*   `false`: Gateway configuration filtering is disabled.', example='false'),
          }(name='Feature', description='The configurations of Pilot features.'),
          http10Enabled?: boolean(name='Http10Enabled', description='Indicates whether HTTP/1.0 is supported. Valid values:

*   `true`: HTTP/1.0 is supported.
*   `false`: HTTP/1.0 is not supported.', example='false'),
          traceSampling?: float(name='TraceSampling', description='The sampling percentage of tracing analysis.', example='100'),
        }(name='Pilot', description='The Pilot configurations.'),
        prometheus?: {
          externalUrl?: string(name='ExternalUrl', description='The endpoint of Prometheus monitoring. If you use a custom Prometheus instance, this parameter is populated by the system.', example='http://prometheus:9090'),
          useExternal?: boolean(name='UseExternal', description='Indicates whether a custom Prometheus instance is used. Valid values:

*   `true`: A custom Prometheus instance is used.
*   `false`: No custom Prometheus instance is used.', example='false'),
        }(name='Prometheus', description='The configurations of Prometheus monitoring.'),
        protocolSupport?: {
          dubboFilterEnabled?: boolean(name='DubboFilterEnabled', description='Indicates whether Dubbo Filter is enabled. Valid values:

*   `true`: Dubbo Filter is enabled.
*   `false`: Dubbo Filter is disabled.', example='false'),
          mysqlFilterEnabled?: boolean(name='MysqlFilterEnabled', description='Indicates whether MySQL Filter is enabled. Valid values:

*   `true`: MySQL Filter is enabled.
*   `false`: MySQL Filter is disabled.', example='false'),
          redisFilterEnabled?: boolean(name='RedisFilterEnabled', description='Indicates whether Redis Filter is enabled. Valid values:

*   `true`: Redis Filter is enabled.
*   `false`: Redis Filter is disabled.', example='false'),
          thriftFilterEnabled?: boolean(name='ThriftFilterEnabled', description='Indicates whether Thrift Filter is enabled. Valid values:

*   `true`: Thrift Filter is enabled.
*   `false`: Thrift Filter is disabled.', example='false'),
        }(name='ProtocolSupport', description='The configurations of protocol support.'),
        proxy?: {
          accessLogFile?: string(name='AccessLogFile', description='The path to the file that stores the access logs of sidecar proxies.', example='/dev/stdout'),
          accessLogFormat?: string(name='AccessLogFormat', description='The format of the access logs of sidecar proxies.', example='{"authority_for":"%REQ(:AUTHORITY)%","bytes_received":"%BYTES_RECEIVED%","bytes_sent":"%BYTES_SENT%","downstream_local_address":"%DOWNSTREAM_LOCAL_ADDRESS%","downstream_remote_address":"%DOWNSTREAM_REMOTE_ADDRESS%","duration":"%DURATION%","istio_policy_status":"%DYNAMIC_METADATA(istio.mixer:status)%","method":"%REQ(:METHOD)%","path":"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%","protocol":"%PROTOCOL%","request_id":"%REQ(X-REQUEST-ID)%","requested_server_name":"%REQUESTED_SERVER_NAME%","response_code":"%RESPONSE_CODE%","response_flags":"%RESPONSE_FLAGS%","route_name":"%ROUTE_NAME%","start_time":"%START_TIME%","trace_id":"%REQ(X-B3-TRACEID)%","upstream_cluster":"%UPSTREAM_CLUSTER%","upstream_host":"%UPSTREAM_HOST%","upstream_local_address":"%UPSTREAM_LOCAL_ADDRESS%","upstream_service_time":"%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)%","upstream_transport_failure_reason":"%UPSTREAM_TRANSPORT_FAILURE_REASON%","user_agent":"%REQ(USER-AGENT)%","x_forwarded_for":"%REQ(X-FORWARDED-FOR)%"}'),
          accessLogServiceEnabled?: boolean(name='AccessLogServiceEnabled', description='Indicates whether gRPC Access Log Service (ALS) for Envoy is enabled. Valid values:

*   `true`: gRPC ALS for Envoy is enabled.
*   `false`: gRPC ALS for Envoy is disabled.', example='false'),
          accessLogServiceHost?: string(name='AccessLogServiceHost', description='The endpoint of gRPC ALS for Envoy.', example='0.0.0.0'),
          accessLogServicePort?: int32(name='AccessLogServicePort', description='The port of gRPC ALS for Envoy.', example='9999'),
          clusterDomain?: string(name='ClusterDomain', description='The trusted domain.', example='cluster.domain'),
          enableDNSProxying?: boolean(name='EnableDNSProxying', description='Indicates whether the Domain Name System (DNS) proxy feature is enabled. Valid values: Valid values:

*   `true`: The DNS proxy feature is enabled.
*   `false`: The DNS proxy feature is disabled.', example='false'),
          limitCPU?: string(name='LimitCPU', description='The maximum number of CPU cores.', example='2000m'),
          limitMemory?: string(name='LimitMemory', description='The maximum size of the memory.', example='1024Mi'),
          requestCPU?: string(name='RequestCPU', description='The number of CPU cores that are requested.', example='100m'),
          requestMemory?: string(name='RequestMemory', description='The size of the memory that is requested.', example='128Mi'),
        }(name='Proxy', description='The proxy configurations.'),
        sidecarInjector?: {
          autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled', description='Indicates whether automatic sidecar injection can be enabled by using pod annotations. Valid values:

*   `true`: Automatic sidecar injection can be enabled by using pod annotations.
*   `false`: Automatic sidecar injection cannot be enabled by using pod annotations.', example='true'),
          enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault', description='Indicates whether automatic sidecar injection is enabled for all namespaces. Valid values:

*   `true`: Automatic sidecar injection is enabled for all namespaces.
*   `false`: Automatic sidecar injection is not enabled for all namespaces.', example='false'),
          initCNIConfiguration?: {
            enabled?: boolean(name='Enabled', description='Indicates whether the CNI plug-in is enabled. Valid values:

*   `true`: The CNI plug-in is enabled.
*   `false`: The CNI plug-in is disabled.', example='false'),
            excludeNamespaces?: string(name='ExcludeNamespaces', description='The namespaces to exclude. The CNI plug-in ignores pods in the excluded namespaces.', example='kube-system,istio-system'),
          }(name='InitCNIConfiguration', description='The configurations of Container Network Interface (CNI).'),
          limitCPU?: string(name='LimitCPU', description='The maximum number of CPU cores that are available to the sidecar injector pod.', example='4000m'),
          limitMemory?: string(name='LimitMemory', description='The maximum size of the memory that is available to the sidecar injector pod.', example='2048Mi'),
          requestCPU?: string(name='RequestCPU', description='The number of CPU cores that are requested by the sidecar injector pod.', example='1000m'),
          requestMemory?: string(name='RequestMemory', description='The size of the memory that is requested by the sidecar injector pod.', example='512Mi'),
          sidecarInjectorNum?: int32(name='SidecarInjectorNum', description='The number of component replicas that are used for sidecar injection. Default value: `1`.', example='1'),
          sidecarInjectorWebhookAsYaml?: string(name='SidecarInjectorWebhookAsYaml', description='Other configurations of automatic sidecar injection, in the YAML format. For more information, see [Enable automatic sidecar injection by using multiple methods](~~186136~~).', example='{"injectedAnnotations":{"test/istio-init":"runtime/default2","test/istio-proxy":"runtime/default"},"replicaCount":2,"nodeSelector":{"beta.kubernetes.io/os":"linux"}}'),
        }(name='SidecarInjector', description='The configurations of the sidecar injector.'),
        telemetry?: boolean(name='Telemetry', description='Indicates whether Prometheus monitoring is enabled. We recommend that you use [Prometheus Service of Application Real-Time Monitoring Service (ARMS)](https://arms.console.aliyun.com/). Valid values:

*   `true`: Prometheus monitoring is enabled.
*   `false`: Prometheus monitoring is disabled.', example='true'),
        tracing?: boolean(name='Tracing', description='Indicates whether tracing analysis is enabled. This feature can be enabled only after [Tracing Analysis](https://tracing-analysis.console.aliyun.com/) is activated. Valid values:

*   `true`: Tracing analysis is enabled.
*   `false`: Tracing analysis is disabled.', example='true'),
        webAssemblyFilterDeployment?: {
          enabled?: boolean(name='Enabled', description='Indicates whether WebAssembly Filter is enabled. Valid values:

*   `true`:WebAssembly Filter is enabled.
*   `false`: WebAssembly Filter is disabled.', example='false'),
        }(name='WebAssemblyFilterDeployment', description='The configurations of WebAssembly Filter.'),
      }(name='MeshConfig', description='The configurations of the ASM instance.'),
      network?: {
        securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', example='sg-2ze384sxttxbctnj****'),
        vSwitches?: [ string ](name='VSwitches', description='The ID of the vSwitch.'),
        vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-2zew0rajjkmxy2369****'),
      }(name='Network', description='The network configurations of the ASM instance.'),
    }(name='Spec', description='The specifications of the ASM instance.'),
  }(name='ServiceMesh', description='The details of the ASM instance.'),
}

model DescribeServiceMeshDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshDetailResponseBody(name='body'),
}

async function describeServiceMeshDetailWithOptions(request: DescribeServiceMeshDetailRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshDetail',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMeshDetail(request: DescribeServiceMeshDetailRequest): DescribeServiceMeshDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshDetailWithOptions(request, runtime);
}

model DescribeServiceMeshKubeconfigRequest {
  privateIpAddress?: boolean(name='PrivateIpAddress', description='Specifies whether to query the kubeconfig file that is used for Internet access or internal network access.', example='false'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
}

model DescribeServiceMeshKubeconfigResponseBody = {
  expireTime?: string(name='ExpireTime'),
  kubeconfig?: string(name='Kubeconfig', description='The content of the kubeconfig file of the cluster.', example='apiVersion: v1 clusters: - cluster:     server: https://47.110.xx.xx:6443     certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURUakNDQWphZ0F3SUJBZ0lVYzBQVy82ejR1aHlxYkRRdnNsV1htSmpJeFdNd0RRWUpLb1pJaHZjTkFRRUwKQlFBd1BqRW5NQThHQTFVRUNoTUlhR0Z1WjNwb2IzVXdGQVlEVlFRS0V3MWhiR2xpWVdKaElHTnNiM1ZrTVJNdwpFUVlEVlFRREV3cHJkV0psY201bGRHVnpNQ0FYRFRJeU1EUXdOekExTVRnd01Gb1lEekl3TlRJd016TXdNRFV4Ck9EQXdXakErTVNjd0R3WURWUVFLRXdob1lXNW5lbWh2ZFRBVUJnTlZCQW9URFdGc2FXSmhZbUVnWTJ4dmRXUXgKRXpBUkJnTlZCQU1UQ210MVltVnlibVYwWlhNd2dnRWlNQTBHQ1NxR1NJYjNEUUVCQVFVQUE0SUJE****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeServiceMeshKubeconfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshKubeconfigResponseBody(name='body'),
}

async function describeServiceMeshKubeconfigWithOptions(request: DescribeServiceMeshKubeconfigRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshKubeconfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshKubeconfig',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMeshKubeconfig(request: DescribeServiceMeshKubeconfigRequest): DescribeServiceMeshKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshKubeconfigWithOptions(request, runtime);
}

model DescribeServiceMeshLogsRequest {
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='ca04bc38979214bf2882be79d39b4****'),
}

model DescribeServiceMeshLogsResponseBody = {
  logs?: [ 
    {
      creationTime?: string(name='CreationTime', description='The point in time when the logs were generated.', example='2021-11-19T15:21:53+08:00'),
      log?: string(name='Log', description='The content of the logs.', example='[RequestID: 31d3a0f0-07ed-4f6e-9004-1804498c****, UID-110982038403****] c096d641835af4658827a4c66c234**** | Start to add cluster c186a6d9641a24098b5499d4d8313****'),
      serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='ca04bc38979214bf2882be79d39b4****'),
    }
  ](name='Logs', description='The details of the logs.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model DescribeServiceMeshLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshLogsResponseBody(name='body'),
}

async function describeServiceMeshLogsWithOptions(request: DescribeServiceMeshLogsRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshLogsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshLogs',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMeshLogs(request: DescribeServiceMeshLogsRequest): DescribeServiceMeshLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshLogsWithOptions(request, runtime);
}

model DescribeServiceMeshProxyStatusRequest {
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='ca04bc38979214bf2882be79d39b4****'),
}

model DescribeServiceMeshProxyStatusResponseBody = {
  code?: string(name='Code', description='The status code. Valid values:

`200`: The status code returned because the operation is successful.

*   `403`: The status code returned because you are not authorized to perform this operation.
*   `503`: The status code returned because a backend server error occurs.', example='200'),
  message?: string(name='Message', description='The returned message.', example='success'),
  proxyStatus?: [ 
    {
      clusterSynced?: string(name='ClusterSynced', description='The update status of the proxy. Valid values:

*   `SYNCED`: The status of the proxy is updated.
*   `NOT SENT`: The status of the proxy is not updated.
*   `STALE (Never Acknowledged)`: Istiod has sent multiple requests to the Envoy proxy to update the status of the proxy but receives no response.
*   `STALE`: Istiod has sent a request to the Envoy proxy to update the status of the proxy but receives no response.', example='SYNCED'),
      endpointPercent?: string(name='EndpointPercent', description='The percentage of the updated endpoints.', example='1'),
      endpointSynced?: string(name='EndpointSynced', description='The update status of the endpoint. Valid values:

*   `SYNCED`: The status of the endpoint is updated.
*   `NOT SENT`: The status of the endpoint is not updated.
*   `STALE (Never Acknowledged)`: Istiod has sent multiple requests to the Envoy proxy to update the status of the endpoint but receives no response.
*   `STALE`: Istiod has sent a request to the Envoy proxy to update the status of the endpoint but receives no response.', example='SYNCED'),
      istioVersion?: string(name='IstioVersion', description='The version of Istiod.', example='1.9.7'),
      listenerSynced?: string(name='ListenerSynced', description='The update status of the listener. Valid values:

*   `SYNCED`: The status of the listener is updated.
*   `NOT SENT`: The status of the listener is not updated.
*   `STALE (Never Acknowledged)`: Istiod has sent multiple requests to the Envoy proxy to update the status of the listener but receives no response.
*   `STALE`: Istiod has sent a request to the Envoy proxy to update the status of the listener but receives no response.', example='SYNCED'),
      proxyId?: string(name='ProxyId', description='The ID of the proxy on the data plane.', example='119q****'),
      proxyVersion?: string(name='ProxyVersion', description='The version number of the proxy on the data plane.', example='1.9.7'),
      routeSynced?: string(name='RouteSynced', description='The update status of the route. Valid values:

*   `SYNCED`: The status of the route is updated.
*   `NOT SENT`: The status of the route is not updated.
*   `STALE (Never Acknowledged)`: Istiod has sent multiple requests to the Envoy proxy to update the status of the route but receives no response.
*   `STALE`: Istiod has sent a request to the Envoy proxy to update the status of the route but receives no response.', example='SYNCED'),
    }
  ](name='ProxyStatus', description='The information about the status of the proxies on the data plane.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
  success?: string(name='Success', description='Indicates whether the request is successful.', example='success'),
}

model DescribeServiceMeshProxyStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshProxyStatusResponseBody(name='body'),
}

async function describeServiceMeshProxyStatusWithOptions(request: DescribeServiceMeshProxyStatusRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshProxyStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshProxyStatus',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMeshProxyStatus(request: DescribeServiceMeshProxyStatusRequest): DescribeServiceMeshProxyStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshProxyStatusWithOptions(request, runtime);
}

model DescribeServiceMeshUpgradeStatusRequest {
  allIstioGatewayFullNames?: string(name='AllIstioGatewayFullNames', description='The ID of the request.', example='istio-system:ingressgateway1,istio-system:ingressgateway2'),
  guestClusterIds?: string(name='GuestClusterIds', description='The fully qualified names of ingress gateways in the ASM instance. Separate multiple names with commas (,).', example='caeac85a793c94afbbb0a4bb20320****'),
  serviceMeshId?: string(name='ServiceMeshId', description='The IDs of the clusters on the data plane of the ASM instance. Separate multiple clusters with commas (,).', example='11fd0027-c27e-41bb-a565-75583054****'),
}

model DescribeServiceMeshUpgradeStatusResponseBody = {
  requestId?: string(name='RequestId', description='The upgrade results.', example='11fd0027-c27e-41bb-a565-75583054****'),
  upgradeDetail?: {
    finishedGatewaysNum?: long(name='FinishedGatewaysNum', description='The status of the ASM instance. Valid values:

*   running: The instance is running.
*   `upgrading`: The instance is being upgraded.
*   `upgrading_failed`: The upgrade of the instance fails.', example='1'),
    gatewayStatusRecord?: map[string]UpgradeDetailGatewayStatusRecordValue(name='GatewayStatusRecord'),
    meshStatus?: string(name='MeshStatus', description='The total number of ingress gateways in the ASM instance.', example='running'),
    totalGatewaysNum?: long(name='TotalGatewaysNum', description='The information about the status of the ingress gateways.', example='2'),
  }(name='UpgradeDetail', description='The number of ingress gateways that are upgraded.'),
}

model DescribeServiceMeshUpgradeStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshUpgradeStatusResponseBody(name='body'),
}

async function describeServiceMeshUpgradeStatusWithOptions(request: DescribeServiceMeshUpgradeStatusRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshUpgradeStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.allIstioGatewayFullNames)) {
    body['AllIstioGatewayFullNames'] = request.allIstioGatewayFullNames;
  }
  if (!Util.isUnset(request.guestClusterIds)) {
    body['GuestClusterIds'] = request.guestClusterIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshUpgradeStatus',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMeshUpgradeStatus(request: DescribeServiceMeshUpgradeStatusRequest): DescribeServiceMeshUpgradeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshUpgradeStatusWithOptions(request, runtime);
}

model DescribeServiceMeshVMsRequest {
  serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='ccb37ff104caf419fbf48fb38e6f****'),
}

model DescribeServiceMeshVMsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='4b2c0fe0-6705-4614-8521-6b9d289163c8'),
  VMs?: [ 
    {
      hasTag?: boolean(name='HasTag', description='Indicates whether the ECS instance has labels.', example='false'),
      hostName?: string(name='HostName', description='The host name.', example='iZ2ze45cgxkx4q12eh****'),
      instanceId?: string(name='InstanceId', description='The ID of the ECS instance.', example='i-2ze0kub9scdguom****'),
      ipAddress?: string(name='IpAddress', description='The IP address of the ECS instance.', example='192.168.2.241'),
      region?: string(name='Region', description='The region ID.', example='cn-beijing'),
      securityGroupIds?: string(name='SecurityGroupIds', description='The security group to which the ECS instance belongs.', example='sg-2zeaqy08amco9osl****'),
      serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='ccb37ff104caf419fbf48fb38e6f3****'),
      status?: string(name='Status', description='The state of the ECS instance.', example='Running'),
    }
  ](name='VMs', description='The ECS instances that reside in the same VPC as the ASM instance.'),
}

model DescribeServiceMeshVMsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshVMsResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request DescribeServiceMeshVMsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeServiceMeshVMsResponse
 */
// Deprecated
async function describeServiceMeshVMsWithOptions(request: DescribeServiceMeshVMsRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshVMsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshVMs',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request DescribeServiceMeshVMsRequest
  * @return DescribeServiceMeshVMsResponse
 */
// Deprecated
async function describeServiceMeshVMs(request: DescribeServiceMeshVMsRequest): DescribeServiceMeshVMsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshVMsWithOptions(request, runtime);
}

model DescribeServiceMeshesRequest {
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model DescribeServiceMeshesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
  serviceMeshes?: [ 
    {
      clusterSpec?: string(name='ClusterSpec', description='The edition of the ASM instance. Valid values:

- `standard`: Standard Edition
- `enterprise`: Enterprise Edition
- `ultimate`: Ultimate Edition', example='standard'),
      clusters?: [ string ](name='Clusters', description='The information about the clusters.'),
      endpoints?: {
        intranetApiServerEndpoint?: string(name='IntranetApiServerEndpoint', description='The endpoint that is used to access the API server from the internal network.', example='https://192.168.xx.xx:6443'),
        intranetPilotEndpoint?: string(name='IntranetPilotEndpoint', description='The endpoint that is used to access Istio Pilot from the internal network.', example='192.168.xx.xx:15011'),
        publicApiServerEndpoint?: string(name='PublicApiServerEndpoint', description='The endpoint that is used to expose the API server to the Internet.', example='https://123.56.xx.xx:6443'),
        publicPilotEndpoint?: string(name='PublicPilotEndpoint', description='The endpoint that is used to expose Istio Pilot to the Internet.', example='182.92.xx.xx:15011'),
        reverseTunnelEndpoint?: string(name='ReverseTunnelEndpoint', description='The endpoint of the reverse tunnel.', example='...'),
      }(name='Endpoints', description='All endpoints of the ASM instance.'),
      ownerId?: string(name='OwnerId', description='The ID of the Alibaba Cloud service instance for which the ASM instance is created.', example='cc3e96f249d124eb38b72718ec5*****'),
      ownerType?: string(name='OwnerType', description='The Alibaba Cloud service for which the ASM instance is created. Valid values:

- `ackone`: The ASM instance is created for Alibaba Cloud Distributed Cloud Container Platform (ACK One).
- An empty value indicates that the ASM instance is created by the user.', example='ackone'),
      serviceMeshInfo?: {
        creationTime?: string(name='CreationTime', description='The point in time when the ASM instance was created.', example='2020-04-21T09:42:20+08:00'),
        errorMessage?: string(name='ErrorMessage', description='The error message that is returned when the call failed.', example='error'),
        name?: string(name='Name', description='The name of the ASM instance.', example='test'),
        profile?: string(name='Profile', description='The edition of the ASM instance before ASM is available for commercial use. Valid values:

*   `Pro`: Professional Edition
*   `Default`: Standard Edition', example='Pro'),
        regionId?: string(name='RegionId', description='The ID of the region in which the ASM instance resides.', example='cn-beijing'),
        serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='cb8963379255149cb98c8686f274x****'),
        state?: string(name='State', description='The status of the ASM instance.', example='success'),
        updateTime?: string(name='UpdateTime', description='The point in time when the ASM instance was last modified.', example='2020-04-21T09:42:20+08:00'),
        version?: string(name='Version', description='The version number of the ASM instance.', example='1'),
      }(name='ServiceMeshInfo', description='The basic information about the ASM instance.'),
      spec?: {
        loadBalancer?: {
          apiServerLoadbalancerId?: string(name='ApiServerLoadbalancerId', description='The ID of the SLB instance that is used when the API server is exposed to the Internet.', example='lb-2zekaak10uxds44vx****'),
          apiServerPublicEip?: boolean(name='ApiServerPublicEip', description='Indicates whether the API Server is exposed to the Internet. Valid values:

*   `true`: The API server is exposed to the Internet.
*   `false`: The API server is not exposed to the Internet.', example='true'),
          pilotPublicEip?: boolean(name='PilotPublicEip', description='Indicates whether Istio Pilot is exposed to the Internet. Valid values:

*   `true`: Istio Pilot is exposed to the Internet.
*   `false`: Istio Pilot is not exposed to the Internet.', example='true'),
          pilotPublicLoadbalancerId?: string(name='PilotPublicLoadbalancerId', description='The ID of the Server Load Balancer (SLB) instance that is used when Istio Pilot is exposed to the Internet.', example='lb-2zesa8qs8kbkj9jkl****'),
        }(name='LoadBalancer', description='The information about load balancing.'),
        meshConfig?: {
          mtls?: boolean(name='Mtls', description='Indicates whether the feature of routing traffic to the nearest instance is enabled. Valid values:

*   `true`: The feature is enabled.
*   `false`: The feature is disabled.', example='true'),
          outboundTrafficPolicy?: string(name='OutboundTrafficPolicy', description='The outbound traffic policy. Valid values:

*   `ALLOW_ANY`: Outbound traffic to an external service is allowed.
*   `REGISTRY_ONLY`: Outbound traffic is allowed to only external services that are defined in the service registry of the ASM instance.', example='ALLOW_ANY'),
          pilot?: {
            http10Enabled?: boolean(name='Http10Enabled', description='Indicates whether the support for HTTP 1.0 is enabled. Valid values:

*   `true`: The support for HTTP 1.0 is enabled.
*   `false`: The support for HTTP 1.0 is disabled.', example='true'),
            traceSampling?: float(name='TraceSampling', description='The sampling percentage of tracing.', example='0.2'),
          }(name='Pilot', description='The configurations of the control plane.'),
          sidecarInjector?: {
            autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled', description='Indicates whether automatic sidecar injection is enabled by using annotations.', example='true'),
            enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault', description='Indicates whether automatic sidecar injection is enabled for all namespaces. Valid values:

*   `true`: Automatic sidecar injection is enabled for all namespaces.
*   `false`: Automatic sidecar injection is disabled for all namespaces.', example='false'),
            initCNIConfiguration?: {
              enabled?: boolean(name='Enabled', description='Indicates whether elevated privileges are required for the istio-init container when you perform traffic redirection for the istio-proxy container. Valid values:

*   `true`: Elevated privileges are required for the istio-init container.
*   `false`: Elevated privileges are not required for the istio-init container.', example='true'),
              excludeNamespaces?: string(name='ExcludeNamespaces', description='The namespace for which sidecar injection is disabled.', example='default,foo'),
            }(name='InitCNIConfiguration', description='The initial configurations of Container Network Interface (CNI).'),
          }(name='SidecarInjector', description='The configurations of sidecar injection.'),
          strictMtls?: boolean(name='StrictMtls', description='Indicates whether mutual Transport Layer Security (mTLS) is strictly enforced.', example='true'),
          telemetry?: boolean(name='Telemetry', description='Indicates whether Prometheus monitoring is enabled. We recommend that you use Prometheus Service of Application Real-Time Monitoring Service (ARMS). Valid values:

*   `true`: Prometheus monitoring is enabled.
*   `false`: Prometheus monitoring is disabled.', example='true'),
          tracing?: boolean(name='Tracing', description='Indicates whether the tracing feature is enabled. This feature can be enabled only after Tracing Analysis is activated. Valid values:

*   `true`: The tracing feature is enabled.
*   `false`: The tracing feature is disabled.', example='true'),
        }(name='MeshConfig', description='The configurations of the ASM instance.'),
        network?: {
          securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', example='sg-2ze384sxttxbctnj****'),
          vSwitches?: [ string ](name='VSwitches', description='The IDs of vSwitches.'),
          vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-2zew0rajjkmxy2369****'),
        }(name='Network', description='The network configurations of the ASM instance.'),
      }(name='Spec', description='The specifications of the ASM instance.'),
      tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag'),
    }
  ](name='ServiceMeshes', description='The information about the ASM instances.'),
}

model DescribeServiceMeshesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshesResponseBody(name='body'),
}

async function describeServiceMeshesWithOptions(request: DescribeServiceMeshesRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshes',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMeshes(request: DescribeServiceMeshesRequest): DescribeServiceMeshesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshesWithOptions(request, runtime);
}

model DescribeUpgradeVersionRequest {
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
}

model DescribeUpgradeVersionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='11fd0027-c27e-41bb-a565-75583054****'),
  version?: {
    istioOperatorVersion?: string(name='IstioOperatorVersion', description='The version of the ASM instance.', example='v1.10.5.34-g7689a219-aliyun'),
    istioVersion?: string(name='IstioVersion', description='The Istio version.', example='1.10.5.34'),
    kubernetesVersion?: string(name='KubernetesVersion', description='The Kubernetes version.', example='1.20'),
  }(name='Version', description='The version information.'),
}

model DescribeUpgradeVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUpgradeVersionResponseBody(name='body'),
}

async function describeUpgradeVersionWithOptions(request: DescribeUpgradeVersionRequest, runtime: Util.RuntimeOptions): DescribeUpgradeVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUpgradeVersion',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUpgradeVersion(request: DescribeUpgradeVersionRequest): DescribeUpgradeVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUpgradeVersionWithOptions(request, runtime);
}

model DescribeUserPermissionsRequest {
  subAccountUserId?: string(name='SubAccountUserId', description='The ID of the RAM user or RAM role.', example='27852573609480****'),
}

model DescribeUserPermissionsResponseBody = {
  permissions?: [ 
    {
      isRamRole?: string(name='IsRamRole', description='The entity to which the permissions are granted. A value of `true` indicates that the permissions are granted to a RAM user. A value of `false` indicates that the permissions are granted to a RAM role.', example='false'),
      parentId?: string(name='ParentId', description='This parameter is required by the system. The return value is fixed to `0`.', example='0'),
      resourceId?: string(name='ResourceId', description='The ID of the ASM instance.', example='c57b848115458460583a4260cb713****'),
      resourceType?: string(name='ResourceType', description='This parameter is required by the system. The return value is fixed to `cluster`.', example='cluster'),
      roleName?: string(name='RoleName', description='The name of the permissions. Valid values:

*   `istio-admin`: the permissions of Alibaba Cloud Service Mesh (ASM) administrators.
*   `istio-ops`: the permissions of ASM restricted users.
*   `istio-readonly`: the read-only permissions.', example='istio-admin'),
      roleType?: string(name='RoleType', description='This parameter is required by the system. The return value is fixed to `custom`.', example='custom'),
    }
  ](name='Permissions', description='The permissions that are granted to an entity.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5A7C9E37-C171-584F-9A99-869B48C4196D'),
}

model DescribeUserPermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUserPermissionsResponseBody(name='body'),
}

async function describeUserPermissionsWithOptions(request: DescribeUserPermissionsRequest, runtime: Util.RuntimeOptions): DescribeUserPermissionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.subAccountUserId)) {
    body['SubAccountUserId'] = request.subAccountUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserPermissions',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUserPermissions(request: DescribeUserPermissionsRequest): DescribeUserPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserPermissionsWithOptions(request, runtime);
}

model DescribeUsersWithPermissionsRequest {
  userType?: string(name='UserType', description='Specifies whether to query the IDs of all RAM users or RAM roles to which an RBAC role is assigned. Valid values:

*   `SubUser`: Query the IDs of all RAM users to which an RBAC role is assigned.
*   `RamRole`: Query the IDs of all RAM roles to which an RBAC role is assigned.', example='SubUser'),
}

model DescribeUsersWithPermissionsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='12B94024-C241-13CD-BA44-6106DF1****'),
  UIDs?: [ string ](name='UIDs', description='The IDs of the RAM users or RAM roles to which an RBAC role is assigned.'),
}

model DescribeUsersWithPermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUsersWithPermissionsResponseBody(name='body'),
}

async function describeUsersWithPermissionsWithOptions(request: DescribeUsersWithPermissionsRequest, runtime: Util.RuntimeOptions): DescribeUsersWithPermissionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.userType)) {
    body['UserType'] = request.userType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUsersWithPermissions',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUsersWithPermissions(request: DescribeUsersWithPermissionsRequest): DescribeUsersWithPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUsersWithPermissionsWithOptions(request, runtime);
}

model DescribeVMsInServiceMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='ccb37ff104caf419fbf48fb38e6f3****'),
}

model DescribeVMsInServiceMeshResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='4b2c0fe0-6705-4614-8521-6b9d289163c8'),
  VMs?: [ 
    {
      hasTag?: boolean(name='HasTag', description='Indicates whether the ECS instance has labels.', example='true'),
      hostName?: string(name='HostName', description='The host name.', example='iZ2ze45cgxkx4q12eh9l****'),
      instanceId?: string(name='InstanceId', description='The ID of the ECS instance.', example='i-2ze45cgxkx4q12e****'),
      ipAddress?: string(name='IpAddress', description='The IP address of the ECS instance.', example='10.0.*,***'),
      region?: string(name='Region', description='The region ID.', example='cn-beijing'),
      securityGroupIds?: string(name='SecurityGroupIds', description='The security group to which the ECS instance belongs.', example='sg-2zeaqy08amco9osl****'),
      status?: string(name='Status', description='The state of the ECS instance.', example='Running'),
    }
  ](name='VMs', description='The VMs that are added to the ASM instance.'),
}

model DescribeVMsInServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVMsInServiceMeshResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request DescribeVMsInServiceMeshRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeVMsInServiceMeshResponse
 */
// Deprecated
async function describeVMsInServiceMeshWithOptions(request: DescribeVMsInServiceMeshRequest, runtime: Util.RuntimeOptions): DescribeVMsInServiceMeshResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVMsInServiceMesh',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request DescribeVMsInServiceMeshRequest
  * @return DescribeVMsInServiceMeshResponse
 */
// Deprecated
async function describeVMsInServiceMesh(request: DescribeVMsInServiceMeshRequest): DescribeVMsInServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVMsInServiceMeshWithOptions(request, runtime);
}

model DescribeVSwitchesRequest {
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-bp17gig441u0msmd78****'),
}

model DescribeVSwitchesResponseBody = {
  maxResults?: int32(name='MaxResults', description='The maximum number of entries returned.', example='10'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.', example='“”'),
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
  totalCount?: int32(name='TotalCount', description='The total number of vSwitches that are deployed in the VPC in the region. This parameter is optional and is not returned by default.', example='10'),
  vSwitches?: [ 
    {
      isDefault?: boolean(name='IsDefault', description='Indicates whether the vSwitch is the default vSwitch. Valid values:

*   `true`
*   `false`', example='false'),
      status?: string(name='Status', description='The state of the vSwitch. Valid values:

*   `Pending`: The vSwitch is being configured.
*   `Available`: The vSwitch is available.', example='Available'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-bp1g24p9no0iqir46****'),
      vSwitchName?: string(name='VSwitchName', description='The name of the vSwitch.', example='vsw-test'),
      vpcId?: string(name='VpcId', description='The ID of the VPC to which the vSwitch belongs.', example='vpc-bp17gig441u0msmd6****'),
      zoneId?: string(name='ZoneId', description='交换机所属的可用区。', example='cn-hangzhou-k'),
    }
  ](name='VSwitches', description='The available vSwitches.'),
}

model DescribeVSwitchesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVSwitchesResponseBody(name='body'),
}

async function describeVSwitchesWithOptions(request: DescribeVSwitchesRequest, runtime: Util.RuntimeOptions): DescribeVSwitchesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVSwitches',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVSwitchesWithOptions(request, runtime);
}

model DescribeVersionsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
  versionInfo?: [ 
    {
      edition?: string(name='Edition', description='The edition of the ASM instance. Valid values:

*   `Default`: Standard Edition
*   `Pro`: Professional Edition that is commercially released', example='Default'),
      versions?: [ string ](name='Versions', description='The ASM versions available for the ASM instance of the current edition.'),
    }
  ](name='VersionInfo', description='The available ASM versions.'),
}

model DescribeVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVersionsResponseBody(name='body'),
}

async function describeVersionsWithOptions(runtime: Util.RuntimeOptions): DescribeVersionsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeVersions',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVersions(): DescribeVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVersionsWithOptions(runtime);
}

model DescribeVpcsRequest {
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
}

model DescribeVpcsResponseBody = {
  maxResults?: int32(name='MaxResults', description='The maximum number of entries returned on a single page.', example='10'),
  nextToken?: string(name='NextToken', description='The token that marks the end of the current returned page. If this parameter is empty, it indicates that you have retrieved all the data.', example='""'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned. By default, this parameter is not returned.', example='10'),
  vpcs?: [ 
    {
      isDefault?: boolean(name='IsDefault', description='Indicates whether the VPC is the default VPC in the specified region. Valid values:

*   `true`: yes
*   `false`: no', example='false'),
      status?: string(name='Status', description='The status of the VPC. Valid values:

*   `Pending`: The VPC is being configured.
*   `Available`: The VPC is available for use.', example='Available'),
      vpcId?: string(name='VpcId', description='The ID of the VPC.', example='vpc-bp1qkf2o3xmqc2519****'),
      vpcName?: string(name='VpcName', description='The name of the VPC.', example='vpc-test'),
    }
  ](name='Vpcs', description='The list of VPCs that are available in the specified region.'),
}

model DescribeVpcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVpcsResponseBody(name='body'),
}

async function describeVpcsWithOptions(request: DescribeVpcsRequest, runtime: Util.RuntimeOptions): DescribeVpcsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVpcs',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVpcs(request: DescribeVpcsRequest): DescribeVpcsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcsWithOptions(request, runtime);
}

model GetCaCertRequest {
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the Alibaba Cloud Service Mesh (ASM) instance.', example='c7894c929677643a5bfe1a732d778a****'),
}

model GetCaCertResponseBody = {
  caCert?: string(name='CaCert', description='The Base64-encoded content of the CA certificate.', example='-----BEGIN CERTIFICATE-----\\nMIIFszCCA5ugAwIBAgIDM/1OMA0GCSqGSIb3DQEBCwUAME427zhT4HDLcCEW****-----END CERTIFICATE-----\\n'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E0496204-7586-5B4C-B364-2361CC0ED****'),
}

model GetCaCertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCaCertResponseBody(name='body'),
}

async function getCaCertWithOptions(request: GetCaCertRequest, runtime: Util.RuntimeOptions): GetCaCertResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetCaCert',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCaCert(request: GetCaCertRequest): GetCaCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCaCertWithOptions(request, runtime);
}

model GetDeploymentBySelectorRequest {
  guestCluster?: string(name='GuestCluster', description='The name of the cluster.', example='cbe80a56d07ed45818b4d39273e23****'),
  labelSelector?: map[string]string(name='LabelSelector', description='The label selector information.'),
  limit?: long(name='Limit', description='The maximum number of returned data entries.', example='10'),
  mark?: string(name='Mark', description='The marker of data queried last time.', example='eyJ2IjoibWV0YS5rOHMuaW8vdjEiLCJydiI6NzgxODk3MCwic3RhcnQiOiJuZ2lueDQ1N1x1MDAw****'),
  nameSpace?: string(name='NameSpace', description='The namespace.', example='default'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the Alibaba Cloud Service Mesh (ASM) instance.', example='ce9fc65def2aa4c918747b9360fbd****'),
}

model GetDeploymentBySelectorShrinkRequest {
  guestCluster?: string(name='GuestCluster', description='The name of the cluster.', example='cbe80a56d07ed45818b4d39273e23****'),
  labelSelectorShrink?: string(name='LabelSelector', description='The label selector information.'),
  limit?: long(name='Limit', description='The maximum number of returned data entries.', example='10'),
  mark?: string(name='Mark', description='The marker of data queried last time.', example='eyJ2IjoibWV0YS5rOHMuaW8vdjEiLCJydiI6NzgxODk3MCwic3RhcnQiOiJuZ2lueDQ1N1x1MDAw****'),
  nameSpace?: string(name='NameSpace', description='The namespace.', example='default'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the Alibaba Cloud Service Mesh (ASM) instance.', example='ce9fc65def2aa4c918747b9360fbd****'),
}

model GetDeploymentBySelectorResponseBody = {
  deploymentNameList?: [ bytes ](name='DeploymentNameList', description='The queried workloads.'),
  mark?: string(name='Mark', description='The end-of-data marker.', example='eyJ2IjoibWV0YS5rOHMuaW8vdjEiLCJydiI6NTgyMDUzMzk5MCwic3RhcnQiOiJwbXMtYWRhcHRlci1kZGxsXHUwMDA****'),
  requestId?: string(name='RequestId', description='The request ID.', example='946690C2-41D3-55A0-A501-E2FFAB5F****'),
}

model GetDeploymentBySelectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeploymentBySelectorResponseBody(name='body'),
}

async function getDeploymentBySelectorWithOptions(tmpReq: GetDeploymentBySelectorRequest, runtime: Util.RuntimeOptions): GetDeploymentBySelectorResponse {
  Util.validateModel(tmpReq);
  var request = new GetDeploymentBySelectorShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.labelSelector)) {
    request.labelSelectorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labelSelector, 'LabelSelector', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.guestCluster)) {
    body['GuestCluster'] = request.guestCluster;
  }
  if (!Util.isUnset(request.labelSelectorShrink)) {
    body['LabelSelector'] = request.labelSelectorShrink;
  }
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.mark)) {
    body['Mark'] = request.mark;
  }
  if (!Util.isUnset(request.nameSpace)) {
    body['NameSpace'] = request.nameSpace;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDeploymentBySelector',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeploymentBySelector(request: GetDeploymentBySelectorRequest): GetDeploymentBySelectorResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeploymentBySelectorWithOptions(request, runtime);
}

model GetGrafanaDashboardUrlRequest {
  k8sClusterId?: string(name='K8sClusterId', description='The ID of the Container Service for Kubernetes (ACK) or serverless Kubernetes (ASK) cluster.', example='c94ca2d27f7aa47ab84ed73e6f084****'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the Alibaba Cloud Service Mesh (ASM) instance.', example='cb8963379255149cb98c8686f274x****'),
  title?: string(name='Title', description='The name of the dashboard.', example='Cloud ASM Istio Http Gateway'),
}

model GetGrafanaDashboardUrlResponseBody = {
  dashboards?: [ 
    {
      title?: string(name='Title', description='The name of the dashboard.', example='Cloud ASM Istio Http Gateway'),
      url?: string(name='Url', description='The URL of the dashboard.', example='https://g.console.aliyun.com/d/181863583797****-14651340-200-2/alibaba-cloud-mesh-service?orgId=32****&refresh=60s'),
    }
  ](name='Dashboards', description='The information about the dashboard.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='76DBB8A0-5AA6-5A56-9A8A-****'),
}

model GetGrafanaDashboardUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGrafanaDashboardUrlResponseBody(name='body'),
}

async function getGrafanaDashboardUrlWithOptions(request: GetGrafanaDashboardUrlRequest, runtime: Util.RuntimeOptions): GetGrafanaDashboardUrlResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.k8sClusterId)) {
    body['K8sClusterId'] = request.k8sClusterId;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetGrafanaDashboardUrl',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGrafanaDashboardUrl(request: GetGrafanaDashboardUrlRequest): GetGrafanaDashboardUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGrafanaDashboardUrlWithOptions(request, runtime);
}

model GetRegisteredServiceEndpointsRequest {
  clusterIds?: string(name='ClusterIds', description='The name of the registered service.', example='c8b054ee8c3914d079b5ce9733328****,c58faedb8a78640d3aeb0372e4c02****'),
  name?: string(name='Name', description='The type of the registered service. Valid values:

*   `ServiceEntry`: indicates that the service is registered by creating a service entry.
*   `Kubernetes`: indicates that the service is registered on a Kubernetes cluster on the data plane.', example='reviews'),
  namespace?: string(name='Namespace', description='The IDs of clusters in the ASM instance. Separate multiple cluster IDs with commas (,).', example='default'),
  serviceMeshId?: string(name='ServiceMeshId', description='The name of the namespace.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
  serviceType?: string(name='ServiceType', description='The endpoints of the registered service.', example='Kubernetes'),
}

model GetRegisteredServiceEndpointsResponseBody = {
  endPointSlice?: {
    endpointsDetails?: [ 
      {
        address?: string(name='Address', description='The port of the registered service.', example='127.2.**.**'),
        hostname?: string(name='Hostname', description='The ID of the region in which the registered service resides.', example='www.demo.com'),
        podName?: string(name='PodName', description='The IP address of the registered service.', example='provider-v1-8c86b6898-h***'),
        ports?: [ int32 ](name='Ports', description='The host name of the registered service.'),
        region?: string(name='Region', description='Indicates whether sidecar proxies are injected. Valid values:

*   `true`: yes
*   `false`: no', example='cn-hangzhou'),
        sidecarInjected?: boolean(name='SidecarInjected', description='The ID of the request.', example='false'),
      }
    ](name='EndpointsDetails', description='The name of the pod.'),
    location?: string(name='Location', description='The details of the endpoint of the registered service.', example='MESH_INTERNAL'),
    namespace?: string(name='Namespace', description='The location of the registered service. Valid values:

*   `MESH_INTERNAL`: The service is deployed inside the ASM instance.
*   `MESH_EXTERNAL`: The service is deployed outside the ASM instance.', example='default'),
    serviceName?: string(name='ServiceName', description='The name of the namespace.', example='reviews'),
  }(name='EndPointSlice', description='The name of the registered service.'),
  requestId?: string(name='RequestId', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
  serviceEndpoints?: [ 
    {
      address?: string(name='Address', description='The ID of the cluster on the data plane.', example='192.168.25.153'),
      clusterId?: string(name='ClusterId', description='The details of the endpoints of the registered service.', example='c80f45444b3da447da60a911390c2****'),
    }
  ](name='ServiceEndpoints', description='The IP address of the registered service.'),
}

model GetRegisteredServiceEndpointsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRegisteredServiceEndpointsResponseBody(name='body'),
}

async function getRegisteredServiceEndpointsWithOptions(request: GetRegisteredServiceEndpointsRequest, runtime: Util.RuntimeOptions): GetRegisteredServiceEndpointsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clusterIds)) {
    body['ClusterIds'] = request.clusterIds;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.serviceType)) {
    body['ServiceType'] = request.serviceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetRegisteredServiceEndpoints',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRegisteredServiceEndpoints(request: GetRegisteredServiceEndpointsRequest): GetRegisteredServiceEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegisteredServiceEndpointsWithOptions(request, runtime);
}

model GetRegisteredServiceNamespacesRequest {
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='cb8963379255149cb98c8686f274x****'),
}

model GetRegisteredServiceNamespacesResponseBody = {
  namespaces?: [ string ](name='Namespaces', description='The names of the queried namespaces.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model GetRegisteredServiceNamespacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRegisteredServiceNamespacesResponseBody(name='body'),
}

async function getRegisteredServiceNamespacesWithOptions(request: GetRegisteredServiceNamespacesRequest, runtime: Util.RuntimeOptions): GetRegisteredServiceNamespacesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetRegisteredServiceNamespaces',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRegisteredServiceNamespaces(request: GetRegisteredServiceNamespacesRequest): GetRegisteredServiceNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegisteredServiceNamespacesWithOptions(request, runtime);
}

model GetSwimLaneDetailRequest {
  groupName?: string(name='GroupName', description='The name of the lane group.', example='test'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='xxx'),
  swimLaneName?: string(name='SwimLaneName', description='The name of the lane.', example='s1'),
}

model GetSwimLaneDetailResponseBody = {
  ingressRule?: string(name='IngressRule', description='The traffic routing rule that routes traffic to the lane by using the ingress gateway. The traffic routing rule contains one or more custom routes.', example='[{"Domains":["*"],"RouteName":"r1","MatchRequest":{"Headers":[{"Name":"x-asm-prefer-tag","MatchingMode":"exact","MatchingContent":"s1"}],"URI":{"MatchingMode":"exact","MatchingContent":"/mock"}},"RouteDestinations":[{"Destination":{"Host":"mocka.default.svc.cluster.local","Subset":"s1"}}]},{"Domains":["*"],"RouteName":"hello","MatchRequest":{"Headers":[{"Name":"x-asm-prefer-tag","MatchingMode":"exact","MatchingContent":"s1"}],"URI":{"MatchingMode":"exact","MatchingContent":"/mocktest"}},"RouteDestinations":[{"Destination":{"Host":"mocka.default.svc.cluster.local","Subset":"s1"}}]}]'),
  ingressService?: string(name='IngressService', description='This parameter is deprecated.', example='mocka.default.svc.cluster.local'),
  labelSelectorKey?: string(name='LabelSelectorKey', description='Fixed value: **ASM_TRAFFIC_TAG**.', example='ASM_TRAFFIC_TAG'),
  labelSelectorValue?: string(name='LabelSelectorValue', description='The value of ASM_TRAFFIC_TAG.', example='v1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='yyyy'),
  servicesList?: string(name='ServicesList', description='A list of services associated with the lane.', example='["sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mocka","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockb","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockc"]'),
}

model GetSwimLaneDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSwimLaneDetailResponseBody(name='body'),
}

async function getSwimLaneDetailWithOptions(request: GetSwimLaneDetailRequest, runtime: Util.RuntimeOptions): GetSwimLaneDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    body['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.swimLaneName)) {
    body['SwimLaneName'] = request.swimLaneName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetSwimLaneDetail',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSwimLaneDetail(request: GetSwimLaneDetailRequest): GetSwimLaneDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSwimLaneDetailWithOptions(request, runtime);
}

model GetSwimLaneGroupListRequest {
  serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='xxxx'),
}

model GetSwimLaneGroupListResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='yyyy'),
  swimLaneGroupList?: [ 
    {
      fallbackTarget?: string(name='FallbackTarget'),
      groupName?: string(name='GroupName', description='The name of the lane group.', example='test'),
      ingressGatewayName?: string(name='IngressGatewayName', description='The name of the ingress gateway.', example='ingressgateway'),
      ingressType?: string(name='IngressType', description='The ingress type. Traffic routing rules can be configured only in an ingress gateway.', example='ASM'),
      isPermissive?: boolean(name='IsPermissive'),
      routeHeader?: string(name='RouteHeader'),
      serviceList?: string(name='ServiceList', description='A list of services associated with the lane group.', example='["sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mocka","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockb","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockc"]'),
      swimLaneLabels?: string(name='SwimLaneLabels'),
      traceHeader?: string(name='TraceHeader'),
    }
  ](name='SwimLaneGroupList', description='The information about the lane groups.'),
}

model GetSwimLaneGroupListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSwimLaneGroupListResponseBody(name='body'),
}

async function getSwimLaneGroupListWithOptions(request: GetSwimLaneGroupListRequest, runtime: Util.RuntimeOptions): GetSwimLaneGroupListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetSwimLaneGroupList',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSwimLaneGroupList(request: GetSwimLaneGroupListRequest): GetSwimLaneGroupListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSwimLaneGroupListWithOptions(request, runtime);
}

model GetSwimLaneListRequest {
  groupName?: string(name='GroupName', description='The name of the lane group.', example='test'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='xxx'),
}

model GetSwimLaneListResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='yyyy'),
  swimLaneList?: [ 
    {
      groupName?: string(name='GroupName', description='The name of the lane group.', example='test'),
      ingressRule?: string(name='IngressRule', description='The traffic routing rule associated with the lane.', example='[{"Domains":["*"],"RouteName":"r1","MatchRequest":{"Headers":[{"Name":"x-asm-prefer-tag","MatchingMode":"exact","MatchingContent":"s1"}],"URI":{"MatchingMode":"exact","MatchingContent":"/mock"}},"RouteDestinations":[{"Destination":{"Host":"mocka.default.svc.cluster.local","Subset":"s1"}}]},{"Domains":["*"],"RouteName":"hello","MatchRequest":{"Headers":[{"Name":"x-asm-prefer-tag","MatchingMode":"exact","MatchingContent":"s1"}],"URI":{"MatchingMode":"exact","MatchingContent":"/mocktest"}},"RouteDestinations":[{"Destination":{"Host":"mocka.default.svc.cluster.local","Subset":"s1"}}]}]'),
      ingressService?: string(name='IngressService', description='This parameter is deprecated.', example='mocka.default.svc.cluster.local'),
      labelSelectorKey?: string(name='LabelSelectorKey', description='The label key of the associated service workload. Fixed value: `ASM_TRAFFIC_TAG`.', example='ASM_TRAFFIC_TAG'),
      labelSelectorValue?: string(name='LabelSelectorValue', description='The label value of the associated service workload.``', example='v1'),
      name?: string(name='Name', description='The name of the lane.', example='s1'),
      serviceList?: string(name='ServiceList', description='A list of services associated with the lane.', example='["sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mocka","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockb","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockc"]'),
    }
  ](name='SwimLaneList', description='A list of all the lanes in the lane group.'),
}

model GetSwimLaneListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSwimLaneListResponseBody(name='body'),
}

async function getSwimLaneListWithOptions(request: GetSwimLaneListRequest, runtime: Util.RuntimeOptions): GetSwimLaneListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    body['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetSwimLaneList',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSwimLaneList(request: GetSwimLaneListRequest): GetSwimLaneListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSwimLaneListWithOptions(request, runtime);
}

model GetVmAppMeshInfoRequest {
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='ce51a7de4a5144db88a864****'),
}

model GetVmAppMeshInfoResponseBody = {
  data?: string(name='Data', description='The returned information.', example='...'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9522f7c9-63a1-4603-b850-37d12a****'),
}

model GetVmAppMeshInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVmAppMeshInfoResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request GetVmAppMeshInfoRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetVmAppMeshInfoResponse
 */
// Deprecated
async function getVmAppMeshInfoWithOptions(request: GetVmAppMeshInfoRequest, runtime: Util.RuntimeOptions): GetVmAppMeshInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVmAppMeshInfo',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request GetVmAppMeshInfoRequest
  * @return GetVmAppMeshInfoResponse
 */
// Deprecated
async function getVmAppMeshInfo(request: GetVmAppMeshInfoRequest): GetVmAppMeshInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVmAppMeshInfoWithOptions(request, runtime);
}

model GetVmMetaRequest {
  namespace?: string(name='Namespace', description='The namespace. This parameter is valid only after you set the Namespace and the ServiceAccount parameters.', example='hello'),
  serviceAccount?: string(name='ServiceAccount', description='The service account. This parameter is valid only after you set the Namespace and the ServiceAccount parameters.', example='http-sa'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='ce51a7de4a5144db88a864ed91****'),
  trustDomain?: string(name='TrustDomain', description='The trusted domain. Default value: cluster.local. This parameter is valid only after you set the Namespace and the ServiceAccount parameters.', example='cluster.local'),
}

model GetVmMetaResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='9522f7c9-63a1-4603-b850-37d12a****'),
  vmMetaInfo?: {
    envoyEnvContent?: string(name='EnvoyEnvContent', description='The content of the EnvoyEnv file.', example='....'),
    hostsContent?: string(name='HostsContent', description='The content of the hosts file.', example='....'),
    tokenContent?: string(name='TokenContent', description='The content of the Token file.', example='....'),
  }(name='VmMetaInfo', description='The metadata that is required to add a non-containerized application to the ASM instance.'),
}

model GetVmMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVmMetaResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request GetVmMetaRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetVmMetaResponse
 */
// Deprecated
async function getVmMetaWithOptions(request: GetVmMetaRequest, runtime: Util.RuntimeOptions): GetVmMetaResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVmMeta',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request GetVmMetaRequest
  * @return GetVmMetaResponse
 */
// Deprecated
async function getVmMeta(request: GetVmMetaRequest): GetVmMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVmMetaWithOptions(request, runtime);
}

model GrantUserPermissionsRequest {
  permissions?: string(name='Permissions', description='The permissions that are granted to an entity. The content is a string that consists of JSON arrays. You must specify all permissions that you want to grant to an entity. You can add or remove permissions by modifying the content. Field definition of the sample code:

*   `IsCustom`: a parameter that is required by the system. Set the value to `true`.
*   `Cluster`: the ID of the Alibaba Cloud Service Mesh (ASM) instance.
*   `RoleName`: the name of the permissions. Valid values: `istio-admin`, `istio-ops`, and `istio-readonly`. A value of istio-admin indicates the permissions of ASM administrators. A value of istio-ops indicates the permissions of ASM restricted users. A value of istio-readonly indicates the read-only permissions.
*   `IsRamRole`: the entity to which you want to grant the permissions. To grant the permissions to a RAM role, set the value to `true`. Otherwise, set the value to `false`.', example='[{"IsCustom":true,"RoleName":"istio-ops","Cluster":"c57b848115458460583a4260cb713****","RoleType":"custom","IsRamRole":false},{"IsCustom":true,"RoleName":"istio-ops","Cluster":"c4ec191f4e12145c09286ea3e2b8f****","RoleType":"custom","IsRamRole":false}]'),
  subAccountUserId?: string(name='SubAccountUserId', description='The ID of the RAM user or RAM role.', example='27852573609480****'),
  subAccountUserIds?: [ string ](name='SubAccountUserIds', description='The ID list of the RAM user or RAM role.'),
}

model GrantUserPermissionsShrinkRequest {
  permissions?: string(name='Permissions', description='The permissions that are granted to an entity. The content is a string that consists of JSON arrays. You must specify all permissions that you want to grant to an entity. You can add or remove permissions by modifying the content. Field definition of the sample code:

*   `IsCustom`: a parameter that is required by the system. Set the value to `true`.
*   `Cluster`: the ID of the Alibaba Cloud Service Mesh (ASM) instance.
*   `RoleName`: the name of the permissions. Valid values: `istio-admin`, `istio-ops`, and `istio-readonly`. A value of istio-admin indicates the permissions of ASM administrators. A value of istio-ops indicates the permissions of ASM restricted users. A value of istio-readonly indicates the read-only permissions.
*   `IsRamRole`: the entity to which you want to grant the permissions. To grant the permissions to a RAM role, set the value to `true`. Otherwise, set the value to `false`.', example='[{"IsCustom":true,"RoleName":"istio-ops","Cluster":"c57b848115458460583a4260cb713****","RoleType":"custom","IsRamRole":false},{"IsCustom":true,"RoleName":"istio-ops","Cluster":"c4ec191f4e12145c09286ea3e2b8f****","RoleType":"custom","IsRamRole":false}]'),
  subAccountUserId?: string(name='SubAccountUserId', description='The ID of the RAM user or RAM role.', example='27852573609480****'),
  subAccountUserIdsShrink?: string(name='SubAccountUserIds', description='The ID list of the RAM user or RAM role.'),
}

model GrantUserPermissionsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5A7C9E37-C171-584F-9A99-869B48C4****'),
}

model GrantUserPermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GrantUserPermissionsResponseBody(name='body'),
}

async function grantUserPermissionsWithOptions(tmpReq: GrantUserPermissionsRequest, runtime: Util.RuntimeOptions): GrantUserPermissionsResponse {
  Util.validateModel(tmpReq);
  var request = new GrantUserPermissionsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.subAccountUserIds)) {
    request.subAccountUserIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.subAccountUserIds, 'SubAccountUserIds', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.permissions)) {
    body['Permissions'] = request.permissions;
  }
  if (!Util.isUnset(request.subAccountUserId)) {
    body['SubAccountUserId'] = request.subAccountUserId;
  }
  if (!Util.isUnset(request.subAccountUserIdsShrink)) {
    body['SubAccountUserIds'] = request.subAccountUserIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GrantUserPermissions',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function grantUserPermissions(request: GrantUserPermissionsRequest): GrantUserPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return grantUserPermissionsWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', example='""'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType', example='servicemesh'),
  tag?: [ 
    {
      key?: string(name='Key', example='test'),
      value?: string(name='Value', example='yahaha'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', example='""'),
  requestId?: string(name='RequestId', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId', example='863c333b-9a8e-4b53-a13f-52a979362431'),
      resourceType?: string(name='ResourceType', example='servicemesh'),
      tagKey?: string(name='TagKey', example='k1'),
      tagValue?: string(name='TagValue', example='yahaha'),
    }
  ](name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ModifyApiServerEipResourceRequest {
  apiServerEipId?: string(name='ApiServerEipId', description='The ID of the EIP.', example='eip-bp1adu9jegmxnaoq****'),
  operation?: string(name='Operation', description='The type of the operation. Valid values:

*   `UnBindEip`: disassociates an EIP from the API server.
*   `BindEip`: associates an EIP with the API server.', example='BindEip'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the Alibaba Cloud Service Mesh (ASM) instance.', example='cb8963379255149cb98c8686f274x****'),
}

model ModifyApiServerEipResourceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model ModifyApiServerEipResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyApiServerEipResourceResponseBody(name='body'),
}

async function modifyApiServerEipResourceWithOptions(request: ModifyApiServerEipResourceRequest, runtime: Util.RuntimeOptions): ModifyApiServerEipResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apiServerEipId)) {
    body['ApiServerEipId'] = request.apiServerEipId;
  }
  if (!Util.isUnset(request.operation)) {
    body['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyApiServerEipResource',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyApiServerEipResource(request: ModifyApiServerEipResourceRequest): ModifyApiServerEipResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyApiServerEipResourceWithOptions(request, runtime);
}

model ModifyServiceMeshNameRequest {
  name?: string(name='Name', description='The new name of the ASM instance.', example='test-mesh'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='cdd30a90a7cea480ebcc7ff****'),
}

model ModifyServiceMeshNameResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='EDDC0D86-2FC3-56FB-9213-96EB0A3523F1'),
}

model ModifyServiceMeshNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyServiceMeshNameResponseBody(name='body'),
}

async function modifyServiceMeshNameWithOptions(request: ModifyServiceMeshNameRequest, runtime: Util.RuntimeOptions): ModifyServiceMeshNameResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyServiceMeshName',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyServiceMeshName(request: ModifyServiceMeshNameRequest): ModifyServiceMeshNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyServiceMeshNameWithOptions(request, runtime);
}

model ReActivateAuditRequest {
  enableAudit?: boolean(name='EnableAudit', description='Specifies whether to recreate a project that is used to store audit logs. Valid values:

*   true: recreates a project.
*   false: does not recreate a project.', example='true'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the Alibaba Cloud Service Mesh (ASM) instance.', example='c5bf9eb05c4424b89985d6536a809****'),
}

model ReActivateAuditResponseBody = {
  data?: string(name='Data', description='The name of the project that is used to store audit logs.', example='k8s-log-c0703599f695f4b8fa1c6492a33af****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='17163CE9-CE4B-1B87-9185-1A1AD7E7****'),
}

model ReActivateAuditResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReActivateAuditResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that you understand the billing methods of Log Service. For more information, visit the [pricing page](https://www.aliyun.com/price/product?spm=5176.10695662.1119587.4.194c6a67rcPWQH#/sls/detail).
  *
  * @param request ReActivateAuditRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ReActivateAuditResponse
 */
async function reActivateAuditWithOptions(request: ReActivateAuditRequest, runtime: Util.RuntimeOptions): ReActivateAuditResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.enableAudit)) {
    body['EnableAudit'] = request.enableAudit;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReActivateAudit',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, make sure that you understand the billing methods of Log Service. For more information, visit the [pricing page](https://www.aliyun.com/price/product?spm=5176.10695662.1119587.4.194c6a67rcPWQH#/sls/detail).
  *
  * @param request ReActivateAuditRequest
  * @return ReActivateAuditResponse
 */
async function reActivateAudit(request: ReActivateAuditRequest): ReActivateAuditResponse {
  var runtime = new Util.RuntimeOptions{};
  return reActivateAuditWithOptions(request, runtime);
}

model RemoveClusterFromServiceMeshRequest {
  clusterId?: string(name='ClusterId', example='cb8963379255149cb98c8686f274x****'),
  reserveNamespace?: boolean(name='ReserveNamespace', description='移除集群时，保留istio-system 命名空间', example='false'),
  serviceMeshId?: string(name='ServiceMeshId', example='ce3c25e247da24f3aab9b7edfae83****'),
}

model RemoveClusterFromServiceMeshResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='success'),
  requestId?: string(name='RequestId', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model RemoveClusterFromServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveClusterFromServiceMeshResponseBody(name='body'),
}

async function removeClusterFromServiceMeshWithOptions(request: RemoveClusterFromServiceMeshRequest, runtime: Util.RuntimeOptions): RemoveClusterFromServiceMeshResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.reserveNamespace)) {
    body['ReserveNamespace'] = request.reserveNamespace;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveClusterFromServiceMesh',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeClusterFromServiceMesh(request: RemoveClusterFromServiceMeshRequest): RemoveClusterFromServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeClusterFromServiceMeshWithOptions(request, runtime);
}

model RemoveVMFromServiceMeshRequest {
  ecsId?: string(name='EcsId', description='The ID of the ECS instance.', example='i-2ze90ts4edj3650****'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='ccb37ff104caf419fbf48fb38e6f3****'),
}

model RemoveVMFromServiceMeshResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='4b2c0fe0-6705-4614-8521-6b9d289163c8'),
}

model RemoveVMFromServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveVMFromServiceMeshResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request RemoveVMFromServiceMeshRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return RemoveVMFromServiceMeshResponse
 */
// Deprecated
async function removeVMFromServiceMeshWithOptions(request: RemoveVMFromServiceMeshRequest, runtime: Util.RuntimeOptions): RemoveVMFromServiceMeshResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ecsId)) {
    query['EcsId'] = request.ecsId;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveVMFromServiceMesh',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request RemoveVMFromServiceMeshRequest
  * @return RemoveVMFromServiceMeshResponse
 */
// Deprecated
async function removeVMFromServiceMesh(request: RemoveVMFromServiceMeshRequest): RemoveVMFromServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeVMFromServiceMeshWithOptions(request, runtime);
}

model RevokeKubeconfigRequest {
  privateIpAddress?: boolean(name='PrivateIpAddress', description='Specifies whether to return the kubeconfig file for private access.

*   `true`: returns the kubeconfig file for private access.
*   `false`: returns the kubeconfig file for public access.', example='false'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance for which you want to revoke a kubeconfig file.', example='cf08a11940e8c46c48bc791fcdb3****'),
}

model RevokeKubeconfigResponseBody = {
  kubeconfig?: string(name='Kubeconfig', description='The new kubeconfig file generated.', example='apiVersion: v1 clusters: - cluster:     server: https://121.**.**.**:6443     certificate-authority-data: *****   name: kubernetes contexts: - context:     cluster: kubernetes     user: "*****"   name: ***** current-context: ***** kind: Config preferences: {} users: - name: "*****"   user:     client-certificate-data: *****     client-key-data: *****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7CF71C8B-79DD-150F-929E-267C51C5E311'),
}

model RevokeKubeconfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokeKubeconfigResponseBody(name='body'),
}

async function revokeKubeconfigWithOptions(request: RevokeKubeconfigRequest, runtime: Util.RuntimeOptions): RevokeKubeconfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.privateIpAddress)) {
    body['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RevokeKubeconfig',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokeKubeconfig(request: RevokeKubeconfigRequest): RevokeKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeKubeconfigWithOptions(request, runtime);
}

model TagResourcesRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType', example='servicemesh'),
  tag?: [ 
    {
      key?: string(name='Key', example='test'),
      value?: string(name='Value', example='yahaha'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', example='false'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType', example='servicemesh'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateASMGatewayRequest {
  body?: string(name='Body', description='The new YAML content of the ASM gateway.', example='{"apiVersion":"istio.alibabacloud.com/v1beta1","kind":"IstioGateway","metadata":{"name":"ingressgateway","namespace":"istio-system"},"spec":{"gatewayType":"ingress","clusterIds":["xxxxx"],"ports":[{"name":"http-0","port":80,"targetPort":80,"protocol":"TCP"},{"name":"https-1","port":443,"targetPort":443,"protocol":"TCP"}],"serviceAnnotations":{"service.beta.kubernetes.io/alicloud-loadbalancer-address-type":"internet","service.beta.kubernetes.io/alibaba-cloud-loadbalancer-spec":"slb.s1.small"},"replicaCount":2,"resources":{"limits":{"cpu":"2","memory":"4G"},"requests":{"cpu":"200m","memory":"256Mi"}},"serviceType":"LoadBalancer","maxReplicas":2,"minReplicas":2}}'),
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='cb8963379255149cb98c8686f274x****'),
}

model UpdateASMGatewayResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model UpdateASMGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateASMGatewayResponseBody(name='body'),
}

async function updateASMGatewayWithOptions(request: UpdateASMGatewayRequest, runtime: Util.RuntimeOptions): UpdateASMGatewayResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['Body'] = request.body;
  }
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateASMGateway',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateASMGateway(request: UpdateASMGatewayRequest): UpdateASMGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateASMGatewayWithOptions(request, runtime);
}

model UpdateASMGatewayImportedServicesRequest {
  ASMGatewayName?: string(name='ASMGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
  serviceNames?: string(name='ServiceNames', description='The names of the services. Separate multiple service names with commas (,). Example: reviews,sleep.', example='reviews,sleep'),
  serviceNamespace?: string(name='ServiceNamespace', description='The namespace in which the service resides.', example='default'),
}

model UpdateASMGatewayImportedServicesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='11fd0027-c27e-41bb-a565-75583054****'),
}

model UpdateASMGatewayImportedServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateASMGatewayImportedServicesResponseBody(name='body'),
}

async function updateASMGatewayImportedServicesWithOptions(request: UpdateASMGatewayImportedServicesRequest, runtime: Util.RuntimeOptions): UpdateASMGatewayImportedServicesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ASMGatewayName)) {
    body['ASMGatewayName'] = request.ASMGatewayName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.serviceNames)) {
    body['ServiceNames'] = request.serviceNames;
  }
  if (!Util.isUnset(request.serviceNamespace)) {
    body['ServiceNamespace'] = request.serviceNamespace;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateASMGatewayImportedServices',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateASMGatewayImportedServices(request: UpdateASMGatewayImportedServicesRequest): UpdateASMGatewayImportedServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateASMGatewayImportedServicesWithOptions(request, runtime);
}

model UpdateASMNamespaceFromGuestClusterRequest {
  k8sClusterId?: string(name='K8sClusterId', description='The ID of the Kubernetes cluster whose namespace information you want to synchronize to ASM. The Kubernetes cluster is added to the ASM instance that is specified by the ServiceMeshId parameter.', example='c6f6d46583def494ba1f2e2937c8*****'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='cbf9ca9e6d5dc4c87a3ecd0ebf1e*****'),
}

model UpdateASMNamespaceFromGuestClusterResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9DEC6122-ACEC-183D-8451-8E0A1A******'),
}

model UpdateASMNamespaceFromGuestClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateASMNamespaceFromGuestClusterResponseBody(name='body'),
}

async function updateASMNamespaceFromGuestClusterWithOptions(request: UpdateASMNamespaceFromGuestClusterRequest, runtime: Util.RuntimeOptions): UpdateASMNamespaceFromGuestClusterResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.k8sClusterId)) {
    body['K8sClusterId'] = request.k8sClusterId;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateASMNamespaceFromGuestCluster',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateASMNamespaceFromGuestCluster(request: UpdateASMNamespaceFromGuestClusterRequest): UpdateASMNamespaceFromGuestClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateASMNamespaceFromGuestClusterWithOptions(request, runtime);
}

model UpdateControlPlaneLogConfigRequest {
  enabled?: boolean(name='Enabled', example='false'),
  logTTLInDay?: int32(name='LogTTLInDay', example='30'),
  project?: string(name='Project', example='aia-asm-deva-sh'),
  serviceMeshId?: string(name='ServiceMeshId', example='c20667db760fe4ee6910220136624****'),
}

model UpdateControlPlaneLogConfigResponseBody = {
  requestId?: string(name='RequestId', example='488F046B-63D2-5D96-9A70-E00C3685D49F'),
}

model UpdateControlPlaneLogConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateControlPlaneLogConfigResponseBody(name='body'),
}

async function updateControlPlaneLogConfigWithOptions(request: UpdateControlPlaneLogConfigRequest, runtime: Util.RuntimeOptions): UpdateControlPlaneLogConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.enabled)) {
    body['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.logTTLInDay)) {
    body['LogTTLInDay'] = request.logTTLInDay;
  }
  if (!Util.isUnset(request.project)) {
    body['Project'] = request.project;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateControlPlaneLogConfig',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateControlPlaneLogConfig(request: UpdateControlPlaneLogConfigRequest): UpdateControlPlaneLogConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateControlPlaneLogConfigWithOptions(request, runtime);
}

model UpdateIstioGatewayRoutesRequest {
  description?: string(name='Description', description='The description of the routing rule.', example='demo route'),
  gatewayRoute?: {
    domains?: [ string ](name='Domains'),
    HTTPAdvancedOptions?: {
      delegate?: {
        name?: string(name='Name', description='The name of the virtual service.', example='reviews'),
        namespace?: string(name='Namespace', description='The namespace to which the virtual service belongs.', example='default'),
      }(name='Delegate', description='The virtual service that defines traffic routing.'),
      fault?: {
        abort?: {
          httpStatus?: int32(name='HttpStatus', description='The HTTP status code.', example='400'),
          percentage?: {
            value?: float(name='Value', description='The percentage of requests that are aborted with the specified error code, which is expressed as a decimal.', example='0.1'),
          }(name='Percentage', description='The percentage of requests that are aborted with the specified error code.'),
        }(name='Abort', description='The configurations for aborting requests with specified error codes.'),
        delay?: {
          fixedDelay?: string(name='FixedDelay', description='The fixed duration for request delay.', example='5s'),
          percentage?: {
            value?: float(name='Value', description='The percentage of requests to which the delay fault is injected, which is expressed as a decimal.', example='0.1'),
          }(name='Percentage', description='The percentage of requests to which the delay fault is injected.'),
        }(name='Delay', description='The duration to delay a request.'),
      }(name='Fault', description='The configurations of fault injection.'),
      HTTPRedirect?: {
        authority?: string(name='Authority', description='The value to be used to overwrite the value of the Authority or Host header during redirection.', example='newratings.default.svc.cluster.local'),
        redirectCode?: int32(name='RedirectCode', description='The HTTP status code to be used to indicate URL redirection. Default value: 301.', example='301'),
        uri?: string(name='Uri', description='The value to be used to overwrite the URL path during redirection.', example='/v1/getProductRatings'),
      }(name='HTTPRedirect', description='The HTTP redirection rule.'),
      mirror?: {
        host?: string(name='Host', description='The name of the service defined in the service registry.', example='reviews.default.svc.cluster.local'),
        subset?: string(name='Subset', description='The name of the service subset.', example='v1'),
      }(name='Mirror', description='The configurations for mirroring HTTP traffic to another destination in addition to forwarding requests to the specified destination.'),
      mirrorPercentage?: {
        value?: float(name='Value', description='The percentage of requests that are mirrored to another destination except for the original destination, which is expressed as a decimal.', example='0.2'),
      }(name='MirrorPercentage', description='The percentage of requests that are mirrored to another destination except for the original destination.'),
      retries?: {
        attempts?: int32(name='Attempts', description='The number of retries allowed for a request.', example='3'),
        perTryTimeout?: string(name='PerTryTimeout', description='The timeout period for each retry.', example='2s'),
        retryOn?: string(name='RetryOn', description='The condition for retries. Example: `connect-failure,refused-stream,503`.', example='connect-failure,refused-stream,503'),
        retryRemoteLocalities?: {
          value?: boolean(name='Value', description='Specifies whether to allow retries to other localities. Valid values:

*   `true`
*   `false`

Default value: `false`.', example='false'),
        }(name='RetryRemoteLocalities', description='Specifies whether to allow retries to other localities.'),
      }(name='Retries', description='The configurations of retries for failed requests.'),
      rewrite?: {
        authority?: string(name='Authority', description='The value to be used to overwrite the value of the Authority or Host header.', example='newratings.default.svc.cluster.local'),
        uri?: string(name='Uri', description='The value to be used to overwrite the path or prefix of the URI.', example='/v1/getProductRatings'),
      }(name='Rewrite', description='The configurations for rewriting the virtual service.'),
      timeout?: string(name='Timeout', description='The timeout period for requests.', example='5s'),
    }(name='HTTPAdvancedOptions', description='The advanced settings for routing HTTP traffic.'),
    matchRequest?: {
      headers?: [ 
        {
          matchingContent?: string(name='MatchingContent', description='The header value to be matched.', example='v1'),
          matchingMode?: string(name='MatchingMode', description='The matching mode for the header value. Valid values:

*   `exact`: exact match
*   `prefix`: match by prefix
*   `regex`: match by regular expression', example='exact'),
          name?: string(name='Name', description='The header key to be matched.', example='x-request-id'),
        }
      ](name='Headers', description='The request headers to be matched.'),
      ports?: [ int32 ](name='Ports', description='The ports.'),
      TLSMatchAttributes?: [ 
        {
          SNIHosts?: [ string ](name='SNIHosts', description='The Server Name Indication (SNI) values to be matched.'),
          TLSPort?: int32(name='TLSPort', description='The TLS port.', example='443'),
        }
      ](name='TLSMatchAttributes', description='The matching rule for Transport Layer Security (TLS) traffic.'),
      URI?: {
        matchingContent?: string(name='MatchingContent', description='The content to be matched.', example='/ratings/v2/'),
        matchingMode?: string(name='MatchingMode', description='The matching mode for the routing rule. Valid values:

*   `exact`: exact match
*   `prefix`: match by prefix
*   `regex`: match by regular expression', example='prefix'),
      }(name='URI', description='The matching rule for URIs.'),
    }(name='MatchRequest', description='The matching rules for traffic routing.'),
    namespace?: string(name='Namespace', description='The namespace in which the destination service resides.', example='default'),
    rawVSRoute?: any(name='RawVSRoute'),
    routeDestinations?: [ 
      {
        destination?: {
          host?: string(name='Host', description='The name of the service defined in the service registry.', example='reviews'),
          port?: {
            number?: int32(name='Number', example='80'),
          }(name='Port'),
          subset?: string(name='Subset', description='The name of the service subset.', example='v1'),
        }(name='Destination', description='The unique endpoint of the destination service to which the specified requests are sent.'),
        weight?: int32(name='Weight', description='The weight of the service subset.', example='80'),
      }
    ](name='RouteDestinations', description='The endpoints of destination services for Layer 4 weighted routing.'),
    routeName?: string(name='RouteName', description='The name of the routing rule.', example='reviews-v2-routes'),
    routeType?: string(name='RouteType', description='The type of the traffic to be routed. Valid values: `HTTP`, `TLS`, and `TCP`.', example='HTTP'),
  }(name='GatewayRoute', description='The information about the routing rule to be updated for the ASM gateway.'),
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  priority?: int32(name='Priority', description='The priority of the routing rule. The value of this parameter is an integer. A smaller value indicates a higher priority.', example='1'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
  status?: int32(name='Status', description='The status of the routing rule. Valid values:

*   `0`: The routing rule is valid.
*   `1`: The routing rule is invalid.
*   `2`: An error occurs during the creation or update of the routing rule.', example='1'),
}

model UpdateIstioGatewayRoutesShrinkRequest {
  description?: string(name='Description', description='The description of the routing rule.', example='demo route'),
  gatewayRouteShrink?: string(name='GatewayRoute', description='The information about the routing rule to be updated for the ASM gateway.'),
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  priority?: int32(name='Priority', description='The priority of the routing rule. The value of this parameter is an integer. A smaller value indicates a higher priority.', example='1'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
  status?: int32(name='Status', description='The status of the routing rule. Valid values:

*   `0`: The routing rule is valid.
*   `1`: The routing rule is invalid.
*   `2`: An error occurs during the creation or update of the routing rule.', example='1'),
}

model UpdateIstioGatewayRoutesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model UpdateIstioGatewayRoutesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIstioGatewayRoutesResponseBody(name='body'),
}

async function updateIstioGatewayRoutesWithOptions(tmpReq: UpdateIstioGatewayRoutesRequest, runtime: Util.RuntimeOptions): UpdateIstioGatewayRoutesResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateIstioGatewayRoutesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.gatewayRoute)) {
    request.gatewayRouteShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.gatewayRoute, 'GatewayRoute', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.gatewayRouteShrink)) {
    body['GatewayRoute'] = request.gatewayRouteShrink;
  }
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.priority)) {
    body['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIstioGatewayRoutes',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateIstioGatewayRoutes(request: UpdateIstioGatewayRoutesRequest): UpdateIstioGatewayRoutesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIstioGatewayRoutesWithOptions(request, runtime);
}

model UpdateIstioInjectionConfigRequest {
  dataPlaneMode?: string(name='DataPlaneMode'),
  enableIstioInjection?: boolean(name='EnableIstioInjection', description='Specifies whether to enable Istio automatic sidecar injection.', example='true'),
  enableSidecarSetInjection?: boolean(name='EnableSidecarSetInjection', description='Specifies whether to enable automatic sidecar injection by using SidecarSet.', example='false'),
  istioRev?: string(name='IstioRev', description='Specifies the version to be injected into the namespace. This parameter is valid only when the ASM instance performs a canary release. When IstioRev is not empty, you must not specify EnableIstioInjection and EnableSidecarSetInjection.', example='canary'),
  namespace?: string(name='Namespace', description='The namespace for which you want to modify the sidecar injection setting.', example='default'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='ce2cdbb9d013f447180cf5ca8bb******'),
}

model UpdateIstioInjectionConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='98B268E6-9381-5A98-8012-6E7E82******'),
}

model UpdateIstioInjectionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIstioInjectionConfigResponseBody(name='body'),
}

async function updateIstioInjectionConfigWithOptions(request: UpdateIstioInjectionConfigRequest, runtime: Util.RuntimeOptions): UpdateIstioInjectionConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataPlaneMode)) {
    body['DataPlaneMode'] = request.dataPlaneMode;
  }
  if (!Util.isUnset(request.enableIstioInjection)) {
    body['EnableIstioInjection'] = request.enableIstioInjection;
  }
  if (!Util.isUnset(request.enableSidecarSetInjection)) {
    body['EnableSidecarSetInjection'] = request.enableSidecarSetInjection;
  }
  if (!Util.isUnset(request.istioRev)) {
    body['IstioRev'] = request.istioRev;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIstioInjectionConfig',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateIstioInjectionConfig(request: UpdateIstioInjectionConfigRequest): UpdateIstioInjectionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIstioInjectionConfigWithOptions(request, runtime);
}

model UpdateIstioRouteAdditionalStatusRequest {
  description?: string(name='Description', description='The description of the routing rule.', example='demo route'),
  istioGatewayName?: string(name='IstioGatewayName', description='The name of the ASM gateway.', example='ingressgateway'),
  priority?: int32(name='Priority', description='The priority of the routing rule. The value of this parameter is an integer. A smaller value indicates a higher priority.', example='0'),
  routeName?: string(name='RouteName', description='The name of the routing rule.', example='http-test'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
  status?: int32(name='Status', description='The status of the routing rule. Valid values:

*   `0`: The routing rule is valid.
*   `1`: The routing rule is invalid.
*   `2`: An error occurs during the creation or update of the routing rule.', example='0'),
}

model UpdateIstioRouteAdditionalStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model UpdateIstioRouteAdditionalStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIstioRouteAdditionalStatusResponseBody(name='body'),
}

async function updateIstioRouteAdditionalStatusWithOptions(request: UpdateIstioRouteAdditionalStatusRequest, runtime: Util.RuntimeOptions): UpdateIstioRouteAdditionalStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.routeName)) {
    query['RouteName'] = request.routeName;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIstioRouteAdditionalStatus',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateIstioRouteAdditionalStatus(request: UpdateIstioRouteAdditionalStatusRequest): UpdateIstioRouteAdditionalStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIstioRouteAdditionalStatusWithOptions(request, runtime);
}

model UpdateMeshCRAggregationRequest {
  CPULimit?: string(name='CPULimit', description='The maximum number of CPU cores that are available for the components installed in the ACK cluster on the data plane if you enable the Kubernetes API to access Istio resources in the ASM instance. You can specify the parameter value in the standard quantity representation used by Kubernetes.', example='1'),
  CPURequirement?: string(name='CPURequirement', description='The number of CPU cores that are requested by the components installed in the Container Service for Kubernetes (ACK) cluster on the data plane if you enable the Kubernetes API to access Istio resources in the ASM instance. You can specify the parameter value in the standard quantity representation used by Kubernetes.', example='1'),
  enabled?: boolean(name='Enabled', description='Specifies whether to enable the Kubernetes API on the data plane to access Istio resources in the ASM instance. Valid values:

*   `true`: enables the Kubernetes API to access Istio resources in the ASM instance.
*   `false`: does not enable the Kubernetes API to access Istio resources in the ASM instance.', example='true'),
  memoryLimit?: string(name='MemoryLimit', description='The maximum size of the memory that is available for the components installed in the ACK cluster on the data plane if you enable the Kubernetes API to access Istio resources in the ASM instance. You can specify the parameter value in the standard quantity representation used by Kubernetes. 1 Mi equals 1,024 KB.', example='500Mi'),
  memoryRequirement?: string(name='MemoryRequirement', description='The size of the memory that is requested by the components installed in the ACK cluster on the data plane if you enable the Kubernetes API to access Istio resources in the ASM instance. You can specify the parameter value in the standard quantity representation used by Kubernetes. 1 Mi equals 1,024 KB.', example='500Mi'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the Alibaba Cloud Service Mesh (ASM) instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
  usePublicApiServer?: boolean(name='UsePublicApiServer', description='Specifies whether the Kubernetes API on the data plane uses the public endpoint of the API server to access Istio resources in the ASM instance. Valid values:

*   `true`: The Kubernetes API on the data plane uses the public endpoint of the API server to access Istio resources in the ASM instance.
*   `false`: The Kubernetes API on the data plane uses the private endpoint of the API server to access Istio resources in the ASM instance.

Default value: `false`.', example='false'),
}

model UpdateMeshCRAggregationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model UpdateMeshCRAggregationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMeshCRAggregationResponseBody(name='body'),
}

async function updateMeshCRAggregationWithOptions(request: UpdateMeshCRAggregationRequest, runtime: Util.RuntimeOptions): UpdateMeshCRAggregationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.CPULimit)) {
    body['CPULimit'] = request.CPULimit;
  }
  if (!Util.isUnset(request.CPURequirement)) {
    body['CPURequirement'] = request.CPURequirement;
  }
  if (!Util.isUnset(request.enabled)) {
    body['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.memoryLimit)) {
    body['MemoryLimit'] = request.memoryLimit;
  }
  if (!Util.isUnset(request.memoryRequirement)) {
    body['MemoryRequirement'] = request.memoryRequirement;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.usePublicApiServer)) {
    body['UsePublicApiServer'] = request.usePublicApiServer;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMeshCRAggregation',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMeshCRAggregation(request: UpdateMeshCRAggregationRequest): UpdateMeshCRAggregationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMeshCRAggregationWithOptions(request, runtime);
}

model UpdateMeshFeatureRequest {
  accessLogEnabled?: boolean(name='AccessLogEnabled', description='Specifies whether to enable access log collection. Valid values:

*   `true`: enables access log collection.
*   `false`: disables access log collection.

Default value: `false`.', example='false'),
  accessLogFile?: string(name='AccessLogFile', description='Specifies whether to enable access logging. Valid values:

*   `""`: disables access logging.
*   `/dev/stdout`: enables access logging. Access logs are written to /dev/stdout.', example='“”'),
  accessLogFormat?: string(name='AccessLogFormat', description='The custom format of access logs. To set this parameter, make sure that you have enabled access log collection. The value must be a JSON string. The following key names must be contained: authority_for, bytes_received, bytes_sent, downstream_local_address, downstream_remote_address, duration, istio_policy_status, method, path, protocol, requested_server_name, response_code, response_flags, route_name, start_time, trace_id, upstream_cluster, upstream_host, upstream_local_address, upstream_service_time, upstream_transport_failure_reason, user_agent, and x_forwarded_for.', example='{"authority_for":"%REQ(:AUTHORITY)%","bytes_received":"%BYTES_RECEIVED%","bytes_sent":"%BYTES_SENT%","downstream_local_address":"%DOWNSTREAM_LOCAL_ADDRESS%","downstream_remote_address":"%DOWNSTREAM_REMOTE_ADDRESS%","duration":"%DURATION%","istio_policy_status":"%DYNAMIC_METADATA(istio.mixer:status)%","method":"%REQ(:METHOD)%","path":"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%","protocol":"%PROTOCOL%","request_id":"%REQ(X-REQUEST-ID)%","requested_server_name":"%REQUESTED_SERVER_NAME%","response_code":"%RESPONSE_CODE%","response_flags":"%RESPONSE_FLAGS%","route_name":"%ROUTE_NAME%","start_time":"%START_TIME%","trace_id":"%REQ(X-B3-TRACEID)%","upstream_cluster":"%UPSTREAM_CLUSTER%","upstream_host":"%UPSTREAM_HOST%","upstream_local_address":"%UPSTREAM_LOCAL_ADDRESS%","upstream_service_time":"%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)%","upstream_transport_failure_reason":"%UPSTREAM_TRANSPORT_FAILURE_REASON%","user_agent":"%REQ(USER-AGENT)%","x_forwarded_for":"%REQ(X-FORWARDED-FOR)%"}'),
  accessLogGatewayEnabled?: boolean(name='AccessLogGatewayEnabled'),
  accessLogGatewayLifecycle?: int32(name='AccessLogGatewayLifecycle', description='The retention period for the access logs of the sidecar proxy. Unit: day. The logs are collected by using Log Service. For example, `30` indicates 30 days.', example='30'),
  accessLogProject?: string(name='AccessLogProject', description='The custom project on which the Log Service collects logs.', example='mesh-log-cf245a429b6ff4b6e97f20797758e****'),
  accessLogServiceEnabled?: boolean(name='AccessLogServiceEnabled', description='Specifies whether to enable gRPC Access Log Service (ALS) for Envoy. Valid values:

*   `true`: enables gRPC ALS for Envoy.
*   `false`: disables gRPC ALS for Envoy.

Default value: `false`.', example='false'),
  accessLogServiceHost?: string(name='AccessLogServiceHost', description='The endpoint of gRPC ALS for Envoy.', example='0.0.0.0'),
  accessLogServicePort?: int32(name='AccessLogServicePort', description='The port of gRPC ALS for Envoy.', example='9999'),
  accessLogSidecarEnabled?: boolean(name='AccessLogSidecarEnabled'),
  accessLogSidecarLifecycle?: int32(name='AccessLogSidecarLifecycle', description='Specifies whether to enable automatic diagnostics for the ASM instance. If you enable this feature, the ASM instance is automatically diagnosed when you modify Istio resources in the ASM instance.', example='30'),
  auditProject?: string(name='AuditProject', description='The name of the Log Service project that is used for mesh audit.

Default value: `mesh-log-{ASM instance ID}`.', example='mesh-log-c08ba3fd1e64xxb0f8cc1ad8****'),
  autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled', description='Specifies whether to enable automatic sidecar proxy injection by using pod annotations. Valid values:

*   `true`: enables automatic sidecar proxy injection by using pod annotations.
*   `false`: disables automatic sidecar proxy injection by using pod annotations.

Default value: `false`.', example='false'),
  CRAggregationEnabled?: boolean(name='CRAggregationEnabled', description='Specifies whether to use the Kubernetes API of clusters on the data plane to access Istio resources. To use this feature, the version of the ASM instance must be V1.9.7.93 or later.', example='false'),
  clusterSpec?: string(name='ClusterSpec', description='Specifies whether to enable the feature of controlling the OPA injection scope. Valid values:

*   `true`: enables the feature.
*   `false`: disables the feature.', example='standard'),
  cniEnabled?: boolean(name='CniEnabled', description='Specifies whether to enable the Container Network Interface (CNI) plug-in. Valid values:

*   `true`: enables the CNI plug-in.
*   `false`: disables the CNI plug-in.

Default value: `false`.', example='false'),
  cniExcludeNamespaces?: string(name='CniExcludeNamespaces', description='The namespaces to be excluded for the CNI plug-in.', example='kube-system'),
  concurrency?: int32(name='Concurrency', description='Specifies whether to delay application container startup until the sidecar proxy container is started in a pod.', example='2'),
  configSourceEnabled?: boolean(name='ConfigSourceEnabled', description='Specifies whether to enable the external service registry. Valid values:

*   `true`: enables the external service registry.
*   `false`: disables the external service registry.

Default value: `false`.', example='false'),
  configSourceNacosID?: string(name='ConfigSourceNacosID', description='The instance ID of the Nacos registry.', example='mse-cn-tl326******'),
  customizedPrometheus?: boolean(name='CustomizedPrometheus', description='Specifies whether to use a custom Prometheus instance. Valid values:

*   `true`: uses a custom Prometheus instance.
*   `false`: does not use a custom Prometheus instance.

Default value: `false`.', example='false'),
  customizedZipkin?: boolean(name='CustomizedZipkin', description='Specifies whether to use a self-managed Zipkin system to collect tracing data. Valid values:

*   `true`: uses a self-managed Zipkin system.
*   `false`: does not use a self-managed Zipkin system.

Default value: `false`.', example='false'),
  DNSProxyingEnabled?: boolean(name='DNSProxyingEnabled', description='Specifies whether to enable DNS proxy. Valid values:

*   `true`: enables the DNS proxy feature.
*   `false`: disables the DNS proxy feature.

Default value: `false`.', example='false'),
  defaultComponentsScheduleConfig?: string(name='DefaultComponentsScheduleConfig', description='Specifies the default scheduling configurations that ASM delivers to components on the data plane. You can configure `nodeSelector` and `tolerations` in the JSON format.

> 

*   Modifying the value of this parameter is a high-risk operation. The modification will cause all components on the data plane of ASM to restart. Exercise caution before modifying the value of this parameter.

*   The configurations specified by this parameter do not apply to the ASM gateway. You can configure gateway-specific scheduling on the ASM gateway.', example='{"tolerations":[{"key":"test-taints", "operator":"Exists", "effect":"NoSchedule"}], "nodeSelector":{"kubernetes.io/hostname":"test-nodes"}}'),
  discoverySelectors?: string(name='DiscoverySelectors', description='The label selectors used to specify the namespaces of the clusters on the data plane for selective service discovery.', example='[{"matchExpressions":[{"key":"asm-discovery","operator":"Exists"}]}]'),
  dubboFilterEnabled?: boolean(name='DubboFilterEnabled', description='Specifies whether to enable Dubbo Filter. Valid values:

*   `true`: enables Dubbo Filter.
*   `false`: disables Dubbo Filter.

Default value: `false`.', example='false'),
  enableAudit?: boolean(name='EnableAudit', description='Specifies whether to enable the mesh audit feature. To enable this feature, make sure that you have activated [Log Service](https://sls.console.aliyun.com/). Valid values:

*   `true`: enables the mesh audit feature.
*   `false`: disables the mesh audit feature.

Default value: `false`.', example='false'),
  enableAutoDiagnosis?: boolean(name='EnableAutoDiagnosis', description='The ports for which outbound traffic is redirected to the sidecar proxy.', example='true'),
  enableBootstrapXdsAgent?: boolean(name='EnableBootstrapXdsAgent', description='Specifies the authentication token of an ARMS Prometheus instance when the Mesh Topology feature is enabled and ARMS Prometheus is used to collect monitoring metrics. The token is used to allow Mesh Topology to access the ARMS Prometheus instance. The token is in the JSON format. The key in the JSON object is the ID of the cluster on the data plane, and the value is the authentication token of the ARMS Prometheus instance deployed in the cluster.', example='true'),
  enableCRHistory?: boolean(name='EnableCRHistory', description='Specifies whether to enable the rollback feature for Istio resources.', example='false'),
  enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault', description='Specifies whether to enable automatic sidecar proxy injection for all namespaces. Valid values:

*   `true`: enables automatic sidecar proxy injection for all namespaces.
*   `false`: disables automatic sidecar proxy injection for all namespaces.

Default value: `false`.', example='false'),
  enableSDSServer?: boolean(name='EnableSDSServer', description='Specifies whether to enable Secret Discovery Service (SDS). Valid values:

*   `true`: enables SDS.
*   `false`: disables SDS.

Default value: `false`.', example='false'),
  excludeIPRanges?: string(name='ExcludeIPRanges', description='The IP addresses of external services to which traffic is not intercepted.', example='100.100.XXX.XXX'),
  excludeInboundPorts?: string(name='ExcludeInboundPorts', description='The ports for which inbound traffic is not redirected to the sidecar proxy. Separate multiple ports with commas (,).', example='80,81'),
  excludeOutboundPorts?: string(name='ExcludeOutboundPorts', description='The ports for which outbound traffic is not redirected to the sidecar proxy. Separate multiple ports with commas (,).', example='80,81'),
  filterGatewayClusterConfig?: boolean(name='FilterGatewayClusterConfig', description='Specifies whether to enable gateway configuration filtering. Valid values:

*   `true`: enables gateway configuration filtering.
*   `false`: disables gateway configuration filtering.

Default value: `false`.', example='false'),
  gatewayAPIEnabled?: boolean(name='GatewayAPIEnabled', description='Specifies whether to enable Gateway API. Valid values:

*   `true`: enables Gateway API.
*   `false`: disables Gateway API.

Default value: `false`.', example='false'),
  holdApplicationUntilProxyStarts?: boolean(name='HoldApplicationUntilProxyStarts', description='Other metrics of the sidecar proxy on the data plane.', example='true'),
  http10Enabled?: boolean(name='Http10Enabled', description='Specifies whether to support HTTP 1.0. Valid values:

*   `true`: supports HTTP 1.0.
*   `false`: does not support HTTP 1.0.

Default value: `false`.', example='false'),
  includeIPRanges?: string(name='IncludeIPRanges', description='The IP addresses of external services to which traffic is intercepted.', example='*'),
  includeInboundPorts?: string(name='IncludeInboundPorts', description='The ports for which inbound traffic is redirected to the sidecar proxy.', example='80,81'),
  includeOutboundPorts?: string(name='IncludeOutboundPorts', description='The log level of the sidecar proxy on the data plane. Log levels include `none`, `error`, `warn`, `info`, and `debug`. The levels correspond to different amounts of information reported by the logs. For example, none-level logs report the least information, while debug-level logs report the most information.', example='8000,8001'),
  integrateKiali?: boolean(name='IntegrateKiali', description='Specifies whether to enable Node Feature Discovery (NFD).', example='false'),
  interceptionMode?: string(name='InterceptionMode', description='Specifies whether to load the bootstrap configuration before the sidecar proxy is started.', example='TPROXY'),
  kialiArmsAuthTokens?: string(name='KialiArmsAuthTokens', description='Specifies the default scheduling configurations that ASM delivers to components on the data plane. You can configure `nodeSelector` and tolerations in the JSON format.

> *   Modifying the value of this parameter is a high-risk operation. The modification will cause all components on the data plane of ASM to restart. Exercise caution before modifying the value of this parameter.
>*   The configurations specified by this parameter do not apply to the ASM gateway. You can configure gateway-specific scheduling on the ASM gateway.', example='{"c31e3b******5634b":"token_example"}'),
  kialiEnabled?: boolean(name='KialiEnabled', description='Specifies whether to enable the Mesh Topology feature. To enable this feature, make sure that you have enabled Prometheus monitoring. If Prometheus monitoring is disabled, the Mesh Topology feature must be disabled. Valid values:````

*   `true`: enables the Mesh Topology feature.
*   `false`: disables the Mesh Topology feature.

Default value: `false`.', example='false'),
  kialiServiceAnnotations?: string(name='KialiServiceAnnotations', description='Specifies Classic Load Balancer (CLB) instances by using annotations when the Mesh Topology feature is enabled. These CLB instances are used to access the Mesh Topology feature in different clusters.

This parameter is a JSON-encoded string. The key in the JSON object is the ID of a cluster on the data plane, and the value is the annotation content of the Mesh Topology service in the cluster.

For more information about how to configure CLB instances by using annotations, see [Add annotations to the YAML file of a Service to configure CLB instances](https://www.alibabacloud.com/help/container-service-for-kubernetes/latest/use-annotations-to-configure-load-balancing-1).', example='{"c31e3b******5634b":{"service.beta.kubernetes.io/alibaba-cloud-loadbalancer-address-type":"intranet"}}'),
  lifecycle?: string(name='Lifecycle', description='The lifecycle of the sidecar proxy.', example='{"postStart":{"exec":{"command":["pilot-agent","wait"]}},"preStop":{"exec":{"command":["/bin/sh","-c","sleep 15"]}}}'),
  localityLBConf?: string(name='LocalityLBConf', description='The configurations of cross-region load balancing. Valid values:

*   `failover`: the configurations of cross-region failover. Example:

<!---->

    failover: [// Cross-region failover configurations of the struct type. 
            {
                // If a service fails in the China (Beijing) region, the traffic is redirected to the same service in the China (Hangzhou) region. 
                from: "cn-beijing", 
                to: "cn-hangzhou",
            }
        ]

*   `distribute`: the configurations of cross-region traffic distribution. Example:

<!---->

    distribute: [// Cross-region traffic distribution configurations of the struct type. 
            {
                // For traffic that is routed to the China (Beijing) region, 70% of the traffic is allocated to the China (Beijing) region and the rest of the traffic is redirected to the China (Hangzhou) region. 
                "from": "cn-beijing",
                "to": {
                    "cn-beijing": 70,
                    "cn-hangzhou": 30,
                }
            }
        ]', example='{"failover":[{"from":"cn-hangzhou","to":"cn-shanghai"}]}'),
  localityLoadBalancing?: boolean(name='LocalityLoadBalancing', description='Specifies whether to enable cross-region load balancing. Valid values:

*   `true`: enables cross-region load balancing.
*   `false`: disables cross-region load balancing.

Default value: `false`.', example='true'),
  logLevel?: string(name='LogLevel', description='The number of worker threads used by the sidecar proxy on the data plane.', example='info'),
  MSEEnabled?: boolean(name='MSEEnabled', description='Specifies whether to enable Microservice Engine (MSE). Valid values:

*   `true`: enables MSE.
*   `false`: disables MSE.

Default value: `false`.', example='false'),
  multiBufferEnabled?: boolean(name='MultiBufferEnabled', description='Specifies whether to enable Transport Layer Security (TLS) acceleration based on MultiBuffer.', example='false'),
  multiBufferPollDelay?: string(name='MultiBufferPollDelay', description='The pull-request latency. By default, this parameter is left empty.', example='0.02s'),
  mysqlFilterEnabled?: boolean(name='MysqlFilterEnabled', description='Specifies whether to enable MySQL Filter. Valid values:

*   `true`: enables MySQL Filter.
*   `false`: disables MySQL Filter.

Default value: `false`.', example='false'),
  NFDEnabled?: boolean(name='NFDEnabled', description='Specifies whether to clear feature labels on nodes when NFD is disabled.

This parameter is valid only when the `NFDEnabled` parameter is set to `false`.', example='false'),
  NFDLabelPruned?: boolean(name='NFDLabelPruned', description='The minimum number of CPU cores requested by the proxy service that exports Tracing Analysis data. For example, `1000m` indicates one CPU core.', example='false'),
  OPAInjectorCPULimit?: string(name='OPAInjectorCPULimit', description='The maximum size of the memory that is available to the pod that injects OPA proxies into application pods. For example, `1024Mi` indicates 1024 MB.', example='1000m'),
  OPAInjectorCPURequirement?: string(name='OPAInjectorCPURequirement', description='The minimum size of the memory requested by the pod that injects OPA proxies into application pods. For example, `50 Mi` indicates 50 MB.', example='80m'),
  OPAInjectorMemoryLimit?: string(name='OPAInjectorMemoryLimit', description='Specifies whether to create an SLB instance for accessing the ASM mesh topology.', example='1024Mi'),
  OPAInjectorMemoryRequirement?: string(name='OPAInjectorMemoryRequirement', description='The maximum number of CPU cores that are available to the pod that injects OPA proxies into application pods. For example, `1000m` indicates one CPU core.', example='50Mi'),
  OPALimitCPU?: string(name='OPALimitCPU', description='The maximum number of CPU cores that are available to the OPA proxy container.', example='2'),
  OPALimitMemory?: string(name='OPALimitMemory', description='The maximum size of the memory that is available to the OPA proxy container.', example='1024Mi'),
  OPALogLevel?: string(name='OPALogLevel', description='The log level of the OPA proxy container.

*   `info`: outputs all information.
*   `debug`: outputs debugging and error information.
*   `error`: outputs only error information.', example='info'),
  OPARequestCPU?: string(name='OPARequestCPU', description='The number of CPU cores that are requested by the OPA proxy container.', example='1'),
  OPARequestMemory?: string(name='OPARequestMemory', description='The size of the memory that is requested by the OPA proxy container.', example='512Mi'),
  OPAScopeInjected?: boolean(name='OPAScopeInjected', description='The minimum number of CPU cores requested by the pod that injects OPA proxies into application pods. For example, `1000m` indicates one CPU core.', example='false'),
  opaEnabled?: boolean(name='OpaEnabled', description='Specifies whether to enable the OPA plug-in. Valid values:

*   `true`: enables the OPA plug-in.
*   `false`: disables the OPA plug-in.

Default value: `false`.', example='false'),
  openAgentPolicy?: boolean(name='OpenAgentPolicy', description='Specifies whether to install the Open Policy Agent (OPA) plug-in. Valid values:

*   `true`: installs the OPA plug-in.
*   `false`: does not install the OPA plug-in.

Default value: `false`.', example='false'),
  outboundTrafficPolicy?: string(name='OutboundTrafficPolicy', description='The policy for accessing external services. Valid values:

*   `ALLOW_ANY`: allows access to all external services.
*   `REGISTRY_ONLY`: allows access to only the external services that are defined in the ServiceEntry of the ASM instance.', example='ALLOW_ANY'),
  prometheusUrl?: string(name='PrometheusUrl', description='The endpoint of Prometheus monitoring. If you use ARMS Prometheus, set this parameter to the endpoint of Prometheus provided by ARMS.', example='http://prometheus:9090'),
  proxyInitCPUResourceLimit?: string(name='ProxyInitCPUResourceLimit', description='The maximum number of CPU cores that are available to the istio-init container.', example='2000m'),
  proxyInitCPUResourceRequest?: string(name='ProxyInitCPUResourceRequest', description='The number of CPU cores that are requested by the istio-init container.', example='10m'),
  proxyInitMemoryResourceLimit?: string(name='ProxyInitMemoryResourceLimit', description='The maximum size of the memory that is available to the istio-init container.', example='1024Mi'),
  proxyInitMemoryResourceRequest?: string(name='ProxyInitMemoryResourceRequest', description='The size of the memory that is requested by the istio-init container.', example='10Mi'),
  proxyLimitCPU?: string(name='ProxyLimitCPU', description='The maximum number of CPU cores that are available to the sidecar proxy container.', example='2000m'),
  proxyLimitMemory?: string(name='ProxyLimitMemory', description='The maximum size of the memory that is available to the sidecar proxy container.', example='1024Mi'),
  proxyRequestCPU?: string(name='ProxyRequestCPU', description='The number of CPU cores that are requested by the sidecar proxy container.', example='100m'),
  proxyRequestMemory?: string(name='ProxyRequestMemory', description='The size of the memory that is requested by the sidecar proxy container.', example='128Mi'),
  proxyStatsMatcher?: string(name='ProxyStatsMatcher', description='The mode in which the sidecar proxy intercepts inbound traffic. Valid values:

*   `REDIRECT`: The sidecar proxy intercepts inbound traffic in the REDIRECT mode.
*   `TPROXY`: The sidecar proxy intercepts inbound traffic in the TPROXY mode.', example='{"inclusionRegexps":".*adaptive_concurrency.*"}'),
  redisFilterEnabled?: boolean(name='RedisFilterEnabled', description='Specifies whether to enable Redis Filter. Valid values:

*   `true`: enables Redis Filter.
*   `false`: disables Redis Filter.

Default value: `false`.', example='false'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='cb8963379255149cb98c8686f274x****'),
  sidecarInjectorLimitCPU?: string(name='SidecarInjectorLimitCPU', description='The maximum number of CPU cores that are available to the pod where a sidecar proxy injector resides.', example='4000m'),
  sidecarInjectorLimitMemory?: string(name='SidecarInjectorLimitMemory', description='The maximum size of the memory that is available to the pod where a sidecar proxy injector resides.', example='2048Mi'),
  sidecarInjectorRequestCPU?: string(name='SidecarInjectorRequestCPU', description='The number of CPU cores that are requested by the pod where a sidecar proxy injector resides.', example='1000m'),
  sidecarInjectorRequestMemory?: string(name='SidecarInjectorRequestMemory', description='The size of the memory that is requested by the pod where a sidecar proxy injector resides.', example='512Mi'),
  sidecarInjectorWebhookAsYaml?: string(name='SidecarInjectorWebhookAsYaml', description='Other configurations of automatic sidecar proxy injection, in the YAML format.', example='{"injectedAnnotations":{"test/istio-init":"runtime/default2","test/istio-proxy":"runtime/default"},"replicaCount":2,"nodeSelector":{"beta.kubernetes.io/os":"linux"}}'),
  telemetry?: boolean(name='Telemetry', description='Specifies whether to enable Prometheus monitoring. We recommend that you enable [ARMS Prometheus](https://arms.console.aliyun.com/). Valid values:

*   `true`: enables Prometheus monitoring.
*   `false`: disables Prometheus monitoring.

Default value: `false`.', example='false'),
  terminationDrainDuration?: string(name='TerminationDrainDuration', description='The maximum period of time that the sidecar proxy waits for requests to be processed before the proxy is stopped. For example, if you want to specify a period of 5 seconds, set this parameter to 5s.', example='5s'),
  thriftFilterEnabled?: boolean(name='ThriftFilterEnabled', description='Specifies whether to enable Thrift Filter. Valid values:

*   `true`: enables Thrift Filter.
*   `false`: disables Thrift Filter.

Default value: `false`.', example='false'),
  traceCustomTags?: string(name='TraceCustomTags', description='The custom tag of Tracing Analysis. Specify this parameter in the JSON format.

    {
        "name1": CustomTag,
        "name2": CustomTag
    }

Tag key: literal, header, or environment.

    {
        "literal": {
            "value": "Fixed value"
        }
        "header": {
            "name": "Header name"
            "defaultValue": "Default value that is used if the specified header does not exist"
        }
        "environment": {
            "name": "Environment variable name"
            "defaultValue": "Default value that is used if the specified environment variable does not exist"
        }
    }', example='{"mytag": {"literal":{"value":"test"}}}'),
  traceMaxPathTagLength?: string(name='TraceMaxPathTagLength', description='The maximum length of the request path contained in the HttpUrl span tag. Default value: `256`.', example='256'),
  traceSampling?: float(name='TraceSampling', description='The sampling percentage of Tracing Analysis.', example='100'),
  tracing?: boolean(name='Tracing', description='Specifies whether to enable the Tracing Analysis feature. To enable this feature, make sure that you have activated [Tracing Analysis](https://tracing-analysis.console.aliyun.com/). Valid values:

*   `true`: enables the Tracing Analysis feature.
*   `false`: disables the Tracing Analysis feature.

Default value: `false`.', example='false'),
  tracingOnExtZipkinLimitCPU?: string(name='TracingOnExtZipkinLimitCPU', description='The maximum size of the memory that is available to the proxy service that exports Tracing Analysis data. For example, `1Mi` indicates 1 MB.', example='1000Mi'),
  tracingOnExtZipkinLimitMemory?: string(name='TracingOnExtZipkinLimitMemory', description='The retention period for the access logs of the ingress gateway. Unit: day. The logs are collected by using Log Service. For example, `30` indicates 30 days.', example='1024Mi'),
  tracingOnExtZipkinRequestCPU?: string(name='TracingOnExtZipkinRequestCPU', description='The minimum size of the memory requested by the proxy service that exports Tracing Analysis data. For example, `1Mi` indicates 1 MB.', example='200m'),
  tracingOnExtZipkinRequestMemory?: string(name='TracingOnExtZipkinRequestMemory', description='The maximum number of CPU cores that are available to the proxy service that exports Tracing Analysis data. For example, `1000m` indicates one CPU core.', example='200Mi'),
  webAssemblyFilterEnabled?: boolean(name='WebAssemblyFilterEnabled', description='Specifies whether to enable WebAssembly Filter. Valid values:

*   `true`: enables WebAssembly Filter.
*   `false`: disables WebAssembly Filter.

Default value: `false`.', example='false'),
}

model UpdateMeshFeatureResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BD65C0AD-D3C6-48D3-8D93-38D2015C****'),
}

model UpdateMeshFeatureResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMeshFeatureResponseBody(name='body'),
}

async function updateMeshFeatureWithOptions(request: UpdateMeshFeatureRequest, runtime: Util.RuntimeOptions): UpdateMeshFeatureResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessLogGatewayEnabled)) {
    query['AccessLogGatewayEnabled'] = request.accessLogGatewayEnabled;
  }
  if (!Util.isUnset(request.accessLogSidecarEnabled)) {
    query['AccessLogSidecarEnabled'] = request.accessLogSidecarEnabled;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessLogEnabled)) {
    body['AccessLogEnabled'] = request.accessLogEnabled;
  }
  if (!Util.isUnset(request.accessLogFile)) {
    body['AccessLogFile'] = request.accessLogFile;
  }
  if (!Util.isUnset(request.accessLogFormat)) {
    body['AccessLogFormat'] = request.accessLogFormat;
  }
  if (!Util.isUnset(request.accessLogGatewayLifecycle)) {
    body['AccessLogGatewayLifecycle'] = request.accessLogGatewayLifecycle;
  }
  if (!Util.isUnset(request.accessLogProject)) {
    body['AccessLogProject'] = request.accessLogProject;
  }
  if (!Util.isUnset(request.accessLogServiceEnabled)) {
    body['AccessLogServiceEnabled'] = request.accessLogServiceEnabled;
  }
  if (!Util.isUnset(request.accessLogServiceHost)) {
    body['AccessLogServiceHost'] = request.accessLogServiceHost;
  }
  if (!Util.isUnset(request.accessLogServicePort)) {
    body['AccessLogServicePort'] = request.accessLogServicePort;
  }
  if (!Util.isUnset(request.accessLogSidecarLifecycle)) {
    body['AccessLogSidecarLifecycle'] = request.accessLogSidecarLifecycle;
  }
  if (!Util.isUnset(request.auditProject)) {
    body['AuditProject'] = request.auditProject;
  }
  if (!Util.isUnset(request.autoInjectionPolicyEnabled)) {
    body['AutoInjectionPolicyEnabled'] = request.autoInjectionPolicyEnabled;
  }
  if (!Util.isUnset(request.CRAggregationEnabled)) {
    body['CRAggregationEnabled'] = request.CRAggregationEnabled;
  }
  if (!Util.isUnset(request.clusterSpec)) {
    body['ClusterSpec'] = request.clusterSpec;
  }
  if (!Util.isUnset(request.cniEnabled)) {
    body['CniEnabled'] = request.cniEnabled;
  }
  if (!Util.isUnset(request.cniExcludeNamespaces)) {
    body['CniExcludeNamespaces'] = request.cniExcludeNamespaces;
  }
  if (!Util.isUnset(request.concurrency)) {
    body['Concurrency'] = request.concurrency;
  }
  if (!Util.isUnset(request.configSourceEnabled)) {
    body['ConfigSourceEnabled'] = request.configSourceEnabled;
  }
  if (!Util.isUnset(request.configSourceNacosID)) {
    body['ConfigSourceNacosID'] = request.configSourceNacosID;
  }
  if (!Util.isUnset(request.customizedPrometheus)) {
    body['CustomizedPrometheus'] = request.customizedPrometheus;
  }
  if (!Util.isUnset(request.customizedZipkin)) {
    body['CustomizedZipkin'] = request.customizedZipkin;
  }
  if (!Util.isUnset(request.DNSProxyingEnabled)) {
    body['DNSProxyingEnabled'] = request.DNSProxyingEnabled;
  }
  if (!Util.isUnset(request.defaultComponentsScheduleConfig)) {
    body['DefaultComponentsScheduleConfig'] = request.defaultComponentsScheduleConfig;
  }
  if (!Util.isUnset(request.discoverySelectors)) {
    body['DiscoverySelectors'] = request.discoverySelectors;
  }
  if (!Util.isUnset(request.dubboFilterEnabled)) {
    body['DubboFilterEnabled'] = request.dubboFilterEnabled;
  }
  if (!Util.isUnset(request.enableAudit)) {
    body['EnableAudit'] = request.enableAudit;
  }
  if (!Util.isUnset(request.enableAutoDiagnosis)) {
    body['EnableAutoDiagnosis'] = request.enableAutoDiagnosis;
  }
  if (!Util.isUnset(request.enableBootstrapXdsAgent)) {
    body['EnableBootstrapXdsAgent'] = request.enableBootstrapXdsAgent;
  }
  if (!Util.isUnset(request.enableCRHistory)) {
    body['EnableCRHistory'] = request.enableCRHistory;
  }
  if (!Util.isUnset(request.enableNamespacesByDefault)) {
    body['EnableNamespacesByDefault'] = request.enableNamespacesByDefault;
  }
  if (!Util.isUnset(request.enableSDSServer)) {
    body['EnableSDSServer'] = request.enableSDSServer;
  }
  if (!Util.isUnset(request.excludeIPRanges)) {
    body['ExcludeIPRanges'] = request.excludeIPRanges;
  }
  if (!Util.isUnset(request.excludeInboundPorts)) {
    body['ExcludeInboundPorts'] = request.excludeInboundPorts;
  }
  if (!Util.isUnset(request.excludeOutboundPorts)) {
    body['ExcludeOutboundPorts'] = request.excludeOutboundPorts;
  }
  if (!Util.isUnset(request.filterGatewayClusterConfig)) {
    body['FilterGatewayClusterConfig'] = request.filterGatewayClusterConfig;
  }
  if (!Util.isUnset(request.gatewayAPIEnabled)) {
    body['GatewayAPIEnabled'] = request.gatewayAPIEnabled;
  }
  if (!Util.isUnset(request.holdApplicationUntilProxyStarts)) {
    body['HoldApplicationUntilProxyStarts'] = request.holdApplicationUntilProxyStarts;
  }
  if (!Util.isUnset(request.http10Enabled)) {
    body['Http10Enabled'] = request.http10Enabled;
  }
  if (!Util.isUnset(request.includeIPRanges)) {
    body['IncludeIPRanges'] = request.includeIPRanges;
  }
  if (!Util.isUnset(request.includeInboundPorts)) {
    body['IncludeInboundPorts'] = request.includeInboundPorts;
  }
  if (!Util.isUnset(request.includeOutboundPorts)) {
    body['IncludeOutboundPorts'] = request.includeOutboundPorts;
  }
  if (!Util.isUnset(request.integrateKiali)) {
    body['IntegrateKiali'] = request.integrateKiali;
  }
  if (!Util.isUnset(request.interceptionMode)) {
    body['InterceptionMode'] = request.interceptionMode;
  }
  if (!Util.isUnset(request.kialiArmsAuthTokens)) {
    body['KialiArmsAuthTokens'] = request.kialiArmsAuthTokens;
  }
  if (!Util.isUnset(request.kialiEnabled)) {
    body['KialiEnabled'] = request.kialiEnabled;
  }
  if (!Util.isUnset(request.kialiServiceAnnotations)) {
    body['KialiServiceAnnotations'] = request.kialiServiceAnnotations;
  }
  if (!Util.isUnset(request.lifecycle)) {
    body['Lifecycle'] = request.lifecycle;
  }
  if (!Util.isUnset(request.localityLBConf)) {
    body['LocalityLBConf'] = request.localityLBConf;
  }
  if (!Util.isUnset(request.localityLoadBalancing)) {
    body['LocalityLoadBalancing'] = request.localityLoadBalancing;
  }
  if (!Util.isUnset(request.logLevel)) {
    body['LogLevel'] = request.logLevel;
  }
  if (!Util.isUnset(request.MSEEnabled)) {
    body['MSEEnabled'] = request.MSEEnabled;
  }
  if (!Util.isUnset(request.multiBufferEnabled)) {
    body['MultiBufferEnabled'] = request.multiBufferEnabled;
  }
  if (!Util.isUnset(request.multiBufferPollDelay)) {
    body['MultiBufferPollDelay'] = request.multiBufferPollDelay;
  }
  if (!Util.isUnset(request.mysqlFilterEnabled)) {
    body['MysqlFilterEnabled'] = request.mysqlFilterEnabled;
  }
  if (!Util.isUnset(request.NFDEnabled)) {
    body['NFDEnabled'] = request.NFDEnabled;
  }
  if (!Util.isUnset(request.NFDLabelPruned)) {
    body['NFDLabelPruned'] = request.NFDLabelPruned;
  }
  if (!Util.isUnset(request.OPAInjectorCPULimit)) {
    body['OPAInjectorCPULimit'] = request.OPAInjectorCPULimit;
  }
  if (!Util.isUnset(request.OPAInjectorCPURequirement)) {
    body['OPAInjectorCPURequirement'] = request.OPAInjectorCPURequirement;
  }
  if (!Util.isUnset(request.OPAInjectorMemoryLimit)) {
    body['OPAInjectorMemoryLimit'] = request.OPAInjectorMemoryLimit;
  }
  if (!Util.isUnset(request.OPAInjectorMemoryRequirement)) {
    body['OPAInjectorMemoryRequirement'] = request.OPAInjectorMemoryRequirement;
  }
  if (!Util.isUnset(request.OPALimitCPU)) {
    body['OPALimitCPU'] = request.OPALimitCPU;
  }
  if (!Util.isUnset(request.OPALimitMemory)) {
    body['OPALimitMemory'] = request.OPALimitMemory;
  }
  if (!Util.isUnset(request.OPALogLevel)) {
    body['OPALogLevel'] = request.OPALogLevel;
  }
  if (!Util.isUnset(request.OPARequestCPU)) {
    body['OPARequestCPU'] = request.OPARequestCPU;
  }
  if (!Util.isUnset(request.OPARequestMemory)) {
    body['OPARequestMemory'] = request.OPARequestMemory;
  }
  if (!Util.isUnset(request.OPAScopeInjected)) {
    body['OPAScopeInjected'] = request.OPAScopeInjected;
  }
  if (!Util.isUnset(request.opaEnabled)) {
    body['OpaEnabled'] = request.opaEnabled;
  }
  if (!Util.isUnset(request.openAgentPolicy)) {
    body['OpenAgentPolicy'] = request.openAgentPolicy;
  }
  if (!Util.isUnset(request.outboundTrafficPolicy)) {
    body['OutboundTrafficPolicy'] = request.outboundTrafficPolicy;
  }
  if (!Util.isUnset(request.prometheusUrl)) {
    body['PrometheusUrl'] = request.prometheusUrl;
  }
  if (!Util.isUnset(request.proxyInitCPUResourceLimit)) {
    body['ProxyInitCPUResourceLimit'] = request.proxyInitCPUResourceLimit;
  }
  if (!Util.isUnset(request.proxyInitCPUResourceRequest)) {
    body['ProxyInitCPUResourceRequest'] = request.proxyInitCPUResourceRequest;
  }
  if (!Util.isUnset(request.proxyInitMemoryResourceLimit)) {
    body['ProxyInitMemoryResourceLimit'] = request.proxyInitMemoryResourceLimit;
  }
  if (!Util.isUnset(request.proxyInitMemoryResourceRequest)) {
    body['ProxyInitMemoryResourceRequest'] = request.proxyInitMemoryResourceRequest;
  }
  if (!Util.isUnset(request.proxyLimitCPU)) {
    body['ProxyLimitCPU'] = request.proxyLimitCPU;
  }
  if (!Util.isUnset(request.proxyLimitMemory)) {
    body['ProxyLimitMemory'] = request.proxyLimitMemory;
  }
  if (!Util.isUnset(request.proxyRequestCPU)) {
    body['ProxyRequestCPU'] = request.proxyRequestCPU;
  }
  if (!Util.isUnset(request.proxyRequestMemory)) {
    body['ProxyRequestMemory'] = request.proxyRequestMemory;
  }
  if (!Util.isUnset(request.proxyStatsMatcher)) {
    body['ProxyStatsMatcher'] = request.proxyStatsMatcher;
  }
  if (!Util.isUnset(request.redisFilterEnabled)) {
    body['RedisFilterEnabled'] = request.redisFilterEnabled;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.sidecarInjectorLimitCPU)) {
    body['SidecarInjectorLimitCPU'] = request.sidecarInjectorLimitCPU;
  }
  if (!Util.isUnset(request.sidecarInjectorLimitMemory)) {
    body['SidecarInjectorLimitMemory'] = request.sidecarInjectorLimitMemory;
  }
  if (!Util.isUnset(request.sidecarInjectorRequestCPU)) {
    body['SidecarInjectorRequestCPU'] = request.sidecarInjectorRequestCPU;
  }
  if (!Util.isUnset(request.sidecarInjectorRequestMemory)) {
    body['SidecarInjectorRequestMemory'] = request.sidecarInjectorRequestMemory;
  }
  if (!Util.isUnset(request.sidecarInjectorWebhookAsYaml)) {
    body['SidecarInjectorWebhookAsYaml'] = request.sidecarInjectorWebhookAsYaml;
  }
  if (!Util.isUnset(request.telemetry)) {
    body['Telemetry'] = request.telemetry;
  }
  if (!Util.isUnset(request.terminationDrainDuration)) {
    body['TerminationDrainDuration'] = request.terminationDrainDuration;
  }
  if (!Util.isUnset(request.thriftFilterEnabled)) {
    body['ThriftFilterEnabled'] = request.thriftFilterEnabled;
  }
  if (!Util.isUnset(request.traceCustomTags)) {
    body['TraceCustomTags'] = request.traceCustomTags;
  }
  if (!Util.isUnset(request.traceMaxPathTagLength)) {
    body['TraceMaxPathTagLength'] = request.traceMaxPathTagLength;
  }
  if (!Util.isUnset(request.traceSampling)) {
    body['TraceSampling'] = request.traceSampling;
  }
  if (!Util.isUnset(request.tracing)) {
    body['Tracing'] = request.tracing;
  }
  if (!Util.isUnset(request.tracingOnExtZipkinLimitCPU)) {
    body['TracingOnExtZipkinLimitCPU'] = request.tracingOnExtZipkinLimitCPU;
  }
  if (!Util.isUnset(request.tracingOnExtZipkinLimitMemory)) {
    body['TracingOnExtZipkinLimitMemory'] = request.tracingOnExtZipkinLimitMemory;
  }
  if (!Util.isUnset(request.tracingOnExtZipkinRequestCPU)) {
    body['TracingOnExtZipkinRequestCPU'] = request.tracingOnExtZipkinRequestCPU;
  }
  if (!Util.isUnset(request.tracingOnExtZipkinRequestMemory)) {
    body['TracingOnExtZipkinRequestMemory'] = request.tracingOnExtZipkinRequestMemory;
  }
  if (!Util.isUnset(request.webAssemblyFilterEnabled)) {
    body['WebAssemblyFilterEnabled'] = request.webAssemblyFilterEnabled;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMeshFeature',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMeshFeature(request: UpdateMeshFeatureRequest): UpdateMeshFeatureResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMeshFeatureWithOptions(request, runtime);
}

model UpdateNamespaceScopeSidecarConfigRequest {
  concurrency?: int32(name='Concurrency', description='The number of worker threads to run in Istio Proxy.', example='2'),
  enableCoreDump?: boolean(name='EnableCoreDump'),
  excludeIPRanges?: string(name='ExcludeIPRanges', description='The range of IP addresses that are allowed to access external services. (`global.proxy.excludelPRanges`)', example='172.16.0.0/12'),
  excludeInboundPorts?: string(name='ExcludeInboundPorts', description='The port that the inbound traffic of the sidecar proxy does not pass through.', example='82'),
  excludeOutboundPorts?: string(name='ExcludeOutboundPorts', description='The port that the outbound traffic of the sidecar proxy does not pass through.', example='81'),
  holdApplicationUntilProxyStarts?: boolean(name='HoldApplicationUntilProxyStarts', description='Specifies whether applications can be started only after Istio Proxy starts. Valid values:

*   `true`: Applications can be started only after Istio Proxy starts.
*   `false`: Applications can be started before Istio Proxy starts.', example='true'),
  includeIPRanges?: string(name='IncludeIPRanges', description='The range of IP addresses that are denied to access external services. (`global.proxy.includelPRanges`)', example='*'),
  includeInboundPorts?: string(name='IncludeInboundPorts', description='The port that the inbound traffic of the sidecar proxy passes through.', example='83'),
  includeOutboundPorts?: string(name='IncludeOutboundPorts', description='The port that the outbound traffic of the sidecar proxy passes through.', example='84'),
  interceptionMode?: string(name='InterceptionMode', description='The mode in which the sidecar proxy intercepts inbound traffic. Valid values:

*   `REDIRECT`: The sidecar proxy intercepts inbound traffic in the REDIRECT mode.
*   `TPROXY`: The sidecar proxy intercepts inbound traffic in the TPROXY mode.', example='TPROXY'),
  istioDNSProxyEnabled?: boolean(name='IstioDNSProxyEnabled', description='Specifies whether to enable the Domain Name System (DNS) proxy feature. Valid values:

*   `true`: The DNS proxy feature is enabled.
*   `false`: The DNS proxy feature is disabled.', example='true'),
  lifecycle?: string(name='Lifecycle', description='The lifecycle of the sidecar proxy.', example='{"postStart":{"exec":{"command":["pilot-agent","wait"]}},"preStop":{"exec":{"command":["/bin/sh","-c","sleep 15"]}}}'),
  logLevel?: string(name='LogLevel', description='The log level. Valid values: `info`, `debug`, `tracing`, and `error`.', example='info'),
  namespace?: string(name='Namespace', description='The namespace for which you want to update the sidecar proxy configurations.', example='default'),
  postStart?: string(name='PostStart', description='The post-start parameters of Istio Proxy.', example='{"exec":{"command":["pilot-agent","wait"]}}'),
  preStop?: string(name='PreStop', description='The pre-close parameters of Istio Proxy.', example='{"exec":{"command":["/bin/sh","-c","sleep 15"]}}'),
  privileged?: boolean(name='Privileged'),
  proxyInitAckSloCPUResourceLimit?: string(name='ProxyInitAckSloCPUResourceLimit', example='2000'),
  proxyInitAckSloCPUResourceRequest?: string(name='ProxyInitAckSloCPUResourceRequest', example='100'),
  proxyInitAckSloMemoryResourceLimit?: string(name='ProxyInitAckSloMemoryResourceLimit', example='2048Mi'),
  proxyInitAckSloMemoryResourceRequest?: string(name='ProxyInitAckSloMemoryResourceRequest', example='128Mi'),
  proxyInitCPUResourceLimit?: string(name='ProxyInitCPUResourceLimit', description='The maximum number of CPU cores that are available to the sidecar proxy init container.', example='2000 m'),
  proxyInitCPUResourceRequest?: string(name='ProxyInitCPUResourceRequest', description='The minimum number of CPU cores that are requested by the sidecar proxy init container.', example='60 m'),
  proxyInitMemoryResourceLimit?: string(name='ProxyInitMemoryResourceLimit', description='The maximum size of memory that is available to the sidecar proxy init container.', example='50 Mi'),
  proxyInitMemoryResourceRequest?: string(name='ProxyInitMemoryResourceRequest', description='The minimum size of memory that is requested by the sidecar proxy init container.', example='30 Mi'),
  proxyMetadata?: string(name='ProxyMetadata', description='The environment variables that are added to a sidecar proxy. The environment variables are represented as JSON objects. The keys and values in the JSON objects represent the keys and values added to the environment variables of the sidecar proxy.', example='{"EXIT_ON_ZERO_ACTIVE_CONNECTIONS":"true"}'),
  proxyStatsMatcher?: string(name='ProxyStatsMatcher', description='The monitoring metrics for data collected by Envoy proxies. The value is in the JSON format.', example='{ "inclusionPrefixes": [ "cluster.outbound", "cluster_manager", "listener_manager", "server", "cluster.xds-grpc" ], "inclusionRegexps": [ "listener.*.downstream_cx_total", "listener.*.downstream_cx_active" ] }'),
  readinessFailureThreshold?: int32(name='ReadinessFailureThreshold'),
  readinessInitialDelaySeconds?: int32(name='ReadinessInitialDelaySeconds'),
  readinessPeriodSeconds?: int32(name='ReadinessPeriodSeconds'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='ca04bc38979214bf2882be79d39b4****'),
  sidecarProxyAckSloCPUResourceLimit?: string(name='SidecarProxyAckSloCPUResourceLimit', example='2000'),
  sidecarProxyAckSloCPUResourceRequest?: string(name='SidecarProxyAckSloCPUResourceRequest', example='100'),
  sidecarProxyAckSloMemoryResourceLimit?: string(name='SidecarProxyAckSloMemoryResourceLimit', example='2048Mi'),
  sidecarProxyAckSloMemoryResourceRequest?: string(name='SidecarProxyAckSloMemoryResourceRequest', example='128Mi'),
  sidecarProxyCPUResourceLimit?: string(name='SidecarProxyCPUResourceLimit', description='The maximum number of CPU cores that are available to the sidecar proxy container.', example='2000 m'),
  sidecarProxyCPUResourceRequest?: string(name='SidecarProxyCPUResourceRequest', description='The minimum number of CPU cores that are requested by the sidecar proxy container.', example='60 m'),
  sidecarProxyMemoryResourceLimit?: string(name='SidecarProxyMemoryResourceLimit', description='The maximum size of memory that is available to the sidecar proxy container.', example='50 Mi'),
  sidecarProxyMemoryResourceRequest?: string(name='SidecarProxyMemoryResourceRequest', description='The minimum size of memory that is requested by the sidecar proxy container.', example='30 Mi'),
  terminationDrainDuration?: string(name='TerminationDrainDuration', description='The maximum period of time that the sidecar proxy waits for a request to end.', example='6s'),
  tracing?: string(name='Tracing', description='The custom configurations of Tracing Analysis. The configurations must be serialized into JSON strings. The configurations contain the following parameters:

*   `sampling`: The sampling rate, which is of the DOUBLE type.

*   `custom_tags`: The custom tags added to reported spans, which are of the MAP type. The key of a tag is of the string type. The value of a tag is in the JSON format. A custom tag can belong to one of the following types:

    *   `literal`: The tag value is a fixed value in the JSON format. This tag must contain the `value` field that specifies a literal. Example: `{"value":"test"}`.
    *   `header`: The tag value is a request header in the JSON format. This tag must contain the `name` field and `defaultValue` field.The name field indicates the name of the request header. The defaultValue field indicates the default value that is used when no request header is available. Example: `{"name":"test","defaultValue":"test"}`.
    *   `environment`: The tag value is an environment variable in the JSON format. This tag must contain the `name` field and `defaultValue` field. The name field indicates the name of the environment variable. The defaultValue field indicates the environment variable that is used when no environment variable is available. Example: `{"name":"test","defaultValue":"test"}`.', example='{"sampling":99.8,"custom_tags":{"test":{"literal":{"value":"testnamespace"}}}}'),
}

model UpdateNamespaceScopeSidecarConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model UpdateNamespaceScopeSidecarConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateNamespaceScopeSidecarConfigResponseBody(name='body'),
}

async function updateNamespaceScopeSidecarConfigWithOptions(request: UpdateNamespaceScopeSidecarConfigRequest, runtime: Util.RuntimeOptions): UpdateNamespaceScopeSidecarConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.concurrency)) {
    body['Concurrency'] = request.concurrency;
  }
  if (!Util.isUnset(request.enableCoreDump)) {
    body['EnableCoreDump'] = request.enableCoreDump;
  }
  if (!Util.isUnset(request.excludeIPRanges)) {
    body['ExcludeIPRanges'] = request.excludeIPRanges;
  }
  if (!Util.isUnset(request.excludeInboundPorts)) {
    body['ExcludeInboundPorts'] = request.excludeInboundPorts;
  }
  if (!Util.isUnset(request.excludeOutboundPorts)) {
    body['ExcludeOutboundPorts'] = request.excludeOutboundPorts;
  }
  if (!Util.isUnset(request.holdApplicationUntilProxyStarts)) {
    body['HoldApplicationUntilProxyStarts'] = request.holdApplicationUntilProxyStarts;
  }
  if (!Util.isUnset(request.includeIPRanges)) {
    body['IncludeIPRanges'] = request.includeIPRanges;
  }
  if (!Util.isUnset(request.includeInboundPorts)) {
    body['IncludeInboundPorts'] = request.includeInboundPorts;
  }
  if (!Util.isUnset(request.includeOutboundPorts)) {
    body['IncludeOutboundPorts'] = request.includeOutboundPorts;
  }
  if (!Util.isUnset(request.interceptionMode)) {
    body['InterceptionMode'] = request.interceptionMode;
  }
  if (!Util.isUnset(request.istioDNSProxyEnabled)) {
    body['IstioDNSProxyEnabled'] = request.istioDNSProxyEnabled;
  }
  if (!Util.isUnset(request.lifecycle)) {
    body['Lifecycle'] = request.lifecycle;
  }
  if (!Util.isUnset(request.logLevel)) {
    body['LogLevel'] = request.logLevel;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.postStart)) {
    body['PostStart'] = request.postStart;
  }
  if (!Util.isUnset(request.preStop)) {
    body['PreStop'] = request.preStop;
  }
  if (!Util.isUnset(request.privileged)) {
    body['Privileged'] = request.privileged;
  }
  if (!Util.isUnset(request.proxyInitAckSloCPUResourceLimit)) {
    body['ProxyInitAckSloCPUResourceLimit'] = request.proxyInitAckSloCPUResourceLimit;
  }
  if (!Util.isUnset(request.proxyInitAckSloCPUResourceRequest)) {
    body['ProxyInitAckSloCPUResourceRequest'] = request.proxyInitAckSloCPUResourceRequest;
  }
  if (!Util.isUnset(request.proxyInitAckSloMemoryResourceLimit)) {
    body['ProxyInitAckSloMemoryResourceLimit'] = request.proxyInitAckSloMemoryResourceLimit;
  }
  if (!Util.isUnset(request.proxyInitAckSloMemoryResourceRequest)) {
    body['ProxyInitAckSloMemoryResourceRequest'] = request.proxyInitAckSloMemoryResourceRequest;
  }
  if (!Util.isUnset(request.proxyInitCPUResourceLimit)) {
    body['ProxyInitCPUResourceLimit'] = request.proxyInitCPUResourceLimit;
  }
  if (!Util.isUnset(request.proxyInitCPUResourceRequest)) {
    body['ProxyInitCPUResourceRequest'] = request.proxyInitCPUResourceRequest;
  }
  if (!Util.isUnset(request.proxyInitMemoryResourceLimit)) {
    body['ProxyInitMemoryResourceLimit'] = request.proxyInitMemoryResourceLimit;
  }
  if (!Util.isUnset(request.proxyInitMemoryResourceRequest)) {
    body['ProxyInitMemoryResourceRequest'] = request.proxyInitMemoryResourceRequest;
  }
  if (!Util.isUnset(request.proxyMetadata)) {
    body['ProxyMetadata'] = request.proxyMetadata;
  }
  if (!Util.isUnset(request.proxyStatsMatcher)) {
    body['ProxyStatsMatcher'] = request.proxyStatsMatcher;
  }
  if (!Util.isUnset(request.readinessFailureThreshold)) {
    body['ReadinessFailureThreshold'] = request.readinessFailureThreshold;
  }
  if (!Util.isUnset(request.readinessInitialDelaySeconds)) {
    body['ReadinessInitialDelaySeconds'] = request.readinessInitialDelaySeconds;
  }
  if (!Util.isUnset(request.readinessPeriodSeconds)) {
    body['ReadinessPeriodSeconds'] = request.readinessPeriodSeconds;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.sidecarProxyAckSloCPUResourceLimit)) {
    body['SidecarProxyAckSloCPUResourceLimit'] = request.sidecarProxyAckSloCPUResourceLimit;
  }
  if (!Util.isUnset(request.sidecarProxyAckSloCPUResourceRequest)) {
    body['SidecarProxyAckSloCPUResourceRequest'] = request.sidecarProxyAckSloCPUResourceRequest;
  }
  if (!Util.isUnset(request.sidecarProxyAckSloMemoryResourceLimit)) {
    body['SidecarProxyAckSloMemoryResourceLimit'] = request.sidecarProxyAckSloMemoryResourceLimit;
  }
  if (!Util.isUnset(request.sidecarProxyAckSloMemoryResourceRequest)) {
    body['SidecarProxyAckSloMemoryResourceRequest'] = request.sidecarProxyAckSloMemoryResourceRequest;
  }
  if (!Util.isUnset(request.sidecarProxyCPUResourceLimit)) {
    body['SidecarProxyCPUResourceLimit'] = request.sidecarProxyCPUResourceLimit;
  }
  if (!Util.isUnset(request.sidecarProxyCPUResourceRequest)) {
    body['SidecarProxyCPUResourceRequest'] = request.sidecarProxyCPUResourceRequest;
  }
  if (!Util.isUnset(request.sidecarProxyMemoryResourceLimit)) {
    body['SidecarProxyMemoryResourceLimit'] = request.sidecarProxyMemoryResourceLimit;
  }
  if (!Util.isUnset(request.sidecarProxyMemoryResourceRequest)) {
    body['SidecarProxyMemoryResourceRequest'] = request.sidecarProxyMemoryResourceRequest;
  }
  if (!Util.isUnset(request.terminationDrainDuration)) {
    body['TerminationDrainDuration'] = request.terminationDrainDuration;
  }
  if (!Util.isUnset(request.tracing)) {
    body['Tracing'] = request.tracing;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNamespaceScopeSidecarConfig',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateNamespaceScopeSidecarConfig(request: UpdateNamespaceScopeSidecarConfigRequest): UpdateNamespaceScopeSidecarConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNamespaceScopeSidecarConfigWithOptions(request, runtime);
}

model UpdateSwimLaneRequest {
  groupName?: string(name='GroupName', description='The name of the lane group.', example='test'),
  labelSelectorKey?: string(name='LabelSelectorKey', description='The label key of the associated service workload. Set the value to `ASM_TRAFFIC_TAG`.', example='ASM_TRAFFIC_TAG'),
  labelSelectorValue?: string(name='LabelSelectorValue', description='The label value of the associated service workload.``', example='v1'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='xxx'),
  servicesList?: string(name='ServicesList', description='A list of services associated with the lane.', example='["sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mocka","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockb","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockc"]'),
  swimLaneName?: string(name='SwimLaneName', description='The name of the lane.', example='s1'),
}

model UpdateSwimLaneResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='yyy'),
}

model UpdateSwimLaneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSwimLaneResponseBody(name='body'),
}

async function updateSwimLaneWithOptions(request: UpdateSwimLaneRequest, runtime: Util.RuntimeOptions): UpdateSwimLaneResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    body['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.labelSelectorKey)) {
    body['LabelSelectorKey'] = request.labelSelectorKey;
  }
  if (!Util.isUnset(request.labelSelectorValue)) {
    body['LabelSelectorValue'] = request.labelSelectorValue;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.servicesList)) {
    body['ServicesList'] = request.servicesList;
  }
  if (!Util.isUnset(request.swimLaneName)) {
    body['SwimLaneName'] = request.swimLaneName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSwimLane',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSwimLane(request: UpdateSwimLaneRequest): UpdateSwimLaneResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSwimLaneWithOptions(request, runtime);
}

model UpdateSwimLaneGroupRequest {
  fallbackTarget?: string(name='FallbackTarget'),
  groupName?: string(name='GroupName', description='The name of the lane group.', example='test'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='xxx'),
  servicesList?: string(name='ServicesList', description='A list of services associated with the lane group.', example='["sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mocka","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockb","sh01/c089443ea9e50403fa4f0a6237d11e0a9/default/mockc"]'),
}

model UpdateSwimLaneGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='yyy'),
}

model UpdateSwimLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSwimLaneGroupResponseBody(name='body'),
}

async function updateSwimLaneGroupWithOptions(request: UpdateSwimLaneGroupRequest, runtime: Util.RuntimeOptions): UpdateSwimLaneGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fallbackTarget)) {
    body['FallbackTarget'] = request.fallbackTarget;
  }
  if (!Util.isUnset(request.groupName)) {
    body['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.servicesList)) {
    body['ServicesList'] = request.servicesList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSwimLaneGroup',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSwimLaneGroup(request: UpdateSwimLaneGroupRequest): UpdateSwimLaneGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSwimLaneGroupWithOptions(request, runtime);
}

model UpgradeMeshEditionPartiallyRequest {
  ASMGatewayContinue?: boolean(name='ASMGatewayContinue', description='Specifies whether to upgrade the ASM gateways for the ASM instance. Valid values:

*   `true`
*   `false`', example='true'),
  expectedVersion?: string(name='ExpectedVersion', example='v1.15.3.118-g4712daf0-aliyun'),
  preCheck?: boolean(name='PreCheck', description='Specifies whether to perform an upgrade check. If the value of this parameter is set to true, only the upgrade check is performed and the ASM instance is not upgraded.', example='true'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ASM instance ID.', example='ca04bc38979214bf2882be79d39b4****'),
  switchToPro?: boolean(name='SwitchToPro', description='Specifies whether to upgrade the ASM instance to Professional Edition. Valid values:

*   `true`
*   `false`', example='true', deprecated='true'),
  upgradeGatewayRecords?: string(name='UpgradeGatewayRecords', description='Specifies the ASM gateways to be upgraded. Separate multiple ASM gateways with commas (,).', example='ingressgateway1,ingressgateway2'),
}

model UpgradeMeshEditionPartiallyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='31d3a0f0-07ed-4f6e-9004-1804498c****'),
}

model UpgradeMeshEditionPartiallyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeMeshEditionPartiallyResponseBody(name='body'),
}

async function upgradeMeshEditionPartiallyWithOptions(request: UpgradeMeshEditionPartiallyRequest, runtime: Util.RuntimeOptions): UpgradeMeshEditionPartiallyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ASMGatewayContinue)) {
    body['ASMGatewayContinue'] = request.ASMGatewayContinue;
  }
  if (!Util.isUnset(request.expectedVersion)) {
    body['ExpectedVersion'] = request.expectedVersion;
  }
  if (!Util.isUnset(request.preCheck)) {
    body['PreCheck'] = request.preCheck;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.switchToPro)) {
    body['SwitchToPro'] = request.switchToPro;
  }
  if (!Util.isUnset(request.upgradeGatewayRecords)) {
    body['UpgradeGatewayRecords'] = request.upgradeGatewayRecords;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeMeshEditionPartially',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeMeshEditionPartially(request: UpgradeMeshEditionPartiallyRequest): UpgradeMeshEditionPartiallyResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeMeshEditionPartiallyWithOptions(request, runtime);
}

model UpgradeMeshVersionRequest {
  preCheck?: boolean(name='PreCheck'),
  serviceMeshId?: string(name='ServiceMeshId', description='The ID of the ASM instance.', example='c08ba3fd1e6484b0f8cc1ad8fe10d****'),
}

model UpgradeMeshVersionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='11fd0027-c27e-41bb-a565-75583054****'),
}

model UpgradeMeshVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeMeshVersionResponseBody(name='body'),
}

async function upgradeMeshVersionWithOptions(request: UpgradeMeshVersionRequest, runtime: Util.RuntimeOptions): UpgradeMeshVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.preCheck)) {
    query['PreCheck'] = request.preCheck;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeMeshVersion',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeMeshVersion(request: UpgradeMeshVersionRequest): UpgradeMeshVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeMeshVersionWithOptions(request, runtime);
}

