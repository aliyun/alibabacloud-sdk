/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('servicemesh', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model SecretCreateRecordValue = {
  state?: string(name='State'),
  clusterId?: string(name='ClusterId'),
  message?: string(name='Message'),
}

model SecretDeleteRecordValue = {
  state?: string(name='State'),
  clusterId?: string(name='ClusterId'),
  message?: string(name='Message'),
}

model CCMVersionsValue = {
  queryState?: string(name='QueryState'),
  version?: string(name='Version'),
  SLBGracefulDrainSupport?: boolean(name='SLBGracefulDrainSupport'),
  clusterId?: string(name='ClusterId'),
  message?: string(name='Message'),
}

model UpgradeDetailGatewayStatusRecordValue = {
  status?: string(name='Status'),
  message?: string(name='Message'),
  version?: string(name='Version'),
}

model AddClusterIntoServiceMeshRequest {
  clusterId?: string(name='ClusterId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model AddClusterIntoServiceMeshResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AddClusterIntoServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddClusterIntoServiceMeshResponseBody(name='body'),
}

async function addClusterIntoServiceMeshWithOptions(request: AddClusterIntoServiceMeshRequest, runtime: Util.RuntimeOptions): AddClusterIntoServiceMeshResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddClusterIntoServiceMesh',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addClusterIntoServiceMesh(request: AddClusterIntoServiceMeshRequest): AddClusterIntoServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return addClusterIntoServiceMeshWithOptions(request, runtime);
}

model AddVMIntoServiceMeshRequest {
  ecsId?: string(name='EcsId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model AddVMIntoServiceMeshResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddVMIntoServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddVMIntoServiceMeshResponseBody(name='body'),
}

async function addVMIntoServiceMeshWithOptions(request: AddVMIntoServiceMeshRequest, runtime: Util.RuntimeOptions): AddVMIntoServiceMeshResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ecsId)) {
    query['EcsId'] = request.ecsId;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddVMIntoServiceMesh',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addVMIntoServiceMesh(request: AddVMIntoServiceMeshRequest): AddVMIntoServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVMIntoServiceMeshWithOptions(request, runtime);
}

model CreateASMGatewayRequest {
  body?: string(name='Body'),
  istioGatewayName?: string(name='IstioGatewayName'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model CreateASMGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateASMGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateASMGatewayResponseBody(name='body'),
}

async function createASMGatewayWithOptions(request: CreateASMGatewayRequest, runtime: Util.RuntimeOptions): CreateASMGatewayResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['Body'] = request.body;
  }
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateASMGateway',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createASMGateway(request: CreateASMGatewayRequest): CreateASMGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createASMGatewayWithOptions(request, runtime);
}

model CreateGatewaySecretRequest {
  cert?: string(name='Cert'),
  istioGatewayName?: string(name='IstioGatewayName'),
  key?: string(name='Key'),
  secretName?: string(name='SecretName'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model CreateGatewaySecretResponseBody = {
  requestId?: string(name='RequestId'),
  secretCreateRecord?: map[string]SecretCreateRecordValue(name='SecretCreateRecord'),
}

model CreateGatewaySecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGatewaySecretResponseBody(name='body'),
}

async function createGatewaySecretWithOptions(request: CreateGatewaySecretRequest, runtime: Util.RuntimeOptions): CreateGatewaySecretResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.cert)) {
    body['Cert'] = request.cert;
  }
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.key)) {
    body['Key'] = request.key;
  }
  if (!Util.isUnset(request.secretName)) {
    body['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateGatewaySecret',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGatewaySecret(request: CreateGatewaySecretRequest): CreateGatewaySecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGatewaySecretWithOptions(request, runtime);
}

model CreateIstioGatewayDomainsRequest {
  credential?: string(name='Credential'),
  forceHttps?: boolean(name='ForceHttps'),
  hosts?: string(name='Hosts'),
  istioGatewayName?: string(name='IstioGatewayName'),
  limit?: string(name='Limit'),
  namespace?: string(name='Namespace'),
  number?: int32(name='Number'),
  portName?: string(name='PortName'),
  protocol?: string(name='Protocol'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model CreateIstioGatewayDomainsResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateIstioGatewayDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIstioGatewayDomainsResponseBody(name='body'),
}

async function createIstioGatewayDomainsWithOptions(request: CreateIstioGatewayDomainsRequest, runtime: Util.RuntimeOptions): CreateIstioGatewayDomainsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.credential)) {
    body['Credential'] = request.credential;
  }
  if (!Util.isUnset(request.forceHttps)) {
    body['ForceHttps'] = request.forceHttps;
  }
  if (!Util.isUnset(request.hosts)) {
    body['Hosts'] = request.hosts;
  }
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.number)) {
    body['Number'] = request.number;
  }
  if (!Util.isUnset(request.portName)) {
    body['PortName'] = request.portName;
  }
  if (!Util.isUnset(request.protocol)) {
    body['Protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIstioGatewayDomains',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIstioGatewayDomains(request: CreateIstioGatewayDomainsRequest): CreateIstioGatewayDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIstioGatewayDomainsWithOptions(request, runtime);
}

model CreateIstioGatewayRoutesRequest {
  description?: string(name='Description'),
  gatewayRoute?: {
    domains?: [ string ](name='Domains'),
    HTTPAdvancedOptions?: {
      delegate?: {
        name?: string(name='Name'),
        namespace?: string(name='Namespace'),
      }(name='Delegate'),
      fault?: {
        abort?: {
          httpStatus?: int32(name='HttpStatus'),
          percentage?: {
            value?: float(name='Value'),
          }(name='Percentage'),
        }(name='Abort'),
        delay?: {
          fixedDelay?: string(name='FixedDelay'),
          percentage?: {
            value?: float(name='Value'),
          }(name='Percentage'),
        }(name='Delay'),
      }(name='Fault'),
      HTTPRedirect?: {
        authority?: string(name='Authority'),
        redirectCode?: int32(name='RedirectCode'),
        uri?: string(name='Uri'),
      }(name='HTTPRedirect'),
      mirror?: {
        host?: string(name='Host'),
        subset?: string(name='Subset'),
      }(name='Mirror'),
      mirrorPercentage?: {
        value?: float(name='Value'),
      }(name='MirrorPercentage'),
      retries?: {
        attempts?: int32(name='Attempts'),
        perTryTimeout?: string(name='PerTryTimeout'),
        retryOn?: string(name='RetryOn'),
        retryRemoteLocalities?: {
          value?: boolean(name='Value'),
        }(name='RetryRemoteLocalities'),
      }(name='Retries'),
      rewrite?: {
        authority?: string(name='Authority'),
        uri?: string(name='Uri'),
      }(name='Rewrite'),
      timeout?: string(name='Timeout'),
    }(name='HTTPAdvancedOptions'),
    matchRequest?: {
      headers?: [ 
        {
          matchingContent?: string(name='MatchingContent'),
          matchingMode?: string(name='MatchingMode'),
          name?: string(name='Name'),
        }
      ](name='Headers'),
      ports?: [ int32 ](name='Ports'),
      TLSMatchAttributes?: [ 
        {
          SNIHosts?: [ string ](name='SNIHosts'),
          TLSPort?: int32(name='TLSPort'),
        }
      ](name='TLSMatchAttributes'),
      URI?: {
        matchingContent?: string(name='MatchingContent'),
        matchingMode?: string(name='MatchingMode'),
      }(name='URI'),
    }(name='MatchRequest'),
    namespace?: string(name='Namespace'),
    routeDestinations?: [ 
      {
        destination?: {
          host?: string(name='Host'),
          port?: {
            number?: int32(name='Number'),
          }(name='Port'),
          subset?: string(name='Subset'),
        }(name='Destination'),
        weight?: int32(name='Weight'),
      }
    ](name='RouteDestinations'),
    routeName?: string(name='RouteName'),
    routeType?: string(name='RouteType'),
  }(name='GatewayRoute'),
  istioGatewayName?: string(name='IstioGatewayName'),
  priority?: int32(name='Priority'),
  serviceMeshId?: string(name='ServiceMeshId'),
  status?: int32(name='Status'),
}

model CreateIstioGatewayRoutesShrinkRequest {
  description?: string(name='Description'),
  gatewayRouteShrink?: string(name='GatewayRoute'),
  istioGatewayName?: string(name='IstioGatewayName'),
  priority?: int32(name='Priority'),
  serviceMeshId?: string(name='ServiceMeshId'),
  status?: int32(name='Status'),
}

model CreateIstioGatewayRoutesResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateIstioGatewayRoutesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIstioGatewayRoutesResponseBody(name='body'),
}

async function createIstioGatewayRoutesWithOptions(tmpReq: CreateIstioGatewayRoutesRequest, runtime: Util.RuntimeOptions): CreateIstioGatewayRoutesResponse {
  Util.validateModel(tmpReq);
  var request = new CreateIstioGatewayRoutesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.gatewayRoute)) {
    request.gatewayRouteShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.gatewayRoute, 'GatewayRoute', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.gatewayRouteShrink)) {
    body['GatewayRoute'] = request.gatewayRouteShrink;
  }
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.priority)) {
    body['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIstioGatewayRoutes',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIstioGatewayRoutes(request: CreateIstioGatewayRoutesRequest): CreateIstioGatewayRoutesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIstioGatewayRoutesWithOptions(request, runtime);
}

model CreateServiceMeshRequest {
  accessLogEnabled?: boolean(name='AccessLogEnabled'),
  accessLogFile?: string(name='AccessLogFile'),
  accessLogFormat?: string(name='AccessLogFormat'),
  accessLogProject?: string(name='AccessLogProject'),
  accessLogServiceEnabled?: boolean(name='AccessLogServiceEnabled'),
  accessLogServiceHost?: string(name='AccessLogServiceHost'),
  accessLogServicePort?: int32(name='AccessLogServicePort'),
  apiServerLoadBalancerSpec?: string(name='ApiServerLoadBalancerSpec'),
  apiServerPublicEip?: boolean(name='ApiServerPublicEip'),
  auditProject?: string(name='AuditProject'),
  autoRenew?: boolean(name='AutoRenew'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
  CRAggregationEnabled?: boolean(name='CRAggregationEnabled'),
  chargeType?: string(name='ChargeType'),
  clusterSpec?: string(name='ClusterSpec'),
  configSourceEnabled?: boolean(name='ConfigSourceEnabled'),
  configSourceNacosID?: string(name='ConfigSourceNacosID'),
  controlPlaneLogEnabled?: boolean(name='ControlPlaneLogEnabled'),
  controlPlaneLogProject?: string(name='ControlPlaneLogProject'),
  customizedPrometheus?: boolean(name='CustomizedPrometheus'),
  customizedZipkin?: boolean(name='CustomizedZipkin'),
  DNSProxyingEnabled?: boolean(name='DNSProxyingEnabled'),
  dubboFilterEnabled?: boolean(name='DubboFilterEnabled'),
  edition?: string(name='Edition'),
  enableAudit?: boolean(name='EnableAudit'),
  enableCRHistory?: boolean(name='EnableCRHistory'),
  enableSDSServer?: boolean(name='EnableSDSServer'),
  excludeIPRanges?: string(name='ExcludeIPRanges'),
  excludeInboundPorts?: string(name='ExcludeInboundPorts'),
  excludeOutboundPorts?: string(name='ExcludeOutboundPorts'),
  filterGatewayClusterConfig?: boolean(name='FilterGatewayClusterConfig'),
  gatewayAPIEnabled?: boolean(name='GatewayAPIEnabled'),
  globalRateLimitEnabled?: boolean(name='GlobalRateLimitEnabled'),
  includeIPRanges?: string(name='IncludeIPRanges'),
  istioVersion?: string(name='IstioVersion'),
  kialiEnabled?: boolean(name='KialiEnabled'),
  localityLBConf?: string(name='LocalityLBConf'),
  localityLoadBalancing?: boolean(name='LocalityLoadBalancing'),
  MSEEnabled?: boolean(name='MSEEnabled'),
  multiBufferEnabled?: boolean(name='MultiBufferEnabled'),
  multiBufferPollDelay?: string(name='MultiBufferPollDelay'),
  mysqlFilterEnabled?: boolean(name='MysqlFilterEnabled'),
  name?: string(name='Name'),
  OPALimitCPU?: string(name='OPALimitCPU'),
  OPALimitMemory?: string(name='OPALimitMemory'),
  OPALogLevel?: string(name='OPALogLevel'),
  OPARequestCPU?: string(name='OPARequestCPU'),
  OPARequestMemory?: string(name='OPARequestMemory'),
  opaEnabled?: boolean(name='OpaEnabled'),
  openAgentPolicy?: boolean(name='OpenAgentPolicy'),
  period?: int32(name='Period'),
  pilotLoadBalancerSpec?: string(name='PilotLoadBalancerSpec'),
  prometheusUrl?: string(name='PrometheusUrl'),
  proxyLimitCPU?: string(name='ProxyLimitCPU'),
  proxyLimitMemory?: string(name='ProxyLimitMemory'),
  proxyRequestCPU?: string(name='ProxyRequestCPU'),
  proxyRequestMemory?: string(name='ProxyRequestMemory'),
  redisFilterEnabled?: boolean(name='RedisFilterEnabled'),
  regionId?: string(name='RegionId'),
  telemetry?: boolean(name='Telemetry'),
  thriftFilterEnabled?: boolean(name='ThriftFilterEnabled'),
  traceSampling?: float(name='TraceSampling'),
  tracing?: boolean(name='Tracing'),
  vSwitches?: string(name='VSwitches'),
  vpcId?: string(name='VpcId'),
  webAssemblyFilterEnabled?: boolean(name='WebAssemblyFilterEnabled'),
}

model CreateServiceMeshResponseBody = {
  requestId?: string(name='RequestId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model CreateServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceMeshResponseBody(name='body'),
}

async function createServiceMeshWithOptions(request: CreateServiceMeshRequest, runtime: Util.RuntimeOptions): CreateServiceMeshResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessLogEnabled)) {
    body['AccessLogEnabled'] = request.accessLogEnabled;
  }
  if (!Util.isUnset(request.accessLogFile)) {
    body['AccessLogFile'] = request.accessLogFile;
  }
  if (!Util.isUnset(request.accessLogFormat)) {
    body['AccessLogFormat'] = request.accessLogFormat;
  }
  if (!Util.isUnset(request.accessLogProject)) {
    body['AccessLogProject'] = request.accessLogProject;
  }
  if (!Util.isUnset(request.accessLogServiceEnabled)) {
    body['AccessLogServiceEnabled'] = request.accessLogServiceEnabled;
  }
  if (!Util.isUnset(request.accessLogServiceHost)) {
    body['AccessLogServiceHost'] = request.accessLogServiceHost;
  }
  if (!Util.isUnset(request.accessLogServicePort)) {
    body['AccessLogServicePort'] = request.accessLogServicePort;
  }
  if (!Util.isUnset(request.apiServerLoadBalancerSpec)) {
    body['ApiServerLoadBalancerSpec'] = request.apiServerLoadBalancerSpec;
  }
  if (!Util.isUnset(request.apiServerPublicEip)) {
    body['ApiServerPublicEip'] = request.apiServerPublicEip;
  }
  if (!Util.isUnset(request.auditProject)) {
    body['AuditProject'] = request.auditProject;
  }
  if (!Util.isUnset(request.autoRenew)) {
    body['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.autoRenewPeriod)) {
    body['AutoRenewPeriod'] = request.autoRenewPeriod;
  }
  if (!Util.isUnset(request.CRAggregationEnabled)) {
    body['CRAggregationEnabled'] = request.CRAggregationEnabled;
  }
  if (!Util.isUnset(request.chargeType)) {
    body['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.clusterSpec)) {
    body['ClusterSpec'] = request.clusterSpec;
  }
  if (!Util.isUnset(request.configSourceEnabled)) {
    body['ConfigSourceEnabled'] = request.configSourceEnabled;
  }
  if (!Util.isUnset(request.configSourceNacosID)) {
    body['ConfigSourceNacosID'] = request.configSourceNacosID;
  }
  if (!Util.isUnset(request.controlPlaneLogEnabled)) {
    body['ControlPlaneLogEnabled'] = request.controlPlaneLogEnabled;
  }
  if (!Util.isUnset(request.controlPlaneLogProject)) {
    body['ControlPlaneLogProject'] = request.controlPlaneLogProject;
  }
  if (!Util.isUnset(request.customizedPrometheus)) {
    body['CustomizedPrometheus'] = request.customizedPrometheus;
  }
  if (!Util.isUnset(request.customizedZipkin)) {
    body['CustomizedZipkin'] = request.customizedZipkin;
  }
  if (!Util.isUnset(request.DNSProxyingEnabled)) {
    body['DNSProxyingEnabled'] = request.DNSProxyingEnabled;
  }
  if (!Util.isUnset(request.dubboFilterEnabled)) {
    body['DubboFilterEnabled'] = request.dubboFilterEnabled;
  }
  if (!Util.isUnset(request.edition)) {
    body['Edition'] = request.edition;
  }
  if (!Util.isUnset(request.enableAudit)) {
    body['EnableAudit'] = request.enableAudit;
  }
  if (!Util.isUnset(request.enableCRHistory)) {
    body['EnableCRHistory'] = request.enableCRHistory;
  }
  if (!Util.isUnset(request.enableSDSServer)) {
    body['EnableSDSServer'] = request.enableSDSServer;
  }
  if (!Util.isUnset(request.excludeIPRanges)) {
    body['ExcludeIPRanges'] = request.excludeIPRanges;
  }
  if (!Util.isUnset(request.excludeInboundPorts)) {
    body['ExcludeInboundPorts'] = request.excludeInboundPorts;
  }
  if (!Util.isUnset(request.excludeOutboundPorts)) {
    body['ExcludeOutboundPorts'] = request.excludeOutboundPorts;
  }
  if (!Util.isUnset(request.filterGatewayClusterConfig)) {
    body['FilterGatewayClusterConfig'] = request.filterGatewayClusterConfig;
  }
  if (!Util.isUnset(request.gatewayAPIEnabled)) {
    body['GatewayAPIEnabled'] = request.gatewayAPIEnabled;
  }
  if (!Util.isUnset(request.globalRateLimitEnabled)) {
    body['GlobalRateLimitEnabled'] = request.globalRateLimitEnabled;
  }
  if (!Util.isUnset(request.includeIPRanges)) {
    body['IncludeIPRanges'] = request.includeIPRanges;
  }
  if (!Util.isUnset(request.istioVersion)) {
    body['IstioVersion'] = request.istioVersion;
  }
  if (!Util.isUnset(request.kialiEnabled)) {
    body['KialiEnabled'] = request.kialiEnabled;
  }
  if (!Util.isUnset(request.localityLBConf)) {
    body['LocalityLBConf'] = request.localityLBConf;
  }
  if (!Util.isUnset(request.localityLoadBalancing)) {
    body['LocalityLoadBalancing'] = request.localityLoadBalancing;
  }
  if (!Util.isUnset(request.MSEEnabled)) {
    body['MSEEnabled'] = request.MSEEnabled;
  }
  if (!Util.isUnset(request.multiBufferEnabled)) {
    body['MultiBufferEnabled'] = request.multiBufferEnabled;
  }
  if (!Util.isUnset(request.multiBufferPollDelay)) {
    body['MultiBufferPollDelay'] = request.multiBufferPollDelay;
  }
  if (!Util.isUnset(request.mysqlFilterEnabled)) {
    body['MysqlFilterEnabled'] = request.mysqlFilterEnabled;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.OPALimitCPU)) {
    body['OPALimitCPU'] = request.OPALimitCPU;
  }
  if (!Util.isUnset(request.OPALimitMemory)) {
    body['OPALimitMemory'] = request.OPALimitMemory;
  }
  if (!Util.isUnset(request.OPALogLevel)) {
    body['OPALogLevel'] = request.OPALogLevel;
  }
  if (!Util.isUnset(request.OPARequestCPU)) {
    body['OPARequestCPU'] = request.OPARequestCPU;
  }
  if (!Util.isUnset(request.OPARequestMemory)) {
    body['OPARequestMemory'] = request.OPARequestMemory;
  }
  if (!Util.isUnset(request.opaEnabled)) {
    body['OpaEnabled'] = request.opaEnabled;
  }
  if (!Util.isUnset(request.openAgentPolicy)) {
    body['OpenAgentPolicy'] = request.openAgentPolicy;
  }
  if (!Util.isUnset(request.period)) {
    body['Period'] = request.period;
  }
  if (!Util.isUnset(request.pilotLoadBalancerSpec)) {
    body['PilotLoadBalancerSpec'] = request.pilotLoadBalancerSpec;
  }
  if (!Util.isUnset(request.prometheusUrl)) {
    body['PrometheusUrl'] = request.prometheusUrl;
  }
  if (!Util.isUnset(request.proxyLimitCPU)) {
    body['ProxyLimitCPU'] = request.proxyLimitCPU;
  }
  if (!Util.isUnset(request.proxyLimitMemory)) {
    body['ProxyLimitMemory'] = request.proxyLimitMemory;
  }
  if (!Util.isUnset(request.proxyRequestCPU)) {
    body['ProxyRequestCPU'] = request.proxyRequestCPU;
  }
  if (!Util.isUnset(request.proxyRequestMemory)) {
    body['ProxyRequestMemory'] = request.proxyRequestMemory;
  }
  if (!Util.isUnset(request.redisFilterEnabled)) {
    body['RedisFilterEnabled'] = request.redisFilterEnabled;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.telemetry)) {
    body['Telemetry'] = request.telemetry;
  }
  if (!Util.isUnset(request.thriftFilterEnabled)) {
    body['ThriftFilterEnabled'] = request.thriftFilterEnabled;
  }
  if (!Util.isUnset(request.traceSampling)) {
    body['TraceSampling'] = request.traceSampling;
  }
  if (!Util.isUnset(request.tracing)) {
    body['Tracing'] = request.tracing;
  }
  if (!Util.isUnset(request.vSwitches)) {
    body['VSwitches'] = request.vSwitches;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.webAssemblyFilterEnabled)) {
    body['WebAssemblyFilterEnabled'] = request.webAssemblyFilterEnabled;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceMesh',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createServiceMesh(request: CreateServiceMeshRequest): CreateServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceMeshWithOptions(request, runtime);
}

model CreateSwimLaneRequest {
  groupName?: string(name='GroupName'),
  labelSelectorKey?: string(name='LabelSelectorKey'),
  labelSelectorValue?: string(name='LabelSelectorValue'),
  serviceMeshId?: string(name='ServiceMeshId'),
  servicesList?: string(name='ServicesList'),
  swimLaneName?: string(name='SwimLaneName'),
}

model CreateSwimLaneResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateSwimLaneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSwimLaneResponseBody(name='body'),
}

async function createSwimLaneWithOptions(request: CreateSwimLaneRequest, runtime: Util.RuntimeOptions): CreateSwimLaneResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    body['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.labelSelectorKey)) {
    body['LabelSelectorKey'] = request.labelSelectorKey;
  }
  if (!Util.isUnset(request.labelSelectorValue)) {
    body['LabelSelectorValue'] = request.labelSelectorValue;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.servicesList)) {
    body['ServicesList'] = request.servicesList;
  }
  if (!Util.isUnset(request.swimLaneName)) {
    body['SwimLaneName'] = request.swimLaneName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSwimLane',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSwimLane(request: CreateSwimLaneRequest): CreateSwimLaneResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSwimLaneWithOptions(request, runtime);
}

model CreateSwimLaneGroupRequest {
  groupName?: string(name='GroupName'),
  ingressGatewayName?: string(name='IngressGatewayName'),
  ingressType?: string(name='IngressType'),
  serviceMeshId?: string(name='ServiceMeshId'),
  servicesList?: string(name='ServicesList'),
}

model CreateSwimLaneGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateSwimLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSwimLaneGroupResponseBody(name='body'),
}

async function createSwimLaneGroupWithOptions(request: CreateSwimLaneGroupRequest, runtime: Util.RuntimeOptions): CreateSwimLaneGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    body['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.ingressGatewayName)) {
    body['IngressGatewayName'] = request.ingressGatewayName;
  }
  if (!Util.isUnset(request.ingressType)) {
    body['IngressType'] = request.ingressType;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.servicesList)) {
    body['ServicesList'] = request.servicesList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSwimLaneGroup',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSwimLaneGroup(request: CreateSwimLaneGroupRequest): CreateSwimLaneGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSwimLaneGroupWithOptions(request, runtime);
}

model DeleteGatewayRouteRequest {
  istioGatewayName?: string(name='IstioGatewayName'),
  routeName?: string(name='RouteName'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DeleteGatewayRouteResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGatewayRouteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGatewayRouteResponseBody(name='body'),
}

async function deleteGatewayRouteWithOptions(request: DeleteGatewayRouteRequest, runtime: Util.RuntimeOptions): DeleteGatewayRouteResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.routeName)) {
    body['RouteName'] = request.routeName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGatewayRoute',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGatewayRoute(request: DeleteGatewayRouteRequest): DeleteGatewayRouteResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGatewayRouteWithOptions(request, runtime);
}

model DeleteGatewaySecretRequest {
  istioGatewayName?: string(name='IstioGatewayName'),
  secretName?: string(name='SecretName'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DeleteGatewaySecretResponseBody = {
  requestId?: string(name='RequestId'),
  secretDeleteRecord?: map[string]SecretDeleteRecordValue(name='SecretDeleteRecord'),
}

model DeleteGatewaySecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGatewaySecretResponseBody(name='body'),
}

async function deleteGatewaySecretWithOptions(request: DeleteGatewaySecretRequest, runtime: Util.RuntimeOptions): DeleteGatewaySecretResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.secretName)) {
    body['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGatewaySecret',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGatewaySecret(request: DeleteGatewaySecretRequest): DeleteGatewaySecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGatewaySecretWithOptions(request, runtime);
}

model DeleteIstioGatewayDomainsRequest {
  hosts?: string(name='Hosts'),
  istioGatewayName?: string(name='IstioGatewayName'),
  limit?: string(name='Limit'),
  namespace?: string(name='Namespace'),
  portName?: string(name='PortName'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DeleteIstioGatewayDomainsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIstioGatewayDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIstioGatewayDomainsResponseBody(name='body'),
}

async function deleteIstioGatewayDomainsWithOptions(request: DeleteIstioGatewayDomainsRequest, runtime: Util.RuntimeOptions): DeleteIstioGatewayDomainsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.hosts)) {
    body['Hosts'] = request.hosts;
  }
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.portName)) {
    body['PortName'] = request.portName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIstioGatewayDomains',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIstioGatewayDomains(request: DeleteIstioGatewayDomainsRequest): DeleteIstioGatewayDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIstioGatewayDomainsWithOptions(request, runtime);
}

model DeleteServiceMeshRequest {
  force?: boolean(name='Force'),
  retainResources?: string(name='RetainResources'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DeleteServiceMeshResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceMeshResponseBody(name='body'),
}

async function deleteServiceMeshWithOptions(request: DeleteServiceMeshRequest, runtime: Util.RuntimeOptions): DeleteServiceMeshResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.force)) {
    body['Force'] = request.force;
  }
  if (!Util.isUnset(request.retainResources)) {
    body['RetainResources'] = request.retainResources;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceMesh',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteServiceMesh(request: DeleteServiceMeshRequest): DeleteServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServiceMeshWithOptions(request, runtime);
}

model DeleteSwimLaneRequest {
  groupName?: string(name='GroupName'),
  serviceMeshId?: string(name='ServiceMeshId'),
  swimLaneName?: string(name='SwimLaneName'),
}

model DeleteSwimLaneResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSwimLaneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSwimLaneResponseBody(name='body'),
}

async function deleteSwimLaneWithOptions(request: DeleteSwimLaneRequest, runtime: Util.RuntimeOptions): DeleteSwimLaneResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    body['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.swimLaneName)) {
    body['SwimLaneName'] = request.swimLaneName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSwimLane',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSwimLane(request: DeleteSwimLaneRequest): DeleteSwimLaneResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSwimLaneWithOptions(request, runtime);
}

model DeleteSwimLaneGroupRequest {
  groupName?: string(name='GroupName'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DeleteSwimLaneGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSwimLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSwimLaneGroupResponseBody(name='body'),
}

async function deleteSwimLaneGroupWithOptions(request: DeleteSwimLaneGroupRequest, runtime: Util.RuntimeOptions): DeleteSwimLaneGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    body['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSwimLaneGroup',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSwimLaneGroup(request: DeleteSwimLaneGroupRequest): DeleteSwimLaneGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSwimLaneGroupWithOptions(request, runtime);
}

model DescribeASMGatewayImportedServicesRequest {
  ASMGatewayName?: string(name='ASMGatewayName'),
  serviceMeshId?: string(name='ServiceMeshId'),
  serviceNamespace?: string(name='ServiceNamespace'),
}

model DescribeASMGatewayImportedServicesResponseBody = {
  importedServices?: [ 
    {
      serviceName?: string(name='ServiceName'),
      serviceNamespace?: string(name='ServiceNamespace'),
    }
  ](name='ImportedServices'),
  requestId?: string(name='RequestId'),
}

model DescribeASMGatewayImportedServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeASMGatewayImportedServicesResponseBody(name='body'),
}

async function describeASMGatewayImportedServicesWithOptions(request: DescribeASMGatewayImportedServicesRequest, runtime: Util.RuntimeOptions): DescribeASMGatewayImportedServicesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ASMGatewayName)) {
    body['ASMGatewayName'] = request.ASMGatewayName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.serviceNamespace)) {
    body['ServiceNamespace'] = request.serviceNamespace;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeASMGatewayImportedServices',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeASMGatewayImportedServices(request: DescribeASMGatewayImportedServicesRequest): DescribeASMGatewayImportedServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeASMGatewayImportedServicesWithOptions(request, runtime);
}

model DescribeAhasProRequest {
  regionId?: string(name='RegionId'),
}

model DescribeAhasProResponseBody = {
  requestId?: string(name='RequestId'),
  status?: boolean(name='Status'),
}

model DescribeAhasProResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAhasProResponseBody(name='body'),
}

async function describeAhasProWithOptions(request: DescribeAhasProRequest, runtime: Util.RuntimeOptions): DescribeAhasProResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAhasPro',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAhasPro(request: DescribeAhasProRequest): DescribeAhasProResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAhasProWithOptions(request, runtime);
}

model DescribeCCMVersionRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeCCMVersionResponseBody = {
  CCMVersions?: map[string]CCMVersionsValue(name='CCMVersions'),
  requestId?: string(name='RequestId'),
}

model DescribeCCMVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCCMVersionResponseBody(name='body'),
}

async function describeCCMVersionWithOptions(request: DescribeCCMVersionRequest, runtime: Util.RuntimeOptions): DescribeCCMVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCCMVersion',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCCMVersion(request: DescribeCCMVersionRequest): DescribeCCMVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCCMVersionWithOptions(request, runtime);
}

model DescribeCensRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeCensResponseBody = {
  clusters?: [ string ](name='Clusters'),
  requestId?: string(name='RequestId'),
}

model DescribeCensResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCensResponseBody(name='body'),
}

async function describeCensWithOptions(request: DescribeCensRequest, runtime: Util.RuntimeOptions): DescribeCensResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCens',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCens(request: DescribeCensRequest): DescribeCensResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCensWithOptions(request, runtime);
}

model DescribeClusterGrafanaRequest {
  k8sClusterId?: string(name='K8sClusterId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeClusterGrafanaResponseBody = {
  dashboards?: [ 
    {
      title?: string(name='Title'),
      url?: string(name='Url'),
    }
  ](name='Dashboards'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterGrafanaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterGrafanaResponseBody(name='body'),
}

async function describeClusterGrafanaWithOptions(request: DescribeClusterGrafanaRequest, runtime: Util.RuntimeOptions): DescribeClusterGrafanaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.k8sClusterId)) {
    query['K8sClusterId'] = request.k8sClusterId;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterGrafana',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterGrafana(request: DescribeClusterGrafanaRequest): DescribeClusterGrafanaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterGrafanaWithOptions(request, runtime);
}

model DescribeClusterPrometheusRequest {
  k8sClusterId?: string(name='K8sClusterId'),
  k8sClusterRegionId?: string(name='K8sClusterRegionId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeClusterPrometheusResponseBody = {
  prometheus?: string(name='Prometheus'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterPrometheusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterPrometheusResponseBody(name='body'),
}

async function describeClusterPrometheusWithOptions(request: DescribeClusterPrometheusRequest, runtime: Util.RuntimeOptions): DescribeClusterPrometheusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.k8sClusterId)) {
    query['K8sClusterId'] = request.k8sClusterId;
  }
  if (!Util.isUnset(request.k8sClusterRegionId)) {
    query['K8sClusterRegionId'] = request.k8sClusterRegionId;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterPrometheus',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterPrometheus(request: DescribeClusterPrometheusRequest): DescribeClusterPrometheusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterPrometheusWithOptions(request, runtime);
}

model DescribeClustersInServiceMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeClustersInServiceMeshResponseBody = {
  clusters?: [ 
    {
      accessLogDashboards?: [ 
        {
          title?: string(name='Title'),
          url?: string(name='Url'),
        }
      ](name='AccessLogDashboards'),
      clusterDomain?: string(name='ClusterDomain'),
      clusterId?: string(name='ClusterId'),
      clusterType?: string(name='ClusterType'),
      creationTime?: string(name='CreationTime'),
      errorMessage?: string(name='ErrorMessage'),
      logtailInstalledState?: string(name='LogtailInstalledState'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      sgId?: string(name='SgId'),
      state?: string(name='State'),
      updateTime?: string(name='UpdateTime'),
      version?: string(name='Version'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Clusters'),
  requestId?: string(name='RequestId'),
}

model DescribeClustersInServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClustersInServiceMeshResponseBody(name='body'),
}

async function describeClustersInServiceMeshWithOptions(request: DescribeClustersInServiceMeshRequest, runtime: Util.RuntimeOptions): DescribeClustersInServiceMeshResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClustersInServiceMesh',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClustersInServiceMesh(request: DescribeClustersInServiceMeshRequest): DescribeClustersInServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClustersInServiceMeshWithOptions(request, runtime);
}

model DescribeCrTemplatesRequest {
  istioVersion?: string(name='IstioVersion'),
  kind?: string(name='Kind'),
}

model DescribeCrTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  templates?: [ 
    {
      chineseName?: string(name='ChineseName'),
      englishName?: string(name='EnglishName'),
      yaml?: string(name='Yaml'),
    }
  ](name='Templates'),
}

model DescribeCrTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCrTemplatesResponseBody(name='body'),
}

async function describeCrTemplatesWithOptions(request: DescribeCrTemplatesRequest, runtime: Util.RuntimeOptions): DescribeCrTemplatesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.istioVersion)) {
    body['IstioVersion'] = request.istioVersion;
  }
  if (!Util.isUnset(request.kind)) {
    body['Kind'] = request.kind;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCrTemplates',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCrTemplates(request: DescribeCrTemplatesRequest): DescribeCrTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCrTemplatesWithOptions(request, runtime);
}

model DescribeEipResourcesRequest {
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeEipResourcesResponseBody = {
  eipList?: [ 
    {
      allocationId?: string(name='AllocationId'),
      instanceType?: string(name='InstanceType'),
      ipAddress?: string(name='IpAddress'),
      status?: string(name='Status'),
    }
  ](name='EipList'),
  pageResult?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageResult'),
  requestId?: string(name='RequestId'),
}

model DescribeEipResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEipResourcesResponseBody(name='body'),
}

async function describeEipResourcesWithOptions(request: DescribeEipResourcesRequest, runtime: Util.RuntimeOptions): DescribeEipResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEipResources',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEipResources(request: DescribeEipResourcesRequest): DescribeEipResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipResourcesWithOptions(request, runtime);
}

model DescribeGatewaySecretDetailsRequest {
  istioGatewayName?: string(name='IstioGatewayName'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeGatewaySecretDetailsResponseBody = {
  gatewaySecretDetails?: [ 
    {
      expiredTime?: string(name='ExpiredTime'),
      gatewayName?: string(name='GatewayName'),
      issueTime?: string(name='IssueTime'),
      message?: string(name='Message'),
      SNI?: string(name='SNI'),
      secretName?: string(name='SecretName'),
      state?: string(name='State'),
    }
  ](name='GatewaySecretDetails'),
  requestId?: string(name='RequestId'),
}

model DescribeGatewaySecretDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGatewaySecretDetailsResponseBody(name='body'),
}

async function describeGatewaySecretDetailsWithOptions(request: DescribeGatewaySecretDetailsRequest, runtime: Util.RuntimeOptions): DescribeGatewaySecretDetailsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGatewaySecretDetails',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGatewaySecretDetails(request: DescribeGatewaySecretDetailsRequest): DescribeGatewaySecretDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGatewaySecretDetailsWithOptions(request, runtime);
}

model DescribeGuestClusterAccessLogDashboardsRequest {
  k8sClusterId?: string(name='K8sClusterId'),
}

model DescribeGuestClusterAccessLogDashboardsResponseBody = {
  dashboards?: [ 
    {
      title?: string(name='Title'),
      url?: string(name='Url'),
    }
  ](name='Dashboards'),
  k8sClusterId?: string(name='K8sClusterId'),
  requestId?: string(name='RequestId'),
}

model DescribeGuestClusterAccessLogDashboardsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGuestClusterAccessLogDashboardsResponseBody(name='body'),
}

async function describeGuestClusterAccessLogDashboardsWithOptions(request: DescribeGuestClusterAccessLogDashboardsRequest, runtime: Util.RuntimeOptions): DescribeGuestClusterAccessLogDashboardsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.k8sClusterId)) {
    body['K8sClusterId'] = request.k8sClusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGuestClusterAccessLogDashboards',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGuestClusterAccessLogDashboards(request: DescribeGuestClusterAccessLogDashboardsRequest): DescribeGuestClusterAccessLogDashboardsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGuestClusterAccessLogDashboardsWithOptions(request, runtime);
}

model DescribeGuestClusterNamespacesRequest {
  guestClusterID?: string(name='GuestClusterID'),
  serviceMeshId?: string(name='ServiceMeshId'),
  showNsLabels?: boolean(name='ShowNsLabels'),
}

model DescribeGuestClusterNamespacesResponseBody = {
  nsLabels?: map[string]any(name='NsLabels'),
  nsList?: [ string ](name='NsList'),
  requestId?: string(name='RequestId'),
}

model DescribeGuestClusterNamespacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGuestClusterNamespacesResponseBody(name='body'),
}

async function describeGuestClusterNamespacesWithOptions(request: DescribeGuestClusterNamespacesRequest, runtime: Util.RuntimeOptions): DescribeGuestClusterNamespacesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.guestClusterID)) {
    body['GuestClusterID'] = request.guestClusterID;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.showNsLabels)) {
    body['ShowNsLabels'] = request.showNsLabels;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGuestClusterNamespaces',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGuestClusterNamespaces(request: DescribeGuestClusterNamespacesRequest): DescribeGuestClusterNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGuestClusterNamespacesWithOptions(request, runtime);
}

model DescribeGuestClusterPodsRequest {
  guestClusterID?: string(name='GuestClusterID'),
  namespace?: string(name='Namespace'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeGuestClusterPodsResponseBody = {
  podList?: [ string ](name='PodList'),
  requestId?: string(name='RequestId'),
}

model DescribeGuestClusterPodsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGuestClusterPodsResponseBody(name='body'),
}

async function describeGuestClusterPodsWithOptions(request: DescribeGuestClusterPodsRequest, runtime: Util.RuntimeOptions): DescribeGuestClusterPodsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.guestClusterID)) {
    body['GuestClusterID'] = request.guestClusterID;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGuestClusterPods',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGuestClusterPods(request: DescribeGuestClusterPodsRequest): DescribeGuestClusterPodsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGuestClusterPodsWithOptions(request, runtime);
}

model DescribeImportedServicesDetailRequest {
  ASMGatewayName?: string(name='ASMGatewayName'),
  serviceMeshId?: string(name='ServiceMeshId'),
  serviceNamespace?: string(name='ServiceNamespace'),
}

model DescribeImportedServicesDetailResponseBody = {
  details?: [ 
    {
      clusterIds?: [ string ](name='ClusterIds'),
      labels?: map[string]string(name='Labels'),
      namespace?: string(name='Namespace'),
      ports?: [ 
        {
          name?: string(name='Name'),
          nodePort?: int32(name='NodePort'),
          port?: int32(name='Port'),
          protocol?: string(name='Protocol'),
          targetPort?: int32(name='TargetPort'),
        }
      ](name='Ports'),
      serviceName?: string(name='ServiceName'),
      serviceType?: string(name='ServiceType'),
    }
  ](name='Details'),
  requestId?: string(name='RequestId'),
}

model DescribeImportedServicesDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImportedServicesDetailResponseBody(name='body'),
}

async function describeImportedServicesDetailWithOptions(request: DescribeImportedServicesDetailRequest, runtime: Util.RuntimeOptions): DescribeImportedServicesDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ASMGatewayName)) {
    body['ASMGatewayName'] = request.ASMGatewayName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.serviceNamespace)) {
    body['ServiceNamespace'] = request.serviceNamespace;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImportedServicesDetail',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImportedServicesDetail(request: DescribeImportedServicesDetailRequest): DescribeImportedServicesDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImportedServicesDetailWithOptions(request, runtime);
}

model DescribeIngressGatewaysRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeIngressGatewaysResponseBody = {
  ingressGateways?: [  map[string]any ](name='IngressGateways'),
  requestId?: string(name='RequestId'),
}

model DescribeIngressGatewaysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIngressGatewaysResponseBody(name='body'),
}

async function describeIngressGatewaysWithOptions(request: DescribeIngressGatewaysRequest, runtime: Util.RuntimeOptions): DescribeIngressGatewaysResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIngressGateways',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIngressGateways(request: DescribeIngressGatewaysRequest): DescribeIngressGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIngressGatewaysWithOptions(request, runtime);
}

model DescribeIstioGatewayDomainsRequest {
  istioGatewayName?: string(name='IstioGatewayName'),
  limit?: string(name='Limit'),
  namespace?: string(name='Namespace'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeIstioGatewayDomainsResponseBody = {
  gatewaySecretDetails?: [ 
    {
      credentialName?: string(name='CredentialName'),
      detail?: string(name='Detail'),
      domains?: [ string ](name='Domains'),
      namespace?: string(name='Namespace'),
      portName?: string(name='PortName'),
      protocol?: string(name='Protocol'),
    }
  ](name='GatewaySecretDetails'),
  requestId?: string(name='RequestId'),
}

model DescribeIstioGatewayDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIstioGatewayDomainsResponseBody(name='body'),
}

async function describeIstioGatewayDomainsWithOptions(request: DescribeIstioGatewayDomainsRequest, runtime: Util.RuntimeOptions): DescribeIstioGatewayDomainsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIstioGatewayDomains',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIstioGatewayDomains(request: DescribeIstioGatewayDomainsRequest): DescribeIstioGatewayDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIstioGatewayDomainsWithOptions(request, runtime);
}

model DescribeIstioGatewayRouteDetailRequest {
  istioGatewayName?: string(name='IstioGatewayName'),
  routeName?: string(name='RouteName'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeIstioGatewayRouteDetailResponseBody = {
  description?: string(name='Description'),
  namespace?: string(name='Namespace'),
  priority?: int32(name='Priority'),
  requestId?: string(name='RequestId'),
  routeDetail?: {
    domains?: [ string ](name='Domains'),
    HTTPAdvancedOptions?: {
      delegate?: {
        name?: string(name='Name'),
        namespace?: string(name='Namespace'),
      }(name='Delegate'),
      fault?: {
        abort?: {
          httpStatus?: int32(name='HttpStatus'),
          percentage?: {
            value?: float(name='Value'),
          }(name='Percentage'),
        }(name='Abort'),
        delay?: {
          exponentialDelay?: string(name='ExponentialDelay'),
          fixedDelay?: string(name='FixedDelay'),
          percentage?: {
            value?: float(name='Value'),
          }(name='Percentage'),
        }(name='Delay'),
      }(name='Fault'),
      HTTPRedirect?: {
        authority?: string(name='Authority'),
        redirectCode?: int32(name='RedirectCode'),
        uri?: string(name='Uri'),
      }(name='HTTPRedirect'),
      mirror?: {
        host?: string(name='Host'),
        subset?: string(name='Subset'),
      }(name='Mirror'),
      mirrorPercentage?: {
        value?: float(name='Value'),
      }(name='MirrorPercentage'),
      retries?: {
        attempts?: int32(name='Attempts'),
        perTryTimeout?: string(name='PerTryTimeout'),
        retryOn?: string(name='RetryOn'),
        retryRemoteLocalities?: {
          value?: boolean(name='Value'),
        }(name='RetryRemoteLocalities'),
      }(name='Retries'),
      rewrite?: {
        authority?: string(name='Authority'),
        uri?: string(name='Uri'),
      }(name='Rewrite'),
      timeout?: string(name='Timeout'),
    }(name='HTTPAdvancedOptions'),
    matchRequest?: {
      headers?: [ 
        {
          matchingContent?: string(name='MatchingContent'),
          matchingMode?: string(name='MatchingMode'),
          name?: string(name='Name'),
        }
      ](name='Headers'),
      ports?: [ int32 ](name='Ports'),
      TLSMatchAttributes?: [ 
        {
          SNIHosts?: [ string ](name='SNIHosts'),
          TLSPort?: int32(name='TLSPort'),
        }
      ](name='TLSMatchAttributes'),
      URI?: {
        matchingContent?: string(name='MatchingContent'),
        matchingMode?: string(name='MatchingMode'),
      }(name='URI'),
    }(name='MatchRequest'),
    routeDestinations?: [ 
      {
        destination?: {
          host?: string(name='Host'),
          port?: {
            number?: int32(name='Number'),
          }(name='Port'),
          subset?: string(name='Subset'),
        }(name='Destination'),
        headers?: {
          request?: {
            add?: map[string]any(name='Add'),
            remove?: [ string ](name='Remove'),
            set?: map[string]string(name='Set'),
          }(name='Request'),
          response?: {
            add?: map[string]any(name='Add'),
            remove?: [ string ](name='Remove'),
            set?: map[string]any(name='Set'),
          }(name='Response'),
        }(name='Headers'),
        weight?: int32(name='Weight'),
      }
    ](name='RouteDestinations'),
    routeName?: string(name='RouteName'),
    routeType?: string(name='RouteType'),
  }(name='RouteDetail'),
  status?: int32(name='Status'),
}

model DescribeIstioGatewayRouteDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIstioGatewayRouteDetailResponseBody(name='body'),
}

async function describeIstioGatewayRouteDetailWithOptions(request: DescribeIstioGatewayRouteDetailRequest, runtime: Util.RuntimeOptions): DescribeIstioGatewayRouteDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.routeName)) {
    body['RouteName'] = request.routeName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIstioGatewayRouteDetail',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIstioGatewayRouteDetail(request: DescribeIstioGatewayRouteDetailRequest): DescribeIstioGatewayRouteDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIstioGatewayRouteDetailWithOptions(request, runtime);
}

model DescribeIstioGatewayRoutesRequest {
  istioGatewayName?: string(name='IstioGatewayName'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeIstioGatewayRoutesResponseBody = {
  managementRoutes?: [ 
    {
      ASMGatewayName?: string(name='ASMGatewayName'),
      description?: string(name='Description'),
      destinationHost?: [ string ](name='DestinationHost'),
      destinationSubSet?: [ string ](name='DestinationSubSet'),
      namespace?: string(name='Namespace'),
      priority?: int32(name='Priority'),
      routeName?: string(name='RouteName'),
      routePath?: string(name='RoutePath'),
      status?: int32(name='Status'),
    }
  ](name='ManagementRoutes'),
  requestId?: string(name='RequestId'),
}

model DescribeIstioGatewayRoutesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIstioGatewayRoutesResponseBody(name='body'),
}

async function describeIstioGatewayRoutesWithOptions(request: DescribeIstioGatewayRoutesRequest, runtime: Util.RuntimeOptions): DescribeIstioGatewayRoutesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIstioGatewayRoutes',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIstioGatewayRoutes(request: DescribeIstioGatewayRoutesRequest): DescribeIstioGatewayRoutesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIstioGatewayRoutesWithOptions(request, runtime);
}

model DescribeNamespaceScopeSidecarConfigRequest {
  namespace?: string(name='Namespace'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeNamespaceScopeSidecarConfigResponseBody = {
  configPatches?: {
    concurrency?: int32(name='Concurrency'),
    excludeInboundPorts?: string(name='ExcludeInboundPorts'),
    excludeOutboundIPRanges?: string(name='ExcludeOutboundIPRanges'),
    excludeOutboundPorts?: string(name='ExcludeOutboundPorts'),
    holdApplicationUntilProxyStarts?: boolean(name='HoldApplicationUntilProxyStarts'),
    includeInboundPorts?: string(name='IncludeInboundPorts'),
    includeOutboundIPRanges?: string(name='IncludeOutboundIPRanges'),
    includeOutboundPorts?: string(name='IncludeOutboundPorts'),
    istioDNSProxyEnabled?: boolean(name='IstioDNSProxyEnabled'),
    lifecycleStr?: string(name='LifecycleStr'),
    logLevel?: string(name='LogLevel'),
    proxyStatsMatcher?: {
      inclusionPrefixes?: [ string ](name='InclusionPrefixes'),
      inclusionRegexps?: [ string ](name='InclusionRegexps'),
      inclusionSuffixes?: [ string ](name='InclusionSuffixes'),
    }(name='ProxyStatsMatcher'),
    sidecarProxyInitResourceLimit?: {
      resourceCPULimit?: string(name='ResourceCPULimit'),
      resourceMemoryLimit?: string(name='ResourceMemoryLimit'),
    }(name='SidecarProxyInitResourceLimit'),
    sidecarProxyInitResourceRequest?: {
      resourceCPURequest?: string(name='ResourceCPURequest'),
      resourceMemoryRequest?: string(name='ResourceMemoryRequest'),
    }(name='SidecarProxyInitResourceRequest'),
    sidecarProxyResourceLimit?: {
      resourceCPULimit?: string(name='ResourceCPULimit'),
      resourceMemoryLimit?: string(name='ResourceMemoryLimit'),
    }(name='SidecarProxyResourceLimit'),
    sidecarProxyResourceRequest?: {
      resourceCPURequest?: string(name='ResourceCPURequest'),
      resourceMemoryRequest?: string(name='ResourceMemoryRequest'),
    }(name='SidecarProxyResourceRequest'),
    terminationDrainDuration?: string(name='TerminationDrainDuration'),
    tracing?: {
      customTags?: map[string]any(name='CustomTags'),
      maxPathTagLength?: int32(name='MaxPathTagLength'),
      sampling?: double(name='Sampling'),
    }(name='Tracing'),
  }(name='ConfigPatches'),
  requestId?: string(name='RequestId'),
}

model DescribeNamespaceScopeSidecarConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNamespaceScopeSidecarConfigResponseBody(name='body'),
}

async function describeNamespaceScopeSidecarConfigWithOptions(request: DescribeNamespaceScopeSidecarConfigRequest, runtime: Util.RuntimeOptions): DescribeNamespaceScopeSidecarConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNamespaceScopeSidecarConfig',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNamespaceScopeSidecarConfig(request: DescribeNamespaceScopeSidecarConfigRequest): DescribeNamespaceScopeSidecarConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNamespaceScopeSidecarConfigWithOptions(request, runtime);
}

model DescribeNodesInstanceTypeRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeNodesInstanceTypeResponseBody = {
  instanceTypes?: [ 
    {
      key?: string(name='Key'),
      multiBufferEnabled?: boolean(name='MultiBufferEnabled'),
      nodeType?: string(name='NodeType'),
      value?: string(name='Value'),
    }
  ](name='InstanceTypes'),
  requestId?: string(name='RequestId'),
}

model DescribeNodesInstanceTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNodesInstanceTypeResponseBody(name='body'),
}

async function describeNodesInstanceTypeWithOptions(request: DescribeNodesInstanceTypeRequest, runtime: Util.RuntimeOptions): DescribeNodesInstanceTypeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNodesInstanceType',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNodesInstanceType(request: DescribeNodesInstanceTypeRequest): DescribeNodesInstanceTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNodesInstanceTypeWithOptions(request, runtime);
}

model DescribeReusableSlbRequest {
  k8sClusterId?: string(name='K8sClusterId'),
  networkType?: string(name='NetworkType'),
}

model DescribeReusableSlbResponseBody = {
  requestId?: string(name='RequestId'),
  reusableSlbList?: [ 
    {
      loadBalancerId?: string(name='LoadBalancerId'),
      loadBalancerName?: string(name='LoadBalancerName'),
    }
  ](name='ReusableSlbList'),
}

model DescribeReusableSlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeReusableSlbResponseBody(name='body'),
}

async function describeReusableSlbWithOptions(request: DescribeReusableSlbRequest, runtime: Util.RuntimeOptions): DescribeReusableSlbResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.k8sClusterId)) {
    body['K8sClusterId'] = request.k8sClusterId;
  }
  if (!Util.isUnset(request.networkType)) {
    body['NetworkType'] = request.networkType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeReusableSlb',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeReusableSlb(request: DescribeReusableSlbRequest): DescribeReusableSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReusableSlbWithOptions(request, runtime);
}

model DescribeServiceMeshAdditionalStatusRequest {
  checkMode?: string(name='CheckMode'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeServiceMeshAdditionalStatusResponseBody = {
  clusterStatus?: {
    accessLogProjectStatus?: string(name='AccessLogProjectStatus'),
    apiServerEIPStatus?: string(name='ApiServerEIPStatus'),
    apiServerLoadBalancerStatus?: {
      locked?: boolean(name='Locked'),
      payType?: string(name='PayType'),
      reused?: boolean(name='Reused'),
      SLBBackEndServerNumStatus?: string(name='SLBBackEndServerNumStatus'),
      SLBExistStatus?: string(name='SLBExistStatus'),
    }(name='ApiServerLoadBalancerStatus'),
    auditProjectStatus?: string(name='AuditProjectStatus'),
    canaryPilotLoadBalancerStatus?: {
      locked?: boolean(name='Locked'),
      payType?: string(name='PayType'),
      reused?: boolean(name='Reused'),
      SLBBackEndServerNumStatus?: string(name='SLBBackEndServerNumStatus'),
      SLBExistStatus?: string(name='SLBExistStatus'),
    }(name='CanaryPilotLoadBalancerStatus'),
    controlPlaneProjectStatus?: string(name='ControlPlaneProjectStatus'),
    logtailStatusRecord?: map[string]any(name='LogtailStatusRecord'),
    pilotLoadBalancerStatus?: {
      locked?: boolean(name='Locked'),
      payType?: string(name='PayType'),
      reused?: boolean(name='Reused'),
      SLBBackEndServerNumStatus?: string(name='SLBBackEndServerNumStatus'),
      SLBExistStatus?: string(name='SLBExistStatus'),
    }(name='PilotLoadBalancerStatus'),
    sgStatus?: string(name='SgStatus'),
  }(name='ClusterStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeServiceMeshAdditionalStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshAdditionalStatusResponseBody(name='body'),
}

async function describeServiceMeshAdditionalStatusWithOptions(request: DescribeServiceMeshAdditionalStatusRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshAdditionalStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkMode)) {
    body['CheckMode'] = request.checkMode;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshAdditionalStatus',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMeshAdditionalStatus(request: DescribeServiceMeshAdditionalStatusRequest): DescribeServiceMeshAdditionalStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshAdditionalStatusWithOptions(request, runtime);
}

model DescribeServiceMeshClustersRequest {
  limit?: long(name='Limit'),
  offset?: long(name='Offset'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeServiceMeshClustersResponseBody = {
  clusters?: [ 
    {
      clusterDomain?: string(name='ClusterDomain'),
      clusterId?: string(name='ClusterId'),
      clusterType?: string(name='ClusterType'),
      creationTime?: string(name='CreationTime'),
      errorMessage?: string(name='ErrorMessage'),
      forbiddenFlag?: long(name='ForbiddenFlag'),
      forbiddenInfo?: string(name='ForbiddenInfo'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      serviceMeshId?: string(name='ServiceMeshId'),
      sgId?: string(name='SgId'),
      state?: string(name='State'),
      updateTime?: string(name='UpdateTime'),
      version?: string(name='Version'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Clusters'),
  numberOfClusters?: long(name='NumberOfClusters'),
  requestId?: string(name='RequestId'),
}

model DescribeServiceMeshClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshClustersResponseBody(name='body'),
}

async function describeServiceMeshClustersWithOptions(request: DescribeServiceMeshClustersRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshClustersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.offset)) {
    body['Offset'] = request.offset;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshClusters',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMeshClusters(request: DescribeServiceMeshClustersRequest): DescribeServiceMeshClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshClustersWithOptions(request, runtime);
}

model DescribeServiceMeshDetailRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeServiceMeshDetailResponseBody = {
  requestId?: string(name='RequestId'),
  serviceMesh?: {
    clusterSpec?: string(name='ClusterSpec'),
    clusters?: [ string ](name='Clusters'),
    endpoints?: {
      intranetApiServerEndpoint?: string(name='IntranetApiServerEndpoint'),
      intranetPilotEndpoint?: string(name='IntranetPilotEndpoint'),
      publicApiServerEndpoint?: string(name='PublicApiServerEndpoint'),
      publicPilotEndpoint?: string(name='PublicPilotEndpoint'),
    }(name='Endpoints'),
    ownerId?: string(name='OwnerId'),
    ownerType?: string(name='OwnerType'),
    serviceMeshInfo?: {
      creationTime?: string(name='CreationTime'),
      errorMessage?: string(name='ErrorMessage'),
      name?: string(name='Name'),
      profile?: string(name='Profile'),
      regionId?: string(name='RegionId'),
      serviceMeshId?: string(name='ServiceMeshId'),
      state?: string(name='State'),
      updateTime?: string(name='UpdateTime'),
      version?: string(name='Version'),
    }(name='ServiceMeshInfo'),
    spec?: {
      loadBalancer?: {
        apiServerLoadbalancerId?: string(name='ApiServerLoadbalancerId'),
        apiServerPublicEip?: boolean(name='ApiServerPublicEip'),
        pilotPublicEip?: boolean(name='PilotPublicEip'),
        pilotPublicLoadbalancerId?: string(name='PilotPublicLoadbalancerId'),
      }(name='LoadBalancer'),
      meshConfig?: {
        accessLog?: {
          enabled?: boolean(name='Enabled'),
          project?: string(name='Project'),
        }(name='AccessLog'),
        audit?: {
          auditProjectStatus?: string(name='AuditProjectStatus'),
          enabled?: boolean(name='Enabled'),
          project?: string(name='Project'),
        }(name='Audit'),
        controlPlaneLogInfo?: {
          enabled?: boolean(name='Enabled'),
          project?: string(name='Project'),
        }(name='ControlPlaneLogInfo'),
        customizedZipkin?: boolean(name='CustomizedZipkin'),
        edition?: {
          istiodImageTag?: string(name='IstiodImageTag'),
          name?: string(name='Name'),
          proxyImageTag?: string(name='ProxyImageTag'),
        }(name='Edition'),
        enableLocalityLB?: boolean(name='EnableLocalityLB'),
        excludeIPRanges?: string(name='ExcludeIPRanges'),
        excludeInboundPorts?: string(name='ExcludeInboundPorts'),
        excludeOutboundPorts?: string(name='ExcludeOutboundPorts'),
        extraConfiguration?: {
          accessLogExtraConf?: {
            gatewayLifecycle?: int32(name='GatewayLifecycle'),
            sidecarLifecycle?: int32(name='SidecarLifecycle'),
          }(name='AccessLogExtraConf'),
          autoDiagnosis?: {
            autoDiagnosisEnabled?: boolean(name='AutoDiagnosisEnabled'),
          }(name='AutoDiagnosis'),
          CRAggregationConfiguration?: {
            enabled?: boolean(name='Enabled'),
          }(name='CRAggregationConfiguration'),
          CRAggregationEnabled?: boolean(name='CRAggregationEnabled'),
          discoverySelectors?: [  map[string]any ](name='DiscoverySelectors'),
          istioCRHistory?: {
            enableHistory?: boolean(name='EnableHistory'),
          }(name='IstioCRHistory'),
          lifecycle?: {
            postStart?: {
              exec?: {
                command?: [ string ](name='command'),
              }(name='exec'),
              httpGet?: {
                host?: string(name='host'),
                httpHeaders?: [ 
                  {
                    name?: string(name='name'),
                    value?: string(name='value'),
                  }
                ](name='httpHeaders'),
                port?: string(name='port'),
                scheme?: string(name='scheme'),
              }(name='httpGet'),
              tcpSocket?: {
                host?: string(name='host'),
                port?: string(name='port'),
              }(name='tcpSocket'),
            }(name='postStart'),
            preStop?: {
              exec?: {
                command?: [ string ](name='command'),
              }(name='exec'),
              httpGet?: {
                host?: string(name='host'),
                httpHeaders?: [ 
                  {
                    name?: string(name='name'),
                    value?: string(name='value'),
                  }
                ](name='httpHeaders'),
                port?: string(name='port'),
                scheme?: string(name='scheme'),
              }(name='httpGet'),
              tcpSocket?: {
                host?: string(name='host'),
                port?: string(name='port'),
              }(name='tcpSocket'),
            }(name='preStop'),
          }(name='Lifecycle'),
          multiBuffer?: {
            enabled?: boolean(name='Enabled'),
            pollDelay?: string(name='PollDelay'),
          }(name='MultiBuffer'),
          NFDConfiguration?: {
            enabled?: boolean(name='Enabled'),
            NFDLabelPruned?: boolean(name='NFDLabelPruned'),
          }(name='NFDConfiguration'),
          OPAScopeInjection?: {
            OPAScopeInjected?: boolean(name='OPAScopeInjected'),
          }(name='OPAScopeInjection'),
          rateLimit?: {
            enableGlobalRateLimit?: boolean(name='EnableGlobalRateLimit'),
          }(name='RateLimit'),
          sidecarProxyInitResourceLimit?: {
            resourceCPULimit?: string(name='ResourceCPULimit'),
            resourceMemoryLimit?: string(name='ResourceMemoryLimit'),
          }(name='SidecarProxyInitResourceLimit'),
          sidecarProxyInitResourceRequest?: {
            resourceCPURequest?: string(name='ResourceCPURequest'),
            resourceMemoryRequest?: string(name='ResourceMemoryRequest'),
          }(name='SidecarProxyInitResourceRequest'),
          terminationDrainDuration?: string(name='TerminationDrainDuration'),
        }(name='ExtraConfiguration'),
        includeIPRanges?: string(name='IncludeIPRanges'),
        k8sNewAPIsSupport?: {
          gatewayAPIEnabled?: boolean(name='GatewayAPIEnabled'),
        }(name='K8sNewAPIsSupport'),
        kiali?: {
          enabled?: boolean(name='Enabled'),
          url?: string(name='Url'),
        }(name='Kiali'),
        localityLB?: {
          distribute?: map[string]any(name='Distribute'),
          enabled?: boolean(name='Enabled'),
          failover?: map[string]any(name='Failover'),
        }(name='LocalityLB'),
        MSE?: {
          enabled?: boolean(name='Enabled'),
        }(name='MSE'),
        OPA?: {
          enabled?: boolean(name='Enabled'),
          limitCPU?: string(name='LimitCPU'),
          limitMemory?: string(name='LimitMemory'),
          logLevel?: string(name='LogLevel'),
          requestCPU?: string(name='RequestCPU'),
          requestMemory?: string(name='RequestMemory'),
        }(name='OPA'),
        outboundTrafficPolicy?: string(name='OutboundTrafficPolicy'),
        pilot?: {
          configSource?: {
            enabled?: boolean(name='Enabled'),
            nacosID?: string(name='NacosID'),
          }(name='ConfigSource'),
          feature?: {
            enableSDSServer?: boolean(name='EnableSDSServer'),
            filterGatewayClusterConfig?: boolean(name='FilterGatewayClusterConfig'),
          }(name='Feature'),
          http10Enabled?: boolean(name='Http10Enabled'),
          traceSampling?: float(name='TraceSampling'),
        }(name='Pilot'),
        prometheus?: {
          externalUrl?: string(name='ExternalUrl'),
          useExternal?: boolean(name='UseExternal'),
        }(name='Prometheus'),
        protocolSupport?: {
          dubboFilterEnabled?: boolean(name='DubboFilterEnabled'),
          mysqlFilterEnabled?: boolean(name='MysqlFilterEnabled'),
          redisFilterEnabled?: boolean(name='RedisFilterEnabled'),
          thriftFilterEnabled?: boolean(name='ThriftFilterEnabled'),
        }(name='ProtocolSupport'),
        proxy?: {
          accessLogFile?: string(name='AccessLogFile'),
          accessLogFormat?: string(name='AccessLogFormat'),
          accessLogServiceEnabled?: boolean(name='AccessLogServiceEnabled'),
          accessLogServiceHost?: string(name='AccessLogServiceHost'),
          accessLogServicePort?: int32(name='AccessLogServicePort'),
          clusterDomain?: string(name='ClusterDomain'),
          enableDNSProxying?: boolean(name='EnableDNSProxying'),
          limitCPU?: string(name='LimitCPU'),
          limitMemory?: string(name='LimitMemory'),
          requestCPU?: string(name='RequestCPU'),
          requestMemory?: string(name='RequestMemory'),
        }(name='Proxy'),
        sidecarInjector?: {
          autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled'),
          enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault'),
          initCNIConfiguration?: {
            enabled?: boolean(name='Enabled'),
            excludeNamespaces?: string(name='ExcludeNamespaces'),
          }(name='InitCNIConfiguration'),
          limitCPU?: string(name='LimitCPU'),
          limitMemory?: string(name='LimitMemory'),
          requestCPU?: string(name='RequestCPU'),
          requestMemory?: string(name='RequestMemory'),
          sidecarInjectorNum?: int32(name='SidecarInjectorNum'),
          sidecarInjectorWebhookAsYaml?: string(name='SidecarInjectorWebhookAsYaml'),
        }(name='SidecarInjector'),
        telemetry?: boolean(name='Telemetry'),
        tracing?: boolean(name='Tracing'),
        webAssemblyFilterDeployment?: {
          enabled?: boolean(name='Enabled'),
        }(name='WebAssemblyFilterDeployment'),
      }(name='MeshConfig'),
      network?: {
        securityGroupId?: string(name='SecurityGroupId'),
        vSwitches?: [ string ](name='VSwitches'),
        vpcId?: string(name='VpcId'),
      }(name='Network'),
    }(name='Spec'),
  }(name='ServiceMesh'),
}

model DescribeServiceMeshDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshDetailResponseBody(name='body'),
}

async function describeServiceMeshDetailWithOptions(request: DescribeServiceMeshDetailRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshDetail',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMeshDetail(request: DescribeServiceMeshDetailRequest): DescribeServiceMeshDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshDetailWithOptions(request, runtime);
}

model DescribeServiceMeshKubeconfigRequest {
  privateIpAddress?: boolean(name='PrivateIpAddress'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeServiceMeshKubeconfigResponseBody = {
  kubeconfig?: string(name='Kubeconfig'),
  requestId?: string(name='RequestId'),
}

model DescribeServiceMeshKubeconfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshKubeconfigResponseBody(name='body'),
}

async function describeServiceMeshKubeconfigWithOptions(request: DescribeServiceMeshKubeconfigRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshKubeconfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshKubeconfig',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMeshKubeconfig(request: DescribeServiceMeshKubeconfigRequest): DescribeServiceMeshKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshKubeconfigWithOptions(request, runtime);
}

model DescribeServiceMeshLogsRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeServiceMeshLogsResponseBody = {
  logs?: [ 
    {
      creationTime?: string(name='CreationTime'),
      log?: string(name='Log'),
      serviceMeshId?: string(name='ServiceMeshId'),
    }
  ](name='Logs'),
  requestId?: string(name='RequestId'),
}

model DescribeServiceMeshLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshLogsResponseBody(name='body'),
}

async function describeServiceMeshLogsWithOptions(request: DescribeServiceMeshLogsRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshLogsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshLogs',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMeshLogs(request: DescribeServiceMeshLogsRequest): DescribeServiceMeshLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshLogsWithOptions(request, runtime);
}

model DescribeServiceMeshProxyStatusRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeServiceMeshProxyStatusResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  proxyStatus?: [ 
    {
      clusterSynced?: string(name='ClusterSynced'),
      endpointPercent?: string(name='EndpointPercent'),
      endpointSynced?: string(name='EndpointSynced'),
      istioVersion?: string(name='IstioVersion'),
      listenerSynced?: string(name='ListenerSynced'),
      proxyId?: string(name='ProxyId'),
      proxyVersion?: string(name='ProxyVersion'),
      routeSynced?: string(name='RouteSynced'),
    }
  ](name='ProxyStatus'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeServiceMeshProxyStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshProxyStatusResponseBody(name='body'),
}

async function describeServiceMeshProxyStatusWithOptions(request: DescribeServiceMeshProxyStatusRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshProxyStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshProxyStatus',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMeshProxyStatus(request: DescribeServiceMeshProxyStatusRequest): DescribeServiceMeshProxyStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshProxyStatusWithOptions(request, runtime);
}

model DescribeServiceMeshUpgradeStatusRequest {
  allIstioGatewayFullNames?: string(name='AllIstioGatewayFullNames'),
  guestClusterIds?: string(name='GuestClusterIds'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeServiceMeshUpgradeStatusResponseBody = {
  requestId?: string(name='RequestId'),
  upgradeDetail?: {
    finishedGatewaysNum?: long(name='FinishedGatewaysNum'),
    gatewayStatusRecord?: map[string]UpgradeDetailGatewayStatusRecordValue(name='GatewayStatusRecord'),
    meshStatus?: string(name='MeshStatus'),
    totalGatewaysNum?: long(name='TotalGatewaysNum'),
  }(name='UpgradeDetail'),
}

model DescribeServiceMeshUpgradeStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshUpgradeStatusResponseBody(name='body'),
}

async function describeServiceMeshUpgradeStatusWithOptions(request: DescribeServiceMeshUpgradeStatusRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshUpgradeStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.allIstioGatewayFullNames)) {
    body['AllIstioGatewayFullNames'] = request.allIstioGatewayFullNames;
  }
  if (!Util.isUnset(request.guestClusterIds)) {
    body['GuestClusterIds'] = request.guestClusterIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshUpgradeStatus',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMeshUpgradeStatus(request: DescribeServiceMeshUpgradeStatusRequest): DescribeServiceMeshUpgradeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshUpgradeStatusWithOptions(request, runtime);
}

model DescribeServiceMeshVMsRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeServiceMeshVMsResponseBody = {
  requestId?: string(name='RequestId'),
  VMs?: [ 
    {
      hasTag?: boolean(name='HasTag'),
      hostName?: string(name='HostName'),
      instanceId?: string(name='InstanceId'),
      ipAddress?: string(name='IpAddress'),
      region?: string(name='Region'),
      securityGroupIds?: string(name='SecurityGroupIds'),
      serviceMeshId?: string(name='ServiceMeshId'),
      status?: string(name='Status'),
    }
  ](name='VMs'),
}

model DescribeServiceMeshVMsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshVMsResponseBody(name='body'),
}

async function describeServiceMeshVMsWithOptions(request: DescribeServiceMeshVMsRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshVMsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshVMs',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMeshVMs(request: DescribeServiceMeshVMsRequest): DescribeServiceMeshVMsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshVMsWithOptions(request, runtime);
}

model DescribeServiceMeshesResponseBody = {
  requestId?: string(name='RequestId'),
  serviceMeshes?: [ 
    {
      clusterSpec?: string(name='ClusterSpec'),
      clusters?: [ string ](name='Clusters'),
      endpoints?: {
        intranetApiServerEndpoint?: string(name='IntranetApiServerEndpoint'),
        intranetPilotEndpoint?: string(name='IntranetPilotEndpoint'),
        publicApiServerEndpoint?: string(name='PublicApiServerEndpoint'),
        publicPilotEndpoint?: string(name='PublicPilotEndpoint'),
        reverseTunnelEndpoint?: string(name='ReverseTunnelEndpoint'),
      }(name='Endpoints'),
      ownerId?: string(name='OwnerId'),
      ownerType?: string(name='OwnerType'),
      serviceMeshInfo?: {
        creationTime?: string(name='CreationTime'),
        errorMessage?: string(name='ErrorMessage'),
        name?: string(name='Name'),
        profile?: string(name='Profile'),
        regionId?: string(name='RegionId'),
        serviceMeshId?: string(name='ServiceMeshId'),
        state?: string(name='State'),
        updateTime?: string(name='UpdateTime'),
        version?: string(name='Version'),
      }(name='ServiceMeshInfo'),
      spec?: {
        loadBalancer?: {
          apiServerLoadbalancerId?: string(name='ApiServerLoadbalancerId'),
          apiServerPublicEip?: boolean(name='ApiServerPublicEip'),
          pilotPublicEip?: boolean(name='PilotPublicEip'),
          pilotPublicLoadbalancerId?: string(name='PilotPublicLoadbalancerId'),
        }(name='LoadBalancer'),
        meshConfig?: {
          mtls?: boolean(name='Mtls'),
          outboundTrafficPolicy?: string(name='OutboundTrafficPolicy'),
          pilot?: {
            http10Enabled?: boolean(name='Http10Enabled'),
            traceSampling?: float(name='TraceSampling'),
          }(name='Pilot'),
          sidecarInjector?: {
            autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled'),
            enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault'),
            initCNIConfiguration?: {
              enabled?: boolean(name='Enabled'),
              excludeNamespaces?: string(name='ExcludeNamespaces'),
            }(name='InitCNIConfiguration'),
          }(name='SidecarInjector'),
          strictMtls?: boolean(name='StrictMtls'),
          telemetry?: boolean(name='Telemetry'),
          tracing?: boolean(name='Tracing'),
        }(name='MeshConfig'),
        network?: {
          securityGroupId?: string(name='SecurityGroupId'),
          vSwitches?: [ string ](name='VSwitches'),
          vpcId?: string(name='VpcId'),
        }(name='Network'),
      }(name='Spec'),
    }
  ](name='ServiceMeshes'),
}

model DescribeServiceMeshesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServiceMeshesResponseBody(name='body'),
}

async function describeServiceMeshesWithOptions(runtime: Util.RuntimeOptions): DescribeServiceMeshesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeServiceMeshes',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServiceMeshes(): DescribeServiceMeshesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshesWithOptions(runtime);
}

model DescribeUpgradeVersionRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeUpgradeVersionResponseBody = {
  requestId?: string(name='RequestId'),
  version?: {
    istioOperatorVersion?: string(name='IstioOperatorVersion'),
    istioVersion?: string(name='IstioVersion'),
    kubernetesVersion?: string(name='KubernetesVersion'),
  }(name='Version'),
}

model DescribeUpgradeVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUpgradeVersionResponseBody(name='body'),
}

async function describeUpgradeVersionWithOptions(request: DescribeUpgradeVersionRequest, runtime: Util.RuntimeOptions): DescribeUpgradeVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUpgradeVersion',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUpgradeVersion(request: DescribeUpgradeVersionRequest): DescribeUpgradeVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUpgradeVersionWithOptions(request, runtime);
}

model DescribeUserPermissionsRequest {
  subAccountUserId?: string(name='SubAccountUserId'),
}

model DescribeUserPermissionsResponseBody = {
  permissions?: [ 
    {
      isRamRole?: string(name='IsRamRole'),
      parentId?: string(name='ParentId'),
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      roleName?: string(name='RoleName'),
      roleType?: string(name='RoleType'),
    }
  ](name='Permissions'),
  requestId?: string(name='RequestId'),
}

model DescribeUserPermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUserPermissionsResponseBody(name='body'),
}

async function describeUserPermissionsWithOptions(request: DescribeUserPermissionsRequest, runtime: Util.RuntimeOptions): DescribeUserPermissionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.subAccountUserId)) {
    body['SubAccountUserId'] = request.subAccountUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserPermissions',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUserPermissions(request: DescribeUserPermissionsRequest): DescribeUserPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserPermissionsWithOptions(request, runtime);
}

model DescribeUsersWithPermissionsRequest {
  userType?: string(name='UserType'),
}

model DescribeUsersWithPermissionsResponseBody = {
  requestId?: string(name='RequestId'),
  UIDs?: [ string ](name='UIDs'),
}

model DescribeUsersWithPermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUsersWithPermissionsResponseBody(name='body'),
}

async function describeUsersWithPermissionsWithOptions(request: DescribeUsersWithPermissionsRequest, runtime: Util.RuntimeOptions): DescribeUsersWithPermissionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.userType)) {
    body['UserType'] = request.userType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUsersWithPermissions',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUsersWithPermissions(request: DescribeUsersWithPermissionsRequest): DescribeUsersWithPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUsersWithPermissionsWithOptions(request, runtime);
}

model DescribeVMsInServiceMeshRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeVMsInServiceMeshResponseBody = {
  requestId?: string(name='RequestId'),
  VMs?: [ 
    {
      hasTag?: boolean(name='HasTag'),
      hostName?: string(name='HostName'),
      instanceId?: string(name='InstanceId'),
      ipAddress?: string(name='IpAddress'),
      region?: string(name='Region'),
      securityGroupIds?: string(name='SecurityGroupIds'),
      status?: string(name='Status'),
    }
  ](name='VMs'),
}

model DescribeVMsInServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVMsInServiceMeshResponseBody(name='body'),
}

async function describeVMsInServiceMeshWithOptions(request: DescribeVMsInServiceMeshRequest, runtime: Util.RuntimeOptions): DescribeVMsInServiceMeshResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVMsInServiceMesh',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVMsInServiceMesh(request: DescribeVMsInServiceMeshRequest): DescribeVMsInServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVMsInServiceMeshWithOptions(request, runtime);
}

model DescribeVSwitchesRequest {
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
}

model DescribeVSwitchesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vSwitches?: [ 
    {
      isDefault?: boolean(name='IsDefault'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vSwitchName?: string(name='VSwitchName'),
      vpcId?: string(name='VpcId'),
    }
  ](name='VSwitches'),
}

model DescribeVSwitchesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVSwitchesResponseBody(name='body'),
}

async function describeVSwitchesWithOptions(request: DescribeVSwitchesRequest, runtime: Util.RuntimeOptions): DescribeVSwitchesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVSwitches',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVSwitchesWithOptions(request, runtime);
}

model DescribeVersionsResponseBody = {
  requestId?: string(name='RequestId'),
  versionInfo?: [ 
    {
      edition?: string(name='Edition'),
      versions?: [ string ](name='Versions'),
    }
  ](name='VersionInfo'),
}

model DescribeVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVersionsResponseBody(name='body'),
}

async function describeVersionsWithOptions(runtime: Util.RuntimeOptions): DescribeVersionsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeVersions',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVersions(): DescribeVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVersionsWithOptions(runtime);
}

model DescribeVpcsRequest {
  regionId?: string(name='RegionId'),
}

model DescribeVpcsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpcs?: [ 
    {
      isDefault?: boolean(name='IsDefault'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
    }
  ](name='Vpcs'),
}

model DescribeVpcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVpcsResponseBody(name='body'),
}

async function describeVpcsWithOptions(request: DescribeVpcsRequest, runtime: Util.RuntimeOptions): DescribeVpcsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVpcs',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVpcs(request: DescribeVpcsRequest): DescribeVpcsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcsWithOptions(request, runtime);
}

model GetCaCertRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetCaCertResponseBody = {
  caCert?: string(name='CaCert'),
  requestId?: string(name='RequestId'),
}

model GetCaCertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCaCertResponseBody(name='body'),
}

async function getCaCertWithOptions(request: GetCaCertRequest, runtime: Util.RuntimeOptions): GetCaCertResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetCaCert',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCaCert(request: GetCaCertRequest): GetCaCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCaCertWithOptions(request, runtime);
}

model GetDeploymentBySelectorRequest {
  guestCluster?: string(name='GuestCluster'),
  labelSelector?: map[string]string(name='LabelSelector'),
  limit?: long(name='Limit'),
  mark?: string(name='Mark'),
  nameSpace?: string(name='NameSpace'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetDeploymentBySelectorShrinkRequest {
  guestCluster?: string(name='GuestCluster'),
  labelSelectorShrink?: string(name='LabelSelector'),
  limit?: long(name='Limit'),
  mark?: string(name='Mark'),
  nameSpace?: string(name='NameSpace'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetDeploymentBySelectorResponseBody = {
  deploymentNameList?: [ bytes ](name='DeploymentNameList'),
  mark?: string(name='Mark'),
  requestId?: string(name='RequestId'),
}

model GetDeploymentBySelectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeploymentBySelectorResponseBody(name='body'),
}

async function getDeploymentBySelectorWithOptions(tmpReq: GetDeploymentBySelectorRequest, runtime: Util.RuntimeOptions): GetDeploymentBySelectorResponse {
  Util.validateModel(tmpReq);
  var request = new GetDeploymentBySelectorShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.labelSelector)) {
    request.labelSelectorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labelSelector, 'LabelSelector', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.guestCluster)) {
    body['GuestCluster'] = request.guestCluster;
  }
  if (!Util.isUnset(request.labelSelectorShrink)) {
    body['LabelSelector'] = request.labelSelectorShrink;
  }
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.mark)) {
    body['Mark'] = request.mark;
  }
  if (!Util.isUnset(request.nameSpace)) {
    body['NameSpace'] = request.nameSpace;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDeploymentBySelector',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeploymentBySelector(request: GetDeploymentBySelectorRequest): GetDeploymentBySelectorResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeploymentBySelectorWithOptions(request, runtime);
}

model GetGrafanaDashboardUrlRequest {
  k8sClusterId?: string(name='K8sClusterId'),
  serviceMeshId?: string(name='ServiceMeshId'),
  title?: string(name='Title'),
}

model GetGrafanaDashboardUrlResponseBody = {
  dashboards?: [ 
    {
      title?: string(name='Title'),
      url?: string(name='Url'),
    }
  ](name='Dashboards'),
  requestId?: string(name='RequestId'),
}

model GetGrafanaDashboardUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGrafanaDashboardUrlResponseBody(name='body'),
}

async function getGrafanaDashboardUrlWithOptions(request: GetGrafanaDashboardUrlRequest, runtime: Util.RuntimeOptions): GetGrafanaDashboardUrlResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.k8sClusterId)) {
    body['K8sClusterId'] = request.k8sClusterId;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetGrafanaDashboardUrl',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGrafanaDashboardUrl(request: GetGrafanaDashboardUrlRequest): GetGrafanaDashboardUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGrafanaDashboardUrlWithOptions(request, runtime);
}

model GetRegisteredServiceEndpointsRequest {
  clusterIds?: string(name='ClusterIds'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  serviceMeshId?: string(name='ServiceMeshId'),
  serviceType?: string(name='ServiceType'),
}

model GetRegisteredServiceEndpointsResponseBody = {
  endPointSlice?: {
    endpointsDetails?: [ 
      {
        address?: string(name='Address'),
        hostname?: string(name='Hostname'),
        podName?: string(name='PodName'),
        ports?: [ int32 ](name='Ports'),
        region?: string(name='Region'),
        sidecarInjected?: boolean(name='SidecarInjected'),
      }
    ](name='EndpointsDetails'),
    location?: string(name='Location'),
    namespace?: string(name='Namespace'),
    serviceName?: string(name='ServiceName'),
  }(name='EndPointSlice'),
  requestId?: string(name='RequestId'),
  serviceEndpoints?: [ 
    {
      address?: string(name='Address'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='ServiceEndpoints'),
}

model GetRegisteredServiceEndpointsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRegisteredServiceEndpointsResponseBody(name='body'),
}

async function getRegisteredServiceEndpointsWithOptions(request: GetRegisteredServiceEndpointsRequest, runtime: Util.RuntimeOptions): GetRegisteredServiceEndpointsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clusterIds)) {
    body['ClusterIds'] = request.clusterIds;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.serviceType)) {
    body['ServiceType'] = request.serviceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetRegisteredServiceEndpoints',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRegisteredServiceEndpoints(request: GetRegisteredServiceEndpointsRequest): GetRegisteredServiceEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegisteredServiceEndpointsWithOptions(request, runtime);
}

model GetRegisteredServiceNamespacesRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetRegisteredServiceNamespacesResponseBody = {
  namespaces?: [ string ](name='Namespaces'),
  requestId?: string(name='RequestId'),
}

model GetRegisteredServiceNamespacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRegisteredServiceNamespacesResponseBody(name='body'),
}

async function getRegisteredServiceNamespacesWithOptions(request: GetRegisteredServiceNamespacesRequest, runtime: Util.RuntimeOptions): GetRegisteredServiceNamespacesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetRegisteredServiceNamespaces',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRegisteredServiceNamespaces(request: GetRegisteredServiceNamespacesRequest): GetRegisteredServiceNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegisteredServiceNamespacesWithOptions(request, runtime);
}

model GetSwimLaneDetailRequest {
  groupName?: string(name='GroupName'),
  serviceMeshId?: string(name='ServiceMeshId'),
  swimLaneName?: string(name='SwimLaneName'),
}

model GetSwimLaneDetailResponseBody = {
  ingressRule?: string(name='IngressRule'),
  ingressService?: string(name='IngressService'),
  labelSelectorKey?: string(name='LabelSelectorKey'),
  labelSelectorValue?: string(name='LabelSelectorValue'),
  requestId?: string(name='RequestId'),
  servicesList?: string(name='ServicesList'),
}

model GetSwimLaneDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSwimLaneDetailResponseBody(name='body'),
}

async function getSwimLaneDetailWithOptions(request: GetSwimLaneDetailRequest, runtime: Util.RuntimeOptions): GetSwimLaneDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    body['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.swimLaneName)) {
    body['SwimLaneName'] = request.swimLaneName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetSwimLaneDetail',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSwimLaneDetail(request: GetSwimLaneDetailRequest): GetSwimLaneDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSwimLaneDetailWithOptions(request, runtime);
}

model GetSwimLaneGroupListRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetSwimLaneGroupListResponseBody = {
  requestId?: string(name='RequestId'),
  swimLaneGroupList?: [ 
    {
      groupName?: string(name='GroupName'),
      ingressGatewayName?: string(name='IngressGatewayName'),
      ingressType?: string(name='IngressType'),
      serviceList?: string(name='ServiceList'),
    }
  ](name='SwimLaneGroupList'),
}

model GetSwimLaneGroupListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSwimLaneGroupListResponseBody(name='body'),
}

async function getSwimLaneGroupListWithOptions(request: GetSwimLaneGroupListRequest, runtime: Util.RuntimeOptions): GetSwimLaneGroupListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetSwimLaneGroupList',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSwimLaneGroupList(request: GetSwimLaneGroupListRequest): GetSwimLaneGroupListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSwimLaneGroupListWithOptions(request, runtime);
}

model GetSwimLaneListRequest {
  groupName?: string(name='GroupName'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetSwimLaneListResponseBody = {
  requestId?: string(name='RequestId'),
  swimLaneList?: [ 
    {
      groupName?: string(name='GroupName'),
      ingressRule?: string(name='IngressRule'),
      ingressService?: string(name='IngressService'),
      labelSelectorKey?: string(name='LabelSelectorKey'),
      labelSelectorValue?: string(name='LabelSelectorValue'),
      name?: string(name='Name'),
      serviceList?: string(name='ServiceList'),
    }
  ](name='SwimLaneList'),
}

model GetSwimLaneListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSwimLaneListResponseBody(name='body'),
}

async function getSwimLaneListWithOptions(request: GetSwimLaneListRequest, runtime: Util.RuntimeOptions): GetSwimLaneListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    body['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetSwimLaneList',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSwimLaneList(request: GetSwimLaneListRequest): GetSwimLaneListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSwimLaneListWithOptions(request, runtime);
}

model GetVmAppMeshInfoRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model GetVmAppMeshInfoResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetVmAppMeshInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVmAppMeshInfoResponseBody(name='body'),
}

async function getVmAppMeshInfoWithOptions(request: GetVmAppMeshInfoRequest, runtime: Util.RuntimeOptions): GetVmAppMeshInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVmAppMeshInfo',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVmAppMeshInfo(request: GetVmAppMeshInfoRequest): GetVmAppMeshInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVmAppMeshInfoWithOptions(request, runtime);
}

model GetVmMetaRequest {
  namespace?: string(name='Namespace'),
  serviceAccount?: string(name='ServiceAccount'),
  serviceMeshId?: string(name='ServiceMeshId'),
  trustDomain?: string(name='TrustDomain'),
}

model GetVmMetaResponseBody = {
  requestId?: string(name='RequestId'),
  vmMetaInfo?: {
    envoyEnvContent?: string(name='EnvoyEnvContent'),
    hostsContent?: string(name='HostsContent'),
    tokenContent?: string(name='TokenContent'),
  }(name='VmMetaInfo'),
}

model GetVmMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVmMetaResponseBody(name='body'),
}

async function getVmMetaWithOptions(request: GetVmMetaRequest, runtime: Util.RuntimeOptions): GetVmMetaResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVmMeta',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVmMeta(request: GetVmMetaRequest): GetVmMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVmMetaWithOptions(request, runtime);
}

model GrantUserPermissionsRequest {
  permissions?: string(name='Permissions'),
  subAccountUserId?: string(name='SubAccountUserId'),
}

model GrantUserPermissionsResponseBody = {
  requestId?: string(name='RequestId'),
}

model GrantUserPermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GrantUserPermissionsResponseBody(name='body'),
}

async function grantUserPermissionsWithOptions(request: GrantUserPermissionsRequest, runtime: Util.RuntimeOptions): GrantUserPermissionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.permissions)) {
    body['Permissions'] = request.permissions;
  }
  if (!Util.isUnset(request.subAccountUserId)) {
    body['SubAccountUserId'] = request.subAccountUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GrantUserPermissions',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function grantUserPermissions(request: GrantUserPermissionsRequest): GrantUserPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return grantUserPermissionsWithOptions(request, runtime);
}

model ModifyApiServerEipResourceRequest {
  apiServerEipId?: string(name='ApiServerEipId'),
  operation?: string(name='Operation'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model ModifyApiServerEipResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyApiServerEipResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyApiServerEipResourceResponseBody(name='body'),
}

async function modifyApiServerEipResourceWithOptions(request: ModifyApiServerEipResourceRequest, runtime: Util.RuntimeOptions): ModifyApiServerEipResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apiServerEipId)) {
    body['ApiServerEipId'] = request.apiServerEipId;
  }
  if (!Util.isUnset(request.operation)) {
    body['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyApiServerEipResource',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyApiServerEipResource(request: ModifyApiServerEipResourceRequest): ModifyApiServerEipResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyApiServerEipResourceWithOptions(request, runtime);
}

model ModifyServiceMeshNameRequest {
  name?: string(name='Name'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model ModifyServiceMeshNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyServiceMeshNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyServiceMeshNameResponseBody(name='body'),
}

async function modifyServiceMeshNameWithOptions(request: ModifyServiceMeshNameRequest, runtime: Util.RuntimeOptions): ModifyServiceMeshNameResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyServiceMeshName',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyServiceMeshName(request: ModifyServiceMeshNameRequest): ModifyServiceMeshNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyServiceMeshNameWithOptions(request, runtime);
}

model ReActivateAuditRequest {
  enableAudit?: boolean(name='EnableAudit'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model ReActivateAuditResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ReActivateAuditResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReActivateAuditResponseBody(name='body'),
}

async function reActivateAuditWithOptions(request: ReActivateAuditRequest, runtime: Util.RuntimeOptions): ReActivateAuditResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.enableAudit)) {
    body['EnableAudit'] = request.enableAudit;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReActivateAudit',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reActivateAudit(request: ReActivateAuditRequest): ReActivateAuditResponse {
  var runtime = new Util.RuntimeOptions{};
  return reActivateAuditWithOptions(request, runtime);
}

model RemoveClusterFromServiceMeshRequest {
  clusterId?: string(name='ClusterId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model RemoveClusterFromServiceMeshResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model RemoveClusterFromServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveClusterFromServiceMeshResponseBody(name='body'),
}

async function removeClusterFromServiceMeshWithOptions(request: RemoveClusterFromServiceMeshRequest, runtime: Util.RuntimeOptions): RemoveClusterFromServiceMeshResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveClusterFromServiceMesh',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeClusterFromServiceMesh(request: RemoveClusterFromServiceMeshRequest): RemoveClusterFromServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeClusterFromServiceMeshWithOptions(request, runtime);
}

model RemoveVMFromServiceMeshRequest {
  ecsId?: string(name='EcsId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model RemoveVMFromServiceMeshResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveVMFromServiceMeshResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveVMFromServiceMeshResponseBody(name='body'),
}

async function removeVMFromServiceMeshWithOptions(request: RemoveVMFromServiceMeshRequest, runtime: Util.RuntimeOptions): RemoveVMFromServiceMeshResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ecsId)) {
    query['EcsId'] = request.ecsId;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveVMFromServiceMesh',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeVMFromServiceMesh(request: RemoveVMFromServiceMeshRequest): RemoveVMFromServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeVMFromServiceMeshWithOptions(request, runtime);
}

model RevokeKubeconfigRequest {
  privateIpAddress?: boolean(name='PrivateIpAddress'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model RevokeKubeconfigResponseBody = {
  kubeconfig?: string(name='Kubeconfig'),
  requestId?: string(name='RequestId'),
}

model RevokeKubeconfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokeKubeconfigResponseBody(name='body'),
}

async function revokeKubeconfigWithOptions(request: RevokeKubeconfigRequest, runtime: Util.RuntimeOptions): RevokeKubeconfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.privateIpAddress)) {
    body['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RevokeKubeconfig',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokeKubeconfig(request: RevokeKubeconfigRequest): RevokeKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeKubeconfigWithOptions(request, runtime);
}

model UpdateASMGatewayRequest {
  body?: string(name='Body'),
  istioGatewayName?: string(name='IstioGatewayName'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model UpdateASMGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateASMGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateASMGatewayResponseBody(name='body'),
}

async function updateASMGatewayWithOptions(request: UpdateASMGatewayRequest, runtime: Util.RuntimeOptions): UpdateASMGatewayResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['Body'] = request.body;
  }
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateASMGateway',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateASMGateway(request: UpdateASMGatewayRequest): UpdateASMGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateASMGatewayWithOptions(request, runtime);
}

model UpdateASMGatewayImportedServicesRequest {
  ASMGatewayName?: string(name='ASMGatewayName'),
  serviceMeshId?: string(name='ServiceMeshId'),
  serviceNames?: string(name='ServiceNames'),
  serviceNamespace?: string(name='ServiceNamespace'),
}

model UpdateASMGatewayImportedServicesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateASMGatewayImportedServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateASMGatewayImportedServicesResponseBody(name='body'),
}

async function updateASMGatewayImportedServicesWithOptions(request: UpdateASMGatewayImportedServicesRequest, runtime: Util.RuntimeOptions): UpdateASMGatewayImportedServicesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ASMGatewayName)) {
    body['ASMGatewayName'] = request.ASMGatewayName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.serviceNames)) {
    body['ServiceNames'] = request.serviceNames;
  }
  if (!Util.isUnset(request.serviceNamespace)) {
    body['ServiceNamespace'] = request.serviceNamespace;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateASMGatewayImportedServices',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateASMGatewayImportedServices(request: UpdateASMGatewayImportedServicesRequest): UpdateASMGatewayImportedServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateASMGatewayImportedServicesWithOptions(request, runtime);
}

model UpdateASMNamespaceFromGuestClusterRequest {
  k8sClusterId?: string(name='K8sClusterId'),
  serviceMeshId?: string(name='ServiceMeshId'),
}

model UpdateASMNamespaceFromGuestClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateASMNamespaceFromGuestClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateASMNamespaceFromGuestClusterResponseBody(name='body'),
}

async function updateASMNamespaceFromGuestClusterWithOptions(request: UpdateASMNamespaceFromGuestClusterRequest, runtime: Util.RuntimeOptions): UpdateASMNamespaceFromGuestClusterResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.k8sClusterId)) {
    body['K8sClusterId'] = request.k8sClusterId;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateASMNamespaceFromGuestCluster',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateASMNamespaceFromGuestCluster(request: UpdateASMNamespaceFromGuestClusterRequest): UpdateASMNamespaceFromGuestClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateASMNamespaceFromGuestClusterWithOptions(request, runtime);
}

model UpdateIstioGatewayRoutesRequest {
  description?: string(name='Description'),
  gatewayRoute?: {
    domains?: [ string ](name='Domains'),
    HTTPAdvancedOptions?: {
      delegate?: {
        name?: string(name='Name'),
        namespace?: string(name='Namespace'),
      }(name='Delegate'),
      fault?: {
        abort?: {
          httpStatus?: int32(name='HttpStatus'),
          percentage?: {
            value?: float(name='Value'),
          }(name='Percentage'),
        }(name='Abort'),
        delay?: {
          fixedDelay?: string(name='FixedDelay'),
          percentage?: {
            value?: float(name='Value'),
          }(name='Percentage'),
        }(name='Delay'),
      }(name='Fault'),
      HTTPRedirect?: {
        authority?: string(name='Authority'),
        redirectCode?: int32(name='RedirectCode'),
        uri?: string(name='Uri'),
      }(name='HTTPRedirect'),
      mirror?: {
        host?: string(name='Host'),
        subset?: string(name='Subset'),
      }(name='Mirror'),
      mirrorPercentage?: {
        value?: float(name='Value'),
      }(name='MirrorPercentage'),
      retries?: {
        attempts?: int32(name='Attempts'),
        perTryTimeout?: string(name='PerTryTimeout'),
        retryOn?: string(name='RetryOn'),
        retryRemoteLocalities?: {
          value?: boolean(name='Value'),
        }(name='RetryRemoteLocalities'),
      }(name='Retries'),
      rewrite?: {
        authority?: string(name='Authority'),
        uri?: string(name='Uri'),
      }(name='Rewrite'),
      timeout?: string(name='Timeout'),
    }(name='HTTPAdvancedOptions'),
    matchRequest?: {
      headers?: [ 
        {
          matchingContent?: string(name='MatchingContent'),
          matchingMode?: string(name='MatchingMode'),
          name?: string(name='Name'),
        }
      ](name='Headers'),
      ports?: [ int32 ](name='Ports'),
      TLSMatchAttributes?: [ 
        {
          SNIHosts?: [ string ](name='SNIHosts'),
          TLSPort?: int32(name='TLSPort'),
        }
      ](name='TLSMatchAttributes'),
      URI?: {
        matchingContent?: string(name='MatchingContent'),
        matchingMode?: string(name='MatchingMode'),
      }(name='URI'),
    }(name='MatchRequest'),
    namespace?: string(name='Namespace'),
    routeDestinations?: [ 
      {
        destination?: {
          host?: string(name='Host'),
          port?: {
            number?: int32(name='Number'),
          }(name='Port'),
          subset?: string(name='Subset'),
        }(name='Destination'),
        weight?: int32(name='Weight'),
      }
    ](name='RouteDestinations'),
    routeName?: string(name='RouteName'),
    routeType?: string(name='RouteType'),
  }(name='GatewayRoute'),
  istioGatewayName?: string(name='IstioGatewayName'),
  priority?: int32(name='Priority'),
  serviceMeshId?: string(name='ServiceMeshId'),
  status?: int32(name='Status'),
}

model UpdateIstioGatewayRoutesShrinkRequest {
  description?: string(name='Description'),
  gatewayRouteShrink?: string(name='GatewayRoute'),
  istioGatewayName?: string(name='IstioGatewayName'),
  priority?: int32(name='Priority'),
  serviceMeshId?: string(name='ServiceMeshId'),
  status?: int32(name='Status'),
}

model UpdateIstioGatewayRoutesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIstioGatewayRoutesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIstioGatewayRoutesResponseBody(name='body'),
}

async function updateIstioGatewayRoutesWithOptions(tmpReq: UpdateIstioGatewayRoutesRequest, runtime: Util.RuntimeOptions): UpdateIstioGatewayRoutesResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateIstioGatewayRoutesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.gatewayRoute)) {
    request.gatewayRouteShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.gatewayRoute, 'GatewayRoute', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.gatewayRouteShrink)) {
    body['GatewayRoute'] = request.gatewayRouteShrink;
  }
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.priority)) {
    body['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIstioGatewayRoutes',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateIstioGatewayRoutes(request: UpdateIstioGatewayRoutesRequest): UpdateIstioGatewayRoutesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIstioGatewayRoutesWithOptions(request, runtime);
}

model UpdateIstioRouteAdditionalStatusRequest {
  description?: string(name='Description'),
  istioGatewayName?: string(name='IstioGatewayName'),
  priority?: int32(name='Priority'),
  routeName?: string(name='RouteName'),
  serviceMeshId?: string(name='ServiceMeshId'),
  status?: int32(name='Status'),
}

model UpdateIstioRouteAdditionalStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIstioRouteAdditionalStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIstioRouteAdditionalStatusResponseBody(name='body'),
}

async function updateIstioRouteAdditionalStatusWithOptions(request: UpdateIstioRouteAdditionalStatusRequest, runtime: Util.RuntimeOptions): UpdateIstioRouteAdditionalStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.routeName)) {
    query['RouteName'] = request.routeName;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.istioGatewayName)) {
    body['IstioGatewayName'] = request.istioGatewayName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIstioRouteAdditionalStatus',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateIstioRouteAdditionalStatus(request: UpdateIstioRouteAdditionalStatusRequest): UpdateIstioRouteAdditionalStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIstioRouteAdditionalStatusWithOptions(request, runtime);
}

model UpdateMeshCRAggregationRequest {
  CPULimit?: string(name='CPULimit'),
  CPURequirement?: string(name='CPURequirement'),
  enabled?: boolean(name='Enabled'),
  memoryLimit?: string(name='MemoryLimit'),
  memoryRequirement?: string(name='MemoryRequirement'),
  serviceMeshId?: string(name='ServiceMeshId'),
  usePublicApiServer?: boolean(name='UsePublicApiServer'),
}

model UpdateMeshCRAggregationResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMeshCRAggregationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMeshCRAggregationResponseBody(name='body'),
}

async function updateMeshCRAggregationWithOptions(request: UpdateMeshCRAggregationRequest, runtime: Util.RuntimeOptions): UpdateMeshCRAggregationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.CPULimit)) {
    body['CPULimit'] = request.CPULimit;
  }
  if (!Util.isUnset(request.CPURequirement)) {
    body['CPURequirement'] = request.CPURequirement;
  }
  if (!Util.isUnset(request.enabled)) {
    body['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.memoryLimit)) {
    body['MemoryLimit'] = request.memoryLimit;
  }
  if (!Util.isUnset(request.memoryRequirement)) {
    body['MemoryRequirement'] = request.memoryRequirement;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.usePublicApiServer)) {
    body['UsePublicApiServer'] = request.usePublicApiServer;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMeshCRAggregation',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMeshCRAggregation(request: UpdateMeshCRAggregationRequest): UpdateMeshCRAggregationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMeshCRAggregationWithOptions(request, runtime);
}

model UpdateMeshFeatureRequest {
  accessLogEnabled?: boolean(name='AccessLogEnabled'),
  accessLogFile?: string(name='AccessLogFile'),
  accessLogFormat?: string(name='AccessLogFormat'),
  accessLogGatewayLifecycle?: int32(name='AccessLogGatewayLifecycle'),
  accessLogProject?: string(name='AccessLogProject'),
  accessLogServiceEnabled?: boolean(name='AccessLogServiceEnabled'),
  accessLogServiceHost?: string(name='AccessLogServiceHost'),
  accessLogServicePort?: int32(name='AccessLogServicePort'),
  accessLogSidecarLifecycle?: int32(name='AccessLogSidecarLifecycle'),
  auditProject?: string(name='AuditProject'),
  autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled'),
  CRAggregationEnabled?: boolean(name='CRAggregationEnabled'),
  clusterSpec?: string(name='ClusterSpec'),
  cniEnabled?: boolean(name='CniEnabled'),
  cniExcludeNamespaces?: string(name='CniExcludeNamespaces'),
  concurrency?: int32(name='Concurrency'),
  configSourceEnabled?: boolean(name='ConfigSourceEnabled'),
  configSourceNacosID?: string(name='ConfigSourceNacosID'),
  customizedPrometheus?: boolean(name='CustomizedPrometheus'),
  customizedZipkin?: boolean(name='CustomizedZipkin'),
  DNSProxyingEnabled?: boolean(name='DNSProxyingEnabled'),
  discoverySelectors?: string(name='DiscoverySelectors'),
  dubboFilterEnabled?: boolean(name='DubboFilterEnabled'),
  enableAudit?: boolean(name='EnableAudit'),
  enableAutoDiagnosis?: boolean(name='EnableAutoDiagnosis'),
  enableCRHistory?: boolean(name='EnableCRHistory'),
  enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault'),
  enableSDSServer?: boolean(name='EnableSDSServer'),
  excludeIPRanges?: string(name='ExcludeIPRanges'),
  excludeInboundPorts?: string(name='ExcludeInboundPorts'),
  excludeOutboundPorts?: string(name='ExcludeOutboundPorts'),
  filterGatewayClusterConfig?: boolean(name='FilterGatewayClusterConfig'),
  gatewayAPIEnabled?: boolean(name='GatewayAPIEnabled'),
  globalRateLimitEnabled?: boolean(name='GlobalRateLimitEnabled'),
  holdApplicationUntilProxyStarts?: boolean(name='HoldApplicationUntilProxyStarts'),
  http10Enabled?: boolean(name='Http10Enabled'),
  includeIPRanges?: string(name='IncludeIPRanges'),
  includeInboundPorts?: string(name='IncludeInboundPorts'),
  includeOutboundPorts?: string(name='IncludeOutboundPorts'),
  integrateKiali?: boolean(name='IntegrateKiali'),
  kialiEnabled?: boolean(name='KialiEnabled'),
  lifecycle?: string(name='Lifecycle'),
  localityLBConf?: string(name='LocalityLBConf'),
  localityLoadBalancing?: boolean(name='LocalityLoadBalancing'),
  logLevel?: string(name='LogLevel'),
  MSEEnabled?: boolean(name='MSEEnabled'),
  multiBufferEnabled?: boolean(name='MultiBufferEnabled'),
  multiBufferPollDelay?: string(name='MultiBufferPollDelay'),
  mysqlFilterEnabled?: boolean(name='MysqlFilterEnabled'),
  NFDEnabled?: boolean(name='NFDEnabled'),
  NFDLabelPruned?: boolean(name='NFDLabelPruned'),
  OPAInjectorCPULimit?: string(name='OPAInjectorCPULimit'),
  OPAInjectorCPURequirement?: string(name='OPAInjectorCPURequirement'),
  OPAInjectorMemoryLimit?: string(name='OPAInjectorMemoryLimit'),
  OPAInjectorMemoryRequirement?: string(name='OPAInjectorMemoryRequirement'),
  OPALimitCPU?: string(name='OPALimitCPU'),
  OPALimitMemory?: string(name='OPALimitMemory'),
  OPALogLevel?: string(name='OPALogLevel'),
  OPARequestCPU?: string(name='OPARequestCPU'),
  OPARequestMemory?: string(name='OPARequestMemory'),
  OPAScopeInjected?: boolean(name='OPAScopeInjected'),
  opaEnabled?: boolean(name='OpaEnabled'),
  openAgentPolicy?: boolean(name='OpenAgentPolicy'),
  outboundTrafficPolicy?: string(name='OutboundTrafficPolicy'),
  prometheusUrl?: string(name='PrometheusUrl'),
  proxyInitCPUResourceLimit?: string(name='ProxyInitCPUResourceLimit'),
  proxyInitCPUResourceRequest?: string(name='ProxyInitCPUResourceRequest'),
  proxyInitMemoryResourceLimit?: string(name='ProxyInitMemoryResourceLimit'),
  proxyInitMemoryResourceRequest?: string(name='ProxyInitMemoryResourceRequest'),
  proxyLimitCPU?: string(name='ProxyLimitCPU'),
  proxyLimitMemory?: string(name='ProxyLimitMemory'),
  proxyRequestCPU?: string(name='ProxyRequestCPU'),
  proxyRequestMemory?: string(name='ProxyRequestMemory'),
  proxyStatsMatcher?: string(name='ProxyStatsMatcher'),
  redisFilterEnabled?: boolean(name='RedisFilterEnabled'),
  serviceMeshId?: string(name='ServiceMeshId'),
  sidecarInjectorLimitCPU?: string(name='SidecarInjectorLimitCPU'),
  sidecarInjectorLimitMemory?: string(name='SidecarInjectorLimitMemory'),
  sidecarInjectorRequestCPU?: string(name='SidecarInjectorRequestCPU'),
  sidecarInjectorRequestMemory?: string(name='SidecarInjectorRequestMemory'),
  sidecarInjectorWebhookAsYaml?: string(name='SidecarInjectorWebhookAsYaml'),
  telemetry?: boolean(name='Telemetry'),
  terminationDrainDuration?: string(name='TerminationDrainDuration'),
  thriftFilterEnabled?: boolean(name='ThriftFilterEnabled'),
  traceCustomTags?: string(name='TraceCustomTags'),
  traceMaxPathTagLength?: string(name='TraceMaxPathTagLength'),
  traceSampling?: float(name='TraceSampling'),
  tracing?: boolean(name='Tracing'),
  tracingOnExtZipkinLimitCPU?: string(name='TracingOnExtZipkinLimitCPU'),
  tracingOnExtZipkinLimitMemory?: string(name='TracingOnExtZipkinLimitMemory'),
  tracingOnExtZipkinRequestCPU?: string(name='TracingOnExtZipkinRequestCPU'),
  tracingOnExtZipkinRequestMemory?: string(name='TracingOnExtZipkinRequestMemory'),
  webAssemblyFilterEnabled?: boolean(name='WebAssemblyFilterEnabled'),
}

model UpdateMeshFeatureResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMeshFeatureResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMeshFeatureResponseBody(name='body'),
}

async function updateMeshFeatureWithOptions(request: UpdateMeshFeatureRequest, runtime: Util.RuntimeOptions): UpdateMeshFeatureResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessLogEnabled)) {
    body['AccessLogEnabled'] = request.accessLogEnabled;
  }
  if (!Util.isUnset(request.accessLogFile)) {
    body['AccessLogFile'] = request.accessLogFile;
  }
  if (!Util.isUnset(request.accessLogFormat)) {
    body['AccessLogFormat'] = request.accessLogFormat;
  }
  if (!Util.isUnset(request.accessLogGatewayLifecycle)) {
    body['AccessLogGatewayLifecycle'] = request.accessLogGatewayLifecycle;
  }
  if (!Util.isUnset(request.accessLogProject)) {
    body['AccessLogProject'] = request.accessLogProject;
  }
  if (!Util.isUnset(request.accessLogServiceEnabled)) {
    body['AccessLogServiceEnabled'] = request.accessLogServiceEnabled;
  }
  if (!Util.isUnset(request.accessLogServiceHost)) {
    body['AccessLogServiceHost'] = request.accessLogServiceHost;
  }
  if (!Util.isUnset(request.accessLogServicePort)) {
    body['AccessLogServicePort'] = request.accessLogServicePort;
  }
  if (!Util.isUnset(request.accessLogSidecarLifecycle)) {
    body['AccessLogSidecarLifecycle'] = request.accessLogSidecarLifecycle;
  }
  if (!Util.isUnset(request.auditProject)) {
    body['AuditProject'] = request.auditProject;
  }
  if (!Util.isUnset(request.autoInjectionPolicyEnabled)) {
    body['AutoInjectionPolicyEnabled'] = request.autoInjectionPolicyEnabled;
  }
  if (!Util.isUnset(request.CRAggregationEnabled)) {
    body['CRAggregationEnabled'] = request.CRAggregationEnabled;
  }
  if (!Util.isUnset(request.clusterSpec)) {
    body['ClusterSpec'] = request.clusterSpec;
  }
  if (!Util.isUnset(request.cniEnabled)) {
    body['CniEnabled'] = request.cniEnabled;
  }
  if (!Util.isUnset(request.cniExcludeNamespaces)) {
    body['CniExcludeNamespaces'] = request.cniExcludeNamespaces;
  }
  if (!Util.isUnset(request.concurrency)) {
    body['Concurrency'] = request.concurrency;
  }
  if (!Util.isUnset(request.configSourceEnabled)) {
    body['ConfigSourceEnabled'] = request.configSourceEnabled;
  }
  if (!Util.isUnset(request.configSourceNacosID)) {
    body['ConfigSourceNacosID'] = request.configSourceNacosID;
  }
  if (!Util.isUnset(request.customizedPrometheus)) {
    body['CustomizedPrometheus'] = request.customizedPrometheus;
  }
  if (!Util.isUnset(request.customizedZipkin)) {
    body['CustomizedZipkin'] = request.customizedZipkin;
  }
  if (!Util.isUnset(request.DNSProxyingEnabled)) {
    body['DNSProxyingEnabled'] = request.DNSProxyingEnabled;
  }
  if (!Util.isUnset(request.discoverySelectors)) {
    body['DiscoverySelectors'] = request.discoverySelectors;
  }
  if (!Util.isUnset(request.dubboFilterEnabled)) {
    body['DubboFilterEnabled'] = request.dubboFilterEnabled;
  }
  if (!Util.isUnset(request.enableAudit)) {
    body['EnableAudit'] = request.enableAudit;
  }
  if (!Util.isUnset(request.enableAutoDiagnosis)) {
    body['EnableAutoDiagnosis'] = request.enableAutoDiagnosis;
  }
  if (!Util.isUnset(request.enableCRHistory)) {
    body['EnableCRHistory'] = request.enableCRHistory;
  }
  if (!Util.isUnset(request.enableNamespacesByDefault)) {
    body['EnableNamespacesByDefault'] = request.enableNamespacesByDefault;
  }
  if (!Util.isUnset(request.enableSDSServer)) {
    body['EnableSDSServer'] = request.enableSDSServer;
  }
  if (!Util.isUnset(request.excludeIPRanges)) {
    body['ExcludeIPRanges'] = request.excludeIPRanges;
  }
  if (!Util.isUnset(request.excludeInboundPorts)) {
    body['ExcludeInboundPorts'] = request.excludeInboundPorts;
  }
  if (!Util.isUnset(request.excludeOutboundPorts)) {
    body['ExcludeOutboundPorts'] = request.excludeOutboundPorts;
  }
  if (!Util.isUnset(request.filterGatewayClusterConfig)) {
    body['FilterGatewayClusterConfig'] = request.filterGatewayClusterConfig;
  }
  if (!Util.isUnset(request.gatewayAPIEnabled)) {
    body['GatewayAPIEnabled'] = request.gatewayAPIEnabled;
  }
  if (!Util.isUnset(request.globalRateLimitEnabled)) {
    body['GlobalRateLimitEnabled'] = request.globalRateLimitEnabled;
  }
  if (!Util.isUnset(request.holdApplicationUntilProxyStarts)) {
    body['HoldApplicationUntilProxyStarts'] = request.holdApplicationUntilProxyStarts;
  }
  if (!Util.isUnset(request.http10Enabled)) {
    body['Http10Enabled'] = request.http10Enabled;
  }
  if (!Util.isUnset(request.includeIPRanges)) {
    body['IncludeIPRanges'] = request.includeIPRanges;
  }
  if (!Util.isUnset(request.includeInboundPorts)) {
    body['IncludeInboundPorts'] = request.includeInboundPorts;
  }
  if (!Util.isUnset(request.includeOutboundPorts)) {
    body['IncludeOutboundPorts'] = request.includeOutboundPorts;
  }
  if (!Util.isUnset(request.integrateKiali)) {
    body['IntegrateKiali'] = request.integrateKiali;
  }
  if (!Util.isUnset(request.kialiEnabled)) {
    body['KialiEnabled'] = request.kialiEnabled;
  }
  if (!Util.isUnset(request.lifecycle)) {
    body['Lifecycle'] = request.lifecycle;
  }
  if (!Util.isUnset(request.localityLBConf)) {
    body['LocalityLBConf'] = request.localityLBConf;
  }
  if (!Util.isUnset(request.localityLoadBalancing)) {
    body['LocalityLoadBalancing'] = request.localityLoadBalancing;
  }
  if (!Util.isUnset(request.logLevel)) {
    body['LogLevel'] = request.logLevel;
  }
  if (!Util.isUnset(request.MSEEnabled)) {
    body['MSEEnabled'] = request.MSEEnabled;
  }
  if (!Util.isUnset(request.multiBufferEnabled)) {
    body['MultiBufferEnabled'] = request.multiBufferEnabled;
  }
  if (!Util.isUnset(request.multiBufferPollDelay)) {
    body['MultiBufferPollDelay'] = request.multiBufferPollDelay;
  }
  if (!Util.isUnset(request.mysqlFilterEnabled)) {
    body['MysqlFilterEnabled'] = request.mysqlFilterEnabled;
  }
  if (!Util.isUnset(request.NFDEnabled)) {
    body['NFDEnabled'] = request.NFDEnabled;
  }
  if (!Util.isUnset(request.NFDLabelPruned)) {
    body['NFDLabelPruned'] = request.NFDLabelPruned;
  }
  if (!Util.isUnset(request.OPAInjectorCPULimit)) {
    body['OPAInjectorCPULimit'] = request.OPAInjectorCPULimit;
  }
  if (!Util.isUnset(request.OPAInjectorCPURequirement)) {
    body['OPAInjectorCPURequirement'] = request.OPAInjectorCPURequirement;
  }
  if (!Util.isUnset(request.OPAInjectorMemoryLimit)) {
    body['OPAInjectorMemoryLimit'] = request.OPAInjectorMemoryLimit;
  }
  if (!Util.isUnset(request.OPAInjectorMemoryRequirement)) {
    body['OPAInjectorMemoryRequirement'] = request.OPAInjectorMemoryRequirement;
  }
  if (!Util.isUnset(request.OPALimitCPU)) {
    body['OPALimitCPU'] = request.OPALimitCPU;
  }
  if (!Util.isUnset(request.OPALimitMemory)) {
    body['OPALimitMemory'] = request.OPALimitMemory;
  }
  if (!Util.isUnset(request.OPALogLevel)) {
    body['OPALogLevel'] = request.OPALogLevel;
  }
  if (!Util.isUnset(request.OPARequestCPU)) {
    body['OPARequestCPU'] = request.OPARequestCPU;
  }
  if (!Util.isUnset(request.OPARequestMemory)) {
    body['OPARequestMemory'] = request.OPARequestMemory;
  }
  if (!Util.isUnset(request.OPAScopeInjected)) {
    body['OPAScopeInjected'] = request.OPAScopeInjected;
  }
  if (!Util.isUnset(request.opaEnabled)) {
    body['OpaEnabled'] = request.opaEnabled;
  }
  if (!Util.isUnset(request.openAgentPolicy)) {
    body['OpenAgentPolicy'] = request.openAgentPolicy;
  }
  if (!Util.isUnset(request.outboundTrafficPolicy)) {
    body['OutboundTrafficPolicy'] = request.outboundTrafficPolicy;
  }
  if (!Util.isUnset(request.prometheusUrl)) {
    body['PrometheusUrl'] = request.prometheusUrl;
  }
  if (!Util.isUnset(request.proxyInitCPUResourceLimit)) {
    body['ProxyInitCPUResourceLimit'] = request.proxyInitCPUResourceLimit;
  }
  if (!Util.isUnset(request.proxyInitCPUResourceRequest)) {
    body['ProxyInitCPUResourceRequest'] = request.proxyInitCPUResourceRequest;
  }
  if (!Util.isUnset(request.proxyInitMemoryResourceLimit)) {
    body['ProxyInitMemoryResourceLimit'] = request.proxyInitMemoryResourceLimit;
  }
  if (!Util.isUnset(request.proxyInitMemoryResourceRequest)) {
    body['ProxyInitMemoryResourceRequest'] = request.proxyInitMemoryResourceRequest;
  }
  if (!Util.isUnset(request.proxyLimitCPU)) {
    body['ProxyLimitCPU'] = request.proxyLimitCPU;
  }
  if (!Util.isUnset(request.proxyLimitMemory)) {
    body['ProxyLimitMemory'] = request.proxyLimitMemory;
  }
  if (!Util.isUnset(request.proxyRequestCPU)) {
    body['ProxyRequestCPU'] = request.proxyRequestCPU;
  }
  if (!Util.isUnset(request.proxyRequestMemory)) {
    body['ProxyRequestMemory'] = request.proxyRequestMemory;
  }
  if (!Util.isUnset(request.proxyStatsMatcher)) {
    body['ProxyStatsMatcher'] = request.proxyStatsMatcher;
  }
  if (!Util.isUnset(request.redisFilterEnabled)) {
    body['RedisFilterEnabled'] = request.redisFilterEnabled;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.sidecarInjectorLimitCPU)) {
    body['SidecarInjectorLimitCPU'] = request.sidecarInjectorLimitCPU;
  }
  if (!Util.isUnset(request.sidecarInjectorLimitMemory)) {
    body['SidecarInjectorLimitMemory'] = request.sidecarInjectorLimitMemory;
  }
  if (!Util.isUnset(request.sidecarInjectorRequestCPU)) {
    body['SidecarInjectorRequestCPU'] = request.sidecarInjectorRequestCPU;
  }
  if (!Util.isUnset(request.sidecarInjectorRequestMemory)) {
    body['SidecarInjectorRequestMemory'] = request.sidecarInjectorRequestMemory;
  }
  if (!Util.isUnset(request.sidecarInjectorWebhookAsYaml)) {
    body['SidecarInjectorWebhookAsYaml'] = request.sidecarInjectorWebhookAsYaml;
  }
  if (!Util.isUnset(request.telemetry)) {
    body['Telemetry'] = request.telemetry;
  }
  if (!Util.isUnset(request.terminationDrainDuration)) {
    body['TerminationDrainDuration'] = request.terminationDrainDuration;
  }
  if (!Util.isUnset(request.thriftFilterEnabled)) {
    body['ThriftFilterEnabled'] = request.thriftFilterEnabled;
  }
  if (!Util.isUnset(request.traceCustomTags)) {
    body['TraceCustomTags'] = request.traceCustomTags;
  }
  if (!Util.isUnset(request.traceMaxPathTagLength)) {
    body['TraceMaxPathTagLength'] = request.traceMaxPathTagLength;
  }
  if (!Util.isUnset(request.traceSampling)) {
    body['TraceSampling'] = request.traceSampling;
  }
  if (!Util.isUnset(request.tracing)) {
    body['Tracing'] = request.tracing;
  }
  if (!Util.isUnset(request.tracingOnExtZipkinLimitCPU)) {
    body['TracingOnExtZipkinLimitCPU'] = request.tracingOnExtZipkinLimitCPU;
  }
  if (!Util.isUnset(request.tracingOnExtZipkinLimitMemory)) {
    body['TracingOnExtZipkinLimitMemory'] = request.tracingOnExtZipkinLimitMemory;
  }
  if (!Util.isUnset(request.tracingOnExtZipkinRequestCPU)) {
    body['TracingOnExtZipkinRequestCPU'] = request.tracingOnExtZipkinRequestCPU;
  }
  if (!Util.isUnset(request.tracingOnExtZipkinRequestMemory)) {
    body['TracingOnExtZipkinRequestMemory'] = request.tracingOnExtZipkinRequestMemory;
  }
  if (!Util.isUnset(request.webAssemblyFilterEnabled)) {
    body['WebAssemblyFilterEnabled'] = request.webAssemblyFilterEnabled;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMeshFeature',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMeshFeature(request: UpdateMeshFeatureRequest): UpdateMeshFeatureResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMeshFeatureWithOptions(request, runtime);
}

model UpdateNamespaceScopeSidecarConfigRequest {
  concurrency?: int32(name='Concurrency'),
  excludeIPRanges?: string(name='ExcludeIPRanges'),
  excludeInboundPorts?: string(name='ExcludeInboundPorts'),
  excludeOutboundPorts?: string(name='ExcludeOutboundPorts'),
  holdApplicationUntilProxyStarts?: boolean(name='HoldApplicationUntilProxyStarts'),
  includeIPRanges?: string(name='IncludeIPRanges'),
  includeInboundPorts?: string(name='IncludeInboundPorts'),
  includeOutboundPorts?: string(name='IncludeOutboundPorts'),
  istioDNSProxyEnabled?: boolean(name='IstioDNSProxyEnabled'),
  lifecycle?: string(name='Lifecycle'),
  logLevel?: string(name='LogLevel'),
  namespace?: string(name='Namespace'),
  postStart?: string(name='PostStart'),
  preStop?: string(name='PreStop'),
  proxyInitCPUResourceLimit?: string(name='ProxyInitCPUResourceLimit'),
  proxyInitCPUResourceRequest?: string(name='ProxyInitCPUResourceRequest'),
  proxyInitMemoryResourceLimit?: string(name='ProxyInitMemoryResourceLimit'),
  proxyInitMemoryResourceRequest?: string(name='ProxyInitMemoryResourceRequest'),
  proxyStatsMatcher?: string(name='ProxyStatsMatcher'),
  serviceMeshId?: string(name='ServiceMeshId'),
  sidecarProxyCPUResourceLimit?: string(name='SidecarProxyCPUResourceLimit'),
  sidecarProxyCPUResourceRequest?: string(name='SidecarProxyCPUResourceRequest'),
  sidecarProxyMemoryResourceLimit?: string(name='SidecarProxyMemoryResourceLimit'),
  sidecarProxyMemoryResourceRequest?: string(name='SidecarProxyMemoryResourceRequest'),
  terminationDrainDuration?: string(name='TerminationDrainDuration'),
  tracing?: string(name='Tracing'),
}

model UpdateNamespaceScopeSidecarConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateNamespaceScopeSidecarConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateNamespaceScopeSidecarConfigResponseBody(name='body'),
}

async function updateNamespaceScopeSidecarConfigWithOptions(request: UpdateNamespaceScopeSidecarConfigRequest, runtime: Util.RuntimeOptions): UpdateNamespaceScopeSidecarConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.concurrency)) {
    body['Concurrency'] = request.concurrency;
  }
  if (!Util.isUnset(request.excludeIPRanges)) {
    body['ExcludeIPRanges'] = request.excludeIPRanges;
  }
  if (!Util.isUnset(request.excludeInboundPorts)) {
    body['ExcludeInboundPorts'] = request.excludeInboundPorts;
  }
  if (!Util.isUnset(request.excludeOutboundPorts)) {
    body['ExcludeOutboundPorts'] = request.excludeOutboundPorts;
  }
  if (!Util.isUnset(request.holdApplicationUntilProxyStarts)) {
    body['HoldApplicationUntilProxyStarts'] = request.holdApplicationUntilProxyStarts;
  }
  if (!Util.isUnset(request.includeIPRanges)) {
    body['IncludeIPRanges'] = request.includeIPRanges;
  }
  if (!Util.isUnset(request.includeInboundPorts)) {
    body['IncludeInboundPorts'] = request.includeInboundPorts;
  }
  if (!Util.isUnset(request.includeOutboundPorts)) {
    body['IncludeOutboundPorts'] = request.includeOutboundPorts;
  }
  if (!Util.isUnset(request.istioDNSProxyEnabled)) {
    body['IstioDNSProxyEnabled'] = request.istioDNSProxyEnabled;
  }
  if (!Util.isUnset(request.lifecycle)) {
    body['Lifecycle'] = request.lifecycle;
  }
  if (!Util.isUnset(request.logLevel)) {
    body['LogLevel'] = request.logLevel;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.postStart)) {
    body['PostStart'] = request.postStart;
  }
  if (!Util.isUnset(request.preStop)) {
    body['PreStop'] = request.preStop;
  }
  if (!Util.isUnset(request.proxyInitCPUResourceLimit)) {
    body['ProxyInitCPUResourceLimit'] = request.proxyInitCPUResourceLimit;
  }
  if (!Util.isUnset(request.proxyInitCPUResourceRequest)) {
    body['ProxyInitCPUResourceRequest'] = request.proxyInitCPUResourceRequest;
  }
  if (!Util.isUnset(request.proxyInitMemoryResourceLimit)) {
    body['ProxyInitMemoryResourceLimit'] = request.proxyInitMemoryResourceLimit;
  }
  if (!Util.isUnset(request.proxyInitMemoryResourceRequest)) {
    body['ProxyInitMemoryResourceRequest'] = request.proxyInitMemoryResourceRequest;
  }
  if (!Util.isUnset(request.proxyStatsMatcher)) {
    body['ProxyStatsMatcher'] = request.proxyStatsMatcher;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.sidecarProxyCPUResourceLimit)) {
    body['SidecarProxyCPUResourceLimit'] = request.sidecarProxyCPUResourceLimit;
  }
  if (!Util.isUnset(request.sidecarProxyCPUResourceRequest)) {
    body['SidecarProxyCPUResourceRequest'] = request.sidecarProxyCPUResourceRequest;
  }
  if (!Util.isUnset(request.sidecarProxyMemoryResourceLimit)) {
    body['SidecarProxyMemoryResourceLimit'] = request.sidecarProxyMemoryResourceLimit;
  }
  if (!Util.isUnset(request.sidecarProxyMemoryResourceRequest)) {
    body['SidecarProxyMemoryResourceRequest'] = request.sidecarProxyMemoryResourceRequest;
  }
  if (!Util.isUnset(request.terminationDrainDuration)) {
    body['TerminationDrainDuration'] = request.terminationDrainDuration;
  }
  if (!Util.isUnset(request.tracing)) {
    body['Tracing'] = request.tracing;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNamespaceScopeSidecarConfig',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateNamespaceScopeSidecarConfig(request: UpdateNamespaceScopeSidecarConfigRequest): UpdateNamespaceScopeSidecarConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNamespaceScopeSidecarConfigWithOptions(request, runtime);
}

model UpdateSwimLaneRequest {
  groupName?: string(name='GroupName'),
  labelSelectorKey?: string(name='LabelSelectorKey'),
  labelSelectorValue?: string(name='LabelSelectorValue'),
  serviceMeshId?: string(name='ServiceMeshId'),
  servicesList?: string(name='ServicesList'),
  swimLaneName?: string(name='SwimLaneName'),
}

model UpdateSwimLaneResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateSwimLaneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSwimLaneResponseBody(name='body'),
}

async function updateSwimLaneWithOptions(request: UpdateSwimLaneRequest, runtime: Util.RuntimeOptions): UpdateSwimLaneResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    body['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.labelSelectorKey)) {
    body['LabelSelectorKey'] = request.labelSelectorKey;
  }
  if (!Util.isUnset(request.labelSelectorValue)) {
    body['LabelSelectorValue'] = request.labelSelectorValue;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.servicesList)) {
    body['ServicesList'] = request.servicesList;
  }
  if (!Util.isUnset(request.swimLaneName)) {
    body['SwimLaneName'] = request.swimLaneName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSwimLane',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSwimLane(request: UpdateSwimLaneRequest): UpdateSwimLaneResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSwimLaneWithOptions(request, runtime);
}

model UpdateSwimLaneGroupRequest {
  groupName?: string(name='GroupName'),
  serviceMeshId?: string(name='ServiceMeshId'),
  servicesList?: string(name='ServicesList'),
}

model UpdateSwimLaneGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateSwimLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSwimLaneGroupResponseBody(name='body'),
}

async function updateSwimLaneGroupWithOptions(request: UpdateSwimLaneGroupRequest, runtime: Util.RuntimeOptions): UpdateSwimLaneGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupName)) {
    body['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.servicesList)) {
    body['ServicesList'] = request.servicesList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSwimLaneGroup',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSwimLaneGroup(request: UpdateSwimLaneGroupRequest): UpdateSwimLaneGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSwimLaneGroupWithOptions(request, runtime);
}

model UpgradeMeshEditionPartiallyRequest {
  ASMGatewayContinue?: boolean(name='ASMGatewayContinue'),
  expectedVersion?: string(name='ExpectedVersion'),
  serviceMeshId?: string(name='ServiceMeshId'),
  switchToPro?: boolean(name='SwitchToPro'),
  upgradeGatewayRecords?: string(name='UpgradeGatewayRecords'),
}

model UpgradeMeshEditionPartiallyResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpgradeMeshEditionPartiallyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeMeshEditionPartiallyResponseBody(name='body'),
}

async function upgradeMeshEditionPartiallyWithOptions(request: UpgradeMeshEditionPartiallyRequest, runtime: Util.RuntimeOptions): UpgradeMeshEditionPartiallyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ASMGatewayContinue)) {
    body['ASMGatewayContinue'] = request.ASMGatewayContinue;
  }
  if (!Util.isUnset(request.expectedVersion)) {
    body['ExpectedVersion'] = request.expectedVersion;
  }
  if (!Util.isUnset(request.serviceMeshId)) {
    body['ServiceMeshId'] = request.serviceMeshId;
  }
  if (!Util.isUnset(request.switchToPro)) {
    body['SwitchToPro'] = request.switchToPro;
  }
  if (!Util.isUnset(request.upgradeGatewayRecords)) {
    body['UpgradeGatewayRecords'] = request.upgradeGatewayRecords;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeMeshEditionPartially',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeMeshEditionPartially(request: UpgradeMeshEditionPartiallyRequest): UpgradeMeshEditionPartiallyResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeMeshEditionPartiallyWithOptions(request, runtime);
}

model UpgradeMeshVersionRequest {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model UpgradeMeshVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpgradeMeshVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeMeshVersionResponseBody(name='body'),
}

async function upgradeMeshVersionWithOptions(request: UpgradeMeshVersionRequest, runtime: Util.RuntimeOptions): UpgradeMeshVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serviceMeshId)) {
    query['ServiceMeshId'] = request.serviceMeshId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeMeshVersion',
    version = '2020-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeMeshVersion(request: UpgradeMeshVersionRequest): UpgradeMeshVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeMeshVersionWithOptions(request, runtime);
}

