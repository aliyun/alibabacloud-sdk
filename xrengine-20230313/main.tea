/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'xrengine-daily.aliyuncs.com',
    ap-northeast-2-pop = 'xrengine-daily.aliyuncs.com',
    ap-south-1 = 'xrengine-daily.aliyuncs.com',
    ap-southeast-1 = 'xrengine-daily.aliyuncs.com',
    ap-southeast-2 = 'xrengine-daily.aliyuncs.com',
    ap-southeast-3 = 'xrengine-daily.aliyuncs.com',
    ap-southeast-5 = 'xrengine-daily.aliyuncs.com',
    cn-beijing = 'xrengine-daily.aliyuncs.com',
    cn-beijing-finance-1 = 'xrengine-daily.aliyuncs.com',
    cn-beijing-finance-pop = 'xrengine-daily.aliyuncs.com',
    cn-beijing-gov-1 = 'xrengine-daily.aliyuncs.com',
    cn-beijing-nu16-b01 = 'xrengine-daily.aliyuncs.com',
    cn-chengdu = 'xrengine-daily.aliyuncs.com',
    cn-edge-1 = 'xrengine-daily.aliyuncs.com',
    cn-fujian = 'xrengine-daily.aliyuncs.com',
    cn-haidian-cm12-c01 = 'xrengine-daily.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'xrengine-daily.aliyuncs.com',
    cn-hangzhou-finance = 'xrengine-daily.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'xrengine-daily.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'xrengine-daily.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'xrengine-daily.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'xrengine-daily.aliyuncs.com',
    cn-hangzhou-test-306 = 'xrengine-daily.aliyuncs.com',
    cn-hongkong = 'xrengine-daily.aliyuncs.com',
    cn-hongkong-finance-pop = 'xrengine-daily.aliyuncs.com',
    cn-huhehaote = 'xrengine-daily.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'xrengine-daily.aliyuncs.com',
    cn-north-2-gov-1 = 'xrengine-daily.aliyuncs.com',
    cn-qingdao = 'xrengine-daily.aliyuncs.com',
    cn-qingdao-nebula = 'xrengine-daily.aliyuncs.com',
    cn-shanghai = 'xrengine-daily.aliyuncs.com',
    cn-shanghai-et15-b01 = 'xrengine-daily.aliyuncs.com',
    cn-shanghai-et2-b01 = 'xrengine-daily.aliyuncs.com',
    cn-shanghai-finance-1 = 'xrengine-daily.aliyuncs.com',
    cn-shanghai-inner = 'xrengine-daily.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'xrengine-daily.aliyuncs.com',
    cn-shenzhen = 'xrengine-daily.aliyuncs.com',
    cn-shenzhen-finance-1 = 'xrengine-daily.aliyuncs.com',
    cn-shenzhen-inner = 'xrengine-daily.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'xrengine-daily.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'xrengine-daily.aliyuncs.com',
    cn-wuhan = 'xrengine-daily.aliyuncs.com',
    cn-wulanchabu = 'xrengine-daily.aliyuncs.com',
    cn-yushanfang = 'xrengine-daily.aliyuncs.com',
    cn-zhangbei = 'xrengine-daily.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'xrengine-daily.aliyuncs.com',
    cn-zhangjiakou = 'xrengine-daily.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'xrengine-daily.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'xrengine-daily.aliyuncs.com',
    eu-central-1 = 'xrengine-daily.aliyuncs.com',
    eu-west-1 = 'xrengine-daily.aliyuncs.com',
    eu-west-1-oxs = 'xrengine-daily.aliyuncs.com',
    me-east-1 = 'xrengine-daily.aliyuncs.com',
    rus-west-1-pop = 'xrengine-daily.aliyuncs.com',
    us-east-1 = 'xrengine-daily.aliyuncs.com',
    us-west-1 = 'xrengine-daily.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('xrengine', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AuthUserRequest {
  jwtToken?: string(name='JwtToken'),
}

model AuthUserResponseBody = {
  code?: string(name='Code'),
  data?: {
    jwtToken?: string(name='JwtToken'),
    type?: string(name='Type'),
  }(name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AuthUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AuthUserResponseBody(name='body'),
}

async function authUserWithOptions(request: AuthUserRequest, runtime: Util.RuntimeOptions): AuthUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AuthUser',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function authUser(request: AuthUserRequest): AuthUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return authUserWithOptions(request, runtime);
}

model GetMapDataRequest {
  appId?: string(name='AppId'),
  jwtToken?: string(name='JwtToken'),
}

model GetMapDataResponseBody = {
  code?: string(name='Code'),
  data?: [  map[string]any ](name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMapDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMapDataResponseBody(name='body'),
}

async function getMapDataWithOptions(request: GetMapDataRequest, runtime: Util.RuntimeOptions): GetMapDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetMapData',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMapData(request: GetMapDataRequest): GetMapDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMapDataWithOptions(request, runtime);
}

model GetMapPublishDataRequest {
  appId?: string(name='AppId'),
  jwtToken?: string(name='JwtToken'),
}

model GetMapPublishDataResponseBody = {
  code?: string(name='Code'),
  data?: [  map[string]any ](name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMapPublishDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMapPublishDataResponseBody(name='body'),
}

async function getMapPublishDataWithOptions(request: GetMapPublishDataRequest, runtime: Util.RuntimeOptions): GetMapPublishDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetMapPublishData',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMapPublishData(request: GetMapPublishDataRequest): GetMapPublishDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMapPublishDataWithOptions(request, runtime);
}

model InitLocateRequest {
  jwtToken?: string(name='JwtToken'),
  params?: string(name='Params'),
}

model InitLocateResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InitLocateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InitLocateResponseBody(name='body'),
}

async function initLocateWithOptions(request: InitLocateRequest, runtime: Util.RuntimeOptions): InitLocateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.params)) {
    body['Params'] = request.params;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'InitLocate',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function initLocate(request: InitLocateRequest): InitLocateResponse {
  var runtime = new Util.RuntimeOptions{};
  return initLocateWithOptions(request, runtime);
}

model ListLocationServiceRequest {
  current?: int32(name='Current'),
  jwtToken?: string(name='JwtToken'),
  size?: int32(name='Size'),
  sort?: string(name='Sort'),
  sortField?: string(name='SortField'),
}

model ListLocationServiceResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      appId?: string(name='AppId'),
      expireTime?: string(name='ExpireTime'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      note?: string(name='Note'),
      qps?: long(name='Qps'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      svcState?: string(name='SvcState'),
    }
  ](name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListLocationServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLocationServiceResponseBody(name='body'),
}

async function listLocationServiceWithOptions(request: ListLocationServiceRequest, runtime: Util.RuntimeOptions): ListLocationServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.sort)) {
    body['Sort'] = request.sort;
  }
  if (!Util.isUnset(request.sortField)) {
    body['SortField'] = request.sortField;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListLocationService',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLocationService(request: ListLocationServiceRequest): ListLocationServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLocationServiceWithOptions(request, runtime);
}

model LocateRequest {
  image?: string(name='Image'),
  jwtToken?: string(name='JwtToken'),
  params?: string(name='Params'),
}

model LocateResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model LocateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LocateResponseBody(name='body'),
}

async function locateWithOptions(request: LocateRequest, runtime: Util.RuntimeOptions): LocateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.image)) {
    body['Image'] = request.image;
  }
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.params)) {
    body['Params'] = request.params;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'Locate',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function locate(request: LocateRequest): LocateResponse {
  var runtime = new Util.RuntimeOptions{};
  return locateWithOptions(request, runtime);
}

model LoginModelScopeRequest {
  empId?: string(name='EmpId'),
  empName?: string(name='EmpName'),
  token?: string(name='Token'),
  type?: string(name='Type'),
}

model LoginModelScopeResponseBody = {
  code?: string(name='Code'),
  data?: {
    jwtToken?: string(name='JwtToken'),
    nickname?: string(name='Nickname'),
    uid?: string(name='Uid'),
  }(name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model LoginModelScopeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LoginModelScopeResponseBody(name='body'),
}

async function loginModelScopeWithOptions(request: LoginModelScopeRequest, runtime: Util.RuntimeOptions): LoginModelScopeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.empId)) {
    body['EmpId'] = request.empId;
  }
  if (!Util.isUnset(request.empName)) {
    body['EmpName'] = request.empName;
  }
  if (!Util.isUnset(request.token)) {
    body['Token'] = request.token;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'LoginModelScope',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function loginModelScope(request: LoginModelScopeRequest): LoginModelScopeResponse {
  var runtime = new Util.RuntimeOptions{};
  return loginModelScopeWithOptions(request, runtime);
}

model PopBatchQueryObjectProjectStatusRequest {
  jwtToken?: string(name='JwtToken'),
  projectIds?: string(name='ProjectIds'),
}

model PopBatchQueryObjectProjectStatusResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      checkStatus?: string(name='CheckStatus'),
      id?: string(name='Id'),
      status?: string(name='Status'),
    }
  ](name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopBatchQueryObjectProjectStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopBatchQueryObjectProjectStatusResponseBody(name='body'),
}

async function popBatchQueryObjectProjectStatusWithOptions(request: PopBatchQueryObjectProjectStatusRequest, runtime: Util.RuntimeOptions): PopBatchQueryObjectProjectStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.projectIds)) {
    body['ProjectIds'] = request.projectIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopBatchQueryObjectProjectStatus',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popBatchQueryObjectProjectStatus(request: PopBatchQueryObjectProjectStatusRequest): PopBatchQueryObjectProjectStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return popBatchQueryObjectProjectStatusWithOptions(request, runtime);
}

model PopBuildFeatureToAvatarProjectRequest {
  projectId?: string(name='ProjectId'),
}

model PopBuildFeatureToAvatarProjectResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopBuildFeatureToAvatarProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopBuildFeatureToAvatarProjectResponseBody(name='body'),
}

async function popBuildFeatureToAvatarProjectWithOptions(request: PopBuildFeatureToAvatarProjectRequest, runtime: Util.RuntimeOptions): PopBuildFeatureToAvatarProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopBuildFeatureToAvatarProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popBuildFeatureToAvatarProject(request: PopBuildFeatureToAvatarProjectRequest): PopBuildFeatureToAvatarProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popBuildFeatureToAvatarProjectWithOptions(request, runtime);
}

model PopBuildObjectProjectRequest {
  jwtToken?: string(name='JwtToken'),
  projectId?: string(name='ProjectId'),
}

model PopBuildObjectProjectResponseBody = {
  code?: string(name='Code'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopBuildObjectProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopBuildObjectProjectResponseBody(name='body'),
}

async function popBuildObjectProjectWithOptions(request: PopBuildObjectProjectRequest, runtime: Util.RuntimeOptions): PopBuildObjectProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopBuildObjectProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popBuildObjectProject(request: PopBuildObjectProjectRequest): PopBuildObjectProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popBuildObjectProjectWithOptions(request, runtime);
}

model PopBuildPakRenderProjectRequest {
  projectId?: string(name='ProjectId'),
}

model PopBuildPakRenderProjectResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopBuildPakRenderProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopBuildPakRenderProjectResponseBody(name='body'),
}

async function popBuildPakRenderProjectWithOptions(request: PopBuildPakRenderProjectRequest, runtime: Util.RuntimeOptions): PopBuildPakRenderProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopBuildPakRenderProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popBuildPakRenderProject(request: PopBuildPakRenderProjectRequest): PopBuildPakRenderProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popBuildPakRenderProjectWithOptions(request, runtime);
}

model PopBuildTextToAvatarProjectRequest {
  projectId?: string(name='ProjectId'),
}

model PopBuildTextToAvatarProjectResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopBuildTextToAvatarProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopBuildTextToAvatarProjectResponseBody(name='body'),
}

async function popBuildTextToAvatarProjectWithOptions(request: PopBuildTextToAvatarProjectRequest, runtime: Util.RuntimeOptions): PopBuildTextToAvatarProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopBuildTextToAvatarProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popBuildTextToAvatarProject(request: PopBuildTextToAvatarProjectRequest): PopBuildTextToAvatarProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popBuildTextToAvatarProjectWithOptions(request, runtime);
}

model PopCreateFeatureToAvatarProjectRequest {
  extInfo?: string(name='ExtInfo'),
  intro?: string(name='Intro'),
  title?: string(name='Title'),
}

model PopCreateFeatureToAvatarProjectResponseBody = {
  code?: string(name='Code'),
  data?: {
    bizUsage?: string(name='BizUsage'),
    buildDetail?: {
      completedTime?: string(name='CompletedTime'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      errorMessage?: string(name='ErrorMessage'),
      estimatedDuration?: long(name='EstimatedDuration'),
      id?: long(name='Id'),
      modifiedTime?: string(name='ModifiedTime'),
      runningTime?: string(name='RunningTime'),
      status?: string(name='Status'),
      submitTime?: string(name='SubmitTime'),
    }(name='BuildDetail'),
    checkStatus?: string(name='CheckStatus'),
    createMode?: string(name='CreateMode'),
    createTime?: string(name='CreateTime'),
    dataset?: {
      buildResultUrl?: map[string]any(name='BuildResultUrl'),
      coverUrl?: string(name='CoverUrl'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      glbModelUrl?: string(name='GlbModelUrl'),
      id?: long(name='Id'),
      modelUrl?: string(name='ModelUrl'),
      modifiedTime?: string(name='ModifiedTime'),
      originResultUrl?: string(name='OriginResultUrl'),
      ossKey?: string(name='OssKey'),
      policy?: {
        accessId?: string(name='AccessId'),
        dir?: string(name='Dir'),
        expire?: string(name='Expire'),
        host?: string(name='Host'),
        policy?: string(name='Policy'),
        signature?: string(name='Signature'),
      }(name='Policy'),
      poseUrl?: string(name='PoseUrl'),
      previewUrl?: string(name='PreviewUrl'),
    }(name='Dataset'),
    deleted?: boolean(name='Deleted'),
    ext?: string(name='Ext'),
    id?: string(name='Id'),
    intro?: string(name='Intro'),
    materialCoverUrl?: string(name='MaterialCoverUrl'),
    modifiedTime?: string(name='ModifiedTime'),
    status?: string(name='Status'),
    title?: string(name='Title'),
    type?: string(name='Type'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopCreateFeatureToAvatarProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopCreateFeatureToAvatarProjectResponseBody(name='body'),
}

async function popCreateFeatureToAvatarProjectWithOptions(request: PopCreateFeatureToAvatarProjectRequest, runtime: Util.RuntimeOptions): PopCreateFeatureToAvatarProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extInfo)) {
    body['ExtInfo'] = request.extInfo;
  }
  if (!Util.isUnset(request.intro)) {
    body['Intro'] = request.intro;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopCreateFeatureToAvatarProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popCreateFeatureToAvatarProject(request: PopCreateFeatureToAvatarProjectRequest): PopCreateFeatureToAvatarProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popCreateFeatureToAvatarProjectWithOptions(request, runtime);
}

model PopCreateObjectProjectRequest {
  autoBuild?: boolean(name='AutoBuild'),
  bizUsage?: string(name='BizUsage'),
  customSource?: string(name='CustomSource'),
  dependencies?: string(name='Dependencies'),
  intro?: string(name='Intro'),
  jwtToken?: string(name='JwtToken'),
  mode?: string(name='Mode'),
  recommendStatus?: string(name='RecommendStatus'),
  title?: string(name='Title'),
}

model PopCreateObjectProjectResponseBody = {
  code?: string(name='Code'),
  data?: {
    auditStatus?: string(name='AuditStatus'),
    autoBuild?: boolean(name='AutoBuild'),
    bizUsage?: string(name='BizUsage'),
    buildDetail?: {
      completedTime?: string(name='CompletedTime'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      errorMessage?: string(name='ErrorMessage'),
      estimatedDuration?: long(name='EstimatedDuration'),
      modifiedTime?: string(name='ModifiedTime'),
      runningTime?: string(name='RunningTime'),
      submitTime?: string(name='SubmitTime'),
    }(name='BuildDetail'),
    checkStatus?: string(name='CheckStatus'),
    createMode?: string(name='CreateMode'),
    createTime?: string(name='CreateTime'),
    customSource?: string(name='CustomSource'),
    dataset?: {
      buildResultUrl?: map[string]any(name='BuildResultUrl'),
      coverUrl?: string(name='CoverUrl'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      errorMessage?: string(name='ErrorMessage'),
      glbModelUrl?: string(name='GlbModelUrl'),
      modelUrl?: string(name='ModelUrl'),
      modifiedTime?: string(name='ModifiedTime'),
      originResultUrl?: string(name='OriginResultUrl'),
      ossKey?: string(name='OssKey'),
      policy?: {
        accessId?: string(name='AccessId'),
        dir?: string(name='Dir'),
        expire?: string(name='Expire'),
        host?: string(name='Host'),
        policy?: string(name='Policy'),
        signature?: string(name='Signature'),
      }(name='Policy'),
      poseUrl?: string(name='PoseUrl'),
      previewUrl?: string(name='PreviewUrl'),
    }(name='Dataset'),
    deleted?: boolean(name='Deleted'),
    dependencies?: string(name='Dependencies'),
    ext?: string(name='Ext'),
    id?: string(name='Id'),
    intro?: string(name='Intro'),
    modifiedTime?: string(name='ModifiedTime'),
    recommendStatus?: string(name='RecommendStatus'),
    source?: {
      clothes?: [ 
        {
          coverUrl?: string(name='CoverUrl'),
          createTime?: string(name='CreateTime'),
          deleted?: boolean(name='Deleted'),
          modifiedTime?: string(name='ModifiedTime'),
          name?: string(name='Name'),
          ossKey?: string(name='OssKey'),
          type?: string(name='Type'),
        }
      ](name='Clothes'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      modifiedTime?: string(name='ModifiedTime'),
      ossKey?: string(name='OssKey'),
      policy?: {
        accessId?: string(name='AccessId'),
        dir?: string(name='Dir'),
        expire?: string(name='Expire'),
        host?: string(name='Host'),
        policy?: string(name='Policy'),
        signature?: string(name='Signature'),
      }(name='Policy'),
      sourceFiles?: [ 
        {
          coverUrl?: string(name='CoverUrl'),
          createTime?: string(name='CreateTime'),
          deleted?: boolean(name='Deleted'),
          fileName?: string(name='FileName'),
          filesize?: long(name='Filesize'),
          modifiedTime?: string(name='ModifiedTime'),
          ossKey?: string(name='OssKey'),
          type?: string(name='Type'),
          url?: string(name='Url'),
        }
      ](name='SourceFiles'),
      token?: {
        accessKeyId?: string(name='AccessKeyId'),
        accessKeySecret?: string(name='AccessKeySecret'),
        dir?: string(name='Dir'),
        expiration?: string(name='Expiration'),
        host?: string(name='Host'),
        securityToken?: string(name='SecurityToken'),
      }(name='Token'),
    }(name='Source'),
    status?: string(name='Status'),
    title?: string(name='Title'),
    type?: string(name='Type'),
  }(name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopCreateObjectProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopCreateObjectProjectResponseBody(name='body'),
}

async function popCreateObjectProjectWithOptions(request: PopCreateObjectProjectRequest, runtime: Util.RuntimeOptions): PopCreateObjectProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoBuild)) {
    body['AutoBuild'] = request.autoBuild;
  }
  if (!Util.isUnset(request.bizUsage)) {
    body['BizUsage'] = request.bizUsage;
  }
  if (!Util.isUnset(request.customSource)) {
    body['CustomSource'] = request.customSource;
  }
  if (!Util.isUnset(request.dependencies)) {
    body['Dependencies'] = request.dependencies;
  }
  if (!Util.isUnset(request.intro)) {
    body['Intro'] = request.intro;
  }
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.mode)) {
    body['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.recommendStatus)) {
    body['RecommendStatus'] = request.recommendStatus;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopCreateObjectProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popCreateObjectProject(request: PopCreateObjectProjectRequest): PopCreateObjectProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popCreateObjectProjectWithOptions(request, runtime);
}

model PopCreatePakRenderProjectRequest {
  extInfo?: string(name='ExtInfo'),
  intro?: string(name='Intro'),
  title?: string(name='Title'),
}

model PopCreatePakRenderProjectResponseBody = {
  code?: string(name='Code'),
  data?: {
    autoBuild?: boolean(name='AutoBuild'),
    bizUsage?: string(name='BizUsage'),
    checkStatus?: string(name='CheckStatus'),
    createMode?: string(name='CreateMode'),
    createTime?: string(name='CreateTime'),
    deleted?: boolean(name='Deleted'),
    dependencies?: string(name='Dependencies'),
    ext?: string(name='Ext'),
    id?: string(name='Id'),
    intro?: string(name='Intro'),
    materialCoverUrl?: string(name='MaterialCoverUrl'),
    modifiedTime?: string(name='ModifiedTime'),
    status?: string(name='Status'),
    title?: string(name='Title'),
    type?: string(name='Type'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopCreatePakRenderProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopCreatePakRenderProjectResponseBody(name='body'),
}

async function popCreatePakRenderProjectWithOptions(request: PopCreatePakRenderProjectRequest, runtime: Util.RuntimeOptions): PopCreatePakRenderProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extInfo)) {
    body['ExtInfo'] = request.extInfo;
  }
  if (!Util.isUnset(request.intro)) {
    body['Intro'] = request.intro;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopCreatePakRenderProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popCreatePakRenderProject(request: PopCreatePakRenderProjectRequest): PopCreatePakRenderProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popCreatePakRenderProjectWithOptions(request, runtime);
}

model PopCreateTextToAvatarProjectRequest {
  extInfo?: string(name='ExtInfo'),
  intro?: string(name='Intro'),
  title?: string(name='Title'),
}

model PopCreateTextToAvatarProjectResponseBody = {
  code?: string(name='Code'),
  data?: {
    autoBuild?: boolean(name='AutoBuild'),
    bizUsage?: string(name='BizUsage'),
    checkStatus?: string(name='CheckStatus'),
    createMode?: string(name='CreateMode'),
    createTime?: string(name='CreateTime'),
    deleted?: boolean(name='Deleted'),
    dependencies?: string(name='Dependencies'),
    ext?: string(name='Ext'),
    id?: string(name='Id'),
    intro?: string(name='Intro'),
    materialCoverUrl?: string(name='MaterialCoverUrl'),
    modifiedTime?: string(name='ModifiedTime'),
    status?: string(name='Status'),
    title?: string(name='Title'),
    type?: string(name='Type'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopCreateTextToAvatarProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopCreateTextToAvatarProjectResponseBody(name='body'),
}

async function popCreateTextToAvatarProjectWithOptions(request: PopCreateTextToAvatarProjectRequest, runtime: Util.RuntimeOptions): PopCreateTextToAvatarProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extInfo)) {
    body['ExtInfo'] = request.extInfo;
  }
  if (!Util.isUnset(request.intro)) {
    body['Intro'] = request.intro;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopCreateTextToAvatarProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popCreateTextToAvatarProject(request: PopCreateTextToAvatarProjectRequest): PopCreateTextToAvatarProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popCreateTextToAvatarProjectWithOptions(request, runtime);
}

model PopListFeatureToAvatarMaterialsRequest {
  current?: int32(name='Current'),
  listStatus?: string(name='ListStatus'),
  size?: int32(name='Size'),
  tags?: string(name='Tags'),
}

model PopListFeatureToAvatarMaterialsResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      checkStatus?: string(name='CheckStatus'),
      common?: boolean(name='Common'),
      coverUrl?: string(name='CoverUrl'),
      deleted?: boolean(name='Deleted'),
      ext?: string(name='Ext'),
      fileUrl?: string(name='FileUrl'),
      id?: string(name='Id'),
      intro?: string(name='Intro'),
      listStatus?: string(name='ListStatus'),
      name?: string(name='Name'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model PopListFeatureToAvatarMaterialsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopListFeatureToAvatarMaterialsResponseBody(name='body'),
}

async function popListFeatureToAvatarMaterialsWithOptions(request: PopListFeatureToAvatarMaterialsRequest, runtime: Util.RuntimeOptions): PopListFeatureToAvatarMaterialsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.listStatus)) {
    body['ListStatus'] = request.listStatus;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    body['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopListFeatureToAvatarMaterials',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popListFeatureToAvatarMaterials(request: PopListFeatureToAvatarMaterialsRequest): PopListFeatureToAvatarMaterialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return popListFeatureToAvatarMaterialsWithOptions(request, runtime);
}

model PopListFeatureToAvatarProjectRequest {
  current?: int32(name='Current'),
  size?: int32(name='Size'),
  sortField?: string(name='SortField'),
  status?: string(name='Status'),
  title?: string(name='Title'),
}

model PopListFeatureToAvatarProjectResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      bizUsage?: string(name='BizUsage'),
      buildDetail?: {
        completedTime?: string(name='CompletedTime'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorMessage?: string(name='ErrorMessage'),
        estimatedDuration?: long(name='EstimatedDuration'),
        modifiedTime?: string(name='ModifiedTime'),
        runningTime?: string(name='RunningTime'),
        status?: string(name='Status'),
        submitTime?: string(name='SubmitTime'),
      }(name='BuildDetail'),
      checkStatus?: string(name='CheckStatus'),
      createMode?: string(name='CreateMode'),
      createTime?: string(name='CreateTime'),
      dataset?: {
        buildResultUrl?: map[string]any(name='BuildResultUrl'),
        coverUrl?: string(name='CoverUrl'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        glbModelUrl?: string(name='GlbModelUrl'),
        modelUrl?: string(name='ModelUrl'),
        modifiedTime?: string(name='ModifiedTime'),
        originResultUrl?: string(name='OriginResultUrl'),
        ossKey?: string(name='OssKey'),
        policy?: {
          accessId?: string(name='AccessId'),
          dir?: string(name='Dir'),
          expire?: string(name='Expire'),
          host?: string(name='Host'),
          policy?: string(name='Policy'),
          signature?: string(name='Signature'),
        }(name='Policy'),
        poseUrl?: string(name='PoseUrl'),
        previewUrl?: string(name='PreviewUrl'),
      }(name='Dataset'),
      deleted?: boolean(name='Deleted'),
      ext?: string(name='Ext'),
      id?: string(name='Id'),
      intro?: string(name='Intro'),
      materialCoverUrl?: string(name='MaterialCoverUrl'),
      modifiedTime?: string(name='ModifiedTime'),
      status?: string(name='Status'),
      title?: string(name='Title'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model PopListFeatureToAvatarProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopListFeatureToAvatarProjectResponseBody(name='body'),
}

async function popListFeatureToAvatarProjectWithOptions(request: PopListFeatureToAvatarProjectRequest, runtime: Util.RuntimeOptions): PopListFeatureToAvatarProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.sortField)) {
    body['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopListFeatureToAvatarProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popListFeatureToAvatarProject(request: PopListFeatureToAvatarProjectRequest): PopListFeatureToAvatarProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popListFeatureToAvatarProjectWithOptions(request, runtime);
}

model PopListObjectCaseRequest {
  current?: int32(name='Current'),
  jwtToken?: string(name='JwtToken'),
  size?: int32(name='Size'),
}

model PopListObjectCaseResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      auditStatus?: string(name='AuditStatus'),
      autoBuild?: boolean(name='AutoBuild'),
      bizUsage?: string(name='BizUsage'),
      buildDetail?: {
        completedTime?: string(name='CompletedTime'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorMessage?: string(name='ErrorMessage'),
        estimatedDuration?: long(name='EstimatedDuration'),
        modifiedTime?: string(name='ModifiedTime'),
        runningTime?: string(name='RunningTime'),
        submitTime?: string(name='SubmitTime'),
      }(name='BuildDetail'),
      checkStatus?: string(name='CheckStatus'),
      createMode?: string(name='CreateMode'),
      createTime?: string(name='CreateTime'),
      customSource?: string(name='CustomSource'),
      dataset?: {
        buildResultUrl?: map[string]any(name='BuildResultUrl'),
        coverUrl?: string(name='CoverUrl'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorMessage?: string(name='ErrorMessage'),
        glbModelUrl?: string(name='GlbModelUrl'),
        modelUrl?: string(name='ModelUrl'),
        modifiedTime?: string(name='ModifiedTime'),
        originResultUrl?: string(name='OriginResultUrl'),
        ossKey?: string(name='OssKey'),
        policy?: {
          accessId?: string(name='AccessId'),
          dir?: string(name='Dir'),
          expire?: string(name='Expire'),
          host?: string(name='Host'),
          policy?: string(name='Policy'),
          signature?: string(name='Signature'),
        }(name='Policy'),
        poseUrl?: string(name='PoseUrl'),
        previewUrl?: string(name='PreviewUrl'),
      }(name='Dataset'),
      deleted?: boolean(name='Deleted'),
      dependencies?: string(name='Dependencies'),
      ext?: string(name='Ext'),
      id?: string(name='Id'),
      intro?: string(name='Intro'),
      modifiedTime?: string(name='ModifiedTime'),
      source?: {
        clothes?: [ 
          {
            coverUrl?: string(name='CoverUrl'),
            createTime?: string(name='CreateTime'),
            deleted?: boolean(name='Deleted'),
            modifiedTime?: string(name='ModifiedTime'),
            name?: string(name='Name'),
            ossKey?: string(name='OssKey'),
            type?: string(name='Type'),
          }
        ](name='Clothes'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        modifiedTime?: string(name='ModifiedTime'),
        ossKey?: string(name='OssKey'),
        policy?: {
          accessId?: string(name='AccessId'),
          dir?: string(name='Dir'),
          expire?: string(name='Expire'),
          host?: string(name='Host'),
          policy?: string(name='Policy'),
          signature?: string(name='Signature'),
        }(name='Policy'),
        sourceFiles?: [ 
          {
            coverUrl?: string(name='CoverUrl'),
            createTime?: string(name='CreateTime'),
            deleted?: boolean(name='Deleted'),
            fileName?: string(name='FileName'),
            filesize?: long(name='Filesize'),
            modifiedTime?: string(name='ModifiedTime'),
            ossKey?: string(name='OssKey'),
            type?: string(name='Type'),
            url?: string(name='Url'),
          }
        ](name='SourceFiles'),
      }(name='Source'),
      status?: string(name='Status'),
      title?: string(name='Title'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model PopListObjectCaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopListObjectCaseResponseBody(name='body'),
}

async function popListObjectCaseWithOptions(request: PopListObjectCaseRequest, runtime: Util.RuntimeOptions): PopListObjectCaseResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopListObjectCase',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popListObjectCase(request: PopListObjectCaseRequest): PopListObjectCaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return popListObjectCaseWithOptions(request, runtime);
}

model PopListObjectProjectRequest {
  auditStatus?: string(name='AuditStatus'),
  current?: int32(name='Current'),
  customSource?: string(name='CustomSource'),
  jwtToken?: string(name='JwtToken'),
  size?: int32(name='Size'),
  sortField?: string(name='SortField'),
  status?: string(name='Status'),
  title?: string(name='Title'),
  withSource?: boolean(name='WithSource'),
}

model PopListObjectProjectResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      auditStatus?: string(name='AuditStatus'),
      autoBuild?: boolean(name='AutoBuild'),
      bizUsage?: string(name='BizUsage'),
      buildDetail?: {
        completedTime?: string(name='CompletedTime'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorMessage?: string(name='ErrorMessage'),
        estimatedDuration?: long(name='EstimatedDuration'),
        modifiedTime?: string(name='ModifiedTime'),
        runningTime?: string(name='RunningTime'),
        submitTime?: string(name='SubmitTime'),
      }(name='BuildDetail'),
      checkStatus?: string(name='CheckStatus'),
      createMode?: string(name='CreateMode'),
      createTime?: string(name='CreateTime'),
      customSource?: string(name='CustomSource'),
      dataset?: {
        buildResultUrl?: map[string]any(name='BuildResultUrl'),
        coverUrl?: string(name='CoverUrl'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorMessage?: string(name='ErrorMessage'),
        glbModelUrl?: string(name='GlbModelUrl'),
        modelUrl?: string(name='ModelUrl'),
        modifiedTime?: string(name='ModifiedTime'),
        originResultUrl?: string(name='OriginResultUrl'),
        ossKey?: string(name='OssKey'),
        policy?: {
          accessId?: string(name='AccessId'),
          dir?: string(name='Dir'),
          expire?: string(name='Expire'),
          host?: string(name='Host'),
          policy?: string(name='Policy'),
          signature?: string(name='Signature'),
        }(name='Policy'),
        poseUrl?: string(name='PoseUrl'),
        previewUrl?: string(name='PreviewUrl'),
      }(name='Dataset'),
      deleted?: boolean(name='Deleted'),
      dependencies?: string(name='Dependencies'),
      ext?: string(name='Ext'),
      id?: string(name='Id'),
      intro?: string(name='Intro'),
      modifiedTime?: string(name='ModifiedTime'),
      source?: {
        clothes?: [ 
          {
            coverUrl?: string(name='CoverUrl'),
            createTime?: string(name='CreateTime'),
            deleted?: boolean(name='Deleted'),
            modifiedTime?: string(name='ModifiedTime'),
            name?: string(name='Name'),
            ossKey?: string(name='OssKey'),
            type?: string(name='Type'),
          }
        ](name='Clothes'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        modifiedTime?: string(name='ModifiedTime'),
        ossKey?: string(name='OssKey'),
        policy?: {
          accessId?: string(name='AccessId'),
          dir?: string(name='Dir'),
          expire?: string(name='Expire'),
          host?: string(name='Host'),
          policy?: string(name='Policy'),
          signature?: string(name='Signature'),
        }(name='Policy'),
        sourceFiles?: [ 
          {
            coverUrl?: string(name='CoverUrl'),
            createTime?: string(name='CreateTime'),
            deleted?: boolean(name='Deleted'),
            fileName?: string(name='FileName'),
            filesize?: long(name='Filesize'),
            modifiedTime?: string(name='ModifiedTime'),
            ossKey?: string(name='OssKey'),
            type?: string(name='Type'),
            url?: string(name='Url'),
          }
        ](name='SourceFiles'),
      }(name='Source'),
      status?: string(name='Status'),
      title?: string(name='Title'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model PopListObjectProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopListObjectProjectResponseBody(name='body'),
}

async function popListObjectProjectWithOptions(request: PopListObjectProjectRequest, runtime: Util.RuntimeOptions): PopListObjectProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.auditStatus)) {
    body['AuditStatus'] = request.auditStatus;
  }
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.customSource)) {
    body['CustomSource'] = request.customSource;
  }
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.sortField)) {
    body['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  if (!Util.isUnset(request.withSource)) {
    body['WithSource'] = request.withSource;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopListObjectProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popListObjectProject(request: PopListObjectProjectRequest): PopListObjectProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popListObjectProjectWithOptions(request, runtime);
}

model PopListTextToAvatarProjectRequest {
  current?: int32(name='Current'),
  jwtToken?: string(name='JwtToken'),
  size?: int32(name='Size'),
  sortField?: string(name='SortField'),
  status?: string(name='Status'),
  title?: string(name='Title'),
}

model PopListTextToAvatarProjectResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      autoBuild?: boolean(name='AutoBuild'),
      bizUsage?: string(name='BizUsage'),
      buildDetail?: {
        completedTime?: string(name='CompletedTime'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorMessage?: string(name='ErrorMessage'),
        estimatedDuration?: long(name='EstimatedDuration'),
        modifiedTime?: string(name='ModifiedTime'),
        runningTime?: string(name='RunningTime'),
        status?: string(name='Status'),
        submitTime?: string(name='SubmitTime'),
      }(name='BuildDetail'),
      checkStatus?: string(name='CheckStatus'),
      createMode?: string(name='CreateMode'),
      createTime?: string(name='CreateTime'),
      dataset?: {
        buildResultUrl?: map[string]any(name='BuildResultUrl'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        modifiedTime?: string(name='ModifiedTime'),
        ossKey?: string(name='OssKey'),
        policy?: {
          accessId?: string(name='AccessId'),
          dir?: string(name='Dir'),
          expire?: string(name='Expire'),
          host?: string(name='Host'),
          policy?: string(name='Policy'),
          signature?: string(name='Signature'),
        }(name='Policy'),
      }(name='Dataset'),
      deleted?: boolean(name='Deleted'),
      dependencies?: string(name='Dependencies'),
      ext?: string(name='Ext'),
      id?: string(name='Id'),
      intro?: string(name='Intro'),
      materialCoverUrl?: string(name='MaterialCoverUrl'),
      modifiedTime?: string(name='ModifiedTime'),
      status?: string(name='Status'),
      title?: string(name='Title'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model PopListTextToAvatarProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopListTextToAvatarProjectResponseBody(name='body'),
}

async function popListTextToAvatarProjectWithOptions(request: PopListTextToAvatarProjectRequest, runtime: Util.RuntimeOptions): PopListTextToAvatarProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.sortField)) {
    body['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopListTextToAvatarProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popListTextToAvatarProject(request: PopListTextToAvatarProjectRequest): PopListTextToAvatarProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popListTextToAvatarProjectWithOptions(request, runtime);
}

model PopObjectProjectDetailRequest {
  jwtToken?: string(name='JwtToken'),
  projectId?: string(name='ProjectId'),
}

model PopObjectProjectDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    autoBuild?: boolean(name='AutoBuild'),
    bizUsage?: string(name='BizUsage'),
    buildDetail?: {
      completedTime?: string(name='CompletedTime'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      errorMessage?: string(name='ErrorMessage'),
      estimatedDuration?: long(name='EstimatedDuration'),
      modifiedTime?: string(name='ModifiedTime'),
      runningTime?: string(name='RunningTime'),
      submitTime?: string(name='SubmitTime'),
    }(name='BuildDetail'),
    checkStatus?: string(name='CheckStatus'),
    createMode?: string(name='CreateMode'),
    createTime?: string(name='CreateTime'),
    dataset?: {
      buildResultUrl?: map[string]any(name='BuildResultUrl'),
      coverUrl?: string(name='CoverUrl'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      errorMessage?: string(name='ErrorMessage'),
      glbModelUrl?: string(name='GlbModelUrl'),
      modelUrl?: string(name='ModelUrl'),
      modifiedTime?: string(name='ModifiedTime'),
      originResultUrl?: string(name='OriginResultUrl'),
      ossKey?: string(name='OssKey'),
      policy?: {
        accessId?: string(name='AccessId'),
        dir?: string(name='Dir'),
        expire?: string(name='Expire'),
        host?: string(name='Host'),
        policy?: string(name='Policy'),
        signature?: string(name='Signature'),
      }(name='Policy'),
      poseUrl?: string(name='PoseUrl'),
      previewUrl?: string(name='PreviewUrl'),
    }(name='Dataset'),
    deleted?: boolean(name='Deleted'),
    dependencies?: string(name='Dependencies'),
    ext?: string(name='Ext'),
    id?: string(name='Id'),
    intro?: string(name='Intro'),
    modifiedTime?: string(name='ModifiedTime'),
    source?: {
      clothes?: [ 
        {
          coverUrl?: string(name='CoverUrl'),
          createTime?: string(name='CreateTime'),
          deleted?: boolean(name='Deleted'),
          modifiedTime?: string(name='ModifiedTime'),
          name?: string(name='Name'),
          ossKey?: string(name='OssKey'),
          type?: string(name='Type'),
        }
      ](name='Clothes'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      modifiedTime?: string(name='ModifiedTime'),
      ossKey?: string(name='OssKey'),
      policy?: {
        accessId?: string(name='AccessId'),
        dir?: string(name='Dir'),
        expire?: string(name='Expire'),
        host?: string(name='Host'),
        policy?: string(name='Policy'),
        signature?: string(name='Signature'),
      }(name='Policy'),
      sourceFiles?: [ 
        {
          coverUrl?: string(name='CoverUrl'),
          createTime?: string(name='CreateTime'),
          deleted?: boolean(name='Deleted'),
          fileName?: string(name='FileName'),
          filesize?: long(name='Filesize'),
          modifiedTime?: string(name='ModifiedTime'),
          ossKey?: string(name='OssKey'),
          type?: string(name='Type'),
          url?: string(name='Url'),
        }
      ](name='SourceFiles'),
    }(name='Source'),
    status?: string(name='Status'),
    title?: string(name='Title'),
    type?: string(name='Type'),
  }(name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopObjectProjectDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopObjectProjectDetailResponseBody(name='body'),
}

async function popObjectProjectDetailWithOptions(request: PopObjectProjectDetailRequest, runtime: Util.RuntimeOptions): PopObjectProjectDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopObjectProjectDetail',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popObjectProjectDetail(request: PopObjectProjectDetailRequest): PopObjectProjectDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return popObjectProjectDetailWithOptions(request, runtime);
}

model PopQueryAvatarProjectDetailRequest {
  projectId?: string(name='ProjectId'),
}

model PopQueryAvatarProjectDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    autoBuild?: boolean(name='AutoBuild'),
    bizUsage?: string(name='BizUsage'),
    buildDetail?: {
      completedTime?: string(name='CompletedTime'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      errorMessage?: string(name='ErrorMessage'),
      estimatedDuration?: long(name='EstimatedDuration'),
      modifiedTime?: string(name='ModifiedTime'),
      runningTime?: string(name='RunningTime'),
      status?: string(name='Status'),
      submitTime?: string(name='SubmitTime'),
    }(name='BuildDetail'),
    checkStatus?: string(name='CheckStatus'),
    createMode?: string(name='CreateMode'),
    createTime?: string(name='CreateTime'),
    dataset?: {
      buildResultUrl?: map[string]any(name='BuildResultUrl'),
      coverUrl?: string(name='CoverUrl'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      glbModelUrl?: string(name='GlbModelUrl'),
      modelUrl?: string(name='ModelUrl'),
      modifiedTime?: string(name='ModifiedTime'),
      originResultUrl?: string(name='OriginResultUrl'),
      ossKey?: string(name='OssKey'),
      poseUrl?: string(name='PoseUrl'),
      previewUrl?: string(name='PreviewUrl'),
    }(name='Dataset'),
    deleted?: boolean(name='Deleted'),
    dependencies?: string(name='Dependencies'),
    ext?: string(name='Ext'),
    id?: string(name='Id'),
    intro?: string(name='Intro'),
    materialCoverUrl?: string(name='MaterialCoverUrl'),
    modifiedTime?: string(name='ModifiedTime'),
    status?: string(name='Status'),
    title?: string(name='Title'),
    type?: string(name='Type'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopQueryAvatarProjectDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopQueryAvatarProjectDetailResponseBody(name='body'),
}

async function popQueryAvatarProjectDetailWithOptions(request: PopQueryAvatarProjectDetailRequest, runtime: Util.RuntimeOptions): PopQueryAvatarProjectDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PopQueryAvatarProjectDetail',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popQueryAvatarProjectDetail(request: PopQueryAvatarProjectDetailRequest): PopQueryAvatarProjectDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return popQueryAvatarProjectDetailWithOptions(request, runtime);
}

model PopVideoSaveSourceRequest {
  jwtToken?: string(name='JwtToken'),
  projectId?: string(name='ProjectId'),
  sourceType?: string(name='SourceType'),
}

model PopVideoSaveSourceResponseBody = {
  code?: string(name='Code'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopVideoSaveSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopVideoSaveSourceResponseBody(name='body'),
}

async function popVideoSaveSourceWithOptions(request: PopVideoSaveSourceRequest, runtime: Util.RuntimeOptions): PopVideoSaveSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopVideoSaveSource',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popVideoSaveSource(request: PopVideoSaveSourceRequest): PopVideoSaveSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return popVideoSaveSourceWithOptions(request, runtime);
}

